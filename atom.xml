<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>爱撒谎的男孩</title>
  <subtitle>一只程序猿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chenjiabing666.github.io/"/>
  <updated>2018-08-04T15:48:19.118Z</updated>
  <id>http://chenjiabing666.github.io/</id>
  
  <author>
    <name>Chenjiabing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>StringUtils的源码解析</title>
    <link href="http://chenjiabing666.github.io/2018/08/04/StringUtils%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://chenjiabing666.github.io/2018/08/04/StringUtils的源码解析/</id>
    <published>2018-08-04T15:47:46.000Z</published>
    <updated>2018-08-04T15:48:19.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="StringUtils"><a href="#StringUtils" class="headerlink" title="StringUtils"></a>StringUtils</h1><ul>
<li>spring封装的字符串工具类</li>
</ul>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><ol>
<li><code>isEmpty(Object str)</code>  ：判断当前字符串为空，如果为空返回true<ol>
<li>如果字符串为空或者是个空字符串，那么返回true</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(Object str)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> (str == <span class="keyword">null</span> || <span class="string">""</span>.equals(str));</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>hasLength(CharSequence str)</code> ： 如果字符串的长度大于0，返回true</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasLength</span><span class="params">(CharSequence str)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span>);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>hasText(String str)</code> ： 判断字符串str是否存在文本内容(不包含空字符)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * StringUtils.hasText(null) = false</div><div class="line">	 * StringUtils.hasText("") = false</div><div class="line">	 * StringUtils.hasText(" ") = false</div><div class="line">	 * StringUtils.hasText("12345") = true</div><div class="line">	 * StringUtils.hasText(" 12345 ") = true</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasText</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">    	<span class="comment">//不为空并且包含指定的str返回true</span></div><div class="line">		<span class="keyword">return</span> (hasLength(str) &amp;&amp; containsText(str));</div><div class="line">	&#125;</div><div class="line"></div><div class="line"><span class="comment">//判断当前字符串str是否存在文本内容</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">containsText</span><span class="params">(CharSequence str)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> strLen = str.length();   <span class="comment">//长度</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strLen; i++) &#123;</div><div class="line">            <span class="comment">//如果不是空白字符，说明其中有文本内容，返回true即可</span></div><div class="line">			<span class="keyword">if</span> (!Character.isWhitespace(str.charAt(i))) &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>public static boolean containsWhitespace(String str)</code> ： 判断当前字符串str是否包含空白字符</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">containsWhitespace</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">    	<span class="comment">//如果长度为0直接返回false</span></div><div class="line">		<span class="keyword">if</span> (!hasLength(str)) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">int</span> strLen = str.length();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strLen; i++) &#123;</div><div class="line">            <span class="comment">//遍历字符串，查看是否存在空白字符，存在即返回true</span></div><div class="line">			<span class="keyword">if</span> (Character.isWhitespace(str.charAt(i))) &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>public static String trimWhitespace(String str)</code> ： 去除字符串str中的空白字符</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">trimWhitespace</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (!hasLength(str)) &#123;</div><div class="line">			<span class="keyword">return</span> str;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder(str);</div><div class="line">    	<span class="comment">//去除字符串前面的空白字符</span></div><div class="line">		<span class="keyword">while</span> (sb.length() &gt; <span class="number">0</span> &amp;&amp; Character.isWhitespace(sb.charAt(<span class="number">0</span>))) &#123;</div><div class="line">			sb.deleteCharAt(<span class="number">0</span>);</div><div class="line">		&#125;</div><div class="line">    	<span class="comment">//去除字符串末尾的空白字符</span></div><div class="line">		<span class="keyword">while</span> (sb.length() &gt; <span class="number">0</span> &amp;&amp; Character.isWhitespace(sb.charAt(sb.length() - <span class="number">1</span>))) &#123;</div><div class="line">			sb.deleteCharAt(sb.length() - <span class="number">1</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> sb.toString();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>public static String trimAllWhitespace(String str)</code> ：去除字符串中所有的空白字符</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">trimAllWhitespace</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (!hasLength(str)) &#123;</div><div class="line">			<span class="keyword">return</span> str;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">int</span> len = str.length();</div><div class="line">    	<span class="comment">//使用stringBuilder存储非空白字符</span></div><div class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder(str.length());</div><div class="line">    	<span class="comment">//遍历字符串，如果不是空白字符，那么直接添加到sb中</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">			<span class="keyword">char</span> c = str.charAt(i);</div><div class="line">			<span class="keyword">if</span> (!Character.isWhitespace(c)) &#123;</div><div class="line">				sb.append(c);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> sb.toString();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>public static String trimLeadingWhitespace(String str)</code> ：去除字符串前面的空白字符</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">trimLeadingWhitespace</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (!hasLength(str)) &#123;</div><div class="line">			<span class="keyword">return</span> str;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder(str);</div><div class="line">    	<span class="comment">//只是去除前面的空白字符</span></div><div class="line">		<span class="keyword">while</span> (sb.length() &gt; <span class="number">0</span> &amp;&amp; Character.isWhitespace(sb.charAt(<span class="number">0</span>))) &#123;</div><div class="line">			sb.deleteCharAt(<span class="number">0</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> sb.toString();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>public static String trimTrailingWhitespace(String str)</code> ：去除末尾的空白字符</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">trimTrailingWhitespace</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (!hasLength(str)) &#123;</div><div class="line">			<span class="keyword">return</span> str;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder(str);</div><div class="line">    	<span class="comment">//去除末尾的</span></div><div class="line">		<span class="keyword">while</span> (sb.length() &gt; <span class="number">0</span> &amp;&amp; Character.isWhitespace(sb.charAt(sb.length() - <span class="number">1</span>))) &#123;</div><div class="line">			sb.deleteCharAt(sb.length() - <span class="number">1</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> sb.toString();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>public static String trimLeadingCharacter(String str, char leadingCharacter)</code> ：去除字符串str前面的指定字符leadingCharacter</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">trimLeadingCharacter</span><span class="params">(String str, <span class="keyword">char</span> leadingCharacter)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (!hasLength(str)) &#123;</div><div class="line">			<span class="keyword">return</span> str;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder(str);</div><div class="line">		<span class="keyword">while</span> (sb.length() &gt; <span class="number">0</span> &amp;&amp; sb.charAt(<span class="number">0</span>) == leadingCharacter) &#123;</div><div class="line">			sb.deleteCharAt(<span class="number">0</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> sb.toString();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>public static String trimTrailingCharacter(String str, char trailingCharacter)</code> ：去除字符串尾部的指定字符 trailingCharacter</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">trimTrailingCharacter</span><span class="params">(String str, <span class="keyword">char</span> trailingCharacter)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (!hasLength(str)) &#123;</div><div class="line">			<span class="keyword">return</span> str;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder(str);</div><div class="line">		<span class="keyword">while</span> (sb.length() &gt; <span class="number">0</span> &amp;&amp; sb.charAt(sb.length() - <span class="number">1</span>) == trailingCharacter) &#123;</div><div class="line">			sb.deleteCharAt(sb.length() - <span class="number">1</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> sb.toString();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>public static boolean startsWithIgnoreCase(String str, String prefix)</code> ： 测试字符串str是否是以prefix开头的，忽略大小写</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">startsWithIgnoreCase</span><span class="params">(String str, String prefix)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> (str != <span class="keyword">null</span> &amp;&amp; prefix != <span class="keyword">null</span> &amp;&amp; str.length() &gt;= prefix.length() &amp;&amp;</div><div class="line">				str.regionMatches(<span class="keyword">true</span>, <span class="number">0</span>, prefix, <span class="number">0</span>, prefix.length()));</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>public static boolean endsWithIgnoreCase(String str, String suffix)</code>：测试字符串str是否是以suffix结尾的，忽略大小写</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">endsWithIgnoreCase</span><span class="params">(String str, String suffix)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> (str != <span class="keyword">null</span> &amp;&amp; suffix != <span class="keyword">null</span> &amp;&amp; str.length() &gt;= suffix.length() &amp;&amp;</div><div class="line">			str.regionMatches(<span class="keyword">true</span>, str.length() - suffix.length(), suffix, <span class="number">0</span>, suffix.length()));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>public static boolean substringMatch(CharSequence str, int index, CharSequence substring)</code> ： 判断字符串str从index开始到结尾，是否与给定的substring相同</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">substringMatch</span><span class="params">(CharSequence str, <span class="keyword">int</span> index, CharSequence substring)</span> </span>&#123;</div><div class="line">    	<span class="comment">//如果开始的索引加上匹配的子串大小大于原本的字符串的大小，表明不匹配，返回false</span></div><div class="line">		<span class="keyword">if</span> (index + substring.length() &gt; str.length()) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line">    	<span class="comment">//逐个字符比较，一旦遇到不同的，直接返回false即可</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; substring.length(); i++) &#123;</div><div class="line">			<span class="keyword">if</span> (str.charAt(index + i) != substring.charAt(i)) &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>public static int countOccurrencesOf(String str, String sub)</code> ： 返回子串sub在str中出现的次数</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countOccurrencesOf</span><span class="params">(String str, String sub)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (!hasLength(str) || !hasLength(sub)) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">//数量</span></div><div class="line">  		<span class="keyword">int</span> pos = <span class="number">0</span>;   <span class="comment">//索引，从0开始统计</span></div><div class="line">		<span class="keyword">int</span> idx;</div><div class="line">   		<span class="comment">// str.indexOf(sub, pos) : 返回子串sub在str中从pos索引开始的下标</span></div><div class="line">		<span class="keyword">while</span> ((idx = str.indexOf(sub, pos)) != -<span class="number">1</span>) &#123;</div><div class="line">			++count;</div><div class="line">			pos = idx + sub.length();  </div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> count;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replace</span><span class="params">(String inString, String oldPattern, String newPattern)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (!hasLength(inString) || !hasLength(oldPattern) || newPattern == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">return</span> inString;</div><div class="line">		&#125;</div><div class="line">    	<span class="comment">//index</span></div><div class="line">		<span class="keyword">int</span> index = inString.indexOf(oldPattern);</div><div class="line">		<span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</div><div class="line">			<span class="comment">// no occurrence -&gt; can return input as-is</span></div><div class="line">			<span class="keyword">return</span> inString;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">int</span> capacity = inString.length();</div><div class="line">		<span class="keyword">if</span> (newPattern.length() &gt; oldPattern.length()) &#123;</div><div class="line">			capacity += <span class="number">16</span>;</div><div class="line">		&#125;</div><div class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder(capacity);</div><div class="line"></div><div class="line">		<span class="keyword">int</span> pos = <span class="number">0</span>;  <span class="comment">// our position in the old string</span></div><div class="line">		<span class="keyword">int</span> patLen = oldPattern.length();</div><div class="line">		<span class="keyword">while</span> (index &gt;= <span class="number">0</span>) &#123;</div><div class="line">			sb.append(inString.substring(pos, index));</div><div class="line">			sb.append(newPattern);</div><div class="line">			pos = index + patLen;</div><div class="line">			index = inString.indexOf(oldPattern, pos);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// append any characters to the right of a match</span></div><div class="line">		sb.append(inString.substring(pos));</div><div class="line">		<span class="keyword">return</span> sb.toString();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>public static String replace(String inString, String oldPattern, String newPattern)</code> ：将字符串inString中的oldPattern全部替换成newPattern</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replace</span><span class="params">(String inString, String oldPattern, String newPattern)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (!hasLength(inString) || !hasLength(oldPattern) || newPattern == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">return</span> inString;</div><div class="line">		&#125;</div><div class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">		<span class="keyword">int</span> pos = <span class="number">0</span>; <span class="comment">// our position in the old string</span></div><div class="line">		<span class="keyword">int</span> index = inString.indexOf(oldPattern);   <span class="comment">//获取oldpattern在instring中的开始索引</span></div><div class="line">		<span class="comment">// the index of an occurrence we've found, or -1</span></div><div class="line">		<span class="keyword">int</span> patLen = oldPattern.length(); </div><div class="line">    	<span class="comment">//遍历字符串，替换</span></div><div class="line">		<span class="keyword">while</span> (index &gt;= <span class="number">0</span>) &#123;</div><div class="line">			sb.append(inString.substring(pos, index));</div><div class="line">			sb.append(newPattern);</div><div class="line">			pos = index + patLen;</div><div class="line">			index = inString.indexOf(oldPattern, pos);</div><div class="line">		&#125;</div><div class="line">		sb.append(inString.substring(pos));</div><div class="line">		<span class="comment">// remember to append any characters to the right of a match</span></div><div class="line">		<span class="keyword">return</span> sb.toString();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>public static String delete(String inString, String pattern)</code> ： 删除字符串inString中指定的pattern内容</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">delete</span><span class="params">(String inString, String pattern)</span> </span>&#123;</div><div class="line">    	<span class="comment">//使用空字符替换删除的pattern</span></div><div class="line">		<span class="keyword">return</span> replace(inString, pattern, <span class="string">""</span>);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>public static String deleteAny(String inString, String charsToDelete)</code> ：删除字符串inString中指定的charsToDelete所有字符</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">deleteAny</span><span class="params">(String inString, String charsToDelete)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (!hasLength(inString) || !hasLength(charsToDelete)) &#123;</div><div class="line">			<span class="keyword">return</span> inString;</div><div class="line">		&#125;</div><div class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">    	<span class="comment">//遍历字符串</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inString.length(); i++) &#123;</div><div class="line">			<span class="keyword">char</span> c = inString.charAt(i);   <span class="comment">//获取当前的字符</span></div><div class="line">            <span class="comment">//如果当前的字符不在需要删除的charsToDelete中，那么添加到sb中</span></div><div class="line">			<span class="keyword">if</span> (charsToDelete.indexOf(c) == -<span class="number">1</span>) &#123;</div><div class="line">				sb.append(c);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> sb.toString();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>public static String quote(String str)</code> ：将字符串用单引号括起来</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">quote</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> (str != <span class="keyword">null</span> ? <span class="string">"'"</span> + str + <span class="string">"'"</span> : <span class="keyword">null</span>);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>public static String uncapitalize(String str)</code> ：首字母小写</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">uncapitalize</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> changeFirstCharacterCase(str, <span class="keyword">false</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">changeFirstCharacterCase</span><span class="params">(String str, <span class="keyword">boolean</span> capitalize)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">return</span> str;</div><div class="line">		&#125;</div><div class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder(str.length());</div><div class="line">		<span class="keyword">if</span> (capitalize) &#123;</div><div class="line">			sb.append(Character.toUpperCase(str.charAt(<span class="number">0</span>)));</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			sb.append(Character.toLowerCase(str.charAt(<span class="number">0</span>)));</div><div class="line">		&#125;</div><div class="line">		sb.append(str.substring(<span class="number">1</span>));</div><div class="line">		<span class="keyword">return</span> sb.toString();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>public static String capitalize(String str)</code> ： 首字母大写</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">capitalize</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> changeFirstCharacterCase(str, <span class="keyword">true</span>);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>public static String getFilename(String path)</code> ： 取出给定的路径path中的文件名，比如<code>/tmp/file.txt</code>，那么取出的文件名为file.txt</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getFilename</span><span class="params">(String path)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);</div><div class="line">		<span class="keyword">return</span> (separatorIndex != -<span class="number">1</span> ? path.substring(separatorIndex + <span class="number">1</span>) : path);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>public static String getFilenameExtension(String path)</code> ：获取给定路径的文件扩展名，比如<code>/tmp/file.txt</code>，那么返回的扩展名为txt</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getFilenameExtension</span><span class="params">(String path)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);   <span class="comment">//获取最后一个.的索引</span></div><div class="line">		<span class="keyword">if</span> (extIndex == -<span class="number">1</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);  <span class="comment">//获取最后一个/的索引</span></div><div class="line">		<span class="keyword">if</span> (folderIndex &gt; extIndex) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> path.substring(extIndex + <span class="number">1</span>);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>public static String stripFilenameExtension(String path)</code>：去掉给定路径的文件扩展名，比如：<code>&quot;mypath/myfile.txt&quot; -&gt; &quot;mypath/myfile&quot;.</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * Strip the filename extension from the given path,</div><div class="line">	 * e.g. "mypath/myfile.txt" -&gt; "mypath/myfile".</div><div class="line">	 * <span class="doctag">@param</span> path the file path (may be &#123;<span class="doctag">@code</span> null&#125;)</div><div class="line">	 * <span class="doctag">@return</span> the path with stripped filename extension,</div><div class="line">	 * or &#123;<span class="doctag">@code</span> null&#125; if none</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">stripFilenameExtension</span><span class="params">(String path)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);</div><div class="line">		<span class="keyword">if</span> (extIndex == -<span class="number">1</span>) &#123;</div><div class="line">			<span class="keyword">return</span> path;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);</div><div class="line">		<span class="keyword">if</span> (folderIndex &gt; extIndex) &#123;</div><div class="line">			<span class="keyword">return</span> path;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> path.substring(<span class="number">0</span>, extIndex);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>public static String[] delimitedListToStringArray(String str, String delimiter)</code> ：已指定的分隔符将字符串str分割成一个字符串数组，比如<code>String[] strs=StringUtils.delimitedListToStringArray(&quot;chenjia,bing&quot;, &quot;,&quot;);</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> String[] delimitedListToStringArray(String str, String delimiter) &#123;</div><div class="line">		<span class="keyword">return</span> delimitedListToStringArray(str, delimiter, <span class="keyword">null</span>);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete)</code> ： 不但使用分割符将字符串分割成数组，并且还去掉了字符串中的指定的字符，比如：<code>String[] strs=StringUtils.delimitedListToStringArray(&quot;chenjia,bing&quot;, &quot;,&quot;,&quot;n&quot;);</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) &#123;</div><div class="line">		<span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> String[<span class="number">0</span>];</div><div class="line">		&#125;</div><div class="line">    	<span class="comment">//没有分隔符直接返回原来字符串</span></div><div class="line">		<span class="keyword">if</span> (delimiter == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;str&#125;;</div><div class="line">		&#125;</div><div class="line">		List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">    	<span class="comment">//如果分隔符为空，那么每一个字符都要分割</span></div><div class="line">		<span class="keyword">if</span> (<span class="string">""</span>.equals(delimiter)) &#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</div><div class="line">                <span class="comment">//删除指定的字符，并且添加到restult中</span></div><div class="line">				result.add(deleteAny(str.substring(i, i + <span class="number">1</span>), charsToDelete));</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;  <span class="comment">//分割符不为空，并且不是空字符串</span></div><div class="line">			<span class="keyword">int</span> pos = <span class="number">0</span>;  </div><div class="line">			<span class="keyword">int</span> delPos;   <span class="comment">//定义需要进行删除的字符串的最后一个index</span></div><div class="line">            <span class="comment">//str.indexOf(delimiter, pos) : 从pos位置开始，获取分割符的索引，此时的 [pos,delpos]就是一个分割的字符串，那么我们需要对其删除指定的字符</span></div><div class="line">			<span class="keyword">while</span> ((delPos = str.indexOf(delimiter, pos)) != -<span class="number">1</span>) &#123;</div><div class="line">                <span class="comment">//删除一个子串中的指定字符，并且添加到result中</span></div><div class="line">				result.add(deleteAny(str.substring(pos, delPos), charsToDelete));</div><div class="line">				pos = delPos + delimiter.length();  <span class="comment">//pos后移，移到下一个需要分割的字符串，也就是剩下的字符串</span></div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (str.length() &gt; <span class="number">0</span> &amp;&amp; pos &lt;= str.length()) &#123;</div><div class="line">				<span class="comment">// Add rest of String, but not in case of empty input.</span></div><div class="line">				result.add(deleteAny(str.substring(pos), charsToDelete));</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> toStringArray(result);   <span class="comment">//将List转换成字符串数组</span></div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>public static String[] toStringArray(Collection&lt;String&gt; collection)</code> ： 将指定的String类型的集合转换成String[]</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> String[] toStringArray(Collection&lt;String&gt; collection) &#123;</div><div class="line">		<span class="keyword">if</span> (collection == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">    	<span class="comment">//调用Collection中的toArray(T[] a)方法,需要指定数组的容量</span></div><div class="line">		<span class="keyword">return</span> collection.toArray(<span class="keyword">new</span> String[collection.size()]);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>public static String[] sortStringArray(String[] array)</code> ：对String[] 数组进行排序</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> String[] sortStringArray(String[] array) &#123;</div><div class="line">    	<span class="comment">//判断数组是否为空，这里的 org.springframework.util.ObjectUtils，也是一个工具类</span></div><div class="line">		<span class="keyword">if</span> (ObjectUtils.isEmpty(array)) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> String[<span class="number">0</span>];</div><div class="line">		&#125;</div><div class="line">		Arrays.sort(array);   <span class="comment">//使用Arrays的排序，升序</span></div><div class="line">		<span class="keyword">return</span> array;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>public static String[] trimArrayElements(String[] array)</code> ： 将给定的字符串数组中的每一个字符串都去掉前后空格</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> String[] trimArrayElements(String[] array) &#123;</div><div class="line">		<span class="keyword">if</span> (ObjectUtils.isEmpty(array)) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> String[<span class="number">0</span>];</div><div class="line">		&#125;</div><div class="line">    	<span class="comment">//创建一个新数组保存</span></div><div class="line">		String[] result = <span class="keyword">new</span> String[array.length];</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</div><div class="line">			String element = array[i];</div><div class="line">			result[i] = (element != <span class="keyword">null</span> ? element.trim() : <span class="keyword">null</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> result;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>public static String[] removeDuplicateStrings(String[] array)</code> ： 去掉字符串数组中重复的字符串</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> String[] removeDuplicateStrings(String[] array) &#123;</div><div class="line">		<span class="keyword">if</span> (ObjectUtils.isEmpty(array)) &#123;</div><div class="line">			<span class="keyword">return</span> array;</div><div class="line">		&#125;</div><div class="line">    	<span class="comment">//使用集合set来去掉重复的元素</span></div><div class="line">		Set&lt;String&gt; set = <span class="keyword">new</span> TreeSet&lt;String&gt;();</div><div class="line">		<span class="keyword">for</span> (String element : array) &#123;</div><div class="line">			set.add(element);</div><div class="line">		&#125;</div><div class="line">    	<span class="comment">//将集合转换成String[]</span></div><div class="line">		<span class="keyword">return</span> toStringArray(set);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>public static String[] split(String toSplit, String delimiter)</code>  ： 以分隔符分割字符串成两个数组，但是这个只是分割第一个分割符</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> String[] split(String toSplit, String delimiter) &#123;</div><div class="line">		<span class="keyword">if</span> (!hasLength(toSplit) || !hasLength(delimiter)) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> offset = toSplit.indexOf(delimiter);</div><div class="line">		<span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">		String beforeDelimiter = toSplit.substring(<span class="number">0</span>, offset);</div><div class="line">		String afterDelimiter = toSplit.substring(offset + delimiter.length());</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;beforeDelimiter, afterDelimiter&#125;;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>public static String arrayToDelimitedString(Object[] arr, String delim)</code> ： 将数组中的每一元素以分割符组成对应的字符串</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">arrayToDelimitedString</span><span class="params">(Object[] arr, String delim)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (ObjectUtils.isEmpty(arr)) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (arr.length == <span class="number">1</span>) &#123;</div><div class="line">			<span class="keyword">return</span> ObjectUtils.nullSafeToString(arr[<span class="number">0</span>]);</div><div class="line">		&#125;</div><div class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">			<span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</div><div class="line">				sb.append(delim);</div><div class="line">			&#125;</div><div class="line">			sb.append(arr[i]);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> sb.toString();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ol>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">cleanPath</span><span class="params">(String path)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">    	<span class="comment">//将path中的\\全部替换成/</span></div><div class="line">    <span class="comment">//如果这个路径是在windows下，如 c:\\image\\file.jpg,那么经过replace，将会变成 c://image//file.jpg</span></div><div class="line">		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR);</div><div class="line">    	<span class="comment">//获取pathToUse中:的索引</span></div><div class="line">		<span class="keyword">int</span> prefixIndex = pathToUse.indexOf(<span class="string">":"</span>);</div><div class="line">		String prefix = <span class="string">""</span>;   <span class="comment">//前缀，比如  c: 或者 /</span></div><div class="line">    <span class="comment">//如果这个路径是在windows下，如 c:\\image\\file.jpg,那么经过replace，将会变成 c://image//file.jpg</span></div><div class="line">		<span class="keyword">if</span> (prefixIndex != -<span class="number">1</span>) &#123;</div><div class="line">			prefix = pathToUse.substring(<span class="number">0</span>, prefixIndex + <span class="number">1</span>);  <span class="comment">//前缀变成 `c:`</span></div><div class="line">			pathToUse = pathToUse.substring(prefixIndex + <span class="number">1</span>);  <span class="comment">//去掉前面的前缀</span></div><div class="line">		&#125;</div><div class="line">    	<span class="comment">//如果pathToUse是以/开头，表示是linux下的路径</span></div><div class="line">		<span class="keyword">if</span> (pathToUse.startsWith(FOLDER_SEPARATOR)) &#123;</div><div class="line">			prefix = prefix + FOLDER_SEPARATOR;   <span class="comment">//前缀就是  /</span></div><div class="line">			pathToUse = pathToUse.substring(<span class="number">1</span>);   <span class="comment">//pathToUse就变成了去掉/之后的字符串</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">//将pathToUse使用/分割成一个字符串数组，比如pathToUse=home/chenjiabinbg/file.txt，那么数组为 ["home","chenjiabing","file.txt"]</span></div><div class="line">		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR);</div><div class="line">    </div><div class="line">		List&lt;String&gt; pathElements = <span class="keyword">new</span> LinkedList&lt;String&gt;();</div><div class="line">		<span class="keyword">int</span> tops = <span class="number">0</span>;</div><div class="line">		</div><div class="line">    	<span class="comment">//遍历数组</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = pathArray.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">			String element = pathArray[i];</div><div class="line">            <span class="comment">//如果这个元素是表示当前路径的   .表示当前路径，..表示上一级路径</span></div><div class="line">			<span class="keyword">if</span> (CURRENT_PATH.equals(element)) &#123;</div><div class="line">				<span class="comment">// Points to current directory - drop it.</span></div><div class="line">			&#125;</div><div class="line">            <span class="comment">//如果是上一级路径，tops+1</span></div><div class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (TOP_PATH.equals(element)) &#123;</div><div class="line">				<span class="comment">// Registering top path found.</span></div><div class="line">				tops++;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				<span class="keyword">if</span> (tops &gt; <span class="number">0</span>) &#123;</div><div class="line">					<span class="comment">// Merging path element with element corresponding to top path.</span></div><div class="line">					tops--;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span> &#123;</div><div class="line">					<span class="comment">// Normal path element found.</span></div><div class="line">					pathElements.add(<span class="number">0</span>, element);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// Remaining top paths need to be retained.</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tops; i++) &#123;</div><div class="line">			pathElements.add(<span class="number">0</span>, TOP_PATH);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;StringUtils&quot;&gt;&lt;a href=&quot;#StringUtils&quot; class=&quot;headerlink&quot; title=&quot;StringUtils&quot;&gt;&lt;/a&gt;StringUtils&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;spring封装的字符串工具类&lt;/li&gt;
&lt;/ul&gt;
&lt;
    
    </summary>
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>spring整合Log4j</title>
    <link href="http://chenjiabing666.github.io/2018/08/04/spring%E6%95%B4%E5%90%88Log4j/"/>
    <id>http://chenjiabing666.github.io/2018/08/04/spring整合Log4j/</id>
    <published>2018-08-04T15:46:43.000Z</published>
    <updated>2018-08-04T15:47:02.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring使用Log4j"><a href="#spring使用Log4j" class="headerlink" title="spring使用Log4j"></a>spring使用Log4j</h1><h2 id="常用日志框架介绍"><a href="#常用日志框架介绍" class="headerlink" title="常用日志框架介绍"></a>常用日志框架介绍</h2><ul>
<li><p>转载自<a href="https://blog.csdn.net/liupeifeng3514/article/details/79624446" target="_blank" rel="external">https://blog.csdn.net/liupeifeng3514/article/details/79624446</a></p>
</li>
<li><p><strong>Log4j</strong> Apache Log4j是一个基于Java的日志记录工具。它是由Ceki Gülcü首创的，现在则是Apache软件基金会的一个项目。 Log4j是几种Java日志框架之一；</p>
</li>
<li><strong>Log4j 2</strong> Apache Log4j 2是apache开发的一款Log4j的升级产品；</li>
<li><strong>Commons Logging</strong> Apache基金会所属的项目，是一套Java日志接口，之前叫Jakarta Commons Logging，后更名为Commons Logging；</li>
<li><strong>Slf4j</strong> 类似于Commons Logging，是一套简易Java日志门面，本身并无日志的实现。（Simple Logging Facade for Java，缩写Slf4j）；</li>
<li><strong>Logback</strong> 一套日志组件的实现（slf4j阵营）；</li>
<li><strong>Jul</strong> （Java Util Logging）,自Java1.4以来的官方日志实现。</li>
</ul>
<h2 id="日志切换"><a href="#日志切换" class="headerlink" title="日志切换"></a>日志切换</h2><ul>
<li>springBoot处切换</li>
</ul>
<h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h2><h3 id="日志的输出级别的设置"><a href="#日志的输出级别的设置" class="headerlink" title="日志的输出级别的设置"></a>日志的输出级别的设置</h3><p>​    1、<strong>OFF</strong>  - <strong>FATAL</strong>  - <strong>WARN</strong>  - <strong>INFO</strong>  - <strong>DEBUG</strong>  - <strong>TRACE</strong>  - <strong>ALL</strong>  </p>
<p>​    2、Log4j建议只使用四个级别，优先级从高到低分别是ERROR、WARN、INFO、DEBUG。通过在这里定义的级别，您可以控制到应用程序中相应级别的日志信息的开关。  比如在这里定义了INFO级别，则应用程序中所有DEBUG级别的日志信息将不被打印出来。  程序会打印高于或等于所设置级别的日志，设置的日志等级越高，打印出来的日志就越少。  如果设置级别为INFO，则优先级高于等于INFO级别（如：INFO、WARN、  ERROR）的日志信息将可以被输出,小于该级别的如DEBUG将不会被输出。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">## level：设定日志记录的最低级别，可设的值有OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者自定义的级别，Log4j建议只使用中间四个级别。通过在这里设定级别，您可以控制应用程序中相应级别的日志信息的开关，比如在这里设定了INFO级别，则应用程序中所有DEBUG级别的日志信息将不会被打印出来。</div><div class="line"></div><div class="line">## appenderName：就是指定日志信息要输出到哪里。可以同时指定多个输出目的地，用逗号隔开。例如：log4j.rootLogger＝INFO,A1,B2,C3</div><div class="line">log4j.rootLogger=[level],appenderName1,appenderName2</div></pre></td></tr></table></figure>
<h3 id="配置日志的输出地"><a href="#配置日志的输出地" class="headerlink" title="配置日志的输出地"></a>配置日志的输出地</h3><p>​    1、<strong>appenderName</strong>：自定义appderName，在log4j.rootLogger设置中使用；</p>
<p>​    2、<strong>className</strong>：可设值如下： </p>
<p>​        (1) <strong>org.apache.log4j.ConsoleAppender</strong>（控制台）</p>
<p>​        (2) <strong>org.apache.log4j.FileAppender</strong>（文件）</p>
<p>​        (3) <strong>org.apache.log4j.DailyRollingFileAppender</strong>（每天产生一个日志文件）</p>
<p>​        (4) <strong>org.apache.log4j.RollingFileAppender</strong>（文件大小到达指定尺寸的时候产生一个新的文件）</p>
<p>​        (5) <strong>org.apache.log4j.WriterAppender</strong>（将日志信息以流格式发送到任意指定的地方）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">log4j.appender.appenderName = className</div></pre></td></tr></table></figure>
<p>(1) ConsoleAppender选项：</p>
<ul>
<li>Threshold=WARN：指定日志信息的最低输出级别，默认为DEBUG。</li>
<li>ImmediateFlush=true：表示所有消息都会被立即输出，设为false则不输出，默认值是true。</li>
<li>Target=System.err：默认值是System.out。</li>
</ul>
<p>(2 )FileAppender选项：</p>
<ul>
<li>Threshold=WARN：指定日志信息的最低输出级别，默认为DEBUG。</li>
<li>ImmediateFlush=true：表示所有消息都会被立即输出，设为false则不输出，默认值是true。</li>
<li>Append=false：true表示消息增加到指定文件中，false则将消息覆盖指定的文件内容，默认值是true。</li>
<li>File=D:/logs/logging.log4j：指定消息输出到logging.log4j文件中。</li>
</ul>
<p>(3) DailyRollingFileAppender选项：</p>
<ul>
<li>Threshold=WARN：指定日志信息的最低输出级别，默认为DEBUG。</li>
<li>ImmediateFlush=true：表示所有消息都会被立即输出，设为false则不输出，默认值是true。</li>
<li>Append=false：true表示消息增加到指定文件中，false则将消息覆盖指定的文件内容，默认值是true。</li>
<li>File=D:/logs/logging.log4j：指定当前消息输出到logging.log4j文件中。</li>
<li>DatePattern=’.’yyyy-MM：每月滚动一次日志文件，即每月产生一个新的日志文件。当前月的日志文件名为logging.log4j，前一个月的日志文件名为logging.log4j.yyyy-MM。<br>另外，也可以指定按周、天、时、分等来滚动日志文件，对应的格式如下： <ul>
<li>1)’.’yyyy-MM：每月</li>
<li>2)’.’yyyy-ww：每周</li>
<li>3)’.’yyyy-MM-dd：每天</li>
<li>4)’.’yyyy-MM-dd-a：每天两次</li>
<li>5)’.’yyyy-MM-dd-HH：每小时</li>
<li>6)’.’yyyy-MM-dd-HH-mm：每分钟</li>
</ul>
</li>
</ul>
<p>(4) RollingFileAppender选项：</p>
<ul>
<li>Threshold=WARN：指定日志信息的最低输出级别，默认为DEBUG。</li>
<li>ImmediateFlush=true：表示所有消息都会被立即输出，设为false则不输出，默认值是true。</li>
<li>Append=false：true表示消息增加到指定文件中，false则将消息覆盖指定的文件内容，默认值是true。</li>
<li>File=D:/logs/logging.log4j：指定消息输出到logging.log4j文件中。</li>
<li>MaxFileSize=100KB：后缀可以是KB, MB或者GB。在日志文件到达该大小时，将会自动滚动，即将原来的内容移到logging.log4j.1文件中。</li>
<li>MaxBackupIndex=2：指定可以产生的滚动文件的最大数，例如，设为2则可以产生logging.log4j.1，logging.log4j.2两个滚动文件和一个logging.log4j文件。</li>
</ul>
<h3 id="配置日志信息的输出格式（Layout）"><a href="#配置日志信息的输出格式（Layout）" class="headerlink" title="配置日志信息的输出格式（Layout）"></a>配置日志信息的输出格式（Layout）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">log4j.appender.appenderName.layout=className</div></pre></td></tr></table></figure>
<p><strong>className</strong>：可设值如下：</p>
<ul>
<li>(1)org.apache.log4j.HTMLLayout（以HTML表格形式布局）</li>
<li>(2)org.apache.log4j.PatternLayout（可以灵活地指定布局模式）</li>
<li>(3)org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）</li>
<li>(4)org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）</li>
</ul>
<p><strong>(1) HTMLLayout选项：</strong></p>
<ul>
<li>LocationInfo=true：输出java文件名称和行号，默认值是false。</li>
<li>Title=My Logging： 默认值是Log4J Log Messages。</li>
</ul>
<p><strong>(2)PatternLayout选项：</strong></p>
<ul>
<li>ConversionPattern=%m%n：设定以怎样的格式显示消息。</li>
<li>格式说明如下</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">%p：输出日志信息的优先级，即DEBUG，INFO，WARN，ERROR，FATAL。</div><div class="line">%d：输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，如：%d&#123;yyyy/MM/dd HH:mm:ss,SSS&#125;。</div><div class="line">%r：输出自应用程序启动到输出该log信息耗费的毫秒数。</div><div class="line">%t：输出产生该日志事件的线程名。</div><div class="line">%l：输出日志事件的发生位置，相当于%c.%M(%F:%L)的组合，包括类全名、方法、文件名以及在代码中的行数。例如：test.TestLog4j.main(TestLog4j.java:10)。</div><div class="line">%c：输出日志信息所属的类目，通常就是所在类的全名。</div><div class="line">%M：输出产生日志信息的方法名。</div><div class="line">%F：输出日志消息产生时所在的文件名称。</div><div class="line">%L：输出代码中的行号。</div><div class="line">%m：输出代码中指定的具体日志信息。</div><div class="line">%n：输出一个回车换行符，Windows平台为"rn"，Unix平台为"n"。</div><div class="line">%x：输出和当前线程相关联的NDC(嵌套诊断环境)，尤其用到像java servlets这样的多客户多线程的应用中。</div><div class="line">%%：输出一个"%"字符。</div><div class="line"></div><div class="line">另外，还可以在%与格式字符之间加上修饰符来控制其最小长度、最大长度、和文本的对齐方式。如：</div><div class="line">1) c：指定输出category的名称，最小的长度是20，如果category的名称长度小于20的话，默认的情况下右对齐。</div><div class="line">2) %-20c："-"号表示左对齐。</div><div class="line">3) %.30c：指定输出category的名称，最大的长度是30，如果category的名称长度大于30的话，就会将左边多出的字符截掉，但小于30的话也不会补空格。</div></pre></td></tr></table></figure>
<h3 id="Log4j比较全面的配置"><a href="#Log4j比较全面的配置" class="headerlink" title="Log4j比较全面的配置"></a>Log4j比较全面的配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">log4j.rootLogger=DEBUG,console,dailyFile,im</div><div class="line">log4j.additivity.org.apache=true</div><div class="line"># 控制台(console)</div><div class="line">log4j.appender.console=org.apache.log4j.ConsoleAppender</div><div class="line">log4j.appender.console.Threshold=DEBUG</div><div class="line">log4j.appender.console.ImmediateFlush=true</div><div class="line">log4j.appender.console.Target=System.err</div><div class="line">log4j.appender.console.layout=org.apache.log4j.PatternLayout</div><div class="line">log4j.appender.console.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n</div><div class="line"></div><div class="line"># 日志文件(logFile)</div><div class="line">log4j.appender.logFile=org.apache.log4j.FileAppender</div><div class="line">log4j.appender.logFile.Threshold=DEBUG</div><div class="line">log4j.appender.logFile.ImmediateFlush=true</div><div class="line">log4j.appender.logFile.Append=true</div><div class="line">log4j.appender.logFile.File=D:/logs/log.log4j</div><div class="line">log4j.appender.logFile.layout=org.apache.log4j.PatternLayout</div><div class="line">log4j.appender.logFile.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n</div><div class="line"># 回滚文件(rollingFile)</div><div class="line">log4j.appender.rollingFile=org.apache.log4j.RollingFileAppender</div><div class="line">log4j.appender.rollingFile.Threshold=DEBUG</div><div class="line">log4j.appender.rollingFile.ImmediateFlush=true</div><div class="line">log4j.appender.rollingFile.Append=true</div><div class="line">log4j.appender.rollingFile.File=D:/logs/log.log4j</div><div class="line">log4j.appender.rollingFile.MaxFileSize=200KB</div><div class="line">log4j.appender.rollingFile.MaxBackupIndex=50</div><div class="line">log4j.appender.rollingFile.layout=org.apache.log4j.PatternLayout</div><div class="line">log4j.appender.rollingFile.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n</div><div class="line"># 定期回滚日志文件(dailyFile)</div><div class="line">log4j.appender.dailyFile=org.apache.log4j.DailyRollingFileAppender</div><div class="line">log4j.appender.dailyFile.Threshold=DEBUG</div><div class="line">log4j.appender.dailyFile.ImmediateFlush=true</div><div class="line">log4j.appender.dailyFile.Append=true</div><div class="line">log4j.appender.dailyFile.File=D:/logs/log.log4j</div><div class="line">log4j.appender.dailyFile.DatePattern=&apos;.&apos;yyyy-MM-dd</div><div class="line">log4j.appender.dailyFile.layout=org.apache.log4j.PatternLayout</div><div class="line">log4j.appender.dailyFile.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n</div><div class="line"># 应用于socket</div><div class="line">log4j.appender.socket=org.apache.log4j.RollingFileAppender</div><div class="line">log4j.appender.socket.RemoteHost=localhost</div><div class="line">log4j.appender.socket.Port=5001</div><div class="line">log4j.appender.socket.LocationInfo=true</div><div class="line"># Set up for Log Factor 5</div><div class="line">log4j.appender.socket.layout=org.apache.log4j.PatternLayout</div><div class="line">log4j.appender.socket.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n</div><div class="line"># Log Factor 5 Appender</div><div class="line">log4j.appender.LF5_APPENDER=org.apache.log4j.lf5.LF5Appender</div><div class="line">log4j.appender.LF5_APPENDER.MaxNumberOfRecords=2000</div><div class="line"># 发送日志到指定邮件</div><div class="line">log4j.appender.mail=org.apache.log4j.net.SMTPAppender</div><div class="line">log4j.appender.mail.Threshold=FATAL</div><div class="line">log4j.appender.mail.BufferSize=10</div><div class="line">log4j.appender.mail.From = xxx@mail.com</div><div class="line">log4j.appender.mail.SMTPHost=mail.com</div><div class="line">log4j.appender.mail.Subject=Log4J Message</div><div class="line">log4j.appender.mail.To= xxx@mail.com</div><div class="line">log4j.appender.mail.layout=org.apache.log4j.PatternLayout</div><div class="line">log4j.appender.mail.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n</div><div class="line"># 应用于数据库</div><div class="line">log4j.appender.database=org.apache.log4j.jdbc.JDBCAppender</div><div class="line">log4j.appender.database.URL=jdbc:mysql://localhost:3306/test</div><div class="line">log4j.appender.database.driver=com.mysql.jdbc.Driver</div><div class="line">log4j.appender.database.user=root</div><div class="line">log4j.appender.database.password=</div><div class="line">log4j.appender.database.sql=INSERT INTO LOG4J (Message) VALUES(&apos;=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n&apos;)</div><div class="line">log4j.appender.database.layout=org.apache.log4j.PatternLayout</div><div class="line">log4j.appender.database.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n</div><div class="line"></div><div class="line"># 自定义Appender</div><div class="line">log4j.appender.im = net.cybercorlin.util.logger.appender.IMAppender</div><div class="line">log4j.appender.im.host = mail.cybercorlin.net</div><div class="line">log4j.appender.im.username = username</div><div class="line">log4j.appender.im.password = password</div><div class="line">log4j.appender.im.recipient = corlin@cybercorlin.net</div><div class="line">log4j.appender.im.layout=org.apache.log4j.PatternLayout</div><div class="line">log4j.appender.im.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n</div></pre></td></tr></table></figure>
<h2 id="Spring使用Log4j日志框架"><a href="#Spring使用Log4j日志框架" class="headerlink" title="Spring使用Log4j日志框架"></a>Spring使用Log4j日志框架</h2><p>1、log4j框架指定日志输出文件只能使用绝对路径，但是我们的项目是跟着系统走的，因此我们需要将日志存放在项目的路径中，这样就需要获取到当前项目的路径，这里只需要在web.xml中添加一个Log4j的监听器即可实现，如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 设置根目录,必须每个项目的值都不相同，否则将会发生冲突如果一个tomcat部署多个项目的话 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">context-param</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>webAppRootKey<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>lifecrystal.root<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></div><div class="line">	</div><div class="line">	<span class="comment">&lt;!-- 指定log4j配置文件的位置，项目路径下 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">context-param</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>log4jConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:log4j.properties<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></div><div class="line">	</div><div class="line">	<span class="comment">&lt;!-- 3000表示 开一条watchdog线程每60秒扫描一下配置文件的变化;这样便于日志存放位置的改变 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">context-param</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>log4jRefreshInterval<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>3000<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></div><div class="line">	</div><div class="line">	<span class="comment">&lt;!-- 1、log4j监听器，将webAppRootKey设置的值加载到系统参数中，这样就可以在配置文件中引用项目的路径</span></div><div class="line">		 2、项目运行期间，每次改变配置文件中的值都会被监听到</div><div class="line">	 --&gt;</div><div class="line">	<span class="tag">&lt;<span class="name">listener</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.util.Log4jConfigListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">listener</span>&gt;</span></div></pre></td></tr></table></figure>
<p>2、此时我们就可以在log4j.properties中使用<code>${lifecrystal.root}</code>获取到项目的路径，实际使用的就是<strong>System.getProperty()</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">#LOG 输出级别和输出的地方，分别为Console和File，这里到值可以随意改变，但是在下文一定要和这里的一样</div><div class="line">log4j.rootLogger=DEBUG,Console,File</div><div class="line"></div><div class="line">#################################输出到控制台，级别为DEBUG#############################################</div><div class="line">#输出目的地方为控制台</div><div class="line">log4j.appender.Console=org.apache.log4j.ConsoleAppender</div><div class="line">## 以system.out的格式输出，黑色的</div><div class="line">log4j.appender.Console.Target=System.out</div><div class="line">## 只有在DEBUG的模式下才会在控制台输出</div><div class="line">log4j.appender.console.Threshold=DEBUG</div><div class="line">#在控制台输出的格式  </div><div class="line">log4j.appender.Console.layout = org.apache.log4j.PatternLayout</div><div class="line">log4j.appender.Console.layout.ConversionPattern=[%p]:[%c]:[%d&#123;yyyy/MM/dd HH:mm:ss&#125;] - %m%n</div><div class="line"></div><div class="line"></div><div class="line">#################################输出到文件中，级别为DEBUG#############################################</div><div class="line"></div><div class="line">#文件大小到一定尺寸产生一个新文件</div><div class="line">log4j.appender.File = org.apache.log4j.RollingFileAppender</div><div class="line">#指定输出目录</div><div class="line">log4j.appender.File.File = $&#123;lifecrystal.root&#125;/logs/debug/logs.log</div><div class="line">#定义文件最大大小</div><div class="line">log4j.appender.File.MaxFileSize = 1000MB</div><div class="line">#DEBUG 日志</div><div class="line">log4j.appender.File.Threshold = DEBUG</div><div class="line">log4j.appender.File.layout = org.apache.log4j.PatternLayout</div><div class="line">log4j.appender.File.layout.ConversionPattern =[%p] [%d&#123;yyyy-MM-dd HH\:mm\:ss &#125;][%c]%m%n</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">##################################Mybatis的sql语句的输出，DEBUG级别#####################################################</div><div class="line">log4j.logger.com.ibatis=DEBUG log4j.logger.com.ibatis.common.jdbc.SimpleDataSource=DEBUG </div><div class="line">log4j.logger.com.ibatis.common.jdbc.ScriptRunner=DEBUG</div><div class="line">log4j.logger.com.ibatis.sqlmap.engine.impl.SqlMapClientDelegate=DEBUG</div><div class="line">log4j.logger.java.sql.Connection=DEBUG log4j.logger.java.sql.Statement=DEBUG </div><div class="line">log4j.logger.java.sql.PreparedStatement=DEBUG</div></pre></td></tr></table></figure>
<p>3、在方法中使用Log4j调试一些内容，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Logger logger=Logger.getLogger(TestController.class);   <span class="comment">//获取Logger对象</span></div><div class="line">	</div><div class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"/test/test"</span>)</div><div class="line">	<span class="meta">@ResponseBody</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"这个是测试方法"</span>);</div><div class="line">		</div><div class="line">		logger.debug(<span class="string">"debug信息"</span>);</div><div class="line">		logger.info(<span class="string">"info信息"</span>);</div><div class="line">		</div><div class="line">		logger.error(<span class="string">"这个是error级别的信息"</span>);</div><div class="line">		System.out.println(<span class="number">10</span>/<span class="number">0</span>);</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> <span class="string">"test"</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>1、<a href="https://blog.csdn.net/liupeifeng3514" target="_blank" rel="external">https://blog.csdn.net/qq_35029429/article/details/78826936</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;spring使用Log4j&quot;&gt;&lt;a href=&quot;#spring使用Log4j&quot; class=&quot;headerlink&quot; title=&quot;spring使用Log4j&quot;&gt;&lt;/a&gt;spring使用Log4j&lt;/h1&gt;&lt;h2 id=&quot;常用日志框架介绍&quot;&gt;&lt;a href=&quot;#常
    
    </summary>
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>spring加载properties属性</title>
    <link href="http://chenjiabing666.github.io/2018/08/04/spring%E5%8A%A0%E8%BD%BDproperties%E5%B1%9E%E6%80%A7/"/>
    <id>http://chenjiabing666.github.io/2018/08/04/spring加载properties属性/</id>
    <published>2018-08-04T15:44:26.000Z</published>
    <updated>2018-08-04T15:45:12.758Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring有两种方式加载properties中的属性"><a href="#spring有两种方式加载properties中的属性" class="headerlink" title="spring有两种方式加载properties中的属性"></a>spring有两种方式加载properties中的属性</h1><h2 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h2><ul>
<li><strong>使用<code>&lt;context:property-placeholder  location=&quot;classpath:jdbc.properties&quot; /&gt;</code>在spring的配置文件中加载类路径下的资源文件</strong></li>
<li>假设我们的<code>jdbc.properties</code>文件中的内容如下：</li>
<li><strong>如果后面有重复的键值，将会覆盖前面的值</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">url=jdbc:mysql://localhost:3306/face?useUnicode=true&amp;characterEncoding=utf8</div><div class="line">driver=com.mysql.jdbc.Driver</div><div class="line">user=root</div><div class="line">password=root</div><div class="line">initSize=2</div><div class="line">maxSize=10</div></pre></td></tr></table></figure>
<ul>
<li>那么我们在spring的配置文件中配置数据源就直接使用里面的属性即可，如下，<strong>使用<code>${}</code>直接即可取出其中的属性</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;context:property-placeholder  location=&quot;classpath:jdbc.properties&quot; /&gt;</div><div class="line"></div><div class="line">&lt;!-- 数据源 --&gt;</div><div class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;</div><div class="line">	&lt;property name=&quot;url&quot; value=&quot;#&#123;url&#125;&quot; /&gt;</div><div class="line">	&lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;driver&#125;&quot; /&gt;</div><div class="line">	&lt;property name=&quot;username&quot; value=&quot;$&#123;user&#125;&quot; /&gt;</div><div class="line">	&lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot; /&gt;</div><div class="line">	&lt;property name=&quot;initialSize&quot; value=&quot;$&#123;initSize&#125;&quot; /&gt;</div><div class="line">	&lt;property name=&quot;maxActive&quot; value=&quot;$&#123;maxSize&#125;&quot; /&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<ul>
<li><strong>我们也可以使用<code>@Value(&quot;${}&quot;)</code>来取出其中的值</strong></li>
</ul>
<h2 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h2><ul>
<li><strong>使用<code>&lt;util:properties id=&quot;dbConfig&quot; location=&quot;classpath:db.properties&quot; /&gt;</code>来加载文件中的属性值</strong></li>
<li>假设<code>db.properties</code>文件如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">url=jdbc:mysql://localhost:3306/face?useUnicode=true&amp;characterEncoding=utf8</div><div class="line">driver=com.mysql.jdbc.Driver</div><div class="line">user=root</div><div class="line">password=root</div><div class="line">initSize=2</div><div class="line">maxSize=10</div></pre></td></tr></table></figure>
<ul>
<li>配置的数据源如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 数据源 --&gt;</div><div class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;</div><div class="line">	&lt;property name=&quot;url&quot; value=&quot;#&#123;dbConfig.url&#125;&quot; /&gt;</div><div class="line">	&lt;property name=&quot;driverClassName&quot; value=&quot;#&#123;dbConfig.driver&#125;&quot; /&gt;</div><div class="line">	&lt;property name=&quot;username&quot; value=&quot;#&#123;dbConfig.user&#125;&quot; /&gt;</div><div class="line">	&lt;property name=&quot;password&quot; value=&quot;#&#123;dbConfig.password&#125;&quot; /&gt;</div><div class="line">	&lt;property name=&quot;initialSize&quot; value=&quot;#&#123;dbConfig.initSize&#125;&quot; /&gt;</div><div class="line">	&lt;property name=&quot;maxActive&quot; value=&quot;#&#123;dbConfig.maxSize&#125;&quot; /&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<ul>
<li><strong>也可以使用 <code>@Value(&quot;#{}&quot;)</code>直接取出其中的值</strong></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;spring有两种方式加载properties中的属性&quot;&gt;&lt;a href=&quot;#spring有两种方式加载properties中的属性&quot; class=&quot;headerlink&quot; title=&quot;spring有两种方式加载properties中的属性&quot;&gt;&lt;/a&gt;sprin
    
    </summary>
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>maven使用总结</title>
    <link href="http://chenjiabing666.github.io/2018/07/01/maven%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://chenjiabing666.github.io/2018/07/01/maven使用总结/</id>
    <published>2018-07-01T06:26:24.000Z</published>
    <updated>2018-07-01T06:27:08.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Maven使用总结"><a href="#Maven使用总结" class="headerlink" title="Maven使用总结"></a>Maven使用总结</h1><h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><ul>
<li><p>maven创建的工程的目录中包含<code>main</code>和<code>test</code>文件夹，分别表示主程序的文件夹和测试程序的文件夹</p>
</li>
<li><p>maven使用<code>scop</code>设置依赖范围，常用的依赖范围如下：</p>
<ol>
<li><p>compile ：编译依赖范围，在测试和运行都有效，这个是<strong>默认</strong>的依赖范围</p>
<ul>
<li>对主程序是否有效：有效</li>
<li>对测试程序是否 有效： 有效</li>
<li>是否参与打包：参与``</li>
<li>是否参与部署：参与</li>
</ul>
</li>
<li><p>test：测试依赖的范围</p>
<ul>
<li>对主程序是否有效：无效</li>
<li>对测试程序是否 有效： 有效</li>
<li>是否参与打包：不参与</li>
<li>典型的例子： <code>junit</code></li>
</ul>
</li>
<li><p><code>provided</code></p>
<ul>
<li>对主程序是否有效： 有效</li>
<li>对测试程序是否有效：有效</li>
<li>是否参与打包：不参与</li>
<li>是否参与部署：不参与</li>
<li>典型的例子：<code>servlet-api</code><ul>
<li>主要解决在开发中需要用到的，但是在部署的时候不需要的依赖，比如<code>servlet-api</code>，在开发中没有Tomcat运行环境，因此需要这个<code>servlet-api</code>，但是一旦部署在Tomcat中，Tomcat中会提供这个<code>servlet-api</code>，如果此时在添加的话会产生依赖冲突</li>
</ul>
</li>
</ul>
</li>
<li><p><code>Runtime</code> ：测试和运行时需要。编译不需要。如JDBC驱动包</p>
<ul>
<li>对测试程序是否有效：有效</li>
<li>对主程序是否有效：有效</li>
<li>是否参与部署： 参与</li>
<li>是否参与打包：参与</li>
</ul>
</li>
<li><p><code>system</code>：系统依赖范围。本地依赖，不在maven中央仓库</p>
<ul>
<li>这个必须和<code>systemPath</code>结合使用，用来指定本地依赖的位置</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 添加服务提供者的jar接口 --&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.tedu.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;basedir&#125;/src/main/webapp/WEB-INF/lib/dubbo-provider-helloService-0.0.1.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h2 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h2><ul>
<li>在开发项目的时候，我们通常需要建立多个项目，如果一个项目中需要用到另外一个项目的类或者数据，那么需要引入这个项目快照</li>
<li>如果<code>HelloFriend</code>项目<strong>依赖</strong><code>Hello</code>这个项目，此时的<code>HelloFriend</code>的<code>pom.xml</code>文件如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></div><div class="line">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.tedu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>HelloFriend<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    </div><div class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">		<span class="comment">&lt;!-- 添加Hello这个项目的依赖快照 --&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.tedu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line">    </div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>此时项目<code>HelloFriend</code>中存在依赖只有<code>Hello</code>项目这个<code>jar</code>，但是如果我们在<code>Hello</code>项目的<code>pom.xml</code>文件中添加一个<code>junit</code>的依赖，这个依赖范围为设置为<code>compile</code>，如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">  		<span class="comment">&lt;!-- Junit --&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>做了上面的操作，我们可以查看项目<code>HelloFriend</code>和<code>Hello</code>中都自动的导入了<code>Junit</code>依赖，这个就是依赖传递。</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>依赖传递只有是依赖范围为<code>compile</code>的情况下才有作用，如果我们需要一个<code>servlet-api</code>的依赖，因为<code>servlet-api</code>这个jar在部署的时候会和Tomcat冲突，因此只能设置为<code>provided</code>，但是此时就不能依赖传递了，只能在每个项目中的<code>pom.xml</code>文件中都添加了</li>
</ul>
<h2 id="依赖排除"><a href="#依赖排除" class="headerlink" title="依赖排除"></a>依赖排除</h2><ul>
<li><strong><code>HelloFriend</code>项目依赖<code>Hello</code>项目，其中<code>compile</code>范围的依赖都会导入<code>HelloFriend</code>中</strong></li>
<li><strong>使用<code>dubbo</code>默认会添加给我们添加<code>spring-framework</code>的版本为<code>2.5.6</code>，默认添加的依赖只能排除，不能在项目中再添加一个其他的版本，只有排除之后才能添加，否则会导致jar包冲突</strong></li>
<li><code>Hello</code>项目中的依赖为：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- Junit --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="comment">&lt;!-- 添加dubbo依赖的jar,会自动添加spring 2.5版本的依赖 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li><p>此时<code>HelloFriend</code>的项目需要使用<code>4.3.13</code>版本的spring，那么我们有如下解决办法：</p>
<ol>
<li>在<code>Hello</code>项目中改变依赖，排除spring2.5版本的：<ul>
<li><strong>一般在公司中项目的版本都是定制好的，我们不可能随意改动父项目中定义好的版本，因此这个方法明显是不行的</strong></li>
</ul>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 使用spring4.3.13 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.13.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">  </div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">          <span class="comment">&lt;!--排除spring2.5版本--&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>我们可以在项目<code>HelloFriend</code>排除这个spring的依赖，那么我们就可以不需要改变<code>Hello</code>项目中的依赖了，如下：<ul>
<li><strong>这个才是正确的排除依赖的方式</strong></li>
</ul>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- SpringMVC --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.13.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 添加Hello这个项目的依赖快照 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.tedu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">          <span class="comment">&lt;!--排除项目中的spring2.5的依赖，这个不会影响Hello项目中的版本--&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="依赖原则"><a href="#依赖原则" class="headerlink" title="依赖原则"></a>依赖原则</h2><h3 id="依赖路径最短优先原则"><a href="#依赖路径最短优先原则" class="headerlink" title="依赖路径最短优先原则"></a>依赖路径最短优先原则</h3><ul>
<li>假设项目<code>MakeFriend</code>依赖<code>HelloFriend</code>，并且<code>HelloFriend</code>依赖<code>Hello</code>项目。此时<code>Hello项目中</code>使用的<code>log4j 1.2.14</code>版本的，但是在<code>HelloFriend</code>版本中使用的是<code>log4j1.2.17</code>版本的，那么此时的<code>MakeFriend</code>应该选择什么版本呢？</li>
<li><img src="http://ono60m7tl.bkt.clouddn.com/maven1.png" alt=""></li>
</ul>
<ul>
<li><code>Hello</code>的依赖如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li><code>HelloFriend</code>依赖如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 添加Hello这个项目的依赖快照 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.tedu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">	</div><div class="line">	<span class="comment">&lt;!--添加1.2.17版本的log4j--&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li><code>MakeFriend</code>的依赖如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.tedu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>HelloFriend<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>我们根据图形可以看到<code>MakeFriend</code>到<code>HelloFriend</code>的<code>log4j1.2.17</code>的路径是<code>2</code>，但是到<code>Hello</code>中的<code>log4j1.2.14</code>的路径为<code>3</code>，因此Maven会选择<code>HelloFriend</code>中的<code>log4j1.2.17</code>版本作为MakeFriend的依赖</strong></li>
</ul>
<h3 id="pom文件中申明顺序优先"><a href="#pom文件中申明顺序优先" class="headerlink" title="pom文件中申明顺序优先"></a>pom文件中申明顺序优先</h3><ul>
<li><p><strong>在<code>路径</code>都是一样的情况下，那么就要看在<code>pom.xml</code>文件中申明的顺序了，先申明的就使用哪个项目中的依赖版本</strong></p>
</li>
<li><p>假设现在的依赖改变了，<code>MakeFriend</code>现在是直接依赖<code>Hello</code>和<code>HelloFriend</code>，如下图</p>
</li>
<li><img src="http://ono60m7tl.bkt.clouddn.com/maven2.png" alt=""></li>
<li>我们可以看出此时到两个版本的依赖都是一样的路径为<code>2</code>，那么我们应该选择哪个版本呢，此时就需要看看在<code>MakeFriend</code>中的<code>pom.xml</code>文件的申明顺序<ul>
<li>可以看出先申明的是<code>HelloFriend</code>，因此<code>MakeFriend</code>使用的是<code>log4j1.2.17</code></li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 先申明HelloFriend,那么就要使用log4j.1.2.17版本 --&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span>	</div><div class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.tedu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>HelloFriend<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">		</div><div class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.tedu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="覆写优先"><a href="#覆写优先" class="headerlink" title="覆写优先"></a>覆写优先</h3><p>​    </p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul>
<li>maven的生命周期有三个部分组成，分别为<code>clean生命周期</code>，<code>site生命周期</code>，<code>default生命周期</code></li>
</ul>
<h3 id="生命周期调用的特点"><a href="#生命周期调用的特点" class="headerlink" title="生命周期调用的特点"></a>生命周期调用的特点</h3><ul>
<li>三大生命周期中也会包含各个阶段，并且各个阶段是有序进行的，maven为了实现构建的自动化，如果我们使用了命令调用生命周期后面的处理阶段，那么会从最前面的阶段开始执行，不用每一个阶段都执行一遍。</li>
</ul>
<h3 id="clean生命周期"><a href="#clean生命周期" class="headerlink" title="clean生命周期"></a>clean生命周期</h3><ul>
<li><p>在进行真正的构建之前进行一些清理工作</p>
</li>
<li><p>clean生命周期包括：</p>
<ul>
<li><code>per-clean</code>：执行了一些需要在clean之前完成的工作</li>
<li><code>clean</code>：移除所有上一次构建生成的文件</li>
<li><code>post-clean</code>：执行一些需要在clean之后立刻完成的工作</li>
</ul>
</li>
<li>当我们执行<code>mvn:clean</code>命令的时候只会执行<code>per-clean</code>和<code>clean</code>这两个阶段的任务，不会执行<code>post-clean</code>的工作</li>
</ul>
<h3 id="default生命周期"><a href="#default生命周期" class="headerlink" title="default生命周期"></a>default生命周期</h3><ul>
<li>构建的核心部分，编译、测试、打包、部署</li>
<li>包括如下的23个生命周期阶段：</li>
</ul>
<table>
<thead>
<tr>
<th>生命周期阶段</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>validate</td>
<td>检查工程配置是否正确，完成构建过程的所有必要信息是否能够获取到。</td>
</tr>
<tr>
<td>initialize</td>
<td>初始化构建状态，例如设置属性。</td>
</tr>
<tr>
<td>generate-sources</td>
<td>生成编译阶段需要包含的任何源码文件。</td>
</tr>
<tr>
<td>process-sources</td>
<td>处理源代码，例如，过滤任何值（filter any value）。</td>
</tr>
<tr>
<td>generate-resources</td>
<td>生成工程包中需要包含的资源文件。</td>
</tr>
<tr>
<td>process-resources</td>
<td>拷贝和处理资源文件到目的目录中，为打包阶段做准备。</td>
</tr>
<tr>
<td>compile</td>
<td>编译工程源码。</td>
</tr>
<tr>
<td>process-classes</td>
<td>处理编译生成的文件，例如 Java Class 字节码的加强和优化。</td>
</tr>
<tr>
<td>generate-test-sources</td>
<td>生成编译阶段需要包含的任何测试源代码。</td>
</tr>
<tr>
<td>process-test-sources</td>
<td>处理测试源代码，例如，过滤任何值（filter any values)。</td>
</tr>
<tr>
<td>test-compile</td>
<td>编译测试源代码到测试目的目录。</td>
</tr>
<tr>
<td>process-test-classes</td>
<td>处理测试代码文件编译后生成的文件。</td>
</tr>
<tr>
<td>test</td>
<td>使用适当的单元测试框架（例如JUnit）运行测试。</td>
</tr>
<tr>
<td>prepare-package</td>
<td>在真正打包之前，为准备打包执行任何必要的操作。</td>
</tr>
<tr>
<td>package</td>
<td>获取编译后的代码，并按照可发布的格式进行打包，例如 JAR、WAR 或者 EAR 文件。</td>
</tr>
<tr>
<td>pre-integration-test</td>
<td>在集成测试执行之前，执行所需的操作。例如，设置所需的环境变量。</td>
</tr>
<tr>
<td>integration-test</td>
<td>处理和部署必须的工程包到集成测试能够运行的环境中。</td>
</tr>
<tr>
<td>post-integration-test</td>
<td>在集成测试被执行后执行必要的操作。例如，清理环境。</td>
</tr>
<tr>
<td>verify</td>
<td>运行检查操作来验证工程包是有效的，并满足质量要求。</td>
</tr>
<tr>
<td>install</td>
<td>安装工程包到本地仓库中，该仓库可以作为本地其他工程的依赖。</td>
</tr>
<tr>
<td>deploy</td>
<td>拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程。</td>
</tr>
</tbody>
</table>
<ul>
<li>当一个阶段通过 Maven 命令调用时，例如<code>mvn compile</code>，只有该阶段之前以及包括该阶段在内的所有阶段会被执行。</li>
<li><img src="https://img-blog.csdn.net/20160114103206331" alt=""></li>
</ul>
<h3 id="Site生命周期"><a href="#Site生命周期" class="headerlink" title="Site生命周期"></a>Site生命周期</h3><ul>
<li>Maven Site 插件一般用来创建新的报告文档、部署站点等。</li>
<li>包含以下阶段<ul>
<li><code>pre-site</code>：执行一些需要在生成站点文档之前完成的工作</li>
<li><code>site</code>：生成项目的站点文档</li>
<li><code>post-site</code>：执行一些需要生成站点文档之后完成的工作</li>
<li><code>site-deploy</code>：将生成站点文档部署到特定的服务器上</li>
</ul>
</li>
</ul>
<h2 id="Maven统一管理依赖的版本号"><a href="#Maven统一管理依赖的版本号" class="headerlink" title="Maven统一管理依赖的版本号"></a>Maven统一管理依赖的版本号</h2><ul>
<li>假设如下的依赖：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- SpringMVC --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.13.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line">	<span class="comment">&lt;!-- Spring-JDBC,要和spring-webmvc的版本一致 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.13.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>那么当我们需要改变spring的依赖版本号为<code>4.3.12.RELEASE</code>，那么我们只有逐个改变<code>version</code>中的值，现在是两个依赖比较好改变的，如果要有很多个的话，那么难免会改错，因此我们需要使用一种方式统一管理依赖的版本号。我们可以使用<code>&lt;properties&gt;</code>标签来管理，新的配置文件如下：<ul>
<li><code>properties</code>中的标签体可以任意指定，如果需要引用定义的标签体中的内容，那么直接使用<code>${标签体}</code>即可</li>
<li>此时我们要是改变版本，那么只需要改变<code>&lt;properties&gt;</code>中的版本即可</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 使用properties管理版本号 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">		<span class="comment">&lt;!-- 这里的标签体可以任意指定，后续只要使用$&#123;&#125;引用标签体即可使用其中定义的内容 --&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">spring-version</span>&gt;</span>4.3.13.RELEASE<span class="tag">&lt;/<span class="name">spring-version</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line">	</div><div class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">		<span class="comment">&lt;!-- SpringMVC --&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">			<span class="comment">&lt;!-- version使用$&#123;&#125; --&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line">		<span class="comment">&lt;!-- Spring-JDBC,要和spring-webmvc的版本一致 --&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        </div><div class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li>我们知道只有<code>compile</code>范围内的依赖才可以传递，但是对于<code>test</code>和<code>provided</code>中的依赖却是不可以传递的，那么必须在每个项目中都要添加依赖，此时肯定会出现每个项目中依赖版本不一致的情况，这样对于每个人的开发来说是比较困难的，因为不同版本的依赖使用的方式也不同，此时我们就需要统一管理这个版本了。</li>
<li>下面我们以<code>junit</code>的版本控制为例</li>
</ul>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul>
<li>创建一个父工程<code>Hello-Parent</code>，打包的方式为<code>pom</code></li>
<li>在<code>Hello-Parent</code>中的<code>pom.xml</code>文件中使用<code>dependencyManagement</code>管理版本，控制<code>junit</code>的版本依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.tedu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Hello-Parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></div><div class="line">    </div><div class="line">  <span class="comment">&lt;!-- 使用properties控制版本号 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">  	<span class="tag">&lt;<span class="name">junit-version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">junit-version</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line">  </div><div class="line">  <span class="comment">&lt;!-- 使用dependencyManagement管理版本 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></div><div class="line">  	</div><div class="line">  	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">  		<span class="comment">&lt;!-- Junit --&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">		</div><div class="line">  	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></div><div class="line">  </div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>在子工程中使用<code>parent</code>标签指定声明对父工程的引用</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.tedu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Hello-Parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">	<span class="comment">&lt;!-- 使用relativePath指定父工程的相对位置 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../Hello-Parent<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>将子工程坐标和父工程坐标重复的地方删除，不删除也没关系</li>
<li>在子工程中删除<code>junit</code>的<code>version</code>标签，表明是继承自父工程的版本，不需要指定</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- Junit --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">          <span class="comment">&lt;!--此时不需要指定version了，因为父工程中已经指定了--&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>子工程全部的配置</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></div><div class="line">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line">	<span class="comment">&lt;!-- 这里的groupId和父工程中的重复了，因此可以删除 </span></div><div class="line">	&lt;groupId&gt;cn.tedu&lt;/groupId&gt;--&gt;</div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">	<span class="comment">&lt;!-- 这里的version版本也和父工程的重复了，因此可以删除</span></div><div class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; --&gt;</div><div class="line">	</div><div class="line">	<span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.tedu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Hello-Parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">		<span class="comment">&lt;!-- 使用relativePath指定父工程的相对位置 --&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../Hello-Parent<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div><div class="line">	</div><div class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">		<span class="comment">&lt;!-- Junit --&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!--不需要指定version--&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><ul>
<li>我们在开发项目的时候都是分模块开发的，此时如果想要使用maven安装这个项目的话，那么需要一个一个的安装，但是我们可以使用聚合的方式，可以实现一次性安装。并且安装还是有先后顺序的，一定要先安装父工程，否则将会找不到依赖信息，我们使用聚合的方式就没有先后安装的障碍了，maven会为我们自动的解决</li>
</ul>
<h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>创建一个maven工程，打包方式为<code>pom</code>，当然也是可以直接使用父工程</li>
<li>在pom.xml配置文件中配置<code>module</code></li>
<li>详细的pom.xml如下：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.tedu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Hello-Manager<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></div><div class="line">  </div><div class="line">  <span class="comment">&lt;!-- 继承父工程 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.tedu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Hello-Parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">		<span class="comment">&lt;!-- 使用relativePath指定父工程的相对位置 --&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../Hello-Parent<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div><div class="line">  </div><div class="line">  <span class="comment">&lt;!-- 使用聚合的方式 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">modules</span>&gt;</span></div><div class="line">  	<span class="tag">&lt;<span class="name">module</span>&gt;</span>../Hello-Parent<span class="tag">&lt;/<span class="name">module</span>&gt;</span></div><div class="line">  	<span class="tag">&lt;<span class="name">module</span>&gt;</span>../Hello<span class="tag">&lt;/<span class="name">module</span>&gt;</span></div><div class="line">  	<span class="tag">&lt;<span class="name">module</span>&gt;</span>../HelloFriend<span class="tag">&lt;/<span class="name">module</span>&gt;</span></div><div class="line">  	<span class="tag">&lt;<span class="name">module</span>&gt;</span>../MakeFriend<span class="tag">&lt;/<span class="name">module</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></div><div class="line">  </div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Maven使用总结&quot;&gt;&lt;a href=&quot;#Maven使用总结&quot; class=&quot;headerlink&quot; title=&quot;Maven使用总结&quot;&gt;&lt;/a&gt;Maven使用总结&lt;/h1&gt;&lt;h2 id=&quot;依赖范围&quot;&gt;&lt;a href=&quot;#依赖范围&quot; class=&quot;headerli
    
    </summary>
    
      <category term="Maven" scheme="http://chenjiabing666.github.io/categories/Maven/"/>
    
    
      <category term="Maven" scheme="http://chenjiabing666.github.io/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="http://chenjiabing666.github.io/2018/07/01/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://chenjiabing666.github.io/2018/07/01/二叉树/</id>
    <published>2018-07-01T06:00:57.000Z</published>
    <updated>2018-07-01T06:01:29.083Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>二叉树是每个节点最多有两个子树的树结构。它有五种基本形态：二叉树可以是空集；根可以有空的左子树或右子树；或者左、右子树皆为空。</p>
<p><img src="https://images0.cnblogs.com/i/497634/201403/270929530778327.jpg" alt=""></p>
<h3 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h3><ol>
<li>度：节点所拥有子节点的个数</li>
<li>叶子节点：度为0的节点，即是没有子节点的节点</li>
<li>分支节点：度不为0的节点</li>
<li>根节点： 没有父节点的节点</li>
<li>层次：根节点的层次为1，其余节点的层次等于该双亲节点的层次加1</li>
<li>深度：树中节点的最大层次</li>
</ol>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul>
<li><strong>性质1</strong>：二叉树第i层上的结点数目最多为 <code>2^{i-1}</code> (i≥1)。</li>
<li><strong>性质2</strong>：深度为k的二叉树至多有<strong>2{k}-1</strong>个结点(k≥1)。</li>
<li><strong>性质3</strong>：包含n个结点的二叉树的高度至少为<strong>log2 (n+1)</strong>。 </li>
<li><strong>性质4</strong>：在任意一棵二叉树中，若终端结点的个数为<strong>n0</strong>，度为2的结点数为<strong>n2</strong>，则<strong>n0=n2+1</strong>。</li>
</ul>
<h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul>
<li><strong>除了最后一层，所有分支节点的子节点个数为2</strong></li>
</ul>
<p><img src="https://images0.cnblogs.com/i/497634/201403/270930282184259.jpg" alt=""></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>叶子只能出现在最后一层。</li>
<li>非叶子结点度一定是2.</li>
<li>在同样深度的二叉树中，满二叉树的结点个数最多，叶子树最多。</li>
</ol>
<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><ul>
<li>若设二叉树的深度为h，除第 h 层外，其它各层 (1~h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在<strong>最左边</strong>，这就是完全二叉树。</li>
<li>完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。</li>
<li>一棵二叉树至多只有最下面的一层上的结点的度数可以小于2，并且最下层上的结点都集中在该层最左边的若干位置上，而在最后一层上，右边的若干结点缺失的二叉树，则此二叉树成为完全二叉树。</li>
<li><img src="https://images0.cnblogs.com/i/497634/201403/270931211084932.jpg" alt=""></li>
</ul>
<h3 id="判断完全二叉树"><a href="#判断完全二叉树" class="headerlink" title="判断完全二叉树"></a>判断完全二叉树</h3><ul>
<li>完全二叉树：<code>叶节点</code>只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树</li>
<li>满二叉树必然是完全二叉树，完全二叉树不一定是满二叉树</li>
</ul>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li><a href="https://baike.so.com/doc/7890124-8164219.html" target="_blank" rel="external">叶子结点</a>只可能在最大的两层上出现,对任意结点，若其右分支下的子孙最大层次为L，则其左分支下的子孙的最大层次必为L 或 L+1;</li>
<li>满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树</li>
<li>只允许最后一层有空缺结点且空缺在右边，即叶子结点只能在层次最大的两层上出现</li>
<li>对任一结点，如果其右子树的深度为j，则其左子树的深度必为j或j+1。 即度为1的点只有1个或0个</li>
</ul>
<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><ul>
<li><p>二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：</p>
<ol>
<li>若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树。</li>
<li>没有键值相等的节点（no duplicate nodes）。</li>
</ol>
</li>
<li><img src="https://images0.cnblogs.com/i/497634/201403/270932052801072.jpg" alt=""></li>
</ul>
<h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * 插入节点</div><div class="line">	 * <span class="doctag">@param</span> value  节点的值</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertNode</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</div><div class="line">		<span class="comment">//如果根节点为null</span></div><div class="line">		<span class="keyword">if</span> (root==<span class="keyword">null</span>) &#123;</div><div class="line">			root=<span class="keyword">new</span> Node(value,<span class="keyword">null</span>,<span class="keyword">null</span>);  <span class="comment">//创建根节点,此时没有左右子节点</span></div><div class="line">			<span class="keyword">return</span>;   <span class="comment">//返回即可，表示插入成功，这个插入的节点就是根节点</span></div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="comment">//如果根节点已经存在，那么就需要从根节点开始比较大小</span></div><div class="line">		Node currentNode=root;  <span class="comment">//当前节点</span></div><div class="line">		Node parentNode=root;  <span class="comment">//当前节点的父节点，需要保存这个节点</span></div><div class="line">		<span class="keyword">boolean</span> isLeftChild=<span class="keyword">true</span>;  <span class="comment">//记录待插入的数是parentNode的左节点还是右节点</span></div><div class="line">		</div><div class="line">		<span class="comment">//当当前节点不为空，表示没有找到插入的位置，当currentNode节点为null的时候，那么这个就是待插入的位置</span></div><div class="line">		<span class="keyword">while</span>(currentNode!=<span class="keyword">null</span>)&#123;</div><div class="line">			parentNode=currentNode;  <span class="comment">//保存当前节点的父节点</span></div><div class="line">			<span class="comment">//如果待插入的值小于当前值，那么到当前节点的左子树中查找</span></div><div class="line">			<span class="keyword">if</span> (value&lt;currentNode.getValue()) &#123;</div><div class="line">				currentNode=currentNode.getLeftChild();  <span class="comment">//当前节点继续向下成为左子节点</span></div><div class="line">				isLeftChild=<span class="keyword">true</span>;  <span class="comment">//左节点</span></div><div class="line">				</div><div class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span> (value&gt;currentNode.getValue()) &#123;  <span class="comment">//如果待插入的数大于当前节点的值，那么到当前节点的右边查找</span></div><div class="line">				currentNode=currentNode.getRightNode();</div><div class="line">				isLeftChild=<span class="keyword">false</span>;</div><div class="line">			&#125;<span class="keyword">else</span> &#123;  <span class="comment">//value和currentNode.value相等，不允许插入</span></div><div class="line">				System.out.println(value+<span class="string">"已经存在，不允许插入"</span>);</div><div class="line">				<span class="keyword">return</span>;   <span class="comment">//直接返回，后面的数字不用插入了</span></div><div class="line">			&#125;</div><div class="line">		&#125; </div><div class="line">		</div><div class="line">		<span class="comment">//循环结束，此时的parentNode就是待插入数字的父节点</span></div><div class="line">		<span class="comment">//如果待插入的节点是左子节点</span></div><div class="line">		<span class="keyword">if</span> (isLeftChild) &#123;</div><div class="line">			Node node=<span class="keyword">new</span> Node(value, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">			parentNode.setLeftChild(node);  <span class="comment">//设置左节点</span></div><div class="line">		&#125;<span class="keyword">else</span> &#123;  <span class="comment">//是右子节点</span></div><div class="line">			Node node=<span class="keyword">new</span> Node(value, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">			parentNode.setRightNode(node);  <span class="comment">//设置右节点</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="查找指定值"><a href="#查找指定值" class="headerlink" title="查找指定值"></a>查找指定值</h3><ul>
<li>比较需要查找的值，如果大于当前节点的值，在其右子树中查找，如果小于当前节点的值，在其左子树中查找</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 在二叉查找树中查找指定的值</div><div class="line"> * <span class="doctag">@param</span> value</div><div class="line"> * <span class="doctag">@return</span> 返回的找到的节点，如果为null表示没有找到</div><div class="line"> * 从根节点查找，比较值，如果大于，在右子树中查找，如果小于在左子树中查找</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">findValue</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</div><div class="line">	Node currentNode=<span class="keyword">this</span>.root;  <span class="comment">//从根节点开始查找</span></div><div class="line">	<span class="comment">//如果currentNode不为null并且值不相等，跳出循环的条件是：要么没有找到，返回null，要么找到了，值相等</span></div><div class="line">	<span class="keyword">while</span>(currentNode!=<span class="keyword">null</span>&amp;&amp;currentNode.value!=value)&#123;</div><div class="line">		<span class="keyword">if</span> (value&lt;currentNode.getValue()) &#123;</div><div class="line">			currentNode=currentNode.getLeftChild();</div><div class="line">		&#125;<span class="keyword">else</span> &#123;</div><div class="line">			currentNode=currentNode.getRightNode();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> currentNode;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><ul>
<li>分为三种：<ul>
<li>删除叶子节点</li>
<li>删除只有一个子节点的节点</li>
<li>删除含有两个子节点的节点</li>
</ul>
</li>
</ul>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="https://www.cnblogs.com/Michaelwjw/p/6384428.html" target="_blank" rel="external">https://www.cnblogs.com/Michaelwjw/p/6384428.html</a></li>
</ul>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><ul>
<li>访问顺序： 先访问父结点，再<code>前序遍历</code>左子树，最后再<code>前面序遍历</code>右子树，即是： <strong>父节点 – 左 子树 — 右子树</strong></li>
<li><img src="http://my.csdn.net/uploads/201203/27/1332780800_2559.jpg" alt=""></li>
<li>图中遍历的结果是：<ol>
<li>从根节点开始，访问1</li>
<li>访问2，此时的2作为父节点，访问左子树</li>
<li>访问4，此时的4作为父节点，访问左子树，没有左子树，访问右子树，也没有右子树，此时开始访问父节点4的右子树</li>
<li>访问5，此时的5作为父节点，访问左子树</li>
<li>访问7，此时的7作为父节点，访问左子树，没有，访问右子树</li>
<li>访问8 ，此时的8作为父节点，访问左子树，没有，访问右子树没有，此时以1作为父节点，开始访问有节点</li>
<li>访问3，此时的3作为父节点，访问左子树，没有，访问右子树</li>
<li>访问6，此时的6作为父节点，左右节点都没有，访问结束</li>
</ol>
</li>
<li>最后的前序遍历为：1，2，4，5，7，8，3，6。</li>
<li>递归调用的算法如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//前序遍历对外的方法</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">()</span></span>&#123; </div><div class="line">		PreOrder(<span class="keyword">this</span>.root);  <span class="comment">//从根节点开始访问   </span></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 前序遍历</div><div class="line">	 * 递归</div><div class="line">	 * <span class="doctag">@param</span> node  父节点</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(Node node)</span></span>&#123;</div><div class="line">		<span class="comment">//如果节点不为null</span></div><div class="line">		<span class="keyword">if</span> (node!=<span class="keyword">null</span>) &#123;</div><div class="line">			System.out.println(node.getValue());  <span class="comment">//输出值</span></div><div class="line">			PreOrder(node.getLeftChild());  <span class="comment">//访问左子树</span></div><div class="line">			PreOrder(node.getRightNode());  <span class="comment">//访问右子树</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><ul>
<li><p>先中序遍历左子树，然后再访问根结点，最后再中序遍历右子树即左—根—右</p>
</li>
<li><p>总的来说，把当前节点看成是根节点，如果这个根节点还存在左子树，继续向下，直到当前节点不存在左子树，那么输出当前节点即可，然后输出父节点的值，然后输出右子树的值，如此反复即可</p>
</li>
<li><p><img src="https://img-blog.csdn.net/20161110202932907?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
</li>
<li><p>中序遍历的规则是【左根右】，我们从root节点A看起；</p>
<p>此时A是根节点，遍历A的左子树；</p>
<p>A的左子树存在，找到B，此时B看做根节点，遍历B的左子树；</p>
<p>B的左子树不存在，返回B，根据【左根右】的遍历规则，记录B，遍历B的右子树；</p>
<p>B的右子树存在，找到C，此时C看做根节点，遍历C的左子树；</p>
<p>C的左子树存在，找到D，由于D是叶子节点，无左子树，记录D，无右子树，返回C，根据【左根右】的遍历规则，记录C，遍历C的右子树；</p>
<p>C的右子树不存在，返回B，B的右子树遍历完，返回A；</p>
<p>至此，A的左子树遍历完毕，根据【左根右】的遍历规则，记录A，遍历A的右子树；</p>
<p>A的右子树存在，找到E，此时E看做根节点，遍历E的左子树；</p>
<p>E的左子树不存在，返回E，根据【左根右】的遍历规则，记录E，遍历E的右子树；</p>
<p>E的右子树存在，找到F，此时F看做根节点，遍历F的左子树；</p>
<p>F的左子树存在，找到G，此时G看做根节点，遍历G的左子树；</p>
<p>G的左子树存在，找到H，由于H是叶子节点，无左子树，记录H，无右子树，返回G，根据【左根右】的遍历规则，记录G，遍历G的右子树；</p>
<p>G的右子树存在，找到K，由于K是叶子节点，无左子树，记录K，无右子树，返回G，根据【左根右】的遍历规则，记录F，遍历F的右子树；</p>
<p>F的右子树不存在，返回F，E的右子树遍历完毕，返回A；</p>
<p>至此，A的右子树也遍历完毕；</p>
</li>
</ul>
<ul>
<li>详细的算法如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//中序遍历对外的方法</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InOrder</span><span class="params">()</span></span>&#123;</div><div class="line">		InOrder(<span class="keyword">this</span>.root);  <span class="comment">//传入根节点</span></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(Node node)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span> (node!=<span class="keyword">null</span>) &#123;</div><div class="line">			InOrder(node.getLeftChild());   <span class="comment">//先遍历左子树</span></div><div class="line">			System.out.println(node.getValue());  </div><div class="line">			InOrder(node.getRightNode());   <span class="comment">//遍历右子树</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h3><ul>
<li>先后序遍历左子树，然后再后序遍历右子树，最后再访问根结点即<strong>左—右—根。</strong></li>
<li>总的来说，把当前节点当做根节点，只要是存在左右子树的继续向下，不输出当前节点的值，直到没有左右子树才输出，再返回，如此反复即可</li>
<li><strong>总结： 当根据顺序访问的时候，只要当前节点没有左右节点或者左右节点已经输出过了，才可以输出当前节点的值</strong></li>
<li><img src="http://my.csdn.net/uploads/201203/27/1332781113_9913.jpg" alt=""></li>
</ul>
<ul>
<li>详细过程如下：<ol>
<li>从根节点1开始，访问左子树2，把2当成根节点，访问左子树4，把4当成根节点，访问左子树，没有，输出4</li>
<li>返回父节点2，把2当成根节点，此时的左子树4已经输出了，那么开始访问右子树5，把5当成根节点，访问左子树7，把7当成根节点，访问左子树，没有，但是存在右子树8，把8当成根节点，访问左子树，没有，访问右子树，没有，此时输出8</li>
<li>返回父节点7，发现不存在左节点，右节点8已经输出了，因此输出7</li>
<li>返回父节点5，发现左节点7已经输出了，并且没有右子树，因此输出5</li>
<li>返回父节点2，发现左右节点都输出了，因此继续返回父4节点1</li>
<li>把1当成根节点，发现左子树已经遍历完成，访问左子树3，把当前的3当成根节点，访问左子树，没有，访问右子树6，把6当成根节点，发现左右子树都不存在，输出6</li>
<li>返回父节点3，发现没有左子树，并且右节点6已经输出了，因此输出3</li>
<li>返回父节点1，输出1</li>
</ol>
</li>
<li>最终的顺序为：4,8,7,5,6,3,1</li>
</ul>
<ul>
<li>详细算法如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//后序遍历对外的方法</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.PostOrder(<span class="keyword">this</span>.root);  <span class="comment">//从根节点开始</span></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//后序遍历</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(Node node)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</div><div class="line">			PostOrder(node.getLeftChild());  <span class="comment">//遍历左子树</span></div><div class="line">			PostOrder(node.getRightNode());  <span class="comment">//遍历右子树</span></div><div class="line">			System.out.println(node.getValue());   <span class="comment">//输出</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><ul>
<li><a href="http://www.cnblogs.com/skywang12345/p/3245399.html" target="_blank" rel="external">http://www.cnblogs.com/skywang12345/p/3245399.html</a></li>
</ul>
<h2 id="参考文章-1"><a href="#参考文章-1" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.cnblogs.com/polly333/p/4740355.html#8" target="_blank" rel="external">https://www.cnblogs.com/polly333/p/4740355.html#8</a></li>
<li><a href="https://www.cnblogs.com/Michaelwjw/p/6384428.html" target="_blank" rel="external">https://www.cnblogs.com/Michaelwjw/p/6384428.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h2&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://chenjiabing666.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://chenjiabing666.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="http://chenjiabing666.github.io/2018/07/01/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://chenjiabing666.github.io/2018/07/01/堆排序/</id>
    <published>2018-07-01T06:00:09.000Z</published>
    <updated>2018-07-01T06:00:39.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h2><ul>
<li>堆(heap)，这里所说的堆是数据结构中的堆，而不是内存模型中的堆。堆通常是一个可以被看做一棵树，它满足下列性质：</li>
<li>[<strong>性质一</strong>] 堆中任意节点的值总是不大于(不小于)其子节点的值；</li>
<li>[<strong>性质二</strong>] 堆总是一棵<code>完全树</code>。</li>
<li>将任意节点不大于其子节点的堆叫做最小堆或小根堆，而将任意节点不小于其子节点的堆叫做最大堆或大根堆。常见的堆有二叉堆、左倾堆、斜堆、二项堆、斐波那契堆等等。</li>
</ul>
<h2 id="排序的过程"><a href="#排序的过程" class="headerlink" title="排序的过程"></a>排序的过程</h2><ol>
<li>将数组建成最大堆或者最小堆</li>
<li>取出堆顶的数据和数组末尾的数据交换，此时对前面的数据再次建堆，再取堆顶的数据和数组中的倒数第二个交换，…………………….</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="构造大顶堆"><a href="#构造大顶堆" class="headerlink" title="构造大顶堆"></a>构造大顶堆</h3><ul>
<li>实现从大到小的排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 构造大顶堆</div><div class="line">	 * 1. 根节点的值一定要比子节点的值大</div><div class="line">	 * 堆的向下调整</div><div class="line">	 * <span class="doctag">@param</span> array  需要调整的数组</div><div class="line">	 * <span class="doctag">@param</span> start  调整的起始位置</div><div class="line">	 * <span class="doctag">@param</span> end    调整的终止位置</div><div class="line">	 * 索引从0开始</div><div class="line">	 * 当前节点的左节点： 2*i+1</div><div class="line">	 * 		   右节点： 2**i+2</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">max_heap_down</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">		<span class="keyword">int</span> currentIndex=start;  <span class="comment">//保存当前节点的下标</span></div><div class="line">		<span class="keyword">int</span> leftIndex=<span class="number">2</span>*currentIndex+<span class="number">1</span>;   <span class="comment">//当前节点左节点的下标</span></div><div class="line">		<span class="comment">//当当前节点的左节点的下标小于终止下标的时候，因为堆是一个完全的二叉树，因此只要没有左子树就一定没有右子树，因此只需要判断左节点的下标即可</span></div><div class="line">		<span class="comment">//只要满足这个条件就表示一定存在左右节点</span></div><div class="line">		<span class="keyword">while</span>(leftIndex&lt;end)&#123;</div><div class="line">			<span class="comment">//当左节点的值小于右节点，那么此时只需要将当前值和右节点的值比较，这里的leftIndex+1是右子节点的下标</span></div><div class="line">			<span class="comment">//如果没有执行if体内的语句，那么此时的左右节点最大的下标就是左节点的下标</span></div><div class="line">			<span class="keyword">if</span>(array[leftIndex]&lt;array[leftIndex+<span class="number">1</span>])&#123;</div><div class="line">				leftIndex++;  <span class="comment">//此时的下标编程右节点的下标</span></div><div class="line">			&#125;</div><div class="line">			<span class="comment">//如果当前节点大于等于左右子节点中的最大值，那么就不用调整了，直接跳出</span></div><div class="line">			<span class="keyword">if</span> (array[currentIndex]&gt;=array[leftIndex]) &#123;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;<span class="keyword">else</span> &#123;    <span class="comment">//如果小于，此时需要调整，将当前节点和左右子节点最大值交换</span></div><div class="line">				<span class="keyword">int</span> temp=array[currentIndex];   <span class="comment">//交换数字</span></div><div class="line">				array[currentIndex]=array[leftIndex];</div><div class="line">				array[leftIndex]=temp;</div><div class="line">				</div><div class="line">				currentIndex=leftIndex;  <span class="comment">//此时的当前节点的下标</span></div><div class="line">				leftIndex=<span class="number">2</span>*currentIndex+<span class="number">1</span>;   <span class="comment">//当前节点的左子节点也需要改变了</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 堆排序，从小到大</div><div class="line">	 * <span class="doctag">@param</span> array 待排序的数组</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heap_sort_asc</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</div><div class="line">		<span class="comment">//从索引为array.length/2-1的位置到0，开始向下调整，那么调整好的数组就是一个大顶堆</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=array.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</div><div class="line">			<span class="comment">//进行向下调整</span></div><div class="line">			max_heap_down(array, i, array.length-<span class="number">1</span>);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="comment">//从最后一个元素开始对序列进行调整，不断的调整，直到第一个元素</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = array.length-<span class="number">1</span>; i &gt;<span class="number">0</span>; i--) &#123;</div><div class="line">			<span class="comment">//此时array[0]就是最大的元素，因此和最后一个元素交换</span></div><div class="line">			<span class="keyword">int</span> temp=array[i];</div><div class="line">			array[i]=array[<span class="number">0</span>];</div><div class="line">			array[<span class="number">0</span>]=temp;</div><div class="line">			</div><div class="line">			<span class="comment">//此时最后一个元素就是最大的，因此我们对前面的元素继续构造大顶堆</span></div><div class="line">			max_heap_down(array, <span class="number">0</span>, i-<span class="number">1</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span>[] array=&#123;<span class="number">12</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">45</span>,<span class="number">1</span>,<span class="number">45</span>,<span class="number">6</span>,<span class="number">72</span>,<span class="number">4</span>&#125;;</div><div class="line">		heap_sort_asc(array);</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</div><div class="line">			System.out.println(array[i]);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h2><ul>
<li>[<a href="http://www.cnblogs.com/skywang12345/p/3610187.html" target="_blank" rel="external">http://www.cnblogs.com/skywang12345/p/3610187.html</a>] (<a href="http://www.cnblogs.com/skywang12345/p/3610187.html" target="_blank" rel="external">http://www.cnblogs.com/skywang12345/p/3610187.html</a>)</li>
<li><a href="http://www.cnblogs.com/skywang12345/p/3602162.html#a43" target="_blank" rel="external">http://www.cnblogs.com/skywang12345/p/3602162.html#a43</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;堆排序&quot;&gt;&lt;a href=&quot;#堆排序&quot; class=&quot;headerlink&quot; title=&quot;堆排序&quot;&gt;&lt;/a&gt;堆排序&lt;/h1&gt;&lt;h2 id=&quot;堆的定义&quot;&gt;&lt;a href=&quot;#堆的定义&quot; class=&quot;headerlink&quot; title=&quot;堆的定义&quot;&gt;&lt;/a&gt;堆的定
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://chenjiabing666.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://chenjiabing666.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>shell排序</title>
    <link href="http://chenjiabing666.github.io/2018/07/01/shell%E6%8E%92%E5%BA%8F/"/>
    <id>http://chenjiabing666.github.io/2018/07/01/shell排序/</id>
    <published>2018-07-01T05:59:09.000Z</published>
    <updated>2018-07-01T05:59:53.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shell-排序"><a href="#Shell-排序" class="headerlink" title="Shell 排序"></a>Shell 排序</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因DL．Shell于1959年提出而得名。</li>
<li>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</li>
<li><strong>该方法实质上是一种分组插入方法</strong></li>
<li>比较相隔较远距离（称为增量）的数，使得数移动时能跨过多个元素，则进行一次比[2] 较就可能消除多个元素交换。</li>
<li>D.L.shell于1959年在以他名字命名的排序算法中实现了这一思想。算法先将要排序的一组数按某个增量d分成若干组，每组中记录的下标相差d.对每组中全部元素进行排序，然后再用一个较小的增量对它进行，在每组中再进行排序。当增量减到1时，整个要排序的数被分成一组，排序完成。</li>
<li>一般的初次取序列的一半为增量，以后每次减半，直到增量为1。</li>
<li><strong>给定实例的shell排序的排序过程</strong></li>
<li>假设待排序文件有10个记录，其关键字分别是：49，38，65，97，76，13，27，49，55，04。增量序列的取值依次为：5，2，1</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">		<span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span> &#125;;</div><div class="line">		print(data);</div><div class="line">		shellSort(data, data.length);</div><div class="line">		print(data);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">    	shell排序的实现算法，原理就是使用不同的增量进行分组，之后对每个分组进行插入排序</div><div class="line">    */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> gap, i, j;</div><div class="line">		<span class="comment">//使用增量分割子序列，这里的gap就是增量，使用增量对数组进行分割</span></div><div class="line">		<span class="keyword">for</span> (gap = n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)</div><div class="line"></div><div class="line">		&#123;</div><div class="line">			<span class="comment">// 内层的两个循环对每一个子序列同时做直接插入排序</span></div><div class="line">			<span class="keyword">for</span> (i = gap; i &lt; n; i++)&#123;</div><div class="line">				<span class="keyword">int</span> insertNode=array[i];  <span class="comment">//待插入的数据</span></div><div class="line">				j=i-gap;   <span class="comment">//待插入数据的前一个下标</span></div><div class="line">				</div><div class="line">				<span class="comment">//循环结束的条件是insertNode&gt;=array[j],那么此时的insertNode需要插入的位置就是array[j+1]这个位置了</span></div><div class="line">				<span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;insertNode&lt;array[j])&#123;</div><div class="line">					array[j+gap]=array[j];   <span class="comment">//元素后移</span></div><div class="line">					j=j-gap;</div><div class="line">				&#125;</div><div class="line">				array[j+gap]=insertNode;   <span class="comment">//此时的array[j+gap]就是待插入的位置</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</div><div class="line">			System.out.print(data[i] + <span class="string">"\t"</span>);</div><div class="line">		&#125;</div><div class="line">		System.out.println();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Shell-排序&quot;&gt;&lt;a href=&quot;#Shell-排序&quot; class=&quot;headerlink&quot; title=&quot;Shell 排序&quot;&gt;&lt;/a&gt;Shell 排序&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://chenjiabing666.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://chenjiabing666.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL性能优化</title>
    <link href="http://chenjiabing666.github.io/2018/06/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://chenjiabing666.github.io/2018/06/26/MySQL性能优化/</id>
    <published>2018-06-26T14:59:48.000Z</published>
    <updated>2018-06-29T07:14:15.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL性能优化"><a href="#MySQL性能优化" class="headerlink" title="MySQL性能优化"></a>MySQL性能优化</h1><h2 id="查看数据库性能参数"><a href="#查看数据库性能参数" class="headerlink" title="查看数据库性能参数"></a>查看数据库性能参数</h2><ul>
<li><code>show status like &quot;value&quot;</code> ：value是要查询的参数值，常用的值如下：</li>
<li><img src="http://ono60m7tl.bkt.clouddn.com/sql1.png" alt=""></li>
</ul>
<h2 id="优化查询"><a href="#优化查询" class="headerlink" title="优化查询"></a>优化查询</h2><h3 id="分析查询语句"><a href="#分析查询语句" class="headerlink" title="分析查询语句"></a>分析查询语句</h3><ul>
<li>Mysql中提供<code>explain</code>和<code>describe</code>来分析查询语句</li>
<li>格式：<code>explain select selectStatemnt</code><ul>
<li><code>explain select * from user where id=1</code>;</li>
<li>查询结果如下：</li>
<li><img src="http://ono60m7tl.bkt.clouddn.com/sql2.png" alt=""></li>
</ul>
</li>
<li>查询的参数分析如下:</li>
</ul>
<p><img src="http://ono60m7tl.bkt.clouddn.com/sql3.png" alt=""></p>
<p><img src="http://ono60m7tl.bkt.clouddn.com/sql4.png" alt=""></p>
<p><img src="http://ono60m7tl.bkt.clouddn.com/sql5.png" alt=""></p>
<p><img src="http://ono60m7tl.bkt.clouddn.com/sql6.png" alt=""></p>
<p><img src="http://ono60m7tl.bkt.clouddn.com/sql7.png" alt=""></p>
<p><img src="http://ono60m7tl.bkt.clouddn.com/sql8.png" alt=""></p>
<p><img src="http://ono60m7tl.bkt.clouddn.com/sql9.png" alt=""></p>
<h3 id="使用索引查询的优化注意点"><a href="#使用索引查询的优化注意点" class="headerlink" title="使用索引查询的优化注意点"></a>使用索引查询的优化注意点</h3><ul>
<li>索引是可以提高查询速度，但是并不是使用带有索引的字段查询时，索引都能起作用</li>
<li>使用索引有几种特殊的情况，在这些特殊的情况下，有可能使用索引字段查询时，索引并没有起作用。下面会详细介绍</li>
</ul>
<h4 id="1-使用LIKE关键字查询"><a href="#1-使用LIKE关键字查询" class="headerlink" title="1. 使用LIKE关键字查询"></a>1. 使用LIKE关键字查询</h4><ul>
<li><strong>使用<code>Like</code>关键字查询的时候，如果匹配字符串的第一个字符为<code>%</code>，那么索引不会起作用。只有<code>%</code>不在第一个位置，索引才会起作用。</strong></li>
<li>我们使用<code>name</code>字段的索引<code>name_index</code>查询用户信息，如下<ul>
<li><code>explain select * from user where name like &quot;%a&quot;;</code> ： 我们看到查询出来的信息，字段<code>possible_keys</code>的值为<code>NULL</code>，这里表示没有使用<code>name</code>的索引<code>name_index</code>，并且这里的<code>rows</code>显示扫描的行数</li>
<li><code>explain select * from user where name like &quot;J%&quot;;</code> ：显示的<code>possible_keys</code>字段的值是<code>name_index</code>，表示使用了<code>name</code>字段的索引进行查询了</li>
</ul>
</li>
</ul>
<h4 id="2-使用组合索引查询"><a href="#2-使用组合索引查询" class="headerlink" title="2. 使用组合索引查询"></a>2. 使用组合索引查询</h4><ul>
<li><p><strong>匹配左前缀</strong>，只要使用了组合索引中的最左边的那个索引值进行查询，那么就会使用组合索引进行查询</p>
</li>
<li><p><strong>Mysql可以为多列创建索引，可以同时为16个字段创建索引。对于组合索引，只有查询条件中使用了这些字段的<code>第一个字段</code>时，才会使用索引查询。</strong></p>
</li>
<li>我们分析查询用户信息的语句，看看对于组合索引的使用<ol>
<li>创建组合索引<code>name_age_index</code> ：<code>create index name_age_index on user(name,age)</code></li>
<li>使用分析查询语句：<code>explain select * from user where age=22;</code>  ：这里查询没有使用第一个字段<code>name</code>字段查询，显示<code>possible_keys</code>为<code>NULL</code>表示没有相关索引</li>
<li>使用分析查询语句：<code>explain select * from user where name=&quot;Jack&quot;</code> ：这里使用了第一个字段进行查询，显示的<code>possible_keys</code>为<code>name_index</code>，<code>key</code>为<code>name_index</code>表示使用了<code>name_index</code>进行查询了</li>
<li><code>explain select * from user where name=&quot;Jack&quot; and age=22</code> ： 同样是使用了<code>name_index</code>索引进行查询</li>
</ol>
</li>
</ul>
<h4 id="3-使用or关键字查询语句"><a href="#3-使用or关键字查询语句" class="headerlink" title="3. 使用or关键字查询语句"></a>3. 使用or关键字查询语句</h4><ul>
<li>在查询条件中只有<code>or</code>关键字，并且<code>or</code>的前后的两个条件的列都是索引的时候，查询中才会使用索引，否则不使用索引。</li>
<li>我们仍然分析查询用户信息的语句，使用<code>OR</code>关键字查询<ul>
<li>为字段<code>age</code>创建索引：<code>create index age_index on user(age)</code></li>
<li>分析查询：<code>explain select * from user where id=1 or name=&quot;Jack&quot;;</code>  ：由于这里的<code>name</code>字段没有创建索引，显示的<code>key</code>为<code>NULL</code>表示该条查询语句并没有使用索引查询</li>
<li>分析查询：<code>explain select * from user where id=1 or age=22;</code> ：由于<code>id</code>和<code>age</code>都创建了索引并且<code>key</code>显示为<code>PRIMARY,age_index</code>，表示使用了索引查询</li>
</ul>
</li>
</ul>
<h4 id="4-索引排序"><a href="#4-索引排序" class="headerlink" title="4. 索引排序"></a>4. 索引排序</h4><ul>
<li>mysql查询只使用一个索引，<strong>因此如果<code>where子句</code>中已经使用了索引的话，那么<code>order by</code>中的列是不会使用索引的</strong>。因此数据库默认排序可以符合要求的情况下不要使用排序操作，尽量不要包含多个列的排序，如果需要最好给这些列建复合索引。</li>
</ul>
<h4 id="5-逻辑运算"><a href="#5-逻辑运算" class="headerlink" title="5. 逻辑运算"></a>5. 逻辑运算</h4><ul>
<li>不使用<code>NOT IN</code> 、<code>&lt;&gt;</code>、<code>！=</code>操作，但<code>&lt;</code>,<code>&lt;=</code>，<code>=</code>，<code>&gt;</code>,<code>&gt;=</code>,<code>BETWEEN</code>,<code>IN</code>是可以用到索引的</li>
</ul>
<h4 id="6-使用短索引"><a href="#6-使用短索引" class="headerlink" title="6. 使用短索引"></a>6. 使用短索引</h4><ul>
<li>对串列进行索引，如果可以就应该指定一个前缀长度。例如，如果有一个char（255）的列，如果在前10个或20个字符内，多数值是唯一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。</li>
</ul>
<h4 id="7-如何使用索引来排序"><a href="#7-如何使用索引来排序" class="headerlink" title="7. 如何使用索引来排序"></a>7. 如何使用索引来排序</h4><p>在排序操作中如果能使用到索引来排序，那么可以极大的提高排序的速度，要使用索引来排序需要满足以下两点即可。</p>
<ul>
<li>1、ORDER BY子句后的列顺序要与组合索引的列顺序一致，且所有排序列的排序方向（正序/倒序）需一致</li>
<li>2、所查询的字段值需要包含在索引列中，及满足覆盖索引</li>
</ul>
<p><strong>通过例子来具体分析</strong></p>
<p>在user_test表上创建一个组合索引</p>
<table>
<thead>
<tr>
<th>1</th>
<th>ALTER TABLE user_test ADD INDEX index_user(user_name , city , age);</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>可以使用到索引排序的案例</p>
<table>
<thead>
<tr>
<th>1234567</th>
<th>1、SELECT user_name, city, age FROM user_test ORDER BY user_name; 2、SELECT user_name, city, age FROM user_test ORDER BY user_name, city; 3、SELECT user_name, city, age FROM user_test ORDER BY user_name DESC, city DESC; 4、SELECT user_name, city, age FROM user_test WHERE user_name = ‘feinik’ ORDER BY city;</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>注：第4点比较特殊一点，如果where查询条件为索引列的第一列，且为常量条件，那么也可以使用到索引</p>
</blockquote>
<p>无法使用索引排序的案例</p>
<p>1、sex不在索引列中</p>
<table>
<thead>
<tr>
<th>1</th>
<th>SELECT user_name, city, age FROM user_test ORDER BY user_name, sex;</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>2、排序列的方向不一致</p>
<table>
<thead>
<tr>
<th>1</th>
<th>SELECT user_name, city, age FROM user_test ORDER BY user_name ASC, city DESC;</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>3、所要查询的字段列sex没有包含在索引列中</p>
<table>
<thead>
<tr>
<th>1</th>
<th>SELECT user_name, city, age, sex FROM user_test ORDER BY user_name;</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>4、where查询条件后的user_name为范围查询，所以无法使用到索引的其他列</p>
<table>
<thead>
<tr>
<th>1</th>
<th>SELECT user_name, city, age FROM user_test WHERE user_name LIKE ‘feinik%’ ORDER BY city;</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h3 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a>优化子查询</h3><ul>
<li>子查询就是一个<code>select</code>语句中嵌套多个<code>select</code>语句，虽然子查询使用起来方便灵活，但是执行的效率并不高。在执行子查询的时候需要为内层的查询语句结果建立一个临时表，然后外层的语句从临时表中查询数据。查询完毕之后再撤销临时表。因此子查询的速度会受到一定的影响。</li>
<li>在Mysql中，可以使用连接<code>Join</code>查询代替子查询，连接查询不需要建立临时表，速度要比子查询要快。如果查询中使用索引的话，性能会更好</li>
</ul>
<h2 id="优化数据库结构"><a href="#优化数据库结构" class="headerlink" title="优化数据库结构"></a>优化数据库结构</h2><h3 id="1-将字段很多的表分解成多个表"><a href="#1-将字段很多的表分解成多个表" class="headerlink" title="1. 将字段很多的表分解成多个表"></a>1. 将字段很多的表分解成多个表</h3><ul>
<li>对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。因为当一个表的数据量很大的时候，会由于使用频率低的字段存在而变慢。</li>
</ul>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ul>
<li>假设会员表（members）存储会员登录认证信息，该表中有很多字段，如<code>id</code>，姓名，密码，地址，电话，个人描述等字段。其中地址，电话，个人描述字段并不常用。我们可以将这些字段分离出来形成一张新的表（member_detail）。表中有<code>member_id</code>，<code>address</code>，<code>phone</code>，<code>description</code>。其中<code>member_id</code>表示会员编号和<code>members</code>表中的<code>id</code>字段值对应</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">create table members(</div><div class="line">	id int(11) primary key auto_increment,</div><div class="line">    name varchar(20) default null,</div><div class="line">    password varchar(20) default null,</div><div class="line">    last_login_time datetime default null,</div><div class="line">    last_login_ip varchar(100) default null</div><div class="line">);</div><div class="line"></div><div class="line">create table member_detail(</div><div class="line">	member_id int(11) not null default 0,</div><div class="line">    address varchar(100) default null,</div><div class="line">    phone varchar(16) default null,</div><div class="line">    description text</div><div class="line">);</div></pre></td></tr></table></figure>
<ul>
<li>如果我们需要查询会员信息，可以使用连接查询：<code>select * from members left join member_detail on members.id=member_detail.member_id;</code></li>
<li>通过这种分解可以提高查询效率，可以优化数据库的性能，因为我们大部分时间需要查询和操作的表就是<code>members</code></li>
</ul>
<h3 id="2-增加中间表"><a href="#2-增加中间表" class="headerlink" title="2. 增加中间表"></a>2. 增加中间表</h3><ul>
<li><strong>对于需要经常联合查询的表，可以使用建立中间表用以提高查询速度。通过建立中间表，把需要经常联合查询的数据插入到中间表中，然后把原来的联合查询改为对中间表的查询，以此来提高查询效率。</strong></li>
<li>假设有一个会员信息表(vip)，其中存储的是每一个会员的信息，还有一个会员组信息表（<code>vip_group</code>)其中存储的是会员组的信息，比如<code>名称</code>，<code>备注信息</code>。现在我们需要经常查询的是会员的名字及其所在会员组的信息，使用联合查询的语句如下：<ul>
<li><code>select vip.name,vg.name,vg.remark from vip left join vip_group on vip.groupId=vg.id</code></li>
</ul>
</li>
<li>我们可以添加一个中间表<code>temp_group</code>，表中存储的是会员名，会员组名称，会员组信息，我们将连接查询的结果添加到中间表中，那么我们以后就可以直接到中间表中查询了，不用每次都联合查询了。</li>
</ul>
<h3 id="3-增加冗余字段"><a href="#3-增加冗余字段" class="headerlink" title="3. 增加冗余字段"></a>3. 增加冗余字段</h3><ul>
<li>设计数据库的时候应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致优雅。但是，合理的增加冗余字段可以提高查询速度。</li>
<li>表的规范程度越高，表与表之间的关系就越多，需要连接查询的情况就越多。例如，员工信息表存储在staff表中，部门信息存储在department表中，通过staff表中的department_id字段与department建立联系。如果要查询一个员工所在部门的名称，必须从staff表中查找员工所在部门编号，然后根据这个编号从department表中查找部门的名称。如果经常需要进行这个操作，连接查询会浪费很多时间。此时我们可以在staff表中添加一个<code>department_name</code>字段，用来记录部门名称，这样就不需要每次连接操作了。</li>
<li>冗余字段会导致很多问题，比如字段的值在一个表中改变了，在另外一个表中也要更新这个数据，很可能造成数据不一致，因此要根据实际需要综合分析是否使用冗余字段</li>
</ul>
<p>##　优化插入记录的速度</p>
<ul>
<li>插入记录的时候，影响插入速度的只要是索引、唯一性校验、一次插入多条记录等。根据这些情况，可以分别进行优化</li>
</ul>
<h3 id="1-禁用唯一性检查"><a href="#1-禁用唯一性检查" class="headerlink" title="1. 禁用唯一性检查"></a>1. 禁用唯一性检查</h3><ul>
<li>插入数据之前执行<code>set unique_checks=0</code>来禁止对唯一性索引的检查，执行完成之后再执行<code>set unique_checks=1</code></li>
</ul>
<h3 id="2-禁用外键检查"><a href="#2-禁用外键检查" class="headerlink" title="2. 禁用外键检查"></a>2. 禁用外键检查</h3><ul>
<li>插入数据之前执行禁止外键检查，数据插入完成之后再恢复对外键的检查，语句如下：<ul>
<li><code>set foreign_key_checks=0</code> ：禁用</li>
<li><code>set foreign_key_checks=1</code> ：启用外键检查</li>
</ul>
</li>
</ul>
<h3 id="3-禁止自动提交"><a href="#3-禁止自动提交" class="headerlink" title="3. 禁止自动提交"></a>3. 禁止自动提交</h3><ul>
<li>插入数据之前禁止事务的自动提交，在数据插入完成之后，执行恢复自动提交<ul>
<li><code>set autocommit=0</code></li>
<li><code>set autocommit=1</code></li>
</ul>
</li>
</ul>
<h2 id="优化Mysql服务器"><a href="#优化Mysql服务器" class="headerlink" title="优化Mysql服务器"></a>优化Mysql服务器</h2><ul>
<li>对硬件的优化，对Mysql服务的参数进行优化</li>
</ul>
<h3 id="优化服务器硬件"><a href="#优化服务器硬件" class="headerlink" title="优化服务器硬件"></a>优化服务器硬件</h3><ul>
<li><img src="http://ono60m7tl.bkt.clouddn.com/sql11.png" alt=""></li>
</ul>
<h3 id="优化MySQL参数"><a href="#优化MySQL参数" class="headerlink" title="优化MySQL参数"></a>优化MySQL参数</h3><p><img src="http://ono60m7tl.bkt.clouddn.com/sql12.png" alt=""></p>
<p><img src="http://ono60m7tl.bkt.clouddn.com/sql13.png" alt=""></p>
<p><img src="http://ono60m7tl.bkt.clouddn.com/sql14.png" alt=""></p>
<p><img src="http://ono60m7tl.bkt.clouddn.com/sql15.png" alt=""></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="http://www.cnblogs.com/clsn/p/8214048.html" target="_blank" rel="external">http://www.cnblogs.com/clsn/p/8214048.html</a></li>
<li><a href="https://blog.csdn.net/u013087513/article/details/77899412" target="_blank" rel="external">https://blog.csdn.net/u013087513/article/details/77899412</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MySQL性能优化&quot;&gt;&lt;a href=&quot;#MySQL性能优化&quot; class=&quot;headerlink&quot; title=&quot;MySQL性能优化&quot;&gt;&lt;/a&gt;MySQL性能优化&lt;/h1&gt;&lt;h2 id=&quot;查看数据库性能参数&quot;&gt;&lt;a href=&quot;#查看数据库性能参数&quot; class
    
    </summary>
    
      <category term="数据库干货篇" scheme="http://chenjiabing666.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B2%E8%B4%A7%E7%AF%87/"/>
    
    
      <category term="SQL" scheme="http://chenjiabing666.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL触发器</title>
    <link href="http://chenjiabing666.github.io/2018/06/26/MySQL%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <id>http://chenjiabing666.github.io/2018/06/26/MySQL触发器/</id>
    <published>2018-06-26T14:58:57.000Z</published>
    <updated>2018-06-26T14:59:16.857Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL触发器"><a href="#MySQL触发器" class="headerlink" title="MySQL触发器"></a>MySQL触发器</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>MySQL的触发器和存储过程一样，都是嵌入到MysQL中的一段程序，不过触发器不要调用，而是由事件触发的，这些事件包括<code>insert</code>，<code>update</code>，<code>delete</code>语句，如果定义了触发程序，当数据执行这些语句的时候就会激发触发器执行相应的操作。</li>
</ul>
<h2 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h2><h3 id="创建一行执行语句的触发器"><a href="#创建一行执行语句的触发器" class="headerlink" title="创建一行执行语句的触发器"></a>创建一行执行语句的触发器</h3><ul>
<li>格式：<code>create trigger trigger_name trigger_time trigger_event on table for each row trigger_stmt</code><ul>
<li><code>trigger_name</code> ：触发器的名字</li>
<li><code>trigger_time</code>： 触发器触发的时机，取值为<code>before</code>，<code>after</code><ul>
<li><code>before</code>：表示在激发触发器的语句执行之前执行触发器的执行语句</li>
<li><code>after</code>：表示在激发触发器的语句执行之后执行触发器的执行语句</li>
</ul>
</li>
<li><code>trigger_event</code>：触发事件，取值为<code>insert</code>，<code>update</code>，<code>delete</code><ul>
<li><code>insert</code> ：比如Mysql中的<code>insert</code>和<code>replace</code>语句就会触发这个事件</li>
<li><code>update</code>：更新某一行的数据会激发这个事件，比如<code>update</code>语句</li>
<li><code>delete</code>：删除某一行的时候激发触发器，可能通过<code>delete</code>或者<code>replace</code>语句激发</li>
</ul>
</li>
<li><code>table</code>：标识建立触发器的表名，即是当那张表发生了<code>insert</code>，<code>update</code>，<code>delete</code>事件激发触发器</li>
<li><code>trigger_stmt</code>：触发器执行的语句<ul>
<li>执行语句中不能返回结果集</li>
</ul>
</li>
</ul>
</li>
<li>实例：<ul>
<li><code>new.age</code>：获取新插入的字段<code>age</code>的值</li>
<li><code>new.name</code> ： 获取新插入的<code>name</code>字段的值</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">-- 创建user表</div><div class="line">create table user(id int primary key auto_increment,name varchar(10),age int); </div><div class="line"></div><div class="line">-- 设置用户变量@sum，用于统计年龄</div><div class="line">set @sum=0;  </div><div class="line"></div><div class="line">-- 插入数据,将会在插入数据之前激发触发器，执行触发器中定义的语句，计算出插入的年龄总和赋值给@sum</div><div class="line">insert into user(name,age) values(&quot;Jack&quot;,22),(&quot;Tom&quot;,33);</div><div class="line"></div><div class="line">-- 创建触发器，insert事件，在user表插入数据之前执行语句，其中的new.age是获取插入的每一行的age字段的值</div><div class="line">create trigger sum before  insert on user for each row set @sum=@sum+new.age;</div></pre></td></tr></table></figure>
<h3 id="创建多行执行语句的触发器"><a href="#创建多行执行语句的触发器" class="headerlink" title="创建多行执行语句的触发器"></a>创建多行执行语句的触发器</h3><ul>
<li>格式：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">	create trigger trigger_name trigger_time trigger_event on table for each row</div><div class="line">		begin</div><div class="line">			-- 语句执行列表</div><div class="line">		end </div><div class="line">		//</div><div class="line">delimiter ;</div></pre></td></tr></table></figure>
<ul>
<li>实例<ul>
<li>如果修改的名字和已经存在的重复，那么就设置异常（主键冲突）取消后面的更新语句，不过这个一定要使用<code>before</code>的触发时间</li>
<li><strong><code>new.name</code> : 表示修改之后的<code>name</code>字段的值，如果没有修改，那么和之前的一样</strong></li>
<li><strong><code>old.name</code> ：表示修改之前的<code>name</code>字段的值</strong></li>
<li><strong>触发器不能撤销后面的操作，如果想要撤销操作可以制造异常，那么后面的语句就不会执行了，如下面的程序制造了主键冲突的异常</strong></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">-- 创建user表</div><div class="line">create table user(id int primary key auto_increment,name varchar(10),age int);</div><div class="line"></div><div class="line">-- 创建触发器</div><div class="line">delimiter //</div><div class="line">	create trigger testUpdate before update on user for each row </div><div class="line">		begin</div><div class="line">			declare total int default 0;  -- 创建一个total变量，统计数量</div><div class="line">			select count(*) from user where name=new.name into total;  -- 根据修改之后的name查询出数量赋值给total</div><div class="line">			if old.name!=new.name&amp;&amp;total!=0  -- count!=0并且确实修改了名字表示修改的名字重复</div><div class="line">				then set new.id=1;   -- 名字重复导致主键冲突抛出异常，这样后续的语句就不会执行了</div><div class="line">			end if;</div><div class="line">		end</div><div class="line">		//</div><div class="line">delimiter ;</div></pre></td></tr></table></figure>
<h2 id="查看触发器"><a href="#查看触发器" class="headerlink" title="查看触发器"></a>查看触发器</h2><h3 id="查看所有触发器"><a href="#查看所有触发器" class="headerlink" title="查看所有触发器"></a>查看所有触发器</h3><ul>
<li><code>show triggers [from database]</code>  ： 查看当前数据的所有的触发器 <ul>
<li><code>show triggers from test \G</code> : 查看<code>test</code>数据库中的所有触发器</li>
<li><code>show triggers \G</code> ： 有条理的显示所有触发器</li>
</ul>
</li>
</ul>
<h3 id="查看指定的触发器"><a href="#查看指定的触发器" class="headerlink" title="查看指定的触发器"></a>查看指定的触发器</h3><ul>
<li>如果需要查看指定的触发器，那么可以从<code>information_schema</code>数据库中的<code>triggers</code>表中查询指定的触发器<ul>
<li><code>select * from information_schema.triggers where trigger_name=&quot;testUpdate&quot;\G</code> <ul>
<li><code>where</code>后面是条件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h2><ul>
<li><code>drop db.trigger_name</code> : 删除指定数据库中的触发器<ul>
<li><code>db</code> ：数据库的名字</li>
<li><code>trigger_name</code> ：触发器的名字</li>
</ul>
</li>
</ul>
<h2 id="触发器执行的顺序"><a href="#触发器执行的顺序" class="headerlink" title="触发器执行的顺序"></a>触发器执行的顺序</h2><ul>
<li>我们建立的数据库一般都是<code>InnoDB</code>数据库，其上建立的表是事务性表，也就是事务安全的。这时，若SQL语句或触发器执行失败，MySQL 会回滚事务，有：<ul>
<li>如果 BEFORE 触发器执行失败，SQL 无法正确执行。</li>
<li>SQL 执行失败时，AFTER 型触发器不会触发。</li>
<li>AFTER 类型的触发器执行失败，SQL 会回滚。</li>
</ul>
</li>
</ul>
<h2 id="NEW-和-OLD"><a href="#NEW-和-OLD" class="headerlink" title="NEW 和 OLD"></a>NEW 和 OLD</h2><ul>
<li>在<code>INSERT</code> 型触发器中，<code>NEW</code>用来表示将要（<code>BEFORE</code>）或已经（<code>AFTER</code>）插入的新数据；</li>
<li>在<code>UPDATE</code>型触发器中，<code>OLD</code> 用来表示将要或已经被修改的原数据，<code>NEW</code> 用来表示将要或已经修改为的新数据；</li>
<li>在 <code>DELETE</code>型触发器中，<code>OLD</code> 用来表示将要或已经被删除的原数据；</li>
</ul>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ul>
<li><code>NEW/OLD.columName</code> : 比如获取更新后的<code>name</code>字段的值<ul>
<li><code>new.name</code></li>
</ul>
</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li><code>OLD</code> 是只读的，不可以使用<code>set</code>修改</li>
<li><code>new</code>是可以修改的，我们可以在触发器中使用<code>set</code>语句修改</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MySQL触发器&quot;&gt;&lt;a href=&quot;#MySQL触发器&quot; class=&quot;headerlink&quot; title=&quot;MySQL触发器&quot;&gt;&lt;/a&gt;MySQL触发器&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
      <category term="数据库干货篇" scheme="http://chenjiabing666.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B2%E8%B4%A7%E7%AF%87/"/>
    
    
      <category term="SQL" scheme="http://chenjiabing666.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中的锁</title>
    <link href="http://chenjiabing666.github.io/2018/06/26/MySQL%E4%B8%AD%E7%9A%84%E9%94%81/"/>
    <id>http://chenjiabing666.github.io/2018/06/26/MySQL中的锁/</id>
    <published>2018-06-26T14:58:12.000Z</published>
    <updated>2018-06-26T14:58:43.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL中的锁"><a href="#MySQL中的锁" class="headerlink" title="MySQL中的锁"></a>MySQL中的锁</h1><h2 id="数据库引擎"><a href="#数据库引擎" class="headerlink" title="数据库引擎"></a>数据库引擎</h2><ul>
<li>数据库的引擎分为<code>MyISAM</code>和<code>InnoDB</code>和其他的</li>
<li>不同的数据库引擎默认使用的锁是不同的</li>
<li><code>MyISAM</code>默认使用的是<strong>表级别锁</strong>，<code>InnoDB</code>默认使用的是<code>行级锁</code></li>
<li>我们在使用的时候，一般都是使用<code>InnoDB</code>，支持事务，事务安全等功能</li>
</ul>
<h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><ul>
<li><strong>表级锁</strong>：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</li>
<li><strong>行级锁</strong>：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li>
<li><strong>页面锁</strong>：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</li>
</ul>
<h2 id="InnoDB锁的模式"><a href="#InnoDB锁的模式" class="headerlink" title="InnoDB锁的模式"></a>InnoDB锁的模式</h2><ul>
<li>InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁。</li>
<li><p>行级锁和表级锁本来就有许多不同之处，另外，事务的引入也带来了一些新问题。</p>
</li>
<li><p><strong>默认使用的是行级锁</strong></p>
</li>
</ul>
<h3 id="1-事务（Transaction）及其ACID属性"><a href="#1-事务（Transaction）及其ACID属性" class="headerlink" title="1.事务（Transaction）及其ACID属性"></a>1.事务（Transaction）及其ACID属性</h3><ul>
<li><p>事务是由一组SQL语句组成的逻辑处理单元，事务具有4属性，通常称为事务的ACID属性。</p>
</li>
<li><p>原性性（Actomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</p>
</li>
<li>一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以操持完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。</li>
<li>隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。</li>
<li>持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。</li>
</ul>
<h3 id="2-并发事务带来的问题"><a href="#2-并发事务带来的问题" class="headerlink" title="2.并发事务带来的问题"></a>2.并发事务带来的问题</h3><ul>
<li><p>相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持可以支持更多的用户。但并发事务处理也会带来一些问题，主要包括以下几种情况。</p>
</li>
<li><p><strong>更新丢失</strong>（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题——最后的更新覆盖了其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改保存其更改副本的编辑人员覆盖另一个编辑人员所做的修改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题</p>
</li>
<li><strong>脏读</strong>（Dirty Reads）：一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读”。</li>
<li><strong>不可重复读</strong>（Non-Repeatable Reads）：一个事务在读取某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。</li>
<li><strong>幻读</strong>（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。</li>
</ul>
<h3 id="3-事务隔离级别"><a href="#3-事务隔离级别" class="headerlink" title="3.事务隔离级别"></a>3.事务隔离级别</h3><ul>
<li>在并发事务处理带来的问题中，“更新丢失”通常应该是完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据<strong>加必要的锁</strong>来解决，因此，防止更新丢失应该是应用的责任。</li>
<li>“脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。数据库实现事务隔离的方式，基本可以分为以下两种。</li>
<li>一种是在读取数据前，对其加锁，阻止其他事务对数据进行修改。</li>
<li><p>另一种是不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot），并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度，好像是数据库可以提供同一数据的多个版本，因此，这种技术叫做数据多版本并发控制（ＭultiVersion Concurrency Control，简称MVCC或MCC），也经常称为多版本数据库。</p>
</li>
<li><p>数据库的事务隔离级别越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的，同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。</p>
</li>
<li><p>为了解决“隔离”与“并发”的矛盾，ISO/ANSI SQL92定义了４个事务隔离级别，每个级别的隔离程度不同，允许出现的副作用也不同，应用可以根据自己业务逻辑要求，通过选择不同的隔离级别来平衡＂隔离＂与＂并发＂的矛盾</p>
</li>
</ul>
<h3 id="事务４种隔离级别比较"><a href="#事务４种隔离级别比较" class="headerlink" title="事务４种隔离级别比较"></a>事务４种隔离级别比较</h3><table>
<thead>
<tr>
<th>隔离级别/读数据一致性及允许的并发副作用</th>
<th>读数据一致性</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>未提交读（Read uncommitted）</td>
<td>最低级别，只能保证不读取物理上损坏的数据</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>已提交度（Read committed）</td>
<td>语句级</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可重复读（Repeatable read）</td>
<td>事务级</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>可序列化（Serializable）</td>
<td>最高级别，事务级</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody>
</table>
<h3 id="两种行级锁"><a href="#两种行级锁" class="headerlink" title="两种行级锁"></a>两种行级锁</h3><ol>
<li><p><strong>共享锁（S）</strong>：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁</p>
<ul>
<li><p><strong>共享锁好像只读锁，可以允许多个事务同时读这行数据，但是不允许修改（排他锁）</strong></p>
</li>
<li><p>如果一个事务获取共享锁了，那么其他事务只能获取这一行的共享锁，而不能获取这行的排他锁</p>
</li>
</ul>
</li>
<li><p><strong>排他锁（X）</strong>：允许获得排他锁的事务更新数据，但是组织其他事务获得相同数据集的共享锁和排他锁。</p>
<ul>
<li><strong>相当于只写锁，只能同时允许一个事务对该行数据的更新，并且也不允许其他的事务读这行的数据</strong></li>
<li>如果一个事务获取了这行数据的排他锁，那么其他的事务将不能获取这行数据的共享锁和排它锁，只有等待前一个事务释放才有机会获取</li>
</ul>
</li>
</ol>
<ul>
<li><strong>对于<code>UPDATE</code>、<code>DELETE</code>和<code>INSERT</code>语句，InnoDB会自动给涉及及数据集加排他锁（Ｘ）</strong></li>
<li><strong>对于普通<code>SELECT</code>语句，InnoDB不会任何锁；事务可以通过以下语句显示给记录集加共享锁或排锁。</strong><ul>
<li>共享锁（Ｓ）：<code>SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE</code></li>
<li>排他锁（X）：<code>SELECT * FROM table_name WHERE ... FOR UPDATE</code></li>
</ul>
</li>
</ul>
<h3 id="两种表级锁"><a href="#两种表级锁" class="headerlink" title="两种表级锁"></a>两种表级锁</h3><ul>
<li><strong>意向共享锁（IS）</strong>：表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的IS锁</li>
<li><strong>意向排他锁（IX）</strong>：类似上面，表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得该表的IX锁。</li>
<li><strong>意向锁是InnoDB自动加的，不需用户干预</strong></li>
</ul>
<h3 id="InnoDB行锁兼容模式"><a href="#InnoDB行锁兼容模式" class="headerlink" title="InnoDB行锁兼容模式"></a>InnoDB行锁兼容模式</h3><ul>
<li><strong>当一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之如果请求不兼容，则该事务就等待锁释放。</strong></li>
</ul>
<table>
<thead>
<tr>
<th>当前锁模式/是否兼容/请求锁模式</th>
<th>X</th>
<th>IX</th>
<th>S</th>
<th>IS</th>
</tr>
</thead>
<tbody>
<tr>
<td>X</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
</tr>
<tr>
<td>IX</td>
<td>冲突</td>
<td>兼容</td>
<td>冲突</td>
<td>兼容</td>
</tr>
<tr>
<td>S</td>
<td>冲突</td>
<td>冲突</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>IS</td>
<td>冲突</td>
<td>兼容</td>
<td>兼容</td>
<td>兼容</td>
</tr>
</tbody>
</table>
<h3 id="InnoDB行锁实现原理"><a href="#InnoDB行锁实现原理" class="headerlink" title="InnoDB行锁实现原理"></a>InnoDB行锁实现原理</h3><ul>
<li><strong>InnoDB行锁是通过给<code>索引项</code>加锁实现的，如果没有索引，InnoDB会通过隐藏的聚簇索引来对记录加锁。</strong></li>
<li><strong>也就是说：如果不通过索引条件检索数据，那么InnoDB将对表中所有数据加锁，实际效果跟表锁一样。</strong></li>
</ul>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul>
<li>我们知道数据库会为主键<code>id</code>创建唯一性索引，如果一个事务执行<code>select * from user where id=1 for update</code>，那么执行完成之后数据库仅仅是为<code>id=1</code>这行的数据添加<code>排他锁</code>，其他事务对其他行的数据还是可以获取共享锁和排他锁的，即是其他事务还是可以对其他行的数据执行增删改查的。但是对于<code>id=1</code>这行的数据只能<code>select</code>不能更新插入。如果执行了<code>update user set name=&quot;Jack&quot; where id=1</code>，会自动为<code>id=1</code>这行数据添加排他锁，其他的事务对改行数据不能做任何的操作（可以<code>select</code>），但是可以对其他行的数据仍然可以执行操作</li>
<li>此时如果一个事务执行了<code>update user set name=&quot;Jack&quot; where age=22</code>，因为<code>age</code>不是索引，那么会自动添加<code>表级锁</code>锁住<code>user</code>表中的全部数据，那么此时所有的数据在另外一个事务中只能查询了，不能执行更新和插入了</li>
<li>此时如果我们为<code>age</code>添加索引：<code>create index age_index on user(age)</code>，再执行<code>update user set name=&quot;Jack&quot; where age=22</code>，那么此时添加的就是<code>行级锁</code>，仅仅锁住的是<code>age=22</code>的那些行，另外的事务还是可以操作其他行的数据</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul>
<li>加入共享锁，<code>where id</code>，id默认是唯一索引</li>
<li><img src="https://www.2cto.com/uploadfile/Collfiles/20150810/20150810092332321.png" alt=""></li>
</ul>
<ul>
<li>排他锁的例子<ul>
<li>使用<code>select * from .... for update</code> 添加排他锁</li>
</ul>
</li>
<li><img src="https://www.2cto.com/uploadfile/Collfiles/20150810/20150810092333322.png" alt=""></li>
</ul>
<h3 id="行锁的三种情形"><a href="#行锁的三种情形" class="headerlink" title="行锁的三种情形"></a>行锁的三种情形</h3><ul>
<li><strong>以下的三种情形都是针对索引项的，不是索引项的会自动使用表级锁锁住全表</strong></li>
</ul>
<ol>
<li><strong>Record lock</strong> ：对<strong>索引项</strong>加锁，即锁定一条记录。</li>
<li><strong>Gap lock：</strong>对<strong>索引项</strong>之间的<code>间隙</code>、对第一条记录前的间隙或最后一条记录后的间隙加锁，即锁定一个范围的记录，不包含记录本身</li>
<li><strong>Next-key Lock</strong>：锁定一个范围的记录并包含记录本身（上面两者的结合）。</li>
</ol>
<h4 id="间隙锁（Next-Key锁）"><a href="#间隙锁（Next-Key锁）" class="headerlink" title="间隙锁（Next-Key锁）"></a>间隙锁（Next-Key锁）</h4><ul>
<li><p>只针对带有区间的操作，比如<code>&gt;30</code>或者<code>&lt;3</code>等</p>
</li>
<li><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙(GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制不是所谓的间隙锁（Next-Key锁）。</p>
</li>
<li><p>举例来说，假如emp表中只有101条记录，其<code>empid</code>（主键，唯一索引）的值分别是1,2,…,100,101，下面的SQL：</p>
<p><code>SELECT * FROM emp WHERE empid &gt; 100 FOR UPDATE</code></p>
</li>
<li><p>是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。</p>
</li>
<li><p>InnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求，对于上面的例子，要是不使用间隙锁，如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另一方面，是为了满足其恢复和复制的需要。有关其恢复和复制对机制的影响，以及不同隔离级别下InnoDB使用间隙锁的情况。</p>
</li>
<li><p>很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。</p>
</li>
</ul>
<h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><ul>
<li>我们给<code>age</code>添加了索引，那么在一个事务中执行<code>select * from user where age&gt;22 for update</code> 或者<code>update user set name=&quot;Jack&quot; where age&gt;22</code> ，都会为<code>user</code>表中<code>age&gt;22</code>这个区间的数据添加<code>间隙锁</code>那么只要<code>age</code>的范围在<code>22~positive infinity</code>之间的数据另外一个事务都不可以更新或者插入，在<code>age&lt;=22</code>之间的数据是可以操作的，比如<code>insert</code>，<code>update</code></li>
</ul>
<h3 id="什么时候使用表锁"><a href="#什么时候使用表锁" class="headerlink" title="什么时候使用表锁"></a>什么时候使用表锁</h3><ul>
<li><p>对于InnoDB表，在绝大部分情况下都应该使用行级锁，因为事务和行锁往往是我们之所以选择InnoDB表的理由。但在个另特殊事务中，也可以考虑使用表级锁。</p>
</li>
<li><p>第一种情况是：事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度。</p>
</li>
<li><p>第二种情况是：事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。</p>
</li>
<li><p>当然，应用中这两种事务不能太多，否则，就应该考虑使用ＭyISAＭ表。</p>
</li>
<li><p>在InnoDB下 ，使用表锁要注意以下两点。</p>
</li>
<li><p>（１）使用LOCK TALBES虽然可以给InnoDB加表级锁，但必须说明的是，表锁不是由InnoDB存储引擎层管理的，而是由其上一层ＭySQL Server负责的，仅当autocommit=0、innodb_table_lock=1（默认设置）时，InnoDB层才能知道MySQL加的表锁，ＭySQL Server才能感知InnoDB加的行锁，这种情况下，InnoDB才能自动识别涉及表级锁的死锁；否则，InnoDB将无法自动检测并处理这种死锁。</p>
</li>
<li><p>（２）在用LOCAK TABLES对InnoDB锁时要注意，要将AUTOCOMMIT设为0，否则ＭySQL不会给表加锁；事务结束前，不要用UNLOCAK TABLES释放表锁，因为UNLOCK TABLES会隐含地提交事务；COMMIT或ROLLBACK产不能释放用LOCAK TABLES加的表级锁，必须用UNLOCK TABLES释放表锁，正确的方式见如下语句。</p>
</li>
<li><p>例如，如果需要写表t1并从表t读，可以按如下做：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SET AUTOCOMMIT=0;</div><div class="line">LOCAK TABLES t1 WRITE, t2 READ, ...;</div><div class="line">[do something with tables t1 and here];</div><div class="line">COMMIT;</div><div class="line">UNLOCK TABLES;</div></pre></td></tr></table></figure>
<h3 id="关于死锁"><a href="#关于死锁" class="headerlink" title="关于死锁"></a>关于死锁</h3><ul>
<li>ＭyISAM表锁是deadlock free的，这是因为ＭyISAM总是一次性获得所需的全部锁，要么全部满足，要么等待，因此不会出现死锁。但是在InnoDB中，除单个SQL组成的事务外，锁是逐步获得的，这就决定了InnoDB发生死锁是可能的。</li>
<li>发生死锁后，InnoDB一般都能自动检测到，并使一个事务释放锁并退回，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及锁的情况下，InnoDB并不能完全自动检测到死锁，这需要通过设置锁等待超时参数innodb_lock_wait_timeout来解决。需要说明的是，这个参数并不是只用来解决死锁问题，在并发访问比较高的情况下，如果大量事务因无法立即获取所需的锁而挂起，会占用大量计算机资源，造成严重性能问题，甚至拖垮数据库。我们通过设置合适的锁等待超时阈值，可以避免这种情况发生。</li>
<li>通常来说，死锁都是应用设计的问题，通过调整业务流程、数据库对象设计、事务大小、以及访问数据库的SQL语句，绝大部分都可以避免。下面就通过实例来介绍几种死锁的常用方法。</li>
<li>（１）在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序为访问表，这样可以大大降低产生死锁的机会。如果两个session访问两个表的顺序不同，发生死锁的机会就非常高！但如果以相同的顺序来访问，死锁就可能避免。</li>
<li>（２）在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低死锁的可能。</li>
<li>（３）在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应该先申请共享锁，更新时再申请排他锁，甚至死锁。</li>
<li>（４）在REPEATEABLE-READ隔离级别下，如果两个线程同时对相同条件记录用SELECT…ROR UPDATE加排他锁，在没有符合该记录情况下，两个线程都会加锁成功。程序发现记录尚不存在，就试图插入一条新记录，如果两个线程都这么做，就会出现死锁。这种情况下，将隔离级别改成READ COMMITTED，就可以避免问题。</li>
<li>（５）当隔离级别为READ COMMITED时，如果两个线程都先执行SELECT…FOR UPDATE，判断是否存在符合条件的记录，如果没有，就插入记录。此时，只有一个线程能插入成功，另一个线程会出现锁等待，当第１个线程提交后，第２个线程会因主键重出错，但虽然这个线程出错了，却会获得一个排他锁！这时如果有第３个线程又来申请排他锁，也会出现死锁。对于这种情况，可以直接做插入操作，然后再捕获主键重异常，或者在遇到主键重错误时，总是执行ROLLBACK释放获得的排他锁。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>对于ＭyISAM的表锁，主要有以下几点</strong><br>（１）共享读锁（S）之间是兼容的，但共享读锁（S）和排他写锁（X）之间，以及排他写锁之间（X）是互斥的，也就是说读和写是串行的。</p>
<p>（２）在一定条件下，ＭyISAM允许查询和插入并发执行，我们可以利用这一点来解决应用中对同一表和插入的锁争用问题。</p>
<p>（３）ＭyISAM默认的锁调度机制是写优先，这并不一定适合所有应用，用户可以通过设置LOW_PRIPORITY_UPDATES参数，或在INSERT、UPDATE、DELETE语句中指定LOW_PRIORITY选项来调节读写锁的争用。</p>
<p>（４）由于表锁的锁定粒度大，读写之间又是串行的，因此，如果更新操作较多，ＭyISAM表可能会出现严重的锁等待，可以考虑采用InnoDB表来减少锁冲突。</p>
<p><strong>对于InnoDB表，主要有以下几点</strong></p>
<p>（１）InnoDB的行销是基于索引实现的，如果不通过索引访问数据，InnoDB会使用表锁。</p>
<p>（２）InnoDB间隙锁机制，以及InnoDB使用间隙锁的原因。</p>
<p>（３）在不同的隔离级别下，InnoDB的锁机制和一致性读策略不同。</p>
<p>（４）ＭySQL的恢复和复制对InnoDB锁机制和一致性读策略也有较大影响。</p>
<p>（５）锁冲突甚至死锁很难完全避免。</p>
<p><strong>在了解InnoDB的锁特性后，用户可以通过设计和SQL调整等措施减少锁冲突和死锁，包括：</strong></p>
<ul>
<li>尽量使用较低的隔离级别</li>
<li>精心设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会。</li>
<li>选择合理的事务大小，小事务发生锁冲突的几率也更小。</li>
<li>给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁。</li>
<li>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大减少死锁的机会。</li>
<li>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响。</li>
<li>不要申请超过实际需要的锁级别；除非必须，查询时不要显示加锁。</li>
<li>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="http://www.cnblogs.com/chenqionghe/p/4845693.html" target="_blank" rel="external">http://www.cnblogs.com/chenqionghe/p/4845693.html</a></li>
<li><a href="http://www.cnblogs.com/chenqionghe/p/4845693.html" target="_blank" rel="external">http://www.cnblogs.com/chenqionghe/p/4845693.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MySQL中的锁&quot;&gt;&lt;a href=&quot;#MySQL中的锁&quot; class=&quot;headerlink&quot; title=&quot;MySQL中的锁&quot;&gt;&lt;/a&gt;MySQL中的锁&lt;/h1&gt;&lt;h2 id=&quot;数据库引擎&quot;&gt;&lt;a href=&quot;#数据库引擎&quot; class=&quot;headerlink
    
    </summary>
    
      <category term="数据库干货篇" scheme="http://chenjiabing666.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B2%E8%B4%A7%E7%AF%87/"/>
    
    
      <category term="SQL" scheme="http://chenjiabing666.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Mysql存储过程和存储函数</title>
    <link href="http://chenjiabing666.github.io/2018/06/26/Mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0/"/>
    <id>http://chenjiabing666.github.io/2018/06/26/Mysql存储过程和存储函数/</id>
    <published>2018-06-26T14:56:37.000Z</published>
    <updated>2018-06-26T14:57:55.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql存储过程和存储函数"><a href="#Mysql存储过程和存储函数" class="headerlink" title="Mysql存储过程和存储函数"></a>Mysql存储过程和存储函数</h1><h2 id="存储过程的好处"><a href="#存储过程的好处" class="headerlink" title="存储过程的好处"></a>存储过程的好处</h2><ul>
<li><strong>增强SQL语言的功能和灵活性</strong>：存储过程可以用控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。</li>
<li><strong>标准组件式编程</strong>：存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。而且数据库专业人员可以随时对存储过程进行修改，对应用程序源代码毫无影响。</li>
<li><strong>较快的执行速度</strong>：如果某一操作包含大量的Transaction-SQL代码或分别被多次执行，那么存储过程要比批处理的执行速度快很多。因为存储过程是预编译的。在首次运行一个存储过程时查询，优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的Transaction-SQL语句在每次运行时都要进行编译和优化，速度相对要慢一些。</li>
<li>减少网络流量：针对同一个数据库对象的操作（如查询、修改），如果这一操作所涉及的Transaction-SQL语句被组织进存储过程，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而大大减少网络流量并降低了网络负载。</li>
<li>作为一种安全机制来充分利用：通过对执行某一存储过程的权限进行限制，能够实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全。</li>
</ul>
<h2 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h2><h3 id="创建存储函数"><a href="#创建存储函数" class="headerlink" title="创建存储函数"></a>创建存储函数</h3><ul>
<li>在Mysql中有许多已经存在的存储函数，比如<code>CONCAT(..)</code>,<code>LENGTH(str)</code>。但是我们也可以自己定义存储函数。</li>
<li>格式如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">delimiter //    -- 指定分割符</div><div class="line">	create function fun_name()</div><div class="line">	returns type     -- type是执行存储函数返回的类型</div><div class="line">	begin </div><div class="line">	-- 执行其他的语句</div><div class="line">	return ();   -- 返回的数据</div><div class="line">	end</div><div class="line">	//</div><div class="line"></div><div class="line">delimiter ;  -- 指定创建结束</div></pre></td></tr></table></figure>
<ul>
<li><code>returns type</code> : 指定存储函数返回的类型，比如<code>returns char(50)</code>,<code>returns int</code></li>
<li><strong>存储函数有且只有一个返回值</strong></li>
<li><code>return ()</code> : 存储函数的返回值，这里的返回值类型需要和<code>returns type</code>中的类型一致，如果不一致会强制转换<ul>
<li><code>return (select name from user where id=1);</code></li>
</ul>
</li>
<li>下面我们创建一个存储函数，返回<code>user</code>表中的<code>id=1</code>的<code>name</code>值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">	create function selectUserById()</div><div class="line">	returns varchar(50) </div><div class="line">	begin </div><div class="line">	return (select name from user where id=1);</div><div class="line">	end</div><div class="line">	//</div><div class="line">	delimiter ;</div></pre></td></tr></table></figure>
<h4 id="指定参数"><a href="#指定参数" class="headerlink" title="指定参数"></a>指定参数</h4><ul>
<li><strong>在存储函数创建的时候还可以指定参数，这个参数是用户调用的时候输入的。</strong></li>
<li><strong>存储函数中的参数默认是<code>IN</code>参数，而存储过程中的参数可以是<code>IN</code>、<code>OUT</code>、<code>INOUT</code></strong></li>
<li>直接使用<code>parameter 类型</code>指定即可，如果有多个参数可以使用<code>,</code>分割</li>
<li>在调用的时候直接使用<code>select funName(parmeter1,....);</code>即可</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">	create function selectUserById(uid int)</div><div class="line">	returns varchar(50) </div><div class="line">	begin </div><div class="line">	return (select name from user where id=uid);</div><div class="line">	end</div><div class="line">	//</div><div class="line">	delimiter ;</div></pre></td></tr></table></figure>
<h3 id="调用存储函数"><a href="#调用存储函数" class="headerlink" title="调用存储函数"></a>调用存储函数</h3><ul>
<li>存储函数是依赖数据库的，因此我们需要在指定的数据库中调用，或者前面指定数据库的名称<ul>
<li><code>select selectUserById();</code>  : 直接在存储函数所在数据库中调用</li>
<li><code>select dbName.selectUserById();</code>  : 直接使用数据库的名称调用</li>
</ul>
</li>
</ul>
<h3 id="删除存储函数"><a href="#删除存储函数" class="headerlink" title="删除存储函数"></a>删除存储函数</h3><ul>
<li><code>drop function selectUserById;</code> ：直接在存储函数所在数据库中直接删除存储函数</li>
<li><code>drop function dbName.selectUserById;</code> ：使用数据库名称删除存储函数</li>
</ul>
<h3 id="查看存储函数状态"><a href="#查看存储函数状态" class="headerlink" title="查看存储函数状态"></a>查看存储函数状态</h3><ul>
<li>格式：<code>show function status [like pattern]</code>    ： 查看存储函数的状态<ul>
<li><code>show function status \G</code> : 查看所有的存储函数状态,<code>\G</code>是一种特定格式的输出</li>
<li><code>show function status like &#39;select%&#39;\G</code> ：查看<code>select</code>开头的存储函数状态，<code>\G</code>是一种特定格式的输入。</li>
</ul>
</li>
</ul>
<h3 id="查看存储函数的定义"><a href="#查看存储函数的定义" class="headerlink" title="查看存储函数的定义"></a>查看存储函数的定义</h3><ul>
<li>格式：<code>show create function dbName.funName</code><ul>
<li><code>show create function test.selectUserById \G;</code>  ：查询<code>test</code>数据库中的存储函数<code>selectUserById</code>的定义，<code>\G</code>是一种特定的输出格式</li>
</ul>
</li>
</ul>
<h3 id="修改存储函数"><a href="#修改存储函数" class="headerlink" title="修改存储函数"></a>修改存储函数</h3><p><img src="http://ono60m7tl.bkt.clouddn.com/storefunction1.png" alt=""></p>
<h2 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h2><ul>
<li>变量的作用范围是<code>begin.....end</code>程序中</li>
</ul>
<h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><ul>
<li>格式：<code>declare var_name,.... type [default value]</code> <ul>
<li><code>declare age int default 22</code> ：定义一个<strong>局部变量</strong><code>age</code>，类型为<code>int</code>，默认值为<code>22</code></li>
<li><code>declare var1,var2,var3 int</code> ： 定义三个<strong>局部变量</strong>，类型为<code>int</code></li>
</ul>
</li>
<li><strong>全部变量的声明一定要在赋值的前面，否则报错</strong></li>
</ul>
<h3 id="定义用户变量"><a href="#定义用户变量" class="headerlink" title="定义用户变量"></a>定义用户变量</h3><ul>
<li>用户变量以<code>@</code>开头</li>
<li><code>set @pin=10</code></li>
</ul>
<h3 id="为变量赋值"><a href="#为变量赋值" class="headerlink" title="为变量赋值"></a>为变量赋值</h3><ul>
<li>格式：<code>set var1=value1,[var2=value2,....]</code><ul>
<li><code>set age=33;</code> ： 设置age的值为33</li>
<li><code>set var1=22,var2=33</code>: 同时设置多个值</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">declare var1,var2,var3 int;</div><div class="line">set var1=22,var2=33;</div><div class="line">set var3=var1+var2;</div></pre></td></tr></table></figure>
<ul>
<li>使用<code>select col_name[,...] into var_name[,....]  table_expr</code> : 使用<code>select</code>查询得到的结果赋值给变量<ul>
<li>这个<code>select</code>把选定的列的值直接赋值给对应位置的变量</li>
<li><code>table_expr</code>: 可以是表的查询条件，其中包含<code>from 表名</code></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">declare uname varchar(10);  -- 定义变量uname</div><div class="line">declare uage int;    -- 定义变量uage</div><div class="line">select name,age into uname,uage from user where id=1;  -- 将id=1的用户姓名和年龄赋值给变量</div></pre></td></tr></table></figure>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="在存储函数中使用"><a href="#在存储函数中使用" class="headerlink" title="在存储函数中使用"></a>在存储函数中使用</h4><ul>
<li>在存储函数中定义局部变量，并且获取输出</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">	create function selectUserById(uid int)</div><div class="line">	returns varchar(50) </div><div class="line">	begin </div><div class="line">	declare uname varchar(50);</div><div class="line">	select name into uname from user where id=uid;</div><div class="line">	return uname;</div><div class="line">	end</div><div class="line">	//</div><div class="line">	delimiter ;</div></pre></td></tr></table></figure>
<h4 id="在存储过程中使用"><a href="#在存储过程中使用" class="headerlink" title="在存储过程中使用"></a>在存储过程中使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">	create procedure selectUserById(IN uid int)</div><div class="line">		begin</div><div class="line">			declare offest,count int;   -- 定义偏移量</div><div class="line">			set offest=0,count=2;       -- 赋值</div><div class="line">			if uid is not null          -- 如果uid不为null，按照id查询</div><div class="line">				then select * from user where id=uid;  -- 按照id查询</div><div class="line">				else select * from user limit offest,count;  -- 否则uid为null，按照分页查询前面两个</div><div class="line">			end if;</div><div class="line">		end </div><div class="line">		//</div><div class="line">delimiter ;</div></pre></td></tr></table></figure>
<ul>
<li><code>call selectUserById(1)</code>;  ： 查询<code>id=1</code>的用户信息</li>
<li><code>call selectUserById(null);</code>  ：查询所有的用户信息，显示前面两个</li>
</ul>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul>
<li>MySQL存储过程可使用两种风格的注释：<ul>
<li>双杠：–，该风格一般用于单行注释</li>
<li>C风格： 一般用于多行注释</li>
</ul>
</li>
</ul>
<h2 id="流程控制标签的使用"><a href="#流程控制标签的使用" class="headerlink" title="流程控制标签的使用"></a>流程控制标签的使用</h2><ul>
<li>在<code>begin</code>和<code>end</code>之间使用</li>
</ul>
<h3 id="IF-THEN-ELSEIF-ELSE-ENDIF"><a href="#IF-THEN-ELSEIF-ELSE-ENDIF" class="headerlink" title="IF - THEN - ELSEIF - ELSE -ENDIF"></a>IF - THEN - ELSEIF - ELSE -ENDIF</h3><ul>
<li>格式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">begin</div><div class="line">	if expression   -- 判断条件</div><div class="line">    	then .... ;   -- 条件成立执行</div><div class="line">    	elseif .....;   -- 其他条件</div><div class="line">    	else ..... ;  -- 条件相反执行</div><div class="line">    endif;   		  -- 结束if</div><div class="line">end</div></pre></td></tr></table></figure>
<ul>
<li><p>可以不是成对出现，比如只有<code>if</code>，或者<code>if-else</code></p>
</li>
<li><p><strong>如果没有<code>else</code>，那么可以省略，比如<code>if - then - endif</code></strong></p>
</li>
<li>判断相等使用<code>=</code></li>
</ul>
<ul>
<li>实例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">	create procedure selectUserById(IN uid int)</div><div class="line">		begin</div><div class="line">			declare offest,count int;   -- 定义偏移量</div><div class="line">			set offest=0,count=2;       -- 赋值</div><div class="line">			if uid is not null          -- 如果uid不为null，按照id查询</div><div class="line">				then select * from user where id=uid;  -- 按照id查询</div><div class="line">				else select * from user limit offest,count;  -- 否则uid为null，按照分页查询前面两个</div><div class="line">			end if;</div><div class="line">		end </div><div class="line">		//</div><div class="line">delimiter ;</div></pre></td></tr></table></figure>
<h3 id="CASE-WHEN-THEN-ELSE-END-CASE"><a href="#CASE-WHEN-THEN-ELSE-END-CASE" class="headerlink" title="CASE - WHEN - THEN - ELSE - END CASE"></a>CASE - WHEN - THEN - ELSE - END CASE</h3><ul>
<li>这个和java中的<code>switch-case-default</code>相似</li>
<li>格式：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">case expr</div><div class="line">	when value1 then ....;</div><div class="line">	when value2  then .....;</div><div class="line">	when......;</div><div class="line">	....</div><div class="line">	else  .......;</div><div class="line">end case;</div></pre></td></tr></table></figure>
<ul>
<li>实例<ul>
<li>创建一个存储过程，使用<code>case</code></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">	create procedure deleteUserById(IN uid int)</div><div class="line">		begin</div><div class="line">			case uid   -- uid做选择</div><div class="line">				when 1   -- uid==1</div><div class="line">					then delete from user where id=1;   </div><div class="line">				when 2   -- uid==2</div><div class="line">					then delete from user where id=2;</div><div class="line">				else   </div><div class="line">					delete from user;	  -- 删除全部</div><div class="line">			end case;</div><div class="line">		end;</div><div class="line">		//</div><div class="line">delimiter ;</div></pre></td></tr></table></figure>
<h3 id="LOOP-ENDLOOP"><a href="#LOOP-ENDLOOP" class="headerlink" title="LOOP - ENDLOOP"></a>LOOP - ENDLOOP</h3><ul>
<li><code>LOOP</code>只是创建一个循环执行的过程，并不进行条件判断，这个和<code>while</code>不一样，不需要判断条件，如果不跳出，那么将会永远的执行的下去。<strong>但是我们可以使用<code>leave</code>跳出循环</strong></li>
<li>格式：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[LOOP_LABEL]:LOOP</div><div class="line">	statement;</div><div class="line">END LOOP [LOOP_LABEL];</div></pre></td></tr></table></figure>
<ul>
<li>实例<ul>
<li>执行这个语句可以插入<code>9</code>条数据，如果<code>i&gt;=10</code>跳出循环</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">	create procedure insertUserByName(IN uname varchar(50))</div><div class="line">		begin	</div><div class="line">			declare i int default 0;</div><div class="line">			add_loop:loop  -- 开始循环</div><div class="line">				set i=i+1;  -- id++操作</div><div class="line">				insert into user(name) values(uname);  -- 插入语句</div><div class="line">				if i&gt;=10</div><div class="line">					then leave add_loop;   -- 使用leave跳出循环</div><div class="line">				end if;</div><div class="line">			end loop add_loop;   -- 结束循环</div><div class="line">		end</div><div class="line">		//</div><div class="line">delimiter ;</div></pre></td></tr></table></figure>
<h3 id="LEAVE"><a href="#LEAVE" class="headerlink" title="LEAVE"></a>LEAVE</h3><ul>
<li>和循环一起使用，用于退出循环控制，见上面的例子</li>
</ul>
<h3 id="ITERATE"><a href="#ITERATE" class="headerlink" title="ITERATE"></a>ITERATE</h3><ul>
<li><p>格式：<code>iterate label</code></p>
</li>
<li><p><code>iterate</code>只可以出现在<code>LOOP</code>，<code>REPEAT</code>，<code>WHIE</code>语句内，表示再次循环的意思，<code>label</code>表示循环的标志</p>
</li>
<li>实例<ul>
<li>如果<code>p&lt;10</code>重复执行<code>p++</code></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">	create procedure doiterate()</div><div class="line">		begin	</div><div class="line">			declare p int default 0;  -- 定义局部变量</div><div class="line">			my_loop:loop</div><div class="line">				set p=p+1;  -- p++</div><div class="line">                if p&lt;10 </div><div class="line">                	then iterate my_loop;  -- 继续执行前面的循环的语句，p++</div><div class="line">                elseif p&gt;20</div><div class="line">                	then leave my_loop;</div><div class="line">                end if</div><div class="line">        			select &quot;p在10到20之间&quot;   -- 输出语句</div><div class="line">			end loop my_loop;</div><div class="line">		end</div><div class="line">		//</div><div class="line">delimiter ;</div></pre></td></tr></table></figure>
<h3 id="REPEAT"><a href="#REPEAT" class="headerlink" title="REPEAT"></a>REPEAT</h3><ul>
<li>这个也是循环语句，相当于<code>do-while</code></li>
<li>格式：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[repeat_loop]: repeat</div><div class="line">	statement_list;</div><div class="line">	until exper    -- 没有分号</div><div class="line">	end repeat;</div></pre></td></tr></table></figure>
<ul>
<li>实例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">	create procedure dorepeat()</div><div class="line">		begin	</div><div class="line">			declare p int default 0;  -- 定义局部变量</div><div class="line">			my_loop:repeat</div><div class="line">				set p=p+1;</div><div class="line">				select p;</div><div class="line">				until p&gt;10  -- 当p&gt;10的时候循环结束</div><div class="line">			end repeat my_loop;</div><div class="line">		end</div><div class="line">		//</div><div class="line">delimiter ;</div></pre></td></tr></table></figure>
<h3 id="WHILE"><a href="#WHILE" class="headerlink" title="WHILE"></a>WHILE</h3><ul>
<li>这个和<code>REPEAT</code>不同，先进行判断，然后才执行语句</li>
<li>格式：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[while_label]:while expr do</div><div class="line">	statement_list;</div><div class="line">	end while [while_lable];</div></pre></td></tr></table></figure>
<ul>
<li>实例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">	create procedure dowhile()</div><div class="line">		begin	</div><div class="line">			declare p int default 0;  -- 定义局部变量</div><div class="line">			my_loop:while p&lt;10  do   -- 满足条件才执行</div><div class="line">				set p=p+1;   -- p++</div><div class="line">			end while my_loop;    -- 结束循环</div><div class="line">		end</div><div class="line">		//</div><div class="line">delimiter ;</div></pre></td></tr></table></figure>
<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><ul>
<li>存储过程没有返回值</li>
</ul>
<h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><ul>
<li>格式：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">create procedure p_name([IN,OUT,INOUT]parameter 类型.....)</div><div class="line">	begin</div><div class="line">	-- 执行功能</div><div class="line">	end</div><div class="line">	//</div><div class="line">delimiter ;</div></pre></td></tr></table></figure>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li>存储过程根据需要可能会有输入、输出、输入输出参数，如果有多个参数用”,”分割开。MySQL存储过程的参数用在存储过程的定义，共有三种参数类型,IN,OUT,INOUT:<ul>
<li><strong>IN</strong>参数的值必须在调用存储过程时指定，在存储过程中修改该参数的值不能被返回，为默认值</li>
<li><strong>OUT</strong>:该值可在存储过程内部被改变，并可返回</li>
<li><strong>INOUT</strong>:调用时指定，并且可被改变和返回</li>
</ul>
</li>
</ul>
<h3 id="过程体"><a href="#过程体" class="headerlink" title="过程体"></a>过程体</h3><ul>
<li>过程体的开始与结束使用<code>BEGIN</code>与<code>END</code>进行标识。</li>
</ul>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><ul>
<li>定义一个根据<code>id</code>查询的查询用户信息的存储过程，这里的id是由用户输入的，因此可以使用<code>IN</code>参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">	create procedure selectUserById(IN uid int)</div><div class="line">		begin</div><div class="line">			select * from user where id=uid;</div><div class="line">		end</div><div class="line">		//</div><div class="line">delimiter ;</div></pre></td></tr></table></figure>
<h3 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h3><ul>
<li>格式：<code>call procedure_name(...)</code><ul>
<li><code>call selectUserById(1);</code>  :  直接在当前的数据库中调用存储过程<code>selectUserById</code></li>
<li><code>call db_name.selectUsrById(1)</code> : 指定数据库的名字调用</li>
</ul>
</li>
</ul>
<h3 id="查看存储过程的状态"><a href="#查看存储过程的状态" class="headerlink" title="查看存储过程的状态"></a>查看存储过程的状态</h3><ul>
<li>格式：<code>show procedure status like pattern \G</code><ul>
<li><code>show procedure status like &quot;select%&quot;\G</code> : 查看<code>select</code>开头的存储过程状态</li>
<li><code>show procedure status \G</code> : 查看所有的存储过程状态</li>
</ul>
</li>
<li>查询的结果如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">*************************** 1. row ***************************</div><div class="line">                  Db: test   -- 数据库名称</div><div class="line">                Name: selectUserById     -- 存储过程的名字</div><div class="line">                Type: PROCEDURE  </div><div class="line">             Definer: root@localhost</div><div class="line">            Modified: 2018-06-25 22:25:44</div><div class="line">             Created: 2018-06-25 22:25:44</div><div class="line">       Security_type: DEFINER</div><div class="line">             Comment: </div><div class="line">character_set_client: utf8</div><div class="line">collation_connection: utf8_general_ci</div><div class="line">  Database Collation: utf8_general_ci</div><div class="line">1 row in set (0.01 sec)</div></pre></td></tr></table></figure>
<h3 id="查看存储过程的定义"><a href="#查看存储过程的定义" class="headerlink" title="查看存储过程的定义"></a>查看存储过程的定义</h3><ul>
<li>格式：<code>show create procedure  db.pro_name</code><ul>
<li><code>show create procedure test.selectUserById\G</code> : 查询数据库<code>test</code>中存储过程的定义</li>
</ul>
</li>
<li>返回的结果如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">*************************** 1. row ***************************</div><div class="line">           Procedure: selectUserById</div><div class="line">            sql_mode: ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</div><div class="line">    Create Procedure: CREATE DEFINER=`root`@`localhost` PROCEDURE `selectUserById`(IN uid int)</div><div class="line">begin</div><div class="line">select * from user where id=uid;</div><div class="line">end</div><div class="line">character_set_client: utf8</div><div class="line">collation_connection: utf8_general_ci</div><div class="line">  Database Collation: utf8_general_ci</div></pre></td></tr></table></figure>
<h3 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h3><ul>
<li>格式<code>drop procedure pro_name</code><ul>
<li><code>drop procedure selectUserById</code> : 删除当前数据库的<code>selectUserById</code>的存储过程</li>
<li><code>drop procedure test.selectUserById;</code>: 删除<code>test</code>数据库的<code>selectUserById</code>的存储过程</li>
</ul>
</li>
</ul>
<h2 id="游标cursor"><a href="#游标cursor" class="headerlink" title="游标cursor"></a>游标cursor</h2><ul>
<li>在面对大量的数据的时候，游标能够一行一行的读取数据</li>
</ul>
<h3 id="声明游标"><a href="#声明游标" class="headerlink" title="声明游标"></a>声明游标</h3><ul>
<li>格式：<code>declare cursor_name cursor for select_statement</code><ul>
<li><code>cursor_name</code> : 游标的变量名称</li>
<li><code>select_statement</code> ：表示<code>select</code>语句，用于返回一个结果集给游标</li>
</ul>
</li>
<li>比如： <code>declare users cursor for select name,age from user;</code></li>
</ul>
<h3 id="打开游标"><a href="#打开游标" class="headerlink" title="打开游标"></a>打开游标</h3><ul>
<li>格式：<code>open cursor_name;</code> <ul>
<li><code>open users</code></li>
</ul>
</li>
</ul>
<h3 id="使用游标获取一行数据"><a href="#使用游标获取一行数据" class="headerlink" title="使用游标获取一行数据"></a>使用游标获取一行数据</h3><ul>
<li>格式：<code>fetch cursor_name into var_name[,var_name,...]</code><ul>
<li><code>cursor_name</code>：表示游标的名称</li>
<li><code>var_name</code> ： 表示将<code>select</code>语句查询到的一行信息存入到该参数中，<strong><code>var_name</code>必须在声明游标之前定义好</strong></li>
</ul>
</li>
<li>比如： <code>fetch user into uname,uage</code></li>
</ul>
<h3 id="关闭游标"><a href="#关闭游标" class="headerlink" title="关闭游标"></a>关闭游标</h3><ul>
<li>格式：<code>close cursor_name</code></li>
</ul>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><ul>
<li>使用游标获取<code>user</code>表中的一行数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">    create procedure selectOneUser()</div><div class="line">        begin</div><div class="line">        	declare uname varchar(50);  -- 定义uname存储</div><div class="line">        	declare uage int;   -- 定义uage存储</div><div class="line">        	declare users cursor for select name,age from user; -- 声明游标</div><div class="line">        	open users;      -- 打开游标</div><div class="line">        	fetch users into uname,uage;  -- 获取一行数据到存储到uname和uage中</div><div class="line">        	select uname as name,uage as age;    -- 输出一行的结果</div><div class="line">        	close users;    -- 关闭游标</div><div class="line">        end</div><div class="line">        //</div><div class="line">delimiter ;</div><div class="line"></div><div class="line">call selectOneUser();  -- 调用存储过程，此时只是输出第一行的数据</div></pre></td></tr></table></figure>
<ul>
<li>使用循环获取所有的数据<ul>
<li><strong>这里使用循环获取，首先需要使用<code>select count(*)</code>获取总数</strong></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">    create procedure selectUsers()</div><div class="line">        begin</div><div class="line">        	declare uname varchar(50);  -- 定义uname存储</div><div class="line">        	declare uage int;   -- 定义uage存储</div><div class="line">        	declare total int default 0;  -- 定义count，这个用来统计总数</div><div class="line">        	declare i int default 1;  -- 用来循环</div><div class="line">        	declare users cursor for select name,age from user; -- 声明游标</div><div class="line">        	select count(*) from user into total;   -- 查询总数</div><div class="line">        	open users;      -- 打开游标</div><div class="line">        	-- 开始循环遍历</div><div class="line">    		my_loop:while i&lt;=total do</div><div class="line">                set i=i+1;  -- i++</div><div class="line">                fetch users into uname,uage;  -- 获取一行数据到存储到uname和uage中</div><div class="line">                select uname as name,uage as age;    -- 输出一行的结果</div><div class="line">    		end while my_loop;</div><div class="line">        	close users;    -- 关闭游标</div><div class="line">        end</div><div class="line">        //</div><div class="line">delimiter ;</div><div class="line"></div><div class="line">call selectUsers();  -- 调用存储过程，获取全部数据</div></pre></td></tr></table></figure>
<ul>
<li>使用<code>HANDLER</code>判断游标是否还有元素<ul>
<li><code>continue HANDLER for not found</code></li>
<li>当游标中没有值的时候就会指定返回的值</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">    create procedure selectUsers()</div><div class="line">        begin</div><div class="line">        	declare uname varchar(50);  -- 定义uname存储</div><div class="line">        	declare uage int;   -- 定义uage存储</div><div class="line">        	declare flag int default 1;  -- 创建结束游标的标志，默认值为1</div><div class="line">        	declare users cursor for select name,age from user; -- 声明游标</div><div class="line">        	declare continue HANDLER for not found set flag=0;  -- 指定游标结束时的返回值</div><div class="line">        	open users;      -- 打开游标</div><div class="line">        	my_loop:loop</div><div class="line">        		if flag=0  -- 这里使用=，否则报错</div><div class="line">        			 then leave my_loop;  -- 跳出循环</div><div class="line">        		end if;</div><div class="line">        		fetch users into uname,uage;  -- 获取一行数据到存储到uname和uage中</div><div class="line">				select uname as name,uage as age;    -- 输出一行的结果</div><div class="line">        	end loop my_loop;</div><div class="line">        	close users;    -- 关闭游标</div><div class="line">        end</div><div class="line">        //</div><div class="line">delimiter ;</div></pre></td></tr></table></figure>
<h2 id="存储过程和存储函数的区别"><a href="#存储过程和存储函数的区别" class="headerlink" title="存储过程和存储函数的区别"></a>存储过程和存储函数的区别</h2><ol>
<li>存储函数可以使用<code>return</code>返回一个返回值，但是存储过程不能有返回值，如果需要实现返回的功能，可以使用<code>OUT</code>参数实现返回</li>
<li>存储函数只能有输入参数，而且不能带in, 而存储过程可以有多个in,out,inout参数。</li>
<li>存储过程中的语句功能更强大，存储过程可以实现很复杂的业务逻辑，而函数有很多限制，如不能在函数中使用<code>insert</code>,<code>update</code>,<code>delete</code>,<code>create</code>等语句；<strong>存储函数只完成查询的工作，可接受输入参数并返回一个结果，也就是函数实现的功能针对性比较强。</strong></li>
<li><strong>存储过程可以调用存储函数。但函数不能调用存储过程。</strong></li>
<li>存储过程一般是作为一个独立的部分来执行(call调用)。而函数可以作为查询语句的一个部分来调用。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>存储过程中可以使用<code>call</code>调用其他的存储过程，但是不能使用<code>drop</code>语句删除其他的存储过程</li>
<li><strong>存储过程的参数不要和数据库表的字段相同，否则将出现无法预料的结果</strong></li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.cnblogs.com/mark-chan/p/5384139.html" target="_blank" rel="external">https://www.cnblogs.com/mark-chan/p/5384139.html</a></li>
</ul>
<p>​    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">	create function selectUserById()</div><div class="line">	returns varchar(50) </div><div class="line">	begin </div><div class="line">	declare uname varchar(50);</div><div class="line">	select name into uname from user where id=2;</div><div class="line">	return uname;</div><div class="line">	end</div><div class="line">	//</div><div class="line">	delimiter ;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mysql存储过程和存储函数&quot;&gt;&lt;a href=&quot;#Mysql存储过程和存储函数&quot; class=&quot;headerlink&quot; title=&quot;Mysql存储过程和存储函数&quot;&gt;&lt;/a&gt;Mysql存储过程和存储函数&lt;/h1&gt;&lt;h2 id=&quot;存储过程的好处&quot;&gt;&lt;a href=
    
    </summary>
    
      <category term="数据库干货篇" scheme="http://chenjiabing666.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B2%E8%B4%A7%E7%AF%87/"/>
    
    
      <category term="SQL" scheme="http://chenjiabing666.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之Callable、Future、FutureTask</title>
    <link href="http://chenjiabing666.github.io/2018/06/26/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCallable%E3%80%81Future%E3%80%81FutureTask/"/>
    <id>http://chenjiabing666.github.io/2018/06/26/并发编程之Callable、Future、FutureTask/</id>
    <published>2018-06-26T14:55:49.000Z</published>
    <updated>2018-06-26T14:56:09.650Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程之Callable、Future、FutureTask"><a href="#并发编程之Callable、Future、FutureTask" class="headerlink" title="并发编程之Callable、Future、FutureTask"></a>并发编程之Callable、Future、FutureTask</h1><ul>
<li>　在前面的文章中我们讲述了创建线程的2种方式，一种是直接继承<code>Thread</code>，另外一种就是实现<code>Runnable</code>接口。</li>
<li>这2种方式都有一个缺陷就是：在执行完任务之后无法获取执行结果。</li>
<li>如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。</li>
<li>而自从Java 1.5开始，就提供了<code>Callable</code>和<code>Future</code>，通过它们可以在任务执行完毕之后得到任务执行结果。</li>
</ul>
<h2 id="Callable与Runnable"><a href="#Callable与Runnable" class="headerlink" title="Callable与Runnable"></a>Callable与Runnable</h2><ul>
<li>先说一下java.lang.Runnable吧，它是一个接口，在它里面只声明了一个run()方法</li>
<li><strong>由于run()方法返回值为void类型，所以在执行完任务之后无法返回任何结果。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>Callable</code>位于<code>java.util.concurrent</code>包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做call()<ul>
<li>可以看到，这是一个泛型接口，call()函数返回的类型就是传递进来的V类型。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Computes a result, or throws an exception if unable to do so.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> computed result</div><div class="line">     * <span class="doctag">@throws</span> Exception if unable to compute a result</div><div class="line">     */</div><div class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>那么怎么使用<code>Callable</code>呢？一般情况下是配合<code>ExecutorService</code>来使用的，在<code>ExecutorService</code>接口中声明了若干个<code>submit</code>方法的重载版本：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</div><div class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</div><div class="line">Future&lt;?&gt; submit(Runnable task);</div></pre></td></tr></table></figure>
<h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><ul>
<li>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</li>
<li>Future类位于java.util.concurrent包下，它是一个接口：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</div><div class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></div><div class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>cancel</code>方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。</li>
<li><code>isCancelled</code>方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</li>
<li><code>isDone</code>方法表示任务是否已经完成，若任务完成，则返回true；</li>
<li><code>get()</code>方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</li>
<li><code>get(long timeout, TimeUnit unit)</code>用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。</li>
</ul>
<h3 id="三种功能"><a href="#三种功能" class="headerlink" title="三种功能"></a>三种功能</h3><p>　　1）判断任务是否完成；</p>
<p>　　2）能够中断任务；</p>
<p>　　3）能够获取任务执行结果。</p>
<h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><ul>
<li>我们先来看一下FutureTask的实现：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>FutureTask类实现了RunnableFuture接口，我们看一下RunnableFuture接口的实现：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>可以看出RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</strong></li>
</ul>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><ul>
<li>事实上，FutureTask是Future接口的一个唯一实现类。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="使用Callable-Future获取执行结果"><a href="#使用Callable-Future获取执行结果" class="headerlink" title="使用Callable+Future获取执行结果"></a>使用Callable+Future获取执行结果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ExecutorService executor = Executors.newCachedThreadPool();</div><div class="line">        Task task = <span class="keyword">new</span> Task();</div><div class="line">        Future&lt;Integer&gt; result = executor.submit(task);</div><div class="line">        executor.shutdown();</div><div class="line">         </div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</div><div class="line">            e1.printStackTrace();</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        System.out.println(<span class="string">"主线程在执行任务"</span>);</div><div class="line">         </div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            System.out.println(<span class="string">"task运行结果"</span>+result.get());</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        System.out.println(<span class="string">"所有任务执行完毕"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"子线程在进行计算"</span>);</div><div class="line">        Thread.sleep(<span class="number">3000</span>);</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</div><div class="line">            sum += i;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用Callable-FutureTask获取执行结果"><a href="#使用Callable-FutureTask获取执行结果" class="headerlink" title="使用Callable+FutureTask获取执行结果"></a>使用Callable+FutureTask获取执行结果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//第一种方式</span></div><div class="line">        ExecutorService executor = Executors.newCachedThreadPool();</div><div class="line">        Task task = <span class="keyword">new</span> Task();</div><div class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(task);</div><div class="line">        executor.submit(futureTask);</div><div class="line">        executor.shutdown();</div><div class="line">         </div><div class="line">        <span class="comment">//第二种方式，注意这种方式和第一种方式效果是类似的，只不过一个使用的是ExecutorService，一个使用的是Thread</span></div><div class="line">        <span class="comment">/*Task task = new Task();</span></div><div class="line">        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task);</div><div class="line">        Thread thread = new Thread(futureTask);</div><div class="line">        thread.start();*/</div><div class="line">         </div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</div><div class="line">            e1.printStackTrace();</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        System.out.println(<span class="string">"主线程在执行任务"</span>);</div><div class="line">         </div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            System.out.println(<span class="string">"task运行结果"</span>+futureTask.get());</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        System.out.println(<span class="string">"所有任务执行完毕"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"子线程在进行计算"</span>);</div><div class="line">        Thread.sleep(<span class="number">3000</span>);</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</div><div class="line">            sum += i;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;并发编程之Callable、Future、FutureTask&quot;&gt;&lt;a href=&quot;#并发编程之Callable、Future、FutureTask&quot; class=&quot;headerlink&quot; title=&quot;并发编程之Callable、Future、FutureTas
    
    </summary>
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之线程池的使用</title>
    <link href="http://chenjiabing666.github.io/2018/06/26/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://chenjiabing666.github.io/2018/06/26/并发编程之线程池的使用/</id>
    <published>2018-06-26T14:54:59.000Z</published>
    <updated>2018-06-26T14:55:36.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程之线程池的使用"><a href="#并发编程之线程池的使用" class="headerlink" title="并发编程之线程池的使用"></a>并发编程之线程池的使用</h1><ul>
<li>转载自<a href="http://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="external">http://www.cnblogs.com/dolphin0520/p/3932921.html</a></li>
<li><a href="https://blog.csdn.net/wanghao_0206/article/details/76460877" target="_blank" rel="external">https://blog.csdn.net/wanghao_0206/article/details/76460877</a></li>
</ul>
<h2 id="Java中的ThreadPoolExecutor类"><a href="#Java中的ThreadPoolExecutor类" class="headerlink" title="Java中的ThreadPoolExecutor类"></a>Java中的ThreadPoolExecutor类</h2><blockquote>
<p><code>java.uitl.concurrent.ThreadPoolExecutor</code>类是线程池中最核心的一个类，因此如果要透彻地了解Java中的线程池，必须先了解这个类。下面我们来看一下ThreadPoolExecutor类的具体实现源码。</p>
<p>在ThreadPoolExecutor类中提供了四个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</div><div class="line">&gt;     .....</div><div class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></div><div class="line">&gt;             BlockingQueue&lt;Runnable&gt; workQueue);</div><div class="line">&gt;  </div><div class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></div><div class="line">&gt;             BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory);</div><div class="line">&gt;  </div><div class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></div><div class="line">&gt;             BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler);</div><div class="line">&gt;  </div><div class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></div><div class="line">&gt;         BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler);</div><div class="line">&gt;     ...</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>从上面的代码可以得知，<code>ThreadPoolExecutor</code>继承了<code>AbstractExecutorService</code>类，并提供了四个构造器，事实上，通过观察每个构造器的源码具体实现，发现前面三个构造器都是调用的第四个构造器进行的初始化工作。</strong></p>
<ul>
<li><code>corePoolSize</code>：核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到<strong>缓存队列</strong>当中；</li>
<li><code>maximumPoolSize</code>：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；</li>
<li><code>keepAliveTime</code>：<strong>表示线程没有任务执行时最多保持多久时间会终止</strong>。默认情况下，只有当线程池中的线程数大于<code>corePoolSize</code>时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；</li>
<li><code>unit</code>：参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; TimeUnit.DAYS;               <span class="comment">//天</span></div><div class="line">&gt; TimeUnit.HOURS;             <span class="comment">//小时</span></div><div class="line">&gt; TimeUnit.MINUTES;           <span class="comment">//分钟</span></div><div class="line">&gt; TimeUnit.SECONDS;           <span class="comment">//秒</span></div><div class="line">&gt; TimeUnit.MILLISECONDS;      <span class="comment">//毫秒</span></div><div class="line">&gt; TimeUnit.MICROSECONDS;      <span class="comment">//微妙</span></div><div class="line">&gt; TimeUnit.NANOSECONDS;       <span class="comment">//纳秒</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<ul>
<li><code>workQueue</code>：一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：<ul>
<li><code>SynchronousQueue</code></li>
<li><code>ArrayBlockingQueue</code></li>
<li><code>LinkedBlockingQueue</code></li>
</ul>
</li>
<li><code>threadFactory</code>：线程工厂，主要用来创建线程</li>
<li><code>handler</code>：表示当拒绝处理任务时的策略，有以下四种取值：<ul>
<li><code>ThreadPoolExecutor.AbortPolicy</code>:丢弃任务并抛出RejectedExecutionException异常。 </li>
<li><code>ThreadPoolExecutor.DiscardPolicy</code>：也是丢弃任务，但是不抛出异常</li>
<li><code>ThreadPoolExecutor.DiscardOldestPolicy</code> :丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li>
<li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：由调用线程处理该任务 </li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </div><div class="line">         <span class="comment">//指定各种参数和缓存队列</span></div><div class="line">         ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">200</span>, TimeUnit.MILLISECONDS,</div><div class="line">                 <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>));</div><div class="line">          </div><div class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">15</span>;i++)&#123;</div><div class="line">             MyTask myTask = <span class="keyword">new</span> MyTask(i);</div><div class="line">             executor.execute(myTask);   <span class="comment">//执行线程</span></div><div class="line">             System.out.println(<span class="string">"线程池中线程数目："</span>+executor.getPoolSize()+<span class="string">"，队列中等待执行的任务数目："</span>+</div><div class="line">             executor.getQueue().size()+<span class="string">"，已执行玩别的任务数目："</span>+executor.getCompletedTaskCount());</div><div class="line">         &#125;</div><div class="line">         executor.shutdown();   <span class="comment">//终止执行，等待缓存队列中的线程全部执行完成之后才会终止</span></div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//线程</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> taskNum;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.taskNum = num;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"正在执行task "</span>+taskNum);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.currentThread().sleep(<span class="number">4000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"task "</span>+taskNum+<span class="string">"执行完毕"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>从执行结果可以看出，当线程池中线程的数目大于5时，便将任务放入任务缓存队列里面，当任务缓存队列满了之后，便创建新的线程。如果上面程序中，将for循环中改成执行20个任务，就会抛出任务拒绝异常了。</li>
</ul>
<h2 id="使用工具类Executors"><a href="#使用工具类Executors" class="headerlink" title="使用工具类Executors"></a>使用工具类Executors</h2><ul>
<li>不过在java doc中，并不提倡我们直接使用<code>ThreadPoolExecutor</code>，而是使用Executors类中提供的几个静态方法来创建线程池</li>
<li>几个静态方法可以创建<code>ExecutorService</code>实例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Executors.newCachedThreadPool();        <span class="comment">//创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE</span></div><div class="line">Executors.newSingleThreadExecutor();   <span class="comment">//创建容量为1的缓冲池</span></div><div class="line">Executors.newFixedThreadPool(<span class="keyword">int</span>);    <span class="comment">//创建固定容量大小的缓冲池</span></div></pre></td></tr></table></figure>
<ul>
<li>源码如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</div><div class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</div><div class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</div><div class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</div><div class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</div><div class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>从它们的具体实现来看，它们实际上也是调用了ThreadPoolExecutor，只不过参数都已配置好</li>
<li><code>newFixedThreadPool</code>创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的<code>LinkedBlockingQueue</code>；</li>
<li><code>newSingleThreadExecutor</code>将corePoolSize和maximumPoolSize都设置为1，也使用的LinkedBlockingQueue；</li>
<li><code>newCachedThreadPool</code>将corePoolSize设置为0，将maximumPoolSize设置为<code>Integer.MAX_VALUE</code>，使用的<code>SynchronousQueue</code>，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。</li>
<li>实际中，如果Executors提供的三个静态方法能满足要求，就尽量使用它提供的三个方法，因为自己去手动配置<code>ThreadPoolExecutor</code>的参数有点麻烦，要根据实际任务的类型和数量来进行配置。</li>
<li>另外，如果<code>ThreadPoolExecutor</code>达不到要求，可以自己继承<code>ThreadPoolExecutor</code>类进行重写。</li>
</ul>
<h3 id="使用实例-1"><a href="#使用实例-1" class="headerlink" title="使用实例"></a>使用实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadFactory</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		MyThread thread=<span class="keyword">new</span> MyThread();  <span class="comment">//创建MyThread</span></div><div class="line">		<span class="comment">//创建固定大小的线程池</span></div><div class="line">		ExecutorService pService=Executors.newFixedThreadPool(<span class="number">10</span>);</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</div><div class="line">			pService.execute(<span class="keyword">new</span> Thread(thread));   <span class="comment">//在线程池中获取线程并且执行</span></div><div class="line">		&#125;</div><div class="line">		pService.shutdown();   <span class="comment">//执行完毕之后关闭</span></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">	<span class="keyword">private</span>  Integer count=<span class="number">0</span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">			System.out.println(<span class="string">"线程池开始使用"</span>);</div><div class="line">			System.out.println(<span class="string">"执行其他的操作"</span>);</div><div class="line">			System.out.println(count++);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a>AbstractExecutorService</h2><ul>
<li><code>AbstractExecutorService</code>是一个抽象类，它实现了<code>ExecutorService</code>接口。</li>
</ul>
<h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h2><ul>
<li><p>继承<code>Executor</code>接口</p>
</li>
<li><p>源码</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></div><div class="line">        <span class="keyword">throws</span> InterruptedException;</div><div class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</div><div class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</div><div class="line">    Future&lt;?&gt; submit(Runnable task);</div><div class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</div><div class="line">        <span class="keyword">throws</span> InterruptedException;</div><div class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</div><div class="line">                                  <span class="keyword">long</span> timeout, TimeUnit unit)</div><div class="line">        <span class="keyword">throws</span> InterruptedException;</div><div class="line"> </div><div class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></div><div class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException;</div><div class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></div><div class="line">                    <span class="keyword">long</span> timeout, TimeUnit unit)</div><div class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><ul>
<li>源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ThreadPoolExecutor、AbstractExecutorService、ExecutorService和Executor的关系"><a href="#ThreadPoolExecutor、AbstractExecutorService、ExecutorService和Executor的关系" class="headerlink" title="ThreadPoolExecutor、AbstractExecutorService、ExecutorService和Executor的关系"></a>ThreadPoolExecutor、AbstractExecutorService、ExecutorService和Executor的关系</h2><ul>
<li><code>Executor</code>是一个顶层接口，在它里面只声明了一个方法<code>execute(Runnable)</code>，返回值为void，参数为<code>Runnable</code>类型，从字面意思可以理解，就是用来执行传进去的任务的；</li>
<li>然后<code>ExecutorService</code>接口继承了<code>Executor</code>接口，并声明了一些方法：<code>submit</code>、<code>invokeAll</code>、<code>invokeAny</code>以及<code>shutDown</code>等；</li>
<li>抽象类<code>AbstractExecutorService</code>实现了<code>ExecutorService</code>接口，基本实现了<code>ExecutorService</code>中声明的所有方法；</li>
<li><p>然后<code>ThreadPoolExecutor</code>继承了类<code>AbstractExecutorService</code>。</p>
</li>
<li><p>在<code>ThreadPoolExecutor</code>类中有几个非常重要的方法：</p>
<ul>
<li><code>execute()</code>方法实际上是Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</li>
<li><code>submit()</code>方法是在ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，在ThreadPoolExecutor中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和execute()方法不同，它能够返回任务执行的结果，去看submit()方法的实现，会发现它实际上还是调用的execute()方法，只不过它利用了Future来获取任务执行结果（Future相关内容将在下一篇讲述）。</li>
<li><code>shutdown()</code>和<code>shutdownNow()</code>是用来关闭线程池的。</li>
</ul>
</li>
</ul>
<h2 id="深入剖析线程池实现原理"><a href="#深入剖析线程池实现原理" class="headerlink" title="深入剖析线程池实现原理"></a>深入剖析线程池实现原理</h2><h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><ul>
<li>在<code>ThreadPoolExecutor</code>中定义了一个<code>volatile</code>变量，另外定义了几个<code>static final</code>变量表示线程池的各个状态：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> runState;   </div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = <span class="number">0</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   = <span class="number">1</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       = <span class="number">2</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED = <span class="number">3</span>;</div></pre></td></tr></table></figure>
<ul>
<li><code>runState</code>表示当前线程池的状态，它是一个volatile变量用来保证线程之间的可见性；下面的几个static final变量表示runState可能的几个取值。</li>
<li>当创建线程池后，初始时，线程池处于<code>RUNNING</code>状态；</li>
<li>如果调用了<code>shutdown()</code>方法，则线程池处于<code>SHUTDOWN</code>状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；</li>
<li>如果调用了<code>shutdownNow()</code>方法，则线程池处于<code>STOP</code>状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；</li>
<li>当线程池处于<code>SHUTDOWN</code>或<code>STOP</code>状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为<code>TERMINATED</code>状态。</li>
</ul>
<h3 id="任务的执行"><a href="#任务的执行" class="headerlink" title="任务的执行"></a>任务的执行</h3><ul>
<li>在了解将任务提交给线程池到任务执行完毕整个过程之前，我们先来看一下ThreadPoolExecutor类中其他的一些比较重要成员变量：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;              <span class="comment">//任务缓存队列，用来存放等待执行的任务</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();   <span class="comment">//线程池的主要状态锁，对线程池状态（比如线程池大小</span></div><div class="line">                                                              <span class="comment">//、runState等）的改变都要使用这个锁</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();  <span class="comment">//用来存放工作集</span></div><div class="line"> </div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span>  keepAliveTime;    <span class="comment">//线程存货时间   </span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;   <span class="comment">//是否允许为核心线程设置存活时间</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span>   corePoolSize;     <span class="comment">//核心池的大小（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span>   maximumPoolSize;   <span class="comment">//线程池最大能容忍的线程数</span></div><div class="line"> </div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span>   poolSize;       <span class="comment">//线程池中当前的线程数</span></div><div class="line"> </div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler; <span class="comment">//任务拒绝策略</span></div><div class="line"> </div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;   <span class="comment">//线程工厂，用来创建线程</span></div><div class="line"> </div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;   <span class="comment">//用来记录线程池中曾经出现过的最大线程数</span></div><div class="line"> </div><div class="line"><span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;   <span class="comment">//用来记录已经执行完毕的任务个数</span></div></pre></td></tr></table></figure>
<blockquote>
<p>每个变量的作用都已经标明出来了，这里要重点解释一下corePoolSize、maximumPoolSize、largestPoolSize三个变量。</p>
<p>corePoolSize在很多地方被翻译成核心池大小，其实我的理解这个就是线程池的大小。举个简单的例子：</p>
<p>假如有一个工厂，工厂里面有10个工人，每个工人同时只能做一件任务。</p>
<p>因此只要当10个工人中有工人是空闲的，来了任务就分配给空闲的工人做；</p>
<p>当10个工人都有任务在做时，如果还来了任务，就把任务进行排队等待；</p>
<p>如果说新任务数目增长的速度远远大于工人做任务的速度，那么此时工厂主管可能会想补救措施，比如重新招4个临时工人进来；</p>
<p>然后就将任务也分配给这4个临时工人做；</p>
<p>如果说着14个工人做任务的速度还是不够，此时工厂主管可能就要考虑不再接收新的任务或者抛弃前面的一些任务了。</p>
<p>当这14个工人当中有人空闲时，而新任务增长的速度又比较缓慢，工厂主管可能就考虑辞掉4个临时工了，只保持原来的10个工人，毕竟请额外的工人是要花钱的。</p>
<p>这个例子中的corePoolSize就是10，而maximumPoolSize就是14（10+4）。</p>
<p>也就是说corePoolSize就是线程池大小，maximumPoolSize在我看来是线程池的一种补救措施，即任务量突然过大时的一种补救措施。</p>
<p>不过为了方便理解，在本文后面还是将corePoolSize翻译成核心池大小。</p>
<p>largestPoolSize只是一个用来起记录作用的变量，用来记录线程池中曾经有过的最大线程数目，跟线程池的容量没有任何关系。</p>
</blockquote>
<h3 id="线程池中的线程初始化"><a href="#线程池中的线程初始化" class="headerlink" title="线程池中的线程初始化"></a>线程池中的线程初始化</h3><ul>
<li>默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。</li>
<li><p>在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到：</p>
</li>
<li><p>prestartCoreThread()：初始化一个核心线程；</p>
</li>
<li>prestartAllCoreThreads()：初始化所有核心线程</li>
</ul>
<h3 id="任务缓存队列及排队策略"><a href="#任务缓存队列及排队策略" class="headerlink" title="任务缓存队列及排队策略"></a>任务缓存队列及排队策略</h3><ul>
<li>在前面我们多次提到了任务缓存队列，即workQueue，它用来存放等待执行的任务。</li>
<li><code>workQueue</code>的类型为<code>BlockingQueue&lt;Runnable&gt;</code>，通常可以取下面三种类型：<ul>
<li><code>ArrayBlockingQueue</code>：基于数组的先进先出队列，此队列创建时必须指定大小</li>
<li><code>LinkedBlockingQueue</code>：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为<code>Integer.MAX_VALUE</code>；</li>
<li><code>synchronousQueue</code>：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务</li>
</ul>
</li>
</ul>
<h3 id="任务拒绝策略"><a href="#任务拒绝策略" class="headerlink" title="任务拒绝策略"></a>任务拒绝策略</h3><ul>
<li>当线程池的任务缓存队列已满并且线程池中的线程数目达到<code>maximumPoolSize</code>，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</div><div class="line">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</div><div class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</div><div class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</div></pre></td></tr></table></figure>
<h3 id="线程池关闭"><a href="#线程池关闭" class="headerlink" title="线程池关闭"></a>线程池关闭</h3><ul>
<li><code>ThreadPoolExecutor</code>提供了两个方法，用于线程池的关闭，分别是<code>shutdown()</code>和<code>shutdownNow()</code>，其中：<ul>
<li><code>shutdown()</code>：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</li>
<li><code>shutdownNow()</code>：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</li>
</ul>
</li>
</ul>
<h3 id="线程池容量的动态调整"><a href="#线程池容量的动态调整" class="headerlink" title="线程池容量的动态调整"></a>线程池容量的动态调整</h3><ul>
<li><code>ThreadPoolExecutor</code>提供了动态调整线程池容量大小的方法：<code>setCorePoolSize()</code>和<code>setMaximumPoolSize()</code><ul>
<li><code>setCorePoolSize</code>：设置核心池大小</li>
<li><code>setMaximumPoolSize</code>：设置线程池最大能创建的线程数目大小</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;并发编程之线程池的使用&quot;&gt;&lt;a href=&quot;#并发编程之线程池的使用&quot; class=&quot;headerlink&quot; title=&quot;并发编程之线程池的使用&quot;&gt;&lt;/a&gt;并发编程之线程池的使用&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;转载自&lt;a href=&quot;http://www.cnblo
    
    </summary>
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型</title>
    <link href="http://chenjiabing666.github.io/2018/06/26/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://chenjiabing666.github.io/2018/06/26/Java内存模型/</id>
    <published>2018-06-26T14:54:04.000Z</published>
    <updated>2018-06-26T14:54:42.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><ul>
<li>Java内存模型规范了Java虚拟机与计算机内存是如何协同工作的。Java虚拟机是一个完整的计算机的一个模型，因此这个模型自然也包含一个内存模型——又称为Java内存模型。</li>
<li>如果你想设计表现良好的并发程序，理解Java内存模型是非常重要的。Java内存模型规定了如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。</li>
<li>原始的Java内存模型存在一些不足，因此Java内存模型在Java1.5时被重新修订。这个版本的Java内存模型在Java8中人在使用。</li>
</ul>
<h3 id="Java内存模型内部原理"><a href="#Java内存模型内部原理" class="headerlink" title="Java内存模型内部原理"></a>Java内存模型内部原理</h3><ul>
<li>Java内存模型把Java虚拟机内部划分为线程栈和堆。这张图演示了Java内存模型的逻辑视图。</li>
</ul>
<p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-1.png" alt="Java Memory Model"></p>
<ul>
<li>每一个运行在Java虚拟机里的线程都拥有自己的线程栈。这个线程栈包含了这个线程调用的方法当前执行点相关的信息。一个线程仅能访问自己的线程栈。一个线程创建的本地变量对其它线程不可见，仅自己可见。即使两个线程执行同样的代码，这两个线程任然在在自己的线程栈中的代码来创建本地变量。因此，每个线程拥有每个本地变量的独有版本。</li>
<li><strong>所有原始类型的本地变量都存放在线程栈上，因此对其它线程不可见。一个线程可能向另一个线程传递一个原始类型变量的拷贝，但是它不能共享这个原始类型变量自身。</strong></li>
<li><strong>堆上包含在Java程序中创建的所有对象，无论是哪一个对象创建的。这包括原始类型的对象版本。如果一个对象被创建然后赋值给一个局部变量，或者用来作为另一个对象的成员变量，这个对象任然是存放在堆上。</strong></li>
<li>下面这张图演示了调用栈和本地变量存放在线程栈上，对象存放在堆上。</li>
</ul>
<p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-2.png" alt="enter image description here"></p>
<ul>
<li><strong>一个本地变量可能是原始类型，在这种情况下，它总是“呆在”线程栈上。</strong></li>
<li><strong>一个本地变量也可能是指向一个对象的一个引用。在这种情况下，<code>引用</code>（这个本地变量）存放在线程栈上，但是对象本身存放在堆上。</strong><ul>
<li>线程栈中存放的是堆上对象的引用，我们可以通过线程栈中的引用访问到这个对象</li>
</ul>
</li>
<li><strong>一个对象可能包含方法，这些方法可能包含本地变量。这些本地变量任然存放在线程栈上，即使这些方法所属的对象存放在堆上。</strong><ul>
<li>放在堆上的对象可以有多个方法，如果这个方法中存在本地变量，那么这些本地变量都是存放在线程栈中的</li>
</ul>
</li>
<li><strong>一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。</strong></li>
<li><strong>静态成员变量跟随着类定义一起也存放在堆上。</strong><ul>
<li>一个堆上的对象中如果存在静态成员变量，那么这个静态成员变量也是存放在堆上</li>
</ul>
</li>
<li><strong>存放在堆上的对象可以被所有持有对这个对象引用的线程访问。当一个线程可以访问一个对象时，它也可以访问这个对象的成员变量。如果两个线程同时调用同一个对象上的同一个方法，它们将会都访问这个对象的成员变量，但是每一个线程都拥有这个本地变量的私有拷贝。</strong></li>
<li>下图演示了上面提到的点：</li>
</ul>
<p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-3.png" alt="enter image description here"></p>
<ul>
<li>两个线程拥有一些列的本地变量。其中一个本地变量（Local Variable 2）执行堆上的一个共享对象（Object 3）。这两个线程分别拥有同一个对象的不同引用。这些引用都是本地变量，因此存放在各自线程的线程栈上。这两个不同的引用指向堆上同一个对象。</li>
<li>注意，这个共享对象（Object 3）持有Object2和Object4一个引用作为其成员变量（如图中Object3指向Object2和Object4的箭头）。通过在Object3中这些成员变量引用，这两个线程就可以访问Object2和Object4。</li>
<li>这张图也展示了指向堆上两个不同对象的一个本地变量。在这种情况下，指向两个不同对象的引用不是同一个对象。理论上，两个线程都可以访问Object1和Object5，如果两个线程都拥有两个对象的引用。但是在上图中，每一个线程仅有一个引用指向两个对象其中之一。</li>
<li>因此，什么类型的Java代码会导致上面的内存图呢？如下所示：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> class MyRunnable implements <span class="title">Runnable</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        methodOne();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> localVariable1 = <span class="number">45</span>;</div><div class="line"></div><div class="line">        MySharedObject localVariable2 =</div><div class="line">            MySharedObject.sharedInstance;</div><div class="line"></div><div class="line">        <span class="comment">//... do more with local variables.</span></div><div class="line"></div><div class="line">        methodTwo();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodTwo</span><span class="params">()</span> </span>&#123;</div><div class="line">        Integer localVariable1 = <span class="keyword">new</span> Integer(<span class="number">99</span>);</div><div class="line"></div><div class="line">        <span class="comment">//... do more with local variable.</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySharedObject</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//static variable pointing to instance of MySharedObject</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MySharedObject sharedInstance =</div><div class="line">        <span class="keyword">new</span> MySharedObject();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//member variables pointing to two objects on the heap</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> Integer object2 = <span class="keyword">new</span> Integer(<span class="number">22</span>);</div><div class="line">    <span class="keyword">public</span> Integer object4 = <span class="keyword">new</span> Integer(<span class="number">44</span>);</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">long</span> member1 = <span class="number">12345</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">long</span> member1 = <span class="number">67890</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果两个线程同时执行<code>run()</code>方法，就会出现上图所示的情景。<code>run()</code>方法调用<code>methodOne()</code>方法，<code>methodOne()</code>调用<code>methodTwo()</code>方法。</li>
<li><code>methodOne()</code>声明了一个原始类型的本地变量和一个引用类型的本地变量。</li>
<li>每个线程执行<code>methodOne()</code>都会在它们对应的线程栈上创建<code>localVariable1</code>和<code>localVariable2</code>的私有拷贝。<code>localVariable1</code>变量彼此完全独立，仅“生活”在每个线程的线程栈上。一个线程看不到另一个线程对它的<code>localVariable1</code>私有拷贝做出的修改。</li>
<li>每个线程执行<code>methodOne()</code>时也将会创建它们各自的<code>localVariable2</code>拷贝。然而，两个<code>localVariable2</code>的不同拷贝都指向堆上的同一个对象。代码中通过一个静态变量设置<code>localVariable2</code>指向一个对象引用。仅存在一个静态变量的一份拷贝，这份拷贝存放在堆上。因此，<code>localVariable2</code>的两份拷贝都指向由<code>MySharedObject</code>指向的静态变量的同一个实例。<code>MySharedObject</code>实例也存放在堆上。它对应于上图中的Object3。</li>
<li>注意，<code>MySharedObject</code>类也包含两个成员变量。这些成员变量随着这个对象存放在堆上。这两个成员变量指向另外两个<code>Integer</code>对象。这些<code>Integer</code>对象对应于上图中的Object2和Object4.</li>
<li>注意，<code>methodTwo()</code>创建一个名为<code>localVariable</code>的本地变量。这个成员变量是一个指向一个<code>Integer</code>对象的对象引用。这个方法设置<code>localVariable1</code>引用指向一个新的<code>Integer</code>实例。在执行<code>methodTwo</code>方法时，<code>localVariable1</code>引用将会在每个线程中存放一份拷贝。这两个<code>Integer</code>对象实例化将会被存储堆上，但是每次执行这个方法时，这个方法都会创建一个新的<code>Integer</code>对象，两个线程执行这个方法将会创建两个不同的<code>Integer</code>实例。<code>methodTwo</code>方法创建的<code>Integer</code>对象对应于上图中的Object1和Object5。</li>
<li>还有一点，<code>MySharedObject</code>类中的两个<code>long</code>类型的成员变量是原始类型的。因为，这些变量是成员变量，所以它们任然随着该对象存放在堆上，仅有本地变量存放在线程栈上。</li>
</ul>
<h3 id="硬件内存架构"><a href="#硬件内存架构" class="headerlink" title="硬件内存架构"></a>硬件内存架构</h3><ul>
<li>现代硬件内存模型与Java内存模型有一些不同。理解内存模型架构以及Java内存模型如何与它协同工作也是非常重要的。这部分描述了通用的硬件内存架构，下面的部分将会描述Java内存是如何与它“联手”工作的。</li>
<li>下面是现代计算机硬件架构的简单图示：</li>
</ul>
<p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-4.png" alt="enter image description here"></p>
<ul>
<li>一个现代计算机通常由两个或者多个CPU。其中一些CPU还有多核。从这一点可以看出，在一个有两个或者多个CPU的现代计算机上同时运行多个线程是可能的。每个CPU在某一时刻运行一个线程是没有问题的。这意味着，如果你的Java程序是多线程的，在你的Java程序中每个CPU上一个线程可能同时（并发）执行。</li>
<li>每个CPU都包含一系列的寄存器，它们是CPU内内存的基础。CPU在寄存器上执行操作的速度远大于在主存上执行的速度。这是因为CPU访问寄存器的速度远大于主存。</li>
<li>每个CPU可能还有一个CPU缓存层。实际上，绝大多数的现代CPU都有一定大小的缓存层。CPU访问缓存层的速度快于访问主存的速度，但通常比访问内部寄存器的速度还要慢一点。一些CPU还有多层缓存，但这些对理解Java内存模型如何和内存交互不是那么重要。只要知道CPU中可以有一个缓存层就可以了。</li>
<li>一个计算机还包含一个主存。所有的CPU都可以访问主存。主存通常比CPU中的缓存大得多。</li>
<li>通常情况下，当一个CPU需要读取主存时，它会将主存的部分读到CPU缓存中。它甚至可能将缓存中的部分内容读到它的内部寄存器中，然后在寄存器中执行操作。当CPU需要将结果写回到主存中去时，它会将内部寄存器的值刷新到缓存中，然后在某个时间点将值刷新回主存。</li>
<li>当CPU需要在缓存层存放一些东西的时候，存放在缓存中的内容通常会被刷新回主存。CPU缓存可以在某一时刻将数据局部写到它的内存中，和在某一时刻局部刷新它的内存。它不会再某一时刻读/写整个缓存。通常，在一个被称作“cache lines”的更小的内存块中缓存被更新。一个或者多个缓存行可能被读到缓存，一个或者多个缓存行可能再被刷新回主存。</li>
</ul>
<h3 id="Java内存模型和硬件内存架构之间的桥接"><a href="#Java内存模型和硬件内存架构之间的桥接" class="headerlink" title="Java内存模型和硬件内存架构之间的桥接"></a>Java内存模型和硬件内存架构之间的桥接</h3><ul>
<li>上面已经提到，Java内存模型与硬件内存架构之间存在差异。硬件内存架构没有区分线程栈和堆。对于硬件，<strong>所有的线程栈和堆都分布在主内中</strong>。部分线程栈和堆可能有时候会出现在CPU缓存中和CPU内部的寄存器中。如下图所示：</li>
</ul>
<p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-5.png" alt="enter image description here"></p>
<ul>
<li>当对象和变量被存放在计算机中各种不同的内存区域中时，就可能会出现一些具体的问题。主要包括如下两个方面：<ul>
<li>线程对共享变量修改的可见性</li>
<li>当读，写和检查共享变量时出现race conditions</li>
</ul>
</li>
<li>下面我们专门来解释以下这两个问题。</li>
</ul>
<h4 id="共享对象可见性"><a href="#共享对象可见性" class="headerlink" title="共享对象可见性"></a>共享对象可见性</h4><ul>
<li>如果两个或者更多的线程在没有正确的使用<code>volatile</code>声明或者同步的情况下共享一个对象，一个线程更新这个共享对象可能对其它线程来说是不接见的。</li>
<li>想象一下，共享对象被初始化在主存中。跑在CPU上的一个线程将这个共享对象读到CPU缓存中。然后修改了这个对象。只要CPU缓存没有被刷新会主存，对象修改后的版本对跑在其它CPU上的线程都是不可见的。这种方式可能导致每个线程拥有这个共享对象的私有拷贝，每个拷贝停留在不同的CPU缓存中。</li>
<li>下图示意了这种情形。跑在左边CPU的线程拷贝这个共享对象到它的CPU缓存中，然后将count变量的值修改为2。这个修改对跑在右边CPU上的其它线程是不可见的，因为修改后的count的值还没有被刷新回主存中去。</li>
</ul>
<p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-6.png" alt="enter image description here"></p>
<ul>
<li>解决这个问题你可以使用Java中的<code>volatile</code>关键字。<code>volatile</code>关键字可以保证直接从主存中读取一个变量，如果这个变量被修改后，总是会被写回到主存中去。</li>
</ul>
<h4 id="Race-Conditions"><a href="#Race-Conditions" class="headerlink" title="Race Conditions"></a>Race Conditions</h4><ul>
<li>如果两个或者更多的线程共享一个对象，多个线程在这个共享对象上更新变量，就有可能发生<a href="http://tutorials.jenkov.com/java-concurrency/race-conditions-and-critical-sections.html" target="_blank" rel="external">race conditions</a>。</li>
<li>想象一下，如果线程A读一个共享对象的变量count到它的CPU缓存中。再想象一下，线程B也做了同样的事情，但是往一个不同的CPU缓存中。现在线程A将<code>count</code>加1，线程B也做了同样的事情。现在<code>count</code>已经被增在了两个，每个CPU缓存中一次。</li>
<li>如果这些增加操作被顺序的执行，变量<code>count</code>应该被增加两次，然后原值+2被写回到主存中去。</li>
<li>然而，两次增加都是在没有适当的同步下并发执行的。无论是线程A还是线程B将<code>count</code>修改后的版本写回到主存中取，修改后的值仅会被原值大1，尽管增加了两次。</li>
<li>下图演示了上面描述的情况：</li>
</ul>
<p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-7.png" alt="enter image description here"></p>
<ul>
<li>解决这个问题可以使用<a href="http://tutorials.jenkov.com/java-concurrency/synchronized.html" target="_blank" rel="external">Java同步块</a>。一个同步块可以保证在同一时刻仅有一个线程可以进入代码的临界区。同步块还可以保证代码块中所有被访问的变量将会从主存中读入，当线程退出同步代码块时，所有被更新的变量都会被刷新回主存中去，不管这个变量是否被声明为volatile。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java内存模型&quot;&gt;&lt;a href=&quot;#Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型&quot;&gt;&lt;/a&gt;Java内存模型&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Java内存模型规范了Java虚拟机与计算机内存是如何协同工作的。Java虚拟机
    
    </summary>
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之线程管理</title>
    <link href="http://chenjiabing666.github.io/2018/06/26/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://chenjiabing666.github.io/2018/06/26/并发编程之线程管理/</id>
    <published>2018-06-26T14:53:22.000Z</published>
    <updated>2018-06-26T14:53:47.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程之线程管理"><a href="#并发编程之线程管理" class="headerlink" title="并发编程之线程管理"></a>并发编程之线程管理</h1><h2 id="线程的未捕获异常与监控"><a href="#线程的未捕获异常与监控" class="headerlink" title="线程的未捕获异常与监控"></a>线程的未捕获异常与监控</h2><ul>
<li>如果线程的<code>run</code>方法抛出异常未被铺货（Uncaught Exception），那么随着run方法的退出，相应的线程也会提前终止。对于线程的这种异常终止，我们如何得知并做出可能的补救动作，例如重新创建并启动一个替代线程。</li>
<li>Jdk中使用<code>UncaughtExceptionHandler</code>接口实现了对线程的异常信息的监控和处理<ul>
<li>其中有一个<code>uncaughtException(Thread a, Throwable e)</code>方法，在这里我们可以将线程抛出的异常信息记录到日志中，或者开启一个替代线程继续提供服务</li>
</ul>
</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</div><div class="line"> </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    ErrHandler handle = <span class="keyword">null</span>;</div><div class="line">    ThreadA a = <span class="keyword">null</span>;</div><div class="line">    a = <span class="keyword">new</span> ThreadA();   <span class="comment">//创建线程对象</span></div><div class="line">    handle = <span class="keyword">new</span> ErrHandler();   <span class="comment">//创建UncaughtExceptionHandler</span></div><div class="line">    a.setUncaughtExceptionHandler((UncaughtExceptionHandler) handle);</div><div class="line">    a.start();   <span class="comment">//启动</span></div><div class="line"> </div><div class="line">  &#125;</div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义的一个UncaughtExceptionHandler</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrHandler</span> <span class="keyword">implements</span> <span class="title">UncaughtExceptionHandler</span> </span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 这里可以做任何针对异常的处理,比如记录日志等等</div><div class="line">   * <span class="doctag">@param</span> a : 抛出异常的线程对象</div><div class="line">   * <span class="doctag">@param</span> e : 抛出的异常信息，可以获取异常信息</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread a, Throwable e)</span> </span>&#123;</div><div class="line">	  <span class="comment">//做一些日志管理</span></div><div class="line">    System.out.println(<span class="string">"This is:"</span> + a.getName() + <span class="string">",Message:"</span></div><div class="line">        + e.getMessage());</div><div class="line">    <span class="comment">//开启一个另外的线程提供服务</span></div><div class="line">    System.out.println(<span class="string">"现在执行另外一个替代线程提供服务......"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/**</span></div><div class="line"> * 拥有UncaughtExceptionHandler的线程</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">double</span> i = <span class="number">12</span> / <span class="number">0</span>;<span class="comment">// 抛出异常的地方</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a>线程工厂</h2><ul>
<li><a href="http://ifeve.com/thread-management-13/" target="_blank" rel="external">http://ifeve.com/thread-management-13/</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;并发编程之线程管理&quot;&gt;&lt;a href=&quot;#并发编程之线程管理&quot; class=&quot;headerlink&quot; title=&quot;并发编程之线程管理&quot;&gt;&lt;/a&gt;并发编程之线程管理&lt;/h1&gt;&lt;h2 id=&quot;线程的未捕获异常与监控&quot;&gt;&lt;a href=&quot;#线程的未捕获异常与监控&quot; c
    
    </summary>
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之信号量</title>
    <link href="http://chenjiabing666.github.io/2018/06/26/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    <id>http://chenjiabing666.github.io/2018/06/26/并发编程之信号量/</id>
    <published>2018-06-26T14:52:41.000Z</published>
    <updated>2018-06-26T14:53:03.266Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程之信号量"><a href="#并发编程之信号量" class="headerlink" title="并发编程之信号量"></a>并发编程之信号量</h1><h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p>1、Semaphore可以控同时访问的线程个数</p>
<p>2、Semaphore类位于java.util.concurrent包下，它提供了2个构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//参数permits表示许可数目，即同时可以允许多少线程进行访问</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;         </div><div class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</div><div class="line">&#125;</div><div class="line"><span class="comment">//这个多了一个参数fair表示是否是公平的，即等待时间越久的越先获取许可</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;    </div><div class="line">    sync = (fair)? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3、重要方法，acquire()、release()方法：</p>
<ul>
<li>acquire()用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可</li>
<li>release()用来释放许可。注意，在释放许可之前，必须先获获得许可</li>
<li>这4个方法都会被阻塞</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  &#125;     <span class="comment">//获取一个许可</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;    <span class="comment">//获取permits个许可</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123; &#125;          <span class="comment">//释放一个许可</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123; &#125;    <span class="comment">//释放permits个许可</span></div></pre></td></tr></table></figure>
<ul>
<li>不阻塞的方法如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回false</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span> </span>&#123; &#125;;    </div><div class="line"><span class="comment">//尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;  </div><div class="line"><span class="comment">//尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回false</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123; &#125;; </div><div class="line"><span class="comment">//尝试获取permits个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;</div></pre></td></tr></table></figure>
<ul>
<li>通过availablePermits()方法得到可用的许可数目</li>
</ul>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><ul>
<li>我们知道读锁可以允许多个线程同时进行读取，我们可以使用信号量来限制线程个数，如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSemaphore</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Semaphore semaphore=<span class="keyword">new</span> Semaphore(<span class="number">5</span>,<span class="keyword">true</span>);  <span class="comment">//创建5个信号量同时用与读文件</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantReadWriteLock rwLock= <span class="keyword">new</span> ReentrantReadWriteLock();</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Lock rLock=rwLock.readLock();  <span class="comment">//获取读锁</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">//执行10个线程，通过信号量控制，只能5个线程5个线程的执行</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">			MyThread thread=<span class="keyword">new</span> MyThread();</div><div class="line">			thread.setName(<span class="string">"线程"</span>+(i+<span class="number">1</span>));</div><div class="line">			thread.start();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">			reader();</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//读方法</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</div><div class="line">			rLock.lock();  <span class="comment">//获取读锁</span></div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				semaphore.acquire();  <span class="comment">//获取信号量，信号量-1，如果没有成功获取，那么阻塞</span></div><div class="line">				System.out.println(<span class="keyword">this</span>.getName()+<span class="string">"正在读文件"</span>);</div><div class="line">				Thread.sleep(<span class="number">1000</span>);</div><div class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;<span class="keyword">finally</span>&#123;</div><div class="line">				semaphore.release();  <span class="comment">//释放信号量</span></div><div class="line">				rLock.unlock();  <span class="comment">//释放锁</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;并发编程之信号量&quot;&gt;&lt;a href=&quot;#并发编程之信号量&quot; class=&quot;headerlink&quot; title=&quot;并发编程之信号量&quot;&gt;&lt;/a&gt;并发编程之信号量&lt;/h1&gt;&lt;h2 id=&quot;详解&quot;&gt;&lt;a href=&quot;#详解&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之阻塞队列</title>
    <link href="http://chenjiabing666.github.io/2018/06/26/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>http://chenjiabing666.github.io/2018/06/26/并发编程之阻塞队列/</id>
    <published>2018-06-26T14:51:59.000Z</published>
    <updated>2018-06-26T14:52:13.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程之阻塞队列"><a href="#并发编程之阻塞队列" class="headerlink" title="并发编程之阻塞队列"></a>并发编程之阻塞队列</h1><h2 id="1-什么是阻塞队列"><a href="#1-什么是阻塞队列" class="headerlink" title="1. 什么是阻塞队列"></a>1. 什么是阻塞队列</h2><p>阻塞队列（BlockingQueue）是 Java 5 并发新特性中的内容，阻塞队列的接口是 java.util.concurrent.BlockingQueue，它提供了两个附加操作：当队列中为空时，从队列中获取元素的操作将被阻塞；当队列满时，向队列中添加元素的操作将被阻塞。</p>
<p>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器。</p>
<p>阻塞队列提供了四种操作方法：</p>
<p><img src="https://images2015.cnblogs.com/blog/658141/201705/658141-20170519005431775-619484268.png" alt="img"></p>
<ul>
<li>抛出异常：当队列满时，再向队列中插入元素，则会抛出IllegalStateException异常。当队列空时，再向队列中获取元素，则会抛出NoSuchElementException异常。</li>
<li>返回特殊值：当队列满时，向队列中添加元素，则返回false，否则返回true。当队列为空时，向队列中获取元素，则返回null，否则返回元素。</li>
<li>一直阻塞：当阻塞队列满时，如果生产者向队列中插入元素，则队列会一直阻塞当前线程，直到队列可用或响应中断退出。当阻塞队列为空时，如果消费者线程向阻塞队列中获取数据，则队列会一直阻塞当前线程，直到队列空闲或响应中断退出。</li>
<li>超时退出：当队列满时，如果生产线程向队列中添加元素，则队列会阻塞生产线程一段时间，超过指定的时间则退出返回false。当队列为空时，消费线程从队列中移除元素，则队列会阻塞一段时间，如果超过指定时间退出返回null。</li>
</ul>
<h2 id="2-Java中的阻塞队列"><a href="#2-Java中的阻塞队列" class="headerlink" title="2. Java中的阻塞队列"></a>2. Java中的阻塞队列</h2><p>JDK7提供了7个阻塞队列。分别是</p>
<p><img src="https://images2015.cnblogs.com/blog/658141/201705/658141-20170519005458666-1469668426.png" alt="img"></p>
<p>下面分别简单介绍一下：</p>
<ol>
<li><strong>ArrayBlockingQueue</strong>：是一个用数组实现的<strong>有界阻塞队列</strong>，此队列按照先进先出（FIFO）的原则对元素进行排序。支持公平锁和非公平锁。【注：每一个线程在获取锁的时候可能都会排队等待，如果在等待时间上，先获取锁的线程的请求一定先被满足，那么这个锁就是公平的。反之，这个锁就是不公平的。公平的获取锁，也就是当前等待时间最长的线程先获取锁】</li>
<li><strong>LinkedBlockingQueue</strong>：一个由链表结构组成的有界队列，此队列的长度为<code>Integer.MAX_VALUE</code>。此队列按照先进先出的顺序进行排序。<strong>既可以实现无界队列也可以实现无界队列</strong></li>
<li><strong>PriorityBlockingQueue：</strong> 一个支持线程优先级排序的无界队列，默认自然序进行排序，也可以自定义实现compareTo()方法来指定元素排序规则，不能保证同优先级元素的顺序。</li>
<li><strong>DelayQueue：</strong> 一个实现PriorityBlockingQueue实现延迟获取的无界队列，在创建元素时，可以指定多久才能从队列中获取当前元素。只有延时期满后才能从队列中获取元素。（DelayQueue可以运用在以下应用场景：1.缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。2.定时任务调度。使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，从比如TimerQueue就是使用DelayQueue实现的。）</li>
<li><strong>SynchronousQueue：</strong> 一个不存储元素的阻塞队列，每一个put操作必须等待take操作，否则不能添加元素。支持公平锁和非公平锁。SynchronousQueue的一个使用场景是在线程池里。Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。</li>
<li><strong>LinkedTransferQueue：</strong> 一个由链表结构组成的无界阻塞队列，相当于其它队列，LinkedTransferQueue队列多了transfer和tryTransfer方法。</li>
<li><strong>LinkedBlockingDeque：</strong> 一个由链表结构组成的双向阻塞队列。队列头部和尾部都可以添加和移除元素，多线程并发时，可以将锁的竞争最多降到一半。</li>
</ol>
<p>Java中线程安全的内置队列还有两个：ConcurrentLinkedQueue和LinkedTransferQueue，它们使用了CAS这种无锁的方式来实现了线程安全的队列。无锁的方式性能好，但是队列是无界的，用在生产系统中，生产者生产速度过快，可能导致内存溢出。有界的阻塞队列ArrayBlockingQueue和LinkedBlockingQueue，为了减少Java的垃圾回收对系统性能的影响，会尽量选择array/heap格式的数据结构。这样的话就只剩下ArrayBlockingQueue。（先埋个坑在这儿，近来接触到了disruptor，感觉妙不可言。<a href="https://github.com/LMAX-Exchange/disruptor" target="_blank" rel="external">disruptor</a>）</p>
<h2 id="3-阻塞队列的实现原理"><a href="#3-阻塞队列的实现原理" class="headerlink" title="3. 阻塞队列的实现原理"></a>3. 阻塞队列的实现原理</h2><p>这里分析下ArrayBlockingQueue的实现原理。</p>
<p><strong>构造方法</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ArrayBlockingQueue(<span class="keyword">int</span> capacity);</div><div class="line">ArrayBlockingQueue(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair);</div><div class="line">ArrayBlockingQueue(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair, Collection&lt;? extends E&gt; c)</div></pre></td></tr></table></figure>
<p>ArrayBlockingQueue提供了三种构造方法，参数含义如下：</p>
<ul>
<li>capacity：容量，即队列大小。</li>
<li>fair：是否公平锁。</li>
<li>c：队列初始化元素，顺序按照Collection遍历顺序。</li>
</ul>
<p><strong>插入元素</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    checkNotNull(e);</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> (count == items.length)</div><div class="line">            notFull.await();</div><div class="line">        enqueue(e);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从源码可以看出，生产者首先获得锁lock，然后判断队列是否已经满了，如果满了，则等待，直到被唤醒，然后调用enqueue插入元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></div><div class="line">    <span class="comment">// assert items[putIndex] == null;</span></div><div class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</div><div class="line">    items[putIndex] = x;</div><div class="line">    <span class="keyword">if</span> (++putIndex == items.length)</div><div class="line">        putIndex = <span class="number">0</span>;</div><div class="line">    count++;</div><div class="line">    notEmpty.signal();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上是enqueue的实现，实现的操作是插入元素到一个环形数组，然后唤醒notEmpty上阻塞的线程。</p>
<p><strong>获取元素</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</div><div class="line">            notEmpty.await();</div><div class="line">        <span class="keyword">return</span> dequeue();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从源码可以看出，消费者首先获得锁，然后判断队列是否为空，为空，则等待，直到被唤醒，然后调用dequeue获取元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></div><div class="line">    <span class="comment">// assert items[takeIndex] != null;</span></div><div class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    E x = (E) items[takeIndex];</div><div class="line">    items[takeIndex] = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</div><div class="line">        takeIndex = <span class="number">0</span>;</div><div class="line">    count--;</div><div class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</div><div class="line">        itrs.elementDequeued();</div><div class="line">    notFull.signal();</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上是dequeue的实现，获取环形数组当前takeIndex的元素，并及时将当前元素置为null，设置下一次takeIndex的值takeIndex++，然后唤醒notFull上阻塞的线程。</p>
<p>还有其他方法<code>offer(E e)</code>、<code>poll()</code>、<code>add(E e)</code>、<code>remove()</code>、 <code>offer(E e, long timeout, TimeUnit unit)</code>等的实现，因为常用take和put，这些方法就不一一赘述了。</p>
<h2 id="4-阻塞队列的基本使用"><a href="#4-阻塞队列的基本使用" class="headerlink" title="4. 阻塞队列的基本使用"></a>4. 阻塞队列的基本使用</h2><p>使用阻塞队列实现生产者-消费者模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by noly on 2017/5/19.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ArrayBlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">10</span>);</div><div class="line"></div><div class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(queue);</div><div class="line">        Producer producer = <span class="keyword">new</span> Producer(queue);</div><div class="line"></div><div class="line">        producer.start();</div><div class="line">        consumer.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ArrayBlockingQueue&lt;Integer&gt; queue;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(ArrayBlockingQueue&lt;Integer&gt; queue)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.queue = queue;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Integer i = queue.take();</div><div class="line">                System.out.println(<span class="string">"消费者从队列取出元素:"</span> + i);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ArrayBlockingQueue&lt;Integer&gt; queue;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(ArrayBlockingQueue&lt;Integer&gt; queue)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.queue = queue;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                queue.put(i);</div><div class="line">                System.out.println(<span class="string">"生产者向队列插入元素:"</span> + i);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果不使用阻塞队列，使用Object.wait()和Object.notify()、非阻塞队列实现生产者-消费者模式，考虑线程间的通讯，会非常麻烦。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;并发编程之阻塞队列&quot;&gt;&lt;a href=&quot;#并发编程之阻塞队列&quot; class=&quot;headerlink&quot; title=&quot;并发编程之阻塞队列&quot;&gt;&lt;/a&gt;并发编程之阻塞队列&lt;/h1&gt;&lt;h2 id=&quot;1-什么是阻塞队列&quot;&gt;&lt;a href=&quot;#1-什么是阻塞队列&quot; class
    
    </summary>
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之死锁</title>
    <link href="http://chenjiabing666.github.io/2018/06/26/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%AD%BB%E9%94%81/"/>
    <id>http://chenjiabing666.github.io/2018/06/26/并发编程之死锁/</id>
    <published>2018-06-26T14:50:58.000Z</published>
    <updated>2018-06-26T14:51:22.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程之死锁"><a href="#并发编程之死锁" class="headerlink" title="并发编程之死锁"></a>并发编程之死锁</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</li>
</ul>
<h2 id="产生的条件"><a href="#产生的条件" class="headerlink" title="产生的条件"></a>产生的条件</h2><ol>
<li><code>互斥条件</code>：所谓互斥就是线程在某一时间内独占资源。<ol>
<li>每一次的资源只能被一个线程使用</li>
</ol>
</li>
<li><code>请求与保持条件</code>：一个线程因请求资源而阻塞时，对已获得的资源保持不放。 <ol>
<li>一个线程在获取资源的时候，此时另外一个线程请求资源的时候保持不放</li>
</ol>
</li>
<li><code>不剥夺条件</code>:线程已获得资源，在末使用完之前，不能强行剥夺。<ol>
<li>资源只能被持有者线程主动释放，不能被强行剥夺</li>
</ol>
</li>
<li><code>循环等待条件</code>:若干线程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li><strong>我们可以把锁看做一个资源，这个资源正好符合<code>互斥条件</code>，<code>不剥夺条件</code>的要求。那么可能产生死锁的代码特征就是在持有一个锁的情况下去申请另外一个锁，这个通常就是意味着嵌套</strong></li>
<li>一个线程在已经持有一个锁的情况下再次申请这个锁（比如，一个类的同步方法调用该类的另外一个同步方法）并不会导致死锁，这是因为Java中的锁（包括内部锁<code>synchronized</code>和显示锁<code>Lock</code>）都是可重入的（<code>Reentrant</code>），这种情况下线程再次申请这个锁是可以成功的。<strong>因此我们必须使用不同对象的锁</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.demo.test;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 一个简单的死锁类</div><div class="line"> * t1先运行，这个时候flag==true,先锁定obj1,然后睡眠1秒钟</div><div class="line"> * 而t1在睡眠的时候，另一个线程t2启动，flag==false,先锁定obj2,然后也睡眠1秒钟</div><div class="line"> * t1睡眠结束后需要锁定obj2才能继续执行，而此时obj2已被t2锁定</div><div class="line"> * t2睡眠结束后需要锁定obj1才能继续执行，而此时obj1已被t1锁定</div><div class="line"> * t1、t2相互等待，都需要得到对方锁定的资源才能继续执行，从而死锁。 </div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object obj1 = <span class="keyword">new</span> Object();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object obj2 = <span class="keyword">new</span> Object();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeadLock</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.flag = flag;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"运行"</span>);</div><div class="line">        </div><div class="line">        <span class="keyword">if</span>(flag)&#123;</div><div class="line">            <span class="keyword">synchronized</span>(obj1)&#123;</div><div class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"已经锁住obj1"</span>);</div><div class="line">                <span class="keyword">try</span> &#123;  </div><div class="line">                    Thread.sleep(<span class="number">1000</span>);  </div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                    e.printStackTrace();  </div><div class="line">                &#125;  </div><div class="line">                <span class="keyword">synchronized</span>(obj2)&#123;</div><div class="line">                    <span class="comment">// 执行不到这里</span></div><div class="line">                    System.out.println(<span class="string">"1秒钟后，"</span>+Thread.currentThread().getName()</div><div class="line">                                + <span class="string">"锁住obj2"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">synchronized</span>(obj2)&#123;</div><div class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"已经锁住obj2"</span>);</div><div class="line">                <span class="keyword">try</span> &#123;  </div><div class="line">                    Thread.sleep(<span class="number">1000</span>);  </div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                    e.printStackTrace();  </div><div class="line">                &#125;  </div><div class="line">                <span class="keyword">synchronized</span>(obj1)&#123;</div><div class="line">                    <span class="comment">// 执行不到这里</span></div><div class="line">                    System.out.println(<span class="string">"1秒钟后，"</span>+Thread.currentThread().getName()</div><div class="line">                                + <span class="string">"锁住obj1"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><ol>
<li>锁排序法，相关线程使用全局统一的顺序申请锁</li>
<li>加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）<ol>
<li>比如使用<code>tryLock(timeout)</code> : 尝试获取锁，如果获取不到不会持续等待</li>
</ol>
</li>
<li>死锁检测</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、让程序每次至多只能获得一个锁。当然，在多线程环境下，这种情况通常并不现实。</p>
<p>2、设计时考虑清楚锁的顺序，尽量减少嵌在的加锁交互数量。</p>
<p>3、既然死锁的产生是两个线程无限等待对方持有的锁，那么只要等待时间有个上限不就好了。当然synchronized不具备这个功能，但是我们可以使用Lock类中的tryLock方法去尝试获取锁，这个方法可以指定一个超时时限，在等待超过该时限之后便会返回一个失败信息。</p>
<h2 id="参看文章"><a href="#参看文章" class="headerlink" title="参看文章"></a>参看文章</h2><ul>
<li><a href="http://www.cnblogs.com/xiaoxi/p/8311034.html" target="_blank" rel="external">http://www.cnblogs.com/xiaoxi/p/8311034.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;并发编程之死锁&quot;&gt;&lt;a href=&quot;#并发编程之死锁&quot; class=&quot;headerlink&quot; title=&quot;并发编程之死锁&quot;&gt;&lt;/a&gt;并发编程之死锁&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定
    
    </summary>
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之线程协作</title>
    <link href="http://chenjiabing666.github.io/2018/06/26/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C/"/>
    <id>http://chenjiabing666.github.io/2018/06/26/并发编程之线程协作/</id>
    <published>2018-06-26T14:50:23.000Z</published>
    <updated>2018-06-26T14:50:40.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程之线程协作"><a href="#并发编程之线程协作" class="headerlink" title="并发编程之线程协作"></a>并发编程之线程协作</h1><h2 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait / notify / notifyAll"></a>wait / notify / notifyAll</h2><ul>
<li><code>Object.wait()/Object.notify()/Object.notifyAll()</code>可用于实现等待和通知。</li>
<li><p><code>wait()</code>方法可以使其执行的线程被暂停，该方法用来实现等待。</p>
<ul>
<li>进入阻塞状态(Block)</li>
<li><strong>只有在持有一个对象的锁的时候才可以调用<code>wait()</code>方法，因此<code>Object.wait()</code>总是放在相应对象所领导的临界区中，必须和<code>synchronized</code>关键字进行使用</strong></li>
<li><strong>在执行wait方法的同时也会释放同步锁，从而线程进入阻塞状态</strong></li>
</ul>
</li>
<li><p><code>notify()</code>用于唤醒一个被暂停的线程，调用该方法可以实现通知</p>
<ul>
<li><strong>必须使用和<code>wait()</code>方法一样的对象调用</strong></li>
<li>必须使用<code>synchronized</code>关键字，并且在执行完毕之后会释放同步锁</li>
<li><strong>唤醒的是当前对象上的任意一个等待的线程</strong></li>
<li>被唤醒的等待线程在其占用的处理器继续运行的时候，需要再次申请Object对应的内部锁(synchronized)</li>
</ul>
</li>
<li><code>notifyAll()</code> 用于唤醒当前对象中的全部等待线程</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">		MyThread thread=<span class="keyword">new</span> MyThread();</div><div class="line">		<span class="keyword">new</span> Thread(thread,<span class="string">"线程1"</span>).start();</div><div class="line">		Thread.sleep(<span class="number">2000</span>);</div><div class="line">		thread.testNotifyAll();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Object object=<span class="keyword">new</span> Object();  <span class="comment">//创建一个Object对象，用于线程同步锁和调用wait方法</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;   <span class="comment">//保护条件</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">0</span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.testWait();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//测试等待</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWait</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="comment">//循环执行</span></div><div class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">            <span class="comment">//必须和调用wait的方法是一个对象</span></div><div class="line">			<span class="keyword">synchronized</span> (object) &#123;</div><div class="line">				<span class="keyword">while</span>(!<span class="keyword">this</span>.flag)&#123;</div><div class="line">					<span class="keyword">try</span> &#123;</div><div class="line">						System.out.println(Thread.currentThread().getName()+<span class="string">" 等待被唤醒...."</span>);</div><div class="line">						object.wait();</div><div class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">						System.out.println(<span class="string">"线程被终止....."</span>);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">this</span>.doAction();  <span class="comment">//执行其他的动作</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//测试唤醒线程，随机唤醒一个线程</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNotify</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">synchronized</span> (object) &#123;</div><div class="line">			<span class="keyword">this</span>.flag=<span class="keyword">true</span>;  </div><div class="line">			<span class="comment">//从当前object的等待线程中随机唤醒一个线程</span></div><div class="line">			object.notify();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//唤醒所有线程</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNotifyAll</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">synchronized</span> (object) &#123;</div><div class="line">			<span class="keyword">this</span>.flag=<span class="keyword">true</span>;</div><div class="line">			object.notifyAll();  <span class="comment">//唤醒当前对象上的所有等待线程</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//执行其他动作</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"执行其他的功能"</span>);</div><div class="line">		count++;</div><div class="line">		<span class="keyword">if</span> (count==<span class="number">10</span>) &#123;</div><div class="line">			flag=<span class="keyword">false</span>;   <span class="comment">//改变flag的值 ，将会wait</span></div><div class="line">		&#125; </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="条件变量condition"><a href="#条件变量condition" class="headerlink" title="条件变量condition"></a>条件变量condition</h2><ul>
<li>和<code>wait，notify()</code>思想一样，不过这个要和显示锁<code>Lock</code>结合使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span>  Lock lock=<span class="keyword">new</span> ReentrantLock();  <span class="comment">//创建显示锁</span></div><div class="line">	<span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">final</span> Condition condition=lock.newCondition();  <span class="comment">//创建条件变量</span></div><div class="line">	<span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;   <span class="comment">//保护条件</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">		Thread thread1=<span class="keyword">new</span> Thread()&#123;</div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				testWait();</div><div class="line">			&#125;;</div><div class="line">		&#125;;</div><div class="line">		thread1.start();</div><div class="line">		</div><div class="line">		</div><div class="line">		Thread thread2=<span class="keyword">new</span> Thread()&#123;</div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				testSignal();</div><div class="line">			&#125;;</div><div class="line">		&#125;;</div><div class="line">		thread2.start();</div><div class="line">		</div><div class="line">		</div><div class="line">		</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWait</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">			lock.lock();  <span class="comment">//获取显示锁</span></div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				<span class="keyword">if</span> (!flag) &#123;</div><div class="line">					condition.await();</div><div class="line">				&#125;</div><div class="line">				doAction();</div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException exception) &#123;</div><div class="line">				exception.printStackTrace();</div><div class="line">			&#125;<span class="keyword">finally</span>&#123;</div><div class="line">				lock.unlock();  <span class="comment">//释放锁</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSignal</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">			lock.lock();  <span class="comment">//获取锁</span></div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				<span class="keyword">if</span> (flag) &#123;</div><div class="line">					System.out.println(<span class="string">"执行其他的动作"</span>);</div><div class="line">				&#125;<span class="keyword">else</span> &#123;</div><div class="line">					flag=<span class="keyword">true</span>;</div><div class="line">					Thread.sleep(<span class="number">5000</span>);</div><div class="line">					condition.signal();  <span class="comment">//唤醒线程</span></div><div class="line">				&#125;</div><div class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;<span class="keyword">finally</span>&#123;</div><div class="line">				lock.unlock();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"执行其他的动作"</span>);</div><div class="line">		flag=<span class="keyword">false</span>;  <span class="comment">//改变flag</span></div><div class="line">	&#125;</div><div class="line">		</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="倒计时协调器-CountDownLatch"><a href="#倒计时协调器-CountDownLatch" class="headerlink" title="倒计时协调器 CountDownLatch"></a>倒计时协调器 CountDownLatch</h2><h2 id="栅栏-CycliBarrier"><a href="#栅栏-CycliBarrier" class="headerlink" title="栅栏 CycliBarrier"></a>栅栏 CycliBarrier</h2><h2 id="阻塞队列BlockingQueue"><a href="#阻塞队列BlockingQueue" class="headerlink" title="阻塞队列BlockingQueue"></a>阻塞队列BlockingQueue</h2><h2 id="信号量Semaphore"><a href="#信号量Semaphore" class="headerlink" title="信号量Semaphore"></a>信号量Semaphore</h2><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="http://www.cnblogs.com/dolphin0520/p/3920385.html" target="_blank" rel="external">http://www.cnblogs.com/dolphin0520/p/3920385.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;并发编程之线程协作&quot;&gt;&lt;a href=&quot;#并发编程之线程协作&quot; class=&quot;headerlink&quot; title=&quot;并发编程之线程协作&quot;&gt;&lt;/a&gt;并发编程之线程协作&lt;/h1&gt;&lt;h2 id=&quot;wait-notify-notifyAll&quot;&gt;&lt;a href=&quot;#wait
    
    </summary>
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之volatile</title>
    <link href="http://chenjiabing666.github.io/2018/06/26/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bvolatile/"/>
    <id>http://chenjiabing666.github.io/2018/06/26/并发编程之volatile/</id>
    <published>2018-06-26T14:49:47.000Z</published>
    <updated>2018-06-26T14:50:08.635Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程之volatile"><a href="#并发编程之volatile" class="headerlink" title="并发编程之volatile"></a>并发编程之volatile</h1><ul>
<li>volatile称之为轻量级锁，保证了可见性和原子性。</li>
<li>volatile不会引起上下文切换，因此是轻量级的</li>
</ul>
<h2 id="volatile的作用"><a href="#volatile的作用" class="headerlink" title="volatile的作用"></a>volatile的作用</h2><ul>
<li><p>保障可见性，有序性和<code>Long</code>，<code>double</code>类型变量读写操作的原子性</p>
</li>
<li><p><code>volatile</code>仅仅能保证对其修饰的变量的写操作以及读操作本身的原子性，而这并不表示volatile变量的赋值操作一定具有原子性，例如，如下对<code>volatile</code>修饰的变量count的赋值操作并不是原子操作：<code>count++</code></p>
<ul>
<li><code>count++</code>可以分为如下步骤<ul>
<li>读取count的值</li>
<li><code>count+1</code></li>
<li>将<code>count+1</code>的值赋值给<code>count</code></li>
</ul>
</li>
<li>如果<code>count</code>是一个共享变量，那个该赋值操作实际上是一个<code>read-modify-write</code>操作。其执行过程中其他线程可能已经更新了<code>count</code>的值，因此该操作不具备不可分割性，也就不是原子操作。如果变量count是一个局部变量，那么该赋值操作就是一个原子操作。</li>
</ul>
</li>
</ul>
<ul>
<li><strong>一般而言如果对volatile修饰的赋值操作，其右边的表达式中只要设计共享变量（包括被volatile修饰的变量本身），那么这个赋值操作就不是原子操作，此时就需要结合<code>锁</code>来保证原子性了</strong></li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="保证可见性原理"><a href="#保证可见性原理" class="headerlink" title="保证可见性原理"></a>保证可见性原理</h3><ul>
<li>对volatile修饰的变量的读操作之前插入一个<code>加载屏障</code>，能够刷新处理器缓存，使其读取的读取到的变量都是线程更新后的最新值。</li>
<li>对volatile修饰的变量的写操作(修改)之后插入一个<code>存储屏障</code>，能够冲刷处理器缓存，保证后续的线程读取到的值是最新的。</li>
</ul>
<h3 id="保证有序性原理"><a href="#保证有序性原理" class="headerlink" title="保证有序性原理"></a>保证有序性原理</h3><ul>
<li>结合释放屏障和获取屏障保证了有序性</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>volatile的写操作相当于锁的释放的效果，java虚拟机会在该操作之前插入一个释放屏障，并在该操作只有插入一个存储屏障<ul>
<li>释放屏障禁止了volatile写操作与该操作之前的任何读写操作进行重排序，从而保证了volatile写操作之前的任何读写操作会先于volatile写操作之前提交，即其他线程看到写线程对volatile变量的更新时，写线程在更新volatile变量之前执行的内存操作的结果对于度鲜橙必然是可见的。即是保障了有序性</li>
<li>存储屏障保证了在写操作之后的更新能够冲刷处理器缓存，使得后续的读线程能够获取最新的值</li>
</ul>
</li>
<li>volatile的读操作相当于获取锁的效果，Java虚拟机会在该操作之前插入一个加载屏障，并在该操作之后插入一个获取屏障<ul>
<li>加载屏障用于刷新处理器缓存区，保证读取到volatile修饰变量的最新值，保证可见性</li>
<li>获取屏障禁止volatile读操作之后的任何读写操作与volatile读操作进行重排序。因此保证了有序性</li>
</ul>
</li>
</ul>
<h2 id="volatile变量的开销"><a href="#volatile变量的开销" class="headerlink" title="volatile变量的开销"></a>volatile变量的开销</h2><ol>
<li>volatile变量的读写不会导致上下文切换，因此开销比锁小</li>
<li>读取volatile变量每次都需要从高速缓存或者主内存中读取，而无法暂存在寄存器中，因此可能比读取普通变量的成本要高</li>
</ol>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>使用volatile变量作为状态标志。比如<code>volatile int flag=false</code>,其他线程会读取该状态作为执行某一个操作的依据</li>
<li>单例模式下的双重校验锁的实现效果，其中必须使用<code>volatile</code>，否则并不能保证<code>对象</code>可见性</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="http://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="external">http://www.cnblogs.com/dolphin0520/p/3920373.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;并发编程之volatile&quot;&gt;&lt;a href=&quot;#并发编程之volatile&quot; class=&quot;headerlink&quot; title=&quot;并发编程之volatile&quot;&gt;&lt;/a&gt;并发编程之volatile&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;volatile称之为轻量级锁，保证了可
    
    </summary>
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
