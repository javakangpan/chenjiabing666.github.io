<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>爱撒谎的男孩</title>
  <subtitle>一只程序猿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chenjiabing666.github.io/"/>
  <updated>2017-09-15T08:26:29.118Z</updated>
  <id>http://chenjiabing666.github.io/</id>
  
  <author>
    <name>Chenjiabing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Servlet总结二(文件路径获取）</title>
    <link href="http://chenjiabing666.github.io/2017/09/15/Servlet%E6%80%BB%E7%BB%93%E4%BA%8C(%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E8%8E%B7%E5%8F%96)/"/>
    <id>http://chenjiabing666.github.io/2017/09/15/Servlet总结二(文件路径获取)/</id>
    <published>2017-09-15T08:25:28.000Z</published>
    <updated>2017-09-15T08:26:29.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Servlet总结二（文件路径）"><a href="#Servlet总结二（文件路径）" class="headerlink" title="Servlet总结二（文件路径）"></a>Servlet总结二（文件路径）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>前面我们说过<code>ServletContext</code>表示的是web容器中的上下文，下面我们也是用到<code>ServletContext</code>中的方法读取文件</p>
</blockquote>
<h2 id="读取WebRoot文件下的文件"><a href="#读取WebRoot文件下的文件" class="headerlink" title="读取WebRoot文件下的文件"></a>读取WebRoot文件下的文件</h2><blockquote>
<p>我们知道当我们将项目部署到<code>Tomcat</code>服务器中时，项目中的文件路径其实就是在Tomcat中的文件路径，所有的项目都是存储在webapps下的，我们可以看到webaapps下有两个文件夹<code>(WEB-INF,META-INF)</code>，这两个其实就是项目中<code>webRoot</code>下的两个文件夹。</p>
<ul>
<li><code>public String getRealPath(String path)</code>   为给定虚拟路径返回包含实际路径的String</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">//获取ServletContext的对象</span></div><div class="line">ServletContext context = <span class="keyword">this</span>.getServletContext();</div><div class="line"><span class="comment">//context.getRealPath("/")获取项目的根目录的绝对路径(webRoot的绝对路径)</span></div><div class="line"><span class="comment">//得到了webRoot的绝对路径，下面只要再接着写其他文件的路径即可</span></div><div class="line">File file = <span class="keyword">new</span> File(context.getRealPath(<span class="string">"/"</span>)</div><div class="line">		+ <span class="string">"\\WEB-INF\\lib\\file.txt"</span>);</div><div class="line"><span class="keyword">if</span> (file.exists()) &#123;</div><div class="line">	System.out.println(<span class="string">"文件存在"</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">	System.out.println(<span class="string">"文件不存在，现在我们创建一个"</span>);</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		file.createNewFile();<span class="comment">// 创建一个新的文件</span></div><div class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">		e.printStackTrace();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>InputStream getResourceAsStream(String path)</code>   根据传入的路径文件，返回一个<code>InputStream</code>对象</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">      <span class="comment">// 第一个"/"是表示webRoot的根目录，通过这个函数可以不用指定绝对路径就可以构造一个输入字节流</span></div><div class="line">InputStream stream = context</div><div class="line">		.getResourceAsStream(<span class="string">"/WEB-INF/lib/file.txt"</span>);</div><div class="line"><span class="comment">// 通过InputStreamReader将字节流转换为字符流，然后创建缓冲字符流读取文件</span></div><div class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(</div><div class="line">		<span class="keyword">new</span> InputStreamReader(stream));</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">	System.out.println(reader.readLine());</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">	System.out.println(<span class="string">"文件没有成功读取"</span>);</div><div class="line">	e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong>这个函数中的path传入的第一个<code>&quot;/&quot;</code>就表示根目录，在<code>eclipse</code>项目中表示webRoot的绝对路径，在<code>Tomcat</code>下的webapps表示项目名称的绝对路径，因此在下面的WEB-INF,META-INF文件夹下的文件只需要在后面继续添加即可</p>
</blockquote>
<h2 id="读取src下的class文件"><a href="#读取src下的class文件" class="headerlink" title="读取src下的class文件"></a>读取src下的class文件</h2><blockquote>
<p>前面我们获取的<code>webRoot</code>下的文件路径，但是如果我们想要获取<code>src</code>下的文件，那么我们要如何获取呢。</p>
<p>我们仔细看看<code>Tomcat</code>下的文件，可以发现在每一个WEB-INF下都有一个<code>classes</code>，这个就是相当于Tomcat下的src，因此我们利用上面得到的路径稍加修改就可以轻易的得到其中的文件路径</p>
<p>下面我们读取<code>src</code>文件夹下的<code>file.txt</code>中的内容，代码如下:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">      <span class="comment">// 获取ServletContext对象</span></div><div class="line">ServletContext context = <span class="keyword">this</span>.getServletContext();</div><div class="line"><span class="comment">// 这个是获取项目下的src文件夹下的file.txt文件</span></div><div class="line">File file = <span class="keyword">new</span> File(context.getRealPath(<span class="string">"/"</span>)</div><div class="line">		+ <span class="string">"\\WEB-INF\\classes\\file.txt"</span>);</div><div class="line">BufferedReader reader = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">if</span> (file.exists()) &#123;</div><div class="line">	System.out.println(<span class="string">"文件存在，现在可以读取"</span>);</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		<span class="comment">// 创建缓冲流对象，实现读取文件</span></div><div class="line">		reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(file));</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="comment">// 输出第一行内容</span></div><div class="line">			System.out.println(reader.readLine());</div><div class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">		System.out.println(<span class="string">"文件不存在"</span>);</div><div class="line">	&#125; <span class="keyword">finally</span> &#123;</div><div class="line">		<span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				reader.close(); <span class="comment">// 如果reader不是空，就关闭</span></div><div class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">				System.out.println(<span class="string">"文件关闭失败"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">	System.out.println(<span class="string">"文件不存在，现在开始创建一个"</span>);</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		file.createNewFile();<span class="comment">// 创建一个</span></div><div class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">		System.out.println(<span class="string">"没有创建成功"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Servlet总结二（文件路径）&quot;&gt;&lt;a href=&quot;#Servlet总结二（文件路径）&quot; class=&quot;headerlink&quot; title=&quot;Servlet总结二（文件路径）&quot;&gt;&lt;/a&gt;Servlet总结二（文件路径）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a hr
    
    </summary>
    
      <category term="Java Web" scheme="http://chenjiabing666.github.io/categories/Java-Web/"/>
    
    
      <category term="Servlet" scheme="http://chenjiabing666.github.io/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title>Eclipse配置Tomcat</title>
    <link href="http://chenjiabing666.github.io/2017/09/14/Eclipse%E9%85%8D%E7%BD%AETomcat/"/>
    <id>http://chenjiabing666.github.io/2017/09/14/Eclipse配置Tomcat/</id>
    <published>2017-09-14T14:28:10.000Z</published>
    <updated>2017-09-14T14:29:17.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Eclipse配置tomcat"><a href="#Eclipse配置tomcat" class="headerlink" title="Eclipse配置tomcat"></a>Eclipse配置tomcat</h1><h2 id="Eclipse"><a href="#Eclipse" class="headerlink" title="Eclipse"></a>Eclipse</h2><h3 id="创建server"><a href="#创建server" class="headerlink" title="创建server"></a>创建server</h3><blockquote>
<ol>
<li>首先下载<code>eclipse for javaEE developer</code> </li>
<li>打开控制台，然后到server后右击空白处-&gt;New-&gt;Server-&gt;Apach-&gt;Tomact 7.0 -&gt;Next-&gt;添加tomcat的路径即可</li>
</ol>
<p>![第一步](<a href="http://ono60m7tl.bkt.clouddn.com/eclipse1.bmp" target="_blank" rel="external">http://ono60m7tl.bkt.clouddn.com/eclipse1.bmp</a></p>
</blockquote>
<h3 id="发布项目"><a href="#发布项目" class="headerlink" title="发布项目"></a>发布项目</h3><blockquote>
<p>在控制台server的空白处右击-&gt;Add and Remove-&gt;选择项目-&gt;Add-&gt;Finish</p>
<p><img src="http://ono60m7tl.bkt.clouddn.com/eclipse2.bmp" alt="添加项目"></p>
</blockquote>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><blockquote>
<ul>
<li><a href="http://download.csdn.net/download/qq_34162294/9977574" target="_blank" rel="external">javaee中英文对照文档</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Eclipse配置tomcat&quot;&gt;&lt;a href=&quot;#Eclipse配置tomcat&quot; class=&quot;headerlink&quot; title=&quot;Eclipse配置tomcat&quot;&gt;&lt;/a&gt;Eclipse配置tomcat&lt;/h1&gt;&lt;h2 id=&quot;Eclipse&quot;&gt;&lt;a h
    
    </summary>
    
      <category term="Java web" scheme="http://chenjiabing666.github.io/categories/Java-web/"/>
    
    
      <category term="Servlet" scheme="http://chenjiabing666.github.io/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title>Servlet总结一</title>
    <link href="http://chenjiabing666.github.io/2017/09/14/Servlet%E6%80%BB%E7%BB%93%E4%B8%80/"/>
    <id>http://chenjiabing666.github.io/2017/09/14/Servlet总结一/</id>
    <published>2017-09-14T14:24:50.000Z</published>
    <updated>2017-09-15T02:04:23.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Servlet总结一"><a href="#Servlet总结一" class="headerlink" title="Servlet总结一"></a>Servlet总结一</h1><h2 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a>HttpServlet</h2><blockquote>
<p>想要实现一个servlet必须继承这个类，其实一个servlet就是一个java文件，但是这个类必须是继承HttpServlet。</p>
</blockquote>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><blockquote>
<p>servlet的生命周期是从创建到毁灭的一个过程，具体的过程如下：</p>
<blockquote>
<ul>
<li>Servlet 通过调用 <code>init ()</code> 方法进行初始化。</li>
<li>Servlet 调用 <code>service()</code> 方法来处理客户端的请求,但是在这一步还是要用到具体的实现的两个方法，分别是doPost(),doGet()</li>
<li>Servlet 通过调用 <code>destroy()</code> 方法终止（结束）。</li>
<li>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。</li>
</ul>
</blockquote>
</blockquote>
<h3 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h3><blockquote>
<ul>
<li><p><code>init()</code>   初试化方法</p>
</li>
<li><p><code>doGet(HttpServletRequest request,HttpServletResponse response)</code>    处理get请求的方法</p>
</li>
<li><p><code>doPost(HttpServletRequest request,HttpServletResponse response)</code>    处理post请求的方法</p>
</li>
<li><p><code>destroy()</code>      最后销毁</p>
</li>
<li><p><code>Enumeration&lt;E&gt; getInitParameterNames()</code>   该方法从 servlet 的 ServletConfig 对象获取所有的参数名称</p>
</li>
<li><p><code>public String getInitParameter(String name)</code> 该方法从 servlet 的 <code>ServletConfig</code> 对象获取指定参数的值  name是指定的<code>param-name</code>的值，返回的<code>param-value</code>的值，具体的使用如下：</p>
</li>
</ul>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&lt;servlet&gt;</div><div class="line">    &lt;display-name&gt;ServletConfigDemo&lt;/display-name&gt;</div><div class="line">    &lt;servlet-name&gt;ServletConfigDemo&lt;/servlet-name&gt;</div><div class="line">    &lt;servlet-class&gt;com.ServletConfigDemo&lt;/servlet-class&gt;</div><div class="line"></div><div class="line">    &lt;init-param&gt;     </div><div class="line">    	&lt;param-name&gt;username&lt;/param-name&gt;     //定义的name</div><div class="line">    	&lt;param-value&gt;陈加兵&lt;/param-value&gt;      //定义的value</div><div class="line">    &lt;/init-param&gt; </div><div class="line">    </div><div class="line">    &lt;init-param&gt;         </div><div class="line">    	&lt;param-name&gt;password&lt;/param-name&gt;</div><div class="line">    	&lt;param-value&gt;123456&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">    </div><div class="line">  &lt;/servlet&gt;</div><div class="line">  &lt;servlet-mapping&gt;</div><div class="line">    &lt;servlet-name&gt;ServletConfigDemo&lt;/servlet-name&gt;</div><div class="line">    &lt;url-pattern&gt;/ServletConfigDemo&lt;/url-pattern&gt;</div><div class="line">  &lt;/servlet-mapping&gt;</div><div class="line"></div><div class="line"></div><div class="line">    //下面只是一个servlet类中的init()方法，一般否是在init()方法中获取 </div><div class="line">    public void init() throws ServletException &#123;</div><div class="line">		username=this.getInitParameter("username");   //根据指定的名称获取参数的值</div><div class="line">		enumeration=this.getInitParameterNames();    //获取枚举对象</div><div class="line">		while(enumeration.hasMoreElements())&#123;    //通过枚举的方法获取其中的所有的值</div><div class="line">			System.out.println(this.getInitParameter((String) enumeration.nextElement()));</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><p><code>ServletConfig getServletConfig()</code>   返回一个ServletConfig对象，这个方法在后面讲到ServletConfig类的时候回详细的说到</p>
</li>
<li><p><code>ServletContext getServletContext()</code>   返回一个ServletContext对象，这个和ServletConfig类一样重要，在后面会详细讲解</p>
</li>
</ul>
</blockquote>
<h2 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h2><blockquote>
<p>这是servlet容器中用来处理请求的类，并且该对象作为一个参数传给doGet,doPost方法中</p>
</blockquote>
<h3 id="常用的方法-1"><a href="#常用的方法-1" class="headerlink" title="常用的方法"></a>常用的方法</h3><blockquote>
<ul>
<li><p><code>getParameter(String name)</code> 获取表单中的值，name是input中定义的name值，如果不存在返回null，否则返回的字符串 String[]  </p>
</li>
<li><p><code>getParameterValues(String name)</code> 获取表单中有多个name相同的值，例如多选列表，复选框</p>
</li>
<li><p><code>Enumeration getParameterNames()</code>  返回所有请求中的参数，返回的是一个枚举对象，可以通过对应的方法进行列出所有的参数</p>
</li>
</ul>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">   //下面将会详细讲解上面三个方法的使用法，这三个参数是针对表单的，因此需要结合表单讲解，我们将会在index.jsp文件中定义表单</div><div class="line">   //index.jsp文件的内容如下：</div><div class="line">   &lt;form action="ServletDemo" method="post"&gt;       //servletDemo是要处理该请求的servlet的url，使用的是相对路径</div><div class="line">	username: &lt;input type="text" name="username"&gt; &lt;br&gt;Password:</div><div class="line">	&lt;input type="password" name="pw"&gt; &lt;br&gt;</div><div class="line">	&lt;input type="submit" value="提交"&gt; &lt;br&gt; &lt;label&gt;hobby:&lt;/label&gt;</div><div class="line">	&lt;input type="checkbox" name="hobby" value="1"&gt;swing &lt;input</div><div class="line">		type="checkbox" name="hobby" value="2"&gt;dancing &lt;input</div><div class="line">		type="checkbox" name="hobby" value="3"&gt;song</div><div class="line"></div><div class="line">&lt;/form&gt;</div><div class="line"></div><div class="line"></div><div class="line">       //下面是ServletDemo中的部分代码</div><div class="line">        String username = request.getParameter("username");  //获取username的值</div><div class="line">        String pw = request.getParameter("pw");              //获取password的值</div><div class="line">       </div><div class="line">       //获取所有复选框的值</div><div class="line">	 String[] hobbies=request.getParameterValues("hobby");</div><div class="line">	 for(String hobby:hobbies)&#123;</div><div class="line">	 System.out.println(hobby);</div><div class="line">	 &#125;</div><div class="line"></div><div class="line">       </div><div class="line">       //获得所有的元素的name属性的名称，返回的是一个枚举的对象</div><div class="line">	Enumeration enumeration = request.getParameterNames();</div><div class="line">	while (enumeration.hasMoreElements()) &#123;</div><div class="line">		String paramsString = (String) enumeration.nextElement();   //获取其中的每一名称</div><div class="line">		System.out.println(request.getParameter(request.getParameter));  //根据名称获取其中的值</div><div class="line"></div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>Enumeration getHeaderNames()</code>  获取所有请求头中的参数的名称，返回的是一个枚举对象</li>
<li><code>String getHeader(String name)</code>   根据请求头中的名称获取对应名称的请求内容</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取所有请求头的名称，返回的是一个枚举对象	</span></div><div class="line">	Enumeration enumeration=request.getHeaderNames();</div><div class="line">	<span class="keyword">while</span> (enumeration.hasMoreElements()) &#123;</div><div class="line">		String name=(String) enumeration.nextElement();</div><div class="line">		String value=request.getHeader(name);   <span class="comment">//根据名称返回对应的值</span></div><div class="line">		System.out.println(name+<span class="string">":"</span>+value);   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>String getContextPath()</code>    获取应用程序的环境路径，就是上一级目录</li>
<li><code>String getMethod()</code>    返回请求的方式  Get  Post</li>
<li><code>String getQueryString()</code>   返回请求行中的参数部分</li>
<li><code>StringBuffer getRequestURL()</code>   返回完整的URL</li>
<li><code>String getRequestURI()</code>      返回请求行中的资源名部分</li>
<li><code>getRemoteAddr</code>方法返回发出请求的客户机的IP地址。</li>
<li><code>getRemoteHost</code>方法返回发出请求的客户机的完整主机名。</li>
<li><code>getRemotePort</code>方法返回客户机所使用的网络端口号。</li>
<li><code>getLocalAddr</code>方法返回WEB服务器的IP地址。</li>
<li><code>getLocalName</code>方法返回WEB服务器的主机名。</li>
</ul>
</blockquote>
<h3 id="请求转发与包含"><a href="#请求转发与包含" class="headerlink" title="请求转发与包含"></a>请求转发与包含</h3><blockquote>
<p>请求转发相当于一个重定向，但是这个又和重定向不同的是：请求转发是在web容器中进行的，因此浏览器的地址栏并不会改变，但是重定向是要求浏览器重新请求另一个url，因此可以在地址栏清楚的看到地址的变化</p>
<p>请求转发使用的是<code>HttpServletRequest</code>中的<code>getRequestDispatcher</code>方法，下面将会详细介绍</p>
</blockquote>
<h4 id="getRequestDispatcher"><a href="#getRequestDispatcher" class="headerlink" title="getRequestDispatcher"></a>getRequestDispatcher</h4><blockquote>
<p><code>RequestDispatcher getRequestDispatcher(String path)</code>  返回的是一个<code>RequestDispatcher</code>对象，path是指定转发的url，可以是绝对url或者是相对url</p>
</blockquote>
<h4 id="RequestDispatcher"><a href="#RequestDispatcher" class="headerlink" title="RequestDispatcher"></a>RequestDispatcher</h4><blockquote>
<p>定义接收来自客户端的请求并将它们发送到服务器上的任何资源（比如 servlet、HTML 文件或 JSP 文件）的对象。servlet 容器可创建 RequestDispatcher 对象，该对象被用作包装位于特定路径上的服务器资源或通过特定名称给定的服务器资源的包装器。 </p>
<p><code>void forward(ServletRequest request, ServletResponse response)</code>   执行转发请求,因为继承关系，因此其中的参数也是可以是<code>HttpServletRequest</code>和<code>HttpServletResponse</code>对象 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException,           ServletException </span>&#123;</div><div class="line">	request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</div><div class="line">	response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</div><div class="line">	</div><div class="line">	</div><div class="line">	<span class="comment">//获取表单中的值</span></div><div class="line">	String name=request.getParameter(<span class="string">"username"</span>);</div><div class="line">	String password=request.getParameter(<span class="string">"password"</span>);</div><div class="line">	<span class="comment">//上面虽然获取了其中的值，但是不可以此时对浏览器进行响应</span></div><div class="line">	RequestDispatcher dispatcher=request.getRequestDispatcher(<span class="string">"Demo2"</span>);</div><div class="line">	dispatcher.forward(request, response);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p><strong>注意：</strong> 在转发前后不可以对浏览器进行响应，否则会出现错误，其中forward传入的参数是当前的request和response，也就是说在转发之后的文件之中还是可以获取信息的（请求头，表单）</p>
</blockquote>
<p><code>void include(ServletRequest request, ServletResponse response)</code>  包含转发</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</div><div class="line">		request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</div><div class="line">		response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</div><div class="line">		</div><div class="line">		</div><div class="line">		<span class="comment">//获取表单中的值</span></div><div class="line">		String name=request.getParameter(<span class="string">"username"</span>);</div><div class="line">		String password=request.getParameter(<span class="string">"password"</span>);</div><div class="line">		</div><div class="line">		Cookie cookie=<span class="keyword">new</span> Cookie(<span class="string">"age"</span>, <span class="string">"22"</span>);</div><div class="line">		response.addCookie(cookie);</div><div class="line">		PrintWriter pw=response.getWriter();</div><div class="line">		pw.println(<span class="string">"在转发之前先对浏览器进行响应"</span>);</div><div class="line">		</div><div class="line">		<span class="comment">//上面可以看出这里对浏览器进行了响应，使用include可以在转发之前或者之后对浏览器进行响应</span></div><div class="line">		RequestDispatcher dispatcher=request.getRequestDispatcher(<span class="string">"Demo2"</span>);</div><div class="line">		dispatcher.include(request, response);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h5 id="forward和include的区别"><a href="#forward和include的区别" class="headerlink" title="forward和include的区别"></a>forward和include的区别</h5><blockquote>
<ul>
<li><code>forward</code>在转发之前和之后是不可以对浏览器进行响应的，但是<code>include</code>可以。使用<code>include</code>时，如果同时进行了响应，那么会同时响应在同一网页中，会出现在同一个页面中</li>
</ul>
</blockquote>
<h5 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h5><blockquote>
<ul>
<li>请求转发后地址栏都不会出现改变</li>
<li>请求转发过后会重新回到当前的servlet容器中，因此如果想要在当前的servlet容器中处理一些东西是可以实现的，下面来看一个例子</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException,           ServletException </span>&#123;</div><div class="line">	request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</div><div class="line">	response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</div><div class="line">	</div><div class="line">	</div><div class="line">	<span class="comment">//获取表单中的值</span></div><div class="line">	String name=request.getParameter(<span class="string">"username"</span>);</div><div class="line">	String password=request.getParameter(<span class="string">"password"</span>);</div><div class="line">	<span class="comment">//上面虽然获取了其中的值，但是不可以此时对浏览器进行响应</span></div><div class="line">	RequestDispatcher dispatcher=request.getRequestDispatcher(<span class="string">"Demo2"</span>);</div><div class="line">	dispatcher.forward(request, response);</div><div class="line">                                                                                                                               </div><div class="line">      System.out.println(username);   <span class="comment">//这个语句当转发请求处理完成之后会返回到这里执行这句话                                                                                                     </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="传递数据"><a href="#传递数据" class="headerlink" title="传递数据"></a>传递数据</h5><blockquote>
<p>就像写到<code>scrapy</code>爬虫的时候，有时候一个数据会传入到下一个函数中使用，因此需要一个机制携带过去。这里可以使用<code>HttpServletRequest</code>中的 <code>setAttribute</code>方法，详细使用如下：<br> <code>public void setAttribute(String name, Object o)</code>  这里其实相当于传入的是一个键值对，name是key，o是value<br> <code>public void removeAttribute(String name)</code>  根据键值的name移除数据</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,</span></span></div><div class="line">		HttpServletResponse response) <span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line">	<span class="comment">// 设置编码，这个是通过浏览器访问时能够实现中文显示的功能</span></div><div class="line">	response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</div><div class="line">	<span class="comment">//设置和浏览器相应的编码方式，以便在控制台上输出中文，否则将会乱码显示</span></div><div class="line">	request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</div><div class="line"></div><div class="line">	String data=<span class="string">"大家好，我是陈加兵"</span>;</div><div class="line">	request.setAttribute(<span class="string">"data"</span>,data);   <span class="comment">//向请求中传入数据,这个是以键值对存在的，前面的是key，后面的参数是value</span></div><div class="line">	<span class="comment">//将请求转发给HttpServletDemo的servlet文件处理</span></div><div class="line">	RequestDispatcher dispatcher=request.getRequestDispatcher(<span class="string">"HttpServletResponseDemo"</span>);</div><div class="line">	<span class="comment">//如果转发成功，注意这里的转发，地址栏的网址并不会改变</span></div><div class="line">	<span class="keyword">if</span>(dispatcher!=<span class="keyword">null</span>)&#123;</div><div class="line">		dispatcher.forward(request, response);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">   <span class="comment">//下面是HttpServletResponseDemo的处理代码</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span>                     ServletException, IOException </span>&#123;</div><div class="line">	response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);  <span class="comment">//设置响应内容</span></div><div class="line">	request.setCharacterEncoding(<span class="string">"UTF-8"</span>);    <span class="comment">//设置接受的编码</span></div><div class="line">	<span class="comment">//接收请求转发传递的data数据</span></div><div class="line">	String data=(String) request.getAttribute(<span class="string">"data"</span>);</div><div class="line">	PrintWriter pWriter=response.getWriter();</div><div class="line">	pWriter.println(data+<span class="string">"&lt;br/&gt;"</span>);</div><div class="line">	<span class="comment">//移除这个键值对 ，下面在访问这个数据就会显示不存在了</span></div><div class="line">	request.removeAttribute(<span class="string">"data"</span>);</div><div class="line">	pWriter.close();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h2><blockquote>
<p>这个类是用于对浏览器进行响应的</p>
</blockquote>
<h3 id="常用的方法-2"><a href="#常用的方法-2" class="headerlink" title="常用的方法"></a>常用的方法</h3><blockquote>
<ul>
<li><code>PrintWriter getWriter()</code>   返回一个PrintWriter对象，可以将字符串发送到客户端</li>
<li><code>addCookie(Cookie cookie)</code>   将指定的cookie添加到响应中，这个是直接添加到set-cookie中，用于存储一些信息</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">      Cookie cookie=<span class="keyword">new</span> Cookie(<span class="string">"age"</span>, <span class="string">"22"</span>);</div><div class="line">cookie.setMaxAge(<span class="number">7</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>); <span class="comment">//设置cookie的失效时间(秒为单位）</span></div><div class="line">response.addCookie(cookie);   <span class="comment">//添加cookie</span></div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>sendError(int src)</code>    将指定的错误信息发送到客户端 比如401，302….</li>
<li><code>sendError(int sec,String message)</code>    发送错误信息的同时，还发送提醒的信息message</li>
<li><code>sendRedirect(String url)</code>       网页重定向，url是重定向的网址，但是也可以是相对的url</li>
<li><code>ServletOutputStream getOutputStream()</code> 返回适用于在响应中编写二进制数据的 ServletOutputStream。</li>
</ul>
</blockquote>
<h2 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h2><blockquote>
<p>在<code>web.xml</code>中对于每一个Servlet的设置web容器会为其生成一个<code>ServletConfig</code>作为代表对象，你可以从该对象中取得设置在web.xml中的Servlet初始参数</p>
</blockquote>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><blockquote>
<ul>
<li><p><code>String getInitParameter(String name)</code>   根据属性的名称获取指定的值</p>
</li>
<li><p><code>Enumeration getInitParameterNames()</code>    获取该servlet中设置的所有的属性的名称（并不是设置的初始值）</p>
</li>
<li><p><code>ServletContext getServletContext()</code>     获取ServletContext对象</p>
</li>
</ul>
</blockquote>
<h3 id="设置和取得初始参数"><a href="#设置和取得初始参数" class="headerlink" title="设置和取得初始参数"></a>设置和取得初始参数</h3><blockquote>
<p><code>ServletConfig</code>相当于web.xml中个别Servlet设置代表对象，这意味着可以从ServletConfig中取得Servlet设置信息。ServletConfig定义了<code>getInitParameter()</code>、<code>getInitParameterNames()</code> 方法，可以取得设置的Servlet的初始参数</p>
</blockquote>
<h4 id="设置初始参数"><a href="#设置初始参数" class="headerlink" title="设置初始参数"></a>设置初始参数</h4><blockquote>
<p>直接在web.xml中定义如下：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>This is the description of my J2EE component<span class="tag">&lt;/<span class="name">description</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>This is the display name of my J2EE component<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Demo3<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.Demo3<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></div><div class="line">    </div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span>    //定义标签</div><div class="line">    	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>username<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>   //定义的name </div><div class="line">    	<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>陈加兵<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>    //定义的value</div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">    </div><div class="line">   <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">    	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>password<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">    	<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="取得初始参数"><a href="#取得初始参数" class="headerlink" title="取得初始参数"></a>取得初始参数</h4><blockquote>
<p>第一种方法：直接使用带有ServletConfig对象为参数的init直接获取<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line"><span class="comment">//		username=config.getInitParameter("username");   //单独的获取每一个值</span></div><div class="line"><span class="comment">//		password=config.getInitParameter("password");</span></div><div class="line">		</div><div class="line">		<span class="comment">//首先获取所有的初始参数的名称</span></div><div class="line">		Enumeration enumeration=config.getInitParameterNames();</div><div class="line">		<span class="keyword">while</span>(enumeration.hasMoreElements())&#123;</div><div class="line">			String name=(String)enumeration.nextElement();  <span class="comment">//获取每一个值</span></div><div class="line">			<span class="keyword">if</span>(name.equals(<span class="string">"username"</span>))&#123;</div><div class="line">				username=config.getInitParameter(name);</div><div class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">"password"</span>)) &#123;</div><div class="line">				password=config.getInitParameter(name);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>第二种：使用<code>HttpServlet</code>的<code>getServletConfig()</code> 方法直接获取ServletConfig对象，然后再获取参数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">	</div><div class="line">	ServletConfig config=<span class="keyword">this</span>.getServletConfig();   <span class="comment">//获取ServletConfig对象</span></div><div class="line">	username=config.getInitParameter(<span class="string">"username"</span>);   <span class="comment">//获取参数的值</span></div><div class="line">	password=config.getInitParameter(<span class="string">"password"</span>);</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><blockquote>
<ul>
<li><p><code>ServletContext</code>是整个web应用程序运行之后的代表对象，这是一个全局的对象，一个web项目中的所有Servlet文件都是可以共享这个数据的，因此这个有着很大的作用。</p>
</li>
<li><p>有人说这个不是和<code>ServletConfig</code>一样的用法吗，其实不然，<code>ServletConfig</code>并不是这个web程序的全局变量，它所设置的值只是对当前的servlet共享，并不能对web项目中的所有的servlet文件共享</p>
</li>
</ul>
</blockquote>
<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><blockquote>
<ul>
<li><p><code>String getInitParameter(String name)</code>     获取指定名称的属性值</p>
</li>
<li><p><code>Enumeration getInitParameterNames()</code>      获取所有已经设置的属性的名称</p>
</li>
<li><p><code>void setAttribute(String name, Object object)</code>  将对象绑定到此 servlet 上下文中的给定属性名称。如果已将指定名称用于某个属性，则此方法将使用新属性替换具有该名称的属性。 </p>
</li>
<li><p><code>Object getAttribute(String name)</code>   根据指定的属性名称获取绑定的值(需要进行强转)</p>
</li>
<li><p><code>void removeAttribute(String name)</code>   解除绑定的数据</p>
</li>
</ul>
</blockquote>
<h3 id="设置初始参数-1"><a href="#设置初始参数-1" class="headerlink" title="设置初始参数"></a>设置初始参数</h3><blockquote>
<p>这个和<code>ServletConfig</code>是一样的，都是在web.xml中设置的，但是这个是设置在<code>&lt;servlet&gt;&lt;/servlet&gt;</code>的外面的，并不是针对单独的一个<code>servlet</code>来设置的，因此是全局共享的</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span> <span class="attr">id</span>=<span class="string">"WebApp_ID"</span> <span class="attr">version</span>=<span class="string">"2.5"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>web2<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></div><div class="line">  </div><div class="line">  <span class="comment">&lt;!--全局变量，对工程中的所有的Servlet都是共享的--&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></div><div class="line">  		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>context_name<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">  		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>context_value<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">  </div><div class="line">  <span class="comment">&lt;!--在每一对context-param中只能定义一个变量的值--&gt;</span>	</div><div class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></div><div class="line">  </div><div class="line">   <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></div><div class="line">  		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>username<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">  		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>陈加兵<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></div><div class="line">  </div><div class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.Demo1<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Demo2<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.Demo2<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/Demo1<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Demo2<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/Demo2<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">  </div><div class="line">  </div><div class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="获取设置的参数"><a href="#获取设置的参数" class="headerlink" title="获取设置的参数"></a>获取设置的参数</h3><blockquote>
<ul>
<li>第一种方法：使用无参初始化的方法<code>init()</code> ，结合父类<code>HttpServlet</code>的<code>getServletContext()</code>的方法获取<code>ServletContext</code>对象</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用无参构造函数</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">	ServletContext context=<span class="keyword">this</span>.getServletContext();</div><div class="line">	<span class="comment">//根据属性的名称获取指定的值</span></div><div class="line">	String value=context.getInitParameter(<span class="string">"username"</span>);  </div><div class="line">	System.out.println(value);</div><div class="line">	</div><div class="line">	<span class="comment">//获取所有的属性的名称的枚举对象</span></div><div class="line">	Enumeration enumeration=context.getInitParameterNames();</div><div class="line">	<span class="keyword">while</span>(enumeration.hasMoreElements())&#123;</div><div class="line">		<span class="comment">//获取属性的每一个名称</span></div><div class="line">		String name=(String) enumeration.nextElement();</div><div class="line">		<span class="comment">//根据名称获取所有的值</span></div><div class="line">		System.out.println(name+<span class="string">" = "</span>+context.getInitParameter(name));</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>第二种方法：使用有参初始化方法<code>init(ServletConfig config)</code>，结合<code>ServletConfig</code>的<code>getServletContext()</code>方法获取对象</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用有参构造方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">(ServletConfig config)</span></span>&#123;</div><div class="line">	<span class="comment">//调用ServletConfig中的方法获取对象</span></div><div class="line">	ServletContext context=config.getServletContext();</div><div class="line">	<span class="comment">//获取属性的值</span></div><div class="line">	String value=context.getInitParameter(<span class="string">"username"</span>);</div><div class="line">	System.out.println(value);</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="绑定属性"><a href="#绑定属性" class="headerlink" title="绑定属性"></a>绑定属性</h3><blockquote>
<p>有人可能会说如果想用共享数据在web.xml设置有点繁琐，这里可以直接绑定属性，然后就可以在整个web项目中共享这个绑定的属性了</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></div><div class="line">			<span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line">		request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</div><div class="line">		response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</div><div class="line">		<span class="comment">//获取对象（这是父类HttpServlet中的一个方法）</span></div><div class="line">		ServletContext context=<span class="keyword">this</span>.getServletContext();</div><div class="line">		</div><div class="line">		<span class="comment">//count表示访问页面的次数，在这里设置了属性可以全局共享该数据，意思就是在一个项目中的所有的servlet都是可以访问到该数据的</span></div><div class="line">		Integer count=(Integer) context.getAttribute(<span class="string">"count"</span>);  <span class="comment">//获取设置的属性值</span></div><div class="line">		<span class="comment">//如果为空，表示该属性还没有被设置，因此这是第一次访问该页面</span></div><div class="line">		<span class="keyword">if</span>(count==<span class="keyword">null</span>)&#123;    </div><div class="line">			count=<span class="number">1</span>;</div><div class="line">			context.setAttribute(<span class="string">"count"</span>, <span class="number">1</span>);    <span class="comment">//初始值为1，表示访问网页1次</span></div><div class="line">		&#125;<span class="keyword">else</span> &#123;   <span class="comment">//否则表示已经不是第一次访问网页了，因此需要++1</span></div><div class="line">			context.setAttribute(<span class="string">"count"</span>, ++count);   </div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		PrintWriter pWriter=response.getWriter();</div><div class="line">		pWriter.println(<span class="string">"该页面已经被访问了"</span>+count+<span class="string">"次了......"</span>);</div><div class="line">	</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><blockquote>
<p><a href="http://download.csdn.net/download/qq_34162294/9977574" target="_blank" rel="external">javaEE中英文对照文档</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Servlet总结一&quot;&gt;&lt;a href=&quot;#Servlet总结一&quot; class=&quot;headerlink&quot; title=&quot;Servlet总结一&quot;&gt;&lt;/a&gt;Servlet总结一&lt;/h1&gt;&lt;h2 id=&quot;HttpServlet&quot;&gt;&lt;a href=&quot;#HttpServle
    
    </summary>
    
      <category term="Java web" scheme="http://chenjiabing666.github.io/categories/Java-web/"/>
    
    
      <category term="Servlet" scheme="http://chenjiabing666.github.io/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title>多线程的使用</title>
    <link href="http://chenjiabing666.github.io/2017/09/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://chenjiabing666.github.io/2017/09/03/多线程的使用/</id>
    <published>2017-09-03T06:30:25.000Z</published>
    <updated>2017-09-03T06:32:15.937Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>我看了不止一个人说多线程是鸡肋，但是就依照我个人觉得多线程在一些小型的爬虫中还是可以显著的提高速度的，相比多进程来说应该还是挺简单的</p>
</blockquote>
<h2 id="使用多线程"><a href="#使用多线程" class="headerlink" title="使用多线程"></a>使用多线程</h2><h3 id="继承threading-Thread"><a href="#继承threading-Thread" class="headerlink" title="继承threading.Thread"></a>继承threading.Thread</h3><blockquote>
<p>继承threading.Thread模块是一个很好的一个选择，就像java中也是可以继承类和实现接口一样，这都是很好的选择，下面我们来看看具体如何使用</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mythread</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,threadID,name,counter)</span>:</span></div><div class="line">        threading.Thread.__init__(self)    <span class="comment">#首先需要先保留原来threading.Thread中的初始化函数</span></div><div class="line">        self.threadID=threadID      <span class="comment">#重命名线程的ID</span></div><div class="line">        self.name=name              <span class="comment">#线程的名字</span></div><div class="line">        self.counter=counter        <span class="comment">#线程的数量</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        lock.acquire()      <span class="comment">#获取线程锁Lock</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">            <span class="keyword">print</span> <span class="string">"线程"</span>+self.name+<span class="string">"开始运行"</span></div><div class="line">        lock.release()      <span class="comment">#释放线程锁Lock</span></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    lock=threading.Lock()     </div><div class="line">    t1=Mythread(<span class="number">0</span>,<span class="string">"thread-1"</span>,<span class="number">3</span>)</div><div class="line">    t2=Mythread(<span class="number">1</span>,<span class="string">"thread-2"</span>,<span class="number">3</span>)</div><div class="line"></div><div class="line">    t1.start()</div><div class="line">    t2.start()</div><div class="line"></div><div class="line">    threads=[]</div><div class="line">    threads.append(t1)</div><div class="line">    threads.append(t2)</div><div class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</div><div class="line">        t.join()                <span class="comment">#阻塞主线程，直至线程运行完毕才运行main线程的语句</span></div><div class="line">    <span class="keyword">print</span> <span class="string">"线程运行结束"</span></div></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，这种继承的方式有一个缺点，这个和java中继承来实现多线程是一样的，就是一个对象只能是对应一个线程，并不能一个对象被多个线程共享，下面我们将会介绍另外的一种方式</p>
</blockquote>
<h3 id="直接调用threading-Thread"><a href="#直接调用threading-Thread" class="headerlink" title="直接调用threading.Thread"></a>直接调用threading.Thread</h3><blockquote>
<p>上面我们说过继承的方式，但是我个人觉得对于一些比较小的爬虫还是有些繁琐的，因为总是需要重写run方法，现在我们来看看如何简化实现多线程</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line">这是一个简单的例子，其实也不是一个好的例子，但是为了演示方便就选用了，可以看出这里是直接调用</div><div class="line">了func函数，然后变成多个线程同时并行，其中target是要调用的方法(没有括号)，args是方法调用需要传入的参数</div><div class="line">其实这个还是和上面的继承比较相似的</div><div class="line">"""</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(name,age)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">        <span class="keyword">print</span> name+<span class="string">"的年龄为："</span>+str(age)       </div><div class="line">t=threading.Thread(target=func,args=[<span class="string">"陈加兵"</span>,<span class="number">22</span>])</div><div class="line">t.start()</div></pre></td></tr></table></figure>
<h3 id="Thread对象的相关方法"><a href="#Thread对象的相关方法" class="headerlink" title="Thread对象的相关方法"></a>Thread对象的相关方法</h3><blockquote>
<ul>
<li>start()   启动线程</li>
<li>join([timeout])  设置阻塞线程，timeout是可选的参数，表示阻塞的时间，如果没有就是当此线程运行结束才开始运行下一个线程</li>
<li>run()     线程活动的方法</li>
<li>getName()   获取线程名称</li>
<li>setName()   设置线程的名称</li>
<li>isAlive()    判断线程是否还活着</li>
<li>isDaemon()    判断是否是守护线程</li>
<li>setDaemon()   设置为守护线程，守护线程就是当主线程运行完后，这个线程也会随着主线程的结束而结束</li>
</ul>
</blockquote>
<h2 id="共享队列"><a href="#共享队列" class="headerlink" title="共享队列"></a>共享队列</h2><blockquote>
<p>从源代码可以看出队列是实现了锁原语的，因此可以使用队列实现线程的同步，这里的主要原理就不细说了，简单的说就是get和put等方法都实现了锁原语，就是当一个操作正在执行的时候其他的操作会阻塞等待</p>
<p>下面我自己写了一个使用两个线程实现同时入队和出队的程序</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">from</span> Queue <span class="keyword">import</span> Queue</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">myThread</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,threadID,name,counter,q,flag)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        threadID是线程的ID</div><div class="line">        name是线程的名称</div><div class="line">        q是先进先出队列</div><div class="line">        flag是用来调用get和put的标志</div><div class="line">        """</div><div class="line">        threading.Thread.__init__(self)</div><div class="line">        self.name=name</div><div class="line">        self.threadID=threadID</div><div class="line">        self.counter=counter</div><div class="line">        self.q=q</div><div class="line">        self.flag=flag   </div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        当flag为1时就调用put方法，否则调用get</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> self.flag==<span class="number">1</span>:</div><div class="line">            self.put()</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.get()</div><div class="line">            </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            self.q.put(random.randint(<span class="number">0</span>,<span class="number">10</span>))</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.q.empty():</div><div class="line">                <span class="keyword">print</span> self.q.get()</div><div class="line">            </div><div class="line">        </div><div class="line">            </div><div class="line"></div><div class="line">            </div><div class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</div><div class="line"></div><div class="line">    threadLock=threading.Lock()</div><div class="line">    q=Queue()</div><div class="line">    </div><div class="line">    t1=myThread(<span class="number">1</span>,<span class="string">"Thread-1"</span>,<span class="number">1</span>,q,<span class="number">1</span>)</div><div class="line">    t2=myThread(<span class="number">2</span>,<span class="string">"Thread-2"</span>,<span class="number">2</span>,q,<span class="number">2</span>)</div><div class="line">    </div><div class="line">    threads=[]</div><div class="line">    </div><div class="line">    threads.append(t1)</div><div class="line">    threads.append(t2)</div><div class="line">    </div><div class="line">    t1.start()</div><div class="line">    t2.start()</div></pre></td></tr></table></figure>
<h3 id="Queue相关的一些方法"><a href="#Queue相关的一些方法" class="headerlink" title="Queue相关的一些方法"></a>Queue相关的一些方法</h3><blockquote>
<ol>
<li>Queue.qsize() 返回队列的大小</li>
<li>Queue.empty() 如果队列为空，返回True,反之False</li>
<li>Queue.full() 如果队列满了，返回True,反之False</li>
<li>Queue.full 与 maxsize 大小对应</li>
<li>Queue.get([block[, timeout]])获取队列，timeout等待时间</li>
<li>Queue.get_nowait() 相当Queue.get(False)</li>
<li>Queue.put(item) 写入队列，timeout等待时间</li>
<li>Queue.put_nowait(item) 相当Queue.put(item, False)</li>
<li>Queue.task_done() 在完成一项工作之后， Queue.task_done()函数向任务已经完成的队列发送一个信号</li>
<li>Queue.join() 实际上意味着等到队列为空，再执行别的操作</li>
</ol>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;多线程&quot;&gt;&lt;a href=&quot;#多线程&quot; class=&quot;headerlink&quot; title=&quot;多线程&quot;&gt;&lt;/a&gt;多线程&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;b
    
    </summary>
    
      <category term="python" scheme="http://chenjiabing666.github.io/categories/python/"/>
    
    
      <category term="python爬虫" scheme="http://chenjiabing666.github.io/tags/python%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>os模块中常用的的方法</title>
    <link href="http://chenjiabing666.github.io/2017/09/02/os%E6%A8%A1%E5%9D%97%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://chenjiabing666.github.io/2017/09/02/os模块中常用的的方法/</id>
    <published>2017-09-01T23:37:27.000Z</published>
    <updated>2017-09-01T23:42:58.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="os模块中常用的方法"><a href="#os模块中常用的方法" class="headerlink" title="os模块中常用的方法"></a>os模块中常用的方法</h1><h2 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h2><blockquote>
<p><code>os.getcwd()</code>   获取当前的路径<br><code>os.listdir(path)</code>  获取path路径下的全部文件和文件夹，就是显示全部的文件的作用<br><code>os.mkdir(path)</code>   创建一个文件夹<br><code>os.rmdir(path)</code>   删除一个文件夹<br><code>os.remove(path)</code>   删除一个文件<br><code>os.rename(path1,path2)</code>   将文件或者文件夹重命名，path1是原来件路径，path2是改变后的文件的路径名称<br><code>os.makedirs(path)</code>   循环创建文件夹，给出一个路径，连续的创建这个路径的全部文件夹，并不是创建文件<br><code>os.removedirs(path)</code>   循环删除文件夹  会删除整个路径的文件夹<br><code>os.path.abspath(path)</code>    返回此文件的绝对路径<br><code>os.path.exists(path)</code>    判断文件或者文件夹是否存在<br><code>os.path.basename(path)</code>   返回绝对路径中的文件名<br><code>os.path.normpath(path)</code>     标准化文件路径，Windows下将双斜杠变成单斜杠<br><code>os.path.commonprefix(list)</code>   返回list中的相同的路径，只是多个路径相同的部分<br><code>os.path.dirname(path)</code>        返回文件所在上面一层的目录的名称，注意这里是所在紧接着一层的文件夹的名称<br><code>os.path.split(path)</code>   将路径分割成两个部分，返回的是一个元祖，第一个元素是前面的路径，第二个元素是文件的名称<br><code>os.path.getatime(path)</code>   返回文件的最后访问时间<br><code>os.path.getmtime(path)</code>   返回文件的最后修改时间<br><code>os.path.getctime(path)</code>   在unix的系统上返回的是文件最后修改的时间，在window的系统上返回的是文件的创建时间<br><code>os.path.getsize(path)</code>    返回文件的大小，以字节为单位<br><code>os.path.isfile(path)</code>    判断文件是否是文件<br><code>os.path.isdir(path)</code>    判断文件是否是文件夹<br><code>os.path.join(path1,path2)</code>   将两个文件的路径拼接在一起</p>
</blockquote>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><blockquote>
<p>其中的每个方法的例子<a href="https://github.com/chenjiabing666/Python-notebook/blob/master/os.ipynb" target="_blank" rel="external">请点击这里</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;os模块中常用的方法&quot;&gt;&lt;a href=&quot;#os模块中常用的方法&quot; class=&quot;headerlink&quot; title=&quot;os模块中常用的方法&quot;&gt;&lt;/a&gt;os模块中常用的方法&lt;/h1&gt;&lt;h2 id=&quot;常用的方法&quot;&gt;&lt;a href=&quot;#常用的方法&quot; class=&quot;he
    
    </summary>
    
      <category term="python" scheme="http://chenjiabing666.github.io/categories/python/"/>
    
    
      <category term="python爬虫" scheme="http://chenjiabing666.github.io/tags/python%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>python操作MongoDB</title>
    <link href="http://chenjiabing666.github.io/2017/07/09/python%E6%93%8D%E4%BD%9CMongoDB/"/>
    <id>http://chenjiabing666.github.io/2017/07/09/python操作MongoDB/</id>
    <published>2017-07-09T04:40:33.000Z</published>
    <updated>2017-07-09T04:44:14.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python操作MongoDB"><a href="#python操作MongoDB" class="headerlink" title="python操作MongoDB"></a>python操作MongoDB</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>下面推荐本人写的MongoDB的基本操作博文，介绍的还是比较详细的，喜欢的朋友可以去看看</p>
<blockquote>
<ul>
<li><font color="#8BB800" size="3px" face="楷体"><a href="https://chenjiabing666.github.io/2017/04/28/MongoDB%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B9%8B%E5%AE%89%E8%A3%85/">MongoDB干货篇之安装</a></font></li>
<li><font color="#8BB800" size="3px" face="楷体"><a href="https://chenjiabing666.github.io/2017/04/30/MongoDB%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B9%8B%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE/">MongoDB干货篇之查询数据</a></font></li>
<li><font color="#8BB800" size="3px" face="楷体"><a href="https://chenjiabing666.github.io/2017/05/01/MongoDB%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B9%8B%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE/">MongoDB干货篇之更新数据</a></font></li>
</ul>
</blockquote>
</blockquote>
<h2 id="综合应用"><a href="#综合应用" class="headerlink" title="综合应用"></a>综合应用</h2><blockquote>
<p><font color="#8BB800" size="3px" face="楷体">下面是自己写的一个简单的操作，分别对应了增删改查，虽然不太全面，但是只是简单的示范了一下，当然更多的功能还是需要自己去完善的，因为代码中都有注释，这里就不再详细的说了</font></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding:utf-8</span></div><div class="line"><span class="keyword">import</span> pymongo</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoDB</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,db,collections)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        初始化数据库</div><div class="line">        :param db:数据库名称 </div><div class="line">        :param collections: 数据库的集合的名称</div><div class="line">        """</div><div class="line">        self.client = pymongo.MongoClient(<span class="string">'localhost'</span>, <span class="number">27017</span>)    <span class="comment">#获取的连接</span></div><div class="line">        self.db = self.client[db]        <span class="comment">#创建数据库db</span></div><div class="line">        self.post = self.db[collections]    <span class="comment">#创建或者选择要操作的集合</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, data,upsert)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        更新数据库中的数据，如果upsert为Ture，那么当没有找到指定的数据时就直接插入，反之不执行插入</div><div class="line">        :param data: 要插入的数据</div><div class="line">        :param upsert: 判断是插入还是不插入</div><div class="line">        :return: </div><div class="line">        """</div><div class="line">        self.post.update(&#123;<span class="string">"ip"</span>: data&#125;, &#123;<span class="string">'$set'</span>: &#123;<span class="string">'ip'</span>: data&#125;&#125; , upsert)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self,select)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        根据传入的参数查找指定的值，注意这里的select是字典</div><div class="line">        :param select: 指定的查找条件，这里的是字典类型的，比如&#123;"name":"chenjiabing","age":22&#125;</div><div class="line">        :return: 返回的是查询的结果，同样是字典类型的</div><div class="line">        """</div><div class="line">        <span class="keyword">return</span> self.post.find(select)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self,data)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        向数据库中插入指定的数据</div><div class="line">        :param data: 要插入的数据，这里的是字典的类型比如：&#123;"name":"chenjiabing","age":22&#125;</div><div class="line">        :return: 插入成功返回True,反之返回false</div><div class="line">        """</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            self.post.insert(data)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">except</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self,select)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        删除指定条件的记录</div><div class="line">        :param select: 指定的条件，这里是字典类型的，比如&#123;"age":22&#125; 表示删除age=22的所有数据</div><div class="line">        :return: 如果删除成功返回True，else返回False</div><div class="line">        """</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            self.post.remove(select)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">except</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<blockquote>
<p><font color="#8BB800" size="3px" face="楷体">下面是利用上面的Mongo.py文件获取西刺网站的代理并且存入数据库</font></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding:utf-8</span></div><div class="line"><span class="keyword">import</span> requests</div><div class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">from</span> Queue <span class="keyword">import</span> Queue</div><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">from</span> Mongo <span class="keyword">import</span> MongoDB   <span class="comment">#导入文件</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">XICI</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, page)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        self.header:请求头</div><div class="line">        self.q:存储ip的队列</div><div class="line">        slef.urls:页面的url</div><div class="line">        :param page:传入的参数，表示获取多少页的ip</div><div class="line">        """</div><div class="line">        self.header = &#123;<span class="string">"User-Agent"</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.3; WOW64; rv:43.0) Gecko/20100101 Firefox/43.0'</span>&#125;</div><div class="line">        self.q = Queue()</div><div class="line">        self.urls = []</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, page + <span class="number">1</span>):</div><div class="line">            self.urls.append(<span class="string">"http://www.xicidaili.com/nn/"</span> + str(i))</div><div class="line">        self.mongo = MongoDB(<span class="string">'python'</span>,<span class="string">'ip'</span>)  <span class="comment"># 创建MogoDB对象</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_ips</span><span class="params">(self, url)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        根据一页的请求爬取一个页面的ip</div><div class="line">        :param url:传入的参数，表示每一页的链接</div><div class="line">        :return: None</div><div class="line">        """</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            res = requests.get(url, headers=self.header)</div><div class="line">            <span class="keyword">if</span> res.status_code == <span class="number">200</span>:</div><div class="line">                soup = BeautifulSoup(res.text, <span class="string">'lxml'</span>)</div><div class="line">                ips = soup.find_all(<span class="string">'tr'</span>)</div><div class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(ips)):</div><div class="line">                    ip = ips[i]</div><div class="line">                    tds = ip.find_all(<span class="string">"td"</span>)</div><div class="line">                    ip_temp = <span class="string">"http://"</span> + tds[<span class="number">1</span>].contents[<span class="number">0</span>] + <span class="string">":"</span> + tds[<span class="number">2</span>].contents[<span class="number">0</span>]</div><div class="line">                    <span class="keyword">print</span> ip_temp</div><div class="line">                    self.q.put(ip_temp)  <span class="comment"># ip进入队列</span></div><div class="line"></div><div class="line">        <span class="keyword">except</span>:</div><div class="line">            <span class="keyword">print</span> <span class="string">"-------------------------------------------请求出现异常------------------------------------------------"</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, url)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        验证出过来的ip，如果成功就直接存入数据库</div><div class="line">        :param url: 验证ip地址的url</div><div class="line">        :return: 无返回值</div><div class="line">        """</div><div class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.q.empty():</div><div class="line">            ip = self.q.get()</div><div class="line">            proxy = &#123;<span class="string">"http"</span>: ip&#125;</div><div class="line">            <span class="keyword">print</span> proxy</div><div class="line">            <span class="keyword">try</span>:</div><div class="line">                res = requests.get(url, headers=self.header, proxies=proxy, timeout=<span class="number">5</span>)</div><div class="line">                <span class="keyword">if</span> res.status_code == <span class="number">200</span>:</div><div class="line">                    self.mongo.update(ip,<span class="keyword">True</span>)  <span class="comment"># 如果成功验证直接进入数据库</span></div><div class="line">                    <span class="keyword">print</span> <span class="string">"**************************成功存入数据库********************************************"</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="keyword">print</span> <span class="string">"这个ip地址不能用"</span></div><div class="line"></div><div class="line">            <span class="keyword">except</span>:</div><div class="line">                <span class="keyword">print</span> <span class="string">"--------------------------请求失败---------------------------------------------"</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> self.urls:</div><div class="line">            self.get_ips(url)</div><div class="line">        threads = []</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line">            t=threading.Thread(target=self.insert,args=[<span class="string">"http://blog.csdn.net/qq_34162294/article/details/72353389"</span>])</div><div class="line">            threads.append(t)</div><div class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> threads:</div><div class="line">            t.start()</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    p = XICI(<span class="number">3</span>)</div><div class="line">    p.main()</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python操作MongoDB&quot;&gt;&lt;a href=&quot;#python操作MongoDB&quot; class=&quot;headerlink&quot; title=&quot;python操作MongoDB&quot;&gt;&lt;/a&gt;python操作MongoDB&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;
    
    </summary>
    
      <category term="python" scheme="http://chenjiabing666.github.io/categories/python/"/>
    
    
      <category term="MongoDB" scheme="http://chenjiabing666.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Numpy指南</title>
    <link href="http://chenjiabing666.github.io/2017/07/01/Numpy%E6%8C%87%E5%8D%97/"/>
    <id>http://chenjiabing666.github.io/2017/07/01/Numpy指南/</id>
    <published>2017-07-01T05:29:21.000Z</published>
    <updated>2017-07-01T05:31:28.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="numpy指南"><a href="#numpy指南" class="headerlink" title="numpy指南"></a>numpy指南</h1><blockquote>
<p>numpy是一个能够处理多维数组的库，虽然python中也内置了处理数组的库，但是这个并不能满足大数据时代的需求，因此产生了可以处理多维数组的numpy</p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote>
<ul>
<li><code>pip install numpy</code></li>
</ul>
</blockquote>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><blockquote>
<ul>
<li><code>array</code>函数是一个最基本的创建方式，其中传入的参数是一个序列，既可以创建一维数组，也可以创建二维数组，但是这种方法不太灵活，因为你要把这个序列显式的写出来，先不多说了，自己体会吧</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line">a=np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])   <span class="comment">#创建一个二维数组</span></div><div class="line">b=np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]])  <span class="comment">#创建一个二维数组</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> a.shape     <span class="comment">#输出数组的维度，(5,)</span></div><div class="line"><span class="keyword">print</span> b.shape     <span class="comment">#(2,4)</span></div></pre></td></tr></table></figure>
<h3 id="arange"><a href="#arange" class="headerlink" title="arange"></a>arange</h3><blockquote>
<ul>
<li><code>arange(start,end,step)</code>  创建一个一维数组，起始值为start，终值为end，步长为step，其中np.arrange(10) 表示起始值为0，终值为10，步长为1</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a=np.arange(<span class="number">0</span>,<span class="number">10</span>,<span class="number">1</span>)   </div><div class="line">b=np.arange(<span class="number">10</span>)</div></pre></td></tr></table></figure>
<h3 id="reshape"><a href="#reshape" class="headerlink" title="reshape"></a>reshape</h3><blockquote>
<ul>
<li><code>reshape(a,b)</code>能过改变当前数组的尺寸将其赋值给新的数组，但是当前数组并没有改变，这个用来改变当前数组的维度，可以将以为数组改变为二维数组</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a=np.arange(<span class="number">10</span>)   <span class="comment">#创建一个有10个元素的一维数组</span></div><div class="line">b=np.reshape(<span class="number">2</span>,<span class="number">5</span>)  <span class="comment">#将改变后的当前数组赋值给b，但是a数组并没有改变 ，2*5=10</span></div><div class="line">c=np.reshape(<span class="number">5</span>,<span class="number">-1</span>)  <span class="comment">#第一个参数为5行，第二个-1表示自动计算生成，10/5=2</span></div></pre></td></tr></table></figure>
<h3 id="linspace"><a href="#linspace" class="headerlink" title="linspace"></a>linspace</h3><blockquote>
<ul>
<li><code>linspace(start,end,number)</code> 创建一个等距离的数组，start是起始值，end是终值，number是个数，创建的是一个一维数组，其中的元素全部是浮点数，默认的是包括终值的，但是可以通过endpoint=False指定不包括终值</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a=np.linspace(<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>)   <span class="comment">#包含10的一个等差数组</span></div><div class="line">b=np.linspace(<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>,endpoint=<span class="keyword">False</span>)  <span class="comment">#不包含10的一个等差数组</span></div></pre></td></tr></table></figure>
<h3 id="logspace"><a href="#logspace" class="headerlink" title="logspace"></a>logspace</h3><blockquote>
<ul>
<li><code>logspace(start,end,number)</code>  创建的是在10^start和10^end之间包含number个元素的等比数组，创建的是一个等比数组</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a=np.logspace(<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>)  <span class="comment">#创建一个在1-10之间的10个元素的等比数组</span></div></pre></td></tr></table></figure>
<h2 id="存取数据"><a href="#存取数据" class="headerlink" title="存取数据"></a>存取数据</h2><h3 id="下标存取"><a href="#下标存取" class="headerlink" title="下标存取"></a>下标存取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">a=np.arange(<span class="number">10</span>)   <span class="comment">#[0,1,2,3,4,5,6,7,8,9]</span></div><div class="line">a[<span class="number">0</span>]   <span class="comment">#获取第一个元素的值1</span></div><div class="line">a[<span class="number">0</span>:<span class="number">2</span>]  <span class="comment">#获取下标我0,1的值，注意不包括2</span></div><div class="line">a[<span class="number">0</span>:<span class="number">10</span>:<span class="number">1</span>] <span class="comment"># 获取下标在0-10之间的(包括0,不包括9)，步长为1的元素，就是每隔一个区娶一个</span></div><div class="line">a[<span class="number">1</span>:]     <span class="comment">#获取从第二个元素开始到最后的所有的元素</span></div><div class="line">a[:<span class="number">8</span>]     <span class="comment">#获取下标为0-8之间的元素(不包括8)</span></div><div class="line">a[<span class="number">1</span>::<span class="number">1</span>]  <span class="comment">#获取下标为0到最后并且步长为1的所有元素</span></div><div class="line">a[<span class="number">8</span>:<span class="number">4</span>:<span class="number">-1</span>]  <span class="comment">#获取起始下标为8，终止下标为4，并且步长为-1，这是从后向前获取元素</span></div><div class="line">a[::<span class="number">-1</span>]   <span class="comment">#将数组逆置</span></div></pre></td></tr></table></figure>
<h3 id="使用整数序列"><a href="#使用整数序列" class="headerlink" title="使用整数序列"></a>使用整数序列</h3><blockquote>
<p>当使用整数序列对数组元素进行存取时，将使用整数序列中的每个元素作为下标，整数序列可以是列表或者数组。使用整数序列作为下标获得的数组不和原始数组共享数据空间。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x = np.arange(<span class="number">10</span>,<span class="number">1</span>,<span class="number">-1</span>)</div><div class="line"> x[[<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>]] <span class="comment"># 获取x中的下标为3, 3, 1, 8的4个元素，组成一个新的数组</span></div></pre></td></tr></table></figure>
<h2 id="ufunc"><a href="#ufunc" class="headerlink" title="ufunc"></a>ufunc</h2><blockquote>
<p>ufunc是universal function的缩写，它是一种能对数组的每个元素进行操作的函数。NumPy内置的许多ufunc函数都是在C语言级别实现的，因此它们的计算速度非常快.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">np.sin(x)  <span class="comment">#对数组中的每一个值进行sin操作，并且返回一个数组</span></div><div class="line">np.sin(x,y)  <span class="comment">#对数组x中的值进行sin操纵，所得结果返回给y，但是也返回一个结果数组，这个数组和y共享一块空间的</span></div><div class="line">np.add(a,b) <span class="comment">#将两个数组中的对应的值都相加，返回的是一个新的数组</span></div><div class="line">np.add(a,b,c) <span class="comment"># 将两个数组中对应的值相加，结果复制给c，并且返回一个新的数组</span></div><div class="line">np.subtract(a,b) <span class="comment"># 两个数组相减，a-b,返回的是一个新的数组</span></div><div class="line">np.subtract(a,b,c)  </div><div class="line">np.multiply(a,b)  <span class="comment">#相乘</span></div><div class="line">np.multiply(a,b,c)  <span class="comment">#相乘</span></div><div class="line">divide(a,b,[,y])  <span class="comment">#相除，如果是两个整数相除，那么返回的是整数</span></div><div class="line">true_divide(a,b,[,y])  <span class="comment">#相除，总是返回精确的商</span></div><div class="line">floor_divide(a,b,[,y])  <span class="comment">#总是对返回值取整</span></div><div class="line">power(a,b,[,y])   <span class="comment"># a^b  平方</span></div><div class="line">mod(a,b,[,y])   <span class="comment">#取余   %</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;numpy指南&quot;&gt;&lt;a href=&quot;#numpy指南&quot; class=&quot;headerlink&quot; title=&quot;numpy指南&quot;&gt;&lt;/a&gt;numpy指南&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;numpy是一个能够处理多维数组的库，虽然python中也内置了处理数组的
    
    </summary>
    
      <category term="python数据挖掘与分析" scheme="http://chenjiabing666.github.io/categories/python%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="python数据分析" scheme="http://chenjiabing666.github.io/tags/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Lock</title>
    <link href="http://chenjiabing666.github.io/2017/06/22/Lock/"/>
    <id>http://chenjiabing666.github.io/2017/06/22/Lock/</id>
    <published>2017-06-22T07:53:32.000Z</published>
    <updated>2017-06-22T07:54:18.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h1><blockquote>
<p>在上一篇文章中我们讲到了如何使用关键字synchronized来实现同步访问。本文我们继续来探讨这个问题，从Java 5之后，在java.util.concurrent.locks包下提供了另外一种方式来实现同步访问，那就是Lock。</p>
<p>也许有朋友会问，既然都可以通过synchronized来实现同步访问了，那么为什么还需要提供Lock？这个问题将在下面进行阐述。本文先从synchronized的缺陷讲起，然后再讲述java.util.concurrent.locks包下常用的有哪些类和接口，最后讨论以下一些关于锁的概念方面的东西</p>
</blockquote>
<h2 id="synchronized缺陷"><a href="#synchronized缺陷" class="headerlink" title="synchronized缺陷"></a>synchronized缺陷</h2><blockquote>
<p>前面我们说过synchronized的线程释放锁的情况有两种:</p>
<blockquote>
<ol>
<li>代码块或者同步方法执行完毕</li>
<li>代码块或者同步方法出现异常有jvm自动释放锁</li>
</ol>
</blockquote>
<p>从上面的synchronized释放锁可以看出，只有synchronized代码块执行完毕或者异常才会释放，如果代码块中的程序因为IO原因阻塞了，那么线程将永远不会释放锁，但是此时另外的线程还要执行其他的程序，极大的影响了程序的执行效率，现在我们需要一种机制能够让线程不会一直无限的等待下去，能够响应中断，这个通过lock就可以办到</p>
<p>另外如果有一个程序，包含多个读线程和一个写线程，我们可以知道synchronized只能一个一个线程的执行，但是我们需要多个读线程同时进行读，那么使用synchronized肯定是不行的，但是我们使用lock同样可以办到</p>
</blockquote>
<h2 id="Lock-1"><a href="#Lock-1" class="headerlink" title="Lock"></a>Lock</h2><blockquote>
<p>查看API可知，Lock是一个接口，因此是不可以直接创建对象的，但是我们可以利用其实现的类来创建对象，这个先不着急，我们先看看Lock类到底实现了什么方法,具体的实现我们将会在介绍其实现的类的时候再详细的讲解</p>
</blockquote>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><blockquote>
<ul>
<li><code>lock()</code>  获取锁，如果没有获得就会一直等待</li>
<li><code>unlock()</code>  释放锁</li>
<li><code>tryLock()</code>  尝试获得锁，如果成功获得锁就执行，如果没有成功获得锁，那么就不会等待了</li>
<li><code>lockInterruptibly()</code>   如果当前线程未被中断，则获取锁。</li>
</ul>
</blockquote>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><blockquote>
<p>ReentrantLock是可重入锁，是实现Lock接口的一个类，可重入是一种线程的分配机制，可重入的意思就是总是分配给最近获得锁的线程，这是一种不公平的分配机制，将会出现饥饿现象，当然为了解决这种现象，ReentrantLock的构造方法还提供了一个fair参数，如果fair为true表示使用公平分配机制，将会有等待时间最长的线程获得锁</p>
</blockquote>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><blockquote>
<ul>
<li><code>ReentrantLock()</code>  创建一个对象，默认使用的时可重入的机制</li>
<li><code>ReentrantLock(boolean fair)</code>  如果fair为true那么使用的是公平分配机制</li>
</ul>
</blockquote>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><blockquote>
<ul>
<li><code>lock()</code> 获取锁，如果没有获取到将会一直阻塞</li>
</ul>
<p>下面使用一段程序演示以下lock方法的使用，代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//实现接口的线程类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> ReentrantLock rLock = <span class="keyword">null</span>;  <span class="comment">//注意这里的锁一定要是全局变量，否则每一个线程都创建一把锁，那么将会毫无意义</span></div><div class="line"> </div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.rLock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 创建默认的可重入锁</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 将unlock方法放在finally中确保执行中代码出现异常仍然能够释放锁，否则将会造成其它的线程阻塞</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.rLock.lock(); <span class="comment">// 获取锁</span></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">"正在输出"</span></div><div class="line">						+ i);</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">finally</span> &#123;</div><div class="line">			<span class="keyword">this</span>.rLock.unlock(); <span class="comment">// 释放锁，注意这步是一定需要的</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.display(); <span class="comment">// 调用display方法</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//线程的测试类，主要是创建对象启动线程</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">final</span> MyThread thread = <span class="keyword">new</span> MyThread(); <span class="comment">// 创建对象</span></div><div class="line"></div><div class="line">		<span class="comment">// 下面创建两个线程,并且直接启动，</span></div><div class="line">		<span class="keyword">new</span> Thread(thread).start();</div><div class="line"></div><div class="line">		<span class="keyword">new</span> Thread(thread).start();</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行上面的代码得到下图的结果:</p>
<p><img src="http://ono60m7tl.bkt.clouddn.com/result.bmp" alt="结果"></p>
<p>从上面的结果看出，线程是一个一个输出的，并且只有等待一个线程输出完毕才能执行下一个线程，这里的仅仅是针对lock和unlock之间的代码，之外的代码并不是受到控制</p>
<p><strong>注意：</strong> 这里的创建的可重入锁的对象必须对于每一个线程来说是全局的变量，是可以共享的一个对象，如果你在display方法中创建这个对象，那么是毫无意义的，因为每一个线程用的根本不是同一把锁</p>
<ul>
<li><code>boolean tryLock()</code>  首先尝试获取锁，如果获取锁了就执行，否则就不会一直等待</li>
</ul>
<p>下面使用一段代码尝试以下这个方法，代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//实现接口的线程类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> ReentrantLock rLock = <span class="keyword">null</span>; <span class="comment">// 注意这里的锁一定要是全局变量，否则每一个线程都创建一把锁，那么将会毫无意义</span></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.rLock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 创建默认的可重入锁</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 将unlock方法放在finally中确保执行中代码出现异常仍然能够释放锁，否则将会造成其它的线程阻塞</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.rLock.tryLock()) <span class="comment">// 如果获取了锁</span></div><div class="line">		&#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">					System.out.println(Thread.currentThread().getName()</div><div class="line">							+ <span class="string">"正在输出"</span> + i);</div><div class="line">				&#125;</div><div class="line">			&#125; <span class="keyword">finally</span> &#123;</div><div class="line">				<span class="keyword">this</span>.rLock.unlock(); <span class="comment">// 释放锁，注意这步是一定需要的</span></div><div class="line">			&#125;</div><div class="line"></div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			System.out.println(Thread.currentThread().getName()</div><div class="line">					+ <span class="string">"获取锁失败，我将不会一直等待........"</span>);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.display(); <span class="comment">// 调用display方法</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//线程的测试类，主要是创建对象启动线程</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">final</span> MyThread thread = <span class="keyword">new</span> MyThread(); <span class="comment">// 创建对象</span></div><div class="line"></div><div class="line">		<span class="comment">// 下面创建两个线程,并且直接启动，</span></div><div class="line">		<span class="keyword">new</span> Thread(thread).start();</div><div class="line"></div><div class="line">		<span class="keyword">new</span> Thread(thread).start();</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行后的结果如下图:</p>
<p><img src="http://ono60m7tl.bkt.clouddn.com/re.bmp" alt="结果"></p>
<p>从上面的结果我们知道线程0获取了锁开始执行，但是线程1并没有获取锁，但是使用的是tryLock并不是lock,因此不会一直等待下去，所以直接程序向下运行，直接跳过上锁的代码段，因此就输出了上面的那句话后直接结</p>
</blockquote>
<h2 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h2><blockquote>
<p>从API中可以知道，这个也是一个接口，用于实现读写线程，他有两个方法：Lock readLock(),Lock writeLock() 分别用于获得读锁和写锁，指定特定的锁可以实现特定的功能，比如读锁可以在写线程在执行的情况下可以实现多个读线程进行操作，下面我们来介绍它的具体的实现的类ReentrantReadWriteLock </p>
</blockquote>
<h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><blockquote>
<p>这个类也是一个可重入分配的类，当然前面已经说过了什么是可重入，现在我们来说说说这个类的详细的用法</p>
</blockquote>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><blockquote>
<ul>
<li><code>ReentrantReadWriteLock()</code> 使用默认（非公平）的排序属性创建一个新的 ReentrantReadWriteLock。</li>
<li><code>ReentrantReadWriteLock(boolean fair)</code>  使用给定的公平策略创建一个新的ReentrantReadWriteLock。</li>
</ul>
</blockquote>
<h3 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h3><blockquote>
<ul>
<li><code>ReentrantReadWriteLock.ReadLock readLock()</code>   用于返回读取操作的锁</li>
</ul>
<p>前面已经说过读取操作的锁是用来实现多个线程共同执行的，代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//实现接口的线程类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> ReentrantReadWriteLock rwlock = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">public</span> Lock rLock = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.rwlock = <span class="keyword">new</span> ReentrantReadWriteLock(); <span class="comment">// 创建对象，使用的是非公平的</span></div><div class="line">		<span class="keyword">this</span>.rLock = <span class="keyword">this</span>.rwlock.readLock(); <span class="comment">// 获取读取锁对象</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 将unlock方法放在finally中确保执行中代码出现异常仍然能够释放锁，否则将会造成其它的线程阻塞</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.rLock.lock(); <span class="comment">// 获取读取锁</span></div><div class="line"></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">"正在输出"</span></div><div class="line">						+ i);</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">finally</span> &#123;</div><div class="line">			<span class="keyword">this</span>.rLock.unlock(); <span class="comment">// 释放锁，注意这步是一定需要的</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.display(); <span class="comment">// 调用display方法</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//线程的测试类，主要是创建对象启动线程</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">final</span> MyThread thread = <span class="keyword">new</span> MyThread(); <span class="comment">// 创建对象</span></div><div class="line"></div><div class="line">		<span class="comment">// 下面创建两个线程,并且直接启动，</span></div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">new</span> Thread(thread).start();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line"></div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行上面的程序结果如下:</p>
<p><img src="http://ono60m7tl.bkt.clouddn.com/result1.bmp" alt="结果"></p>
<p>从上面的结果可以知道，其实使用读取操作是多个线程同时进行读取的操作，因此一定要小心谨慎的使用，根据自己的需求，一般不能在里面进行修改了，因为出现结果不准确的结果，这个就不多说了，相信大家都明白，总之要小心使用</p>
<ul>
<li><code>ReentrantReadWriteLock.WriteLock writeLock()</code> 返回用于写入操作的锁 </li>
</ul>
<p>写入操作的锁和读取操作的锁不一样了，因为一次只能允许一个线程执行写入操作。</p>
<p>并且如果一个线程已经占用了读锁，另外一个线程申请写锁将会一直等待线程释放读锁。</p>
<p>如果一个线程已经占用了写锁，另外一个线程申请读锁，那么这个线程将会一直等待线程释放写锁才能执行。</p>
<p>总之意思就是写线程和读线程不能同时执行，但是多个读线程可以同时执行</p>
<p>下面将使用一个程序详细的体会以下读写锁的综合使用，代码如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//实现接口的线程类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> ReentrantReadWriteLock rwlock = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">public</span> Lock rLock = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">public</span> Lock wLock = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">public</span> ArrayList&lt;Integer&gt; arrayList = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.rwlock = <span class="keyword">new</span> ReentrantReadWriteLock(); <span class="comment">// 创建对象，使用的是非公平的</span></div><div class="line">		<span class="keyword">this</span>.rLock = <span class="keyword">this</span>.rwlock.readLock(); <span class="comment">// 获取读取锁对象</span></div><div class="line">		arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 实例化</span></div><div class="line">		<span class="keyword">this</span>.wLock = <span class="keyword">this</span>.rwlock.writeLock(); <span class="comment">// 获取写入锁对象</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 将unlock方法放在finally中确保执行中代码出现异常仍然能够释放锁，否则将会造成其它的线程阻塞</span></div><div class="line"></div><div class="line">	<span class="comment">// //向arraylist中写入数据</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">		<span class="keyword">this</span>.wLock.lock(); <span class="comment">// 获取写入锁</span></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">				System.out.println(Thread.currentThread().getName()</div><div class="line">						+ <span class="string">"正在执行写入操作，写入"</span> + i);</div><div class="line">				<span class="keyword">this</span>.arrayList.add(i);</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">finally</span> &#123;</div><div class="line">			<span class="keyword">this</span>.wLock.unlock();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 从arraylist中读取数据，这里只是随机读取使用的是get，并没有做什么修改，因为这仅仅是读取操作，如果进行了修改必须实现同步</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">		<span class="keyword">this</span>.rLock.lock(); <span class="comment">// 获取读取操作的锁</span></div><div class="line">		Random random = <span class="keyword">new</span> Random();</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (!arrayList.isEmpty()) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">					<span class="keyword">int</span> index = random.nextInt(<span class="keyword">this</span>.arrayList.size() - <span class="number">1</span>);</div><div class="line">					<span class="keyword">int</span> data = <span class="keyword">this</span>.arrayList.get(index);</div><div class="line">					System.out.println(Thread.currentThread().getName()</div><div class="line">							+ <span class="string">"正在读取数据     "</span> + data);</div><div class="line">				&#125;</div><div class="line">			&#125; <span class="keyword">finally</span> &#123;</div><div class="line">				<span class="keyword">this</span>.rLock.unlock();</div><div class="line"></div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			System.out.println(<span class="string">"ArrayList为空"</span>);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//线程的测试类，主要是创建对象启动线程</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">final</span> MyThread thread = <span class="keyword">new</span> MyThread(); <span class="comment">// 创建对象</span></div><div class="line"></div><div class="line">		ArrayList&lt;Thread&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">		<span class="comment">/*</span></div><div class="line">		 * 创建8个读线程，2个写线程</div><div class="line">		 */</div><div class="line">	</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</div><div class="line">			arrayList.add(<span class="keyword">new</span> Thread() &#123;</div><div class="line">				<span class="meta">@Override</span></div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">					thread.put();</div><div class="line">				&#125;</div><div class="line">			&#125;);</div><div class="line"></div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</div><div class="line">		&#123;</div><div class="line">			arrayList.add(<span class="keyword">new</span> Thread()&#123;</div><div class="line">				<span class="meta">@Override</span></div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">					thread.get();</div><div class="line">				&#125;</div><div class="line">			&#125;);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		</div><div class="line">		</div><div class="line">		</div><div class="line"></div><div class="line">		<span class="keyword">for</span> (Thread t : arrayList) &#123;</div><div class="line">			t.start();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>结果如下图:</p>
<p><img src="http://ono60m7tl.bkt.clouddn.com/thread.bmp" alt="结果"></p>
<p>从上面可以看出写入线程都是一个一个执行的，读取线程是一起执行的</p>
<p><strong>注意：</strong> 所有的锁对象对于线程来说必须是全局变量，否则毫无意义。读线程只能进行不影响线程安全性的操作，比如不能进行对数据的修改插入，如果想要进行修改的话必须还要使用锁对必要的代码实现同步操作</p>
</blockquote>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote>
<p><a href="http://www.cnblogs.com/dolphin0520/p/3923167.html" target="_blank" rel="external">http://www.cnblogs.com/dolphin0520/p/3923167.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Lock&quot;&gt;&lt;a href=&quot;#Lock&quot; class=&quot;headerlink&quot; title=&quot;Lock&quot;&gt;&lt;/a&gt;Lock&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在上一篇文章中我们讲到了如何使用关键字synchronized来实现同步访问。本文我们继续来探讨这
    
    </summary>
    
      <category term="java学习" scheme="http://chenjiabing666.github.io/categories/java%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>synchronized</title>
    <link href="http://chenjiabing666.github.io/2017/06/20/synchronized/"/>
    <id>http://chenjiabing666.github.io/2017/06/20/synchronized/</id>
    <published>2017-06-20T04:18:29.000Z</published>
    <updated>2017-06-20T04:22:54.372Z</updated>
    
    <content type="html"><![CDATA[<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>相信大家都听说过线程安全问题，在学习操作系统的时候有一个知识点是临界资源，简单的说就是一次只能让一个进程操作的资源，但是我们在使用多线程的时候是并发操作的，并不能控制同时只对一个资源的访问和修改，想要控制那么有几种操作，今天我们就来讲讲第一种方法：线程同步块或者线程同步方法(synchronized)</p>
</blockquote>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><blockquote>
<ul>
<li>下面举一个例子说明<code>synchronized</code>关键字的使用</li>
</ul>
</blockquote>
<h3 id="线程同步方法"><a href="#线程同步方法" class="headerlink" title="线程同步方法"></a>线程同步方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sychor</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">			System.out.println(thread.getName() + <span class="string">"输出:  "</span> + i);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">final</span> Sychor sychor = <span class="keyword">new</span> Sychor();</div><div class="line"></div><div class="line">		Thread t1 = <span class="keyword">new</span> Thread() &#123;</div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				sychor.insert(Thread.currentThread());</div><div class="line">			&#125;;</div><div class="line">		&#125;;</div><div class="line"></div><div class="line">		Thread t2 = <span class="keyword">new</span> Thread() &#123;</div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				sychor.insert(Thread.currentThread());</div><div class="line">			&#125;;</div><div class="line">		&#125;;</div><div class="line"></div><div class="line">		t1.start();</div><div class="line">		t2.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>其中输出结果为下图</p>
</blockquote>
<p><img src="http://ono60m7tl.bkt.clouddn.com/t1.bmp" alt="运行结果"></p>
<blockquote>
<p>从上面的结果可以看出这里的两个线程是同时执行<code>insert()</code>方法的，下面我们在原有的代码上添加<code>synchronized</code>关键字看看效果如何，代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sychor</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">			System.out.println(thread.getName() + <span class="string">"输出:  "</span> + i);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">final</span> Sychor sychor = <span class="keyword">new</span> Sychor();</div><div class="line"></div><div class="line">		Thread t1 = <span class="keyword">new</span> Thread() &#123;</div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				sychor.insert(Thread.currentThread());</div><div class="line">			&#125;;</div><div class="line">		&#125;;</div><div class="line"></div><div class="line">		Thread t2 = <span class="keyword">new</span> Thread() &#123;</div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				sychor.insert(Thread.currentThread());</div><div class="line">			&#125;;</div><div class="line">		&#125;;</div><div class="line"></div><div class="line">		t1.start();</div><div class="line">		t2.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面程序的运行结果我就不列出来，自己可以试试，总之就是加上了<code>synchronized</code>关键字使得线程是一个一个的执行的，只有先执行完一个线程才能执行了另外一个线程。</p>
</blockquote>
<h3 id="线程同步块"><a href="#线程同步块" class="headerlink" title="线程同步块"></a>线程同步块</h3><blockquote>
<p>当然上面的我们使用的是线程同步方法，我们可以使用线程同步块，这两个相比线程同步块更加灵活，只需要将需要同步的代码放在同步块中即可，代码如下；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sychor</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> </span>&#123;</div><div class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">				System.out.println(thread.getName() + <span class="string">"输出:  "</span> + i);</div><div class="line">			&#125;</div><div class="line">            </div><div class="line">		&#125;</div><div class="line">		</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">final</span> Sychor sychor = <span class="keyword">new</span> Sychor();</div><div class="line"></div><div class="line">		Thread t1 = <span class="keyword">new</span> Thread() &#123;</div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				sychor.insert(Thread.currentThread());</div><div class="line">			&#125;;</div><div class="line">		&#125;;</div><div class="line"></div><div class="line">		Thread t2 = <span class="keyword">new</span> Thread() &#123;</div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				sychor.insert(Thread.currentThread());</div><div class="line">			&#125;;</div><div class="line">		&#125;;</div><div class="line"></div><div class="line">		t1.start();</div><div class="line">		t2.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上面的代码中可以看出这种方式更加灵活，只需要将需要同步的代码方法在同步块中，不需要同步的代码放在外面</p>
</blockquote>
<h3 id="详细原因"><a href="#详细原因" class="headerlink" title="详细原因"></a>详细原因</h3><blockquote>
<ul>
<li>我们知道<strong>每一个对象都有一把锁</strong>，当我们使用线程同步方法或者线程同步块的时候实际上获得是对象的唯一的一把锁，当一个线程获得了这唯一的锁，那么其他的线程只能拒之门外了，注意这里我们说是一个对象，也就是说是同一个对象，如果是不同的对象，那么就不起作用了，因为不同对象有不同的对象锁，比如我们将上面的程序改成如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sychor</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> </span>&#123;</div><div class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">				System.out.println(thread.getName() + <span class="string">"输出:  "</span> + i);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">		<span class="comment">//第一个线程</span></div><div class="line">		Thread t1 = <span class="keyword">new</span> Thread() &#123;</div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				Sychor sychor = <span class="keyword">new</span> Sychor();   <span class="comment">//在run() 方法中创建一个对象</span></div><div class="line">				sychor.insert(Thread.currentThread());</div><div class="line">			&#125;;</div><div class="line">		&#125;;</div><div class="line"></div><div class="line">		<span class="comment">//第二个线程</span></div><div class="line">		Thread t2 = <span class="keyword">new</span> Thread() &#123;</div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				Sychor sychor = <span class="keyword">new</span> Sychor();  <span class="comment">//创建另外的一个对象</span></div><div class="line">				sychor.insert(Thread.currentThread());</div><div class="line">			&#125;;</div><div class="line">		&#125;;</div><div class="line"></div><div class="line">		t1.start();</div><div class="line">		t2.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>从上面的结果可知，此时线程同步块根本不起作用，因为他们调用的是<strong>不同对象</strong>的insert方法，获得锁是不一样的</p>
<ul>
<li>上面我们已经说过一个对象有一把锁，线程同步方法和线程同步块实际获得的是对象的锁，因此线程同步块的括号中填入的是<code>this</code>，我们都知道<code>this</code>在一个类中的含义</li>
</ul>
<ol>
<li><strong>一个类也有唯一的一把锁</strong>，我们前面说的是使用对象调用成员方法，现在如果我们要调用类中的静态方法，那么我们可以使用线程同步方法或者同步块获得类中的唯一一把锁，那么对于多个线程同时调用同一个类中的静态方法就可以实现控制了,代码如下:<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sychor</span> </span>&#123;</div><div class="line">	<span class="comment">// 静态方法</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span>  </span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</div><div class="line">		&#123;</div><div class="line">			System.out.println(thread.getName()+<span class="string">"输出     "</span>+i);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">		<span class="comment">//第一个线程</span></div><div class="line">		Thread t1 = <span class="keyword">new</span> Thread() &#123;</div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				Sychor.insert(Thread.currentThread());  <span class="comment">//直接使用类调用静态方法</span></div><div class="line">			&#125;;</div><div class="line">		&#125;;</div><div class="line"></div><div class="line">		<span class="comment">//第二个线程</span></div><div class="line">		Thread t2 = <span class="keyword">new</span> Thread() &#123;</div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				Sychor.insert(Thread.currentThread());   <span class="comment">//直接使用类调用静态方法</span></div><div class="line">			&#125;;</div><div class="line">		&#125;;</div><div class="line"></div><div class="line">		t1.start();</div><div class="line">		t2.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><blockquote>
<ol>
<li><p>要想实现线程安全和同步控制，如果执行的是非<code>static</code>同步方法或者其中的同步块，那么一定要使用同一个对象，如果调用的是static同步方法或者其中的同步块那么一定要使用同一个类去调用</p>
</li>
<li><p>如果一个线程访问的是<code>static</code>同步方法，而另外一个线程访问的是非static的同步方法，此时这两个是不会发生冲突的，因为一个是类的锁，一个是对象的锁</p>
</li>
<li><p>如果使用线程同步块，那么同步块中的代码是控制访问的，但是外面的代码是所有线程都可以访问的</p>
</li>
<li><p>当一个正在执行同步代码块的线程出现了异常，那么<code>jvm</code>会自动释放当前线程所占用的锁，因此不会出现由于异常导致死锁的现象</p>
</li>
</ol>
</blockquote>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote>
<p><a href="http://www.cnblogs.com/dolphin0520/p/3923737.html" target="_blank" rel="external">http://www.cnblogs.com/dolphin0520/p/3923737.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;synchronized&quot;&gt;&lt;a href=&quot;#synchronized&quot; class=&quot;headerlink&quot; title=&quot;synchronized&quot;&gt;&lt;/a&gt;synchronized&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;
    
    </summary>
    
      <category term="java学习" scheme="http://chenjiabing666.github.io/categories/java%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Thread初探</title>
    <link href="http://chenjiabing666.github.io/2017/06/20/Thread%E5%88%9D%E6%8E%A2/"/>
    <id>http://chenjiabing666.github.io/2017/06/20/Thread初探/</id>
    <published>2017-06-20T00:54:01.000Z</published>
    <updated>2017-06-20T00:54:35.270Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Thread初探"><a href="#Thread初探" class="headerlink" title="Thread初探"></a>Thread初探</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>以前大家写的都是单线程的程序，全是在main函数中调用方法，可以清楚的看到它的效率是特别低的，就像python中使用单线程取爬一个网站，可以说能让你等的吐血，因为数据量实在太大了，今天我们就来看看java的并发编程多线程的学习</p>
</blockquote>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><blockquote>
<p>创建一个线程可以有多种方法，比如继承Thread类，实现Runnable接口……下面我们来详细的看看创建的方法</p>
</blockquote>
<h3 id="继承Thread"><a href="#继承Thread" class="headerlink" title="继承Thread"></a>继承Thread</h3><blockquote>
<p>为什么继承<code>Thread</code>可以直接调用<code>start()</code>方法启动线程呢，因为<code>start()</code>本身就是Thread的方法，也就是继承了Thread的start()方法，因此这个类的对象可以调用start()启动线程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//继承Thread</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;    </div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">			System.out.println(<span class="keyword">this</span>.getName()+<span class="string">"正在跑"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">    &#123;</div><div class="line">        Mythread t1=<span class="keyword">new</span> MyThread();   <span class="comment">//创建对象</span></div><div class="line">        t1.start();     <span class="comment">//启动线程</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意:</strong>  继承<code>Thread</code>类的创建方法一个对象只能创建一个线程，并不能多个线程共用一个对象，只能一个线程对应一个对象，因此我们来看看实现<code>Runnable</code>接口的类来实现多个线程共享同一个对象</p>
</blockquote>
<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//实现Runnable接口</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;  </div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</div><div class="line">		&#123;</div><div class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">"正在跑"</span>);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//测试类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">    &#123;</div><div class="line">        Demo d=<span class="keyword">new</span> Demo();  <span class="comment">//创建对象</span></div><div class="line">        Thread thread1=<span class="keyword">new</span> Thread(d); <span class="comment">//为对象创建一个线程</span></div><div class="line">        Thread thread2=<span class="keyword">new</span> Thread(d);   <span class="comment">//创建另外一个线程</span></div><div class="line">        </div><div class="line">        <span class="comment">//同时启动两个线程</span></div><div class="line">        thread1.start();</div><div class="line">        thread2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>从上面可以清楚的看到实现<code>Runnable</code>接口的类一个对象可以供多个线程共享，并不像继承Thread类只为一个线程使用</p>
</blockquote>
<h3 id="简便的创建方法"><a href="#简便的创建方法" class="headerlink" title="简便的创建方法"></a>简便的创建方法</h3><blockquote>
<p>直接在<code>main</code>方法中创建，如果创建的普通类的对象在外面，那么必须是final修饰，可以实现多个线程同时共享一个对象，这个和实现<code>Runnable</code>接口一样，这时候就要控制同步条件了，如果在run方法中定义对象，那么，就是一个线程对应一个对象,这个就和继承Thread类一样的效果。所以可以根据条件自由选择</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//普通的一个类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</div><div class="line">		&#123;</div><div class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">"正在跑"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//线程测试类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//如果在外面必须使用final，当然也可以直写在run方法中,不过写在外面可以实现多个线程共享一个对象</span></div><div class="line">		<span class="comment">//写在run方法中当前对象只能为一个线程使用，和继承Thread类一样的效果</span></div><div class="line">		<span class="keyword">final</span> Simple simple=<span class="keyword">new</span> Simple(); </div><div class="line">		</div><div class="line">		</div><div class="line">		<span class="comment">//下面创建使用同一个对象创建同两个线程，实现多个线程共享一个对象，和实现Runnable接口一样的效果</span></div><div class="line">		Thread t1=<span class="keyword">new</span> Thread()&#123;</div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				simple.display();</div><div class="line">			&#125;;</div><div class="line">		&#125;;</div><div class="line">		</div><div class="line">		Thread t2=<span class="keyword">new</span> Thread()&#123;</div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				simple.display();</div><div class="line">			&#125;;</div><div class="line">		&#125;;</div><div class="line">		</div><div class="line">		<span class="comment">//启动这两个线程</span></div><div class="line">		t1.start();   </div><div class="line">		t2.start();</div><div class="line">    &#125;&#125;</div></pre></td></tr></table></figure>
<h2 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h2><blockquote>
<ul>
<li><p><code>static void sleep(long mils)</code> 使正在运行的线程休眠mils毫秒，但是这里需要注意的是如果线程加了锁，那么使线程休眠并不会释放锁</p>
</li>
<li><p><code>String getName()</code>   得到线程的名称，上面的程序中已经使用了这个方法</p>
</li>
<li><p><code>void setName(String name)</code>  设置正在运行的线程的名字为name</p>
</li>
<li><p><code>start()</code>  启动线程，线程的创建并不意味着线程的启动，只有调用start()方法线程才是真正的开始运行</p>
</li>
<li><p><code>long getId()</code>  返回线程的标识符</p>
</li>
<li><p><code>run()</code>  线程执行的代码都放在run()方法中，在run方法中的调用是有序的，都是按照程序运行的顺序开始执行</p>
</li>
</ul>
</blockquote>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><blockquote>
<p>下面使用上面的方法创建一个实例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//线程的类，继承Thread</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">// 重载run方法，并且在其中写线程执行的代码块</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">			<span class="comment">// 获取线程的id和name</span></div><div class="line">			System.out.println(<span class="string">"Thread-Name:   "</span> + <span class="keyword">this</span>.getName()</div><div class="line">					+ <span class="string">"   Thread-id:    "</span> + <span class="keyword">this</span>.getId());</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				<span class="keyword">this</span>.sleep(<span class="number">1000</span>); <span class="comment">// 线程休眠1秒</span></div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//线程测试的类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		MyThread1 t1 = <span class="keyword">new</span> MyThread1(); <span class="comment">// 创建线程</span></div><div class="line">		t1.setName(<span class="string">"第一个线程"</span>); <span class="comment">// 设置线程的名字</span></div><div class="line"></div><div class="line">		MyThread1 t2 = <span class="keyword">new</span> MyThread1();</div><div class="line">		t2.setName(<span class="string">"第二个线程"</span>);</div><div class="line"></div><div class="line">		t1.start(); <span class="comment">// 启动线程，开始运行</span></div><div class="line">		t2.start();</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>void join()</code>  等待该线程终止才能运行其他的线程</li>
<li><code>void join(long mils)</code>  等待该线程的时间为mils毫秒，一旦过了这个时间其他线程正常执行</li>
</ul>
</blockquote>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//线程类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">// 重载run方法，并且在其中写线程执行的代码块</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">			<span class="comment">// 获取线程的id和name</span></div><div class="line">			System.out.println(<span class="string">"Thread-Name:   "</span> + <span class="keyword">this</span>.getName()</div><div class="line">					+ <span class="string">"   Thread-id:    "</span> + <span class="keyword">this</span>.getId());</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				<span class="keyword">this</span>.sleep(<span class="number">1000</span>); <span class="comment">// 线程休眠1秒</span></div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//测试类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		MyThread1 t1 = <span class="keyword">new</span> MyThread1(); <span class="comment">// 创建线程</span></div><div class="line">		t1.setName(<span class="string">"第一个线程"</span>); <span class="comment">// 设置线程的名字</span></div><div class="line"></div><div class="line">		t1.start(); <span class="comment">// 启动线程，开始运行</span></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			t1.join();   <span class="comment">//阻塞其他线程，只有当这个线程运行完之后才开始运行其他的线程</span></div><div class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">			System.out.println(<span class="string">"主线程正在运行"</span>);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//输出结果</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">Thread-Name:   第一个线程   Thread-id:    9</div><div class="line">Thread-Name:   第一个线程   Thread-id:    9</div><div class="line">Thread-Name:   第一个线程   Thread-id:    9</div><div class="line">Thread-Name:   第一个线程   Thread-id:    9</div><div class="line">Thread-Name:   第一个线程   Thread-id:    9</div><div class="line">Thread-Name:   第一个线程   Thread-id:    9</div><div class="line">Thread-Name:   第一个线程   Thread-id:    9</div><div class="line">Thread-Name:   第一个线程   Thread-id:    9</div><div class="line">Thread-Name:   第一个线程   Thread-id:    9</div><div class="line">Thread-Name:   第一个线程   Thread-id:    9</div><div class="line">主线程正在运行</div><div class="line">主线程正在运行</div><div class="line">主线程正在运行</div><div class="line">主线程正在运行</div><div class="line">主线程正在运行</div><div class="line">主线程正在运行</div><div class="line">主线程正在运行</div><div class="line">主线程正在运行</div><div class="line">主线程正在运行</div><div class="line">主线程正在运行</div><div class="line"> */</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>getPriority()</code>  得到当前线程优先级</li>
<li><code>setPriority(int num)</code> 更改线程的优先级(0-10)默认的是5，优先级越高获得cpu资源的几率就会越高</li>
</ul>
</blockquote>
<h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//线程类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">// 重载run方法，并且在其中写线程执行的代码块</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">			<span class="comment">// 获取线程的id和name</span></div><div class="line">			System.out.println(<span class="string">"Thread-Name:   "</span> + <span class="keyword">this</span>.getName()</div><div class="line">					+ <span class="string">"   Thread-id:    "</span> + <span class="keyword">this</span>.getId());</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				<span class="keyword">this</span>.sleep(<span class="number">1000</span>); <span class="comment">// 线程休眠1秒</span></div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//测试类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		MyThread1 t1 = <span class="keyword">new</span> MyThread1(); <span class="comment">// 创建线程</span></div><div class="line">		t1.setName(<span class="string">"第一个线程"</span>); <span class="comment">// 设置线程的名字</span></div><div class="line"></div><div class="line">		MyThread1 t2 = <span class="keyword">new</span> MyThread1();</div><div class="line">		t2.setName(<span class="string">"第二个线程"</span>);</div><div class="line"></div><div class="line">		t2.setPriority(<span class="number">8</span>);   <span class="comment">//设置第二个线程的优先级为8，第一个线程的优先级为5(是默认的)</span></div><div class="line"></div><div class="line">		t1.start();</div><div class="line">		t2.start();</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 从上面的运行结果可以看出大部分的第二个线程都是在第一个线程之前开始执行的，也就是说优先级越高获得cpu执行的几率就越大</div><div class="line"> * /</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>setDaemon(boolean)</code> 是否设置为守护线程，如果设置为守护线程，那么主线程销毁守护线程也会随之销毁</li>
<li><code>isDaemon()</code>  判断是否为守护线程</li>
</ul>
</blockquote>
<h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//测试类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">// 重载run方法，并且在其中写线程执行的代码块</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">			<span class="comment">// 获取线程的id和name</span></div><div class="line">			System.out.println(<span class="string">"Thread-Name:   "</span> + <span class="keyword">this</span>.getName()</div><div class="line">					+ <span class="string">"   Thread-id:    "</span> + <span class="keyword">this</span>.getId());</div><div class="line"></div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				Thread.sleep(<span class="number">1000</span>);  <span class="comment">//休眠一秒，方便主线程运行结束</span></div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		MyThread1 t1 = <span class="keyword">new</span> MyThread1(); <span class="comment">// 创建线程</span></div><div class="line">		t1.setName(<span class="string">"第一个线程"</span>); <span class="comment">// 设置线程的名字</span></div><div class="line">		t1.setDaemon(<span class="keyword">true</span>);</div><div class="line">		t1.start();</div><div class="line"></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) &#123;</div><div class="line">			System.out.println(i);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//结果：</span></div><div class="line"><span class="comment">/*</span></div><div class="line"> 0</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">Thread-Name:   第一个线程   Thread-id:    9</div><div class="line">*/</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 从上面的结果可以看出，一旦主线程结束，那么守护线程就会自动的结束</div><div class="line"> * /</div></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote>
<ul>
<li><a href="http://www.cnblogs.com/dolphin0520/p/3920357.html" target="_blank" rel="external">http://www.cnblogs.com/dolphin0520/p/3920357.html</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Thread初探&quot;&gt;&lt;a href=&quot;#Thread初探&quot; class=&quot;headerlink&quot; title=&quot;Thread初探&quot;&gt;&lt;/a&gt;Thread初探&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
      <category term="java学习" scheme="http://chenjiabing666.github.io/categories/java%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java字符串进阶</title>
    <link href="http://chenjiabing666.github.io/2017/06/16/Java%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6/"/>
    <id>http://chenjiabing666.github.io/2017/06/16/Java字符串进阶/</id>
    <published>2017-06-16T04:53:57.000Z</published>
    <updated>2017-06-16T04:55:10.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java字符串进阶"><a href="#Java字符串进阶" class="headerlink" title="Java字符串进阶"></a>Java字符串进阶</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>最常用的对字符串操作的类有三个，分别是String,StringBuilder,StringBuffer，下面将会详细的说说这三个类……</p>
</blockquote>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><blockquote>
<p>String类代表字符串，这个是最基本的对字符串的类，这个也是使用比较多的类，这里就不再详细介绍了</p>
</blockquote>
<h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><blockquote>
<ul>
<li><code>new String(String str)</code></li>
<li><code>new String(StringBuilder str)</code></li>
<li><code>new String(StringBuffer str)</code></li>
<li><code>new String(byte[] bys,String charsetName)</code>  通过使用指定的字符集解码指定的 byte 子数组，构造一个新的 String。</li>
</ul>
</blockquote>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><blockquote>
<ul>
<li><code>str charAt(int index)</code>  返回指定索引处的字符</li>
<li><code>String concat(String str)</code>  将指定字符串str连接到此字符串的结尾，返回连接成功后的字符，因此需要接受才能有效果</li>
<li><code>boolean contains(CharSequence s)</code> 判断此字符串是否包含指定的char值序列，这里的 CharSequence是一个接口，可以直接使用它的子类作为参数(String,StringBuffer,StringBuild)</li>
<li><code>static String copyValueOf(char[] c)</code> 将字符数组变成字符串并且返回</li>
<li><code>static String copyValueOf(char[] c,int off,int count)</code> 将截取的字符数组变成字符串并且返回，off是开始截取的下标，count是截取的个数</li>
<li><code>boolean endWith(String s)</code>  判断字符串是否是以s结尾</li>
<li><code>boolean equals(Object o)</code>  用于比较</li>
<li><code>int indexOf(char c)</code> 返回字符c在字符串中第一次出现的索引</li>
<li><code>int indexOf(char c,int fromIndex)</code> 从指定索引处开始搜索，查找第一次出现的索引</li>
<li><code>int indexOf(String str)</code> 返回指定子字符串在此字符串中第一次出现处的索引。</li>
<li><code>int indexOf(String str,int fromIndex)</code> 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。</li>
<li><code>boolean isEmpty()</code>  </li>
<li><code>int length()</code></li>
<li><code>boolean matches(String regex)</code> 是否匹配正则表达式</li>
<li><code>trim()</code>   返回字符串的副本，忽略前导空白和尾部空白。</li>
<li><code>String substring(int beginIndex)</code> 返回一个新的字符串，它是此字符串的一个子字符串。 </li>
<li><code>String substring(int beginIndex, int endIndex)</code>  返回一个新字符串，它是此字符串的一个子字符串。 </li>
<li><code>String toUpperCase()</code>  使用默认语言环境的规则将此 String 中的所有字符都转换为大写。 </li>
<li><code>String[] split(String regex)</code> 根据给定正则表达式的匹配拆分此字符串。</li>
<li><code>String[] split(String regex, int limit)</code> 根据匹配给定的正则表达式来拆分此字符串。</li>
<li><code>char[] toCharArray()</code> 将此字符串转换为一个新的字符数组。</li>
<li><code>byte[] getBytes(Charset charset)</code>  使用给定的 <code>charset</code> 将此 <code>String</code> 编码到 <code>byte</code> 序列，并将结果存储到新的 byte 数组 </li>
</ul>
</blockquote>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote>
<ul>
<li>上面的new String(byte[] bys,String charsetName)这个构造方法很重要，它可以改变字符串的编码集(和byte[] getBytes(Charset charset))配合着使用，下面我们来看一个例子,代码如下:<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">      <span class="comment">/*</span></div><div class="line"> * InputStreamReader实现了将字节流FileInputStream转换为字符流，然后使用转换来的字节流创建高效流，从而实现高效的读写</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 编码集(我的eclipse编辑器默认的是utf-8</div><div class="line"> * 下面将中文字符串的编码集变为GBK写入a.txt文件,因为a.txt默认的是utf-8的因此这里在文件中显示的是乱码</div><div class="line"> * 然后我们读出来的还是GBK的，因为我们写入的是GBK编码集的，但是我的eclipse是utf-8的编码集，因此在控制台上输出的还是乱码</div><div class="line"> * new String(byte[] bys,String</div><div class="line"> * charsetName)使用这个构造方法将byte数组改变编码集并且转换为utf-8格式的，那么这次在控制台上输出的就不乱码了</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="comment">// 将GBK格式的中文写入a.txt文件</span></div><div class="line">File file = <span class="keyword">new</span> File(<span class="string">"src/a.txt"</span>);</div><div class="line">FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(file);</div><div class="line">String str = <span class="string">"中"</span>;</div><div class="line"><span class="keyword">byte</span>[] by = str.getBytes(<span class="string">"GBK"</span>); <span class="comment">// 将字符串改为GBK编码集</span></div><div class="line">fileOutputStream.write(by);</div><div class="line">fileOutputStream.close();</div><div class="line"></div><div class="line"><span class="comment">//从a.txt文件中读取中文</span></div><div class="line">FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(file);</div><div class="line"><span class="keyword">int</span> len;</div><div class="line"><span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</div><div class="line"><span class="keyword">while</span> ((len = fileInputStream.read(bys)) != -<span class="number">1</span>) &#123;</div><div class="line">	System.out.println(<span class="keyword">new</span> String(bys, <span class="string">"GBK"</span>));</div><div class="line">&#125;</div><div class="line">fileInputStream.close();</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><blockquote>
<p>线程安全的可变字符序列。一个类似于 <code>String</code> 的字符串缓冲区，但不能修改。当然最重要的一点就是线程安全，我们可以从它的源码中可以看出，对于一些操作(<code>append</code>,<code>insert</code>..)都是使用了线程控制块来实现同步，适合与多线程下的使用，源代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.append(String.valueOf(obj));</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.append(str);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.delete(start, end);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</div><div class="line"> * <span class="doctag">@since</span>      1.2</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">deleteCharAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.deleteCharAt(index);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a>构造</h3><blockquote>
<ul>
<li><code>new StringBuffer(StringBuilder str)</code></li>
<li><code>new StringBuffer(String str)</code></li>
</ul>
</blockquote>
<h3 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h3><blockquote>
<ul>
<li><code>StringBuffer append(str)</code>将指定类型的str追加到此字符串的后面(<code>String,char,char[],int,double,float,long,StringBuffer,StringBuilder</code>)</li>
<li><code>StringBuffer insert(int offest,  str)</code> 将指定类型的str插入到此序列中,offest表示开始插入的位置的索引,类型有 String,char,char[],int,double,float,long,StringBuffer,StringBuilder</li>
<li><code>String delete(int fromIndex,int endIndex)</code>   移除此序列中的字符串并且返回新的缓冲字符串</li>
<li><code>StringBuffer reverse()</code>  反转字符串</li>
<li><code>String substring(int start)</code>  返回一个新的 String，它包含此字符序列当前所包含的字符子序列。</li>
<li><code>String substring(int start, int end)</code> 返回一个新的 String，它包含此序列当前所包含的字符子序列。</li>
<li><code>StringBuffer deleteCharAt(int index)</code> 移除此序列指定位置的 char。</li>
<li><code>int length()</code>  长度</li>
<li><code>String toString()</code> 返回此序列中数据的字符串表示形式。    </li>
</ul>
</blockquote>
<h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><blockquote>
<p>建议优先采用该类，因为在大多数实现中，它比 <code>StringBuffer</code> 要快。但是这个类不是线程安全的，只适合单线程，如果使用多线程推荐使用<code>StringBuffer</code>,当然使用这个也行，不过需要自己实现同步</p>
</blockquote>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><blockquote>
<ul>
<li><code>new StringBuilder(String str)</code></li>
</ul>
</blockquote>
<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><blockquote>
<p>这个类的常用方法和<code>StringBuffer</code>的一样，这里就不再一一列举了，参照上面的即可使用</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java字符串进阶&quot;&gt;&lt;a href=&quot;#Java字符串进阶&quot; class=&quot;headerlink&quot; title=&quot;Java字符串进阶&quot;&gt;&lt;/a&gt;Java字符串进阶&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
      <category term="java学习" scheme="http://chenjiabing666.github.io/categories/java%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java基础" scheme="http://chenjiabing666.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java正则表达式</title>
    <link href="http://chenjiabing666.github.io/2017/06/16/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://chenjiabing666.github.io/2017/06/16/Java正则表达式/</id>
    <published>2017-06-15T16:18:57.000Z</published>
    <updated>2017-06-15T16:23:45.080Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java正则表达式"><a href="#Java正则表达式" class="headerlink" title="Java正则表达式"></a>Java正则表达式</h1><blockquote>
<p><code>java.util.regex</code>是一个用正则表达式所订制的模式来对字符串进行匹配工作的类库包。它包括两个类：<code>Pattern</code>和<code>Matcher</code>。Pattern是一个正则表达式经编译后的表现模式。Matcher对象是一个状态机器，它依据Pattern对象做为匹配模式对字符串展开匹配检查。 首先一个Pattern实例订制了一个所用语法与PERL的类似的正则表达式经编译后的模式，然后一个Matcher实例在这个给定的Pattern实例的模式控制下进行字符串的匹配工作。</p>
</blockquote>
<h2 id="正则表达式的构造摘要"><a href="#正则表达式的构造摘要" class="headerlink" title="正则表达式的构造摘要"></a>正则表达式的构造摘要</h2><blockquote>
<p>详细摘要请看<a href="http://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/regex/Pattern.html" target="_blank" rel="external">jdk中文文档</a>,下面我只是列出一些经常使用的</p>
</blockquote>
<table>
<thead>
<tr>
<th>构造</th>
<th>匹配</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>任何字符（与行结束符可能匹配也可能不匹配）</td>
</tr>
<tr>
<td>\d</td>
<td>数字：[0-9]</td>
</tr>
<tr>
<td>\D</td>
<td>非数字： [^0-9]</td>
</tr>
<tr>
<td>\s</td>
<td>空白字符：[ \t\n\x0B\f\r]</td>
</tr>
<tr>
<td>\S</td>
<td>非空白字符：[^\s]</td>
</tr>
<tr>
<td>\w</td>
<td>单词字符：[a-zA-Z_0-9]</td>
</tr>
<tr>
<td>\W</td>
<td>非单词字符：[^\w]</td>
</tr>
<tr>
<td>[abc]</td>
<td>a、b 或 c（简单类）</td>
</tr>
<tr>
<td>[^abc]</td>
<td>任何字符，除了 a、b 或 c（否定）</td>
</tr>
<tr>
<td>[a-zA-Z]</td>
<td>a 到 z 或 A 到 Z，两头的字母包括在内（范围）</td>
</tr>
<tr>
<td>^</td>
<td>行的开头</td>
</tr>
<tr>
<td>$</td>
<td>行的结尾</td>
</tr>
<tr>
<td>X?</td>
<td>X，一次或一次也没有</td>
</tr>
<tr>
<td>X*</td>
<td>X，零次或多次</td>
</tr>
<tr>
<td>X+</td>
<td>X，一次或多次</td>
</tr>
<tr>
<td>X{n}</td>
<td>X，恰好 n 次</td>
</tr>
<tr>
<td>X{n,}</td>
<td>X，至少 n 次</td>
</tr>
<tr>
<td>X{n,m}</td>
<td>X，至少 n 次，但是不超过 m 次</td>
</tr>
</tbody>
</table>
<h2 id="Pattern"><a href="#Pattern" class="headerlink" title="Pattern"></a>Pattern</h2><blockquote>
<p>正则表达式的编译表示形式,学过<code>python</code>的都知道这个和python的正则表达式有异曲同工之妙。 但是它的构造方法是私有的，因此不能直接创建对象，但是可以调用它的静态方法返回一个对象，下面会详细介绍</p>
</blockquote>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><blockquote>
<ul>
<li><code>Pattern</code>类用于创建一个正则表达式,也可以说创建一个匹配模式,它的构造方法是私有的,不可以直接创建,但可以通过<code>Pattern.complie(String regex)</code>简单工厂方法创建一个正则表达式，代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//采用的complie(String regex)</span></div><div class="line">Pattern pattern = Pattern.compile(<span class="string">"\\d+"</span>);</div><div class="line"></div><div class="line"><span class="comment">//采用的是complie(String regex,int flag)其中flag表示标志，下面的标志表示忽略字母大小写，详细的字段请看文档</span></div><div class="line">Pattern pattern=Pattern.compile(<span class="string">"(CHEN)(\\D*)(\\d*)"</span>,Pattern.CASE_INSENSITIVE);</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><blockquote>
<ul>
<li><code>Pattern compile(String regex)</code>  用于创建Pattern对象</li>
<li><code>Pattern compile(String regex,int flags)</code>  用于创建Pattern对象，并且指定了标志(比如忽略字母大小写)</li>
<li><code>int flags()</code>  返回此模式的匹配标志</li>
<li><p><code>String pattern()</code>   返回在其中编译过此模式的正则表达式。</p>
</li>
<li><p><code>String[] split(CharSequence input)</code> 根据此模式的正则表达式将输入的字符串拆分成String数组,默认的都是全部拆分开</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">//给出正则表达式用于匹配数字(0-9)</span></div><div class="line">   Pattern pattern = Pattern.compile(<span class="string">"\\d+"</span>);</div><div class="line">   String str = <span class="string">"我是陈加兵456郑元梅34擦市场的逻辑啊"</span>;</div><div class="line">String[] splits = pattern.split(str, <span class="number">2</span>);   <span class="comment">//结果:[我是陈加兵,郑元梅34擦市场的逻辑啊]</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>String[] split(CharSequence input,int limit)</code>  将字符串按照正则表达式表示的内容进行分组，如果limit&gt;0那么就分成limit个组，如果limit&lt;0就按照默认全部分开</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//给出正则表达式用于匹配数字(0-9)</span></div><div class="line">Pattern pattern = Pattern.compile(<span class="string">"\\d+"</span>);</div><div class="line">String str = <span class="string">"我是陈加兵456郑元梅34擦市场的逻辑啊"</span>;</div><div class="line">String[] splits = pattern.split(str, <span class="number">2</span>);   <span class="comment">//结果:[我是陈加兵,郑元梅34擦市场的逻辑啊]</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>Pattern.matches(String regex,CharSequence input)</code>是一个静态方法,用于快速匹配字符串,该方法适合用于只匹配一次,且匹配全部字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Pattern.matches(<span class="string">"\\d+"</span>,<span class="string">"2223"</span>);<span class="comment">//返回true </span></div><div class="line">Pattern.matches(<span class="string">"\\d+"</span>,<span class="string">"2223aa"</span>);<span class="comment">//返回false,需要匹配到所有字符串才能返回true,这里aa不能匹配到 </span></div><div class="line">Pattern.matches(<span class="string">"\\d+"</span>,<span class="string">"22bb23"</span>);<span class="comment">//返回false,需要匹配到所有字符串才能返回true,这里bb不能匹配到</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>Matcher matcher(CharSequence input)</code>  创建匹配给定输入与此模式的匹配器,现在只是先了解以下，下面会详细解释Matcher这个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Pattern p=Pattern.compile(<span class="string">"\\d+"</span>); </div><div class="line">Matcher m=p.matcher(<span class="string">"22bb23"</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h2 id="Matcher"><a href="#Matcher" class="headerlink" title="Matcher"></a>Matcher</h2><blockquote>
<p><code>Pattern</code>类只能做一些简单的匹配操作,要想得到更强更便捷的正则匹配操作,那就需要将Pattern与Matcher一起合作.Matcher类提供了对正则表达式的分组支持,以及对正则表达式的多次匹配支持.<br>Matcher类和Pattern类一样它的构造方法同样是私有的，因此不能直接构造对象，但是上面我们说过Pattern类中有一个方法可以返回一个Matcher对象(<code>matcher(CharSequence input)</code>)</p>
</blockquote>
<h3 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h3><blockquote>
<ul>
<li><p><code>boolean mathces()</code>  尝试将整个区域与模式匹配(针对的是整个字符串，如果整个字符串未完全匹配，那么返回false,如果完全匹配那么返回true) </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">      Pattern pattern=Pattern.compile(<span class="string">"\\d+"</span>);  <span class="comment">//创建Pattern对象</span></div><div class="line">String str=<span class="string">"I am hreo 1234"</span>;  <span class="comment">//需要匹配的字符串</span></div><div class="line">Matcher matcher=pattern.matcher(str);</div><div class="line">      <span class="comment">//并没有完全匹配，因此返回false，如果str="123445"，那么就会返回true</span></div><div class="line">System.out.println(matcher.matches());</div></pre></td></tr></table></figure>
</li>
<li><p><code>boolean lookingAt()</code> 尝试从给定字符串的开头开始匹配，如果有子字符串匹配成功，那么返回true(针对的不是整个字符串，而是从开头开始，如果开头有一段字符串匹配成功，那么返回true)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">      Pattern pattern=Pattern.compile(<span class="string">"\\d+"</span>);  <span class="comment">//创建Pattern对象</span></div><div class="line">String str=<span class="string">"1234 I am a hero"</span>;  <span class="comment">//需要匹配的字符串</span></div><div class="line">Matcher matcher=pattern.matcher(str);</div><div class="line"><span class="comment">//开头的1234匹配到了，因此返回true，如果str="I am a hero  1234"将返回false</span></div><div class="line">System.out.println(matcher.lookingAt());</div></pre></td></tr></table></figure>
</li>
<li><p><code>int start()</code>    匹配到的字符串的第一个元素的索引,如果没有匹配到调用此方法将会报错</p>
</li>
<li><code>int end()</code>     匹配到的字符串的最后一个元素的索引,如果没有匹配到调用此方法将会报错</li>
<li><p><code>String group()</code>  返回的是匹配到的字符串,如果没有匹配到调用此方法将会报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">      Pattern pattern=Pattern.compile(<span class="string">"\\d+"</span>);  <span class="comment">//创建Pattern对象</span></div><div class="line">String str=<span class="string">"1234 I am a hero 33455"</span>;  <span class="comment">//需要匹配的字符串</span></div><div class="line">Matcher matcher=pattern.matcher(str);</div><div class="line"><span class="keyword">if</span>(matcher.lookingAt())</div><div class="line">&#123;</div><div class="line">	System.out.println(<span class="string">"开始匹配到下标为"</span>+matcher.start());  <span class="comment">//0</span></div><div class="line">	System.out.println(<span class="string">"匹配结束的下标为"</span>+matcher.end());    <span class="comment">//4</span></div><div class="line">          System.out.println(<span class="string">"匹配的字符串为"</span>+matcher.group());  <span class="comment">//1234</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>boolean find()</code>  查找整个字符串，如果在任意位置有一段字符串能够匹配成功，那么返回true(任意位置),然后如果再次调用这个查找的话，那么就从上次查找到的末尾开始匹配，也就是说查找的是下一个子序列了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">      Pattern pattern=Pattern.compile(<span class="string">"\\d+"</span>);  <span class="comment">//创建Pattern对象</span></div><div class="line">String str=<span class="string">"1234 I am a hero 6666 chenjiabing8888"</span>;  <span class="comment">//需要匹配的字符串</span></div><div class="line">Matcher matcher=pattern.matcher(str);</div><div class="line"><span class="keyword">while</span>(matcher.find())  <span class="comment">//如果还有匹配的字符序列</span></div><div class="line">&#123;</div><div class="line">	System.out.println(<span class="string">"开始匹配到下标为"</span>+matcher.start()); </div><div class="line">	System.out.println(<span class="string">"匹配结束的下标为"</span>+matcher.end());   </div><div class="line">	System.out.println(<span class="string">"匹配的字符串为"</span>+matcher.group());  </div><div class="line">&#125;  </div><div class="line">      </div><div class="line">  <span class="comment">/*结果如下：</span></div><div class="line">   * </div><div class="line">  开始匹配到下标为0</div><div class="line">  匹配结束的下标为4</div><div class="line">  匹配的字符串为1234</div><div class="line">  开始匹配到下标为17</div><div class="line">  匹配结束的下标为21</div><div class="line">  匹配的字符串为6666</div><div class="line">  开始匹配到下标为33</div><div class="line">  匹配结束的下标为37</div><div class="line">  匹配的字符串为8888</div><div class="line">  */</div><div class="line">  </div><div class="line">  <span class="comment">/*</span></div><div class="line">   * 从上面返回的结果可以知道，find()可以匹配多次只要这个字符串还有可以匹配，</div><div class="line">   * 并且每次的匹配字段的开始下标都是上一次匹配的结束字母的下一个下标</div><div class="line">   */</div></pre></td></tr></table></figure>
</li>
<li><p><code>boolean find(int start)</code>  从指定的索引start位置开始匹配，这个用于重置find()匹配器，因为直接使用find()它的每次开始的索引都是不一样的</p>
</li>
<li><p><code>String group(int num)</code> 返回指定分组匹配到的字符串,group(0)表示匹配到的整个字符串,group(1) 表示匹配到的第一个字符(即是第一个括号中匹配的模式)</p>
</li>
<li><code>int groupCount()</code>  返回匹配到的分组个数</li>
<li><code>String replaceAll(String str)</code>  将所有于模式相匹配的 字符串全部替换程指定的字符串str,返回的是替换后的文本</li>
<li><code>String replaceFirst(String str)</code>  只将第一次匹配到的字符串替换成指定的字符串str，返回的时替换后的文本</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Pattern pattern=Pattern.compile(<span class="string">"\\d+"</span>);</div><div class="line">String str=<span class="string">"chenjiabing2344cal3445"</span>;</div><div class="line">Matcher matcher=pattern.matcher(str);</div><div class="line">str=matcher.replaceFirst(<span class="string">"陈加兵"</span>);   </div><div class="line">System.out.println(str);   <span class="comment">//输出:chenjiabing陈加兵cal3445</span></div><div class="line">      </div><div class="line">      <span class="comment">/*</span></div><div class="line">       * str=matcher.replaceAll("陈加兵");</div><div class="line">       * System.out.println(str)    //输出:chenjiabing陈加兵cal陈加兵</div><div class="line">       */</div></pre></td></tr></table></figure>
<h2 id="捕获组"><a href="#捕获组" class="headerlink" title="捕获组"></a>捕获组</h2><blockquote>
<p>捕获组可以通过从左到右计算其开括号来编号，编号是从<code>1</code> 开始的。例如，在表达式 <code>((A)(B(C)))</code>中，存在四个这样的组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">((A)(B(C)))</div><div class="line">(A)</div><div class="line">(B(C))</div><div class="line">(C)</div></pre></td></tr></table></figure></p>
<p>总之在正则表达式中在括号中的就是一个分组,下面用一个实例来理解一下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">      Pattern pattern=Pattern.compile(<span class="string">"(\\D*)(\\d+)\\s(\\D+)"</span>);</div><div class="line">Matcher matcher=pattern.matcher(<span class="string">"chenjiabingshizuibangde6666 chenjiabign"</span>);</div><div class="line"><span class="keyword">if</span>(matcher.find())</div><div class="line">&#123;</div><div class="line">	System.out.println(<span class="string">"总共匹配到了"</span>+matcher.groupCount()+<span class="string">"个分组"</span>);</div><div class="line">	System.out.println(<span class="string">"匹配到整个字符串为"</span>+matcher.group(<span class="number">0</span>));</div><div class="line">	System.out.println(<span class="string">"匹配到的第一个字符串为"</span>+matcher.group(<span class="number">1</span>));</div><div class="line">	System.out.println(<span class="string">"匹配到的第二个字符串为"</span>+matcher.group(<span class="number">2</span>));</div><div class="line">	System.out.println(<span class="string">"匹配到的第三个字符串为"</span>+matcher.group(<span class="number">3</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="贪婪模式和非贪婪模式"><a href="#贪婪模式和非贪婪模式" class="headerlink" title="贪婪模式和非贪婪模式"></a>贪婪模式和非贪婪模式</h2><blockquote>
<p>贪婪与非贪婪模式影响的是被量词修饰的子表达式的匹配行为，贪婪模式在整个表达式匹配成功的前提下，尽可能多的匹配，而非贪婪模式在整个表达式匹配成功的前提下，尽可能少的匹配<br>一般写<code>python</code>爬虫的时候使用的都是非贪婪模式来匹配<br>使用了贪婪模式后会尽可能匹配更多的字符串，即是到了正则表达式定的末尾但是还是会继续向后匹配，看看是否还能匹配，非贪婪模式则是相反，到了正则表达式定义的结束字符就直接停止匹配了<br>贪婪模式: <code>.*</code> , <code>.+</code><br>非贪婪模式: <code>.*?</code>  , <code>.+?</code></p>
</blockquote>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">      <span class="comment">//使用了贪婪模式,因此当匹配到第一个&lt;/div&gt;的时候还要向后面匹配看看是否还能匹配到，由于后面还有&lt;/div&gt;结尾的，因此还是能够匹配的，因此匹配到的是:陈加兵&lt;/div&gt;&lt;div&gt;郑元梅</span></div><div class="line">      Pattern pattern=Pattern.compile(<span class="string">"&lt;div&gt;(.*)&lt;/div&gt;"</span>);   </div><div class="line"></div><div class="line"><span class="comment">//使用了非贪婪模式，因此当匹配到第一个&lt;/div&gt;的时候就不向后面匹配了，直接返回了，因此匹配到的是:陈加兵</span></div><div class="line">Pattern pattern1=Pattern.compile(<span class="string">"&lt;div&gt;(.*?)&lt;/div&gt;"</span>);   </div><div class="line">String str=<span class="string">"&lt;div&gt;陈加兵&lt;/div&gt;&lt;div&gt;郑元梅&lt;/div&gt;"</span>;</div><div class="line">Matcher matcher=pattern1.matcher(str);</div><div class="line"><span class="keyword">if</span>(matcher.find())</div><div class="line">&#123;</div><div class="line">	System.out.println(matcher.groupCount());  <span class="comment">//1</span></div><div class="line">	System.out.println(matcher.group(<span class="number">1</span>));  <span class="comment">//输出匹配到的字符串,此时输出的是:陈加兵,如果使用贪婪模式输出的是：陈加兵&lt;/div&gt;&lt;div&gt;郑元梅</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote>
<ul>
<li><a href="http://www.cnblogs.com/ggjucheng/p/3423731.html" target="_blank" rel="external">http://www.cnblogs.com/ggjucheng/p/3423731.html</a></li>
<li><a href="http://www.runoob.com/java/java-regular-expressions.html" target="_blank" rel="external">http://www.runoob.com/java/java-regular-expressions.html</a></li>
<li><a href="http://blog.csdn.net/lxcnn/article/details/4756030" target="_blank" rel="external">http://blog.csdn.net/lxcnn/article/details/4756030</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java正则表达式&quot;&gt;&lt;a href=&quot;#Java正则表达式&quot; class=&quot;headerlink&quot; title=&quot;Java正则表达式&quot;&gt;&lt;/a&gt;Java正则表达式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;java.util.regex&lt;/code&gt;是
    
    </summary>
    
      <category term="java学习" scheme="http://chenjiabing666.github.io/categories/java%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java基础" scheme="http://chenjiabing666.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java日期格式化</title>
    <link href="http://chenjiabing666.github.io/2017/06/15/Java%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
    <id>http://chenjiabing666.github.io/2017/06/15/Java日期格式化/</id>
    <published>2017-06-15T04:22:39.000Z</published>
    <updated>2017-06-15T11:08:40.548Z</updated>
    
    <content type="html"><![CDATA[<h1 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<ul>
<li>更多文章请看本人博客<a href="https://chenjiabing666.github.io/">https://chenjiabing666.github.io/</a></li>
<li>版权所有，如需转载请注明来源</li>
</ul>
</blockquote>
<h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><blockquote>
<p><code>Date</code>类表示特定的瞬间精确到毫秒，不过从API可以看出很多的方法已经废弃了，这个类已经在过多使用了，不过还是需要了解一下的，为了后面的学习做铺垫</p>
</blockquote>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><blockquote>
<ul>
<li><code>new Date()</code></li>
</ul>
</blockquote>
<h3 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h3><blockquote>
<ul>
<li><code>long getTime()</code> 返回计算机上面的时间，返回的是毫秒</li>
<li><code>setTime(long s)</code> 用给定的毫秒值s设置时间</li>
</ul>
</blockquote>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Date date=<span class="keyword">new</span> Date();</div><div class="line">System.out.println(date.getTime());</div></pre></td></tr></table></figure>
<h2 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h2><blockquote>
<ul>
<li>这个类是一个简单的格式化日期的类，继承与<code>DateFormat</code>,相对于父类来说使用简单</li>
</ul>
</blockquote>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><blockquote>
<ul>
<li><code>new SimpleDateFormat()</code>  使用默认的格式化模板创建对象</li>
<li><code>new SimpleDateFormat(String pattern)</code>   使用指定的格式化模板创建对象</li>
</ul>
</blockquote>
<h3 id="常用的方法-1"><a href="#常用的方法-1" class="headerlink" title="常用的方法"></a>常用的方法</h3><blockquote>
<ul>
<li><code>String format(Date date)</code>   将给定的日期格式化指定的模板的样式,比如<code>2017-01-29 23:22:11</code></li>
<li><code>applyPattern(String pattern)</code> 将给定的格式应用于此日期的格式，相当于直接使用new Date(String pattern)</li>
<li><code>Date parse(String d)</code>  将给定的格式化的日期格式字符串转换成<code>Date</code>对象，需要注意的是转化的时候定义的模板一定要和字符串的日期格式的模板一样，否则将会解析不正确的形式</li>
</ul>
</blockquote>
<h3 id="常用的日期格式化的模板"><a href="#常用的日期格式化的模板" class="headerlink" title="常用的日期格式化的模板"></a>常用的日期格式化的模板</h3><blockquote>
<p><img src="http://ono60m7tl.bkt.clouddn.com/%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F.bmp" alt="日期格式化的格式"></p>
</blockquote>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><blockquote>
<ul>
<li>使用默认的模板格式化日期</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SimpleDateFormat dateFormat=<span class="keyword">new</span> SimpleDateFormat();   <span class="comment">//默认的格式</span></div><div class="line">String formateString=dateFormat.format(date);   <span class="comment">//格式化当前的日期</span></div><div class="line">System.out.println(formateString);</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>使用指定的模板格式化日期</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String model=<span class="string">"yyyy-MM-dd-FF  HH:mm:ss"</span>;  <span class="comment">//指定格式化的模板</span></div><div class="line">SimpleDateFormat dateFormat2=<span class="keyword">new</span> SimpleDateFormat(model);</div><div class="line">System.out.println(dateFormat2.format(date));</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>将格式化的日期转换成<code>Date</code>类型的，使用的<code>parse(String s)</code>，需要注意的是，下面定义的模板一定要和给定的格式化后的日期格式一样，否则转换后Date类型的毫秒值可能不正确</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">      String d = <span class="string">"2017-06-12 22:34:19"</span>;   <span class="comment">//给出格式化后的日期</span></div><div class="line">String pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>;  <span class="comment">//按照上面的日期格式定义模板，这个一定要完全和上面的一样，否则转换不正确</span></div><div class="line">SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(pattern);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">	Date date = dateFormat.parse(d);   <span class="comment">//解析成Date类型</span></div><div class="line">	System.out.println(dateFormat.format(date));</div><div class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</div><div class="line">	System.err.println(<span class="string">"解析错误"</span>);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>综合使用：计算时间差</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Scanner scanner=<span class="keyword">new</span> Scanner(System.in);</div><div class="line">System.out.println(<span class="string">"请输入年-月-日"</span>);</div><div class="line">String startTime=scanner.next();</div><div class="line">System.out.println(<span class="string">"请输入结束时间(年-月-日)"</span>);</div><div class="line">String endTime=scanner.next();</div><div class="line">String moudle=<span class="string">"yyyy-MM-dd"</span>;   <span class="comment">//定义时间模板</span></div><div class="line"><span class="comment">//创建指定模板的解析</span></div><div class="line">SimpleDateFormat dateFormat=<span class="keyword">new</span> SimpleDateFormat(moudle);</div><div class="line">Date startDate=dateFormat.parse(startTime);<span class="comment">//解析开始时间</span></div><div class="line">Date endDate =dateFormat.parse(endTime);<span class="comment">//解析结束时间</span></div><div class="line"><span class="keyword">long</span> time=startDate.getTime()-endDate.getTime();  <span class="comment">//返回两个时间的差，毫秒</span></div><div class="line"><span class="keyword">int</span> day=(<span class="keyword">int</span>)(time/<span class="number">1000</span>/<span class="number">60</span>/<span class="number">60</span>/<span class="number">24</span>);  <span class="comment">//转化为天数，1秒等于1000毫秒，一分钟等于60秒，一小时等于60分钟，一天等于24小时</span></div><div class="line">System.out.println(day);</div></pre></td></tr></table></figure>
<h2 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h2><blockquote>
<p>Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等 日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。瞬间可用毫秒值来表示，它是距历元（即格林威治标准时间 1970 年 1 月 1 日的 00:00:00.000，格里高利历）的偏移量。 </p>
</blockquote>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><blockquote>
<ul>
<li><code>Calendar.getInstance()</code></li>
</ul>
</blockquote>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><blockquote>
<ul>
<li><code>int get(int field)</code>  返回当前对象的一些日期信息</li>
<li><code>Date getTime()</code>  获得当前日期的<code>Date</code>对象</li>
<li><code>add(int field,int amount)</code>  根据日历的规则，为给定的日历字段添加或减去指定的时间量。例如，要从当前日历时间减去 5 天，可以通过调用以下方法做到这一点：<code>add(Calendar.DAY_OF_MONTH, -5)</code>。 </li>
<li><code>setTime(Date date)</code>  使用给定的<code>Date</code>对象，设置<code>Calendar</code>时间</li>
</ul>
</blockquote>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><blockquote>
<ul>
<li><code>get</code>方法获取一些字段的值</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">      Calendar calendar = Calendar.getInstance(); <span class="comment">// 创建对象</span></div><div class="line">System.out.println(calendar.get(Calendar.YEAR));<span class="comment">// 获取年份</span></div><div class="line">System.out.println(calendar.get(Calendar.MONTH) + <span class="number">1</span>);<span class="comment">// 月，从0开始，即是输出5表示6月</span></div><div class="line">System.out.println(calendar.get(Calendar.DATE));<span class="comment">// 获取一个月中的第几天</span></div><div class="line">System.out.println(calendar.get(Calendar.HOUR)); <span class="comment">// 小时</span></div><div class="line">System.out.println(calendar.get(Calendar.MINUTE)); <span class="comment">// 分钟</span></div><div class="line">System.out.println(calendar.get(Calendar.SECOND)); <span class="comment">// 秒</span></div><div class="line">System.out.println(calendar.get(Calendar.AM_PM)); <span class="comment">// 获得是上午还是下午AM=0,PM=1</span></div><div class="line">System.out.println(calendar.get(Calendar.DAY_OF_MONTH)); <span class="comment">// 一个月中的第几天</span></div><div class="line">System.out.println(calendar.get(Calendar.DAY_OF_WEEK)); <span class="comment">// 一周中的第几天，星期日是第一天</span></div><div class="line">System.out.println(calendar.get(Calendar.DAY_OF_YEAR));<span class="comment">// 一年中的第几天</span></div><div class="line">System.out.println(calendar.get(Calendar.HOUR_OF_DAY)); <span class="comment">// 一天中的第几小时</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> (calendar.get(Calendar.AM_PM) == Calendar.AM) &#123;</div><div class="line">	System.out.println(<span class="string">"现在是上午"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (calendar.get(Calendar.MONTH) + <span class="number">1</span> == Calendar.JULY) &#123;</div><div class="line">	System.out.println(<span class="string">"现在是6月"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>Date getTime()</code>方法的使用</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Calendar calendar=Calendar.getInstance();</div><div class="line">Date date=calendar.getTime();   <span class="comment">//获得Date对象</span></div><div class="line">String pattern=<span class="string">"yyyy-MM-dd  HH:mm:ss"</span>;</div><div class="line">SimpleDateFormat dateFormat=<span class="keyword">new</span> SimpleDateFormat(pattern);</div><div class="line">System.out.println(dateFormat.format(date));</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>add(int field,int amount)</code>方法的使用</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">      Calendar calendar=Calendar.getInstance();</div><div class="line">calendar.add(Calendar.DATE, -<span class="number">2</span>);</div><div class="line">System.out.println(calendar.get(Calendar.DATE));</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>综合实例：计算出当前的准确日期</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">      Calendar calendar = Calendar.getInstance();</div><div class="line"><span class="keyword">int</span> year = calendar.get(Calendar.YEAR);</div><div class="line"><span class="keyword">int</span> month = calendar.get(calendar.MONTH) + <span class="number">1</span>; <span class="comment">// 从0开始算，因此加1</span></div><div class="line"><span class="keyword">int</span> date = calendar.get(Calendar.DATE);</div><div class="line"><span class="keyword">int</span> week = calendar.get(Calendar.WEEK_OF_MONTH) + <span class="number">1</span>; <span class="comment">// 从周日开始算，因此加1</span></div><div class="line"><span class="keyword">int</span> hour = calendar.get(Calendar.HOUR);</div><div class="line"><span class="keyword">int</span> minute = calendar.get(Calendar.MINUTE);</div><div class="line"><span class="keyword">int</span> seconds = calendar.get(Calendar.SECOND);</div><div class="line"><span class="keyword">if</span> (calendar.get(Calendar.AM_PM) == Calendar.AM) &#123;</div><div class="line"></div><div class="line">	System.out.println(<span class="string">"现在是"</span> + year + <span class="string">"年"</span> + month + <span class="string">"月"</span> + date + <span class="string">"号"</span></div><div class="line">			+ <span class="string">"星期"</span> + week + <span class="string">"上午"</span> + hour + <span class="string">"点"</span> + minute + <span class="string">"分"</span> + seconds</div><div class="line">			+ <span class="string">"秒"</span>);</div><div class="line"></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">	System.out.println(<span class="string">"现在是"</span> + year + <span class="string">"年"</span> + month + <span class="string">"月"</span> + date + <span class="string">"号"</span></div><div class="line">			+ <span class="string">"星期"</span> + week + <span class="string">"下午"</span> + hour + <span class="string">"点"</span> + minute + <span class="string">"分"</span> + seconds</div><div class="line">			+ <span class="string">"秒"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;日期格式化&quot;&gt;&lt;a href=&quot;#日期格式化&quot; class=&quot;headerlink&quot; title=&quot;日期格式化&quot;&gt;&lt;/a&gt;日期格式化&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前
    
    </summary>
    
      <category term="java学习" scheme="http://chenjiabing666.github.io/categories/java%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java基础" scheme="http://chenjiabing666.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java反射机制</title>
    <link href="http://chenjiabing666.github.io/2017/06/14/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://chenjiabing666.github.io/2017/06/14/Java反射机制/</id>
    <published>2017-06-14T07:53:54.000Z</published>
    <updated>2017-06-14T16:56:25.372Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a>Java反射机制</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<ul>
<li><a href="http://tool.oschina.net/apidocs/apidoc?api=jdk-zh" target="_blank" rel="external">网页版的jdk的API</a></li>
<li><a href="http://download.csdn.net/detail/qq_34162294/9870892" target="_blank" rel="external">离线版API</a></li>
</ul>
</blockquote>
<h2 id="什么是反射机制"><a href="#什么是反射机制" class="headerlink" title="什么是反射机制"></a>什么是反射机制</h2><blockquote>
<p>反射是java语言的一个特性，它允程序在运行时（注意不是编译的时候）来进行自我检查并且对内部的成员进行操作。例如它允许一个java的类获取他所有的成员变量和方法并且显示出来。这个能特定我们不常看到，但是在其他的比如C或者C++语言中很不就存在这个特性。一个常见的例子是在JavaBean中，一些组件可以通过一个构造器来操作。这个构造器就是用的反射在动态加载的时候来获取的java中类的属性的。</p>
</blockquote>
<h2 id="主要的类"><a href="#主要的类" class="headerlink" title="主要的类"></a>主要的类</h2><blockquote>
<ul>
<li><code>Class</code> 类的实例表示正在运行的 Java 应用程序中的类和接口。Class没有公共的构造方法，Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的</li>
<li><code>Constructor</code>  提供关于类的单个构造方法的信息以及对它的访问权限(主要提供的是对构造方法使用)</li>
<li><code>Method</code>  提供关于类或接口上单独某个方法（以及如何访问该方法）的信息。所反映的方法可能是类方法或实例方法（包括抽象方法)</li>
<li><code>Field</code>  主要提供对类中的成员变量的访问和使用</li>
</ul>
</blockquote>
<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class<t></t></h2><blockquote>
<p>Class类也使用了泛型，即是Class<t>这种形式的，可以直接使用一个具体的类传入，这样的话就不需要强制转换了，比如<code>Class.newInstance()</code>这样使用默认的构造方法构造一个对象就需要不再需要强制转换了即使用<code>(ClassName)Class.newInstance()</code></t></p>
</blockquote>
<h3 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h3><blockquote>
<ul>
<li><code>getConstructor(Class[] params)</code>  获取公共的(public)的构造方法，并且限定其中的参数个数和类型可以获得不同的公共构造方法</li>
<li><code>Constructor[] getConstructors()</code>   返回所有的公共(public)的构造方法</li>
<li><code>getDeclaredConstructor(Class[] params)</code>  获取所有指定的构造方法，但是需要注意的是当获取私有的构造方法的时候需要使用setAccessible设置访问权限为true才能进行构造，否则出现异常</li>
<li><code>Constructor[] getDeclaredConstructors()</code> 返所有的构造方法包括public和private，protected修饰的</li>
<li><code>T newInstance()</code>  返回的是一个调用默认的构造方法(public class_name())实例化的一个Object对象，如果使用泛型那么就返回T类型的，反之返回的是Object需要强制转换才能使用这个对象调用成员函数和成员变量</li>
<li><code>Class forName(String class_name)</code>  返回class对象，每一个类都有一个方法返回Class对象(<code>类名.class</code>)，注意这里的参数一定是具体的路径，包括包的名字，比如<code>demo.Test</code></li>
<li><code>Package getPackage()</code>   返回此类所在的包名(package demo) 当然也可以使用Package.getName()获得包的名字(demo)比如<code>class1.getPackage().getName()</code></li>
<li><code>int getModifiers()</code> 返回的是类的修饰符的整数 类型(修饰符的类型有public private protected)其中得到整数可以使用Modifier中toString(int num)得到public，private，protected的类型,比如Modifier.toString(class1.getModifiers())<br>*<code>Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code> 返回指定参数的方法Method对象,注意这里仅仅是返回的时公共的方法(public)  比如:<code>Method method=class1.getMethod(&quot;display&quot;,new Class[]{int.class})</code>这里的<code>display</code>是方法的名字，有一个参数，类型为int</li>
<li><code>Method[] getMethods()</code>  获取所有的公共的方法(public)返回的是一个数组(Method)</li>
<li><code>Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes)</code>返回所有的指定的参数的方法(public,private,protected，但是不包括继承的),其中参数可以为null(无参数)</li>
<li><code>Method[] getDeclaredMethods()</code> 获取所有的方法</li>
<li><code>Field getField(String name)</code>  指定名字的公共成员变量(public)</li>
<li><code>Field[] getFields()</code>   获取所有的公共的成员变量</li>
<li><code>Field getDeclaredField(String name)</code>  获取所有的指定名称的成员变量(public,protected,private),同样在调用私有成员变量的时候需要先设置访问的权限,field.setAccessible(true)</li>
<li><code>Field[] getDeclaredFields()</code>  获取所有的成员变量(public,protected,private)</li>
<li><code>getSuperclass()</code>   返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的超类的 Class。</li>
<li><code>URL getResource(String name)</code> 查找指定名称的资源(图片，文件…)注意这个资源一定要和指定类在一个包中，否则返回null，比如查找Test类下的airplane.png图片:<code>Test.class.getResource(&quot;airplane.png&quot;)</code>这里返回的将是绝对路径</li>
</ul>
</blockquote>
<h3 id="获取Class的对象并且实例化"><a href="#获取Class的对象并且实例化" class="headerlink" title="获取Class的对象并且实例化"></a>获取Class的对象并且实例化</h3><blockquote>
<ul>
<li><p>使用<code>Class.forName(String className)</code> 其中className一定是包含包的名字，下面的demo就是包的名字，Test是类的名字。这是最常用的方法，学过JDBC的都知道加载驱动的时候就是使用的<code>Class.forName()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 第一种使用forName(String className),其中className一定是包含包的名字，下面的demo就是包的名字，Test是类的名字</div><div class="line"> */</div><div class="line">Class cls=Class.forName(<span class="string">"demo.Test"</span>);</div><div class="line">Test test=(Test)cls.newInstance();    <span class="comment">//这里只是使用了默认的构造方法实例化对象</span></div></pre></td></tr></table></figure>
</li>
<li><p>使用<code>类名.class</code></p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Class cls=Test.class;</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>使用<code>对象.getClass()</code></li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Test test=<span class="keyword">new</span> Test();</div><div class="line">Class cls=test.getClass();</div></pre></td></tr></table></figure>
<h2 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor<t></t></h2><blockquote>
<ul>
<li>主要是用来对类的构造方法进行操作的，可以看出这个也使用了泛型，和上面的Class是一样的，注意这里如果没有使用泛型，那么原本放回<code>T</code>类型的现在都是返回<code>Object</code></li>
</ul>
</blockquote>
<h3 id="常用的方法-1"><a href="#常用的方法-1" class="headerlink" title="常用的方法"></a>常用的方法</h3><blockquote>
<ul>
<li><code>T newInstance(Object parms)</code>   使用带有参数的构造方法实例化对象，如果使用了泛型，那么返回的就是T类型的，反之返回的是Object类型的，需要强制转换</li>
<li><code>getName()</code> 以字符串的形式返回构造方法的名称，具体的路径包含包名(demo.Test)</li>
<li><code>int getModifiers()</code>  和<code>Class</code>类中的方法一样</li>
</ul>
</blockquote>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><blockquote>
<p>主要提供的是对类中的方法的操作</p>
</blockquote>
<h3 id="常用的方法-2"><a href="#常用的方法-2" class="headerlink" title="常用的方法"></a>常用的方法</h3><blockquote>
<ul>
<li><p><code>Object invoke(Object obj,object args)</code>   使用得到的<code>Method</code>对象调用方法，<code>obj</code>是类的已经构造好的对象，如果是静态方法直接写null,因为静态方法的调用不需要对象，返回值是Object类型的，如果接受返回值，需要使用强制转换成相应的类型,<code>args</code>是传入的参数,如果有多个参数，那么可以直接在后面用逗号添加或者直接创建数组<code>new Object[]{22,&quot;chenjiabing&quot;}</code>比如：<code>method.invoke(test,22,&quot;chenjiabing&quot;)</code>    <code>method.invoke(test,new Object[]{22,&quot;chenjiabing&quot;})</code>注意：如果调用的private类型的方法，那么需要在前面设置访问的权限,<code>method.setAccessible(true)</code></p>
</li>
<li><p><code>String getName()</code>  返回此方法的名字(display)</p>
</li>
<li><code>Modifier getModifiers()</code> 返回此方法的修饰符的类型表示的整数(public,private…),可以使用<code>Modifier.toString()</code>转换成字符串形式</li>
<li><code>Class getReturnType()</code>  返回这个方法的返回类型  </li>
<li><code>String toString()</code>   返回这个方法表示的字符串的形式</li>
</ul>
</blockquote>
<h2 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h2><blockquote>
<p>主要提供对类的成员变量的操作</p>
</blockquote>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><blockquote>
<ul>
<li><code>String getName()</code>  返回变量名字</li>
<li><code>Object get(Object obj)</code>  返回此变量在指定对象中的值，因为在构造对象的时候每一个传入的变量的值都不一样，因此需要使用对象obj。obj表示传入的对象，返回的Object类型，因此需要强制转换</li>
<li><code>void set(Object obj,Object value)</code> 改变obj对象上的变量的值为value</li>
<li><code>Modifier getModifiers()</code> 返回整数表示修饰的类型</li>
<li><code>String getType()</code> 获取变量的类型(int,String,double float…..)</li>
</ul>
</blockquote>
<h2 id="Modifier"><a href="#Modifier" class="headerlink" title="Modifier"></a>Modifier</h2><blockquote>
<p>Modifier 类提供了 static 方法和常量，对类和成员访问修饰符进行解码。修饰符集被表示为整数，用不同的位位置 (bit position) 表示不同的修饰符。</p>
</blockquote>
<h3 id="常用的方法-3"><a href="#常用的方法-3" class="headerlink" title="常用的方法"></a>常用的方法</h3><blockquote>
<ul>
<li><code>static String toString(int mode)</code>   将代表修饰符的整数形式转换为字符串形式的修饰符，比如将1转换成public</li>
<li><code>static isInterface(int mode)</code>   如果整数参数包括 interface 修饰符，则返回 true，否则返回 false</li>
<li><code>static isStatic(int mode)</code></li>
<li><code>static isPrivate(int mode)</code></li>
<li><code>static isPublic(int mode)</code></li>
<li><code>static isAbstract(int mode)</code></li>
</ul>
</blockquote>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Modifier.toString(Test.class.getModifiers())    <span class="comment">//得到Test类的修饰符</span></div></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote>
<p>有了上面的铺垫，我们就可以使用上面的这些类进行操作了，在进行操作之前，我们需要先定义一个类<code>Test</code>,放在<code>demo</code>包下，内容如下</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> demo;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.jar.Attributes.Name;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.print.attribute.standard.MediaSize.NA;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> String name;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = <span class="string">"陈加兵"</span>;</div><div class="line">		<span class="keyword">this</span>.age = <span class="number">23</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">		<span class="keyword">this</span>.age = age;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"name="</span> + <span class="keyword">this</span>.name + <span class="string">"----age="</span> + <span class="keyword">this</span>.age);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">		<span class="keyword">this</span>.age = age;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.age;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="实例化对象"><a href="#实例化对象" class="headerlink" title="实例化对象"></a>实例化对象</h3><blockquote>
<ul>
<li>使用Class默认的构造newInstance()</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">      Class class1=Class.forName(<span class="string">"demo.Test"</span>);  <span class="comment">//静态加载Class</span></div><div class="line">Test test=(Test)class1.newInstance();  <span class="comment">//调用默认的构造方法(public Test())实例化对象，由于没有使用泛型，因此需要强转</span></div><div class="line">test.display();    <span class="comment">//调用display方法</span></div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>使用Class中的<code>getConstructor()</code>方法构造对象,需要注意的使用<code>private</code>类型构造方法时一定要先设置访问权限为<code>true</code>-<code>constructor.setAccessible(true)</code>;</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">        <span class="comment">/*</span></div><div class="line">		 *调用public Test(String name,int age)得到Constructor的两种形式</div><div class="line">		 *   1.Constructor constructor=class1.getConstructor(new Class[]&#123;String.class,int.class&#125;);</div><div class="line">		 *   2.Constructor constructor=class1.getConstructor(String.class,int.class);这个和上面的是一样的，就是使用的参数形式不一样</div><div class="line">		 * </div><div class="line">		 * </div><div class="line">		 * </div><div class="line">		 * </div><div class="line">		 *使用newInstance()构造对象的两种方式</div><div class="line">		 *   1.Test test=(Test)constructor.newInstance(new Object[]&#123;"chenjiabing",22&#125;);</div><div class="line">		 *	 2.Test test=(Test)constructor.newInstance("chenjiabing",22); 只是形式不同而已，不过我还是喜欢上面的形式</div><div class="line">		 *</div><div class="line">		 */</div><div class="line">		</div><div class="line">		</div><div class="line">		</div><div class="line">		</div><div class="line">		<span class="comment">/*</span></div><div class="line">		 * 调用public Test(String name,int age)</div><div class="line">		 * 		Class.getConstructor()得到的是公共的构造方法，如果有私有的构造方法，那么就会报错，这时就要使用getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</div><div class="line">		 * 		Test test=(Test)constructor.newInstance("陈加兵",22);</div><div class="line">		 * </div><div class="line">		 * </div><div class="line">		 * 调用public Test() </div><div class="line">		 *  	Constructor constructor=class1.getConstructor(null);</div><div class="line">		 *  	Test test=(Test)constructor.newInstance(null);</div><div class="line">		 * </div><div class="line">		 * </div><div class="line">		 * 调用private Test(int age)</div><div class="line">		 * 		Constructor constructor=class1.getDeclaredConstructor(new Class[]&#123;int.class&#125;);</div><div class="line">				constructor.setAccessible(true);   //因为private类型是不可以直接访问的，因此需要设置访问权限为true</div><div class="line">				Test test=(Test)constructor.newInstance(new Object[]&#123;1000&#125;);</div><div class="line">		*/</div><div class="line">		</div><div class="line">        </div><div class="line">        </div><div class="line">        Class class1=Class.forName(<span class="string">"demo.Test"</span>);</div><div class="line">		<span class="comment">//访问public Test(String name,int age)</span></div><div class="line"><span class="comment">//		Constructor constructor=class1.getConstructor(new Class[]&#123;String.class,int.class&#125;);</span></div><div class="line"><span class="comment">//		Test test=(Test)constructor.newInstance("陈加兵",22);</span></div><div class="line">		</div><div class="line">		<span class="comment">//访问默认的构造方法</span></div><div class="line"><span class="comment">//		Constructor constructor=class1.getConstructor(null);</span></div><div class="line"><span class="comment">//		Test test=(Test)constructor.newInstance(null);</span></div><div class="line"></div><div class="line">		<span class="comment">//访问private类型的构造方法</span></div><div class="line">		Constructor constructor=class1.getDeclaredConstructor(<span class="keyword">new</span> Class[]&#123;<span class="keyword">int</span>.class&#125;);</div><div class="line">		constructor.setAccessible(<span class="keyword">true</span>);</div><div class="line">		Test test=(Test)constructor.newInstance(<span class="keyword">new</span> Object[]&#123;<span class="number">1000</span>&#125;);</div><div class="line">		test.display();</div></pre></td></tr></table></figure>
<h3 id="成员方法的操作"><a href="#成员方法的操作" class="headerlink" title="成员方法的操作"></a>成员方法的操作</h3><blockquote>
<p>使用<code>Class.getMethod()</code>和<code>Class.getDeclaredMethod()</code>方法获取方法，这两个方法的区别前面已经说过了，注意的是调用私有成员方法的之前一定要设置访问权限(<code>method.setAccessible(true)</code>)</p>
<p>Method类中的其他方法前面也已经说过了，详细使用请自己尝试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">		<span class="comment">/*</span></div><div class="line">		 * 获取Method对象的两种方式:</div><div class="line">		 * 		1.Method method_set=class1.getMethod("set", new Class[]&#123;String.class,int.class&#125;);</div><div class="line">		 * 		2.Method method_set=class1.getMethod("set", String.class,int.class);</div><div class="line">		 * </div><div class="line">		 * </div><div class="line">		 * 使用Method.invoke()调用方法的两种方式</div><div class="line">		 * 		1.Object o=method_set.invoke(test, new Object[]&#123;"陈加兵",200&#125;);</div><div class="line">		 * 		2.Object object=method_set.invoke(test, "陈加兵",2000);</div><div class="line">		 */</div><div class="line">		</div><div class="line">        </div><div class="line">        </div><div class="line">        </div><div class="line">		<span class="comment">/*</span></div><div class="line">		 * 获取公共方法(public)：</div><div class="line">		 * 		1.Method method=class1.getMethod("display",null);  //public void display()</div><div class="line">		 * 		2.Method method_set=class1.getMethod("set", new Class[]&#123;String.class,int.class&#125;);  //获取public void set(String name,int age)</div><div class="line">		 * </div><div class="line">		 * </div><div class="line">		 * 获取私有方法(private,protected)</div><div class="line">		 * 		1.Method method_getAge=class1.getDeclaredMethod("getAge", null);</div><div class="line">		 */</div><div class="line">		</div><div class="line">		</div><div class="line">		<span class="comment">//使用构造方法构造一个Test对象</span></div><div class="line">		Class class1 =Class.forName(<span class="string">"demo.Test"</span>);</div><div class="line">		Constructor&lt;Test&gt; constructor=class1.getDeclaredConstructor(<span class="keyword">new</span> Class[]&#123;String.class,<span class="keyword">int</span>.class&#125;);</div><div class="line">		Test test=constructor.newInstance(<span class="keyword">new</span> Object[]&#123;<span class="string">"陈加兵"</span>,<span class="number">22</span>&#125;);</div><div class="line">		</div><div class="line">		</div><div class="line">		Method method=class1.getMethod(<span class="string">"display"</span>,<span class="keyword">null</span>);   <span class="comment">//获取public void display()方法的Method对象</span></div><div class="line">		Object obj=method.invoke(test, <span class="keyword">null</span>);    <span class="comment">//调用方法display</span></div><div class="line">		</div><div class="line">		<span class="comment">//获取public void set(String name,int age)</span></div><div class="line"><span class="comment">//		Method method_set=class1.getMethod("set", new Class[]&#123;String.class,int.class&#125;);</span></div><div class="line">		Method method_set=class1.getMethod(<span class="string">"set"</span>, String.class,<span class="keyword">int</span>.class);</div><div class="line">		</div><div class="line"><span class="comment">//		Object o=method_set.invoke(test, new Object[]&#123;"陈加兵",200&#125;);</span></div><div class="line">		Object object=method_set.invoke(test, <span class="string">"陈加兵"</span>,<span class="number">2000</span>);</div><div class="line">		test.display();</div><div class="line">		</div><div class="line">		</div><div class="line">		<span class="comment">//获取私有方法private int getAge()</span></div><div class="line">		Method method_getAge=class1.getDeclaredMethod(<span class="string">"getAge"</span>, <span class="keyword">null</span>);</div><div class="line">		method_getAge.setAccessible(<span class="keyword">true</span>);   <span class="comment">//必须设置访问权限为true</span></div><div class="line">		<span class="comment">//判断返回值类型是否为int类型的</span></div><div class="line">		<span class="keyword">if</span>(<span class="string">"int"</span>.equals(method_getAge.getReturnType().toString()))</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">int</span> ReturnData=(<span class="keyword">int</span>) method_getAge.invoke(test, <span class="keyword">null</span>);   <span class="comment">//调用并且获取返回值</span></div><div class="line">			System.out.println(ReturnData);</div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="成员变量的操作"><a href="#成员变量的操作" class="headerlink" title="成员变量的操作"></a>成员变量的操作</h3><blockquote>
<p>主要使用的<code>Field</code>类，前面已经详细的说过了</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">		 * 获取public修饰的成员变量：</div><div class="line">		 * 		1.Field field=class1.getField("name"); //获取public的成员变量name的Filed对象</div><div class="line">		 * </div><div class="line">		 * 获取private，protected修饰的成员变量：</div><div class="line">		 * 		1.	Field field2=class1.getDeclaredField("age");</div><div class="line">		 */</div><div class="line">         </div><div class="line">         </div><div class="line">		Class class1=Class.forName(<span class="string">"demo.Test"</span>);</div><div class="line">		Test test=<span class="keyword">new</span> Test(<span class="string">"陈加兵"</span>,<span class="number">1000</span>);</div><div class="line">		Field field=class1.getField(<span class="string">"name"</span>); <span class="comment">//获取public的成员变量name的Filed对象</span></div><div class="line">		System.out.println(field.get(test));   <span class="comment">//获得test对象中的name属性的值</span></div><div class="line">		</div><div class="line">		<span class="comment">//获取private int age的Field对象</span></div><div class="line">		Field field2=class1.getDeclaredField(<span class="string">"age"</span>);</div><div class="line">		field2.setAccessible(<span class="keyword">true</span>);  <span class="comment">//设置访问权限</span></div><div class="line">		System.out.println(field2.get(test));</div></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote>
<ul>
<li><a href="http://www.cnblogs.com/octobershiner/archive/2012/03/18/2404751.html" target="_blank" rel="external">http://www.cnblogs.com/octobershiner/archive/2012/03/18/2404751.html</a></li>
<li><a href="http://www.cnblogs.com/ixenos/p/5699420.html" target="_blank" rel="external">http://www.cnblogs.com/ixenos/p/5699420.html</a></li>
<li><a href="https://yq.aliyun.com/wenzhang/show_17985" target="_blank" rel="external">https://yq.aliyun.com/wenzhang/show_17985</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java反射机制&quot;&gt;&lt;a href=&quot;#Java反射机制&quot; class=&quot;headerlink&quot; title=&quot;Java反射机制&quot;&gt;&lt;/a&gt;Java反射机制&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
      <category term="java学习" scheme="http://chenjiabing666.github.io/categories/java%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java基础" scheme="http://chenjiabing666.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java IO学习笔记总结</title>
    <link href="http://chenjiabing666.github.io/2017/05/26/Java-IO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93/"/>
    <id>http://chenjiabing666.github.io/2017/05/26/Java-IO学习笔记总结/</id>
    <published>2017-05-26T00:09:27.000Z</published>
    <updated>2017-06-21T17:21:44.031Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-IO学习笔记总结"><a href="#Java-IO学习笔记总结" class="headerlink" title="Java IO学习笔记总结"></a>Java IO学习笔记总结</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>前面的八篇文章详细的讲述了Java IO的操作方法，文章列表如下</p>
<ul>
<li><a href="https://chenjiabing666.github.io/2017/05/23/Java-IO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/">基本的文件操作</a></li>
<li><a href="https://chenjiabing666.github.io/2017/05/24/Java-IO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/">字符流和字节流的操作</a></li>
<li><a href="https://chenjiabing666.github.io/2017/05/24/Java-IO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/">InputStreamReader和OutputStreamWriter操作</a></li>
<li><a href="https://chenjiabing666.github.io/2017/05/25/Java-IO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/">内存操作流</a></li>
<li><a href="https://chenjiabing666.github.io/2017/05/25/Java-IO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/">管道流</a></li>
<li><a href="https://chenjiabing666.github.io/2017/05/25/Java-IO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD/">打印流</a></li>
<li><a href="https://chenjiabing666.github.io/2017/05/26/Java-IO学习笔记七/">System对IO的支持</a></li>
<li><a href="https://chenjiabing666.github.io/2017/05/26/Java-IO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AB/">BufferedReader和BufferedWriter</a></li>
</ul>
</blockquote>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><blockquote>
<p>字节流的操作都是基于<code>InputStream</code>和<code>OutputStream</code>这两个抽象类</p>
</blockquote>
<h4 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h4><blockquote>
<p><code>InputStream</code>是<strong>字节输入流</strong>，主要的功能是从文件中读取数据,它的子类有内存操作流 <code>ByteArrayInputStream</code>，管道输入流<code>PipedInputStream</code>，和<code>FileInputStream</code></p>
</blockquote>
<h4 id="OutPutStream"><a href="#OutPutStream" class="headerlink" title="OutPutStream"></a>OutPutStream</h4><blockquote>
<p><code>OutputStream</code>是字节输出流，主要功能是向文件中写入数据，它的常用的子类有<code>ByteArrayOutputStream</code>, <code>FileOutputStream</code>,  <code>PipedOutputStream</code>,<strong><code>PrintStream</code></strong></p>
</blockquote>
<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><blockquote>
<p>字符流的操作都是基于家<code>Writer</code>和<code>Reader</code>这两个抽象类的，一个是输出流，一个是输入流</p>
</blockquote>
<h4 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h4><blockquote>
<p>写入字符流的操作类，常用的子类有<strong><code>PrintWriter</code></strong>,<strong><code>BufferedWriter</code></strong>,<code>OutputStreamWriter</code>(字节流和字符流之间的桥梁)</p>
</blockquote>
<h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><blockquote>
<p>用于读取字符流的抽象类,常用的子类有<code>BufferedReader</code>，<code>InputStreamReader</code></p>
</blockquote>
<h2 id="最好用的"><a href="#最好用的" class="headerlink" title="最好用的"></a>最好用的</h2><blockquote>
<ul>
<li>其中最高效的输入和输出当然是字符流操作的<code>BufferedReader</code>和<code>BufferedWriter</code></li>
<li>最便捷的，格式化最好的当然是<code>PrintStream</code>,<code>PrintWriter</code>这两个类都采用了格式化的输入和输出</li>
</ul>
</blockquote>
<h3 id="输出流最好用的"><a href="#输出流最好用的" class="headerlink" title="输出流最好用的"></a>输出流最好用的</h3><blockquote>
<ul>
<li>输出流中比较好用的是<code>PrintStream</code>,<code>PrintWriter</code></li>
<li>输出流最好用的当然是<code>BufferedWriter</code>和<code>PrintWriter</code>的结合，例子如下；</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">File file=<span class="keyword">new</span> File(<span class="string">"/tmp"</span>+File.separator+<span class="string">"test"</span>+File.separator+<span class="string">"test.txt"</span>);</div><div class="line"><span class="comment">//用BufferedWriter实例化PrintWriter，显著提高写入的效率</span></div><div class="line">PrintWriter printWriter=<span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(file)));</div><div class="line">String name=<span class="string">"陈加兵"</span>;</div><div class="line"><span class="keyword">int</span> age=<span class="number">22</span>;</div><div class="line"><span class="keyword">float</span> grade=<span class="number">99.9f</span>;</div><div class="line">printWriter.printf(<span class="string">"姓名:%s,年龄:%s,grade:%s"</span>,name,age,grade);  <span class="comment">//格式化的写入</span></div><div class="line">printWriter.close();</div></pre></td></tr></table></figure>
<h3 id="输入流最好用的"><a href="#输入流最好用的" class="headerlink" title="输入流最好用的"></a>输入流最好用的</h3><blockquote>
<ul>
<li>本人觉得输入流中<code>BufferedReader</code>功能已经很强大了</li>
</ul>
</blockquote>
<h3 id="综合运用"><a href="#综合运用" class="headerlink" title="综合运用"></a>综合运用</h3><blockquote>
<p><strong>有时候在写程序的时候，你得到了一个字节流，但是你想要创建的却是字符流对象，怎么办了呢？前面已经说过，字节流转换成字符流对象的桥梁是InputStreamReader和InputStreamWiter他们的作用是传入字节流对象构造字符流对象，因此可以完美的实现字节流转换成字符流，这个是非常重要的</strong></p>
<p>下面使用转换流将System.in转换成字符流并且使用高效流读取控制台输入的数据,代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">// 读取键盘的输入的数据，System.in是字节流，因此要想创建高效流必须使用转换流InputStreamReader</span></div><div class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</div><div class="line">String line;</div><div class="line"><span class="comment">//从键盘读取输入的数据，直到读到bye结束</span></div><div class="line"><span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</div><div class="line">	<span class="keyword">if</span> (<span class="string">"bye"</span>.equals(line)) &#123;</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">	System.out.println(line);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-IO学习笔记总结&quot;&gt;&lt;a href=&quot;#Java-IO学习笔记总结&quot; class=&quot;headerlink&quot; title=&quot;Java IO学习笔记总结&quot;&gt;&lt;/a&gt;Java IO学习笔记总结&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; cla
    
    </summary>
    
      <category term="java学习" scheme="http://chenjiabing666.github.io/categories/java%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java IO编程" scheme="http://chenjiabing666.github.io/tags/java-IO%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java IO学习笔记八</title>
    <link href="http://chenjiabing666.github.io/2017/05/26/Java-IO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AB/"/>
    <id>http://chenjiabing666.github.io/2017/05/26/Java-IO学习笔记八/</id>
    <published>2017-05-25T23:37:55.000Z</published>
    <updated>2017-06-20T00:55:02.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BufferedReader和BufferedWriter"><a href="#BufferedReader和BufferedWriter" class="headerlink" title="BufferedReader和BufferedWriter"></a>BufferedReader和BufferedWriter</h1><blockquote>
<ul>
<li>这两个类是高效率的提高文件的读取速度，它们为字符输入和输出提供了一个缓冲区，可以显著的调高写入和读取的速度，特别针对大量的磁盘文件读取的时候,下面着重的讲讲这两个类</li>
</ul>
</blockquote>
<h2 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h2><blockquote>
<ul>
<li>从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取,要特别注意的是这个市针对字符流而不是字节流。</li>
<li>通常，<code>Reader</code> 所作的每个读取请求都会导致对底层字符或字节流进行相应的读取请求。因此，建议用 <code>BufferedReader</code> 包装所有其 <code>read()</code>操作可能开销很高的<code>Reader</code>（如 <code>FileReader</code> 和 <code>InputStreamReader</code>）</li>
</ul>
</blockquote>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><blockquote>
<ul>
<li><code>BufferedReader(Reader in)</code>  创建一个使用默认大小输入缓冲区的缓冲字符输入流。</li>
<li><code>BufferedReader(Reader in, int sz)</code>    创建一个使用指定大小输入缓冲区的缓冲字符输入流。</li>
</ul>
</blockquote>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><blockquote>
<ul>
<li>可以看出构造函数使用了Reader这个抽象类来初始化，我们前面说过这个是针对字符流的读取，因此可以使用<code>Reader</code>类的两个子类<code>FileReader</code>,<code>InputStreamReader</code>来初始化</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">File file=<span class="keyword">new</span> File(<span class="string">"/tmp"</span>+File.separator+<span class="string">"test"</span>+File.separator+<span class="string">"test.txt"</span>);</div><div class="line">BufferedReader bufferedReader=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(file));  <span class="comment">//使用FileReader实例化</span></div><div class="line"><span class="comment">//使用InputStreamReader来实例化</span></div><div class="line">BufferedReader bufferedReader=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(file)));</div></pre></td></tr></table></figure>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><blockquote>
<ul>
<li><code>close()</code></li>
<li><code>String readLine()</code>  读取一行的数据</li>
<li><code>int read()</code>   读取一个字符，注意这里的和字节的不一样，这里的汉字占用了一个字节，前面讲到读取字节流的时候使用byte读取汉字占用三个字节</li>
<li><code>skip(int n)</code>   跳过n个字节</li>
<li><code>ready()</code>  判断此流是否已准备好被读取。</li>
</ul>
</blockquote>
<h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><blockquote>
<ul>
<li>用于控制台的读取,前面已经说过<code>System.in</code>返回的是<code>InputStream</code>类型的，因此可以使用<code>InputStreamReader</code>实例化,当然这个有点多余了，我们完全可以使用<code>java.util</code>提供的<code>Scanner</code>直接进行输入</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BufferedReader bufferedReader=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</div><div class="line">        String str=bufferedReader.readLine();  <span class="comment">//将控制台输入的字符串读取</span></div><div class="line">        System.out.println(str);  <span class="comment">//打印出来</span></div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>用于文件的读取</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"> BufferedReader bufferedReader=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(file));</div><div class="line">       <span class="comment">// BufferedReader bufferedReader=new BufferedReader(new InputStreamReader(new FileInputStream(file)));</span></div><div class="line"><span class="comment">//        bufferedReader.skip(2);    //跳过两个字节</span></div><div class="line"><span class="comment">//        </span></div><div class="line"><span class="comment">//        第一种读取的方式</span></div><div class="line">        <span class="keyword">while</span>(bufferedReader.ready())     <span class="comment">//判断是否还有字符</span></div><div class="line">        &#123;</div><div class="line">            String str=bufferedReader.readLine();   <span class="comment">//直接读取一行</span></div><div class="line">            System.out.println(str);  </div><div class="line">        &#125;</div><div class="line">        bufferedReader.close();</div><div class="line">        </div><div class="line">        <span class="comment">//第二种读取方式</span></div><div class="line">        <span class="keyword">int</span> len=bufferedReader.read();</div><div class="line">        <span class="keyword">while</span>(len!=-<span class="number">1</span>)   <span class="comment">//判断是否读到文件的末尾</span></div><div class="line">        &#123;</div><div class="line">            System.out.print((<span class="keyword">char</span>)len);  <span class="comment">//强制转化成字符</span></div><div class="line">            len=bufferedReader.read();</div><div class="line">        &#125;</div><div class="line">		</div><div class="line">		<span class="comment">//第三种方式，根据readLine读取一行，如果到达了文件的末尾返回null</span></div><div class="line">		String s;</div><div class="line">		<span class="keyword">while</span>((s=bufferedReader.readLine())!=<span class="keyword">null</span>)</div><div class="line">		&#123;</div><div class="line">			System.out.println(S);</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<h2 id="BufferedWriter"><a href="#BufferedWriter" class="headerlink" title="BufferedWriter"></a>BufferedWriter</h2><blockquote>
<ul>
<li>将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。</li>
<li>通常 <code>Writer</code> 将其输出立即发送到底层字符或字节流。除非要求提示输出，否则建议用 BufferedWriter 包装所有其 write() 操作可能开销很高的 Writer（如 <code>FileWriters</code> 和 <code>OutputStreamWriters</code>）。例如</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PrintWriter out</div><div class="line">   = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"foo.out"</span>)));</div></pre></td></tr></table></figure>
<h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><blockquote>
<ul>
<li><code>BufferedWriter(Writer out)</code>   创建一个使用默认大小输出缓冲区的缓冲字符输出流。</li>
<li><code>BufferedWriter(Writer out, int sz)</code>    创建一个使用给定大小输出缓冲区的新缓冲字符输出流。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">File file=<span class="keyword">new</span> File(<span class="string">"/tmp"</span>+File.separator+<span class="string">"test"</span>+File.separator+<span class="string">"test.txt"</span>);</div><div class="line">BufferedWriter bufferedWriter=<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(file));</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意这里的FileWriter是Writer的子类，因此可以使用其实例化</strong></p>
</blockquote>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><blockquote>
<ul>
<li><code>close()</code></li>
<li><code>flush()</code></li>
<li><code>newLine()</code>  写入一个与平台相关的换行符</li>
<li><code>write(int data)</code> 写入一个字符，这里的写入的不是整数</li>
<li><code>write(String str)</code>  写入一个字符串</li>
<li><code>write(String str,int off,int len)</code>  写入部分字符串</li>
<li><code>write(char[] c)</code></li>
<li><code>write(char[] c,int off,int len)</code></li>
</ul>
</blockquote>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">File file=<span class="keyword">new</span> File(<span class="string">"/tmp"</span>+File.separator+<span class="string">"test"</span>+File.separator+<span class="string">"test.txt"</span>);</div><div class="line">File file1=<span class="keyword">new</span> File(<span class="string">"/tmp"</span>+File.separator+<span class="string">"test"</span>);</div><div class="line">File file2=<span class="keyword">new</span> File(<span class="string">"/tmp"</span>+File.separator+<span class="string">"test"</span>+File.separator+<span class="string">"demo.txt"</span>);</div><div class="line"><span class="keyword">if</span>(!file1.exists())</div><div class="line">&#123;</div><div class="line">    file1.mkdir();</div><div class="line">    System.out.println(<span class="string">"文件夹创建成功"</span>);</div><div class="line">&#125;</div><div class="line">BufferedWriter bufferedWriter=<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(file));</div><div class="line">String str=<span class="string">"陈加兵"</span>;</div><div class="line"><span class="keyword">int</span> data=<span class="number">48</span>;</div><div class="line">String name=<span class="string">"chenjiabing"</span>;</div><div class="line"><span class="keyword">char</span>[] chars=name.toCharArray();</div><div class="line">bufferedWriter.write(str);   <span class="comment">//写入一个字符串，当然也可以截取这个字符串的某一段</span></div><div class="line">bufferedWriter.newLine();  <span class="comment">//写入一个平台自带的换行符，因为每一个操作系统的换行符都不一样</span></div><div class="line">bufferedWriter.write(data);   <span class="comment">//写入的并不是整数，而是这个整数所代表的字符</span></div><div class="line">bufferedWriter.newLine();</div><div class="line">bufferedWriter.write(chars,<span class="number">1</span>,<span class="number">4</span>);  <span class="comment">//写入字符数组</span></div><div class="line">bufferedWriter.flush();</div><div class="line">bufferedWriter.close()</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>拓展：</strong>通过了上面的学习，你不觉得使用这个类写入文件数据有点烦了，只能写入<code>String</code> <code>char</code>类型的数据，此时我们就想到了前面说过的打印流(<code>PrintWriter</code>)，这是一个便捷的写入文件的类，可以指定任意格式任意类型的数据，同样是输出流，我么可以将他们结合起来，构成一个更加强大的输出流，如下:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">File file=<span class="keyword">new</span> File(<span class="string">"/tmp"</span>+File.separator+<span class="string">"test"</span>+File.separator+<span class="string">"test.txt"</span>);</div><div class="line"><span class="comment">//用BufferedWriter实例化PrintWriter，显著提高写入的效率</span></div><div class="line">PrintWriter printWriter=<span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(file)));</div><div class="line">String name=<span class="string">"陈加兵"</span>;</div><div class="line"><span class="keyword">int</span> age=<span class="number">22</span>;</div><div class="line"><span class="keyword">float</span> grade=<span class="number">99.9f</span>;</div><div class="line">printWriter.printf(<span class="string">"姓名:%s,年龄:%s,grade:%s"</span>,name,age,grade);  <span class="comment">//格式化的写入</span></div><div class="line">printWriter.close();</div></pre></td></tr></table></figure>
<h2 id="综合实例"><a href="#综合实例" class="headerlink" title="综合实例"></a>综合实例</h2><blockquote>
<p>将一个文件中数据转移到另外一个文件中</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> IO;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by chenjiabing on 17-5-26.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo13</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 常用函数：</div><div class="line">     * newLine()</div><div class="line">     * write(String str)</div><div class="line">     * write(String str,int off,int len)</div><div class="line">     * write(Char[] c)</div><div class="line">     * write(Char[] c,int off,int len)</div><div class="line">     * write(int data)</div><div class="line">     * close()</div><div class="line">     * flush()</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        File file = <span class="keyword">new</span> File(<span class="string">"/tmp"</span> + File.separator + <span class="string">"test"</span> + File.separator + <span class="string">"test.txt"</span>);</div><div class="line">        File file1 = <span class="keyword">new</span> File(<span class="string">"/tmp"</span> + File.separator + <span class="string">"test"</span>);</div><div class="line">        File file2 = <span class="keyword">new</span> File(<span class="string">"/tmp"</span> + File.separator + <span class="string">"test"</span> + File.separator + <span class="string">"demo.txt"</span>);</div><div class="line">        BufferedWriter bufferedWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(file2));</div><div class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(file));</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (bufferedReader.ready()) &#123;</div><div class="line">            String str = bufferedReader.readLine();  <span class="comment">//读取文件test.txt中的一行数据</span></div><div class="line">            bufferedWriter.write(str);   <span class="comment">//将这一行数据写入文件demo.txt</span></div><div class="line">            bufferedWriter.newLine();</div><div class="line">        &#125;</div><div class="line">        bufferedReader.close();</div><div class="line">        bufferedWriter.flush();</div><div class="line">        bufferedWriter.close();</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote>
<ul>
<li><a href="http://ifeve.com/java-io-char-buffered-filter/" target="_blank" rel="external">http://ifeve.com/java-io-char-buffered-filter/</a></li>
<li><a href="http://www.cnblogs.com/lich/archive/2011/12/11/2284223.html" target="_blank" rel="external">http://www.cnblogs.com/lich/archive/2011/12/11/2284223.html</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;BufferedReader和BufferedWriter&quot;&gt;&lt;a href=&quot;#BufferedReader和BufferedWriter&quot; class=&quot;headerlink&quot; title=&quot;BufferedReader和BufferedWriter&quot;&gt;&lt;/a
    
    </summary>
    
      <category term="java学习" scheme="http://chenjiabing666.github.io/categories/java%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java IO编程" scheme="http://chenjiabing666.github.io/tags/java-IO%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java IO学习笔记七</title>
    <link href="http://chenjiabing666.github.io/2017/05/26/Java-IO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83/"/>
    <id>http://chenjiabing666.github.io/2017/05/26/Java-IO学习笔记七/</id>
    <published>2017-05-25T23:37:47.000Z</published>
    <updated>2017-06-20T00:55:23.145Z</updated>
    
    <content type="html"><![CDATA[<h1 id="System对IO的支持"><a href="#System对IO的支持" class="headerlink" title="System对IO的支持"></a>System对IO的支持</h1><blockquote>
<ul>
<li><code>System</code>是系统的类，其中的方法都是在控制台的输入和输出，但是通过重定向也是可以对文件的输入输出</li>
<li><p><code>System</code>中定义了标准输入、标准输出和错误输出流，定义如下:</p>
<blockquote>
<ol>
<li><code>static PrintStream err</code> “标准”错误输出流。</li>
<li><code>static InputStream    in</code> “标准”输入流。</li>
<li><code>static PrintStream    out</code>   “标准”输出流。</li>
</ol>
</blockquote>
</li>
<li><p>从上面的定义可以知道这里的返回值都是字节的输入和输出流，因此可以使用<code>PrintStream</code>接受这个返回值，然后利用其进行输出，同样的输入也是可以这样做,当然对于<code>OutputStream</code>和<code>InputStream</code>也是可以的，因为<code>PrintStream</code>是继承<code>OutputStream</code></p>
</li>
</ul>
</blockquote>
<h2 id="System-out"><a href="#System-out" class="headerlink" title="System.out"></a>System.out</h2><blockquote>
<ul>
<li><code>System.out</code>是一个标准的输出流，可以使用<code>PrintStream</code>和<code>OutputStream</code>接收返回值，然后使用其进行标准的输出,实例如下</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">PrintStream printStream=System.out;  <span class="comment">//使用PrintStream</span></div><div class="line"><span class="comment">//OutputStream outputStream=System.out;   //使用OutputStream</span></div><div class="line">    String name=<span class="string">"陈加兵"</span>;</div><div class="line">    <span class="keyword">int</span> age=<span class="number">22</span>;</div><div class="line">    printStream.printf(<span class="string">"姓名:%s,年龄:%s"</span>,name,age);  <span class="comment">//使用格式话的输出</span></div></pre></td></tr></table></figure>
<blockquote>
<p>其实我还是比较用<code>PrintStream</code>进行格式话的输出的</p>
<ul>
<li><code>System.out</code>的重定向输出，可以使用这个将指定的内容输出到文件中，实例如下：</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    File file=<span class="keyword">new</span> File(<span class="string">"/tmp"</span>+File.separator+<span class="string">"test"</span>+File.separator+<span class="string">"test.txt"</span>);</div><div class="line">        System.setOut(<span class="keyword">new</span> PrintStream(<span class="keyword">new</span> PrintStream(file)));  <span class="comment">//设置重定向的文件</span></div><div class="line">    &#125;<span class="keyword">catch</span> (IOException e) </div><div class="line">    &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    System.out.println(<span class="string">"陈加兵的个人博客"</span>)；<span class="comment">//向文件输入内容</span></div></pre></td></tr></table></figure>
<h2 id="System-in"><a href="#System-in" class="headerlink" title="System.in"></a>System.in</h2><blockquote>
<ul>
<li>这是一个标准输入流，可以使用<code>InputStream</code>来接受返回值，然后利用其进行输入，实例如下：</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">byte</span>[] bytes=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">       InputStream inputStream=System.in;   <span class="comment">//使用InputStream来接收这个返回值</span></div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           inputStream.read(bytes);  <span class="comment">//读取控制台输入的字符串</span></div><div class="line">       &#125;<span class="keyword">catch</span> (IOException e)</div><div class="line">       &#123;</div><div class="line">           e.printStackTrace();</div><div class="line">       &#125;</div><div class="line">       System.out.println(<span class="keyword">new</span> String(bytes));  <span class="comment">//输出</span></div></pre></td></tr></table></figure>
<blockquote>
<p>说实话这种控制台输入的方式不太好，还是使用原来的<code>Scanner</code>比较好</p>
<ul>
<li>System.in的重定向</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">File file = <span class="keyword">new</span> File(<span class="string">"/tmp"</span> + File.separator + <span class="string">"test"</span> + File.separator + <span class="string">"test.txt"</span>);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    System.setIn(<span class="keyword">new</span> FileInputStream(file));  <span class="comment">//设置重定向</span></div><div class="line">    System.in.read(bytes);   <span class="comment">//读取文件中字节数据</span></div><div class="line"></div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="keyword">new</span> String(bytes));   <span class="comment">//打印出文件中的内容</span></div></pre></td></tr></table></figure>
<h2 id="System-err"><a href="#System-err" class="headerlink" title="System.err"></a>System.err</h2><blockquote>
<ul>
<li>这是一个标准错误输出流，在<code>IDEA</code>中输出的内容是红色的，和<code>System.out</code>输出的格式一样，只是颜色不一样，因为这里的重定向不太重要也不太常用，这里就不再详细说了，详情请看<a href="http://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/System.html" target="_blank" rel="external">帮助文档</a></li>
</ul>
</blockquote>
<h2 id="System-exit"><a href="#System-exit" class="headerlink" title="System.exit"></a>System.exit</h2><blockquote>
<ul>
<li><code>public static void exit(int status)</code></li>
<li>终止当前的<code>java虚拟机</code>，参数用作状态码；根据惯例，非<code>0</code> 的状态码表示异常终止,如<code>System.exit(0)</code></li>
</ul>
</blockquote>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote>
<ul>
<li><a href="http://www.cnblogs.com/lich/archive/2011/12/11/2284155.html" target="_blank" rel="external">http://www.cnblogs.com/lich/archive/2011/12/11/2284155.html</a></li>
<li><a href="http://ifeve.com/java-io-system-in-system-out-system-err/" target="_blank" rel="external">http://ifeve.com/java-io-system-in-system-out-system-err/</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;System对IO的支持&quot;&gt;&lt;a href=&quot;#System对IO的支持&quot; class=&quot;headerlink&quot; title=&quot;System对IO的支持&quot;&gt;&lt;/a&gt;System对IO的支持&lt;/h1&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Syste
    
    </summary>
    
      <category term="java学习" scheme="http://chenjiabing666.github.io/categories/java%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java IO编程" scheme="http://chenjiabing666.github.io/tags/java-IO%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java IO学习笔记六</title>
    <link href="http://chenjiabing666.github.io/2017/05/25/Java-IO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD/"/>
    <id>http://chenjiabing666.github.io/2017/05/25/Java-IO学习笔记六/</id>
    <published>2017-05-25T07:33:09.000Z</published>
    <updated>2017-06-20T00:55:16.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h1><blockquote>
<ul>
<li>在整个<code>IO</code>包中，打印流是输出信息最方便的类，主要包含<strong>字节打印流</strong>（<code>PrintStream</code>）和<strong>字符打印流</strong>（<code>PrintWrite</code>）。打印流提供了非常方便的打印功能，可以打印任何的数据类型，例如：小数、整数、字符串等等，相对于前面学习的几个文件的操作来说，这里的打印流是最简便的一个类了</li>
</ul>
</blockquote>
<h2 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h2><blockquote>
<ul>
<li>主要功能是格式化的将内容写入文件，并不是打印在控制台上</li>
<li><code>PrintStream</code>最大的好处就是可以格式化的输出，相信学过<code>c</code>的朋友都知道<code>prinf</code>这格式化输出函数，这里的<code>PrintStream</code>实现了更加简单的格式化输出，不需要使用什么<code>%d</code>,<code>%f</code>了，只需要都是用<code>%s</code>即可，这个很像<code>python</code></li>
<li><code>PrintStream</code> 打印的所有字符都使用平台的默认字符编码转换为字节。在需要写入字符而不是写入字节的情况下，应该使用 <code>PrintWriter</code>类。</li>
</ul>
</blockquote>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><blockquote>
<ul>
<li><code>PrintStream(File file)</code>       创建具有指定文件且不带自动行刷新的新打印流。</li>
<li><code>PrintStream(OutputStream out)</code>    创建新的打印流。</li>
<li><code>PrintStream(OutputStream out, boolean autoFlush)</code>  创建新的打印流，并且设置自动刷新</li>
<li><code>PrintStream(String fileName)</code>   创建具有指定文件名称且不带自动行刷新的新打印流。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">File file_2=<span class="keyword">new</span> File(<span class="string">"/tmp"</span>+File.separator+<span class="string">"test"</span>+File.separator+<span class="string">"test.txt"</span>);</div><div class="line">PrintStream printStream=<span class="keyword">new</span> PrintStream(file_2);  <span class="comment">//直接使用File</span></div><div class="line">PrintStream printStream=<span class="keyword">new</span> PrintStream(<span class="keyword">new</span> FileOutputStream(file_2));  <span class="comment">//使用OutputStream的子类FileOutputStream</span></div></pre></td></tr></table></figure>
<h3 id="常用的函数"><a href="#常用的函数" class="headerlink" title="常用的函数"></a>常用的函数</h3><blockquote>
<ul>
<li><p><code>PrintStream append(char c)</code>  在此输入流的后面追加字符。</p>
</li>
<li><p><code>PrintStream    append(CharSequence csq)</code>  将指定字符序列添加到此输出流。</p>
</li>
<li><p><code>PrintStream    append(CharSequence csq, int start, int end)</code>   将指定字符序列的子序列添加到此输出流。</p>
</li>
<li><p><code>print()</code>  打印常用的数据类型，比如<code>String</code>,<code>char</code>,<code>int</code> ,<code>double</code>,<code>float</code>,<code>boolean</code>,<code>long</code>,<code>short</code></p>
</li>
<li><code>println()</code>  打印常用的数据类型，但是带有换行符</li>
<li><code>printf(String format, Object... args)</code> 使用指定格式字符串和参数将格式化的字符串写入此输出流的便捷方法。</li>
<li><code>format(String format, Object... args)</code>  使用指定格式字符串和参数将格式化字符串写入此输出流中。</li>
<li><code>close()</code></li>
<li><code>flush()</code></li>
</ul>
</blockquote>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">package</span> IO;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by chenjiabing on 17-5-25.</div><div class="line"> */</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="comment">/**test.txt文件中的结果如下:</span></div><div class="line"> 陈加兵</div><div class="line"> 2299.9</div><div class="line"> 姓名:陈加兵,n年龄:22,成绩:99.9</div><div class="line"> 姓名:陈加兵,n年龄:22,成绩:99.9</div><div class="line"> c</div><div class="line"> chenjiabi</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo9</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        PrintStream printStream = <span class="keyword">null</span>;</div><div class="line">        File file_1 = <span class="keyword">new</span> File(<span class="string">"/tmp"</span> + File.separator + <span class="string">"test"</span>);</div><div class="line">        File file_2 = <span class="keyword">new</span> File(<span class="string">"/tmp"</span> + File.separator + <span class="string">"test"</span> + File.separator + <span class="string">"test.txt"</span>);</div><div class="line">        <span class="keyword">if</span> (!file_1.exists()) &#123;</div><div class="line">            file_1.mkdir();</div><div class="line">            System.out.println(<span class="string">"文件创建成功"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line"><span class="comment">//            PrintStream printStream=new PrintStream(file_2);</span></div><div class="line">            printStream = <span class="keyword">new</span> PrintStream(<span class="keyword">new</span> FileOutputStream(file_2));</div><div class="line">            String name = <span class="string">"陈加兵"</span>;</div><div class="line">            <span class="keyword">int</span> age = <span class="number">22</span>;</div><div class="line">            <span class="keyword">float</span> grade = <span class="number">99.9f</span>;</div><div class="line"></div><div class="line">            printStream.println(name);<span class="comment">//println()</span></div><div class="line"></div><div class="line">            printStream.print(age);<span class="comment">//print()</span></div><div class="line"></div><div class="line">            printStream.println(grade);<span class="comment">//print()</span></div><div class="line"></div><div class="line">            printStream.format(<span class="string">"姓名:%s,n年龄:%s,成绩:%s%s"</span>, name, age, grade, <span class="string">"\n"</span>);<span class="comment">//format()</span></div><div class="line"></div><div class="line">            printStream.printf(<span class="string">"姓名:%s,n年龄:%s,成绩:%s%s"</span>, name, age, grade, <span class="string">"\n"</span>);</div><div class="line"></div><div class="line">            printStream.append(<span class="string">'c'</span>);   <span class="comment">//append</span></div><div class="line">            printStream.append(<span class="string">"\nchenjiabing"</span>,<span class="number">0</span>,<span class="number">10</span>);  <span class="comment">//append</span></div><div class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (printStream != <span class="keyword">null</span>) &#123;</div><div class="line">                printStream.flush();</div><div class="line">                printStream.close();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a>PrintWriter</h2><blockquote>
<ul>
<li>继承<code>Writer</code>，主要针对的是字符流的操作</li>
<li><p>向文本输出流打印对象的格式化表示形式。此类实现在 <code>PrintStream</code>中的所有 <code>print</code> 方法。它不包含用于写入原始字节的方法，对于这些字节，程序应该使用未编码的字节流进行写入。</p>
</li>
<li><p>与<code>PrintStream</code> 类不同，如果启用了自动刷新，则只有在调用 <code>println</code>、<code>printf</code> 或 <code>format</code> 的其中一个方法时才可能完成此操作，而不是每当正好输出换行符时才完成。这些方法使用平台自有的行分隔符概念，而不是换行符。</p>
</li>
<li><p>此类中的方法不会抛出 <code>I/O</code> 异常，尽管其某些构造方法可能抛出异常。客户端可能会查询调用 <code>checkError()</code> 是否出现错误。</p>
</li>
</ul>
</blockquote>
<h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><blockquote>
<ul>
<li><code>PrintWriter(File file)</code>   使用指定文件创建不具有自动行刷新的新 <code>PrintWriter</code>。</li>
<li><code>PrintWriter(OutputStream out)</code>   根据现有的 <code>OutputStream</code> 创建不带自动行刷新的新 <code>PrintWriter</code>。</li>
<li><code>PrintWriter(OutputStream out, boolean autoFlush)</code>     通过现有的 <code>OutputStream</code> 创建新的 <code>PrintWriter</code>。</li>
<li><code>PrintWriter(String fileName)</code>   创建具有指定文件名称且不带自动行刷新的新 <code>PrintWriter</code>。</li>
</ul>
</blockquote>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><blockquote>
<p>这里的常用到的函数和<code>PrintStream</code>的差不多就不再详细的列出来了，详情请看<a href="http://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/PrintWriter.html" target="_blank" rel="external">帮助文档</a></p>
</blockquote>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> IO;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by chenjiabing on 17-5-25.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo10</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">    &#123;</div><div class="line">        PrintWriter printWriter=<span class="keyword">null</span>;</div><div class="line">        File file=<span class="keyword">new</span> File(<span class="string">"/tmp"</span>+File.separator+<span class="string">"test"</span>+File.separator+<span class="string">"file.txt"</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            printWriter=<span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileOutputStream(file));</div><div class="line">            printWriter.println(<span class="string">"chenjiabing"</span>);</div><div class="line">            printWriter.println(<span class="string">"陈加兵"</span>);</div><div class="line">        &#125;<span class="keyword">catch</span> (IOException e)</div><div class="line">        &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;<span class="keyword">finally</span> &#123;</div><div class="line">                <span class="keyword">if</span>(printWriter!=<span class="keyword">null</span>)</div><div class="line">                &#123;</div><div class="line">                    printWriter.close();</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote>
<ul>
<li><a href="http://www.cnblogs.com/lich/archive/2011/12/11/2284093.html" target="_blank" rel="external">http://www.cnblogs.com/lich/archive/2011/12/11/2284093.html</a></li>
<li><a href="http://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/PrintWriter.html" target="_blank" rel="external">http://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/PrintWriter.html</a></li>
<li><a href="http://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/PrintStream.html" target="_blank" rel="external">http://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/PrintStream.html</a></li>
<li><a href="http://blog.csdn.net/yyyandroid/article/details/7756390" target="_blank" rel="external">http://blog.csdn.net/yyyandroid/article/details/7756390</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;打印流&quot;&gt;&lt;a href=&quot;#打印流&quot; class=&quot;headerlink&quot; title=&quot;打印流&quot;&gt;&lt;/a&gt;打印流&lt;/h1&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在整个&lt;code&gt;IO&lt;/code&gt;包中，打印流是输出信息最方便的类，主要包含&lt;strong&gt;
    
    </summary>
    
      <category term="java学习" scheme="http://chenjiabing666.github.io/categories/java%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java IO编程" scheme="http://chenjiabing666.github.io/tags/java-IO%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java IO学习笔记五</title>
    <link href="http://chenjiabing666.github.io/2017/05/25/Java-IO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/"/>
    <id>http://chenjiabing666.github.io/2017/05/25/Java-IO学习笔记五/</id>
    <published>2017-05-25T07:33:00.000Z</published>
    <updated>2017-06-20T00:55:41.829Z</updated>
    
    <content type="html"><![CDATA[<h1 id="管道流"><a href="#管道流" class="headerlink" title="管道流"></a>管道流</h1><blockquote>
<ul>
<li><p>管道流的主要作用是可以进行两个<strong>线程间的通讯</strong>，分为管道输出流(<code>PipedOutputStream</code>)、管道输入流（<code>PipedInputStream</code>），如果想要进行管道输出，则必须要把输出流连在输入流之上，在PipedOutputStream类上有如下的一个方法用于连接管道：<br><code>public void connect(PipedInputStream snk)throws IOException</code></p>
</li>
<li><p>通常是创建两个单独的线程来实现通信，如果是单个线程的话容易出现线程堵塞，因为输出流最多只能向缓冲区写入1024个字节的数据，如果超出就会出现线程堵塞，因此必须创建多个线程实现缓冲区的释放和存储</p>
</li>
</ul>
</blockquote>
<h2 id="PipedOutputStream"><a href="#PipedOutputStream" class="headerlink" title="PipedOutputStream"></a>PipedOutputStream</h2><blockquote>
<ul>
<li>管道输出流是管道的发送端，可以将管道输出流连接到管道输入流来创建一个通信管道，通常，数据由某个线程写入 <code>PipedOutputStream</code>对象，并由其他线程从连接的 <code>PipedInputStream</code> 读取。不建议对这两个对象尝试使用单个线程，因为这样可能会造成该线程死锁。如果某个线程正从连接的管道输入流中读取数据字节，但该线程不再处于活动状态，则该管道被视为处于 毁坏 状态。</li>
</ul>
</blockquote>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><blockquote>
<ul>
<li><code>PipedOutputStream()</code>  创建尚未连接到管道输入流的管道输出流。</li>
<li><code>PipedOutputStream(PipedInputStream snk)</code>   创建连接到指定管道输入流的管道输出流。</li>
</ul>
</blockquote>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><blockquote>
<ul>
<li><code>close()</code>  关闭</li>
<li><code>void    connect(PipedInputStream snk)</code>  将此管道输出流连接到接收者。</li>
<li><code>void    flush()</code>    刷新此输出流并强制写出所有缓冲的输出字节。</li>
<li><code>void    write(byte[] b, int off, int len)</code>      将 <code>len</code> 字节从初始偏移量为 <code>off</code> 的指定 <code>byte</code> 数组写入该管道输出流。</li>
<li><code>void    write(int b)</code>    将指定 <code>byte</code> 写入传送的输出流。</li>
</ul>
</blockquote>
<h2 id="PipedInputStream"><a href="#PipedInputStream" class="headerlink" title="PipedInputStream"></a>PipedInputStream</h2><blockquote>
<ul>
<li>管道输入流应该连接到管道输出流；管道输入流提供要写入管道输出流的所有数据字节。通常，数据由某个线程从 <code>PipedInputStream</code> 对象读取，并由其他线程将其写入到相应的 <code>PipedOutputStream</code>。不建议对这两个对象尝试使用单个线程，因为这样可能死锁线程。管道输入流包含一个缓冲区，可在缓冲区限定的范围内将读操作和写操作分离开。 如果向连接管道输出流提供数据字节的线程不再存在，则认为该管道已损坏。</li>
</ul>
</blockquote>
<h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><blockquote>
<ul>
<li><code>PipedInputStream()</code>    创建尚未连接的 <code>PipedInputStream</code>。</li>
<li><code>PipedInputStream(PipedOutputStream src)</code>    创建 <code>PipedInputStream</code>，使其连接到管道输出流 <code>src</code>。</li>
</ul>
</blockquote>
<h3 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h3><blockquote>
<ul>
<li><code>int    available()</code>   返回可以不受阻塞地从此输入流中读取的字节数。</li>
<li><code>void    close()</code>   关闭此管道输入流并释放与该流相关的所有系统资源。</li>
<li><code>void    connect(PipedOutputStream src)</code>    使此管道输入流连接到管道输出流 <code>src</code>。</li>
<li><code>int    read()</code>  读取此管道输入流中的下一个数据字节。</li>
<li><code>int read(byte[] b, int off, int len)</code>    将最多 <code>len</code> 个数据字节从此管道输入流读入 <code>byte</code> 数组。</li>
<li><code>protected  void    receive(int b)</code>   接收数据字节。</li>
</ul>
</blockquote>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> IO;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.PipedInputStream;</div><div class="line"><span class="keyword">import</span> java.io.PipedOutputStream;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by chenjiabing on 17-5-25.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 注意的问题：</div><div class="line"> * 1.写线程正在往缓冲区写数据的时候，但是此时的读线程的管道结束，那么此时的写线程的管道就会发生IOException异常</div><div class="line"> * 2.读线程正在从缓冲区读数据的时候，但是此时的写线程的管道已经结束了，此时就会引起读线程的管道发生IOException异常</div><div class="line"> * 3.必须是启用多线程才能实现管道之间的读写，否则会出现堵塞现象，因为这里的PipeOutputStream每次向缓冲区写入的字节数最大是1024，如果不及时的减少缓冲区的数据量就会出现堵塞</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo7</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PipedOutputStream outputStream = <span class="keyword">new</span> PipedOutputStream();</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PipedInputStream inputStream = <span class="keyword">new</span> PipedInputStream();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建一个写入数据进程，使用的是PipeOutStream，将数据写入管道中</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2000</span>];     <span class="comment">//创建一个2000字节的数组</span></div><div class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        outputStream.write(bytes, <span class="number">0</span>, <span class="number">2000</span>);  <span class="comment">//写入管道，但是这里的缓冲区最多写入1024个字节的数据，因此这个是一次没有写完</span></div><div class="line">                        System.out.println(<span class="string">"写入成功"</span>);</div><div class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                        System.out.println(<span class="string">"写入失败"</span>);</div><div class="line">                        System.exit(<span class="number">1</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 使用PipeInputStream创建一个读取的线程</div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];  <span class="comment">//一次性只读取100个字节</span></div><div class="line">                <span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    len = inputStream.read(bytes, <span class="number">0</span>, <span class="number">100</span>);  <span class="comment">//读取</span></div><div class="line">                    <span class="keyword">while</span> (len != -<span class="number">1</span>) &#123;</div><div class="line">                        System.out.println(<span class="string">"已经读取了"</span> + len + <span class="string">"个字节"</span>);</div><div class="line">                        len = inputStream.read(bytes, <span class="number">0</span>, <span class="number">100</span>);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line"></div><div class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                    System.out.println(<span class="string">"读取失败"</span>);</div><div class="line">                    System.exit(<span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            inputStream.connect(outputStream);  <span class="comment">//连接</span></div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            System.out.println(<span class="string">"连接失败"</span>);</div><div class="line">            System.exit(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        send();</div><div class="line">        receive();</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意:</strong>从上面的运行结果可以看出，缓冲区最多可以写入<code>1024</code>个字节的数据，所以在缓冲区满了之后上面的<code>send</code>进程就会堵塞等待缓冲区空闲，如果<code>recieve</code>进程不继续读取数据了，那么就会一直出现堵塞</p>
</blockquote>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote>
<ul>
<li>写线程正在往缓冲区写数据的时候，但是此时的读线程的结束读取，那么此时的写线程的管道就会发生<code>IOException</code>异常，可以将上面<code>receive</code>进程中的<code>while(true)</code>去掉就可以清楚的看出</li>
<li>读线程正在从缓冲区读数据的时候，但是此时的写线程的管道已经结束了，此时就会引起读线程的管道发生<code>IOException</code>异常,将上面的<code>send</code>进程中的<code>while(true)</code>去掉就可以实现这个问题</li>
<li>必须是启用多线程才能实现管道之间的读写，否则会出现堵塞现象，因为这里的<code>PipeOutputStream</code>每次向缓冲区写入的字节数最大是<code>1024</code>，如果不及时的减少缓冲区的数据量就会出现堵塞</li>
</ul>
</blockquote>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><blockquote>
<ul>
<li>后续更新中……….</li>
</ul>
</blockquote>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote>
<ul>
<li><a href="http://www.cnblogs.com/lich/archive/2011/12/11/2283928.html" target="_blank" rel="external">http://www.cnblogs.com/lich/archive/2011/12/11/2283928.html</a></li>
<li><a href="http://ifeve.com/java-io-%E7%AE%A1%E9%81%93/" target="_blank" rel="external">http://ifeve.com/java-io-%E7%AE%A1%E9%81%93/</a></li>
<li><a href="http://www.cnblogs.com/chinareny2k/archive/2010/03/24/1693878.html" target="_blank" rel="external">http://www.cnblogs.com/chinareny2k/archive/2010/03/24/1693878.html</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;管道流&quot;&gt;&lt;a href=&quot;#管道流&quot; class=&quot;headerlink&quot; title=&quot;管道流&quot;&gt;&lt;/a&gt;管道流&lt;/h1&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;管道流的主要作用是可以进行两个&lt;strong&gt;线程间的通讯&lt;/strong&gt;，分为管道输
    
    </summary>
    
      <category term="java学习" scheme="http://chenjiabing666.github.io/categories/java%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java IO编程" scheme="http://chenjiabing666.github.io/tags/java-IO%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java IO学习笔记四</title>
    <link href="http://chenjiabing666.github.io/2017/05/25/Java-IO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/"/>
    <id>http://chenjiabing666.github.io/2017/05/25/Java-IO学习笔记四/</id>
    <published>2017-05-25T07:32:49.000Z</published>
    <updated>2017-06-20T00:55:36.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存操作流"><a href="#内存操作流" class="headerlink" title="内存操作流"></a>内存操作流</h1><blockquote>
<p>之前的所有的流操作都是针对文件的，但是有时候只是想要实现数据间转换，此时如果我们想要创建一个文件然后再删除文件，那样显得有点麻烦，因此此时的内存操作流就显得很适合这类的操作，因为它只是在内存中存储，并不会真正的创建文件，内存操作流涉及的两个类是<code>ByteArrayInputStream</code>,<code>ByteArrayOutputStream</code>.</p>
</blockquote>
<h2 id="ByteArrayInputStream"><a href="#ByteArrayInputStream" class="headerlink" title="ByteArrayInputStream"></a>ByteArrayInputStream</h2><blockquote>
<ul>
<li><code>ByteArrayInputStream</code> 包含一个内部缓冲区，该缓冲区包含从流中读取的字节。内部计数器跟踪<code>read</code>方法要提供的下一个字节。</li>
<li>关闭 <code>ByteArrayInputStream</code>无效。此类中的方法在关闭此流后仍可被调用，而不会产生任何 <code>IOException</code>。</li>
<li>主要的功能是从缓冲区读取字节</li>
</ul>
</blockquote>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><blockquote>
<ul>
<li><code>ByteArrayInputStream(byte[] buf)</code>   创建一个 <code>ByteArrayInputStream</code>，使用 <code>buf</code> 作为其缓冲区数组。</li>
<li><code>ByteArrayInputStream(byte[] buf, int offset, int length)</code>    创建 <code>ByteArrayInputStream</code>，使用 buf 作为其缓冲区数组。</li>
</ul>
</blockquote>
<h3 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h3><blockquote>
<ul>
<li><code>close()</code>  不过对这个无效，因为关闭之后仍然可以使用函数读取而不报错</li>
<li><code>int read()</code> 从缓冲区中读取一个字节</li>
<li><code>int read(byte[] bytes)</code>  将缓冲区中的内容读取到数组中</li>
<li><code>int read(byte[] bytes,int off,int len)</code>    将最多 <code>len</code> 个数据字节从此输入流读入 <code>byte</code> 数组。</li>
<li><code>long skip(long n)</code>    从此输入流中跳过<code>n</code> 个输入字节。</li>
<li><code>void reset()</code>  将此 byte 数组输出流的 count 字段重置为零，从而丢弃输出流中目前已累积的所有输出（清除缓冲区）</li>
</ul>
</blockquote>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo8</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">        String str = <span class="string">"chenjiabing\n陈加兵"</span>;</div><div class="line">        <span class="keyword">byte</span>[] bytes = str.getBytes();  <span class="comment">//创建一个数组</span></div><div class="line">        ByteArrayInputStream inputStream = <span class="keyword">new</span> ByteArrayInputStream(bytes);  <span class="comment">//使用bytes作为缓冲区数组</span></div><div class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</div><div class="line">        <span class="comment">/*第一种方法读取缓冲区中的数据，这个和文件的操作不一样，这个可以直接冲缓冲区中读取数据字节*/</span></div><div class="line">        <span class="keyword">while</span> ((temp = inputStream.read()) != -<span class="number">1</span>) &#123;</div><div class="line">            System.out.print((<span class="keyword">char</span>) temp);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/*创建数组用于存储读取的内容，下面是第二种读取数据的方法*/</span></div><div class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[bytes.length];</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">int</span> len = inputStream.read(b);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="keyword">new</span> String(b));</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ByteArrayOutputStream"><a href="#ByteArrayOutputStream" class="headerlink" title="ByteArrayOutputStream"></a>ByteArrayOutputStream</h2><blockquote>
<ul>
<li><p>此类实现了一个输出流，其中的数据被写入一个<code>byte</code> 数组。缓冲区会随着数据的不断写入而自动增长。可使用 <code>toByteArray()</code> 和 toString() 获取数据。</p>
</li>
<li><p>关闭 <code>ByteArrayOutputStream</code> 无效。此类中的方法在关闭此流后仍可被调用，而不会产生任何 <code>IOException</code>。</p>
</li>
</ul>
</blockquote>
<h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><blockquote>
<ul>
<li><code>ByteArrayOutputStream()</code>     创建一个新的 <code>byte</code>数组输出流。</li>
<li><code>ByteArrayOutputStream(int size)</code>    创建一个新的 <code>byte</code> 数组输出流，它具有指定大小的缓冲区容量（以字节为单位）。</li>
</ul>
</blockquote>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><blockquote>
<ul>
<li><p><code>int size()</code>    返回缓冲区的当前大小。</p>
</li>
<li><p><code>byte[] toByteArray()</code>    创建一个新分配的 <code>byte</code> 数组。</p>
</li>
<li><p><code>String toString()</code>   将缓冲区的字节转换成字符串</p>
</li>
<li><p><code>void    write(byte[] b, int off, int len)</code>  将指定 <code>byte</code> 数组中从偏移量 <code>off</code> 开始的 <code>len</code> 个字节写入此 <code>byte</code> 数组输出流。</p>
</li>
<li><p><code>void    write(int b)</code>    将指定的字节写入此 <code>byte</code>数组输出流。</p>
</li>
</ul>
</blockquote>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo8</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">        ByteArrayOutputStream outputStream = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">        String str = <span class="string">"chenjiabing"</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            outputStream.write(str.getBytes());   <span class="comment">//将字符串转换成数组然后写入缓冲区</span></div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                outputStream.close();  <span class="comment">//这里的关闭无效</span></div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//将缓冲区的数据转换成字符串后输出，这里同样可以看出输出流的关闭根本不影响函数的调用</span></div><div class="line">        System.out.println(outputStream.size());  <span class="comment">//输出缓冲区的大小</span></div><div class="line">        System.out.println(outputStream.toString());  <span class="comment">//输出chenjiabing</span></div><div class="line">        outputStream.reset();   <span class="comment">//清除缓冲区的内容，如果不清零那么原先写入的数据还是存在的，但是此时我们已经不需要前面的数据了</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            outputStream.write(<span class="string">"陈加兵"</span>.getBytes());  <span class="comment">//继续向缓冲区写入数据</span></div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(outputStream.size());  <span class="comment">//这里的一个汉字占了三个字节</span></div><div class="line">        System.out.println(outputStream.toString());<span class="comment">//输出陈加兵</span></div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h2><blockquote>
<p>下面我们结合上面的两个类将<strong>字符串转换大小写</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo8</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">        ByteArrayOutputStream outputStream = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">        String str = <span class="string">"chenjiabing"</span>;</div><div class="line">        ByteArrayInputStream inputStream = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes());  <span class="comment">//实例化输入流</span></div><div class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> ((temp = inputStream.read()) != -<span class="number">1</span>)   <span class="comment">//读取缓冲区的字节数据</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">char</span> c = (<span class="keyword">char</span>) temp;  <span class="comment">//将整数转换成字符，ascii码的转换</span></div><div class="line">            outputStream.write(Character.toUpperCase(c));  <span class="comment">//转换成大写，然后写入输出流的缓冲区中</span></div><div class="line">        &#125;</div><div class="line">        System.out.println(outputStream.toString());   <span class="comment">//利用输出流输出转换后的字符串，即是去取出内存中的数据</span></div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote>
<ul>
<li><p><a href="http://blog.csdn.net/yyyandroid/article/details/7756390" target="_blank" rel="external">http://blog.csdn.net/yyyandroid/article/details/7756390</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/lich/archive/2011/12/11/2283883.html" target="_blank" rel="external">http://www.cnblogs.com/lich/archive/2011/12/11/2283883.html</a></p>
</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;内存操作流&quot;&gt;&lt;a href=&quot;#内存操作流&quot; class=&quot;headerlink&quot; title=&quot;内存操作流&quot;&gt;&lt;/a&gt;内存操作流&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;之前的所有的流操作都是针对文件的，但是有时候只是想要实现数据间转换，此时如果我们想要创建一
    
    </summary>
    
      <category term="java学习" scheme="http://chenjiabing666.github.io/categories/java%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java IO编程" scheme="http://chenjiabing666.github.io/tags/java-IO%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
