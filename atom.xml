<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>爱撒谎的男孩</title>
  <subtitle>微信公众号：码猿技术专栏</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chenjiabing666.github.io/"/>
  <updated>2020-08-27T09:06:59.796Z</updated>
  <id>http://chenjiabing666.github.io/</id>
  
  <author>
    <name>不才陈某</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Navicat Premium 12破解版安装</title>
    <link href="http://chenjiabing666.github.io/2020/08/27/Navicat%20Premium%2012%E5%85%8D%E8%B4%B9%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85/"/>
    <id>http://chenjiabing666.github.io/2020/08/27/Navicat Premium 12免费版本安装/</id>
    <published>2020-08-27T07:51:57.000Z</published>
    <updated>2020-08-27T09:06:59.796Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>这几年的工作过程中使用了很多的数据库工具，比如Sqlyog，DBeaver,sqlplus等工具，但是个人觉得很好用的还是Navicat。</li>
<li>不如人意的就是目前Navicat都在收费，今天就来分享下如何安装免费的Navicat。</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-Log-plugin/6.jpg" alt=""></li>
</ul>
<h2 id="免费版本安装"><a href="#免费版本安装" class="headerlink" title="免费版本安装"></a>免费版本安装</h2><ol>
<li>首先去官网下载Navicat_12的安装包，根据自己电脑的配置下载合适的。</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/navicat12/1.png" alt=""></p>
<ol>
<li>下载成功之后，直接<code>安装</code>，<code>启动</code>即可</li>
<li>启动时选择<code>试用</code>版本。</li>
<li>打开<strong>神秘的包包</strong>，找到匹配的，如下：</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/navicat12/2.png" alt=""></p>
<ol>
<li>将其中的文件全部复制到<code>Navicat_12</code>的根目录，文件如下：</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/navicat12/3.png" alt=""></p>
<ol>
<li>重新启动Navicat，出现以下界面，表示安装成功，如下：</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/navicat12/4.png" alt=""></p>
<h2 id="如何连接Oracle"><a href="#如何连接Oracle" class="headerlink" title="如何连接Oracle"></a>如何连接Oracle</h2><ul>
<li>如果本地未安装过Oracle数据库，新安装的Navicat默认是连接不上oracle的，需要配置一下<code>oci.dll</code>。</li>
<li>选择<code>工具</code>-&gt;<code>选项</code></li>
<li><img src="https://images2018.cnblogs.com/blog/1023171/201808/1023171-20180819144807854-2077107245.png" alt=""></li>
<li>指定<code>oci.dll</code>的路径，如下：</li>
<li><img src="https://images2018.cnblogs.com/blog/1023171/201808/1023171-20180819144833188-1560669113.png" alt=""></li>
<li>重新启动，即可连接。</li>
<li><strong>注意</strong>：Navicat_12自带的oci.dll如果版本不合适，可以去官网下载对应的版本。</li>
</ul>
<h2 id="如何连接Sql-server"><a href="#如何连接Sql-server" class="headerlink" title="如何连接Sql server"></a>如何连接Sql server</h2><ul>
<li>如果本地未安装过SQL Server数据库，Navicat是不能连接上数据库的，具体解决方案如下：</li>
<li>在Navicat的根目录下找到<code>sqlncli_x64.msi</code>双击安装即可，当然如果版本不合适，可以自己去官网下载。</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/navicat12/5.png" alt=""></li>
<li>安装成功后，重启启动，即可连接。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>安装免费版的Navicat很简单，只需要一个神秘的包包，哈哈。</li>
<li>老规矩，关注公众号【码猿技术专栏】回复关键词<code>Navicat12</code>即可获取。</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E4%B8%83%E7%A7%92%E7%BC%96%E7%A8%8B.jpg" alt=""></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;这几年的工作过程中使用了很多的数据库工具，比如Sqlyog，DBeaver,sqlplus等工具，但是个人觉得很好用的还是Nav
    
    </summary>
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis Log plugin破解，亲测可用！！！</title>
    <link href="http://chenjiabing666.github.io/2020/08/26/plugin%E7%A0%B4%E8%A7%A3%EF%BC%8C%E4%BA%B2%E6%B5%8B%E5%8F%AF%E7%94%A8/"/>
    <id>http://chenjiabing666.github.io/2020/08/26/plugin破解，亲测可用/</id>
    <published>2020-08-26T06:50:11.000Z</published>
    <updated>2020-08-26T06:50:58.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>今天重新装了IDEA2020，顺带重装了一些插件，毕竟这些插件都是习惯一直在用，其中一款就是Mybatis  Log plugin，按照往常的思路，在IDEA插件市场搜索安装，艹，眼睛一瞟，竟然收费了，对于我这种支持盗版的人来说太难了，于是自己开始捣鼓各种尝试破解，下文分享自己的破解方式。</li>
</ul>
<h2 id="什么是Mybatis-Log-plugin"><a href="#什么是Mybatis-Log-plugin" class="headerlink" title="什么是Mybatis Log plugin"></a>什么是Mybatis Log plugin</h2><ul>
<li>举个栗子，通常在找bug的时候都会查看执行了什么SQL，想把这条SQL拼接出来执行调试，可能有些小白还在傻傻的把各个参数复制出来，补到<code>?</code>占位符中，哈哈。</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-Log-plugin/6.jpg" alt=""></li>
</ul>
<ul>
<li>简单的说就是能根据log4j的打印的sql日志一键生成执行的<code>sql</code>语句。</li>
<li>类似如下一个日志信息：</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-Log-plugin/1.png" alt="日志信息"></li>
<li>如果使用Log plugin这个插件，将会很容易的把参数添加到sql语句中得到一条完整的sql，效果如下：</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-Log-plugin/4.png" alt="完整sql"></li>
<li>一旦开启了<code>Mybatis Log plugin</code>这个插件，在程序运行过程中只要是有SQL语句都会自动生成在<code>Mybatis Log</code>这个界面，当然也可以自己关掉。</li>
</ul>
<h2 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h2><ul>
<li><code>Setting-&gt;plugin-&gt;Marketplace</code>搜索框输入<code>Mybatis Log plugin</code>，如下：</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-Log-plugin/2.png" alt="搜索输入"></li>
<li>很遗憾的是， IDEA2020中已经开始收费了，艹，对于一向支持盗版的我来说，很不爽~</li>
</ul>
<h2 id="如何破解"><a href="#如何破解" class="headerlink" title="如何破解"></a>如何破解</h2><ul>
<li>下载jar包<code>plugin.intellij.assistant.mybaitslog-2020.1-1.0.3.jar</code>，文末附有下载方式。</li>
<li><code>setting-&gt;plguin-&gt;设置-&gt; install plugin from Disk...</code></li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-Log-plugin/3.png" alt="破解步骤"></p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><ul>
<li>日志中从<code>Preparing</code>到<code>Parameters</code>这两行的参数选中，右键选择<code>restore sql from Selection</code></li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-Log-plugin/5.png" alt=""></li>
<li>此时将会在<code>Mybatis Log</code>界面出现完整的SQL语句。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>对于复杂的SQL语句来说，Mybatis Log plugin这款插件简直是太爱了，能够自动拼接参数生成执行的SQL语句。</li>
<li>老规矩，关注公众号【码猿技术专栏】，公众号回复<code>mybatis log</code>获取破解包。</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E4%B8%83%E7%A7%92%E7%BC%96%E7%A8%8B.jpg" alt=""></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;今天重新装了IDEA2020，顺带重装了一些插件，毕竟这些插件都是习惯一直在用，其中一款就是Mybatis  Log plugi
    
    </summary>
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>IDEA2020永久破解，亲测可用！！！</title>
    <link href="http://chenjiabing666.github.io/2020/05/08/IDEA2020%E6%B0%B8%E4%B9%85%E7%A0%B4%E8%A7%A3%EF%BC%8C%E4%BA%B2%E6%B5%8B%E5%8F%AF%E7%94%A8%EF%BC%81%EF%BC%81%EF%BC%81/"/>
    <id>http://chenjiabing666.github.io/2020/05/08/IDEA2020永久破解，亲测可用！！！/</id>
    <published>2020-05-08T10:51:57.000Z</published>
    <updated>2020-08-20T04:31:34.449Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>随着 IDEA 的 2020 版本的发布，新增和优化了很多的功能，今天陈某不说新增的功能，来讲一讲如何永久破解。</li>
<li>不说别的，先上破解后的效果图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA%E7%A0%B4%E8%A7%A3/1.png" alt="永久破解效果图"></li>
</ul>
<h2 id="如何破解？"><a href="#如何破解？" class="headerlink" title="如何破解？"></a>如何破解？</h2><ul>
<li>破解过程很简单，基本是傻瓜式的，过程如下。</li>
</ul>
<h3 id="1-下载安装"><a href="#1-下载安装" class="headerlink" title="1. 下载安装"></a>1. 下载安装</h3><ul>
<li>官网下载<code>IDEA 2020.1</code>，下载地址自己动手百度吧。</li>
<li>安装成功后，启动 IDEA，选择<code>试用</code>启动 IDEA。</li>
</ul>
<h3 id="下载破解包"><a href="#下载破解包" class="headerlink" title="下载破解包"></a>下载破解包</h3><ul>
<li>公众号回复关键词<code>IDEA破解包</code>下载，其实就是一个 jar 包，如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA%E7%A0%B4%E8%A7%A3/2.png" alt="破解包"></li>
</ul>
<h3 id="开始破解"><a href="#开始破解" class="headerlink" title="开始破解"></a>开始破解</h3><ul>
<li><p>直接将<code>jetbrains-agent.jar</code>文件用鼠标<code>拖进</code>idea 界面，然后一路<code>重启</code>或者<code>确定</code>，中间出现什么拖放失败不用理会，直接点确定就好是正常现象。如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA%E7%A0%B4%E8%A7%A3/3.png" alt="破解"></p>
</li>
<li><p>重启成功后，会跳出如下界面，直接点击<code>为IDEA安装</code>，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA%E7%A0%B4%E8%A7%A3/4.png" alt=""></p>
</li>
<li>继续点击<code>是</code>安装，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA%E7%A0%B4%E8%A7%A3/7.png" alt=""></li>
</ul>
<h3 id="验证是否破解成功"><a href="#验证是否破解成功" class="headerlink" title="验证是否破解成功"></a>验证是否破解成功</h3><ul>
<li>根据上述的步骤 99%的可能破解成功，此时打开 IDEA，点击<code>help-&gt;Register</code>查看是否破解成功，出现下图将是破解成功，如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA%E7%A0%B4%E8%A7%A3/1.png" alt=""></li>
<li>里面的激活码是重启之上自动填入的，如果不行找到下载的压缩文件 lib 下的 ACTIVATION_CODE.txt 换一个激活码或者查看 README.pdf 帮助。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA%E7%A0%B4%E8%A7%A3/5.png" alt=""><br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA%E7%A0%B4%E8%A7%A3/6.png" alt=""></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>至此 IDEA 2020 已经破解成功了，按照陈某的步骤 99%的朋友保证能够破解成功，文中的破解文件在公众号回复<code>IDEA破解包</code>即可获取。</li>
<li>另外如果想要 IDEA 2020 的安装包，回复关键词<code>IDEA2020</code>即可获取。</li>
<li>关注我微信公众号【码猿技术专栏】</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E4%B8%83%E7%A7%92%E7%BC%96%E7%A8%8B.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;随着 IDEA 的 2020 版本的发布，新增和优化了很多的功能，今天陈某不说新增的功能，来讲一讲如何永久破解。&lt;/li&gt;
&lt;l
    
    </summary>
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>线上Bug无法复现怎么办？老司机教你一招，SpringBoot远程调试不用愁！</title>
    <link href="http://chenjiabing666.github.io/2020/04/28/%E7%BA%BF%E4%B8%8ABug%E6%97%A0%E6%B3%95%E5%A4%8D%E7%8E%B0%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F%E8%80%81%E5%8F%B8%E6%9C%BA%E6%95%99%E4%BD%A0%E4%B8%80%E6%8B%9B%EF%BC%8CSpringBoot%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E4%B8%8D%E7%94%A8%E6%84%81%EF%BC%81/"/>
    <id>http://chenjiabing666.github.io/2020/04/28/线上Bug无法复现怎么办？老司机教你一招，SpringBoot远程调试不用愁！/</id>
    <published>2020-04-28T03:03:37.000Z</published>
    <updated>2020-08-19T06:58:25.779Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>在部署线上项目时，相信大家都会遇到一个问题，线上的 Bug 但是在本地不会复现，多么无奈。</li>
<li>此时最常用的就是取到前端传递的数据用接口测试工具测试，比如 POSTMAN，复杂不，难受不？</li>
<li>今天陈某教你一招，让你轻松调试线上的 Bug。文章目录如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/7.png" alt=""></li>
</ul>
<h2 id="什么是-JPDA？"><a href="#什么是-JPDA？" class="headerlink" title="什么是 JPDA？"></a>什么是 JPDA？</h2><ul>
<li><p><code>JPDA</code>(Java Platform Debugger Architecture)，即 Java 平台调试体系，具体结构图如下图所示。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/1.png" alt=""></p>
</li>
<li><p>其中实现调试功能的主要协议是<code>JDWP</code>协议，在 <code>Java SE 5</code> 以前版本，JVM 端的实现接口是 <code>JVMPI</code>(Java Virtual Machine Profiler Interface)，而在 <code>Java SE 5</code> 及以后版本，使用 <code>JVMTI</code>(Java Virtual Machine Tool Interface) 来替代 JVMPI。</p>
</li>
<li>因此，如果使用 Java SE 5 之前版本，使用调试功能的命令为：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -Xdebug -Xrunjdwp:...</div></pre></td></tr></table></figure>
<ul>
<li>而 <code>Java SE 5</code> 及之后版本，使用调试功能的命令为：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -agentlib:jdwp=...</div></pre></td></tr></table></figure>
<h2 id="调试命令"><a href="#调试命令" class="headerlink" title="调试命令"></a>调试命令</h2><ul>
<li>现在开发中最常见的一条远程调试的的命令如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=<span class="number">9091</span> -jar xxx.jar</div></pre></td></tr></table></figure>
<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><ul>
<li>基于前面的调试命令，我们来分析一下基本的参数代表什么意思。</li>
</ul>
<h3 id="transport"><a href="#transport" class="headerlink" title="transport"></a>transport</h3><ul>
<li>指定运行的被调试应用和调试者之间的通信协议，它由几个可选值：<ol>
<li><code>dt_socket</code>：主要的方式，采用<code>socket</code>方式连接。</li>
<li><code>dt_shmem</code>：采用共享内存方式连接，仅支持 Windows 平台。</li>
</ol>
</li>
</ul>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><ul>
<li>指定当前应用作为调试服务端还是客户端，默认为<code>n</code>。</li>
<li>如果你想将当前应用作为被调试应用，设置该值为 <code>y</code>,如果你想将当前应用作为客户端，作为调试的发起者，设置该值为<code>n</code>。</li>
</ul>
<h3 id="suspend"><a href="#suspend" class="headerlink" title="suspend"></a>suspend</h3><ul>
<li>当前应用启动后，是否阻塞应用直到被连接，默认值为 <code>y</code>。</li>
<li>在大部分的应用场景，这个值为 <code>n</code>，即不需要应用阻塞等待连接。一个可能为 <code>y</code>的应用场景是，你的程序在启动时出现了一个故障，为了调试，必须等到调试方连接上来后程序再启动。</li>
</ul>
<h3 id="address"><a href="#address" class="headerlink" title="address"></a>address</h3><ul>
<li>暴露的调试连接端口，默认值为 <code>8000</code>。</li>
<li><strong>此端口一定不能与项目端口重复，且必须是服务器开放的端口。</strong></li>
</ul>
<h3 id="onthrow"><a href="#onthrow" class="headerlink" title="onthrow"></a>onthrow</h3><ul>
<li>当程序抛出设定异常时，中断调试。</li>
</ul>
<h3 id="onuncaught"><a href="#onuncaught" class="headerlink" title="onuncaught"></a>onuncaught</h3><ul>
<li>当程序抛出未捕获异常时，是否中断调试，默认值为 n。</li>
</ul>
<h3 id="launch"><a href="#launch" class="headerlink" title="launch"></a>launch</h3><ul>
<li>当调试中断时，执行的程序。</li>
</ul>
<h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><ul>
<li>该参数限定为<code>java -agentlib:jdwp=…</code>可用，单位为毫秒<code>ms</code>。</li>
<li>当 <code>suspend = y</code> 时，该值表示等待连接的超时；当 <code>suspend = n</code> 时，该值表示连接后的使用超时。</li>
</ul>
<h2 id="参考命令"><a href="#参考命令" class="headerlink" title="参考命令"></a>参考命令</h2><ol>
<li><p><code>-agentlib:jdwp=transport=dt_socket,server=y,address=8000</code>：以 Socket 方式监听 8000 端口，程序启动阻塞（suspend 的默认值为 y）直到被连接。</p>
</li>
<li><p><code>-agentlib:jdwp=transport=dt_socket,server=y,address=localhost:8000,timeout=5000</code>：以 Socket 方式监听 8000 端口，当程序启动后 5 秒无调试者连接的话终止，程序启动阻塞（suspend 的默认值为 y）直到被连接。</p>
</li>
<li><p><code>-agentlib:jdwp=transport=dt_shmem,server=y,suspend=n</code>：选择可用的共享内存连接地址并使用 stdout 打印，程序启动不阻塞。</p>
</li>
<li><p><code>-agentlib:jdwp=transport=dt_socket,address=myhost:8000</code>：以 socket 方式连接到 <code>myhost:8000</code>上的调试程序，在连接成功前启动阻塞。</p>
</li>
<li><p><code>-agentlib:jdwp=transport=dt_socket,server=y,address=8000,onthrow=java.io.IOException,launch=/usr/local/bin/debugstub</code>：以 Socket 方式监听 8000 端口，程序启动阻塞（suspend 的默认值为 y）直到被连接。当抛出 IOException 时中断调试，转而执行 <code>usr/local/bin/debugstub</code>程序。</p>
</li>
</ol>
<h3 id="IDEA-远程调试示例"><a href="#IDEA-远程调试示例" class="headerlink" title="IDEA 远程调试示例"></a>IDEA 远程调试示例</h3><ul>
<li>首先打包 SpringBoot 项目，在服务器上运行，执行以下命令：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=<span class="number">9190</span> -jar debug-demo.jar</div></pre></td></tr></table></figure>
<ul>
<li><p>出现下图的界面，表示运行成功：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/2.png" alt=""></p>
</li>
<li><p>然后在 IDEA 中，点击 <code>Edit Configurations</code>，在弹框中点击 <code>+</code> 号，然后选择<code>Remote</code>。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/3.png" alt=""></p>
</li>
<li>填写服务器的地址及端口，点击 OK 即可。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/4.png" alt=""></li>
<li>配置完毕后，DEBUG 调试运行即可。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/5.png" alt=""></li>
<li>配置完毕后点击保存即可，因为我配置的 suspend=n，因此服务端程序无需阻塞等待我们的连接。我们点击 IDEA 调试按钮，当我访问某一接口时，能够正常调试。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/6.png" alt=""></li>
</ul>
<h2 id="小福利"><a href="#小福利" class="headerlink" title="小福利"></a>小福利</h2><ul>
<li>作者为大家准备了接近 10M 的面试题，涵盖后端各个技术维度，老规矩，公众号内回复关键词<code>JAVA面试题</code>即可免费获取。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/8.png" alt=""></li>
<li>关注微信公众号回复关键词：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E4%B8%83%E7%A7%92%E7%BC%96%E7%A8%8B.jpg" alt=""></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在部署线上项目时，相信大家都会遇到一个问题，线上的 Bug 但是在本地不会复现，多么无奈。&lt;/li&gt;
&lt;li&gt;此时最常用的就是取
    
    </summary>
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>大白话布隆过滤器，又能和面试官扯皮了！！！</title>
    <link href="http://chenjiabing666.github.io/2020/04/26/%E5%A4%A7%E7%99%BD%E8%AF%9D%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%8C%E5%8F%88%E8%83%BD%E5%92%8C%E9%9D%A2%E8%AF%95%E5%AE%98%E6%89%AF%E7%9A%AE%E4%BA%86%EF%BC%81%EF%BC%81%EF%BC%81/"/>
    <id>http://chenjiabing666.github.io/2020/04/26/大白话布隆过滤器，又能和面试官扯皮了！！！/</id>
    <published>2020-04-26T14:06:38.000Z</published>
    <updated>2020-04-26T14:07:08.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>文章首发于微信公众号<a href="https://mp.weixin.qq.com/s/Vo935pCXH0aPgG20f1ppEg" target="_blank" rel="external">大白话布隆过滤器，又能和面试官扯皮了~</a></li>
<li>近期在做推荐系统中已读内容去重的相关内容，刚好用到了布隆过滤器，于是写了一篇文章记录分享一下。</li>
<li>文章的篇幅不是很长，主要讲了布隆过滤器的核心思想，目录如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.png" alt=""></li>
</ul>
<h2 id="什么是布隆过滤器？"><a href="#什么是布隆过滤器？" class="headerlink" title="什么是布隆过滤器？"></a>什么是布隆过滤器？</h2><ul>
<li>布隆过滤器是由一个长度为<code>m</code>比特的位<strong>数组</strong>与<code>k</code>个<strong>哈希函数</strong>组成的数据结构。比特数组均初始化为<code>0</code>，所有哈希函数都可以分别把输入数据尽量均匀地散列。</li>
<li>当<strong>插入</strong>一个元素时，将其数据通过<code>k</code>个哈希函数转换成<code>k</code>个哈希值，这<code>k</code>个哈希值将作为比特数组的<code>下标</code>，并将数组中的对应下标的值置为<code>1</code>。</li>
<li>当<strong>查询</strong>一个元素时，同样会将其数据通过<code>k</code>个哈希函数转换成<code>k</code>个哈希值（数组下标），查询数组中对应下标的值，如果有一个下标的值为<code>0</code>表明该元素一定不在集合中，如果全部下标的值都为<code>1</code>，表明该元素有<code>可能</code>在集合中。<strong>至于为什么有可能在集合中？</strong> 因为有可能某个或者多个下标的值为 1 是受到其他元素的影响，这就是所谓的<code>假阳性</code>，下文会详细讲述。</li>
<li><strong>无法删除一个元素</strong>，为什么呢？因为你删除的元素的哈希值可能和集合中的某个元素的哈希值有相同的，一旦删除了这个元素会导致其他的元素也被删除。</li>
<li>下图示出一个<code>m=18</code>, <code>k=3</code>的布隆过滤器示例。集合中的 x、y、z 三个元素通过 3 个不同的哈希函数散列到位数组中。当查询元素 w 时，因为有一个比特为 0，因此 w 不在该集合中。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/1.png" alt=""></li>
</ul>
<h2 id="假阳性概率的计算"><a href="#假阳性概率的计算" class="headerlink" title="假阳性概率的计算"></a>假阳性概率的计算</h2><ul>
<li>假阳性是布隆过滤器的一个痛点，因此需要不择一切手段来使假阳性的概率降低，此时就需要计算一下假阳性的概率了。</li>
<li>假设我们的哈希函数选择位数组中的比特时，都是等概率的。当然在设计哈希函数时，也应该尽量满足均匀分布。</li>
<li>在位数组长度<code>m</code>的布隆过滤器中插入一个元素，它的其中一个哈希函数会将某个特定的比特置为<code>1</code>。因此，在插入元素后，该比特仍然为 0 的概率是：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/2.png" alt=""></li>
<li>现有<code>k</code>个哈希函数，并插入<code>n</code>个元素，自然就可以得到该比特仍然为 0 的概率是：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/3.png" alt=""></li>
<li>反过来讲，它已经被置为<code>1</code>的概率就是：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/4.png" alt=""></li>
<li>也就是说，如果在插入<code>n</code>个元素后，我们用一个不在集合中的元素来检测，那么被误报为存在于集合中的概率（也就是所有哈希函数对应的比特都为<code>1</code>的概率）为：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/5.png" alt=""></li>
<li>当<code>n</code>比较大时，根据极限公式，可以近似得出假阳性率：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/6.png" alt=""></li>
<li>所以，在哈希函数个数<code>k</code>一定的情况下有如下结论：<ol>
<li>位数组长度 m 越大，假阳性率越低。</li>
<li>已插入元素的个数 n 越大，假阳性率越高。</li>
</ol>
</li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>用比特数组表示，不用存储数据本身，对空间的节省相比于传统方式占据绝对的优势。</li>
<li>时间效率很高，无论是插入还是查询，只需要简单的经过哈希函数转换，时间复杂度均为<code>O(k)</code>。</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>存在<code>假阳性</code>的概率，准确率要求高的场景不太适用。</li>
<li>只能插入和查询，不能删除了元素。</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>布隆过滤器的用途很多，但是主要的作用就是去重，这里列举几个使用场景。</li>
</ul>
<h3 id="爬虫重复-URL-检测"><a href="#爬虫重复-URL-检测" class="headerlink" title="爬虫重复 URL 检测"></a>爬虫重复 URL 检测</h3><ul>
<li>试想一下，百度是一个爬虫，它会定时搜集各大网站的信息，文章，那么它是如何保证爬取到文章信息不重复，它会将 URL 存放到布隆过滤器中，每次爬取之前先从布隆过滤器中判断这个 URL 是否存在，这样就避免了重复爬取。当然这种存在假阳性的可能，但是只要你的比特数组足够大，<code>假阳性</code>的概率会很低，另一方面，你认为百度会在意这种的误差吗，你的一篇文章可能因为假阳性概率没有收录到，对百度有影响吗？</li>
</ul>
<h3 id="抖音推荐功能"><a href="#抖音推荐功能" class="headerlink" title="抖音推荐功能"></a>抖音推荐功能</h3><ul>
<li>读者朋友们应该没人没刷过抖音吧，每次刷的时候抖音给你的视频有重复的吗？他是如何保证推荐的内容不重复的呢？</li>
<li>最容易想到的就是抖音会记录用户的历史观看记录，然后从历史记录中排除。这是一种解决办法，但是性能呢？不用多说了，有点常识的都知道这不可能。</li>
<li>解决这种重复的问题，布隆过滤器有着绝对的优势，能够很轻松的解决。</li>
</ul>
<h3 id="防止缓存穿透"><a href="#防止缓存穿透" class="headerlink" title="防止缓存穿透"></a>防止缓存穿透</h3><ul>
<li>缓存穿透是指查询一条数据库和缓存都没有的一条数据，就会一直查询数据库，对数据库的访问压力会一直增大。</li>
<li>布隆过滤器在解决缓存穿透的问题效果也是很好，这里不再细说，后续文章会写。</li>
</ul>
<h2 id="如何实现布隆过滤器？"><a href="#如何实现布隆过滤器？" class="headerlink" title="如何实现布隆过滤器？"></a>如何实现布隆过滤器？</h2><ul>
<li>了解布隆过滤器的设计思想之后，想要实现一个布隆过滤器其实很简单，陈某这里就不再搬门弄斧了，介绍一下现成的实现方式吧。</li>
</ul>
<h3 id="Redis-实现"><a href="#Redis-实现" class="headerlink" title="Redis 实现"></a>Redis 实现</h3><ul>
<li>Redis4.0 之后推出了插件的功能，下面用 docker 安装：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker pull redislabs/rebloom</div><div class="line">docker run -p6379:<span class="number">6379</span> redislabs/rebloom</div></pre></td></tr></table></figure>
<ul>
<li>安装完成后连接 redis 即可，运行命令：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis-cli</div></pre></td></tr></table></figure>
<ul>
<li>至于具体的使用这里不再演示了，直接看官方文档和教程，使用起来还是很简单的。</li>
</ul>
<h3 id="Guava-实现"><a href="#Guava-实现" class="headerlink" title="Guava 实现"></a>Guava 实现</h3><ul>
<li>guava 对应布隆过滤器的实现做出了支持，使用 guava 可以很轻松的实现一个布隆过滤器。</li>
</ul>
<p><strong>1. 创建布隆过滤器</strong></p>
<ul>
<li>创建布隆过滤器，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">BloomFilter&lt;Integer&gt; filter = BloomFilter.create(</div><div class="line">                    Funnels.integerFunnel(),</div><div class="line">                    <span class="number">5000</span>,</div><div class="line">                    <span class="number">0.01</span>);</div><div class="line"><span class="comment">//插入</span></div><div class="line">IntStream.range(<span class="number">0</span>, <span class="number">100_000</span>).forEach(filter::put);</div><div class="line"><span class="comment">//判断是否存在</span></div><div class="line"><span class="keyword">boolean</span> b = filter.mightContain(<span class="number">1</span>);</div></pre></td></tr></table></figure>
<ul>
<li><code>arg1</code>：用于将任意类型 T 的输入数据转化为 Java 基本类型的数据，这里转换为 byte</li>
<li><code>arg2</code>：byte 字节数组的基数</li>
<li><code>arg3</code>：期望的假阳性概率</li>
</ul>
<p><strong>2.估计最优 m 值和 k 值</strong></p>
<ul>
<li>guava 在底层对 byte 数组的基数(m)和哈希函数的个数 k 做了自己的算法，源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//m值的计算</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">optimalNumOfBits</span><span class="params">(<span class="keyword">long</span> n, <span class="keyword">double</span> p)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (p == <span class="number">0</span>) &#123;</div><div class="line">    p = Double.MIN_VALUE;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> (<span class="keyword">long</span>) (-n * Math.log(p) / (Math.log(<span class="number">2</span>) * Math.log(<span class="number">2</span>)));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//k值的计算</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">optimalNumOfHashFunctions</span><span class="params">(<span class="keyword">long</span> n, <span class="keyword">long</span> m)</span> </span>&#123;</div><div class="line">  <span class="comment">// (m / n) * log(2), but avoid truncation due to division!</span></div><div class="line">  <span class="keyword">return</span> Math.max(<span class="number">1</span>, (<span class="keyword">int</span>) Math.round((<span class="keyword">double</span>) m / n * Math.log(<span class="number">2</span>)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>想要理解 guava 的计算原理，还要从的上面推导的过程继续。</li>
<li>由假阳性率的近似计算方法可知，如果要使假阳性率尽量小，在 m 和 n 给定的情况下，<code>k</code>值应为：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/7.png" alt=""></li>
<li>将 k 代入上一节的式子并化简，我们可以整理出期望假阳性率 p 与 m、n 的关系：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/8,.png" alt=""></li>
<li>换算而得：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/9.png" alt=""></li>
<li>根据以上分析得出以下的结论：<ol>
<li>如果指定期望假阳性率 p，那么最优的 m 值与期望元素数 n 呈线性关系。</li>
<li>最优的 k 值实际上只与 p 有关，与 m 和 n 都无关，即：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/10.png" alt=""></li>
<li>综上两个结论，在创建布隆过滤器的时候，确定<code>p</code>值和<code>m</code>值很重要。</li>
</ol>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>至此，布隆过滤器的知识介绍到这里，如果觉得陈某写得不错的，转发在看点一波，读者的一份支持将会是我莫大的鼓励。</li>
<li><strong>另外想和陈某私聊或者想要加交流群的朋友，公众号回复关键词<code>加群</code>加陈某微信，陈某会第一时间拉你进群。</strong></li>
</ul>
<h2 id="巨人的肩膀"><a href="#巨人的肩膀" class="headerlink" title="巨人的肩膀"></a>巨人的肩膀</h2><ul>
<li><a href="https://blog.csdn.net/u012422440/article/details/94088166" target="_blank" rel="external">https://blog.csdn.net/u012422440/article/details/94088166</a></li>
<li><a href="https://blog.csdn.net/Revivedsun/article/details/94992323" target="_blank" rel="external">https://blog.csdn.net/Revivedsun/article/details/94992323</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;文章首发于微信公众号&lt;a href=&quot;https://mp.weixin.qq.com/s/Vo935pCXH0aPgG20f1
    
    </summary>
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>看完这篇缓存穿透的文章，保证你能和面试官互扯！！！</title>
    <link href="http://chenjiabing666.github.io/2020/04/26/%E7%9C%8B%E5%AE%8C%E8%BF%99%E7%AF%87%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%9A%84%E6%96%87%E7%AB%A0%EF%BC%8C%E4%BF%9D%E8%AF%81%E4%BD%A0%E8%83%BD%E5%92%8C%E9%9D%A2%E8%AF%95%E5%AE%98%E4%BA%92%E6%89%AF%EF%BC%81%EF%BC%81%EF%BC%81/"/>
    <id>http://chenjiabing666.github.io/2020/04/26/看完这篇缓存穿透的文章，保证你能和面试官互扯！！！/</id>
    <published>2020-04-26T14:05:19.000Z</published>
    <updated>2020-08-19T06:59:25.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>昨天有读者朋友留言，想要陈某写一篇防止缓存穿透的文章，今天特意写了一篇。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/4.png" alt=""></li>
<li>文章目录如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/%E7%9C%8B%E5%AE%8C%E8%BF%99%E7%AF%87%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%9A%84%E6%96%87%E7%AB%A0%EF%BC%8C%E4%BF%9D%E8%AF%81%E4%BD%A0%E8%83%BD%E5%92%8C%E9%9D%A2%E8%AF%95%E5%AE%98%E4%BA%92%E6%89%AF.png" alt=""></li>
</ul>
<h2 id="什么是缓存穿透？"><a href="#什么是缓存穿透？" class="headerlink" title="什么是缓存穿透？"></a>什么是缓存穿透？</h2><ul>
<li><strong>缓存穿透</strong>其实是指从缓存中没有查到数据，而不得不从后端系统（比如数据库）中查询的情况。</li>
<li>缓存毕竟是在内存中，不可能所有的数据都存储在 Redis 中，因此少量的缓存穿透是不可避免的，也是系统能够承受的，但是一旦在瞬间发生大量的缓存穿透，数据库的压力会瞬间增大，后果可想而知。</li>
<li>在开发中使用缓存的方案如下图，在查询数据库之前会先查询 Redis：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/1.png" alt="Redis缓存"></li>
<li>缓存穿透的整个过程分为如下几个步骤：<ol>
<li>应用查询缓存，<strong>缓存不命中</strong></li>
<li>DB 层查询不命中，<strong>不将空结果缓存</strong></li>
<li>返回空结果</li>
<li>下一个请求继续重复1,2,3步。</li>
</ol>
</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul>
<li>万事万物都是相生相克，既然出现了缓存穿透，就一定有避免的方案。</li>
<li>下面介绍两种缓存的方案，分别是<code>缓存空值</code>、<code>布隆过滤器</code>。</li>
</ul>
<h3 id="缓存空值"><a href="#缓存空值" class="headerlink" title="缓存空值"></a>缓存空值</h3><ul>
<li>回顾缓存穿透的定义知道，<strong>大量空值没有缓存导致重复的访问 DB 层</strong>，由此解决方案也是很明显了，直接将返回的空值也缓存即可。此时的执行步骤如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/2.png" alt="缓存空值"></li>
<li>如上图所示，如果缓存不命中，查询 DB 层之后，直接将空值缓存在 Redis 中。伪代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Object nullValue = <span class="keyword">new</span> Object();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  Object valueFromDB = getFromDB(uid); <span class="comment">//从数据库中查询数据</span></div><div class="line">  <span class="keyword">if</span> (valueFromDB == <span class="keyword">null</span>) &#123;</div><div class="line">    cache.set(uid, nullValue, <span class="number">10</span>);   <span class="comment">//如果从数据库中查询到空值，就把空值写入缓存，设置较短的超时时间</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    cache.set(uid, valueFromDB, <span class="number">1000</span>);</div><div class="line">  &#125;</div><div class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</div><div class="line">  <span class="comment">// 出现异常也要写入缓存</span></div><div class="line">  cache.set(uid, nullValue, <span class="number">10</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>通过伪代码可以很清楚的了解了缓存空值的流程，但是需要注意以下问题：<ul>
<li><strong>缓存一定要设置过期时间</strong>：因为空值并不是准确的业务数据，并且会占用缓存空间，所以要给空值加上一个过期时间，使得能够在短期之内被淘汰。但是随之而来的一个问题就是在一定的时间窗口内缓存的数据和实际数据不一致，比如设置 10 秒钟过期时间，但是在这 10 秒之内业务又写入了数据，那么返回就不应该为空值了，所以还要考虑数据一致的问题，解决方法很简单，利用消息系统或者主动更新的方式清除掉缓存中的数据即可。</li>
</ul>
</li>
</ul>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><ul>
<li>1970 年布隆提出了一种布隆过滤器的算法，用来判断一个元素是否在一个集合中。这种算法由一个二进制数组和一个 Hash 算法组成。</li>
<li>具体的算法思想这里不再详细解释了，如有不了解的可以看陈某上一篇文章<a href="https://mp.weixin.qq.com/s/Vo935pCXH0aPgG20f1ppEg" target="_blank" rel="external">大白话布隆过滤器，又能和面试官扯皮了~</a>。</li>
<li>解决缓存穿透的大致思想：<strong>在访问缓存层和存储层之前，可以通过定时任务或者系统任务来初始化布隆过滤器，将存在的 key 用布隆过滤器提前保存起来，做第一层的拦截</strong>。例如：一个推荐系统有 4 亿个用户 id， 每个小时算法工程师会根据每个用户之前历史行为计算出推荐数据放到存储层中， 但是最新的用户由于没有历史行为， 就会发生缓存穿透的行为， 为此可以将所有推荐数据的用户做成布隆过滤器。 如果布隆过滤器认为该用户 id 不存在， 那么就不会访问存储层， 在一定程度保护了存储层。此时的结构如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/6.png" alt="布隆过滤器"></li>
<li>当然布隆过滤器的<strong>假阳性</strong>的存在导致了误判率，但是我们可以尽量的降低误判率，一个解决方案就是：使用多个 Hash 算法为元素计算出多个 Hash 值，只有所有 Hash 值对应的数组中的值都为 1 时，才会认为这个元素在集合中。</li>
<li>这种方法适用于<code>数据命中不高</code>、 <code>数据相对固定</code>、 <code>实时性低</code>（通常是<code>数据 集较大</code>）的应用场景，代码维护较为复杂，但是缓存空间占用少。为什么呢？因为布隆过滤器不支持删除元素，一旦数据变化，并不能及时的更新布隆过滤器。</li>
</ul>
<h2 id="两种方案对比"><a href="#两种方案对比" class="headerlink" title="两种方案对比"></a>两种方案对比</h2><ul>
<li>两种方案各有优缺点，具体使用哪种方案还是要根据业务场景和系统体量来定。具体的区别如下表：</li>
</ul>
<table>
<thead>
<tr>
<th>方案</th>
<th>适用场景</th>
<th>维护成本</th>
</tr>
</thead>
<tbody>
<tr>
<td>缓存对象</td>
<td>1. 数据命中不高 2. 数据频繁变化，实时性高</td>
<td>代码维护点单、需要过多的缓存空间，数据一致性需要自己实现</td>
</tr>
<tr>
<td>布隆过滤器</td>
<td>1. 数据命中不高 2.数据相对固定，实时性低</td>
<td>代码维护复杂、缓存空间占用少</td>
</tr>
</tbody>
</table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>至此，如何解决缓存穿透的问题已经介绍完了，觉得写得不错的，有所收获的朋友，点点在看，分享关注一波。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;昨天有读者朋友留言，想要陈某写一篇防止缓存穿透的文章，今天特意写了一篇。&lt;br&gt;&lt;img src=&quot;https://gitee.
    
    </summary>
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>一文搞懂Redis持久化</title>
    <link href="http://chenjiabing666.github.io/2020/04/20/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://chenjiabing666.github.io/2020/04/20/一文搞懂Redis持久化/</id>
    <published>2020-04-20T08:59:42.000Z</published>
    <updated>2020-04-20T09:00:11.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>Redis目前已经成为主流的内存数据库了，但是大部分人仅仅是停留在会用的阶段，你真的了解Redis内部的工作原理吗？</li>
<li>今天这篇文章将为大家介绍Redis持久化的两种方案，文章将会从以下五个方面介绍：<ol>
<li><strong>什么是RDB，RDB如何实现持久化？</strong></li>
<li><strong>什么是AOF，AOF如何实现持久化？</strong></li>
<li><strong>AOF和RDB的区别。</strong></li>
<li><strong>如何重启恢复数据？</strong></li>
<li><strong>持久化性能问题和解决方案</strong><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2></li>
</ol>
</li>
<li>RDB持久化是把当前进程数据生成快照保存到硬盘的过程， 触发RDB持久化过程分为手动触发和自动触发。</li>
<li>RDB完成后会自动生成一个文件，保存在<code>dir</code>配置的指定目录下，文件名是<code>dbfileName</code>指定。</li>
<li>Redis默认会采用LZF算法对生成的RDB文件做压缩处理，压缩后的文件远远小于内存大小，默认开启。</li>
</ul>
<h3 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h3><ul>
<li>手动触发的命令有<code>save</code>和<code>bgsave</code>。</li>
<li><code>save</code>：该命令会阻塞Redis服务器，直到RDB的过程完成，已经被废弃，因此线上不建议使用。</li>
<li><code>bgsave</code>：每次进行RDB过程都会fork一个子进程，由子进程完成RDB的操作，因此阻塞只会发生在fork阶段，一般时间很短。</li>
</ul>
<h3 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h3><ul>
<li>除了手动触发RDB，Redis服务器内部还有如下几个场景能够自动触发RDB：<ol>
<li>根据我们的 <code>save m n</code> 配置规则自动触发。</li>
<li>如果从节点执行全量复制操作， 主节点自动执行bgsave生成RDB文件并发送给从节点。</li>
<li>执行<code>debug reload</code>命令重新加载Redis时， 也会自动触发save操作。</li>
<li>默认情况下执行shutdown命令时， 如果没有开启AOF持久化功能则自动执行<code>bgsave</code>。</li>
</ol>
</li>
</ul>
<h3 id="RDB执行流程"><a href="#RDB执行流程" class="headerlink" title="RDB执行流程"></a>RDB执行流程</h3><ul>
<li>RDB的主流方式就是bgsave，通过下图我们来看看RDB的执行流程：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Redis%E6%8C%81%E4%B9%85%E5%8C%96/RDB%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="RDB执行流程"></li>
<li>通过上图可以很清楚RDB的执行流程，如下：<ol>
<li>执行bgsave命令后，会先判断是否存在AOF或者RDB的子进程，如果存在，直接返回。</li>
<li>父进程fork操作创建一个子进程，fork操作中父进程会被阻塞。</li>
<li>fork完成后，子进程开始根据父进程的内存生成临时快照文件，完成后对原有的RDB文件进行替换。执行<code>lastsave</code>命令可以查看最近一次的RDB时间。</li>
<li>子进程完成后发送信号给父进程，父进程更新统计信息。</li>
</ol>
</li>
</ul>
<h3 id="RDB的优点"><a href="#RDB的优点" class="headerlink" title="RDB的优点"></a>RDB的优点</h3><ul>
<li>RDB是一个紧凑压缩的二进制文件， 代表Redis在某个时间点上的数据快照。 非常适用于备份， 全量复制等场景。 比如每6小时执行<code>bgsave</code>备份，并把RDB文件拷贝到远程机器或者文件系统中，用于灾难恢复。</li>
<li>Redis加载<code>RDB</code>恢复数据远远快于<code>AOF</code>的方式。</li>
</ul>
<h3 id="RDB的缺点"><a href="#RDB的缺点" class="headerlink" title="RDB的缺点"></a>RDB的缺点</h3><ul>
<li>RDB方式数据没办法做到<code>实时持久化</code>/<code>秒级持久化</code>。 因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。</li>
<li>RDB文件使用特定二进制格式保存， Redis版本演进过程中有多个格式的RDB版本， 存在老版本Redis服务无法兼容新版RDB格式的问题。</li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><ul>
<li><code>AOF</code>（append only file） 持久化： 以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中的命令达到恢复数据的目的。 AOF的主要作用是解决了数据持久化的实时性， 目前已经是Redis持久化的<code>主流方式</code>。</li>
</ul>
<h3 id="如何开启AOF"><a href="#如何开启AOF" class="headerlink" title="如何开启AOF"></a>如何开启AOF</h3><ul>
<li>开启AOF功能需要设置配置：<code>appendonly yes</code>， 默认不开启。 AOF文件名通过<code>appendfilename</code>配置设置， 默认文件名是<code>appendonly.aof</code>。 保存路径同RDB持久化方式一致，通过<code>dir</code>配置指定。 </li>
</ul>
<h3 id="AOF整体的执行流程"><a href="#AOF整体的执行流程" class="headerlink" title="AOF整体的执行流程"></a>AOF整体的执行流程</h3><ul>
<li>AOF执行的流程大致分为<code>命令写入</code>、<code>文件同步</code>、<code>文件重写</code>、<code>重启加载</code>四个步骤，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Redis%E6%8C%81%E4%B9%85%E5%8C%96/AOF%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="AOF执行流程"></li>
<li>从上图大致了解了AOF的执行流程，下面一一分析上述的四个步骤。</li>
</ul>
<h3 id="命令写入"><a href="#命令写入" class="headerlink" title="命令写入"></a>命令写入</h3><ul>
<li><p>AOF命令写入的内容直接是文本协议格式。 例如<code>set hello world</code>这条命<br>令， 在AOF缓冲区会追加如下文本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*<span class="number">3</span>\r\n$<span class="number">3</span>\r\nset\r\n$<span class="number">5</span>\r\nhello\r\n$<span class="number">5</span>\r\nworld\r\n</div></pre></td></tr></table></figure>
</li>
<li><p>命令写入是直接写入到AOF的缓冲区中，至于为什么？原因很简单，Redis使用单线程响应命令，如果每次写AOF文件命令都直接追加到硬盘， 那么性能完全取决于当前硬盘负载。先写入缓冲区<code>aof_buf</code>中， 还有另一个好处， Redis可以提供多种缓冲区<br>同步硬盘的策略，在性能和安全性方面做出平衡。</p>
</li>
</ul>
<h3 id="文件同步"><a href="#文件同步" class="headerlink" title="文件同步"></a>文件同步</h3><ul>
<li>Redis提供了多种AOF缓冲区同步文件策略， 由参数<code>appendfsync</code>控制，如下：<ul>
<li>配置为<code>always</code>时， 每次写入都要同步AOF文件， 在一般的SATA硬盘上，Redis只能支持大约几百TPS写入， 显然跟Redis高性能特性背道而驰，不建议配置。</li>
<li>配置为<code>no</code>，由于操作系统每次同步AOF文件的周期不可控，而且会加大每次同步硬盘的数据量，虽然提升了性能，但数据安全性无法保证。</li>
<li>配置为<code>everysec</code>（默认的配置），是<strong>建议的同步策略</strong>， 也是默认配置，做到兼顾性能和数据安全性。理论上只有在系统突然宕机的情况下丢失1秒的数据（当然，这是不太准确的）。</li>
</ul>
</li>
</ul>
<h3 id="文件重写机制"><a href="#文件重写机制" class="headerlink" title="文件重写机制"></a>文件重写机制</h3><ul>
<li>随着命令不断写入AOF， 文件会越来越大， 为了解决这个问题， Redis引入AOF重写机制压缩文件体积。 AOF文件重写是把Redis进程内的数据转化为写命令同步到新AOF文件的过程。</li>
<li><strong>为什么要文件重写呢？</strong> 因为文件重写能够使得AOF文件的体积变得更小，从而使得可以更快的被Redis加载。</li>
<li>重写过程分为手动触发和自动触发。<ul>
<li>手动触发直接使用<code>bgrewriteaof</code>命令。</li>
<li>根据<code>auto-aof-rewrite-min-size</code>和<code>auto-aof-rewrite-percentage</code>参数确定自动触发时机。</li>
</ul>
</li>
<li><code>auto-aof-rewrite-min-size</code>：表示运行AOF重写时文件最小体积， 默认为64MB。</li>
<li><code>auto-aof-rewrite-percentage</code>：代表当前AOF文件空间（<code>aof_current_size</code>） 和上一次重写后AOF文件空间（<code>aof_base_size</code>） 的比值。</li>
<li>自动触发时机相当于<strong>aof_current_size&gt;auto-aof-rewrite-minsize&amp;&amp;（aof_current_size-aof_base_size） /aof_base_size&gt;=auto-aof-rewritepercentage</strong>。其中<code>aof_current_size</code>和<code>aof_base_size</code>可以在<code>info Persistence</code>统计信息中查看。</li>
<li><strong>那么文件重写后的AOF文件为什么会变小呢？</strong> 有如下几个原因：<ol>
<li>进程内已经超时的数据将不会再次写入AOF文件中。</li>
<li>旧的AOF文件含有无效命令，如<code>del key1</code>、 <code>hdel key2</code>等。重写使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令。</li>
<li>多条写命令可以合并为一个， 如：<code>lpush list a</code>、 <code>lpush list b</code>、<code>lpush listc</code>可以转化为：<code>lpush list a b c</code>。为了防止单条命令过大造成客户端缓冲区溢出，对于<code>list</code>、 <code>set</code>、 <code>hash</code>、 <code>zset</code>等类型操作，以64个元素为界拆分为多条。</li>
</ol>
</li>
<li>介绍了文件重写的系列知识，下面来看看Redis内部是如何进行文件重写的，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Redis%E6%8C%81%E4%B9%85%E5%8C%96/%E6%96%87%E4%BB%B6%E9%87%8D%E5%86%99%E6%B5%81%E7%A8%8B.png" alt="文件重写"></li>
<li>看完上图，大致了解了文件重写的流程，对于重写的流程，补充如下：<ol>
<li>重写期间，主线程并没有阻塞，而是在执行其他的操作命令，依然会向旧的AOF文件写入数据，这样能够保证备份的最终完整性，如果数据重写失败，也能保证数据不会丢失。</li>
<li>为了把重写期间响应的写入信息也写入到新的文件中，因此也会为子进程保留一个缓冲区，防止新写的文件丢失数据。</li>
<li>重写是直接把当前内存的数据生成对应命令，并不需要读取老的AOF文件进行分析、命令合并。</li>
<li>AOF文件直接采用的<code>文本协议</code>，主要是兼容性好、追加方便、可读性高可认为修改修复。</li>
<li>无论是<code>RDB</code>还是<code>AOF</code>都是先写入一个临时文件，然后通过<code>重命名</code>完成文件的替换。</li>
</ol>
</li>
</ul>
<h3 id="AOF的优点"><a href="#AOF的优点" class="headerlink" title="AOF的优点"></a>AOF的优点</h3><ul>
<li>使用 AOF 持久化会让 Redis 变得非常耐久：你可以设置不同的 fsync 策略，比如无 fsync ，每秒钟一次 fsync ，或者每次执行写入命令时 fsync 。 AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。</li>
</ul>
<h3 id="AOF的缺点"><a href="#AOF的缺点" class="headerlink" title="AOF的缺点"></a>AOF的缺点</h3><ul>
<li>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间。</li>
<li>数据恢复速度相对于RDB比较慢。</li>
</ul>
<h2 id="AOF和RDB的区别"><a href="#AOF和RDB的区别" class="headerlink" title="AOF和RDB的区别"></a>AOF和RDB的区别</h2><ul>
<li>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</li>
<li>AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</li>
</ul>
<h2 id="重启加载"><a href="#重启加载" class="headerlink" title="重启加载"></a>重启加载</h2><ul>
<li>无论是RDB还是AOF都可用于服务器重启时的数据恢复，执行流程如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Redis%E6%8C%81%E4%B9%85%E5%8C%96/%E5%90%AF%E5%8A%A8%E6%81%A2%E5%A4%8D.png" alt="重启加载流程"></li>
<li>上图很清晰的分析了Redis启动恢复数据的流程，先检查AOF文件是否开启，文件是否存在，再检查RDB是否开启，文件是否存在。</li>
</ul>
<h2 id="性能问题与解决方案"><a href="#性能问题与解决方案" class="headerlink" title="性能问题与解决方案"></a>性能问题与解决方案</h2><ul>
<li>通过上面的分析，我们都知道RDB的快照、AOF的重写都需要fork，这是一个重量级操作，会对Redis造成阻塞。因此为了不影响Redis主进程响应，我们需要尽可能降低阻塞。</li>
<li>那么如何减少fork操作的阻塞呢？<ol>
<li>优先使用物理机或者高效支持fork操作的虚拟化技术。</li>
<li>控制Redis实例最大可用内存， fork耗时跟内存量成正比， 线上建议每个Redis实例内存控制在10GB以内。</li>
<li>合理配置Linux内存分配策略，避免物理内存不足导致fork失败。</li>
<li>降低fork操作的频率，如适度放宽AOF自动触发时机，避免不必要的全量复制等。</li>
</ol>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>本文介绍了Redis持久化的两种不同的策略，大部分内容是运维人员需要掌握的，当然作为后端人员也是需要了解一下，毕竟小公司都是一人搞全栈，哈哈。</li>
<li><strong>如果觉得陈某写的不错，有所收获的话，关注分享一波，你的关注将是陈某写作的最大动力，谢谢支持！！！</strong></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Redis目前已经成为主流的内存数据库了，但是大部分人仅仅是停留在会用的阶段，你真的了解Redis内部的工作原理吗？&lt;/li&gt;

    
    </summary>
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Mysql最全面试指南</title>
    <link href="http://chenjiabing666.github.io/2020/04/20/Mysql%E6%9C%80%E5%85%A8%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    <id>http://chenjiabing666.github.io/2020/04/20/Mysql最全面试指南/</id>
    <published>2020-04-20T08:57:55.000Z</published>
    <updated>2020-04-20T08:58:36.532Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>前几天有读者找到我，说想要一套全面的Mysql面试题，今天陈某特地为她写了一篇。</li>
<li>由于篇幅较长，陈某已经将此文章转换为PDF，公众号回复关键词<code>Mysql面试题</code>即可获取。</li>
</ul>
<h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><h3 id="什么是SQL？"><a href="#什么是SQL？" class="headerlink" title="什么是SQL？"></a>什么是SQL？</h3><ul>
<li>结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询语言。</li>
<li>作用：用于存取数据、查询、更新和管理关系数据库系统。</li>
</ul>
<h3 id="什么是MySQL"><a href="#什么是MySQL" class="headerlink" title="什么是MySQL?"></a>什么是MySQL?</h3><ul>
<li>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。</li>
</ul>
<h3 id="数据库三大范式是什么？"><a href="#数据库三大范式是什么？" class="headerlink" title="数据库三大范式是什么？"></a>数据库三大范式是什么？</h3><ul>
<li><code>第一范式</code>：每个列都不可以再拆分。</li>
<li><code>第二范式</code>：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</li>
<li><code>第三范式</code>：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</li>
<li>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</li>
</ul>
<h3 id="mysql有关权限的表都有哪几个？"><a href="#mysql有关权限的表都有哪几个？" class="headerlink" title="mysql有关权限的表都有哪几个？"></a>mysql有关权限的表都有哪几个？</h3><ul>
<li>MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：<ol>
<li><code>user权限表</code>：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</li>
<li><code>db权限表</code>：记录各个帐号在各个数据库上的操作权限。</li>
<li><code>table_priv权限表</code>：记录数据表级的操作权限。</li>
<li><code>columns_priv权限表</code>：记录数据列级的操作权限。</li>
<li><code>host权限表</code>：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</li>
</ol>
</li>
</ul>
<h3 id="MySQL的binlog有有几种录入格式？分别有什么区别？"><a href="#MySQL的binlog有有几种录入格式？分别有什么区别？" class="headerlink" title="MySQL的binlog有有几种录入格式？分别有什么区别？"></a>MySQL的binlog有有几种录入格式？分别有什么区别？</h3><ul>
<li>有三种格式，statement，row和mixed。<ul>
<li>statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</li>
<li>row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。</li>
<li>mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。</li>
</ul>
</li>
<li>此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。</li>
</ul>
<h3 id="mysql有哪些数据类型？"><a href="#mysql有哪些数据类型？" class="headerlink" title="mysql有哪些数据类型？"></a>mysql有哪些数据类型？</h3><ul>
<li>1、整数类型，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。<ul>
<li>长度：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。</li>
<li>例子：假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。</li>
</ul>
</li>
<li>2、实数类型，包括FLOAT、DOUBLE、DECIMAL。DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。</li>
<li>3、字符串类型，包括VARCHAR、CHAR、TEXT、BLOB<ul>
<li>VARCHAR用于存储可变长字符串，它比定长类型更节省空间。</li>
<li>VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。</li>
<li>VARCHAR存储的内容超出设置的长度时，内容会被截断。</li>
<li>CHAR是定长的，根据定义的字符串长度分配足够的空间。</li>
<li>CHAR会根据需要使用空格进行填充方便比较。</li>
<li>CHAR适合存储很短的字符串，或者所有值都接近同一个长度。</li>
<li>CHAR存储的内容超出设置的长度时，内容同样会被截断。</li>
</ul>
</li>
<li>4、枚举类型（ENUM），把不重复的数据存储为一个预定义的集合。<ul>
<li>有时可以使用ENUM代替常用的字符串类型。</li>
<li>ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。</li>
<li>ENUM在内部存储时，其实存的是整数。</li>
<li>尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。</li>
<li>排序是按照内部存储的整数</li>
</ul>
</li>
<li>5、日期和时间类型，尽量使用timestamp，空间效率高于datetime，<ul>
<li>用整数保存时间戳通常不方便处理。</li>
<li>如果需要存储微妙，可以使用bigint存储。</li>
<li>看到这里，这道真题是不是就比较容易回答了。</li>
</ul>
</li>
</ul>
<h3 id="MyISAM索引与InnoDB索引的区别？"><a href="#MyISAM索引与InnoDB索引的区别？" class="headerlink" title="MyISAM索引与InnoDB索引的区别？"></a>MyISAM索引与InnoDB索引的区别？</h3><ul>
<li>InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。</li>
<li>InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。</li>
<li>MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</li>
<li>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</li>
</ul>
<h3 id="InnoDB引擎的4大特性"><a href="#InnoDB引擎的4大特性" class="headerlink" title="InnoDB引擎的4大特性"></a>InnoDB引擎的4大特性</h3><ul>
<li>插入缓冲（insert buffer)</li>
<li>二次写(double write)</li>
<li>自适应哈希索引(ahi)</li>
<li>预读(read ahead)</li>
</ul>
<h3 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h3><ul>
<li>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</li>
<li>索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</li>
<li>更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。</li>
</ul>
<h3 id="索引有哪些优缺点？"><a href="#索引有哪些优缺点？" class="headerlink" title="索引有哪些优缺点？"></a>索引有哪些优缺点？</h3><ul>
<li>索引的优点： <ul>
<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li>
</ul>
</li>
<li>索引的缺点：<ul>
<li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；</li>
<li>空间方面：索引需要占物理空间。</li>
</ul>
</li>
</ul>
<h3 id="索引有哪几种类型？"><a href="#索引有哪几种类型？" class="headerlink" title="索引有哪几种类型？"></a>索引有哪几种类型？</h3><ul>
<li><code>主键索引</code>: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。</li>
<li><code>唯一索引</code>: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。<ul>
<li>可以通过 <code>ALTER TABLE table_name ADD UNIQUE (column);</code> 创建唯一索引</li>
<li>可以通过 <code>ALTER TABLE table_name ADD UNIQUE (column1,column2);</code> 创建唯一组合索引</li>
</ul>
</li>
<li><code>普通索引</code>: 基本的索引类型，没有唯一性的限制，允许为NULL值。<ul>
<li>可以通过<code>ALTER TABLE table_name ADD INDEX index_name (column);</code>创建普通索引</li>
<li>可以通过<code>ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);</code>创建组合索引。</li>
</ul>
</li>
<li><code>全文索引</code>： 是目前搜索引擎使用的一种关键技术。<ul>
<li>可以通过<code>ALTER TABLE table_name ADD FULLTEXT (column);</code>创建全文索引</li>
</ul>
</li>
</ul>
<h3 id="索引的数据结构（b树，hash）"><a href="#索引的数据结构（b树，hash）" class="headerlink" title="索引的数据结构（b树，hash）"></a>索引的数据结构（b树，hash）</h3><ul>
<li>索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有Hash索引，B+树索引等，而我们经常使用的InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</li>
</ul>
<p><strong>1. B树索引</strong></p>
<ul>
<li>mysql通过存储引擎取数据，基本上90%的人用的就是InnoDB了，按照实现方式分，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。B树索引是Mysql数据库中使用最频繁的索引类型，基本所有存储引擎都支持BTree索引。通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/1.jpg" alt="B树索引"></li>
</ul>
<p><strong>2. B+tree性质</strong></p>
<ul>
<li>n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</li>
<li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li>
<li>所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</li>
<li>B+ 树中，数据对象的插入和删除仅在叶节点上进行。</li>
<li>B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</li>
</ul>
<p><strong>3. 哈希索引</strong></p>
<ul>
<li>简要说下，类似于数据结构中简单实现的HASH表（散列表）一样，当我们在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。当然这只是简略模拟图。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/2.jpg" alt="哈希索引"></li>
</ul>
<h3 id="索引的基本原理"><a href="#索引的基本原理" class="headerlink" title="索引的基本原理"></a>索引的基本原理</h3><ul>
<li>索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</li>
<li>索引的原理很简单，就是把无序的数据变成有序的查询<ol>
<li>把创建了索引的列的内容进行排序</li>
<li>对排序结果生成倒排表</li>
<li>在倒排表内容上拼上数据地址链</li>
<li>在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</li>
</ol>
</li>
</ul>
<h3 id="索引算法有哪些？"><a href="#索引算法有哪些？" class="headerlink" title="索引算法有哪些？"></a>索引算法有哪些？</h3><ul>
<li>索引算法有 BTree算法和Hash算法</li>
</ul>
<p><strong>1. BTree算法</strong></p>
<ul>
<li>BTree是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,&gt;,&gt;=,&lt;,&lt;=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量。</li>
</ul>
<p><strong>2. Hash算法</strong></p>
<ul>
<li>Hash Hash索引只能用于对等比较，例如=,&lt;=&gt;（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。</li>
</ul>
<h3 id="索引设计的原则？"><a href="#索引设计的原则？" class="headerlink" title="索引设计的原则？"></a>索引设计的原则？</h3><ul>
<li>适合索引的列是出现在where子句中的列，或者连接子句中指定的列。</li>
<li>基数较小的类，索引效果较差，没有必要在此列建立索引</li>
<li>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</li>
<li>不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</li>
</ul>
<h3 id="创建索引的原则"><a href="#创建索引的原则" class="headerlink" title="创建索引的原则"></a>创建索引的原则</h3><ul>
<li>索引虽好，但也不是无限制的使用，最好符合一下几个原则<ul>
<li>最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li>
<li>较频繁作为查询条件的字段才去创建索引</li>
<li>更新频繁字段不适合创建索引</li>
<li>若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</li>
<li>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</li>
<li>定义有外键的数据列一定要建立索引。</li>
<li>对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</li>
<li>对于定义为text、image和bit的数据类型的列不要建立索引。</li>
</ul>
</li>
</ul>
<h3 id="创建索引时需要注意什么？"><a href="#创建索引时需要注意什么？" class="headerlink" title="创建索引时需要注意什么？"></a>创建索引时需要注意什么？</h3><ul>
<li>非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</li>
<li>取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</li>
<li>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</li>
</ul>
<h3 id="使用索引查询一定能提高查询的性能吗？"><a href="#使用索引查询一定能提高查询的性能吗？" class="headerlink" title="使用索引查询一定能提高查询的性能吗？"></a>使用索引查询一定能提高查询的性能吗？</h3><ul>
<li>通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。</li>
<li>索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:</li>
<li>基于一个范围的检索，一般查询返回结果集小于表中记录数的30%</li>
<li>基于非唯一性索引的检索</li>
</ul>
<h3 id="百万级别或以上的数据如何删除？"><a href="#百万级别或以上的数据如何删除？" class="headerlink" title="百万级别或以上的数据如何删除？"></a>百万级别或以上的数据如何删除？</h3><ul>
<li>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。<ol>
<li>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li>
<li>然后删除其中无用数据（此过程需要不到两分钟）</li>
<li>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li>
<li>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li>
</ol>
</li>
</ul>
<h3 id="什么是最左前缀原则？什么是最左匹配原则？"><a href="#什么是最左前缀原则？什么是最左匹配原则？" class="headerlink" title="什么是最左前缀原则？什么是最左匹配原则？"></a>什么是最左前缀原则？什么是最左匹配原则？</h3><ul>
<li>顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</li>
<li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li>
<li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li>
</ul>
<h3 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h3><ul>
<li>在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。</li>
<li>B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/3.jpg" alt="B树和B+树的区别"></li>
</ul>
<h3 id="使用B树的好处"><a href="#使用B树的好处" class="headerlink" title="使用B树的好处"></a>使用B树的好处</h3><ul>
<li>B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</li>
</ul>
<h3 id="使用B-树的好处"><a href="#使用B-树的好处" class="headerlink" title="使用B+树的好处"></a>使用B+树的好处</h3><ul>
<li>由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。 B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间</li>
</ul>
<h3 id="什么是聚簇索引？何时使用聚簇索引与非聚簇索引？"><a href="#什么是聚簇索引？何时使用聚簇索引与非聚簇索引？" class="headerlink" title="什么是聚簇索引？何时使用聚簇索引与非聚簇索引？"></a>什么是聚簇索引？何时使用聚簇索引与非聚簇索引？</h3><ul>
<li>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</li>
<li>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因。</li>
</ul>
<h3 id="非聚簇索引一定会回表查询吗？"><a href="#非聚簇索引一定会回表查询吗？" class="headerlink" title="非聚簇索引一定会回表查询吗？"></a>非聚簇索引一定会回表查询吗？</h3><ul>
<li>不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。</li>
<li>举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行select age from employee where age &lt; 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。</li>
</ul>
<h3 id="联合索引是什么？为什么需要注意联合索引中的顺序？"><a href="#联合索引是什么？为什么需要注意联合索引中的顺序？" class="headerlink" title="联合索引是什么？为什么需要注意联合索引中的顺序？"></a>联合索引是什么？为什么需要注意联合索引中的顺序？</h3><ul>
<li>MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</li>
<li>MySQL使用索引时需要索引有序，假设现在建立了”name，age，school”的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。</li>
<li>当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</li>
</ul>
<h3 id="什么是数据库事务？"><a href="#什么是数据库事务？" class="headerlink" title="什么是数据库事务？"></a>什么是数据库事务？</h3><ul>
<li>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</li>
</ul>
<h3 id="事物的四大特性-ACID-介绍一下"><a href="#事物的四大特性-ACID-介绍一下" class="headerlink" title="事物的四大特性(ACID)介绍一下?"></a>事物的四大特性(ACID)介绍一下?</h3><ul>
<li><code>原子性</code>： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><code>一致性</code>： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
<li><code>隔离性</code>： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><code>持久性</code>： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ul>
<h3 id="什么是脏读？幻读？不可重复读？"><a href="#什么是脏读？幻读？不可重复读？" class="headerlink" title="什么是脏读？幻读？不可重复读？"></a>什么是脏读？幻读？不可重复读？</h3><ul>
<li><code>脏读</code>(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</li>
<li><code>不可重复读</code>(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</li>
<li><code>幻读</code>(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</li>
</ul>
<h3 id="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"><a href="#什么是事务的隔离级别？MySQL的默认隔离级别是什么？" class="headerlink" title="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"></a>什么是事务的隔离级别？MySQL的默认隔离级别是什么？</h3><ul>
<li>为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</li>
<li>SQL 标准定义了四个隔离级别：<ul>
<li><code>READ-UNCOMMITTED</code>(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
<li><code>READ-COMMITTED</code>(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>
<li><code>REPEATABLE-READ</code>(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li><code>SERIALIZABLE</code>(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li>
</ul>
</li>
<li><strong>Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别</strong></li>
</ul>
<h3 id="隔离级别与锁的关系"><a href="#隔离级别与锁的关系" class="headerlink" title="隔离级别与锁的关系"></a>隔离级别与锁的关系</h3><ul>
<li>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</li>
<li>在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</li>
<li>在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</li>
<li>SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。</li>
</ul>
<h3 id="按照锁的粒度分数据库锁有哪些？"><a href="#按照锁的粒度分数据库锁有哪些？" class="headerlink" title="按照锁的粒度分数据库锁有哪些？"></a>按照锁的粒度分数据库锁有哪些？</h3><ul>
<li><code>行级锁</code>:行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li>
<li><code>表级锁</code>: 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</li>
<li><code>页级锁</code>:页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</li>
</ul>
<h3 id="从锁的类别上分MySQL都有哪些锁呢？"><a href="#从锁的类别上分MySQL都有哪些锁呢？" class="headerlink" title="从锁的类别上分MySQL都有哪些锁呢？"></a>从锁的类别上分MySQL都有哪些锁呢？</h3><ul>
<li>从锁的类别上来讲，有共享锁和排他锁。<ul>
<li>共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</li>
<li>排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</li>
</ul>
</li>
</ul>
<h3 id="InnoDB存储引擎的锁的算法有哪三种？"><a href="#InnoDB存储引擎的锁的算法有哪三种？" class="headerlink" title="InnoDB存储引擎的锁的算法有哪三种？"></a>InnoDB存储引擎的锁的算法有哪三种？</h3><ul>
<li>Record lock：单个行记录上的锁</li>
<li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li>
<li>Next-key lock：record+gap 锁定一个范围，包含记录本身</li>
</ul>
<h3 id="什么是死锁？怎么解决？"><a href="#什么是死锁？怎么解决？" class="headerlink" title="什么是死锁？怎么解决？"></a>什么是死锁？怎么解决？</h3><ul>
<li>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</li>
<li>常见的解决死锁的方法<ol>
<li>如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</li>
<li>在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</li>
<li>对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</li>
</ol>
</li>
<li>如果业务处理不好可以用分布式事务锁或者使用乐观锁</li>
</ul>
<h3 id="数据库的乐观锁和悲观锁是什么？怎么实现的？"><a href="#数据库的乐观锁和悲观锁是什么？怎么实现的？" class="headerlink" title="数据库的乐观锁和悲观锁是什么？怎么实现的？"></a>数据库的乐观锁和悲观锁是什么？怎么实现的？</h3><ul>
<li>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</li>
<li><code>悲观锁</code>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</li>
<li><code>乐观锁</code>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。</li>
</ul>
<h3 id="大表数据查询，怎么优化？"><a href="#大表数据查询，怎么优化？" class="headerlink" title="大表数据查询，怎么优化？"></a>大表数据查询，怎么优化？</h3><ul>
<li>优化shema、sql语句+索引；</li>
<li>第二加缓存，memcached, redis；</li>
<li>主从复制，读写分离；</li>
<li>垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统</li>
<li>水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表</li>
</ul>
<h3 id="超大分页怎么处理？"><a href="#超大分页怎么处理？" class="headerlink" title="超大分页怎么处理？"></a>超大分页怎么处理？</h3><ul>
<li>超大的分页一般从两个方向上来解决:<ul>
<li>数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于select <em> from table where age &gt; 20 limit 1000000,10这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为select </em> from table where id in (select id from table where age &gt; 20 limit 1000000,10).这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以select * from table where id &gt; 1000000 limit 10,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据</li>
<li>从需求的角度减少这种请求…主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击</li>
</ul>
</li>
</ul>
<h3 id="为什么要尽量设定一个主键？"><a href="#为什么要尽量设定一个主键？" class="headerlink" title="为什么要尽量设定一个主键？"></a>为什么要尽量设定一个主键？</h3><ul>
<li>主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。</li>
</ul>
<h3 id="主键使用自增ID还是UUID？"><a href="#主键使用自增ID还是UUID？" class="headerlink" title="主键使用自增ID还是UUID？"></a>主键使用自增ID还是UUID？</h3><ul>
<li>推荐使用自增ID，不要使用UUID。</li>
<li>因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。</li>
<li>总之，在数据量大一些的情况下，用自增主键性能会好一些。</li>
<li>关于主键是聚簇索引，如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。</li>
</ul>
<h3 id="字段为什么要求定义为not-null？"><a href="#字段为什么要求定义为not-null？" class="headerlink" title="字段为什么要求定义为not null？"></a>字段为什么要求定义为not null？</h3><ul>
<li>null值会占用更多的字节，且会在程序中造成很多与预期不符的情况。</li>
</ul>
<h3 id="如果要存储用户的密码散列，应该使用什么字段进行存储？"><a href="#如果要存储用户的密码散列，应该使用什么字段进行存储？" class="headerlink" title="如果要存储用户的密码散列，应该使用什么字段进行存储？"></a>如果要存储用户的密码散列，应该使用什么字段进行存储？</h3><ul>
<li>密码散列，盐，用户身份证号等固定长度的字符串应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。</li>
</ul>
<h3 id="数据库结构优化？"><a href="#数据库结构优化？" class="headerlink" title="数据库结构优化？"></a>数据库结构优化？</h3><ul>
<li>一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。</li>
<li>需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</li>
<li><strong>将字段很多的表分解成多个表</strong>：对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</li>
<li><strong>增加中间表</strong>：对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。</li>
<li><strong>增加冗余字段</strong>：设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。</li>
</ul>
<h3 id="MySQL数据库cpu飙升到500-的话他怎么处理？"><a href="#MySQL数据库cpu飙升到500-的话他怎么处理？" class="headerlink" title="MySQL数据库cpu飙升到500%的话他怎么处理？"></a>MySQL数据库cpu飙升到500%的话他怎么处理？</h3><ul>
<li>当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。</li>
<li>如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。</li>
<li>一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。</li>
<li>也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等。</li>
</ul>
<h3 id="主从复制的作用？"><a href="#主从复制的作用？" class="headerlink" title="主从复制的作用？"></a>主从复制的作用？</h3><ul>
<li>主数据库出现问题，可以切换到从数据库。</li>
<li>可以进行数据库层面的读写分离。</li>
<li>可以在从数据库上进行日常备份。</li>
</ul>
<h3 id="MySQL主从复制解决的问题？"><a href="#MySQL主从复制解决的问题？" class="headerlink" title="MySQL主从复制解决的问题？"></a>MySQL主从复制解决的问题？</h3><ul>
<li>数据分布：随意开始或停止复制，并在不同地理位置分布数据备份</li>
<li>负载均衡：降低单个服务器的压力</li>
<li>高可用和故障切换：帮助应用程序避免单点失败</li>
<li>升级测试：可以用更高版本的MySQL作为从库</li>
</ul>
<h3 id="MySQL主从复制工作原理？"><a href="#MySQL主从复制工作原理？" class="headerlink" title="MySQL主从复制工作原理？"></a>MySQL主从复制工作原理？</h3><ul>
<li>在主库上把数据更高记录到二进制日志</li>
<li>从库将主库的日志复制到自己的中继日志</li>
<li>从库读取中继日志的事件，将其重放到从库数据中。</li>
</ul>
<h2 id="小福利"><a href="#小福利" class="headerlink" title="小福利"></a>小福利</h2><ul>
<li>由于文章篇幅较长，陈某将其转换为PDF文档，老规矩，回复关键词<code>Mysql面试题</code>即可获取。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/4.png" alt=""></li>
</ul>
<h2 id="巨人的肩膀"><a href="#巨人的肩膀" class="headerlink" title="巨人的肩膀"></a>巨人的肩膀</h2><ul>
<li><a href="https://www.cnblogs.com/hsmwlyl/p/10719152.html" target="_blank" rel="external">https://www.cnblogs.com/hsmwlyl/p/10719152.html</a></li>
<li><a href="https://www.cnblogs.com/caomusheng/p/12586895.html" target="_blank" rel="external">https://www.cnblogs.com/caomusheng/p/12586895.html</a></li>
<li><a href="https://article.itxueyuan.com/eoJEMj" target="_blank" rel="external">https://article.itxueyuan.com/eoJEMj</a></li>
<li><a href="https://blog.csdn.net/thinkwon/article/details/104778621#comments" target="_blank" rel="external">https://blog.csdn.net/thinkwon/article/details/104778621#comments</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;前几天有读者找到我，说想要一套全面的Mysql面试题，今天陈某特地为她写了一篇。&lt;/li&gt;
&lt;li&gt;由于篇幅较长，陈某已经将此文
    
    </summary>
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper实现分布式锁</title>
    <link href="http://chenjiabing666.github.io/2020/04/19/Zookeeper%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://chenjiabing666.github.io/2020/04/19/Zookeeper实现分布式锁/</id>
    <published>2020-04-19T07:48:54.000Z</published>
    <updated>2020-04-19T07:49:18.426Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>真是有人(<code>锁</code>)的地方就有江湖(<code>事务</code>)，今天不谈江湖，来撩撩人。</li>
<li>分布式锁的概念、为什么使用分布式锁，想必大家已经很清楚了。前段时间作者写过Redis是如何实现分布式锁，今天这篇文章来谈谈Zookeeper是如何实现分布式锁的。</li>
<li>陈某今天分别从如下几个方面来详细讲讲ZK如何实现分布式锁：<ol>
<li><strong>ZK的四种节点</strong></li>
<li><strong>排它锁的实现</strong></li>
<li><strong>读写锁的实现</strong></li>
<li><strong>Curator实现分步式锁</strong></li>
</ol>
</li>
</ul>
<h2 id="ZK的四种节点"><a href="#ZK的四种节点" class="headerlink" title="ZK的四种节点"></a>ZK的四种节点</h2><ul>
<li>持久性节点：节点创建后将会一直存在</li>
<li>临时节点：临时节点的生命周期和当前会话绑定，一旦当前会话断开临时节点也会删除，当然可以主动删除。</li>
<li>持久有序节点：节点创建一直存在，并且zk会自动为节点加上一个自增的后缀作为新的节点名称。</li>
<li>临时有序节点：保留临时节点的特性，并且zk会自动为节点加上一个自增的后缀作为新的节点名称。</li>
</ul>
<h2 id="排它锁的实现"><a href="#排它锁的实现" class="headerlink" title="排它锁的实现"></a>排它锁的实现</h2><ul>
<li>排他锁的实现相对简单一点，利用了<strong>zk的创建节点不能重名的特性</strong>。如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/ZK%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/zk%E6%8E%92%E4%BB%96%E9%94%81.png" alt=""></p>
<ul>
<li>根据上图分析大致分为如下步骤：<ol>
<li>尝试获取锁：创建<code>临时节点</code>，zk会保证只有一个客户端创建成功。</li>
<li>创建临时节点成功，获取锁成功，执行业务逻辑，业务执行完成后删除锁。</li>
<li>创建临时节点失败，阻塞等待。</li>
<li>监听删除事件，一旦临时节点删除了，表示互斥操作完成了，可以再次尝试获取锁。</li>
<li>递归：获取锁的过程是一个递归的操作，<code>获取锁-&gt;监听-&gt;获取锁</code>。</li>
</ol>
</li>
<li><strong>如何避免死锁</strong>：创建的是临时节点，当服务宕机会话关闭后临时节点将会被删除，锁自动释放。</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul>
<li>作者参照JDK锁的实现方式加上模板方法模式的封装，封装接口如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Description</span> ZK分布式锁的接口</div><div class="line"> * <span class="doctag">@Author</span> 陈某</div><div class="line"> * <span class="doctag">@Date</span> 2020/4/7 22:52</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ZKLock</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取锁</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 解锁</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>模板抽象类如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Description</span> 排他锁，模板类</div><div class="line"> * <span class="doctag">@Author</span> 陈某</div><div class="line"> * <span class="doctag">@Date</span> 2020/4/7 22:55</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractZKLockMutex</span> <span class="keyword">implements</span> <span class="title">ZKLock</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 节点路径</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> String lockPath;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * zk客户端</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> CuratorFramework zkClient;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AbstractZKLockMutex</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractZKLockMutex</span><span class="params">(String lockPath,CuratorFramework client)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.lockPath=lockPath;</div><div class="line">        <span class="keyword">this</span>.zkClient=client;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 模板方法，搭建的获取锁的框架，具体逻辑交于子类实现</div><div class="line">     * <span class="doctag">@throws</span> Exception</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//获取锁成功</span></div><div class="line">        <span class="keyword">if</span> (tryLock())&#123;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"获取锁成功"</span>);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">//获取锁失败</span></div><div class="line">            <span class="comment">//阻塞一直等待</span></div><div class="line">            waitLock();</div><div class="line">            <span class="comment">//递归，再次获取锁</span></div><div class="line">            lock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 尝试获取锁，子类实现</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 等待获取锁，子类实现</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">waitLock</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 解锁：删除节点或者直接断开连接</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>排他锁的具体实现类如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Description</span> 排他锁的实现类，继承模板类 AbstractZKLockMutex</div><div class="line"> * <span class="doctag">@Author</span> 陈某</div><div class="line"> * <span class="doctag">@Date</span> 2020/4/7 23:23</div><div class="line"> */</div><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKLockMutex</span> <span class="keyword">extends</span> <span class="title">AbstractZKLockMutex</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 用于实现线程阻塞</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZKLockMutex</span><span class="params">(String lockPath,CuratorFramework zkClient)</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>(lockPath,zkClient);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 尝试获取锁：直接创建一个临时节点，如果这个节点存在创建失败抛出异常，表示已经互斥了，</div><div class="line">     * 反之创建成功</div><div class="line">     * <span class="doctag">@throws</span> Exception</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            zkClient.create()</div><div class="line">                    <span class="comment">//临时节点</span></div><div class="line">                    .withMode(CreateMode.EPHEMERAL)</div><div class="line">                    <span class="comment">//权限列表 world:anyone:crdwa</span></div><div class="line">                    .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)</div><div class="line">                    .forPath(lockPath,<span class="string">"lock"</span>.getBytes());</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;<span class="keyword">catch</span> (Exception ex)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 等待锁，一直阻塞监听</div><div class="line">     * <span class="doctag">@return</span>  成功获取锁返回true，反之返回false</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">waitLock</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//监听节点的新增、更新、删除</span></div><div class="line">        <span class="keyword">final</span> NodeCache nodeCache = <span class="keyword">new</span> NodeCache(zkClient, lockPath);</div><div class="line">        <span class="comment">//启动监听</span></div><div class="line">        nodeCache.start();</div><div class="line">        ListenerContainer&lt;NodeCacheListener&gt; listenable = nodeCache.getListenable();</div><div class="line"></div><div class="line">        <span class="comment">//监听器</span></div><div class="line">        NodeCacheListener listener=()-&gt; &#123;</div><div class="line">            <span class="comment">//节点被删除，此时获取锁</span></div><div class="line">            <span class="keyword">if</span> (nodeCache.getCurrentData() == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">//countDownLatch不为null，表示节点存在，此时监听到节点删除了，因此-1</span></div><div class="line">                <span class="keyword">if</span> (countDownLatch != <span class="keyword">null</span>)</div><div class="line">                    countDownLatch.countDown();</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        <span class="comment">//添加监听器</span></div><div class="line">        listenable.addListener(listener);</div><div class="line"></div><div class="line">        <span class="comment">//判断节点是否存在</span></div><div class="line">        Stat stat = zkClient.checkExists().forPath(lockPath);</div><div class="line">        <span class="comment">//节点存在</span></div><div class="line">        <span class="keyword">if</span> (stat!=<span class="keyword">null</span>)&#123;</div><div class="line">            countDownLatch=<span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line">            <span class="comment">//阻塞主线程，监听</span></div><div class="line">            countDownLatch.await();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//移除监听器</span></div><div class="line">        listenable.removeListener(listener);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 解锁，直接删除节点</div><div class="line">     * <span class="doctag">@throws</span> Exception</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        zkClient.delete().forPath(lockPath);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="可重入性排他锁如何设计"><a href="#可重入性排他锁如何设计" class="headerlink" title="可重入性排他锁如何设计"></a>可重入性排他锁如何设计</h3><ul>
<li>可重入的逻辑很简单，在本地保存一个<code>ConcurrentMap</code>，<code>key</code>是当前线程，<code>value</code>是定义的数据，结构如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Thread, LockData&gt; threadData = Maps.newConcurrentMap();</div></pre></td></tr></table></figure>
<ul>
<li>重入的伪代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//判断当前线程是否在threadData保存过</span></div><div class="line">    <span class="comment">//存在，直接return true</span></div><div class="line">    <span class="comment">//不存在执行获取锁的逻辑</span></div><div class="line">    <span class="comment">//获取成功保存在threadData中</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="读写锁的实现"><a href="#读写锁的实现" class="headerlink" title="读写锁的实现"></a>读写锁的实现</h2><ul>
<li>读写锁分为读锁和写锁，区别如下：<ul>
<li>读锁允许多个线程同时读数据，但是在读的同时不允许写线程修改。</li>
<li>写锁在获取后，不允许多个线程同时写或者读。</li>
</ul>
</li>
<li>如何实现读写锁？ZK中有一类节点叫临时有序节点，上文有介绍。下面我们来利用临时有序节点来实现读写锁的功能。</li>
</ul>
<h3 id="读锁的设计"><a href="#读锁的设计" class="headerlink" title="读锁的设计"></a>读锁的设计</h3><ul>
<li>读锁允许多个线程同时进行读，并且在读的同时不允许线程进行写操作，实现原理如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/ZK%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/%E8%AF%BB%E9%94%81.png" alt=""></p>
<ul>
<li>根据上图，获取一个读锁分为以下步骤：<ol>
<li>创建临时有序节点（当前线程拥有的<code>读锁</code>或称作<code>读节点</code>）。</li>
<li>获取路径下所有的子节点，并进行<code>从小到大</code>排序</li>
<li>获取当前节点前的临近写节点(写锁)。</li>
<li>如果不存在的临近写节点，则成功获取读锁。</li>
<li>如果存在临近写节点，对其监听删除事件。</li>
<li>一旦监听到删除事件，<strong>重复2,3,4,5的步骤(递归)</strong>。</li>
</ol>
</li>
</ul>
<h3 id="写锁的设计"><a href="#写锁的设计" class="headerlink" title="写锁的设计"></a>写锁的设计</h3><ul>
<li>线程一旦获取了写锁，不允许其他线程读和写。实现原理如下：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/ZK%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/%E5%86%99%E9%94%81.png" alt=""></p>
<ul>
<li>从上图可以看出唯一和写锁不同的就是监听的节点，这里是监听临近节点(读节点或者写节点)，读锁只需要监听写节点，步骤如下：<ol>
<li>创建临时有序节点（当前线程拥有的<code>写锁</code>或称作<code>写节点</code>）。</li>
<li>获取路径下的所有子节点，并进行<code>从小到大</code>排序。</li>
<li>获取当前节点的临近节点(读节点和写节点)。</li>
<li>如果不存在临近节点，则成功获取锁。</li>
<li>如果存在临近节点，对其进行监听删除事件。</li>
<li>一旦监听到删除事件，<strong>重复2,3,4,5的步骤(递归)</strong>。</li>
</ol>
</li>
</ul>
<h3 id="如何监听"><a href="#如何监听" class="headerlink" title="如何监听"></a>如何监听</h3><ul>
<li>无论是写锁还是读锁都需要监听前面的节点，不同的是读锁只监听临近的写节点，写锁是监听临近的所有节点，抽象出来看其实是一种链式的监听，如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/ZK%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/%E9%93%BE%E5%BC%8F.png" alt=""></p>
<ul>
<li>每一个节点都在监听前面的临近节点，一旦前面一个节点删除了，再从新排序后监听前面的节点，这样递归下去。</li>
</ul>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><ul>
<li>作者简单的写了读写锁的实现，先造出来再优化，不建议用在生产环境。代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKLockRW</span>  </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 节点路径</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> String lockPath;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * zk客户端</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> CuratorFramework zkClient;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 用于阻塞线程</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch=<span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String WRITE_NAME=<span class="string">"_W_LOCK"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String READ_NAME=<span class="string">"_R_LOCK"</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZKLockRW</span><span class="params">(String lockPath, CuratorFramework client)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.lockPath=lockPath;</div><div class="line">        <span class="keyword">this</span>.zkClient=client;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取锁，如果获取失败一直阻塞</div><div class="line">     * <span class="doctag">@throws</span> Exception</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//创建节点</span></div><div class="line">        String node = createNode();</div><div class="line">        <span class="comment">//阻塞等待获取锁</span></div><div class="line">        tryLock(node);</div><div class="line">        countDownLatch.await();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建临时有序节点</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     * <span class="doctag">@throws</span> Exception</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">createNode</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//创建临时有序节点</span></div><div class="line">       <span class="keyword">return</span> zkClient.create()</div><div class="line">                .withMode(CreateMode.EPHEMERAL_SEQUENTIAL)</div><div class="line">                .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)</div><div class="line">                .forPath(lockPath);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取写锁</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span>  ZKLockRW <span class="title">writeLock</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ZKLockRW(lockPath+WRITE_NAME,zkClient);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取读锁</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span>  ZKLockRW <span class="title">readLock</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ZKLockRW(lockPath+READ_NAME,zkClient);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryLock</span><span class="params">(String nodePath)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//获取所有的子节点</span></div><div class="line">        List&lt;String&gt; childPaths = zkClient.getChildren()</div><div class="line">                .forPath(<span class="string">"/"</span>)</div><div class="line">                .stream().sorted().map(o-&gt;<span class="string">"/"</span>+o).collect(Collectors.toList());</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">//第一个节点就是当前的锁，直接获取锁。递归结束的条件</span></div><div class="line">        <span class="keyword">if</span> (nodePath.equals(childPaths.get(<span class="number">0</span>)))&#123;</div><div class="line">            countDownLatch.countDown();</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//1. 读锁：监听最前面的写锁，写锁释放了，自然能够读了</span></div><div class="line">        <span class="keyword">if</span> (nodePath.contains(READ_NAME))&#123;</div><div class="line">            <span class="comment">//查找临近的写锁</span></div><div class="line">            String preNode = getNearWriteNode(childPaths, childPaths.indexOf(nodePath));</div><div class="line">            <span class="keyword">if</span> (preNode==<span class="keyword">null</span>)&#123;</div><div class="line">                countDownLatch.countDown();</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            NodeCache nodeCache=<span class="keyword">new</span> NodeCache(zkClient,preNode);</div><div class="line">            nodeCache.start();</div><div class="line">            ListenerContainer&lt;NodeCacheListener&gt; listenable = nodeCache.getListenable();</div><div class="line">            listenable.addListener(() -&gt; &#123;</div><div class="line">                <span class="comment">//节点删除事件</span></div><div class="line">                <span class="keyword">if</span> (nodeCache.getCurrentData()==<span class="keyword">null</span>)&#123;</div><div class="line">                    <span class="comment">//继续监听前一个节点</span></div><div class="line">                    String nearWriteNode = getNearWriteNode(childPaths, childPaths.indexOf(preNode));</div><div class="line">                    <span class="keyword">if</span> (nearWriteNode==<span class="keyword">null</span>)&#123;</div><div class="line">                        countDownLatch.countDown();</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line">                    tryLock(nearWriteNode);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//如果是写锁，前面无论是什么锁都不能读，直接循环监听上一个节点即可，直到前面无锁</span></div><div class="line">        <span class="keyword">if</span> (nodePath.contains(WRITE_NAME))&#123;</div><div class="line">            String preNode = childPaths.get(childPaths.indexOf(nodePath) - <span class="number">1</span>);</div><div class="line">            NodeCache nodeCache=<span class="keyword">new</span> NodeCache(zkClient,preNode);</div><div class="line">            nodeCache.start();</div><div class="line">            ListenerContainer&lt;NodeCacheListener&gt; listenable = nodeCache.getListenable();</div><div class="line">            listenable.addListener(() -&gt; &#123;</div><div class="line">                <span class="comment">//节点删除事件</span></div><div class="line">                <span class="keyword">if</span> (nodeCache.getCurrentData()==<span class="keyword">null</span>)&#123;</div><div class="line">                    <span class="comment">//继续监听前一个节点</span></div><div class="line">                    tryLock(childPaths.get(childPaths.indexOf(preNode) - <span class="number">1</span>&lt;<span class="number">0</span>?<span class="number">0</span>:childPaths.indexOf(preNode) - <span class="number">1</span>));</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 查找临近的写节点</div><div class="line">     * <span class="doctag">@param</span> childPath 全部的子节点</div><div class="line">     * <span class="doctag">@param</span> index 右边界</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> String  <span class="title">getNearWriteNode</span><span class="params">(List&lt;String&gt; childPath,Integer index)</span></span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</div><div class="line">            String node = childPath.get(i);</div><div class="line">            <span class="keyword">if</span> (node.contains(WRITE_NAME))</div><div class="line">                <span class="keyword">return</span> node;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Curator实现分步式锁"><a href="#Curator实现分步式锁" class="headerlink" title="Curator实现分步式锁"></a>Curator实现分步式锁</h2><ul>
<li>Curator是Netflix公司开源的一个Zookeeper客户端，与Zookeeper提供的原生客户端相比，Curator的抽象层次更高，简化了Zookeeper客户端的开发量。 </li>
<li>Curator在分布式锁方面已经为我们封装好了，大致实现的思路就是按照作者上述的思路实现的。中小型互联网公司还是建议直接使用框架封装好的，毕竟稳定，有些大型的互联公司都是手写的，牛逼啊。</li>
<li>创建一个排他锁很简单，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//arg1：CuratorFramework连接对象，arg2：节点路径</span></div><div class="line">lock=<span class="keyword">new</span> InterProcessMutex(client,path);</div><div class="line"><span class="comment">//获取锁</span></div><div class="line">lock.acquire();</div><div class="line"><span class="comment">//释放锁</span></div><div class="line">lock.release();</div></pre></td></tr></table></figure>
<ul>
<li><p>更多的API请参照官方文档，不是此篇文章重点。</p>
</li>
<li><p><strong>至此ZK实现分布式锁就介绍完了，如有想要源码的朋友，老规矩，回复关键词<code>分布式锁</code>获取。</strong></p>
</li>
</ul>
<h2 id="一点小福利"><a href="#一点小福利" class="headerlink" title="一点小福利"></a>一点小福利</h2><ul>
<li>对于Zookeeper不太熟悉的朋友，陈某特地花费两天时间总结了ZK的常用知识点，包括ZK常用shell命令、ZK权限控制、Curator的基本操作API。目录如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/ZK%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/5.png" alt=""></li>
<li><strong>需要上面PDF文件的朋友，老规矩，回复关键词<code>ZK总结</code>。</strong></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;真是有人(&lt;code&gt;锁&lt;/code&gt;)的地方就有江湖(&lt;code&gt;事务&lt;/code&gt;)，今天不谈江湖，来撩撩人。&lt;/li&gt;
&lt;
    
    </summary>
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper入门</title>
    <link href="http://chenjiabing666.github.io/2020/04/19/Zookeeper%E5%85%A5%E9%97%A8/"/>
    <id>http://chenjiabing666.github.io/2020/04/19/Zookeeper入门/</id>
    <published>2020-04-19T07:48:16.000Z</published>
    <updated>2020-04-19T07:48:31.119Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>Zookeeper 相信大家都听说过，最典型的使用就是作为服务注册中心。今天陈某带大家从零基础入门 Zookeeper，看了本文，你将会对 Zookeeper 有了初步的了解和认识。</li>
<li>注意：本文基于 Zookeeper 的版本是 3.4.14，最新版本的在使用上会有一些出入，但是企业现在使用的大部分都是 3.4x 版本的。</li>
</ul>
<h2 id="Zookeeper-概述"><a href="#Zookeeper-概述" class="headerlink" title="Zookeeper 概述"></a>Zookeeper 概述</h2><ul>
<li>Zookeeper 是一个分布式协调服务的开源框架。主要用来解决分布式集群中应用系统的一致性问题，例如怎样避免同时操作同一数据造成脏读的问题。</li>
<li>ZooKeeper 本质上是一个分布式的小文件存储系统。提供基于类似于文件系 统的目录树方式的数据存储，并且可以对树中的节点进行有效管理。从而用来维护和监控你存储的数据的状态变化。通过监控这些数据状态的变化，从而可以达 到基于数据的集群管理。诸如：<code>统一命名服务</code>、<code>分布式配置管理</code>、<code>分布式消息队列</code>、<code>分布式锁</code>、<code>分布式协调</code>等功能。</li>
</ul>
<h2 id="Zookeeper-特性"><a href="#Zookeeper-特性" class="headerlink" title="Zookeeper 特性"></a>Zookeeper 特性</h2><ol>
<li><p><code>全局数据一致</code>：每个 server 保存一份相同的数据副本，client 无论连 接到哪个 server，展示的数据都是一致的，这是最重要的特征；</p>
</li>
<li><p><code>可靠性</code>：如果消息被其中一台服务器接受，那么将被所有的服务器接受。</p>
</li>
<li><p><code>顺序性</code>：包括全局有序和偏序两种：全局有序是指如果在一台服务器上 消息 a 在消息 b 前发布，则在所有 Server 上消息 a 都将在消息 b 前被 发布；偏序是指如果一个消息 b 在消息 a 后被同一个发送者发布，a 必将排在 b 前面。</p>
</li>
<li><p><code>数据更新原子性</code>：一次数据更新要么成功（半数以上节点成功），要么失 败，不存在中间状态；</p>
</li>
<li><p><code>实时性</code>：Zookeeper 保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。</p>
</li>
</ol>
<h2 id="Zookeeper-节点类型"><a href="#Zookeeper-节点类型" class="headerlink" title="Zookeeper 节点类型"></a>Zookeeper 节点类型</h2><ul>
<li>Znode 有两种，分别为临时节点和永久节点。<ul>
<li><code>临时节点</code>：该节点的生命周期依赖于创建它们的会话。一旦会话结束，临时节点将被自动删除，当然可以也可以手动删除。临时节点不允许拥有子节点。</li>
<li><code>永久节点</code>：该节点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，他们才能被删除。</li>
</ul>
</li>
<li>节点的类型在创建时即被确定，并且不能改变。</li>
<li>Znode 还有一个序列化的特性，如果创建的时候指定的话，该 Znode 的名字后面会自动追加一个不断增加的序列号。序列号对于此节点的父节点来说是唯一的，这样便会记录每个子节点创建的先后顺序。它的格式为<code>&quot;%10d&quot;</code>(10 位数字,没有数值的数位用 0 补充，例如“0000000001”)。</li>
<li>这样便会存在四种类型的 Znode 节点，分类如下：<ul>
<li><code>PERSISTENT</code>：永久节点</li>
<li><code>EPHEMERAL</code>：临时节点</li>
<li><code>PERSISTENT_SEQUENTIAL</code>：永久节点、序列化</li>
<li><code>EPHEMERAL_SEQUENTIAL</code>：临时节点、序列化</li>
</ul>
</li>
</ul>
<h2 id="ZooKeeper-Watcher"><a href="#ZooKeeper-Watcher" class="headerlink" title="ZooKeeper Watcher"></a>ZooKeeper Watcher</h2><ul>
<li>ZooKeeper 提供了分布式数据发布/订阅功能，一个典型的发布/订阅模型系统定义了一种一对多的订阅关系，能让多个订阅者同时监听某一个主题对象，当这个主题对象自身状态变化时，会通知所有订阅者，使他们能够做出相应的处理。</li>
<li>触发事件种类很多，如：节点创建，节点删除，节点改变，子节点改变等。</li>
<li>总的来说可以概括 Watcher 为以下三个过程：客户端向服务端注册 Watcher、服务端事件发生触发 Watcher、客户端回调 Watcher 得到触发事件情况。</li>
</ul>
<h2 id="Watcher-机制特点"><a href="#Watcher-机制特点" class="headerlink" title="Watcher 机制特点"></a>Watcher 机制特点</h2><ul>
<li><p><code>一次性触发</code> ：事件发生触发监听，一个 watcher event 就会被发送到设置监听的客户端，这种效果是一次性的，后续再次发生同样的事件，不会再次触发。</p>
</li>
<li><p><code>事件封装</code> ：ZooKeeper 使用 WatchedEvent 对象来封装服务端事件并传递。WatchedEvent 包含了每一个事件的三个基本属性： <code>通知状态</code>（keeperState），<code>事件类型</code>（EventType）和<code>节点路径</code>（path）。</p>
</li>
<li><p><code>event 异步发送</code> ：watcher 的通知事件从服务端发送到客户端是异步的。</p>
</li>
<li><p><code>先注册再触发</code> ：Zookeeper 中的 watch 机制，必须客户端先去服务端注册监听，这样事件发送才会触发监听，通知给客户端。</p>
</li>
</ul>
<h2 id="常用-Shell-命令"><a href="#常用-Shell-命令" class="headerlink" title="常用 Shell 命令"></a>常用 Shell 命令</h2><h3 id="新增节点"><a href="#新增节点" class="headerlink" title="新增节点"></a>新增节点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">create [<span class="_">-s</span>] [<span class="_">-e</span>] path data</div></pre></td></tr></table></figure>
<ul>
<li><code>-s</code>：表示创建有序节点</li>
<li><code>-e</code>：表示创建临时节点</li>
<li>创建持久化节点：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">create /<span class="built_in">test</span> 1234</div><div class="line"></div><div class="line"><span class="comment">## 子节点</span></div><div class="line">create /<span class="built_in">test</span>/node1 node1</div></pre></td></tr></table></figure>
<ul>
<li>创建持久化有序节点：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">## 完整的节点名称是a0000000001</span></div><div class="line">create /a a</div><div class="line">Created /a0000000001</div><div class="line"></div><div class="line"><span class="comment">## 完整的节点名称是b0000000002</span></div><div class="line">create /b b</div><div class="line">Created /b0000000002</div></pre></td></tr></table></figure>
<ul>
<li>创建临时节点：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">create <span class="_">-e</span> /a a</div></pre></td></tr></table></figure>
<ul>
<li>创建临时有序节点：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">## 完整的节点名称是a0000000001</span></div><div class="line">create <span class="_">-e</span> <span class="_">-s</span> /a a</div><div class="line">Created /a0000000001</div></pre></td></tr></table></figure>
<h3 id="更新节点"><a href="#更新节点" class="headerlink" title="更新节点"></a>更新节点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span> [path] [data] [version]</div></pre></td></tr></table></figure>
<ul>
<li><code>path</code>：节点路径</li>
<li><code>data</code>：数据</li>
<li><code>version</code>：版本号</li>
<li>修改节点数据：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span> /<span class="built_in">test</span> aaa</div><div class="line"></div><div class="line"><span class="comment">## 修改子节点</span></div><div class="line"><span class="built_in">set</span> /<span class="built_in">test</span>/node1 bbb</div></pre></td></tr></table></figure>
<ul>
<li>基于数据版本号修改，如果修改的节点的版本号(<code>dataVersion</code>)不正确，拒绝修改</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span> /<span class="built_in">test</span> aaa 1</div></pre></td></tr></table></figure>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">delete [path] [version]</div></pre></td></tr></table></figure>
<ul>
<li><code>path</code>：节点路径</li>
<li><code>version</code>：版本号，版本号不正确拒绝删除</li>
<li>删除节点</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">delete /<span class="built_in">test</span></div><div class="line"></div><div class="line"><span class="comment">## 版本号删除</span></div><div class="line">delete /<span class="built_in">test</span> 2</div></pre></td></tr></table></figure>
<ul>
<li>递归删除，删除某个节点及后代</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rmr /<span class="built_in">test</span></div></pre></td></tr></table></figure>
<h3 id="查看节点数据和状态"><a href="#查看节点数据和状态" class="headerlink" title="查看节点数据和状态"></a>查看节点数据和状态</h3><ul>
<li>命令格式如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">get path</div></pre></td></tr></table></figure>
<ul>
<li>获取节点详情：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">## 获取节点详情</span></div><div class="line">get /node1</div><div class="line"></div><div class="line"><span class="comment">## 节点内容</span></div><div class="line">aaa</div><div class="line">cZxid = 0x6</div><div class="line">ctime = Sun Apr 05 14:50:10 CST 2020</div><div class="line">mZxid = 0x6</div><div class="line">mtime = Sun Apr 05 14:50:10 CST 2020</div><div class="line">pZxid = 0x7</div><div class="line">cversion = 1</div><div class="line">dataVersion = 0</div><div class="line">aclVersion = 0</div><div class="line">ephemeralOwner = 0x0</div><div class="line">dataLength = 3</div><div class="line">numChildren = 1</div></pre></td></tr></table></figure>
<ul>
<li>节点各个属性对应的含义如下：<ul>
<li><code>cZxid</code>：数据节点创建时的事务 ID。</li>
<li><code>ctime</code>：数据节点创建时间。</li>
<li><code>mZxid</code>：数据节点最后一次更新时的事务 ID。</li>
<li><code>mtime</code>：数据节点最后一次更新的时间。</li>
<li><code>pZxid</code>：数据节点的子节点最后一次被修改时的事务 ID。</li>
<li><code>cversion</code>：子节点的更改次数。</li>
<li><code>dataVersion</code>：节点数据的更改次数。</li>
<li><code>aclVersion</code>  ：节点 ACL 的更改次数。</li>
<li><code>ephemeralOwner</code>：如果节点是临时节点，则表示创建该节点的会话的 SessionID。如果节点是持久化节点，值为 0。</li>
<li><code>dataLength</code>  ：节点数据内容的长度。</li>
<li><code>numChildren</code>：数据节点当前的子节点的个数。</li>
</ul>
</li>
</ul>
<h3 id="查看节点状态"><a href="#查看节点状态" class="headerlink" title="查看节点状态"></a>查看节点状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">stat</span> path</div></pre></td></tr></table></figure>
<ul>
<li><code>stat</code>命令和<code>get</code>命令相似，不过这个命令不会返回节点的数据，只返回节点的状态属性。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">stat</span> /node1</div><div class="line"></div><div class="line"><span class="comment">## 节点状态信息，没有节点数据</span></div><div class="line">cZxid = 0x6</div><div class="line">ctime = Sun Apr 05 14:50:10 CST 2020</div><div class="line">mZxid = 0x6</div><div class="line">mtime = Sun Apr 05 14:50:10 CST 2020</div><div class="line">pZxid = 0x7</div><div class="line">cversion = 1</div><div class="line">dataVersion = 0</div><div class="line">aclVersion = 0</div><div class="line">ephemeralOwner = 0x0</div><div class="line">dataLength = 3</div><div class="line">numChildren = 1</div></pre></td></tr></table></figure>
<h3 id="查看节点列表"><a href="#查看节点列表" class="headerlink" title="查看节点列表"></a>查看节点列表</h3><ul>
<li>查看节点列表有<code>ls path</code>和<code>ls2 path</code>两个命令。后者是前者的增强，不仅会返回节点列表还会返回当前节点的状态信息。</li>
<li><code>ls path</code>：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ls /</div><div class="line"></div><div class="line"><span class="comment">## 仅仅返回节点列表</span></div><div class="line">[zookeeper, node1]</div></pre></td></tr></table></figure>
<ul>
<li><code>ls2 path</code>：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ls2 /</div><div class="line"></div><div class="line"><span class="comment">## 返回节点列表和当前节点的状态信息</span></div><div class="line">[zookeeper, node1]</div><div class="line">cZxid = 0x0</div><div class="line">ctime = Thu Jan 01 08:00:00 CST 1970</div><div class="line">mZxid = 0x0</div><div class="line">mtime = Thu Jan 01 08:00:00 CST 1970</div><div class="line">pZxid = 0x6</div><div class="line">cversion = 2</div><div class="line">dataVersion = 0</div><div class="line">aclVersion = 0</div><div class="line">ephemeralOwner = 0x0</div><div class="line">dataLength = 0</div><div class="line">numChildren = 2</div></pre></td></tr></table></figure>
<h3 id="监听器-get-path-watch"><a href="#监听器-get-path-watch" class="headerlink" title="监听器 get path watch"></a>监听器 get path watch</h3><ul>
<li>使用<code>get path watch</code>注册的监听器在<code>节点内容</code>发生改变时，向客户端发送通知，注意 Zookeeper 的触发器是一次性的，触发一次后会立即生效。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">get /node1 watch</div><div class="line"></div><div class="line"><span class="comment">## 改变节点数据</span></div><div class="line"><span class="built_in">set</span> /node1 bbb</div><div class="line"></div><div class="line"><span class="comment">## 监听到节点内容改变了</span></div><div class="line">WATCHER::</div><div class="line">WatchedEvent state:SyncConnected <span class="built_in">type</span>:NodeDataChanged path:/node1</div></pre></td></tr></table></figure>
<h3 id="监听器-stat-path-watch"><a href="#监听器-stat-path-watch" class="headerlink" title="监听器 stat path watch"></a>监听器 stat path watch</h3><ul>
<li><code>stat path watch</code>注册的监听器能够在<code>节点状态</code>发生改变时向客户端发出通知。比如节点数据改变、节点被删除等。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">stat</span> /node2 watch</div><div class="line"></div><div class="line"><span class="comment">## 删除节点node2</span></div><div class="line">delete /node2</div><div class="line"></div><div class="line"><span class="comment">## 监听器监听到了节点删除</span></div><div class="line">WATCHER::</div><div class="line">WatchedEvent state:SyncConnected <span class="built_in">type</span>:NodeDeleted path:/node2</div></pre></td></tr></table></figure>
<h3 id="监听器-ls-ls2-path-watch"><a href="#监听器-ls-ls2-path-watch" class="headerlink" title="监听器 ls/ls2 path watch"></a>监听器 ls/ls2 path watch</h3><ul>
<li>使用<code>ls path watch</code>或者<code>ls2 path watch</code>注册的监听器，能够监听到该节点下的子节点的<code>增加</code>和<code>删除</code>操作。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ls /node1 watch</div><div class="line"></div><div class="line"><span class="comment">## 创建子节点</span></div><div class="line">create /node1/b b</div><div class="line"></div><div class="line"><span class="comment">## 监听到了子节点的新增</span></div><div class="line">WATCHER::</div><div class="line">WatchedEvent state:SyncConnected <span class="built_in">type</span>:NodeChildrenChanged path:/node1</div></pre></td></tr></table></figure>
<h2 id="Zookeeper-的-ACL-权限控制"><a href="#Zookeeper-的-ACL-权限控制" class="headerlink" title="Zookeeper 的 ACL 权限控制"></a>Zookeeper 的 ACL 权限控制</h2><ul>
<li>zookeeper 类似文件控制系统，client 可以创建，删除，修改，查看节点，那么如何做到权限控制的呢？zookeeper 的<code>access control list</code> 访问控制列表可以做到这一点。</li>
<li>ACL 权限控制，使用<code>scheme:id:permission</code>来标识。<ul>
<li><code>权限模式(scheme)</code>：授权的策略</li>
<li><code>授权对象(id)</code>：授权的对象</li>
<li><code>权限(permission)</code>：授予的权限</li>
</ul>
</li>
<li>权限控制是基于每个节点的，需要对每个节点设置权限。</li>
<li>每个节点支持设置多种权限控制方案和多个权限。</li>
<li>子节点不会继承父节点的权限，客户端无权访问某节点，但可能可以访问它的子节点。</li>
<li>例如：根据 IP 地址进行授权，命令如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span>ACl /node1 ip:192.168.10.1:crdwa</div></pre></td></tr></table></figure>
<h3 id="权限模式"><a href="#权限模式" class="headerlink" title="权限模式"></a>权限模式</h3><ul>
<li>权限模式即是采用何种方式授权。</li>
<li><code>world</code>：只有一个用户，anyone，表示登录 zookeeper 所有人（默认的模式）。</li>
<li><code>ip</code>：对客户端使用 IP 地址认证。</li>
<li><code>auth</code>：使用已添加认证的用户认证。</li>
<li><code>digest</code>：使用<code>用户名:密码</code>方式认证。</li>
</ul>
<h3 id="授权对象"><a href="#授权对象" class="headerlink" title="授权对象"></a>授权对象</h3><ul>
<li>给谁授权，授权对象的 ID 指的是权限赋予的实体，例如 IP 地址或用户。</li>
</ul>
<h3 id="授予的权限"><a href="#授予的权限" class="headerlink" title="授予的权限"></a>授予的权限</h3><ul>
<li>授予的权限包括<code>create</code>、<code>delete</code>、<code>read</code>、<code>writer</code>、<code>admin</code>。也就是增、删、改、查、管理的权限，简写<code>cdrwa</code>。</li>
<li><strong>注意</strong>：以上 5 种权限中，<code>delete</code>是指对子节点的删除权限，其他 4 种权限是对自身节点的操作权限。</li>
<li><code>create</code>：简写<code>c</code>，可以创建子节点。</li>
<li><code>delete</code>：简写<code>d</code>，可以删除子节点（仅下一级节点）。</li>
<li><code>read</code>：简写<code>r</code>，可以读取节点数据以及显示子节点列表。</li>
<li><code>write</code>：简写<code>w</code>，可以更改节点数据。</li>
<li><code>admin</code>：简写<code>a</code>，可以设置节点访问控制列表权限。</li>
</ul>
<h3 id="授权相关命令"><a href="#授权相关命令" class="headerlink" title="授权相关命令"></a>授权相关命令</h3><ul>
<li><code>getAcl [path]</code>：读取指定节点的 ACL 权限。</li>
<li><code>setAcl [path] [acl]</code>：设置 ACL</li>
<li><code>addauth &lt;scheme&gt; &lt;auth&gt;</code>：添加认证用户，和 auth，digest 授权模式相关。</li>
</ul>
<h3 id="world-授权模式案例"><a href="#world-授权模式案例" class="headerlink" title="world 授权模式案例"></a>world 授权模式案例</h3><ul>
<li>zookeeper 中默认的授权模式，针对登录 zookeeper 的任何用户授予指定的权限。命令如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span>Acl [path] world:anyone:[permission]</div></pre></td></tr></table></figure>
<ul>
<li><code>path</code>：节点</li>
<li><code>permission</code>：授予的权限，比如<code>cdrwa</code></li>
<li>去掉不能读取节点数据的权限：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">## 获取权限列表（默认的）</span></div><div class="line">getAcl /node2</div><div class="line"></div><div class="line"><span class="string">'world,'</span>anyone</div><div class="line">: cdrwa</div><div class="line"></div><div class="line"><span class="comment">## 去掉读取节点数据的的权限，去掉r</span></div><div class="line"><span class="built_in">set</span>Acl /node2 world:anyone:cdwa</div><div class="line"></div><div class="line"><span class="comment">## 再次获取权限列表</span></div><div class="line">getAcl /node2</div><div class="line"></div><div class="line"><span class="string">'world,'</span>anyone</div><div class="line">: cdwa</div><div class="line"></div><div class="line"><span class="comment">## 获取节点数据，没有权限，失败</span></div><div class="line">get /node2</div><div class="line"></div><div class="line">Authentication is not valid : /node2</div></pre></td></tr></table></figure>
<h3 id="IP-授权模式案例"><a href="#IP-授权模式案例" class="headerlink" title="IP 授权模式案例"></a>IP 授权模式案例</h3><ul>
<li>针对登录用户的 ip 进行限制权限。命令如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span>Acl [path] ip:[ip]:[acl]</div></pre></td></tr></table></figure>
<ul>
<li>远程登录 zookeeper 的命令如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./zkCli.sh -server ip</div></pre></td></tr></table></figure>
<ul>
<li>设置<code>192.168.10.1</code>这个 ip 的增删改查管理的权限。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span>Acl /node2 ip:192.168.10.1:crdwa</div></pre></td></tr></table></figure>
<h3 id="Auth-授权模式案例"><a href="#Auth-授权模式案例" class="headerlink" title="Auth 授权模式案例"></a>Auth 授权模式案例</h3><ul>
<li>auth 授权模式需要有一个认证用户，添加命令如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">addauth digest [username]:[password]</div></pre></td></tr></table></figure>
<ul>
<li>设置 auth 授权模式命令如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span>Acl [path] auth:[user]:[acl]</div></pre></td></tr></table></figure>
<ul>
<li>为<code>chenmou</code>这个账户添加 cdrwa 权限：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">## 添加一个认证账户</span></div><div class="line">addauth digest chenmou:123456</div><div class="line"></div><div class="line"><span class="comment">## 添加权限</span></div><div class="line"><span class="built_in">set</span>Acl /node2 auth:chenmou:crdwa</div></pre></td></tr></table></figure>
<h3 id="多种模式授权"><a href="#多种模式授权" class="headerlink" title="多种模式授权"></a>多种模式授权</h3><ul>
<li>zookeeper 中同一个节点可以使用多种授权模式，多种授权模式用<code>,</code>分隔。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">## 创建节点</span></div><div class="line">create /node3</div><div class="line"></div><div class="line"><span class="comment">## 添加认证用户</span></div><div class="line">addauth chenmou:123456</div><div class="line"></div><div class="line"><span class="comment">## 添加多种授权模式</span></div><div class="line"><span class="built_in">set</span>Acl /node3 ip:192.178.10.1:crdwa,auth:chenmou:crdwa</div></pre></td></tr></table></figure>
<h3 id="ACL-超级管理员"><a href="#ACL-超级管理员" class="headerlink" title="ACL 超级管理员"></a>ACL 超级管理员</h3><ul>
<li>zookeeper 的权限管理模式有一种叫做<code>super</code>，该模式提供一个超管可以方便的访问任何权限的节点。</li>
<li>假设这个超管是<code>super:admin</code>，需要先为超管生成密码的密文：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> -n super:admin | openssl dgst  -binary -sha1 |openssl base64</div><div class="line"></div><div class="line"><span class="comment">## 执行完生成了秘钥</span></div><div class="line">xQJmxLMiHGwaqBvst5y6rkB6HQs=</div></pre></td></tr></table></figure>
<ul>
<li>打开<code>zookeeper</code>目录下<code>/bin/zkServer.sh</code>，找到如下一行：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nohup JAVA&amp;quot;−Dzookeeper.log.dir=JAVA<span class="string">"−Dzookeeper.log.dir=&#123;ZOO_LOG_DIR&#125;"</span> <span class="string">"-Dzookeeper.root.logger=<span class="variable">$&#123;ZOO_LOG4J_PROP&#125;</span>"</span></div></pre></td></tr></table></figure>
<ul>
<li>在后面添加一行脚本，如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"-Dzookeeper.DigestAuthenticationProvider.superDigest=super:xQJmxLMiHGwaqBvst5y6rkB6HQs="</span></div></pre></td></tr></table></figure>
<ul>
<li>此时完整的脚本如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nohup <span class="string">"<span class="variable">$JAVA</span>"</span> <span class="string">"-Dzookeeper.log.dir=<span class="variable">$&#123;ZOO_LOG_DIR&#125;</span>"</span> <span class="string">"-Dzookeeper.root.logger=<span class="variable">$&#123;ZOO_LOG4J_PROP&#125;</span>"</span> <span class="string">"-Dzookeeper.DigestAuthenticationProvider.superDigest=super:xQJmxLMiHGwaqBvst5y6rkB6HQs="</span> \</div><div class="line">    -cp <span class="string">"<span class="variable">$CLASSPATH</span>"</span> <span class="variable">$JVMFLAGS</span> <span class="variable">$ZOOMAIN</span> <span class="string">"<span class="variable">$ZOOCFG</span>"</span> &gt; <span class="string">"<span class="variable">$_ZOO_DAEMON_OUT</span>"</span> 2&gt;&amp;1 &lt; /dev/null &amp;</div></pre></td></tr></table></figure>
<ul>
<li>重启 zookeeper</li>
<li>重启完成之后此时超管即配置完成，如果需要使用，则使用如下命令：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">addauth digest super:admin</div></pre></td></tr></table></figure>
<h2 id="Curator-客户端"><a href="#Curator-客户端" class="headerlink" title="Curator 客户端"></a>Curator 客户端</h2><ul>
<li>Curator 是 Netflix 公司开源的一个 Zookeeper 客户端，与 Zookeeper 提供的原生客户端相比，Curator 的抽象层次更高，简化了 Zookeeper 客户端的开发量。</li>
</ul>
<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></div><div class="line">                   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">                   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">               <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></div><div class="line">           <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><ul>
<li>客户端建立与 Zookeeper 的连接，这里仅仅演示单机版本的连接，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建CuratorFramework，用来操作api</span></div><div class="line">CuratorFramework  client = CuratorFrameworkFactory.builder()</div><div class="line">    <span class="comment">//ip地址+端口号，如果是集群，逗号分隔</span></div><div class="line">    .connectString(<span class="string">"120.26.101.207:2181"</span>)</div><div class="line">    <span class="comment">//会话超时时间</span></div><div class="line">    .sessionTimeoutMs(<span class="number">5000</span>)</div><div class="line">    <span class="comment">//超时重试策略,RetryOneTime：超时重连仅仅一次</span></div><div class="line">    .retryPolicy(<span class="keyword">new</span> RetryOneTime(<span class="number">3000</span>))</div><div class="line">    <span class="comment">//命名空间，父节点，如果不指定是在根节点下</span></div><div class="line">    .namespace(<span class="string">"node4"</span>)</div><div class="line">    .build();</div><div class="line"><span class="comment">//启动</span></div><div class="line">client.start();</div></pre></td></tr></table></figure>
<h3 id="重连策略"><a href="#重连策略" class="headerlink" title="重连策略"></a>重连策略</h3><ul>
<li>会话连接策略，即是当客户端与 Zookeeper 断开连接之后，客户端重新连接 Zookeeper 时使用的策略，比如重新连接一次。</li>
<li><code>RetryOneTime：</code>N 秒后重连一次，仅仅一次，演示如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.retryPolicy(<span class="keyword">new</span> RetryOneTime(<span class="number">3000</span>))</div></pre></td></tr></table></figure>
<ul>
<li><code>RetryNTimes</code>：每 n 秒重连一次，重连 m 次。演示如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//每三秒重连一次，重连3次。arg1：多长时间后重连，单位毫秒，arg2：总共重连几次</span></div><div class="line">.retryPolicy(<span class="keyword">new</span> RetryNTimes(<span class="number">3000</span>,<span class="number">3</span>))</div></pre></td></tr></table></figure>
<ul>
<li><code>RetryUntilElapsed</code>：设置了最大等待时间，如果超过这个最大等待时间将会不再连接。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//每三秒重连一次，等待时间超过10秒不再重连。arg1：总等待时间，arg2：多长时间重连，单位毫秒</span></div><div class="line">.retryPolicy(<span class="keyword">new</span> RetryUntilElapsed(<span class="number">10000</span>,<span class="number">3000</span>))</div></pre></td></tr></table></figure>
<h3 id="新增节点-1"><a href="#新增节点-1" class="headerlink" title="新增节点"></a>新增节点</h3><ul>
<li>新增节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">client.create()</div><div class="line">    <span class="comment">//指定节点的类型。PERSISTENT：持久化节点，PERSISTENT_SEQUENTIAL：持久化有序节点，EPHEMERAL：临时节点，EPHEMERAL_SEQUENTIAL临时有序节点</span></div><div class="line">    .withMode(CreateMode.PERSISTENT)</div><div class="line">    <span class="comment">//指定权限列表，OPEN_ACL_UNSAFE：world:anyone:crdwa</span></div><div class="line">    .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)</div><div class="line">    <span class="comment">//写入节点数据，arg1:节点名称 arg2:节点数据</span></div><div class="line">    .forPath(<span class="string">"/a"</span>, <span class="string">"a"</span>.getBytes());</div></pre></td></tr></table></figure>
<ul>
<li>自定义权限列表：<code>withACL(acls)</code>方法中可以设置自定义的权限列表，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//自定义权限列表</span></div><div class="line">List&lt;ACL&gt; acls=<span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="comment">//指定授权模式和授权对象 arg1:授权模式，arg2授权对象</span></div><div class="line">Id id=<span class="keyword">new</span> Id(<span class="string">"ip"</span>,<span class="string">"127.0.0.1"</span>);</div><div class="line"><span class="comment">//指定授予的权限，ZooDefs.Perms.ALL:crdwa</span></div><div class="line">acls.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.ALL,id));</div><div class="line">client.create()</div><div class="line">    .withMode(CreateMode.PERSISTENT)</div><div class="line">    <span class="comment">//指定自定义权限列表</span></div><div class="line">    .withACL(acls)</div><div class="line">    .forPath(<span class="string">"/b"</span>, <span class="string">"b"</span>.getBytes());</div></pre></td></tr></table></figure>
<ul>
<li>递归创建节点：<code>creatingParentsIfNeeded()</code>方法对于创建多层节点，如果其中一个节点不存在的话会自动创建</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//递归创建节点</span></div><div class="line">client.create()</div><div class="line">    <span class="comment">//递归方法，如果节点不存在，那么创建该节点</span></div><div class="line">    .creatingParentsIfNeeded()</div><div class="line">    .withMode(CreateMode.PERSISTENT)</div><div class="line">    .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)</div><div class="line">    <span class="comment">//test节点和b节点不存在，递归创建出来</span></div><div class="line">    .forPath(<span class="string">"/test/a"</span>, <span class="string">"a"</span>.getBytes());</div></pre></td></tr></table></figure>
<ul>
<li>异步创建节点：<code>inBackground()</code>方法可以异步回调创建节点，创建完成后会自动回调实现的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//异步创建节点</span></div><div class="line">client.create()</div><div class="line">    .withMode(CreateMode.PERSISTENT)</div><div class="line">    .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)</div><div class="line">    <span class="comment">//异步创建</span></div><div class="line">    .inBackground(<span class="keyword">new</span> BackgroundCallback() &#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">        * <span class="doctag">@param</span> curatorFramework 客户端对象</div><div class="line">        * <span class="doctag">@param</span> curatorEvent 事件对象</div><div class="line">        */</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(CuratorFramework curatorFramework, CuratorEvent curatorEvent)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            <span class="comment">//打印事件类型</span></div><div class="line">            System.out.println(curatorEvent.getType());</div><div class="line">            &#125;</div><div class="line">    &#125;)</div><div class="line">    .forPath(<span class="string">"/test1"</span>, <span class="string">"a"</span>.getBytes());</div></pre></td></tr></table></figure>
<h3 id="更新节点数据"><a href="#更新节点数据" class="headerlink" title="更新节点数据"></a>更新节点数据</h3><ul>
<li>更新节点，当节点不存在会报错，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">client.setData()</div><div class="line">      .forPath(<span class="string">"/a"</span>,<span class="string">"a"</span>.getBytes());</div></pre></td></tr></table></figure>
<ul>
<li>携带版本号更新节点，当版本错误拒绝更新</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">client.setData()</div><div class="line">    <span class="comment">//指定版本号更新，如果版本号错误则拒绝更新</span></div><div class="line">    .withVersion(<span class="number">1</span>)</div><div class="line">    .forPath(<span class="string">"/a"</span>,<span class="string">"a"</span>.getBytes());</div></pre></td></tr></table></figure>
<ul>
<li>异步更新节点数据：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">client.setData()</div><div class="line">        <span class="comment">//异步更新</span></div><div class="line">        .inBackground(<span class="keyword">new</span> BackgroundCallback() &#123;</div><div class="line">        <span class="comment">//回调方法</span></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(CuratorFramework curatorFramework, CuratorEvent curatorEvent)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                   &#125;</div><div class="line">        &#125;)</div><div class="line">		.forPath(<span class="string">"/a"</span>,<span class="string">"a"</span>.getBytes());</div></pre></td></tr></table></figure>
<h3 id="删除节点-1"><a href="#删除节点-1" class="headerlink" title="删除节点"></a>删除节点</h3><ul>
<li>删除当前节点，如果有子节点则拒绝删除</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">client.delete()</div><div class="line">    <span class="comment">//删除节点，如果是该节点包含子节点，那么不能删除</span></div><div class="line">    .forPath(<span class="string">"/a"</span>);</div></pre></td></tr></table></figure>
<ul>
<li>指定版本号删除，如果版本错误则拒绝删除</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">client.delete()</div><div class="line">    <span class="comment">//指定版本号删除</span></div><div class="line">    .withVersion(<span class="number">1</span>)</div><div class="line">    <span class="comment">//删除节点，如果是该节点包含子节点，那么不能删除</span></div><div class="line">    .forPath(<span class="string">"/a"</span>);</div></pre></td></tr></table></figure>
<ul>
<li>如果当前节点包含子节点则一并删除，使用<code>deletingChildrenIfNeeded()</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">client.delete()</div><div class="line">    <span class="comment">//如果删除的节点包含子节点则一起删除</span></div><div class="line">    .deletingChildrenIfNeeded()</div><div class="line">    <span class="comment">//删除节点，如果是该节点包含子节点，那么不能删除</span></div><div class="line">    .forPath(<span class="string">"/a"</span>);</div></pre></td></tr></table></figure>
<ul>
<li>异步删除节点，使用<code>inBackground()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">client.delete()</div><div class="line">	.deletingChildrenIfNeeded()</div><div class="line">	<span class="comment">//异步删除节点</span></div><div class="line">    .inBackground(<span class="keyword">new</span> BackgroundCallback() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(CuratorFramework curatorFramework, CuratorEvent curatorEvent)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//回调监听</span></div><div class="line">        &#125;</div><div class="line">       &#125;)</div><div class="line">    <span class="comment">//删除节点，如果是该节点包含子节点，那么不能删除</span></div><div class="line">    .forPath(<span class="string">"/a"</span>);</div></pre></td></tr></table></figure>
<h3 id="获取节点数据"><a href="#获取节点数据" class="headerlink" title="获取节点数据"></a>获取节点数据</h3><ul>
<li>同步获取节点数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">byte</span>[] bytes = client.getData().forPath(<span class="string">"/node1"</span>);</div><div class="line">System.out.println(<span class="keyword">new</span> String(bytes));</div></pre></td></tr></table></figure>
<ul>
<li>获取节点状态和数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//保存节点状态</span></div><div class="line">Stat stat=<span class="keyword">new</span> Stat();</div><div class="line"><span class="keyword">byte</span>[] bytes = client.getData()</div><div class="line">	<span class="comment">//获取节点状态存储在stat对象中</span></div><div class="line">    .storingStatIn(stat)</div><div class="line">    .forPath(<span class="string">"/node1"</span>);</div><div class="line">System.out.println(<span class="keyword">new</span> String(bytes));</div><div class="line"><span class="comment">//获取节点数据的长度</span></div><div class="line">System.out.println(stat.getDataLength());</div></pre></td></tr></table></figure>
<ul>
<li>异步获取节点数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">client.getData()</div><div class="line">    <span class="comment">//异步获取节点数据，回调监听</span></div><div class="line">     .inBackground((curatorFramework, curatorEvent) -&gt; &#123;</div><div class="line">          <span class="comment">//节点数据</span></div><div class="line">          System.out.println(<span class="keyword">new</span> String(curatorEvent.getData()));</div><div class="line">      &#125;)</div><div class="line">     .forPath(<span class="string">"/node1"</span>);</div></pre></td></tr></table></figure>
<h3 id="获取子节点"><a href="#获取子节点" class="headerlink" title="获取子节点"></a>获取子节点</h3><ul>
<li>同步获取全部子节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; strs = client.getChildren().forPath(<span class="string">"/"</span>);</div><div class="line">       <span class="keyword">for</span> (String str:strs) &#123;</div><div class="line">           System.out.println(str);</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<ul>
<li>异步获取全部子节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">client.getChildren()</div><div class="line"><span class="comment">//异步获取</span></div><div class="line">.inBackground((curatorFramework, curatorEvent) -&gt; &#123;</div><div class="line">        List&lt;String&gt; strs = curatorEvent.getChildren();</div><div class="line">        <span class="keyword">for</span> (String str:strs) &#123;</div><div class="line">              System.out.println(str);</div><div class="line">        &#125;</div><div class="line">  &#125;)</div><div class="line">.forPath(<span class="string">"/"</span>);</div></pre></td></tr></table></figure>
<h3 id="查看节点是否存在"><a href="#查看节点是否存在" class="headerlink" title="查看节点是否存在"></a>查看节点是否存在</h3><ul>
<li>同步查看</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果节点不存在，stat为null</span></div><div class="line">Stat stat = client.checkExists().forPath(<span class="string">"/node"</span>);</div></pre></td></tr></table></figure>
<ul>
<li>异步查看</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果节点不存在，stat为null</span></div><div class="line">client.checkExists()</div><div class="line">    .inBackground((curatorFramework, curatorEvent) -&gt; &#123;</div><div class="line">    <span class="comment">//如果为null则不存在</span></div><div class="line">    System.out.println(curatorEvent.getStat());</div><div class="line">    &#125;)</div><div class="line">    .forPath(<span class="string">"/node"</span>);</div></pre></td></tr></table></figure>
<h3 id="Watcher-API"><a href="#Watcher-API" class="headerlink" title="Watcher API"></a>Watcher API</h3><ul>
<li>curator 提供了两种 watcher 来监听节点的变化<ul>
<li><code>NodeCache</code>：监听一个特定的节点，监听新增和修改</li>
<li><code>PathChildrenCache</code>：监听一个节点的子节点，当一个子节点增加、删除、更新时，path Cache 会改变他的状态，会包含最新的子节点的数据和状态。</li>
</ul>
</li>
<li>NodeCache 演示：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//arg1:连接对象 arg2:监听的节点路径,/namespace/path</span></div><div class="line"><span class="keyword">final</span> NodeCache nodeCache = <span class="keyword">new</span> NodeCache(client, <span class="string">"/w1"</span>);</div><div class="line"><span class="comment">//启动监听</span></div><div class="line">nodeCache.start();</div><div class="line"><span class="comment">//添加监听器</span></div><div class="line">nodeCache.getListenable().addListener(() -&gt; &#123;</div><div class="line">    <span class="comment">//节点路径</span></div><div class="line">    System.out.println(nodeCache.getCurrentData().getPath());</div><div class="line">    <span class="comment">//节点数据</span></div><div class="line">    System.out.println(<span class="keyword">new</span> String(nodeCache.getCurrentData().getData()));</div><div class="line">&#125;);</div><div class="line"><span class="comment">//睡眠100秒</span></div><div class="line">Thread.sleep(<span class="number">1000000</span>);</div><div class="line"><span class="comment">//关闭监听</span></div><div class="line">nodeCache.close();</div></pre></td></tr></table></figure>
<ul>
<li><code>PathChildrenCache</code>演示：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//arg1：连接对象 arg2：节点路径  arg3:是否能够获取节点数据</span></div><div class="line">PathChildrenCache cache=<span class="keyword">new</span> PathChildrenCache(client,<span class="string">"/w1"</span>, <span class="keyword">true</span>);</div><div class="line">cache.start();</div><div class="line">cache.getListenable().addListener((curatorFramework, pathChildrenCacheEvent) -&gt; &#123;</div><div class="line">	<span class="comment">//节点路径</span></div><div class="line">	System.out.println(pathChildrenCacheEvent.getData().getPath());</div><div class="line">	<span class="comment">//节点状态</span></div><div class="line">	System.out.println(pathChildrenCacheEvent.getData().getStat());</div><div class="line">	<span class="comment">//节点数据</span></div><div class="line">	System.out.println(<span class="keyword">new</span> String(pathChildrenCacheEvent.getData().getData()));</div><div class="line">&#125;);</div><div class="line">cache.close();</div></pre></td></tr></table></figure>
<h2 id="小福利"><a href="#小福利" class="headerlink" title="小福利"></a>小福利</h2><ul>
<li>是不是觉得文章太长看得头晕脑胀，为此陈某特地将本篇文章制作成 PDF 文本，需要回去仔细研究的朋友，老规矩，回复关键词<code>ZK入门指南</code>。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Zookeeper 相信大家都听说过，最典型的使用就是作为服务注册中心。今天陈某带大家从零基础入门 Zookeeper，看了本文
    
    </summary>
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Mysql中orderby底层执行流程</title>
    <link href="http://chenjiabing666.github.io/2020/04/19/Mysql%E4%B8%ADorderby%E5%BA%95%E5%B1%82%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    <id>http://chenjiabing666.github.io/2020/04/19/Mysql中orderby底层执行流程/</id>
    <published>2020-04-19T07:46:13.000Z</published>
    <updated>2020-04-19T07:46:41.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>在实际的开发中一定会碰到根据某个字段进行排序后来显示结果的需求，但是你真的理解<code>order by</code>在 Mysql 底层是如何执行的吗？</li>
<li>假设你要查询城市是<code>苏州</code>的所有人名字，并且按照姓名进行排序返回前 1000 个人的姓名、年龄，这条 sql 语句应该如何写？</li>
<li>首先创建一张用户表，sql 语句如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> (</div><div class="line">  <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  city <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  age <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</div><div class="line">  <span class="keyword">KEY</span> city (city)</div><div class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</div></pre></td></tr></table></figure>
<ul>
<li>则上述需求的 sql 查询语句如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> city,<span class="keyword">name</span>,age <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> city=<span class="string">'苏州'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">1000</span>;</div></pre></td></tr></table></figure>
<ul>
<li>这条 sql 查询语句相信大家都能写出来，但是你了解它在 Mysql 底层的执行流程吗？今天陈某来大家聊一聊这条 sql 语句是如何执行的以及有什么参数会影响执行的流程。</li>
<li>本篇文章分为如下几个部分进行详细的阐述：<ol>
<li><strong>全字段排序</strong></li>
<li><strong>rowid 排序</strong></li>
<li><strong>全字段排序 VS rowid 排序</strong></li>
<li><strong>如何避免排序</strong></li>
</ol>
</li>
</ul>
<h2 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h2><ul>
<li>前面聊过索引能够避免全表扫描，因此我们给<code>city</code>这个字段上添加了索引，当然城市的字段很小，不用考虑字符串的索引问题，之前有写过一篇关于如何给字符串的加索引的文章，有不了解朋友看一下这篇文章:<a href="https://mp.weixin.qq.com/s/xaa8ge7LsHWYROOy4qiRJA" target="_blank" rel="external">Mysql 性能优化：如何给字符串加索引？</a></li>
<li>此时用<code>Explain</code>来分析一下的这条查询语句的执行情况，结果如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/1.png" alt="Explain分析结果"></li>
<li><code>Extra</code>这个字段中的<code>Using filesort</code>表示的就是需要排序，MySQL 会给每个线程分配一块内存用于排序，称为<code>sort_buffer</code>。</li>
<li>既然使用了索引进行查询，我们来简单的画一下<code>city</code>这棵索引树的结构，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/2-1.png" alt="city索引树"></li>
<li>从上图可以看出，满足<code>city=&#39;苏州&#39;</code>是从<code>ID3</code>到<code>IDX</code>这些记录。</li>
<li>通常情况下，此条 sql 语句执行流程如下：<ol>
<li>初始化 sort_buffer，确定放入 name、city、age 这三个字段。</li>
<li>从索引 city 找到第一个满足<code>city=&#39;苏州&#39;</code>条件的<code>主键id</code>，也就是图中的<code>ID3</code>。</li>
<li>到<code>主键id索引</code>取出整行，取<code>name</code>、<code>city</code>、<code>age</code>三个字段的值，存入<code>sort_buffer</code>中。</li>
<li>从索引<code>city</code>取下一个记录的主键 id。</li>
<li>重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的<code>IDX</code>。</li>
<li>对<code>sort_buffer</code>中的数据按照字段<code>name</code>做快速排序。</li>
<li>按照排序结果取前 1000 行返回给客户端。</li>
</ol>
</li>
<li>我们称这个排序过程为<code>全字段排序</code>，执行的流程图如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/3.png" alt="全字段排序"></li>
<li>图中<code>按name排序</code>这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数<code>sort_buffer_size</code>。</li>
<li><code>sort_buffer_size</code>：就是 MySQL 为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用<code>磁盘临时文件</code>辅助排序。</li>
</ul>
<h2 id="rowid-排序"><a href="#rowid-排序" class="headerlink" title="rowid 排序"></a>rowid 排序</h2><ul>
<li>在上面这个算法过程里面，只对原表的数据读了一遍，剩下的操作都是在<code>sort_buffer</code>和<code>临时文件</code>中执行的。<strong>但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么<code>sort_buffer</code>里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差</strong>。</li>
<li>所以如果单行很大，这个方法效率不够好。</li>
<li>我们可以修改一个<code>max_length_for_sort_data</code>这个参数使其使用另外一种算法。max_length_for_sort_data，是 MySQL 中专门控制用于排序的行数据的长度的一个参数。它的意思是，如果单行的长度超过这个值，MySQL 就认为单行太大，要换一个算法。</li>
<li><code>city</code>、<code>name</code>、<code>age</code> 这三个字段的定义总长度是<code>36</code>，我把<code>max_length_for_sort_data</code>设置为 16，我们再来看看计算过程有什么改变。设置的 sql 语句如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SET</span> max_length_for_sort_data = <span class="number">16</span>;</div></pre></td></tr></table></figure>
<ul>
<li><p>新的算法放入 sort_buffer 的字段，只有要排序的列（即 name 字段）和主键 id。</p>
</li>
<li><p>但这时，排序的结果就因为少了 city 和 age 字段的值，不能直接返回了，整个执行流程就变成如下所示的样子：</p>
<ol>
<li>初始化<code>sort_buffer</code>，确定放入两个字段，即<code>name</code>和<code>id</code>。</li>
<li>从索引 city 找到第一个满足<code>city=&#39;苏州&#39;</code>条件的<code>主键id</code>，也就是图中的<code>ID3</code>。</li>
<li>到<code>主键id索引</code>取出整行，取 name、id 这两个字段，存入 sort_buffer 中。</li>
<li>从索引<code>city</code>取下一个记录的主键 id。</li>
<li>重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的<code>IDX</code>。</li>
<li>对<code>sort_buffer</code>中的数据按照字段<code>name</code>做快速排序。</li>
<li>遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端。</li>
</ol>
</li>
<li>这个执行流程的示意图如下，我把它称为<code>rowid排序</code>。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/4.png" alt="rowid排序"></li>
<li><strong>对比<code>全字段排序</code>，<code>rowid排序</code>多了一次<code>回表查询</code>，即是多了<code>第7步</code>的查询主键索引树。</strong></li>
</ul>
<h2 id="全字段排序-VS-rowid-排序"><a href="#全字段排序-VS-rowid-排序" class="headerlink" title="全字段排序 VS rowid 排序"></a>全字段排序 VS rowid 排序</h2><ul>
<li>如果 MySQL 实在是担心排序内存太小，会影响排序效率，才会采用 rowid 排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。</li>
<li>如果 MySQL 认为内存足够大，会优先选择全字段排序，把需要的字段都放到 sort_buffer 中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。</li>
<li>这也就体现了 MySQL 的一个设计思想：<strong>如果内存够，就要多利用内存，尽量减少磁盘访问</strong>。</li>
<li><strong>对于 InnoDB 表来说，rowid 排序会要求回表多造成磁盘读，因此不会被优先选择。</strong></li>
</ul>
<h2 id="如何避免排序"><a href="#如何避免排序" class="headerlink" title="如何避免排序"></a>如何避免排序</h2><ul>
<li>其实，并不是所有的<code>order by</code>语句，都需要排序操作的。从上面分析的执行过程，我们可以看到，MySQL 之所以需要生成临时表，并且在临时表上做排序操作，其原因是<strong>原来的数据都是无序的</strong>。</li>
<li>如果能够保证从<code>city</code>这个索引上取出来的行，天然就是按照 name 递增排序的话，是不是就可以不用再排序了呢？</li>
<li>因此想到了联合索引，创建<code>(city,name)</code>联合索引，sql 语句如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">user</span> <span class="keyword">add</span> <span class="keyword">index</span> city_user(city, <span class="keyword">name</span>);</div></pre></td></tr></table></figure>
<ul>
<li>此时的索引树如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/5-1.png" alt="city,name索引树"></li>
<li>在这个索引里面，我们依然可以用树搜索的方式定位到第一个满足<code>city=&#39;苏州&#39;</code>的记录，并且额外确保了，接下来按顺序取“下一条记录”的遍历过程中，只要 city 的值是苏州，name 的值就一定是有序的。</li>
<li>按照上图，整个查询的流程如下：<ol>
<li>从索引(city,name)找到第一个满足 city=’苏州’条件的主键 id。</li>
<li>到主键 id 索引取出整行，取 name、city、age 三个字段的值，作为结果集的一部分直接返回。</li>
<li>从索引(city,name)取下一个记录主键 id。</li>
<li>重复步骤 2、3，直到查到第 1000 条记录，或者是不满足 city=’苏州’条件时循环结束。</li>
</ol>
</li>
<li>对应的流程图如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/6.png" alt="city，name联合索引的执行流程"></li>
<li>可以看到，这个查询过程不需要临时表，也不需要排序。接下来，我们用 explain 的结果来印证一下。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/7.png" alt=""></li>
<li>从图中可以看到，<code>Extra</code>字段中没有<code>Using filesort</code>了，也就是不需要排序了。而且由于<code>(city,name)</code>这个联合索引本身有序，<strong>所以这个查询也不用把 4000 行全都读一遍，只要找到满足条件的前 1000 条记录就可以退出了</strong>。也就是说，在我们这个例子里，只需要扫描 1000 次。</li>
<li>难道仅仅这样就能满足了？此条查询语句是否能再优化呢？<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/8.jpg" alt=""></li>
<li>朋友们还记得覆盖索引吗？覆盖索引的好处就是能够避免再次回表查询，不了解的朋友们可以看一下陈某之前写的文章：<a href="https://mp.weixin.qq.com/s/-IRhK4KyDCkTd_lojeEolw" target="_blank" rel="external">Mysql 性能优化：如何使用覆盖索引？</a>。</li>
<li>我们创建<code>(city,name,age)</code>联合索引，这样在执行上面的查询语句就能使用覆盖索引了，避免了回表查询了，sql 语句如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">user</span> <span class="keyword">add</span> <span class="keyword">index</span> city_user_age(city, <span class="keyword">name</span>, age);</div></pre></td></tr></table></figure>
<ul>
<li>此时执行流程图如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/9-1.png" alt="覆盖索引使用执行流程"></li>
<li><strong>当然，覆盖索引能够提升效率，但是维护索引也是需要代价的，因此还需要权衡使用。</strong></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>今天这篇文章，我和你介绍了 MySQL 里面<code>order by</code>语句的几种算法流程。</li>
<li>在开发系统的时候，你总是不可避免地会使用到 order by 语句。心里要清楚每个语句的排序逻辑是怎么实现的，还要能够分析出在最坏情况下，每个语句的执行对系统资源的消耗，这样才能做到下笔如有神，不犯低级错误。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在实际的开发中一定会碰到根据某个字段进行排序后来显示结果的需求，但是你真的理解&lt;code&gt;order by&lt;/code&gt;在 My
    
    </summary>
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>面试官：你知道哪些事务失效的场景？</title>
    <link href="http://chenjiabing666.github.io/2020/04/19/%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9F/"/>
    <id>http://chenjiabing666.github.io/2020/04/19/面试官：你知道哪些事务失效的场景？/</id>
    <published>2020-04-19T07:45:21.000Z</published>
    <updated>2020-04-19T07:46:33.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>声明式事务是Spring功能中最爽之一，可是有些时候，我们在使用声明式事务并未生效，这是为什么呢？</li>
<li>今天陈某带大家来聊一聊声明事务的几种失效场景。本文将会从以下两个方面来说一下事务为什么会失效？<ol>
<li>@Transactional介绍</li>
<li>@Transactional失效场景</li>
</ol>
</li>
</ul>
<h2 id="Transactional介绍"><a href="#Transactional介绍" class="headerlink" title="@Transactional介绍"></a>@Transactional介绍</h2><ul>
<li><code>@Transactional</code>是声明式事务的注解，可以被标记在<code>类上</code>、<code>接口</code>、<code>方法</code>上。</li>
<li>该注解中有很多值得深入了解的几种属性，我们来看一下。</li>
</ul>
<h3 id="transactionManager"><a href="#transactionManager" class="headerlink" title="transactionManager"></a>transactionManager</h3><ul>
<li>指定事务管理器，值为<code>bean</code>的名称，这个主要用于多事务管理器情况下指定。比如多数据源配置的情况下。</li>
</ul>
<h3 id="isolation"><a href="#isolation" class="headerlink" title="isolation"></a>isolation</h3><ul>
<li>事务的隔离级别，默认是<code>Isolation.DEFAULT</code>。</li>
<li>几种值的含义如下：<ul>
<li><code>Isolation.DEFAULT</code>：事务默认的隔离级别，使用数据库默认的隔离级别。</li>
<li><code>Isolation.READ_UNCOMMITTED</code>：这是事务最低的隔离级别，它充许别外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻读。</li>
<li><code>Isolation.READ_COMMITTED</code>：保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻读。</li>
<li><code>Isolation.REPEATABLE_READ</code>：这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻读。</li>
<li><code>Isolation.SERIALIZABLE</code>：这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻读。</li>
</ul>
</li>
</ul>
<h3 id="propagation"><a href="#propagation" class="headerlink" title="propagation"></a>propagation</h3><ul>
<li>代表事务的传播行为，默认值为<code>Propagation.REQUIRED</code>。</li>
<li><code>Propagation.REQUIRED</code>：如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。比如A方法内部调用了B方法，此时B方法将会使用A方法的事务。</li>
<li><code>Propagation.MANDATORY</code>：支持当前事务，如果当前没有事务，就抛出异常。</li>
<li><code>Propagation.NEVER</code>：以非事务方式执行，如果当前存在事务，则抛出异常。</li>
<li><code>Propagation.NOT_SUPPORTED</code>：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li><code>Propagation.REQUIRES_NEW</code>：新建事务，如果当前存在事务，把当前事务挂起。比如A方法使用默认的事务传播属性，B方法使用<code>REQUIRES_NEW</code>，此时A方法在内部调用B方法，一旦A方法出现异常，A方法中的事务回滚了，但是B方法并没有回滚，因为A和B方法使用的不是同一个事务，B方法新建了一个事务。</li>
<li><code>Propagation.NESTED</code>：支持当前事务，新增<code>Savepoint</code>点，也就是在进入子事务之前，父事务建立一个回滚点，与当前事务同步提交或回滚。 子事务是父事务的一部分，在父事务还未提交时，子事务一定没有提交。嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。</li>
</ul>
<h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><ul>
<li>事务的超时时间，单位为秒。</li>
</ul>
<h3 id="readOnly"><a href="#readOnly" class="headerlink" title="readOnly"></a>readOnly</h3><ul>
<li>该属性用于设置当前事务是否为只读事务，设置为true表示只读，false则表示可读写，默认值为false。如果一个事务只涉及到只读，可以设置为true。</li>
</ul>
<h3 id="rollbackFor-属性"><a href="#rollbackFor-属性" class="headerlink" title="rollbackFor 属性"></a>rollbackFor 属性</h3><ul>
<li>用于指定能够触发事务回滚的异常类型，可以指定多个异常类型。</li>
<li>默认是在<code>RuntimeException</code>和<code>Error</code>上回滚。</li>
</ul>
<h3 id="noRollbackFor"><a href="#noRollbackFor" class="headerlink" title="noRollbackFor"></a>noRollbackFor</h3><ul>
<li>抛出指定的异常类型，不回滚事务，也可以指定多个异常类型。</li>
</ul>
<h2 id="Transactional失效场景"><a href="#Transactional失效场景" class="headerlink" title="@Transactional失效场景"></a>@Transactional失效场景</h2><ul>
<li>声明式事务失效的场景有很多，陈某这里只是罗列一下几种常见的场景。</li>
</ul>
<h3 id="底层数据库引擎不支持事务"><a href="#底层数据库引擎不支持事务" class="headerlink" title="底层数据库引擎不支持事务"></a>底层数据库引擎不支持事务</h3><ul>
<li>如果数据库引擎不支持事务，则Spring自然无法支持事务。</li>
</ul>
<h3 id="在非public修饰的方法使用"><a href="#在非public修饰的方法使用" class="headerlink" title="在非public修饰的方法使用"></a>在非public修饰的方法使用</h3><ul>
<li><p>@Transactional注解使用的是AOP，在使用动态代理的时候只能针对<code>public</code>方法进行代理，源码依据在<code>AbstractFallbackTransactionAttributeSource</code>类中的<code>computeTransactionAttribute</code>方法中，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">computeTransactionAttribute</span><span class="params">(Method method,</span></span></div><div class="line">    Class&lt;?&gt; targetClass) &#123;</div><div class="line">        <span class="comment">// Don't allow no-public methods as required.</span></div><div class="line">        <span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>此处如果不是标注在<code>public</code>修饰的方法上并不会抛出异常，但是会导致事务失效。</p>
</li>
</ul>
<h3 id="异常被-“-踹死了-“"><a href="#异常被-“-踹死了-“" class="headerlink" title="异常被 “ 踹死了 “"></a>异常被 “ 踹死了 “</h3><ul>
<li>这种情况小白是最容易犯错的，在整个事务的方法中使用<code>try-catch</code>，导致异常无法抛出，自然会导致事务失效。伪代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Transactional</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="keyword">try</span>&#123;</div><div class="line">    <span class="comment">//插入一条数据</span></div><div class="line">    <span class="comment">//更改一条数据</span></div><div class="line">  &#125;<span class="keyword">catch</span>(Exception ex)&#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="方法中调用同类的方法"><a href="#方法中调用同类的方法" class="headerlink" title="方法中调用同类的方法"></a>方法中调用同类的方法</h3><ul>
<li>简单的说就是一个类中的<code>A方法</code>（未标注声明式事务）在内部调用了<code>B方法</code>(标注了声明式事务)，这样会导致B方法中的事务失效。</li>
<li><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//插入一条数据</span></div><div class="line">    <span class="comment">//调用B方法</span></div><div class="line">    B();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="meta">@Transactional</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//插入数据</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>为什么会失效呢？</strong>：其实原因很简单，Spring在扫描Bean的时候会自动为标注了<code>@Transactional</code>注解的类生成一个代理类（proxy）,当有注解的方法被调用的时候，实际上是代理类调用的，代理类在调用之前会开启事务，执行事务的操作，但是同类中的方法互相调用，相当于<code>this.B()</code>，此时的B方法并非是代理类调用，而是直接通过原有的Bean直接调用，所以注解会失效。</p>
</li>
<li><strong>如何解决呢？</strong>：这就涉及到注解失效的原因了，后续文章会介绍到，这里不过多介绍了。</li>
</ul>
<h3 id="rollbackFor属性设置错误"><a href="#rollbackFor属性设置错误" class="headerlink" title="rollbackFor属性设置错误"></a>rollbackFor属性设置错误</h3><ul>
<li>很容易理解，指定异常触发回滚，一旦设置错误，导致一些异常不能触发回滚，此时的声明式事务不就失效了吗。</li>
</ul>
<h3 id="noRollbackFor属性设置错误"><a href="#noRollbackFor属性设置错误" class="headerlink" title="noRollbackFor属性设置错误"></a>noRollbackFor属性设置错误</h3><ul>
<li>这个和rollbackFor属性设置错误类似，一旦设置错误，也会导致异常不能触发回滚，此时的声明式事务会失效。</li>
</ul>
<h3 id="propagation属性设置错误"><a href="#propagation属性设置错误" class="headerlink" title="propagation属性设置错误"></a>propagation属性设置错误</h3><ul>
<li>事务的传播属性在上面已经介绍了，默认的事务传播属性是<code>Propagation.REQUIRED</code>，但是一旦配置了错误的传播属性，也是会导致事务失效，如下三种配置将会导致事务失效：<ul>
<li>Propagation.SUPPORTS</li>
<li>Propagation.NOT_SUPPORTED</li>
<li>Propagation.NEVER</li>
</ul>
</li>
</ul>
<h3 id="原始SSM项目，重复扫描导致事务失效"><a href="#原始SSM项目，重复扫描导致事务失效" class="headerlink" title="原始SSM项目，重复扫描导致事务失效"></a>原始SSM项目，重复扫描导致事务失效</h3><ul>
<li>在原始的SSM项目中都配置了<code>context:component-scan</code>并且同时扫描了service层，此时事务将会失效。</li>
<li>按照Spring配置文件的加载顺序来说，会先加载Springmvc的配置文件，如果在加载Springmvc配置文件的时候把service也加载了，但是此时事务还没加载，将会导致事务无法成功生效。</li>
<li>解决方法很简单，把扫描service层的配置设置在Spring配置文件或者其他配置文件中即可。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>事务失效的原因很多，但是千万不要做到一知半解，只有深入理解了，才能在面试过程中对答如流。</li>
<li><strong>今天的文章就到此结束了，如果觉得陈某写得不错，有所收获的，关注在看来一波，你们的鼓励，将会是我写作的动力，谢谢支持！！！</strong></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;声明式事务是Spring功能中最爽之一，可是有些时候，我们在使用声明式事务并未生效，这是为什么呢？&lt;/li&gt;
&lt;li&gt;今天陈某带
    
    </summary>
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>设计模式：工厂方法模式</title>
    <link href="http://chenjiabing666.github.io/2020/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://chenjiabing666.github.io/2020/04/05/设计模式：工厂方法模式/</id>
    <published>2020-04-05T13:44:06.000Z</published>
    <updated>2020-04-05T13:46:31.832Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>工厂方法模式是所有设计模式中比较常用的一种模式，但是真正能搞懂用好的少之又少，Spring底层大量的使用该设计模式来进行封装，以致开发者阅读源代码的时候晕头转向。</li>
<li>今天陈某分别从以下五个方面详细讲述一下工厂方法模式：<ol>
<li><strong>从什么是工厂方法模式</strong></li>
<li><strong>通用框架实现</strong></li>
<li><strong>工厂方法模式的优点</strong></li>
<li><strong>工厂方法模式的升级</strong></li>
<li><strong>Spring底层如何使用工厂方法模式</strong></li>
</ol>
</li>
</ul>
<h2 id="什么是工厂方法模式？"><a href="#什么是工厂方法模式？" class="headerlink" title="什么是工厂方法模式？"></a>什么是工厂方法模式？</h2><ul>
<li>定义：定义一个用于创建对象的 接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</li>
<li>工厂方法模式通用类图如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/1.png" alt=""></li>
<li>在工厂方法模式中，抽象产品<code>Product</code>负责定义产品的特性，实现对事物的抽象定义。</li>
<li><code>AbstractFactory</code>是抽象工厂类，定义了一个抽象工厂方法。具体的如何创建产品由工厂实现类<code>ConcreteFactory</code>完成。</li>
</ul>
<h2 id="通用框架实现"><a href="#通用框架实现" class="headerlink" title="通用框架实现"></a>通用框架实现</h2><ul>
<li>工厂方法模式的变种有很多，陈某给出一个比较实用的通用框架。</li>
<li><p><code>抽象产品类</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 公共逻辑方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 抽象方法：由子类实现，根据业务逻辑定义多个</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>具体产品类1</code>，继承抽象产品类，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product1</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 实现抽象产品类的抽象方法</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>具体产品类2</code>，继承抽象产品类，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product2</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 实现抽象产品类的抽象方法</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>抽象工厂类</code>，必须定义一个工厂方法来自己实现具体的创建逻辑，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 工厂方法，需要子类实现</div><div class="line">     * <span class="doctag">@param</span> cls</div><div class="line">     * <span class="doctag">@param</span> &lt;T&gt;</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T extends Product&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; cls)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>具体工厂类，使用了反射对具体产品的实例化，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> &lt;T extends Product&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; cls)</span> </span>&#123;</div><div class="line">        Product product=<span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            product= (Product) Class.forName(cls.getName()).newInstance();</div><div class="line">        &#125;<span class="keyword">catch</span> (Exception ex)&#123;</div><div class="line">            ex.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (T) product;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>测试如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//创建具体工厂类</span></div><div class="line">        ConcreteFactory factory = <span class="keyword">new</span> ConcreteFactory();</div><div class="line">        <span class="comment">//调用工厂方法获取产品类1的实例</span></div><div class="line">        Product1 product1 = factory.create(Product1.class);</div><div class="line">        System.out.println(product1);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>以上是简单的一个通用框架，读者可以根据自己的业务在其上拓展。</p>
</li>
</ul>
<h2 id="工厂方法模式的优点"><a href="#工厂方法模式的优点" class="headerlink" title="工厂方法模式的优点"></a>工厂方法模式的优点</h2><ul>
<li>良好的封装性，代码结构清晰，调用者不用关系具体的实现过程，只需要提供对应的产品类名称即可。</li>
<li>易扩展性，在增加产品类的情况下，只需要适当的修改工厂类逻辑或者重新拓展一个工厂类即可。</li>
<li>屏蔽了产品类，产品类的变化调用者不用关心。比如在使用<code>JDBC</code>连接数据库时，只需要改动一个驱动的名称，数据库就会从<code>Mysql</code>切换到<code>Oracle</code>，极其灵活。</li>
</ul>
<h2 id="工厂方法模式的升级"><a href="#工厂方法模式的升级" class="headerlink" title="工厂方法模式的升级"></a>工厂方法模式的升级</h2><ul>
<li>在复杂的系统中，一个产品的初始化过程是及其复杂的，仅仅一个具体工厂实现可能有些吃力，此时最好的做法就是为每个产品实现一个工厂，达到一个工厂类只负责生产一个产品。</li>
<li>此时工厂方法模式的类图如下：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/2.png" alt=""></p>
<ul>
<li>如上图，每个产品类都对应了一个工厂，一个工厂只负责生产一个产品，非常符合单一职责原则。</li>
<li>针对上述的升级过程，那么工厂方法中不需要传入抽象产品类了，因为一个工厂只负责一个产品的生产，此时的抽象工厂类如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 工厂方法，需要子类实现</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T extends Product&gt; <span class="function">T <span class="title">create</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Spring底层如何使用工厂方法模式？"><a href="#Spring底层如何使用工厂方法模式？" class="headerlink" title="Spring底层如何使用工厂方法模式？"></a>Spring底层如何使用工厂方法模式？</h2><ul>
<li>工厂方法模式在Spring底层被广泛的使用，陈某今天举个最常用的例子就是<code>AbstractFactoryBean</code>。</li>
<li>这个抽象工厂很熟悉了，这里不再讨论具体的作用。其实现了<code>FactoryBean</code>接口，这个接口中<code>getObject()</code>方法返回真正的Bean实例。</li>
<li><p><code>AbstractFactoryBean</code>中的<code>getObject()</code>方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">//单例，从缓存中取，或者暴露一个早期实例解决循环引用</span></div><div class="line">		<span class="keyword">if</span> (isSingleton()) &#123;</div><div class="line">			<span class="keyword">return</span> (<span class="keyword">this</span>.initialized ? <span class="keyword">this</span>.singletonInstance : getEarlySingletonInstance());</div><div class="line">		&#125;</div><div class="line">    <span class="comment">//多实例</span></div><div class="line">		<span class="keyword">else</span> &#123; </div><div class="line">      <span class="comment">//调用createInstance</span></div><div class="line">			<span class="keyword">return</span> createInstance();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">  <span class="comment">//创建对象</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title">createInstance</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>从以上代码可以看出，创建对象的职责交给了<code>createInstance</code>这个抽象方法，由其子类去定制自己的创建逻辑。</p>
</li>
<li>下图显示了继承了<code>AbstractFactoryBean</code>的具体工厂类，如下：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/3.png" alt=""></p>
<ul>
<li>其实与其说<code>AbstractFactoryBean</code>是抽象工厂类，不如说<code>FactoryBean</code>是真正的抽象工厂类，前者只是对后者的一种增强，完成大部分的可复用的逻辑。比如常用的<code>sqlSessionFactoryBean</code>只是简单的实现了<code>FactoryBean</code>，并未继承<code>AbstractFactoryBean</code>，至于结论如何，具体看你从哪方面看了。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>工厂方法模式是一种常见的设计模式，但是真正能够用的高级，用的透彻还是有些难度的，开发者所能做的就是在此模式基础上思考如何优化自己的代码，达到易扩展、封装性强的效果了。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;工厂方法模式是所有设计模式中比较常用的一种模式，但是真正能搞懂用好的少之又少，Spring底层大量的使用该设计模式来进行封装，以
    
    </summary>
    
      <category term="设计模式" scheme="http://chenjiabing666.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://chenjiabing666.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式：模板模式</title>
    <link href="http://chenjiabing666.github.io/2020/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/"/>
    <id>http://chenjiabing666.github.io/2020/04/05/设计模式：模板模式/</id>
    <published>2020-04-05T13:43:52.000Z</published>
    <updated>2020-04-05T13:45:53.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>模板模式在是Spring底层被广泛的应用，比如事务管理器的实现，JDBC模板的实现。</li>
<li>今天就来谈谈<strong>什么是模板模式</strong>、<strong>模板模式的优缺点</strong>、<strong>模板模式的简单演示</strong>、<strong>模板模式在Spring底层的实现</strong>。</li>
</ul>
<h2 id="什么是模板模式"><a href="#什么是模板模式" class="headerlink" title="什么是模板模式"></a>什么是模板模式</h2><ul>
<li>模板模式首先要有一个抽象类，这个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。</li>
<li>定义：<strong>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</strong></li>
<li>比如在造房子一样，<code>地基</code>，<code>铺线</code>，<code>房子户型</code>都是一样的，由开发商决定，但是在交房之后，室内的<code>装修风格</code>和<code>场景布置</code>却是由业主决定，在这个场景中，开发商其实就是一个抽象类，地基，铺线，房子户型都是可以复用的，但是装修却是不可复用的，必须由业主决定，此时的每一个业主的房子就是一个实现的子类。</li>
<li>模板方法的实现条件注意：<ol>
<li>必须是一个抽象类。</li>
<li>抽象类有一个模板方法，其中定义了算法骨架。</li>
<li>为了防止恶意操作，模板方法必须加上<code>final</code>关键词。</li>
<li>模板方法中除了复用的代码，其他的关键代码必须是抽象的，子类可以继承实现。</li>
</ol>
</li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。</li>
<li>它在父类中提取了公共的部分代码，便于代码复用。</li>
<li>部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</li>
<li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li>
</ul>
<h2 id="简单演示"><a href="#简单演示" class="headerlink" title="简单演示"></a>简单演示</h2><ul>
<li>比如游戏的运行需要如下几个步骤：<ol>
<li>初始化游戏</li>
<li>开始游戏</li>
<li>结束游戏</li>
</ol>
</li>
<li>上述的三个步骤可以是模板类的抽象方法，由具体的子类实现，比如足球游戏。</li>
<li><p>定义模板类，必须是一个抽象类，模板方法必须是<code>final</code>修饰。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</div><div class="line">    <span class="comment">//抽象方法</span></div><div class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</div><div class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span></span>;</div><div class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span></span>;</div><div class="line"> </div><div class="line">   <span class="comment">//模板方法</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</div><div class="line"> </div><div class="line">      <span class="comment">//初始化游戏</span></div><div class="line">      initialize();</div><div class="line"> </div><div class="line">      <span class="comment">//开始游戏</span></div><div class="line">      startPlay();</div><div class="line"> </div><div class="line">      <span class="comment">//结束游戏</span></div><div class="line">      endPlay();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>定义实现类，足球游戏，继承模板类，实现其中的三个抽象方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Football</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</div><div class="line"> </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"足球游戏结束......"</span>);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"足球游戏初始化中......"</span>);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"足球游侠开始了......"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>此时写一个测试方法，运行足球游戏，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplatePatternDemo</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      <span class="comment">//创建足球游戏实例</span></div><div class="line">      Game game = <span class="keyword">new</span> Football();</div><div class="line">      <span class="comment">//开始游戏</span></div><div class="line">      game.play();      </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>输出结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">足球游戏初始化中......</div><div class="line">足球游侠开始了......</div><div class="line">足球游戏结束......</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Spring中的模板模式"><a href="#Spring中的模板模式" class="headerlink" title="Spring中的模板模式"></a>Spring中的模板模式</h2><ul>
<li>Spring底层对于模板模式的使用有很多处，今天陈某带大家康康事务管理器是如何使用模板模式的。</li>
</ul>
<h3 id="模板抽象类"><a href="#模板抽象类" class="headerlink" title="模板抽象类"></a>模板抽象类</h3><ul>
<li><code>AbstractPlatformTransactionManager</code>是Spring中的<code>模板抽象类</code>，来看看它的继承关系图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/1.png" alt=""></li>
<li>实现了<code>PlatformTransactionManager</code>接口，重载了接口中的方法。</li>
</ul>
<h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><ul>
<li><p>事务管理器中抽象类中的模板方法不止一个，比如以下两个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//提交事务</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span></span></div><div class="line"></div><div class="line"><span class="comment">//获取TransactionStatus</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title">getTransaction</span><span class="params">()</span></div></pre></td></tr></table></figure>
</li>
<li><p>这两个方法都对于自己要实现的逻辑搭建了一个骨架，主要的功能是由抽象方法完成，由子类来完成。</p>
</li>
</ul>
<h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><ul>
<li><p>事务管理器抽象类中的抽象方法定义了多个，分别用于处理不同的业务逻辑，由子类实现其中具体的逻辑，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//提交事务</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doCommit</span><span class="params">(DefaultTransactionStatus status)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//回滚事务</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doRollback</span><span class="params">(DefaultTransactionStatus status)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//开始事务</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doBegin</span><span class="params">(Object transaction, TransactionDefinition definition)</span></span></div><div class="line"></div><div class="line"><span class="comment">//获取当前的事务对象</span></div><div class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">doGetTransaction</span><span class="params">()</span></div></pre></td></tr></table></figure>
</li>
<li><p>抽象方法的定义便于子类去扩展，在保证算法逻辑不变的情况下，子类能够定制自己的实现。</p>
</li>
</ul>
<h3 id="具体子类"><a href="#具体子类" class="headerlink" title="具体子类"></a>具体子类</h3><ul>
<li>事务管理器的模板类有很多的具体子类，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/2.png" alt=""></li>
<li>其中我们熟悉的有<code>DataSourceTransactionManager</code>、<code>JtaTransactionManager</code>、<code>RabbitTransactionManager</code>。具体承担什么样的角色和责任不是本节的重点，不再细说。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>模板模式是一个很重要，易扩展的模式，提高了代码复用性，在Spring中有着广泛的应用，比如<code>JDBCTemplate</code>,<code>AbstractPlatformTransactionManager</code>，这些实现都用到了模板模式。</li>
<li>如果觉得陈某的文章能够对你有所帮助，有所启发，关注分享一波，点个在看，谢谢支持！！！</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;模板模式在是Spring底层被广泛的应用，比如事务管理器的实现，JDBC模板的实现。&lt;/li&gt;
&lt;li&gt;今天就来谈谈&lt;stron
    
    </summary>
    
      <category term="设计模式" scheme="http://chenjiabing666.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://chenjiabing666.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Mysql性能优化：为什么count(*)这么慢？</title>
    <link href="http://chenjiabing666.github.io/2020/04/05/Mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88count%E8%BF%99%E4%B9%88%E6%85%A2/"/>
    <id>http://chenjiabing666.github.io/2020/04/05/Mysql性能优化：为什么count这么慢/</id>
    <published>2020-04-05T13:41:59.000Z</published>
    <updated>2020-04-05T13:43:11.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>在开发中一定会用到统计一张表的行数，比如一个交易系统，老板会让你每天生成一个报表，这些统计信息少不了sql中的<code>count</code>函数。</li>
<li>但是随着记录越来越多，查询的速度会越来越慢，为什么会这样呢？Mysql内部到底是怎么处理的？</li>
<li>今天这篇文章将从Mysql内部对于<code>count</code>函数是怎样处理的？</li>
</ul>
<h2 id="count的实现方式"><a href="#count的实现方式" class="headerlink" title="count的实现方式"></a>count的实现方式</h2><ul>
<li>在Mysql中的不同的存储引擎对<code>count</code>函数有不同的实现方式。</li>
<li><code>MyISAM</code>引擎把一个表的总行数存在了磁盘上，因此执行<code>count(*)</code>的时候会直接返回这个数，效率很高（没有<code>where</code>查询条件）。</li>
<li><code>InnoDB</code>引擎并没有直接将总数存在磁盘上，在执行<code>count(*)</code>函数的时候需要一行一行的将数据读出来，然后累计总数。</li>
</ul>
<h2 id="为什么InnoDB不将总数存起来？"><a href="#为什么InnoDB不将总数存起来？" class="headerlink" title="为什么InnoDB不将总数存起来？"></a>为什么InnoDB不将总数存起来？</h2><ul>
<li><p>说道InnoDB相信读者总会想到其支持事务的特性，事务具有隔离性，如果将总数存起来，怎么保证各个事务之间的总数的一致性呢？不明白的看下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/count/1.png" alt=""></p>
</li>
<li><p><code>事务A</code>和<code>事务B</code>中的<code>count(*)</code>的执行结果是不同的，因此InnoDB引擎在每个事务中返回多少行是不确定的，只能一行一行的读出来用来判断总数。</p>
</li>
</ul>
<h2 id="如何提升count效率"><a href="#如何提升count效率" class="headerlink" title="如何提升count效率"></a>如何提升count效率</h2><ul>
<li>在<code>InnoDB</code>对于如何提升<code>count(*)</code>的查询效率，网上有多种解决办法，这里主要介绍三种，并分析可行性。</li>
</ul>
<h3 id="show-table-status"><a href="#show-table-status" class="headerlink" title="show table status"></a>show table status</h3><ul>
<li><code>show table status</code>这个命令能够很快的查询出数据库中每个表的行数，但是真的能够替代<code>count(*)</code>吗？</li>
<li>答案是不能。原因很简单，这个命令统计出来的值是一个<strong>估值</strong>，因此是不准确的，官方文档说误差大概在<code>40%-50%</code>。</li>
<li>因此这种方法直接pass，不准确还用它干嘛。</li>
</ul>
<h3 id="缓存系统存储总数"><a href="#缓存系统存储总数" class="headerlink" title="缓存系统存储总数"></a>缓存系统存储总数</h3><ul>
<li>这种方法也是最容易想到的，增加一行就<code>+1</code>，删除一行就<code>-1</code>，并且缓存系统读取也是很快，既简单又方便的为什么不用？</li>
<li><p>缓存系统和Mysql是两个系统，比如<code>redis</code>和<code>Mysql</code>这两个是典型的比较。两个系统最难的就是在高并发下无法保证数据的一致性。通过以下两图我们来理解一下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/count/2.png" alt=""><br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/count/3.png" alt=""></p>
</li>
<li><p>通过上面两张图，无论是<code>redis计数+1</code>还是<code>insert into user</code>先执行，最终都会导致数据在逻辑上的不一致。第一张图会出现<code>redis计数</code>少了，第二张图虽然计数正确了但是并没有查询出插入的那一行数据。</p>
</li>
<li>在并发系统里面，我们是无法精确控制不同线程的执行时刻的，因为存在图中的这种操作序列，所以，我们说即使Redis正常工作，这个计数值还是逻辑上不精确的。</li>
</ul>
<h3 id="在数据库保存计数"><a href="#在数据库保存计数" class="headerlink" title="在数据库保存计数"></a>在数据库保存计数</h3><ul>
<li>通过缓存系统保存的分析得知了使用缓存无法保证数据在逻辑上的一致性，因此我们想到了直接使用数据库来保存，有了<strong>事务</strong>的支持，也就保证了数据的一致性了。</li>
<li>如何使用呢？很简单，直接将计数保存在一张表中<code>（table_name,total）</code>。</li>
<li><p>至于执行的逻辑只需要将缓存系统中<code>redis计数+1</code>改成<code>total</code>字段+1即可，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/count/4.png" alt=""></p>
</li>
<li><p>由于在同一个事务中，保证了数据在逻辑上的一致性。</p>
</li>
</ul>
<h2 id="不同count的用法"><a href="#不同count的用法" class="headerlink" title="不同count的用法"></a>不同count的用法</h2><ul>
<li><code>count()</code>是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL，累计值就加1，否则不加。最后返回累计值。</li>
<li><code>count</code>的用法有多种，分别是<code>count(*)</code>、<code>count(字段)</code>、<code>count(1)</code>、<code>count(主键id)</code>。那么多种用法，到底有什么差别呢？当然，<strong>前提是没有<code>where</code>条件语句</strong>。</li>
<li><code>count(id)</code>：InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空的，就按行累加。</li>
<li><code>count(1)</code>：InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字<code>1</code>进去，判断是不可能为空的，按行累加。</li>
<li><code>count(字段)</code>：<ul>
<li>如果这个“字段”是定义为<code>not null</code>的话，一行行地从记录里面读出这个字段，判断不能为null，按行累加；</li>
<li>如果这个字段定义允许为<code>null</code>，那么执行的时候，判断到有可能是null，还要把值取出来再判断一下，不是null才累加。</li>
</ul>
</li>
<li><code>count(*)</code>：不会把全部字段取出来，而是专门做了优化，不取值。<code>count(*)</code>肯定不是null，按行累加。</li>
<li>所以结论很简单：<strong>按照效率排序的话，<code>count(字段)</code>&lt;<code>count(主键id)</code>&lt;<code>count(1)</code>≈<code>count(*)</code>，所以建议读者，尽量使用<code>count(*)</code>。</strong></li>
<li><strong>注意</strong>：这里肯定有人会问，<code>count(id)</code>不是走的索引吗，为什么查询效率和其他的差不多呢？陈某在这里解释一下，虽然走的索引，但是还是要一行一行的扫描才能统计出来总数。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>MyISAM</code>表虽然<code>count(*)</code>很快，但是不支持事务；</li>
<li><code>show table status</code>命令虽然返回很快，但是不准确；</li>
<li><code>InnoDB</code>直接<code>count(*)</code>会遍历全表(没有where条件)，虽然结果准确，但会导致性能问题。</li>
<li>缓存系统的存储计数虽然简单效率高，但是无法保证数据的一致性。</li>
<li>数据库保存计数很简单，也能保证数据的一致性，建议使用。</li>
<li><strong>思考题，读者留言区讨论</strong>：在系统高并发的情况下，使用数据库保存计数，是先<code>更新计数+1</code>,还是先<code>插入数据</code>。即是先<code>update total+=1</code>还是先<code>insert into</code>。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在开发中一定会用到统计一张表的行数，比如一个交易系统，老板会让你每天生成一个报表，这些统计信息少不了sql中的&lt;code&gt;cou
    
    </summary>
    
      <category term="数据库干货篇" scheme="http://chenjiabing666.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B2%E8%B4%A7%E7%AF%87/"/>
    
    
      <category term="SQL" scheme="http://chenjiabing666.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>接口幂等性如何设计？</title>
    <link href="http://chenjiabing666.github.io/2020/04/01/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%EF%BC%9F/"/>
    <id>http://chenjiabing666.github.io/2020/04/01/接口幂等性如何设计？/</id>
    <published>2020-04-01T02:38:34.000Z</published>
    <updated>2020-04-01T02:38:57.101Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>现在这个时代大家可能最关心的就是钱了，那么有没有想过你银行转账给你没有一次是转多的，要么失败，要么成功，为什么不能失误一下多转一笔呢？醒醒吧年轻人，别做梦了，做银行的能那么傻x吗？</li>
<li>今天我们就来谈一谈为什么银行转账不能多给我转一笔？关乎到钱的问题，小伙伴们打起精神！！！</li>
<li>要想要理解上述的疑惑，不得不提的一个概念就是幂等性，至于什么是幂等性，如何通过代码实现幂等性，下面将会详细讲述。</li>
</ul>
<h2 id="什么是幂等性"><a href="#什么是幂等性" class="headerlink" title="什么是幂等性"></a>什么是幂等性</h2><ul>
<li>所谓幂等性通俗的将就是一次请求和多次请求同一个资源产生相同的副作用。用数学语言表达就是<code>f(x)=f(f(x))</code>。</li>
<li>维基百科的幂等性定义如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。</div><div class="line">在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“setTrue()”函数就是一个幂等函数,无论多次执行，其结果都是一样的，更复杂的操作幂等保证是利用唯一交易号(流水号)实现.</div></pre></td></tr></table></figure>
<h2 id="为什么需要幂等性"><a href="#为什么需要幂等性" class="headerlink" title="为什么需要幂等性"></a>为什么需要幂等性</h2><ul>
<li>在系统高并发的环境下，很有可能因为网络，阻塞等等问题导致客户端或者调用方并不能及时的收到服务端的反馈甚至是调用超时的问题。总之，就是请求方调用了你的服务，但是没有收到任何的信息，完全懵逼的状态。比如订单的问题，可能会遇到如下的几个问题：</li>
</ul>
<ol>
<li>创建订单时，第一次调用服务超时，再次调用是否产生两笔订单？</li>
<li>订单创建成功去减库存时，第一次减库存超时，是否会多扣一次？</li>
<li>订单支付时，服务端扣钱成功，但是接口反馈超时，此时再次调用支付，是否会多扣一笔呢？</li>
</ol>
<ul>
<li>作为消费者，前两种能接受，第三种情况就MMP了，哈哈哈！！！这种情况一般有如下两种解决方式</li>
</ul>
<ol>
<li>服务方提供一个查询操作是否成功的api，第一次超时之后，调用方调用查询接口，如果查到了就走成功的流程，失败了就走失败的流程。</li>
<li>另一种就是服务方需要使用幂等的方式保证一次和多次的请求结果一致。</li>
</ol>
<h2 id="HTTP的幂等性"><a href="#HTTP的幂等性" class="headerlink" title="HTTP的幂等性"></a>HTTP的幂等性</h2><ul>
<li>GET：只是获取资源，对资源本身没有任何副作用，天然的幂等性。</li>
<li>HEAD：本质上和GET一样，获取头信息，主要是探活的作用，具有幂等性。</li>
<li>OPTIONS：获取当前URL所支持的方法，因此也是具有幂等性的。</li>
<li>DELETE：用于删除资源，有副作用，但是它应该满足幂等性，比如根据id删除某一个资源，调用方可以调用N次而不用担心引起的错误（根据业务需求而变）。</li>
<li>PUT：用于更新资源，有副作用，但是它应该满足幂等性，比如根据id更新数据，调用多次和N次的作用是相同的（根据业务需求而变）。</li>
<li>POST：用于添加资源，多次提交很可能产生副作用，比如订单提交，多次提交很可能产生多笔订单。</li>
</ul>
<h2 id="幂等性的实现方式"><a href="#幂等性的实现方式" class="headerlink" title="幂等性的实现方式"></a>幂等性的实现方式</h2><ul>
<li>对于客户端交互的接口，可以在前端拦截一部分，例如防止表单重复提交，按钮置灰，隐藏，不可点击等方式。但是前端进行拦截器显然是针对普通用户，懂点技术的都可以模拟请求调用接口，所以后端幂等性很重要。</li>
<li>后端的幂等性如何实现？将会从以下几个方面介绍。</li>
</ul>
<h3 id="数据库去重表"><a href="#数据库去重表" class="headerlink" title="数据库去重表"></a>数据库去重表</h3><ul>
<li>在往数据库中插入数据的时候，利用数据库唯一索引特性，保证数据唯一。比如订单的流水号，也可以是多个字段的组合。</li>
<li>实现比较简单，读者可以自己实现看看，这里不再提供demo了。</li>
</ul>
<h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><ul>
<li>很多业务中多有多个状态，比如订单的状态有提交、待支付、已支付、取消、退款等等状态。后端可以根据不同的状态去保证幂等性，比如在退款的时候，一定要保证这笔订单是已支付的状态。</li>
<li>业务中常常出现，读者可以自己实现看看，不再提供demo。</li>
</ul>
<h3 id="TOKEN机制"><a href="#TOKEN机制" class="headerlink" title="TOKEN机制"></a>TOKEN机制</h3><ul>
<li>针对客户端连续点击或者调用方的超时重试等情况，例如提交订单，此种操作就可以用Token的机制实现防止重复提交。</li>
<li>TOKEN机制如何实现？简单的说就是调用方在调用接口的时候先向后端请求一个全局ID（TOKEN），请求的时候携带这个全局ID一起请求，后端需要对这个全局ID校验来保证幂等操作，流程如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/repeat/1.png" alt=""></p>
<ul>
<li>主要的流程步骤如下：<ul>
<li>客户端先发送获取token的请求，服务端会生成一个全局唯一的ID保存在redis中，同时把这个ID返回给客户端。</li>
<li>客户端调用业务请求的时候必须携带这个token，一般放在请求头上。</li>
<li>服务端会校验这个Token，如果校验成功，则执行业务。</li>
<li>如果校验失败，则表示重复操作，直接返回指定的结果给客户端。</li>
</ul>
</li>
<li>通过以上的流程分析，唯一的重点就是这个全局唯一ID如何生成，在分布式服务中往往都会有一个生成全局ID的服务来保证ID的唯一性，但是工程量和实现难度比较大，UUID的数据量相对有些大，此处陈某选择的是雪花算法生成全局唯一ID，不了解雪花算法的读者下一篇文章会着重介绍。</li>
</ul>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul>
<li>陈某选择的环境是SpringBoot+Redis单机环境+注解+拦截器的方式实现，只是演示一下思想，具体的代码可以参照实现。</li>
<li>redis如何实现，获取Token接口将全局唯一Id存入Redis（一定要设置失效时间，根据业务需求），业务请求的时候直接从redis中删除，根据delete的返回值判断，返回true表示第一次请求，返回false表示重复请求。代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenServiceImpl</span> <span class="keyword">implements</span> <span class="title">TokenService</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getToken</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//获取全局唯一id</span></div><div class="line">        <span class="keyword">long</span> nextId = SnowflakeUtil.nextId();</div><div class="line">        <span class="comment">//存入redis，设置10分钟失效</span></div><div class="line">        stringRedisTemplate.opsForValue().set(String.valueOf(nextId), UUID.randomUUID().toString(),<span class="number">10</span>, TimeUnit.MINUTES);</div><div class="line">        <span class="keyword">return</span> String.valueOf(nextId);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">    * 删除记录，true表示第一次提交，false重复提交</div><div class="line">    */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">checkToken</span><span class="params">(String token)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> stringRedisTemplate.delete(token);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>注解的实现如下，标注在controller类上表示当前类上全部接口都做幂等，标注单个方法上，表示单个接口做幂等操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Description</span> 幂等操作的注解</div><div class="line"> * <span class="doctag">@Author</span> CJB</div><div class="line"> * <span class="doctag">@Date</span> 2020/3/25 10:19</div><div class="line"> */</div><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RepeatLimiter &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>请求头的拦截器，用于提取请求头和校验请求头，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Description</span> 获取请求头的信息，具体校验逻辑读者自己实现</div><div class="line"> * <span class="doctag">@Author</span> CJB</div><div class="line"> * <span class="doctag">@Date</span> 2020/3/25 11:09</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderIntercept</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//获取token</span></div><div class="line">        String token = request.getHeader(HeaderConstant.TOKEN);</div><div class="line">        <span class="comment">//校验逻辑</span></div><div class="line">        <span class="keyword">if</span> (!validToken(token))</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TokenInvalidException(<span class="string">"TOKEN失效"</span>);</div><div class="line">        <span class="comment">//获取其他的参数.....</span></div><div class="line">        RequestHeader header = RequestHeader.builder()</div><div class="line">                .token(token)</div><div class="line">                .build();</div><div class="line">        <span class="comment">//放入request中</span></div><div class="line">        request.setAttribute(HeaderConstant.HEADER_INFO,header);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 校验token，逻辑自己实现</div><div class="line">     * <span class="doctag">@param</span> token</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validToken</span><span class="params">(String token)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> Boolean.TRUE;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>保证幂等性的拦截器，直接从redis中删除token，成功则第一次提交，不成功则重复提交。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepeatIntercept</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> TokenService tokenService;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> HandlerMethod)&#123;</div><div class="line">            <span class="comment">//获取方法上的参数</span></div><div class="line">            RepeatLimiter repeatLimiter = AnnotationUtils.findAnnotation(((HandlerMethod) handler).getMethod(), RepeatLimiter.class);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (Objects.isNull(repeatLimiter))&#123;</div><div class="line">                <span class="comment">//获取controller类上注解</span></div><div class="line">                repeatLimiter=AnnotationUtils.findAnnotation(((HandlerMethod) handler).getBean().getClass(),RepeatLimiter.class);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//使用注解，需要拦截验证</span></div><div class="line">            <span class="keyword">if</span> (Objects.nonNull(repeatLimiter))&#123;</div><div class="line">                <span class="comment">//获取全局token，表单提交的唯一id</span></div><div class="line">                RequestHeader info = RequestContextUtils.getHeaderInfo();</div><div class="line"></div><div class="line">                <span class="comment">//没有携带token，抛异常，这里的异常需要全局捕获</span></div><div class="line">                <span class="keyword">if</span> (StringUtils.isEmpty(info.getToken()))</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RepeatException();</div><div class="line"></div><div class="line">                <span class="comment">//校验token</span></div><div class="line">                Boolean flag = tokenService.checkToken(info.getToken());</div><div class="line"></div><div class="line">                <span class="comment">//删除失败，表示</span></div><div class="line">                <span class="keyword">if</span> (Boolean.FALSE.equals(flag))</div><div class="line">                    <span class="comment">//抛出重复提交的异常</span></div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RepeatException();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>接口幂等实现，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/order"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> OrderService orderService;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 下单</div><div class="line">     * <span class="doctag">@param</span> order</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@PostMapping</span></div><div class="line">    <span class="meta">@RepeatLimiter</span>  <span class="comment">//幂等性保证</span></div><div class="line">    <span class="function"><span class="keyword">public</span> CommenResult <span class="title">add</span><span class="params">(@RequestBody Order order)</span></span>&#123;</div><div class="line">        orderService.save(order);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommenResult(<span class="string">"200"</span>,<span class="string">"下单成功"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><ul>
<li>发送getToken的请求获取Token</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/repeat/2.png" alt=""></p>
<ul>
<li>携带Token下单第一次：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/repeat/3.png" alt=""></p>
<ul>
<li>第二次下单：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/repeat/4.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;现在这个时代大家可能最关心的就是钱了，那么有没有想过你银行转账给你没有一次是转多的，要么失败，要么成功，为什么不能失误一下多转一
    
    </summary>
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Mysql性能优化：什么是索引下推？</title>
    <link href="http://chenjiabing666.github.io/2020/04/01/Mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%EF%BC%9F/"/>
    <id>http://chenjiabing666.github.io/2020/04/01/Mysql性能优化：什么是索引下推？/</id>
    <published>2020-04-01T02:37:30.000Z</published>
    <updated>2020-04-01T02:37:58.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>索引下推（index condition pushdown ）简称ICP，在Mysql5.6的版本上推出，用于优化查询。</li>
<li>在不使用ICP的情况下，在使用非主键索引（又叫普通索引或者二级索引）进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件 。</li>
<li>在使用ICP的情况下，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。</li>
<li>索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。 </li>
</ul>
<h2 id="开撸"><a href="#开撸" class="headerlink" title="开撸"></a>开撸</h2><ul>
<li>在开始之前先先准备一张用户表(user)，其中主要几个字段有：id、name、age、address。建立联合索引（name，age）。</li>
<li>假设有一个需求，要求匹配姓名第一个为陈的所有用户，sql语句如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span>  <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'陈%'</span></div></pre></td></tr></table></figure>
<ul>
<li>根据 “最佳左前缀” 的原则，这里使用了联合索引（name，age）进行了查询，性能要比全表扫描肯定要高。</li>
<li>问题来了，如果有其他的条件呢？假设又有一个需求，要求匹配姓名第一个字为陈，年龄为20岁的用户，此时的sql语句如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span>  <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'陈%'</span> <span class="keyword">and</span> age=<span class="number">20</span></div></pre></td></tr></table></figure>
<ul>
<li>这条sql语句应该如何执行呢？下面对Mysql5.6之前版本和之后版本进行分析。</li>
</ul>
<h3 id="Mysql5-6之前的版本"><a href="#Mysql5-6之前的版本" class="headerlink" title="Mysql5.6之前的版本"></a>Mysql5.6之前的版本</h3><ul>
<li>5.6之前的版本是没有索引下推这个优化的，因此执行的过程如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/1.png" alt=""></p>
<ul>
<li>会忽略age这个字段，直接通过name进行查询，在(name,age)这课树上查找到了两个结果，id分别为2,1，然后拿着取到的id值一次次的回表查询，因此这个过程需要<strong>回表两次</strong>。</li>
</ul>
<h3 id="Mysql5-6及之后版本"><a href="#Mysql5-6及之后版本" class="headerlink" title="Mysql5.6及之后版本"></a>Mysql5.6及之后版本</h3><ul>
<li>5.6版本添加了索引下推这个优化，执行的过程如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/2.png" alt=""></p>
<ul>
<li>InnoDB并没有忽略age这个字段，而是在索引内部就判断了age是否等于20，对于不等于20的记录直接跳过，因此在(name,age)这棵索引树中只匹配到了一个记录，此时拿着这个id去主键索引树中回表查询全部数据，这个过程只需要回表一次。</li>
</ul>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><ul>
<li>当然上述的分析只是原理上的，我们可以实战分析一下，因此陈某装了Mysql5.6版本的Mysql，解析了上述的语句，如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/3.png" alt=""></p>
<ul>
<li>根据explain解析结果可以看出Extra的值为<strong>Using index condition</strong>，表示已经使用了索引下推。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>索引下推在<strong>非主键索引</strong>上的优化，可以有效减少回表的次数，大大提升了查询的效率。</li>
<li>关闭索引下推可以使用如下命令，配置文件的修改不再讲述了，毕竟这么优秀的功能干嘛关闭呢：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">set</span> optimizer_switch=<span class="string">'index_condition_pushdown=off'</span>;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;索引下推（index condition pushdown ）简称ICP，在Mysql5.6的版本上推出，用于优化查询。&lt;/li
    
    </summary>
    
      <category term="数据库干货篇" scheme="http://chenjiabing666.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B2%E8%B4%A7%E7%AF%87/"/>
    
    
      <category term="SQL" scheme="http://chenjiabing666.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Mysql性能优化：为什么使用覆盖索引?</title>
    <link href="http://chenjiabing666.github.io/2020/04/01/Mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95/"/>
    <id>http://chenjiabing666.github.io/2020/04/01/Mysql性能优化：为什么使用覆盖索引/</id>
    <published>2020-04-01T02:36:34.000Z</published>
    <updated>2020-04-01T02:36:54.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li><p>相信读者看过很多MYSQL索引优化的文章，其中有很多优化的方法，比如最佳左前缀，覆盖索引等方法，但是你真正理解为什么要使用最佳左前缀，为什么使用覆盖索引会提升查询的效率吗？</p>
</li>
<li><p>本篇文章将从MYSQL内部结构上讲一下为什么覆盖索引能够提升效率。</p>
</li>
</ul>
<h2 id="InnoDB索引模型"><a href="#InnoDB索引模型" class="headerlink" title="InnoDB索引模型"></a>InnoDB索引模型</h2><ul>
<li>在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。</li>
<li>每一个索引在InnoDB里面对应一棵B+树。</li>
</ul>
<h2 id="主键索引和非主键索引的区别"><a href="#主键索引和非主键索引的区别" class="headerlink" title="主键索引和非主键索引的区别"></a>主键索引和非主键索引的区别</h2><ul>
<li>主键索引又叫聚簇索引 ，非主键索引又叫普通索引，那么这两种索引有什么区别呢？</li>
<li>主键索引的叶子节点存放的是整行数据，非主键索引的叶子节点存放的是主键的值。</li>
<li>假设有一张User表（id,age,name,address），其中有id和age两个字段，其中id是主键，age是普通索引，有几行数据u1-u5的(id,age)的值是(100,1)、(200,2)、(300,3)、(500,5)和(600,6) ，此时的两棵树的示例如下：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95/1.png" alt=""></p>
<ul>
<li>从上图可以看出来，基于主键索引的树的叶子节点存放的是整行User数据，基于普通索引age的叶子节点存放的是id（主键）的值。</li>
</ul>
<h2 id="什么是回表？"><a href="#什么是回表？" class="headerlink" title="什么是回表？"></a>什么是回表？</h2><ul>
<li>假设有一条查询语句如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age=<span class="number">3</span>;</div></pre></td></tr></table></figure>
<ul>
<li><p>上面这条sql语句执行的过程如下：</p>
<p>1、根据age这个普通索引在age索引树上搜索，得到主键id的值为300。</p>
<p>2、因为age索引树并没有存储User的全部数据，因此需要根据在age索引树上查询到的主键id的值300再到id索引树搜索一次，查询到了u3。</p>
<p>3、返回结果。</p>
</li>
<li><p>上述执行的过程中，从age索引树再到id索引树的查询的过程叫做回表（回到主键索引树搜索的过程）。</p>
</li>
<li><p>也就是说通过非主键索引的查询需要多扫描一棵索引树，因此需要尽量使用主键索引查询。</p>
</li>
</ul>
<h2 id="为什么使用覆盖索引？"><a href="#为什么使用覆盖索引？" class="headerlink" title="为什么使用覆盖索引？"></a>为什么使用覆盖索引？</h2><ul>
<li>有了上述提及到的几个概念，便能很清楚的理解为什么覆盖索引能够提升查询效率了，因为少了一次回表的过程。</li>
<li>假设我们使用覆盖索引查询，语句如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select id from user where age=3;</div></pre></td></tr></table></figure>
<ul>
<li>这条语句执行过程很简单，直接在age索引树中就能查询到id的值，不用再去id索引树中查找其他的数据，避免了回表。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>覆盖索引的使用能够减少树的搜索次数，避免了回表，显著提升了查询性能，因此覆盖索引是一个常用的性能优化手段。</li>
<li>留给读者一个问题：身份证是一个人的唯一识别凭证，如果有根据身份证号查询市民信息的需求，我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？ </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;相信读者看过很多MYSQL索引优化的文章，其中有很多优化的方法，比如最佳左前缀，覆盖索引等方法，但是你真正理解为什么要使用
    
    </summary>
    
      <category term="数据库干货篇" scheme="http://chenjiabing666.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B2%E8%B4%A7%E7%AF%87/"/>
    
    
      <category term="SQL" scheme="http://chenjiabing666.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>一条查询语句到底是如何执行的?</title>
    <link href="http://chenjiabing666.github.io/2020/04/01/%E4%B8%80%E6%9D%A1%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/"/>
    <id>http://chenjiabing666.github.io/2020/04/01/一条查询语句到底是如何执行的/</id>
    <published>2020-04-01T02:35:30.000Z</published>
    <updated>2020-04-01T02:35:49.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li><p>Mysql在中小型企业中是个香饽饽，目前主流的数据库之一，几乎没有一个后端开发者不会使用的，但是作为一个老司机，仅仅会用真的不够。</p>
</li>
<li><p>今天陈某透过一个简单的查询语句来讲述在Mysql内部的执行过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select * from table where id=10;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="撸它"><a href="#撸它" class="headerlink" title="撸它"></a>撸它</h2><ul>
<li>首先通过一张图片来了解一下Mysql的基础架构，如下：</li>
</ul>
<p>  <img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/MYSQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/1.png" alt=""></p>
<ul>
<li>从上图可以看出，Mysql大致分为Server层和存储引擎层两部分。</li>
<li>Server层包括连接器、查询缓存、分析器、优化器等，其中包含了Mysql的大多数核心功能以及所有的内置函数（如日期，时间函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</li>
<li>存储引擎层负责数据的存储和提取。它的架构是可插拔式的，支持InnoDB、MyISAM等多个存储引擎。Mysql中主流的存储引擎是InnoDB，由于它对事务的支持让它从Mysql5.5.5版本开始成为了默认的存储引擎。</li>
<li>大致了解了整体架构，现在说说每一个基础的模块都承担着怎样的责任。</li>
</ul>
<h3 id="1-连接器"><a href="#1-连接器" class="headerlink" title="1. 连接器"></a>1. 连接器</h3><ul>
<li><p>顾名思义，是客户端和Mysql之间连接的媒介，负责登录、获取权限、维持连接和管理连接。连接命令一般如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql [-h] ip [- P] port -u [user] -p</div></pre></td></tr></table></figure>
</li>
<li><p>在完成经典的TCP握手后，连接器会开始认证身份，要求输入密码。</p>
<ul>
<li>密码认证通过，连接器会查询出拥有的权限，即使管理员修改了权限，也不会影响你这次的连接，只有重新连接才会生效。</li>
<li>密码认证失败，会收到提示信息Access denied for user。</li>
</ul>
</li>
<li><p>连接完成后，没有后续动作的连接将会变成空闲连接，你可以输入<code>show processlist</code>命令看到它。如下图，其中的Command这一列显示为sleep的这一行表示在系统里面有一个空闲连接。</p>
</li>
</ul>
<p>  <img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/MYSQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/2.png" alt=""></p>
<ul>
<li><p>客户端如果太长时间没有执行动作，连接器将会自动断开，这个时间由参数<code>wait_timeout</code>控制，默认值是8小时。</p>
</li>
<li><p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p>
</li>
</ul>
<h3 id="2-查询缓存【废材，8-0-版本完全删除】"><a href="#2-查询缓存【废材，8-0-版本完全删除】" class="headerlink" title="2. 查询缓存【废材，8.0 版本完全删除】"></a>2. 查询缓存【废材，8.0 版本完全删除】</h3><ul>
<li><p>连接建立完成后，你就可以select语句了，执行之前会查询缓存。</p>
</li>
<li><p>查询缓存在Mysql中的是默认关闭的，因为缓存命中率非常低，只要有对表执行一个更新操作，这个表的所有查询缓存都将被清空。怎么样？一句废材足以形容了！！！</p>
</li>
<li><p>废材的东西不必多讲，主流的Redis的缓存你不用，别再搞这废材了。</p>
</li>
</ul>
<h3 id="3-分析器"><a href="#3-分析器" class="headerlink" title="3. 分析器"></a>3. 分析器</h3><ul>
<li><p>如果没有命中查询缓存，就要执行查询了，但是在执行查询之前，需要对SQL语句做解析，判断你这条语句有没有语法错误。</p>
</li>
<li><p>分析器会做 ‘词法分析’ ，你输入的无非可就是多个字符串和空格组成的SQL语句，MYSQL需要识别出里面的字符串是什么，代表什么，有没有关键词等。</p>
</li>
<li><p>MYSQL会从你输入的select 这个关键字识别出来是一个查询语句，table是表名，id是列名。</p>
</li>
<li><p>做完这些会做 ‘语法分析’ ，根据MYSQL定义的规则来判断你的SQL语句有没有语法错误，如果你的语法不对，就会收到类似如下的提醒：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;elect * from t where ID=1&apos; at line 1</div></pre></td></tr></table></figure>
</li>
<li><p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。</p>
</li>
</ul>
<h3 id="4-优化器"><a href="#4-优化器" class="headerlink" title="4. 优化器"></a>4. 优化器</h3><ul>
<li><p>经过分析器词法和语法的分析，此时就能知道这条SQL语句是干什么的。但是在开始执行之前，MYSQL底层还要使用优化器对这条SQL语句进行优化处理。</p>
</li>
<li><p>MYSQL内部会对这条SQL进行评估，比如涉及到多个索引会比较使用哪个索引代价更小、多表join的时候会考虑决定各个表的连接顺序。</p>
</li>
<li><p>优化器的作用一句话总结：根据MYSQL内部的算法决定如何执行这条SQL语句来达到MYSQL认为代价最小目的。</p>
</li>
<li><p>优化器阶段完成后，这个语句的执行方案就确定了，接下来就交给执行器执行了。</p>
</li>
</ul>
<h3 id="5-执行器"><a href="#5-执行器" class="headerlink" title="5. 执行器"></a>5. 执行器</h3><ul>
<li><p>MYSQL通过分析器知道了要做什么，通过优化器知道了如何做，于是就进入了执行器阶段。</p>
</li>
<li><p>执行器开始执行之前，需要检查一下用户对表table有没有执行的权限，没有返回权限不足的错误，有的话就执行。</p>
</li>
<li><p>执行也是分类的，如果Id不是索引则全表扫描，一行一行的查找，如果是索引则在索引组织表中查询，索引的查询很复杂，其中涉及到B+树等算法，这里不再详细介绍。</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>一条SQL语句在MYSQL内部执行的过程涉及到的内部模块有：连接器、查询缓存、分析器、优化器、执行器、存储引擎。</p>
</li>
<li><p>至此，MYSQL的基础架构已经讲完了。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Mysql在中小型企业中是个香饽饽，目前主流的数据库之一，几乎没有一个后端开发者不会使用的，但是作为一个老司机，仅仅会用真
    
    </summary>
    
      <category term="数据库干货篇" scheme="http://chenjiabing666.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B2%E8%B4%A7%E7%AF%87/"/>
    
    
      <category term="SQL" scheme="http://chenjiabing666.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Mysql中的三类锁，你知道吗？</title>
    <link href="http://chenjiabing666.github.io/2020/04/01/Mysql%E4%B8%AD%E7%9A%84%E4%B8%89%E7%B1%BB%E9%94%81%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F/"/>
    <id>http://chenjiabing666.github.io/2020/04/01/Mysql中的三类锁，你知道吗？/</id>
    <published>2020-04-01T02:31:58.000Z</published>
    <updated>2020-04-01T02:34:41.438Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li><p>正所谓有人(锁)的地方就有江湖(事务)，人在江湖飘，怎能一无所知？</p>
</li>
<li><p>今天来细说一下Mysql中的三类锁，分别是全局锁、表级锁、行级锁。</p>
</li>
</ul>
<h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><ul>
<li>全局锁简单的说就是锁住整个数据库实例，命令是<code>Flush tables with read lock</code>。当你需要为整个数据库处于只读的状态的时候，可以使用这个命令。</li>
<li>一旦使用全局锁，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。 </li>
<li>全局锁的使用场景大部分都是用来<strong>数据库备份</strong>。</li>
</ul>
<h3 id="为什么备份要加全局锁？"><a href="#为什么备份要加全局锁？" class="headerlink" title="为什么备份要加全局锁？"></a>为什么备份要加全局锁？</h3><ul>
<li>用户买东西，首先会从余额里扣除金额，然后在订单里添加商品。如果备份数据库，不加锁，并且备份顺序为先备份用余额，再备份订单商品，有可能备份了用户余额后，用户下订单买东西提交事务，然后再备份订单商品表， 此时订单商品已存在。最后备份出来的数据为。最后用户余额为买东西前的余额，没有减少，但是订单商品却多了。演示如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/1.png" alt=""></p>
<ul>
<li>这种情况可能用户会觉得赚了，但是如果备份顺序反过来，先备份商品表再备份余额表，用户就会发现我付了钱，但是商品没有加，这中结果就会更加的严重。 </li>
<li>因此保证备份数据的一致性很重要，必要的手段就是加锁。</li>
</ul>
<h3 id="全局锁有什么坏处？"><a href="#全局锁有什么坏处？" class="headerlink" title="全局锁有什么坏处？"></a>全局锁有什么坏处？</h3><ul>
<li>全局锁是个啥？介绍完了读者心里已经有数了，让这个库只读？这是多么可怕的操作，简单列举几个危险之处：<ul>
<li>如果在主库备份，备份期间不能执行任何更新操作，会导致整个业务停摆，高并发情况下更甚。</li>
<li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。</li>
</ul>
</li>
</ul>
<h3 id="全局备份比较好的解决方案"><a href="#全局备份比较好的解决方案" class="headerlink" title="全局备份比较好的解决方案"></a>全局备份比较好的解决方案</h3><ul>
<li>全局锁远瞅不错，近瞅吓一跳，陈某在此不推荐使用。</li>
<li>其实 官方自带的逻辑备份工具是mysqldump。当<strong>mysqldump</strong>使用参数<strong>–single-transaction</strong>的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。 </li>
<li>一致性备份是好，但前提是存储引擎支持事务，这也是MyISAM被InnoDB取代的原因之一。</li>
</ul>
<h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><ul>
<li>MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。 </li>
<li>表锁一般是在数据库引擎不支持行锁的时候才会被用到的 。</li>
<li>MDL会直到事务提交才释放，在做<strong>表结构变更</strong>的时候，你一定要小心不要导致锁住线上查询和更新 。</li>
</ul>
<h3 id="如何加表锁"><a href="#如何加表锁" class="headerlink" title="如何加表锁"></a>如何加表锁</h3><ul>
<li>显式加表锁和解锁的语句很简单，如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">lock</span> <span class="keyword">tables</span> tb_name <span class="keyword">read</span>/write;</div><div class="line"></div><div class="line"><span class="keyword">unlock</span> <span class="keyword">tables</span>;</div></pre></td></tr></table></figure>
<ul>
<li>需要注意，lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。 </li>
<li>举个例子, 如果在某个线程A中执行<strong>lock tables t1 read, t2 write;</strong> 这个语句，则其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行<strong>unlock tables</strong>之前，也只能执行读t1、读写t2的操作。连写t1都不允许，自然也不能访问其他表。 </li>
</ul>
<h3 id="MDL"><a href="#MDL" class="headerlink" title="MDL"></a>MDL</h3><ul>
<li>MDL不需要显式使用，在访问一个表的时候会被自动加上。 </li>
<li>当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。 </li>
<li><strong>读锁</strong>之间不互斥，因此你可以有多个线程同时对一张表增删改查。 </li>
<li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。 </li>
</ul>
<h3 id="查询表级锁争用"><a href="#查询表级锁争用" class="headerlink" title="查询表级锁争用"></a>查询表级锁争用</h3><ul>
<li>查询表级锁的争用可以通过以下参数分析获得：<ul>
<li><code>Table_locks_immediate</code>：能够立即获得表级锁的次数 </li>
<li><code>Table_locks_waited</code>： 不能立即获取表级锁而需要等待的次数 </li>
</ul>
</li>
<li>查询语句如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'table_locks_waited'</span></div></pre></td></tr></table></figure>
<ul>
<li>如果<code>Table_locks_waited</code>的值比较大，则说明存在着较严重的表级锁争用情况。 </li>
</ul>
<h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><ul>
<li>MySQL的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如MyISAM引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB是支持行锁的，这也是MyISAM被InnoDB替代的重要原因之一。 </li>
<li><strong>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁</strong>。 </li>
<li><strong>在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。</strong> </li>
<li>行级锁分为排它锁（写锁）、共享锁（读锁）、间隙锁。</li>
</ul>
<h3 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h3><ul>
<li>排他锁，也称写锁，独占锁，当前写操作没有完成前，它会阻断其他写锁和读锁。 </li>
<li>Mysql中的更新语句(update/delete/insert)会自动加上排它锁。</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/2.png" alt=""></p>
<ul>
<li>如上图，事务B中的update语句被阻塞了，直到事务A提交才能执行更新操作。</li>
<li>排他锁也可以手动添加，如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</div></pre></td></tr></table></figure>
<ul>
<li>注意以下两点：<ul>
<li>行锁是针对索引加锁的，上述例子中id是主键索引。</li>
<li><strong>加了排他锁并不是其他的事务不能读取这行的数据，而是不能再在这行上面加锁了。</strong></li>
</ul>
</li>
</ul>
<h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><ul>
<li>当我们用范围条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但<strong>并不存在</strong>的记录，叫做”间隙(GAP)”。InnoDB也会对这个”间隙”加锁，这种锁机制就是所谓的间隙锁(Next-Key锁)。 </li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/3.png" alt=""></p>
<ul>
<li>如上图，给id&gt;5中并不存在的数据加上了间隙锁，当插入id=6的数据时被阻塞了。</li>
<li>这是一个坑：<strong>若执行的条件是范围过大，则InnoDB会将整个范围内所有的索引键值全部锁定，很容易对性能造成影响</strong> </li>
</ul>
<h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3><ul>
<li>共享锁，也称读锁，多用于判断数据是否存在，多个读操作可以同时进行而不会互相影响。当如果事务对读锁进行修改操作，很可能会造成死锁。如下图所示。 </li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/4.png" alt=""></p>
<h3 id="分析行锁定"><a href="#分析行锁定" class="headerlink" title="分析行锁定"></a>分析行锁定</h3><ul>
<li>通过检查InnoDB_row_lock 状态变量分析系统上的行锁的争夺情况 。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'innodb_row_lock%'</span></div></pre></td></tr></table></figure>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/5.png" alt=""></p>
<ul>
<li>innodb_row_lock_current_waits: 当前正在等待锁定的数量。</li>
<li>innodb_row_lock_time: 从系统启动到现在锁定总时间长度；非常重要的参数</li>
<li>innodb_row_lock_time_avg: 每次等待所花平均时间；非常重要的参数。</li>
<li>innodb_row_lock_time_max: 从系统启动到现在等待最常的一次所花的时间； </li>
<li>innodb_row_lock_waits: 系统启动后到现在总共等待的次数；非常重要的参数。直接决定优化的方向和策略。 </li>
</ul>
<h3 id="死锁解决方案"><a href="#死锁解决方案" class="headerlink" title="死锁解决方案"></a>死锁解决方案</h3><p>1、直接进入等待，直到超时。这个超时时间可以通过参数<strong>innodb_lock_wait_timeout</strong>来设置，默认50秒。注意超时时间不能设置太短，如果仅仅是短暂的等待，一旦设置时间很短，很快便解锁了，会出现误伤。</p>
<p>2、发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数<strong>innodb_deadlock_detect</strong>设置为on，表示开启这个逻辑，默认开启。 主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。 当并发很高的时候，检测死锁将会消耗大量的资源，因此控制并发也是很重要的一种策略。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;正所谓有人(锁)的地方就有江湖(事务)，人在江湖飘，怎能一无所知？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;今天来细说一下Mys
    
    </summary>
    
      <category term="数据库干货篇" scheme="http://chenjiabing666.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B2%E8%B4%A7%E7%AF%87/"/>
    
    
      <category term="SQL" scheme="http://chenjiabing666.github.io/tags/SQL/"/>
    
  </entry>
  
</feed>
