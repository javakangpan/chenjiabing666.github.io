<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>爱撒谎的男孩</title>
  <subtitle>一只程序猿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chenjiabing666.github.io/"/>
  <updated>2019-06-30T06:22:33.196Z</updated>
  <id>http://chenjiabing666.github.io/</id>
  
  <author>
    <name>Chenjiabing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring中的事件</title>
    <link href="http://chenjiabing666.github.io/2019/06/30/Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6/"/>
    <id>http://chenjiabing666.github.io/2019/06/30/Spring中的事件/</id>
    <published>2019-06-30T06:22:07.000Z</published>
    <updated>2019-06-30T06:22:33.196Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>学过编程语言的肯定知道事件，在JS中事件，Android中的事件，大多是鼠标点击，键盘事件，手指滑动事件等等。在Spring中也有一些事件，比如容器启动、容器关闭、容器刷新都是一个事件。</li>
<li>既然有了事件，自然少不了事件监听器，事件分发器等，后续会详细介绍</li>
</ul>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="Spring中内置的事件"><a href="#Spring中内置的事件" class="headerlink" title="Spring中内置的事件"></a>Spring中内置的事件</h2><ul>
<li><code>ContextStartedEvent</code>：容器启动的时候触发(start方法)</li>
<li><code>ContextRefreshedEvent</code>：容器刷新的时候触发(onRefresh，在finisRefresh中调用)</li>
<li><code>ContextStoppedEvent</code>：容器停止的时候触发(stop方法)</li>
<li><code>ContextClosedEvent</code>：容器关闭的时候触发(close方法)</li>
</ul>
<h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><ul>
<li>Spring中自定义事件只需要继承<code>ApplicationEvent</code>即可完成一个自定义的Spring事件<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义事件，继承ApplicationEvent</div><div class="line"> */</div><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 需要携带的消息，可以是任意类型的数据，相当于传递数据</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> String message;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造方法</div><div class="line">     * <span class="doctag">@param</span> source 事件发生的类</div><div class="line">     * <span class="doctag">@param</span> message 携带的消息</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FirstEvent</span><span class="params">(Object source,String message)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(source);</div><div class="line">        <span class="keyword">this</span>.message=message;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h1><ul>
<li>监听器用来监听事件触发，一旦事件触发了，监听器会执行相应的操作。</li>
<li>监听器的实现有两种方式：<ul>
<li>实现<code>ApplicationListener</code>接口</li>
<li>使用<code>@EventListener</code>注解</li>
</ul>
</li>
</ul>
<h2 id="实现ApplicationListener接口"><a href="#实现ApplicationListener接口" class="headerlink" title="实现ApplicationListener接口"></a>实现ApplicationListener接口</h2><ul>
<li><p>创建监听器需要两个条件：</p>
<ul>
<li>实现ApplicationListener接口</li>
<li>将该自定义的监听器注入到ioc容器中<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义一个监听器，实现ApplicationListener，指定的泛型就是需要监听的事件</div><div class="line"> * 监听ContextRefreshedEvent，当容器完成刷新的时候该监听器就会监听到并执行onApplicationEvent方法</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 重载方法，被监听的事件触发了就会调用这个方法</div><div class="line">     * <span class="doctag">@param</span> event 触发事件的对象</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"容器刷新的监听器启动了........"</span>);</div><div class="line">        System.out.println(event.getSource()+<span class="string">"----&gt;"</span>+event.getTimestamp()+<span class="string">"----"</span>+event.getApplicationContext());</div><div class="line">        System.out.println(<span class="string">"........................................."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>此时只要启动容器，自定义的监听器就会起作用，当然我们监听的是Spring内置的事件，在容器启动的时候Spring会使用事件发布器发布事件，此时才是真正的触发事件，我们自定义的事件并不能被监听，除非被事件发布器发布。</p>
</li>
</ul>
<h2 id="使用-EventListener注解"><a href="#使用-EventListener注解" class="headerlink" title="使用@EventListener注解"></a>使用@EventListener注解</h2><ul>
<li>常见的属性：<ul>
<li><code>classes</code>：Class数组，指定需要监听的事件</li>
<li><code>condition</code>：指定条件，默认监听<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 注解方式实现事件监听器</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomEventListener</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 使用<span class="doctag">@EventListener</span>监听事件</div><div class="line">     * <span class="doctag">@param</span> event 传入的事件源</div><div class="line">     */</div><div class="line">    <span class="meta">@EventListener</span>(classes = &#123;ApplicationEvent.class&#125;)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerContextRefreshEvent</span><span class="params">(ApplicationEvent event)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextRefreshedEvent) &#123;</div><div class="line">            ContextRefreshedEvent e=(ContextRefreshedEvent)event;</div><div class="line">            System.out.println(<span class="string">"ContextRefreshedEvent启动了........"</span>);</div><div class="line">            System.out.println(event.getSource() + <span class="string">"----&gt;"</span> + event.getTimestamp() + <span class="string">"----"</span> + e.getApplicationContext());</div><div class="line">            System.out.println(<span class="string">"........................................."</span>);</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(event <span class="keyword">instanceof</span> ContextStartedEvent)&#123;</div><div class="line">            ContextStartedEvent e=(ContextStartedEvent)event;</div><div class="line">            System.out.println(<span class="string">"ContextStartedEvent启动了........"</span>);</div><div class="line">            System.out.println(event.getSource() + <span class="string">"----&gt;"</span> + event.getTimestamp() + <span class="string">"----"</span> + e.getApplicationContext());</div><div class="line">            System.out.println(<span class="string">"........................................."</span>);</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(event <span class="keyword">instanceof</span> ContextStoppedEvent)&#123;</div><div class="line">            ContextStoppedEvent e=(ContextStoppedEvent)event;</div><div class="line">            System.out.println(<span class="string">"ContextStoppedEvent启动了........"</span>);</div><div class="line">            System.out.println(event.getSource() + <span class="string">"----&gt;"</span> + event.getTimestamp() + <span class="string">"----"</span> + e.getApplicationContext());</div><div class="line">            System.out.println(<span class="string">"........................................."</span>);</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(event <span class="keyword">instanceof</span> ContextClosedEvent)&#123;</div><div class="line">            ContextClosedEvent e=(ContextClosedEvent)event;</div><div class="line">            System.out.println(<span class="string">"ContextClosedEvent启动了........"</span>);</div><div class="line">            System.out.println(event.getSource() + <span class="string">"----&gt;"</span> + event.getTimestamp() + <span class="string">"----"</span> + e.getApplicationContext());</div><div class="line">            System.out.println(<span class="string">"........................................."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 可以不指定classes，默认监听的是方法参数中的事件</div><div class="line">     * <span class="doctag">@param</span> event 事件源</div><div class="line">     */</div><div class="line">    <span class="meta">@EventListener</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleFirstEvent</span><span class="params">(FirstEvent event)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"firstEvent事件启动了，。。。。。。。。。"</span>);</div><div class="line">        System.out.println(event.getSource()+<span class="string">"----&gt;"</span>+event.getMessage());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="事件发布"><a href="#事件发布" class="headerlink" title="事件发布"></a>事件发布</h1><ul>
<li>Spring中发布事件的接口是<code>ApplicationEventPublisher</code>，我们可以自定义自己的类，当然也可以使用spring现成的类</li>
</ul>
<h2 id="Spring的事件发布类"><a href="#Spring的事件发布类" class="headerlink" title="Spring的事件发布类"></a>Spring的事件发布类</h2><ul>
<li>ApplicationContext</li>
<li>AnnotationConfigApplicationContext</li>
</ul>
<h2 id="直接注入"><a href="#直接注入" class="headerlink" title="直接注入"></a>直接注入</h2><ul>
<li><p>在容器启动刷新的时候已经注入了<code>ApplicationEventPublisher</code>的实现，我们可以直接注入使用。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义的事件发布器</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomPublisher</span>  </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 直接注入ApplicationEventPublisher</div><div class="line">     */</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 发布事件</div><div class="line">     * <span class="doctag">@param</span> event 指定的事件</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span></span>&#123;</div><div class="line">        applicationEventPublisher.publishEvent(event);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</div><div class="line">    CustomPublisher customPublisher = applicationContext.getBean(CustomPublisher.class);</div><div class="line">    customPublisher.publishEvent(<span class="keyword">new</span> FirstEvent(<span class="keyword">this</span>,<span class="string">"启动自定义事件"</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="使用ApplicationEventPublisherAware注入"><a href="#使用ApplicationEventPublisherAware注入" class="headerlink" title="使用ApplicationEventPublisherAware注入"></a>使用ApplicationEventPublisherAware注入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义的事件发布器，实现ApplicationEventPublisherAware接口</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomPublisher</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 发布事件</div><div class="line">     * <span class="doctag">@param</span> event 指定的事件</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span></span>&#123;</div><div class="line">        applicationEventPublisher.publishEvent(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.applicationEventPublisher=applicationEventPublisher;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="事件多播器"><a href="#事件多播器" class="headerlink" title="事件多播器"></a>事件多播器</h1><ul>
<li>何为事件多播器【<code>ApplicationEventMulticaster</code>】？<ul>
<li>简单的说事件多播器就是一个管理事件监听器并且广播事件【根据指定的事件调用指定的监听器而已】</li>
</ul>
</li>
<li>spring中两个实现类分别为<code>AbstractApplicationEventMulticaster</code>、<code>SimpleApplicationEventMulticaster</code></li>
<li>如何广播事件？【如何通过指定的事件调用指定的监听器】<ul>
<li>真正的实现在<code>org.springframework.context.event.SimpleApplicationEventMulticaster#multicastEvent(org.springframework.context.ApplicationEvent, org.springframework.core.ResolvableType)</code>这个方法中，如下：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, @Nullable ResolvableType eventType)</span> </span>&#123;</div><div class="line">		ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</div><div class="line">        <span class="comment">//遍历事件监听器</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">final</span> ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</div><div class="line">            <span class="comment">//判断是否设置了Executor，如果存在，那么就异步执行</span></div><div class="line">			Executor executor = getTaskExecutor();</div><div class="line">			<span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</div><div class="line">				executor.execute(() -&gt; invokeListener(listener, event));</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//否则的话，同步执行，调用invokeListener</span></div><div class="line">				invokeListener(listener, event);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/****************************************invokeListener******************************/</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeListener</span><span class="params">(ApplicationListener&lt;?&gt; listener, ApplicationEvent event)</span> </span>&#123;</div><div class="line">    	<span class="comment">//如果有异常处理器，就try-catch执行</span></div><div class="line">		ErrorHandler errorHandler = getErrorHandler();</div><div class="line">		<span class="keyword">if</span> (errorHandler != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				doInvokeListener(listener, event);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">catch</span> (Throwable err) &#123;</div><div class="line">                <span class="comment">//如果有异常了，执行异常处理器的handleError方法</span></div><div class="line">				errorHandler.handleError(err);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//没有异常处理器直接执行</span></div><div class="line">			doInvokeListener(listener, event);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"><span class="comment">/*******************************doInvokeListener****************************/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doInvokeListener</span><span class="params">(ApplicationListener listener, ApplicationEvent event)</span> </span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//此时真正调用监听器中的方法</span></div><div class="line">			listener.onApplicationEvent(event);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (ClassCastException ex) &#123;</div><div class="line">			String msg = ex.getMessage();</div><div class="line">			<span class="keyword">if</span> (msg == <span class="keyword">null</span> || matchesClassCastMessage(msg, event.getClass())) &#123;</div><div class="line">				<span class="comment">// Possibly a lambda-defined listener which we could not resolve the generic event type for</span></div><div class="line">				<span class="comment">// -&gt; let's suppress the exception and just log a debug message.</span></div><div class="line">				Log logger = LogFactory.getLog(getClass());</div><div class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">					logger.debug(<span class="string">"Non-matching event type for listener: "</span> + listener, ex);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				<span class="keyword">throw</span> ex;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h1 id="异步事件"><a href="#异步事件" class="headerlink" title="异步事件"></a>异步事件</h1><ul>
<li>前面创建的事件和监听器都是同步进行，我们可以使用异步事件</li>
</ul>
<h2 id="使用-Async实现异步"><a href="#使用-Async实现异步" class="headerlink" title="使用@Async实现异步"></a>使用@Async实现异步</h2><ul>
<li><p>Spring中可以使用<code>@Async</code>注解标注方法异步执行，不过需要在配置类上开启异步功能，使用<code>@EnableAsync</code>注解，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ComponentScan</span>(value = &#123;<span class="string">"cn.tedu.demo"</span>&#125;)</div><div class="line"><span class="meta">@EnableAsync</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstConfig</span> </span>&#123;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>此时可以在监听方法上标注<code>@Async</code>注解，使得事件异步执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 注解方式实现事件监听器</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomEventListener</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 可以不指定classes，默认监听的是方法参数中的事件</div><div class="line">     * <span class="doctag">@Async</span> : 指定这个方法异步执行</div><div class="line">     * <span class="doctag">@param</span> event 事件源</div><div class="line">     */</div><div class="line">    <span class="meta">@EventListener</span></div><div class="line">    <span class="meta">@Async</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleFirstEvent</span><span class="params">(FirstEvent event)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"firstEvent事件启动了，。。。。。。。。。"</span>);</div><div class="line">        System.out.println(event.getSource()+<span class="string">"----&gt;"</span>+event.getMessage());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="自定义事件多播器"><a href="#自定义事件多播器" class="headerlink" title="自定义事件多播器"></a>自定义事件多播器</h2><ul>
<li>从源码我们可以知道，spring容器加载的时候先获取的是ioc容器中的，如果不存在，那么才会新建一个<code>SimpleApplicationEventMulticaster</code>，我们可以自己注入一个多播器直接使用即可。</li>
<li><p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</div><div class="line">		ConfigurableListableBeanFactory beanFactory = getBeanFactory();</div><div class="line">		<span class="comment">//判断ioc容器中是否存在id为applicationEventMulticaster事件多播器</span></div><div class="line">		<span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</div><div class="line">		    <span class="comment">//直接使用ioc容器中的</span></div><div class="line">			<span class="keyword">this</span>.applicationEventMulticaster =</div><div class="line">					beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</div><div class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</div><div class="line">				logger.trace(<span class="string">"Using ApplicationEventMulticaster ["</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">"]"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">		    <span class="comment">//新建一个，不过没有设置TaskExector</span></div><div class="line">			<span class="keyword">this</span>.applicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</div><div class="line">			beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</div><div class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</div><div class="line">				logger.trace(<span class="string">"No '"</span> + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + <span class="string">"' bean, using "</span> +</div><div class="line">						<span class="string">"["</span> + <span class="keyword">this</span>.applicationEventMulticaster.getClass().getSimpleName() + <span class="string">"]"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>从源码中【<code>org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(org.springframework.context.ApplicationEvent, org.springframework.core.ResolvableType)</code>】我们可以看出监听器的执行是先判断多播器中是否存在<code>Executor</code>,如果存在，那么就单独开启一个线程执行，否则就同步执行，我们在初始化多播器的时候，可以为其设置一个<code>Executor</code>，那么就可以异步执行了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, @Nullable ResolvableType eventType)</span> </span>&#123;</div><div class="line">		ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">final</span> ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</div><div class="line">			Executor executor = getTaskExecutor();</div><div class="line">			<span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</div><div class="line">				executor.execute(() -&gt; invokeListener(listener, event));</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				invokeListener(listener, event);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>实现：在配置类注入一个多播器即可，bean的id一定要是<code>applicationEventMulticaster</code>，同时为其设置一个<code>executor</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义一个事件多播器，用来管理监听器和执行监听器</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="meta">@Bean</span>(name = <span class="string">"applicationEventMulticaster"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> ApplicationEventMulticaster <span class="title">applicationEventMulticaster</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//事件多播器</span></div><div class="line">    SimpleApplicationEventMulticaster simpleApplicationEventMulticaster=<span class="keyword">new</span> SimpleApplicationEventMulticaster();</div><div class="line">    <span class="comment">//设置executor</span></div><div class="line">    SimpleAsyncTaskExecutor executor=<span class="keyword">new</span> SimpleAsyncTaskExecutor();</div><div class="line">    simpleApplicationEventMulticaster.setTaskExecutor(executor);</div><div class="line">    <span class="comment">//设置一个事件异常处理器，当监听器执行出现错误了会进行补救</span></div><div class="line">    simpleApplicationEventMulticaster.setErrorHandler(t-&gt;&#123;</div><div class="line">        <span class="comment">//这里可以针对不同的异常进行处理，在监听器中trycatch，不同执行抛出不同异常即可分类处理</span></div><div class="line">        System.out.println(<span class="string">"监听事件执行报错了"</span>);</div><div class="line">        System.out.println(t.getMessage());</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> simpleApplicationEventMulticaster;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><ul>
<li>在spring源码中和事件涉及到的主要概念如下：<ul>
<li>事件（ApplicationEvent）</li>
<li>监听器（ApplicationEventListener）</li>
<li>事件发布器（ApplicationEventPublisher）</li>
<li>事件多播器（ApplicationEventMulticaster）</li>
</ul>
</li>
<li>具体源码层面的涉及如下：<ul>
<li>容器刷新<code>refresh</code>方法中：<ul>
<li><code>initApplicationEventMulticaster()</code>：初始化事件多播器</li>
<li><code>registerListeners();</code>：注册事件监听器</li>
<li><code>finishRefresh()</code>方法中调用<code>publishEvent(new ContextRefreshedEvent(this))</code>方法发布容器刷新事件。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>​    </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;学过编程语言的肯定知道事件，在JS中事件，Android中的事件，大多是鼠标点击，键盘事件，手指滑动事件等等。在Spring中也
    
    </summary>
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>BeanFactoryPostProcessor解析</title>
    <link href="http://chenjiabing666.github.io/2019/06/27/BeanFactoryPostProcessor%E8%A7%A3%E6%9E%90/"/>
    <id>http://chenjiabing666.github.io/2019/06/27/BeanFactoryPostProcessor解析/</id>
    <published>2019-06-27T15:34:47.000Z</published>
    <updated>2019-06-27T15:35:13.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>Spring IoC容器允许BeanFactoryPostProcessor在容器实例化任何bean之前读取bean的定义(配置元数据)，并可以修改它。同时可以定义多个BeanFactoryPostProcessor，通过设置’order’属性来确定各个BeanFactoryPostProcessor执行顺序。</li>
</ul>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"MyBeanFactoryPostProcessor开始执行"</span>);</div><div class="line">        String[] beanDefinitionNames = beanFactory.getBeanDefinitionNames();</div><div class="line">        <span class="keyword">for</span> (String name : beanDefinitionNames) &#123;</div><div class="line">            <span class="keyword">if</span> (name.equals(<span class="string">"user"</span>))&#123;</div><div class="line">                BeanDefinition beanDefinition = beanFactory.getBeanDefinition(name);</div><div class="line">                MutablePropertyValues propertyValues = beanDefinition.getPropertyValues();</div><div class="line">                propertyValues.add(<span class="string">"name"</span>,<span class="string">"Jack"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><ul>
<li>在刷新ioc容器的方法<code>org.springframework.context.support.AbstractApplicationContext.refresh</code>中执行，如下图：<br><img src="https://github.com/chenjiabing666/BlogImage/blob/master/spring20.png?raw=true" alt=""></li>
</ul>
<h1 id="BeanDefinitionRegistryPostProcessor"><a href="#BeanDefinitionRegistryPostProcessor" class="headerlink" title="BeanDefinitionRegistryPostProcessor"></a>BeanDefinitionRegistryPostProcessor</h1><ul>
<li>后续更新。。。。</li>
</ul>
<h1 id="MergedBeanDefinitionPostProcessor"><a href="#MergedBeanDefinitionPostProcessor" class="headerlink" title="MergedBeanDefinitionPostProcessor"></a>MergedBeanDefinitionPostProcessor</h1><ul>
<li>后续更新</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Spring IoC容器允许BeanFactoryPostProcessor在容器实例化任何bean之前读取bean的定义(配置
    
    </summary>
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>BeanWrapper解析</title>
    <link href="http://chenjiabing666.github.io/2019/06/27/BeanWrapper%E8%A7%A3%E6%9E%90/"/>
    <id>http://chenjiabing666.github.io/2019/06/27/BeanWrapper解析/</id>
    <published>2019-06-27T15:33:20.000Z</published>
    <updated>2019-06-27T15:33:53.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>BeanWrapper是Spring底层经常使用的一个接口，简单来说是对Bean的一种包装，包括对Bean的属性、方法，数据等。</li>
<li>唯一的一个实现类是<code>BeanWrapperImpl</code>，继承和实现关系图如下：<br><img src="https://github.com/chenjiabing666/BlogImage/blob/master/ssss.png?raw=true" alt=""></li>
</ul>
<h1 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h1><ul>
<li><code>public BeanWrapperImpl(Object object)</code>：指定对象构造</li>
<li><code>public BeanWrapperImpl(Class&lt;?&gt; clazz)</code>：指定Class构造，内部会通过反射调用clazz的默认无参构造方法进行实例化</li>
<li><code>public final Object getWrappedInstance()</code>：获取对象实例</li>
<li><code>public PropertyDescriptor getPropertyDescriptor(String propertyName</code>：获取指定属性的PropertyDescriptor </li>
<li><code>public PropertyDescriptor[] getPropertyDescriptors()</code>：获取所有属性的PropertyDescriptor【包括继承而来的】</li>
<li><code>public Object getPropertyValue(String propertyName)</code>：获取指定属性的值</li>
</ul>
<h1 id="PropertyDescriptor"><a href="#PropertyDescriptor" class="headerlink" title="PropertyDescriptor"></a>PropertyDescriptor</h1><ul>
<li>简称属性描述器，是对属性的封装，包括属性的类型，值，get和set方法，可以通过属性描述器可以很简单的获取和修改对应的值。</li>
<li>两个概念如下：<ul>
<li><code>ReadMethod</code>：即是对应属性的get方法</li>
<li><code>WriteMethod</code>：即是对应属性的set方法</li>
</ul>
</li>
</ul>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><ul>
<li>我们可以同<code>BeanWrapper</code>和<code>PropertyDescriptor</code>可以很轻松实现属性的复制，下面是本人手写的一个复制的工具类【当然这个是很粗糙的，和BeanUtils中的copyPropreties方法不能相提并论，不喜勿喷】<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 对象复制【浅克隆】</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewCopyUtils</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLASS=<span class="string">"class"</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 复制对象【只能复制基本数据类型，浅克隆】</div><div class="line">     * <span class="doctag">@param</span> source 源对象</div><div class="line">     * <span class="doctag">@param</span> target 目标对象</div><div class="line">     * <span class="doctag">@param</span> ingoreAgrs 忽略的属性</div><div class="line">     * <span class="doctag">@throws</span> Exception</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyProperties</span><span class="params">(Object source,Object target,String... ingoreAgrs)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">if</span> (source.getClass().isInterface()||target.getClass().isInterface())&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"source和target不能为接口"</span>);</div><div class="line">        &#125;</div><div class="line">        BeanWrapper sourceWrap = createBeanWrap(source);</div><div class="line">        BeanWrapper targetWrap = createBeanWrap(target);</div><div class="line">        PropertyDescriptor[] targetPds = targetWrap.getPropertyDescriptors();</div><div class="line">        PropertyDescriptor[] sourcePds = sourceWrap.getPropertyDescriptors();</div><div class="line">        <span class="comment">//根据名称分组，减少一层循环</span></div><div class="line">        Map&lt;String, List&lt;PropertyDescriptor&gt;&gt; map = Arrays.asList(sourcePds).parallelStream().filter(o -&gt; !StringUtils.equals(CLASS, o.getName())).collect(Collectors.groupingBy(o -&gt; o.getName()));</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; targetPds.length; i++) &#123;</div><div class="line">            PropertyDescriptor tpd=targetPds[i];</div><div class="line">            <span class="comment">//去掉class属性和不要的复制的属性</span></div><div class="line">            <span class="keyword">if</span> (!StringUtils.equals(CLASS,tpd.getName())&amp;&amp; !Arrays.asList(ingoreAgrs).contains(tpd.getName()))&#123;</div><div class="line">                List&lt;PropertyDescriptor&gt; list = map.getOrDefault(tpd.getName(), <span class="keyword">null</span>);</div><div class="line">                <span class="keyword">if</span> (Objects.nonNull(list))&#123;</div><div class="line">                    Method writeMethod = tpd.getWriteMethod();</div><div class="line">                    Method readMethod = list.get(<span class="number">0</span>).getReadMethod();</div><div class="line">                    <span class="keyword">if</span> (Objects.isNull(writeMethod)&amp;&amp;Objects.isNull(readMethod))&#123;</div><div class="line">                        <span class="keyword">throw</span>  <span class="keyword">new</span> Exception(<span class="string">"属性必须有get和set方法"</span>);</div><div class="line">                    &#125;</div><div class="line">                    Object o = readMethod.invoke(source);</div><div class="line">                    writeMethod.invoke(target,o);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造BeanWrapImpl</div><div class="line">     * <span class="doctag">@param</span> source 对象</div><div class="line">     * <span class="doctag">@return</span> BeanWrapper</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanWrapper <span class="title">createBeanWrap</span><span class="params">(Object source)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanWrapperImpl(source);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;BeanWrapper是Spring底层经常使用的一个接口，简单来说是对Bean的一种包装，包括对Bean的属性、方法，数据等。
    
    </summary>
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>InstantiationAwareBeanPostProcessor源码解析</title>
    <link href="http://chenjiabing666.github.io/2019/06/25/InstantiationAwareBeanPostProcessor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://chenjiabing666.github.io/2019/06/25/InstantiationAwareBeanPostProcessor源码解析/</id>
    <published>2019-06-25T13:24:43.000Z</published>
    <updated>2019-06-25T13:54:19.629Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>继承<code>BeanPostProcessor</code>接口，在此基础上又定义了三个方法，分别在Bean<strong>实例化前后【不是初始化】</strong>执行。</li>
<li>从上面的介绍可以看到，这个接口相对于BeanPostProcessor功能更加强大，一个接口承担了Bean的实例化前后、初始化前后责任。</li>
</ul>
<h1 id="Bean加载顺序"><a href="#Bean加载顺序" class="headerlink" title="Bean加载顺序"></a>Bean加载顺序</h1><ul>
<li>ioc容器创建加载Bean的执行顺序如下：<ul>
<li>InstantiationAwareBeanPostProcessor接口中的<code>postProcessBeforeInstantiation</code>，在实例化之前调用</li>
<li>Bean的实例化，调用构造方法</li>
<li>InstantiationAwareBeanPostProcessor接口中的<code>postProcessAfterInstantiation</code>，在实例化之后调用</li>
<li>InstantiationAwareBeanPostProcessor接口中的<code>postProcessPropertyValues</code><strong>【当postProcessAfterInstantiation返回true才执行】</strong></li>
<li>BeanPostProcessor接口中的<code>postProcessBeforeInitialization</code>，在初始化之前调用</li>
<li>InitializingBean中的afterProperties方法，执行初始化</li>
<li>BeanPostProcessor接口中的<code>postProcessAfterInitialization</code>，在实例化之后调用</li>
</ul>
</li>
</ul>
<h1 id="InstantiationAwareBeanPostProcessor接口方法的执行顺序"><a href="#InstantiationAwareBeanPostProcessor接口方法的执行顺序" class="headerlink" title="InstantiationAwareBeanPostProcessor接口方法的执行顺序"></a>InstantiationAwareBeanPostProcessor接口方法的执行顺序</h1><ul>
<li>正常的执行顺序如下：<ul>
<li>postProcessBeforeInstantiation</li>
<li>postProcessAfterInstantiation</li>
<li>postProcessProperties</li>
<li>postProcessBeforeInitialization</li>
<li>postProcessAfterInitialization</li>
</ul>
</li>
</ul>
<h1 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h1><ul>
<li><p><code>Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName)</code>：在实例化之前执行【构造方法之前执行】</p>
<ul>
<li>返回值：如果返回的不为<code>null</code>，那么后续的Bean的创建流程【实例化、初始化afterProperties】都不会执行，而是直接使用返回的快捷Bean，此时的正常执行顺序如下：<ul>
<li>InstantiationAwareBeanPostProcessor接口中的<code>postProcessBeforeInstantiation</code>，在实例化之前调用</li>
<li>BeanPostProcessor接口中的<code>postProcessAfterInitialization</code>，在实例化之后调用<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.resolveBeforeInstantiation </div><div class="line">* 作用：在实例化之前解析是否有快捷创建的Bean，既是通过postProcessBeforeInstantiation返回的Bean</div><div class="line">* 内部调用两个重要的方法：</div><div class="line">*   1、applyBeanPostProcessorsBeforeInstantiation：内部遍历调用postProcessBeforeInstantiation方法【在实例化之前调用】</div><div class="line">*   2、applyBeanPostProcessorsAfterInitialization：如果postProcessBeforeInstantiation方法返回了快捷的Bean，内部遍历调用postProcessBeforeInstantiation方法【在初始化之后调用】</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">resolveBeforeInstantiation</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</div><div class="line">		Object bean = <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;</div><div class="line">			<span class="comment">// Make sure bean class is actually resolved at this point.</span></div><div class="line">			<span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</div><div class="line">				Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);</div><div class="line">				<span class="keyword">if</span> (targetType != <span class="keyword">null</span>) &#123;</div><div class="line">				    <span class="comment">//调用方法，内部遍历调用postProcessBeforeInstantiation方法【在实例化之前调用】</span></div><div class="line">					bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</div><div class="line">					<span class="comment">//如果返回了快捷的Bean</span></div><div class="line">					<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</div><div class="line">					    <span class="comment">//如果postProcessBeforeInstantiation方法返回了快捷的Bean，内部遍历调用postProcessBeforeInstantiation方法【在初始化之后调用】</span></div><div class="line">						bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			mbd.beforeInstantiationResolved = (bean != <span class="keyword">null</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> bean;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	*   org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInstantiation</div><div class="line">	*   作用：调用postProcessBeforeInstantiation方法</div><div class="line">    */</div><div class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">applyBeanPostProcessorsBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span></span></div><div class="line">    			<span class="keyword">throws</span> BeansException &#123;</div><div class="line">	        <span class="comment">//遍历所有的后置处理器</span></div><div class="line">    		<span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</div><div class="line">    		    <span class="comment">//判断是否是InstantiationAwareBeanPostProcessor类型的，如果是的，调用postProcessBeforeInstantiation方法获取快捷Bean</span></div><div class="line">    			<span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</div><div class="line">    				InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</div><div class="line">    				Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);</div><div class="line">    				<span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</div><div class="line">    					<span class="keyword">return</span> result;</div><div class="line">    				&#125;</div><div class="line">    			&#125;</div><div class="line">    		&#125;</div><div class="line">    		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	*   org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization</div><div class="line">	*   作用：遍历调用postProcessAfterInitialization</div><div class="line">	*/</div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></div><div class="line">    			<span class="keyword">throws</span> BeansException &#123;</div><div class="line">    		Object result = existingBean;</div><div class="line">    		<span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</div><div class="line">    			result = beanProcessor.postProcessAfterInitialization(result, beanName);</div><div class="line">    			<span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">    				<span class="keyword">return</span> result;</div><div class="line">    			&#125;</div><div class="line">    		&#125;</div><div class="line">    		<span class="keyword">return</span> result;</div><div class="line">    	&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException</code>：正常情况下在实例化之后在执行<code>populateBean</code>之前调用</p>
<ul>
<li>返回值：如果有指定的bean的时候返回false，那么后续的属性填充和属性依赖注入【<code>populateBean</code>】将不会执行，同时后续的<code>postProcessPropertyValues</code>将不会执行,但是初始化和<code>BeanPostProcessor</code>的仍然会执行。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean</div><div class="line">* 填充指定Bean的属性</div><div class="line">* 在该方法内部遍历所有的BeanPostPorcessor，调用postProcessAfterInstantiation方法</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, BeanWrapper bw)</span> </span>&#123;</div><div class="line">        <span class="comment">//获取属性</span></div><div class="line">		PropertyValues pvs = mbd.getPropertyValues();</div><div class="line">		<span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">if</span> (!pvs.isEmpty()) &#123;</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</div><div class="line">						mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to null instance"</span>);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				<span class="comment">// Skip property population phase for null instance.</span></div><div class="line">				<span class="keyword">return</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">        <span class="comment">//**********************逻辑开始执行********************</span></div><div class="line">        <span class="comment">//标志，判断是否继续执行属性填充，默认为false</span></div><div class="line">		<span class="keyword">boolean</span> continueWithPropertyPopulation = <span class="keyword">true</span>;</div><div class="line">        <span class="comment">//判断ioc容器中是否存在InstantiationAwareBeanPostProcessors(</span></div><div class="line">		<span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</div><div class="line">		    <span class="comment">//遍历所有的BeanPostProcessor</span></div><div class="line">			<span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</div><div class="line">			    <span class="comment">//判断类型是InstantiationAwareBeanPostProcessor</span></div><div class="line">				<span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</div><div class="line">					InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</div><div class="line">					<span class="comment">//执行postProcessAfterInstantiation方法</span></div><div class="line">					<span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</div><div class="line">					    <span class="comment">//返回结果为false，那么赋值continueWithPropertyPopulation=false，表示不继续执行属性填充</span></div><div class="line">						continueWithPropertyPopulation = <span class="keyword">false</span>;</div><div class="line">						<span class="keyword">break</span>;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">        <span class="comment">//如果continueWithPropertyPopulation为false，直接返回，不执行下面的步骤</span></div><div class="line">		<span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">        <span class="comment">//</span></div><div class="line">		<span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</div><div class="line">				mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</div><div class="line">			MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</div><div class="line"></div><div class="line">			<span class="comment">// Add property values based on autowire by name if applicable.</span></div><div class="line">			<span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</div><div class="line">				autowireByName(beanName, mbd, bw, newPvs);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="comment">// Add property values based on autowire by type if applicable.</span></div><div class="line">			<span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</div><div class="line">				autowireByType(beanName, mbd, bw, newPvs);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			pvs = newPvs;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</div><div class="line">		<span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</div><div class="line">			PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</div><div class="line">			<span class="keyword">if</span> (hasInstAwareBpps) &#123;</div><div class="line">			    <span class="comment">//同样是遍历BeanPostProcessor</span></div><div class="line">				<span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</div><div class="line">					<span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</div><div class="line">						InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</div><div class="line">						<span class="comment">//执行postProcessPropertyValues方法</span></div><div class="line">						pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</div><div class="line">						<span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</div><div class="line">							<span class="keyword">return</span>;</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (needsDepCheck) &#123;</div><div class="line">				checkDependencies(beanName, mbd, filteredPds, pvs);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//重要的一步，设置属性</span></div><div class="line">		applyPropertyValues(beanName, mbd, bw, pvs);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</code>：实例化之后调用，在方法<code>applyPropertyValues</code>【属性填充】之前</p>
<ul>
<li>返回值：如果返回null，那么将不会进行后续的属性填充，比如依赖注入等，如果返回的pvs额外的添加了属性，那么后续会填充到该类对应的属性中。</li>
<li>pvs：PropertyValues对象，用于封装指定类的对象，简单来说就是PropertyValue的集合，里面相当于以key-value形式存放类的属性和值</li>
<li>pds：PropertyDescriptor对象数组，PropertyDescriptor相当于存储类的属性，不过可以调用set，get方法设置和获取对应属性的值<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean的代码片段</div><div class="line">*/</div><div class="line"><span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</div><div class="line">			PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</div><div class="line">			<span class="keyword">if</span> (hasInstAwareBpps) &#123;</div><div class="line">			    <span class="comment">//遍历调用postProcessPropertyValues方法</span></div><div class="line">				<span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</div><div class="line">					<span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</div><div class="line">						InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</div><div class="line">						pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</div><div class="line">						<span class="comment">//如果返回的pvs是null，直接返回</span></div><div class="line">						<span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</div><div class="line">							<span class="keyword">return</span>;</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (needsDepCheck) &#123;</div><div class="line">				checkDependencies(beanName, mbd, filteredPds, pvs);</div><div class="line">			&#125;</div><div class="line">		&#125;   </div><div class="line">        <span class="comment">//执行真正的属性填充</span></div><div class="line">		applyPropertyValues(beanName, mbd, bw, pvs);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><ul>
<li>只是写了<code>InstantiationAwareBeanPostProcessor</code>定义的方法，另外的<code>BeanPostProcessor</code>的方法，<a href="https://chenjiabing666.github.io/2019/06/23/Bean%E7%9A%84%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8/">请看上一篇文章</a><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInstantiationAwareBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">InstantiationAwareBeanPostProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 在实例化之前调用，如果返回null，一切按照正常顺序执行，如果返回的是一个实例的对象，那么这个将会跳过实例化、初始化的过程</div><div class="line">     * <span class="doctag">@param</span> beanClass</div><div class="line">     * <span class="doctag">@param</span> beanName</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (beanClass == User.class) &#123;</div><div class="line">            System.out.println(<span class="string">"postProcessBeforeInstantiation执行"</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 在实例化之后，postProcessBeforeInitialization之前执行</div><div class="line">     * <span class="doctag">@param</span> bean</div><div class="line">     * <span class="doctag">@param</span> beanName</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     * <span class="doctag">@throws</span> BeansException</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> User) &#123;</div><div class="line">            System.out.println(<span class="string">"postProcessAfterInstantiation执行"</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 实例化之后调用，属性填充之前</div><div class="line">     * <span class="doctag">@param</span> pvs PropertyValues对象，用于封装指定类的对象，简单来说就是PropertyValue的集合，里面相当于以key-value形式存放类的属性和值</div><div class="line">     * <span class="doctag">@param</span> pds PropertyDescriptor对象数组，PropertyDescriptor相当于存储类的属性，不过可以调用set，get方法设置和获取对应属性的值</div><div class="line">     * <span class="doctag">@param</span> bean 当前的bean</div><div class="line">     * <span class="doctag">@param</span> beanName beanName</div><div class="line">     * <span class="doctag">@return</span> 如果返回null，那么将不会进行后续的属性填充，比如依赖注入等，如果返回的pvs额外的添加了属性，那么后续会填充到该类对应的属性中。</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (pvs <span class="keyword">instanceof</span> MutablePropertyValues&amp;&amp;bean <span class="keyword">instanceof</span> User)&#123;</div><div class="line">           MutablePropertyValues mutablePropertyValues= (MutablePropertyValues) pvs;</div><div class="line">           HashMap&lt;Object, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">           map.put(<span class="string">"name"</span>,<span class="string">"陈加兵"</span>);</div><div class="line">           map.put(<span class="string">"age"</span>,<span class="number">44</span>);</div><div class="line">           mutablePropertyValues.addPropertyValues(map);</div><div class="line">           <span class="keyword">return</span> mutablePropertyValues;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**使用pds设置值</span></div><div class="line">        if (bean instanceof User) &#123;</div><div class="line">            for (PropertyDescriptor descriptor:pds) &#123;</div><div class="line">                try &#123;</div><div class="line">                    if ("name".equals(descriptor.getName())) &#123;</div><div class="line">                        descriptor.getWriteMethod().invoke(bean, "陈加兵");</div><div class="line">                    &#125;else if("age".equals(descriptor.getName()))&#123;</div><div class="line">                        descriptor.getWriteMethod().invoke(bean,40);</div><div class="line">                    &#125;</div><div class="line">                &#125;catch (Exception e)&#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return null;</div><div class="line">        &#125;**/</div><div class="line">        <span class="keyword">return</span> pvs;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> User) &#123;</div><div class="line">            System.out.println(<span class="string">"postProcessBeforeInitialization执行"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> bean;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> User) &#123;</div><div class="line">            System.out.println(<span class="string">"postProcessAfterInitialization执行"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> bean;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="源码梳理"><a href="#源码梳理" class="headerlink" title="源码梳理"></a>源码梳理</h1><ul>
<li>无论是BeanPostProcessor还是<code>InstantiationAwareBeanPostProcessor</code>都是在对象实例化和初始化前后执行的逻辑，因此我们主要的代码都在<code>getBean</code>，<code>doGetBean</code>，<code>cerateBean</code>方法中</li>
<li><code>BeanPostProcessor</code>的两个方法的执行源码请看<a href="https://chenjiabing666.github.io/2019/06/23/Bean%E7%9A%84%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8/">上一篇的文章</a></li>
<li>步骤如下：<ul>
<li><img src="https://github.com/chenjiabing666/BlogImage/blob/master/spring4.png?raw=true" alt=""></li>
<li><img src="https://github.com/chenjiabing666/BlogImage/blob/master/spring5.png?raw=true" alt=""></li>
<li><img src="https://github.com/chenjiabing666/BlogImage/blob/master/spring6.png?raw=true" alt=""></li>
<li><img src="https://github.com/chenjiabing666/BlogImage/blob/master/spring7.png?raw=true" alt=""></li>
<li><img src="https://github.com/chenjiabing666/BlogImage/blob/master/spring8.png?raw=true" alt=""></li>
<li><img src="https://github.com/chenjiabing666/BlogImage/blob/master/spring9.png?raw=true" alt=""></li>
<li><img src="https://github.com/chenjiabing666/BlogImage/blob/master/spring10.png?raw=true" alt=""></li>
<li><img src="https://github.com/chenjiabing666/BlogImage/blob/master/spring11.png?raw=true" alt=""></li>
<li><img src="https://github.com/chenjiabing666/BlogImage/blob/master/spring12.png?raw=true" alt=""></li>
</ul>
</li>
</ul>
<h1 id="Autowired源码解析"><a href="#Autowired源码解析" class="headerlink" title="Autowired源码解析"></a>Autowired源码解析</h1><ul>
<li>从源码可以看出，Autowired的功能实现最重要的一个接口就是<code>AutowiredAnnotationBeanPostProcessor</code>，继承关系如下：<br><img src="https://github.com/chenjiabing666/BlogImage/blob/master/spring13.png?raw=true" alt=""></li>
<li>从继承关系图可以看出，实际上关键的实现了<code>InstantiationAwareBeanPostProcessor</code>这个接口。</li>
<li>源码实现如下图：<br><img src="https://github.com/chenjiabing666/BlogImage/blob/master/spring14.png?raw=true" alt=""></li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>源码：<ul>
<li>ioc容器创建Bean的方法是从<code>createBean</code>方法进入的，真正执行创建的Bean的是<code>doCreateBean</code>方法，我们从createBean开始往下走<ul>
<li>调用<code>resolveBeforeInstantiation</code>方法【在doCreatBean之前执行，即是实例化之前】，在内部遍历BeanPostProcessor调用<code>postProcessBeforeInstantiation</code>方法</li>
<li>如果<code>postProcessBeforeInstantiation</code>方法返回null，那么需要执行实例化的过程，调用<code>doCreatBean</code>实例化Bean。<ul>
<li><code>doCreateBean</code>内部分为两步：①调用createBeanInstance实例化Bean；②调用<code>populateBean</code>设置Bean的属性</li>
</ul>
</li>
<li>在<code>populateBean</code>内部分为如下的步骤：<ul>
<li>调用<code>postProcessAfterInstantiation</code>【实例化之后调用】，分为两种情况：①返回false，后续的<code>postProcessPropertyValues</code>将不再执行，属性也不在进行设置；②返回true，程序照常进行，调用<code>postProcessPropertyValues</code>，属性设置的过程正常进行</li>
</ul>
</li>
<li>执行完<code>populateBean</code>之后将会调用<code>initializeBean</code>【初始化Bean，调用afterPropertiesSet方法】，在内部就涉及到BeanPostProcessor定义的接口了，步骤如下：<ul>
<li>执行<code>applyBeanPostProcessorsBeforeInitialization</code>方法调用<code>postProcessBeforeInitialization</code>【在初始化之前调用】方法</li>
<li>执行<code>invokeInitMethods</code>方法，内部其实是调用afterPropeertiesSet方法，进行初始化</li>
<li>执行<code>applyBeanPostProcessorsAfterInitialization</code>，内部调用<code>postProcessAfterInitialization</code>【在实例化之后调用】方法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;继承&lt;code&gt;BeanPostProcessor&lt;/code&gt;接口，在此基础上又定义了三个方法，分别在Bean&lt;strong&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>FactoryBean解析</title>
    <link href="http://chenjiabing666.github.io/2019/06/23/FactoryBean%E8%A7%A3%E6%9E%90/"/>
    <id>http://chenjiabing666.github.io/2019/06/23/FactoryBean解析/</id>
    <published>2019-06-23T13:49:47.000Z</published>
    <updated>2019-06-23T13:50:08.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>简单的说FactoryBean实际上是一个Bean，并不是一个工厂，它能够为我们创建一个Bean，但是创建的这个Bean实际指向的并不是FactoryBean类型的，而是其中<code>getObject</code>方法返回类型的对象。</li>
</ul>
<h1 id="接口解析"><a href="#接口解析" class="headerlink" title="接口解析"></a>接口解析</h1><ul>
<li>FactoryBean中有三个需要实现的方法，如下：<ul>
<li><code>getObject()</code> ：获取返回的对象，此处返回的对象会被注入到ioc容器中</li>
<li><code>public Class&lt;?&gt; getObjectType()</code>：返回创建Bean类型</li>
<li><code>public boolean isSingleton()</code>：返回是否创建单例，如果返回true，那么创建的对象将是单例的，返回false，创建的是多实例的对象。</li>
</ul>
</li>
</ul>
<h1 id="自定义实现"><a href="#自定义实现" class="headerlink" title="自定义实现"></a>自定义实现</h1><ul>
<li><p>自定义一个FactoryBean，实现Admin的注入，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义FactoryBean，用来创建对象</div><div class="line"> * 1、<span class="doctag">@Component</span> :将创建的MyFactoryBean注入到容器中</div><div class="line"> * 2、实现FactoryBean</div><div class="line"> * 3、指定泛型&lt;T&gt;</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Admin</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Admin <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"创建Admin"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Admin();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</div><div class="line">        <span class="keyword">return</span> Admin.class;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>此时即可从容器中获取到对应的Bean了，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFactoryBean</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//根据id获取实例，这里实际获取的是getObject返回的对象</span></div><div class="line">    Admin admin1 = applicationContext.getBean(<span class="string">"myFactoryBean"</span>, Admin.class);</div><div class="line">    System.out.println(admin1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>以上是获取的实例Bean，现在我们就想获取MyBeanFactory本身这个对象，可以在id的前面加上<code>&amp;</code>即可，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFactoryBean2</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//根据&amp;id获取实例，实际获取的就是MyFactoryBean的对象</span></div><div class="line">    MyFactoryBean bean = applicationContext.getBean(<span class="string">"&amp;myFactoryBean"</span>, MyFactoryBean.class);</div><div class="line">    System.out.println(bean);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><ul>
<li>指定的是FactoryBean的id，为什么获取的是getObject返回的对象？<ul>
<li>简单的逻辑：判断传入的类型是否是<code>FactoryBean</code>类型，如果是该类型的，调用getObject方法返回对象即可。</li>
<li>在源码中可以看到调用的是<code>org.springframework.beans.factory.support.FactoryBeanRegistrySupport#doGetObjectFromFactoryBean</code>方法</li>
<li><img src="https://github.com/chenjiabing666/BlogImage/blob/master/spring2.png?raw=true" alt=""></li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;简单的说FactoryBean实际上是一个Bean，并不是一个工厂，它能够为我们创建一个Bean，但是创建的这个Bean实际指向
    
    </summary>
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Bean的后置处理器</title>
    <link href="http://chenjiabing666.github.io/2019/06/23/Bean%E7%9A%84%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>http://chenjiabing666.github.io/2019/06/23/Bean的后置处理器/</id>
    <published>2019-06-23T13:48:55.000Z</published>
    <updated>2019-06-23T13:49:26.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>调用顺序：在Bean的初始化前后调用，分别对应了其中的两个方法</li>
<li>Bean的后置处理器对应的接口是<code>BeanPostProcessor</code>，其中定义了两个方法，如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 在Bean初始化之前执行，即是在执行Bean的构造方法之后，在执行InitializingBean的afterPropertiesSet方法之前执行</div><div class="line">	 */</div><div class="line">	<span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">         * 在Bean的初始化之后执行，即是在InitializingBean的afterPropertiesSet方法之后执行</div><div class="line">	 */</div><div class="line">	<span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>在Bean的初始化前后做一些自己的逻辑处理，比如为Bean设置一些额外的属性。<ul>
<li>最典型的例子就是spring中的Aware接口的实现，都是利用<code>BeanPostProcessor</code>在Bean初始化之前进行调用set方法设置相应的属性【详情请看<code>ApplicationContextAwareProcessor</code>源码】</li>
<li><code>@Autowired</code>的实现依赖注入也是使用的BeanPostProcessor的原理，详情请看<code>AutowiredAnnotationBeanPostProcessor</code>的源码</li>
</ul>
</li>
</ul>
<h2 id="自定义后置处理器"><a href="#自定义后置处理器" class="headerlink" title="自定义后置处理器"></a>自定义后置处理器</h2><ul>
<li>必备条件：<ul>
<li>自定义的后置处理器必须注入到容器中</li>
<li>必须实现<code>BeanPostProcessor</code>接口，实现其中的方法</li>
</ul>
</li>
</ul>
<ul>
<li><p>自定义一个User类，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 实现InitializingBean接口，定义初始化方法，在构造方法之后执行</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">InitializingBean</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Integer age;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, Integer age)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"执行构造方法"</span>);</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"执行初始化方法，在构造方法执行之后执行"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>自定义后置处理器，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 1、自定义的后置处理器,实现BeanPostProcessor</div><div class="line"> * 2、必须注入到容器中才能执行</div><div class="line"> * 3、后置处理器是每一个Bean实例化前后都会调用的，并不能指定某一个</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 在Bean初始化之前执行，即是在执行Bean的构造方法之后，在执行InitializingBean的afterPropertiesSet方法之前执行</div><div class="line">     * <span class="doctag">@param</span> bean bean的对象</div><div class="line">     * <span class="doctag">@param</span> beanName bean的名字，即是在ioc容器中的id</div><div class="line">     * <span class="doctag">@return</span> 一定不能null</div><div class="line">     * <span class="doctag">@throws</span> BeansException</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        <span class="comment">//如果这个Bean是User类型</span></div><div class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> User)&#123;</div><div class="line">            System.out.println(<span class="string">"在User的初始化方法【afterPropertiesSet】之前执行"</span>);</div><div class="line">            <span class="comment">//改变属性的值</span></div><div class="line">            User user=(User)bean;</div><div class="line">            user.setName(<span class="string">"马云"</span>);</div><div class="line">            user.setAge(<span class="number">40</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> bean;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 在Bean的初始化之后执行，即是在InitializingBean的afterPropertiesSet方法之后执行</div><div class="line">     * <span class="doctag">@param</span> bean bean的对象</div><div class="line">     * <span class="doctag">@param</span> beanName bean的名字，即是在ioc容器中的id</div><div class="line">     * <span class="doctag">@return</span> 一定不能null</div><div class="line">     * <span class="doctag">@throws</span> BeansException</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> User)&#123;</div><div class="line">            System.out.println(<span class="string">"在User的初始化方法【afterPropertiesSet】之后执行"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> bean;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><ul>
<li>最重要的就是后置处理器两个方法的执行顺序：<ul>
<li>为什么<code>postProcessBeforeInitialization</code>在构造方法之后，初始化之前调用？</li>
<li>为什么<code>postProcessAfterInitialization</code>在初始化之后调用？</li>
</ul>
</li>
<li>我们分别在自定义的后置处理器上打上断点，通过debug模式跟踪代码，程序的入口测试类如下：<ul>
<li>使用<code>AnnotationConfigApplicationContext</code>启动容器<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstConfigTest</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> AnnotationConfigApplicationContext applicationContext;</div><div class="line"></div><div class="line">    <span class="meta">@Before</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initApplicationContext</span><span class="params">()</span> </span>&#123;</div><div class="line">        applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(FirstConfig.class);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>执行AnnotationConfigApplicationContext的构造方法<code>public AnnotationConfigApplicationContext(Class&lt;?&gt;... annotatedClasses)</code>： <ol>
<li><code>register(annotatedClasses)</code>：注入指定的配置类<code>FirstConfig</code></li>
<li><strong>【<code>refresh()</code>：刷新容器，在这个执行结束之后会完成Bean的加载，详情见第2步】</strong></li>
</ol>
</li>
<li>进入<code>org.springframework.context.support.AbstractApplicationContext#refresh</code>方法：<ol>
<li><code>prepareRefresh();</code>：在刷新容器之前做一些准备工作，比如设置激活状态【activate】,设置启动时间【startupDate】</li>
<li><code>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</code><ol>
<li><code>refreshBeanFactory()</code>：刷新BeanFactory，如果之前存在了就删除创建新的，返回的是</li>
<li>返回<code>ConfigurableListableBeanFactory</code>类型的Bean工厂</li>
</ol>
</li>
<li><code>prepareBeanFactory(beanFactory);</code>：对新创建的Bean工厂设置一些属性配置<ol>
<li>设置ClassLoader、表达式解析器、属性注入器</li>
<li><strong>设置<code>ApplicationContextAwareProcessor</code>这个后置处理器到<code>org.springframework.beans.factory.support.AbstractBeanFactory#beanPostProcessors</code>该成员变量中、去除一些不能自动注入的类【ResourceLoaderAware、ApplicationEventPublisherAware、MessageSourceAware、ApplicationContextAware、EnvironmentAware】，因为这些Aware类型的类需要后续自定义实现的</strong></li>
<li><strong>向容器中注入一些能够自动注入的类【BeanFactory，ResourceLoader，ApplicationEventPublisher，ApplicationContext】，这些类能够直接通过<code>@Autowired</code>直接注入使用</strong></li>
<li><strong>向容器中注入一些运行环境的Bean【<code>ConfigurableEnvironment</code>、<code>systemProperties(Map&lt;String,Object&gt;</code>其中存放的是配置参数)】，这些Bean可以直接自动注入使用</strong></li>
</ol>
</li>
<li><code>invokeBeanFactoryPostProcessors(beanFactory)</code>：调用已经注册在容器中的BeanFactory后置处理器</li>
<li><code>registerBeanPostProcessors(beanFactory)</code>：向ioc容器中注册BeanFactoryProcessor</li>
<li><code>initMessageSource()</code>：初始化MessageSource</li>
<li><code>initApplicationEventMulticaster()</code>：初始化事件分发器</li>
<li><code>registerListeners()</code>：注册事件监听器，用来监听事件</li>
<li><strong>【<code>finishBeanFactoryInitialization(beanFactory)</code>：初始化单例、非懒加载的Bean】，详情见步骤3</strong></li>
<li><code>finishRefresh()</code>：发布事件</li>
</ol>
</li>
<li>进入<code>org.springframework.context.support.AbstractApplicationContext#finishBeanFactoryInitialization</code>:<ol>
<li>初始化类型转换类</li>
<li>初始化<code>LoadTimeWeaverAware</code>，用于方法织入</li>
<li>冻结BeanDefinition，表示后面的BeanDefinition不能再改变</li>
<li><strong>【<code>beanFactory.preInstantiateSingletons()</code>：初始化Bean，详情请看第4步】</strong></li>
</ol>
</li>
<li><p>进入到<code>org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons</code>方法中，用于初始化Bean</p>
<ol>
<li>遍历所有的BeanNames，判断当前Bean是否是FactoryBean，如果不是运行getBean方法</li>
</ol>
</li>
<li><p>进入到<code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#initializeBean</code>，如下图所示，将是完整的逻辑，可以看出后置处理器为什么是在初始化之前和之后执行。</p>
<ol>
<li><img src="https://raw.githubusercontent.com/chenjiabing666/BlogImage/master/spring1.png" alt=""></li>
</ol>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>从源码可以看出，最核心的执行就是在<code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#initializeBean</code>的方法中，主要的代码逻辑是在初始化之前调用对应的before方法，在之后调用after方法。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;调用顺序：在Bean的初始化前后调用，分别对应了其中的两个方法&lt;/li&gt;
&lt;li&gt;Bean的后置处理器对应的接口是&lt;code&gt;B
    
    </summary>
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring注解开发</title>
    <link href="http://chenjiabing666.github.io/2019/06/23/Spring%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/"/>
    <id>http://chenjiabing666.github.io/2019/06/23/Spring注解开发/</id>
    <published>2019-06-23T03:17:49.000Z</published>
    <updated>2019-06-23T03:18:16.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h1><ul>
<li>标注在类上，表明该类是一个配置类，相当于之前写的spring的xml文件，通常与<code>@Bean</code>结合使用</li>
<li>该注解同时拥有了<code>@Component</code>的作用，将当前类注入ioc容器<ul>
<li>其中有一个<code>value</code>属性，指定注入ioc容器的名称，默认是类名首字母小写</li>
<li>源码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Configuration &#123;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h1><ul>
<li>在配置类中使用该注解</li>
<li>标注在方法上，默认将方法的返回对象注入到ioc容器，名称默认使用的是方法名<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 配置类</div><div class="line"> */</div><div class="line"><span class="meta">@Configuration</span>(value = <span class="string">"MyConfiguration"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 注入一个User对象，ioc容器中的name是user，类型是User类型</div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">"name"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul>
<li><code>name</code>：指定注入ioc容器中的名称</li>
<li><code>value</code>：同name</li>
<li><code>autowireCandidate</code>：是否能够自动注入，默认是true，如果指定了属性为false，那么不能使用<code>@Autowired</code>或者<code>@Resource</code>自动注入</li>
<li><code>initMethod</code>：指定初始化方法，在构造方法之后执行</li>
<li><code>destroyMethod</code>：指定销毁方法，在容器关闭的时候执行</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 配置类</div><div class="line"> */</div><div class="line"><span class="meta">@Configuration</span>(value = <span class="string">"MyConfiguration"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 注入一个User对象，ioc容器中的name是user，类型是User类型</div><div class="line">     * init是User类中的init方法，destory是User类中的destory方法</div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>,destroyMethod = <span class="string">"destory"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user1</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">"name"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* User类</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Integer id;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Integer id, String name)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"执行构造方法"</span>);</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"初始化方法"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"销毁方法"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h1><ul>
<li>指定对象的作用域名，标注在类上或者方法上，默认是单实例</li>
</ul>
<h2 id="四大作用域"><a href="#四大作用域" class="headerlink" title="四大作用域"></a>四大作用域</h2><ul>
<li><code>singleton</code>：单例，默认值，当容器启动的时候会创建对象放入ioc容器中，后续获取只是从容器中创建，并不会再次调用构造方法new出来</li>
<li><code>prototype</code>：多实例，容器启动的时候并不会创建该对象，而是当需要用到的才调用构造方法new出来（不放入ioc容器，每次用到就new一个）</li>
<li><code>request</code>：该属性仅对HTTP请求产生作用，使用该属性定义Bean时，每次HTTP请求都会创建一个新的Bean，适用于WebApplicationContext环境。</li>
<li><code>session</code>：该属性仅用于HTTP Session，同一个Session共享一个Bean实例。不同Session使用不同的实例。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * 指定多实例，每次用到都会调用</div><div class="line">    */</div><div class="line">   <span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>,destroyMethod = <span class="string">"destory"</span>)</div><div class="line">   <span class="meta">@Scope</span>(value = <span class="string">"prototype"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> User <span class="title">user1</span><span class="params">()</span></span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">"name"</span>);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h1 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h1><ul>
<li>标注在方法或者在类上，只有在满足其中的匹配条件才会将对象注入到ioc容器中。</li>
<li>只有一个属性value，是一个<code>Condition</code>数组，要向实现相应的功能，可以自定义一个类，实现<code>Condition</code>这个接口即可。</li>
<li><p>这个注解在SpringBoot中将会有很多的扩展，这里就不多说了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * 指定多实例，每次用到都会调用</div><div class="line">     * <span class="doctag">@Conditional</span> 只有里面全部都匹配才会正常注入到容器中</div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>,destroyMethod = <span class="string">"destory"</span>)</div><div class="line">    <span class="meta">@Conditional</span>(value = &#123;FirstCondition.class&#125;)</div><div class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user1</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">"name"</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>下面看看<code>FirstCondition</code>这个类具体实现</p>
<ul>
<li>只需要实现接口中的<code>matches</code>方法即可，返回true表示符合条件，否则不满足条件，只有满足条件才会注入到ioc容器中<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义的条件判断，实现Condition接口</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 如果返回true表示符合条件，反之不符合条件</div><div class="line">     * <span class="doctag">@param</span> context ConditionContext对象，可以获取上下文的信息</div><div class="line">     * <span class="doctag">@param</span> metadata AnnotatedTypeMetadata对象，可以获取标注在该方法上面的注解信息</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</div><div class="line">        <span class="comment">//获取Environment，用来获取运行环境中的一些变量</span></div><div class="line">        Environment environment = context.getEnvironment();</div><div class="line">        <span class="comment">//获取在properties文件中配置的参数，表示是否注入相关属性</span></div><div class="line">        Boolean isAutowired = environment.&lt;Boolean&gt;getProperty(<span class="string">"isAutowired"</span>, Boolean.class);</div><div class="line">        <span class="keyword">return</span> isAutowired;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="ConditionContext"><a href="#ConditionContext" class="headerlink" title="ConditionContext"></a>ConditionContext</h2><ul>
<li>主要的功能是获取上下文的对象，比如BeanFactory<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConditionContext</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	* 获取 BeanDefinitionRegistry，可以自己手动注册对象到ioc容器中</div><div class="line">    */</div><div class="line">	<span class="function">BeanDefinitionRegistry <span class="title">getRegistry</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 获取BeanFacotory，操作ioc容器，比如获取对应的Bean，判断ioc中是否已经注入   </div><div class="line">	 */</div><div class="line">	<span class="meta">@Nullable</span></div><div class="line">	<span class="function">ConfigurableListableBeanFactory <span class="title">getBeanFactory</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回当前的运行环境，可以获取运行环境中的一下参数，或者一些配置文件中的数据</div><div class="line">	 */</div><div class="line">	<span class="function">Environment <span class="title">getEnvironment</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 获取资源加载器</div><div class="line">	 */</div><div class="line">	<span class="function">ResourceLoader <span class="title">getResourceLoader</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 获取类加载器 </div><div class="line">	 */</div><div class="line">	<span class="meta">@Nullable</span></div><div class="line">	<span class="function">ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="AnnotatedTypeMetadata"><a href="#AnnotatedTypeMetadata" class="headerlink" title="AnnotatedTypeMetadata"></a>AnnotatedTypeMetadata</h2><ul>
<li>主要的作用就是获取标注了<code>@Conditional</code>这个注解的方法上的注解和对应的参数等信息<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnnotatedTypeMetadata</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	* 判断方法上是否有对应的注解 </div><div class="line">    * <span class="doctag">@param</span> annotationName 注解类的全类名，getName()</div><div class="line">    */</div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isAnnotated</span><span class="params">(String annotationName)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	*  获取对应注解的全部属性的值，key是属性，value是属性的值</div><div class="line">    * <span class="doctag">@param</span> annotationName 注解类的全类名，getName()</div><div class="line">    */</div><div class="line">	<span class="meta">@Nullable</span></div><div class="line">	<span class="function">Map&lt;String, Object&gt; <span class="title">getAnnotationAttributes</span><span class="params">(String annotationName)</span></span>;</div><div class="line"></div><div class="line">	<span class="meta">@Nullable</span></div><div class="line">	<span class="function">Map&lt;String, Object&gt; <span class="title">getAnnotationAttributes</span><span class="params">(String annotationName, <span class="keyword">boolean</span> classValuesAsString)</span></span>;</div><div class="line"></div><div class="line">	<span class="meta">@Nullable</span></div><div class="line">	<span class="function">MultiValueMap&lt;String, Object&gt; <span class="title">getAllAnnotationAttributes</span><span class="params">(String annotationName)</span></span>;</div><div class="line"></div><div class="line">	<span class="meta">@Nullable</span></div><div class="line">	<span class="function">MultiValueMap&lt;String, Object&gt; <span class="title">getAllAnnotationAttributes</span><span class="params">(String annotationName, <span class="keyword">boolean</span> classValuesAsString)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h1><ul>
<li>标注在方法上，用来在类加载并且属性赋值之后调用，通常用来初始化，和<code>@Bean</code>中的<code>init-menthd</code>指定的作用相同<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@PostConstruct</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"初始化方法"</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="PreDestroy"><a href="#PreDestroy" class="headerlink" title="@PreDestroy"></a>@PreDestroy</h1><ul>
<li>标注在方法上，容器销毁执行，相当于<code>@Bean</code>中的<code>destroy-method</code>属性<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@PreDestroy</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"销毁方法"</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h1><ul>
<li>用来形式化的注入，主要形式有：<ul>
<li>直接导入类</li>
<li>导入配置类</li>
<li>指定ImportSelector</li>
<li>使用ImportBeanDefinitionRegistrar手动注册</li>
</ul>
</li>
</ul>
<h2 id="直接导入类"><a href="#直接导入类" class="headerlink" title="直接导入类"></a>直接导入类</h2><ul>
<li>直接在 <code>value</code>属性中指定需要导入的类即可，如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span>(value = <span class="string">"MyConfiguration"</span>)</div><div class="line"><span class="meta">@Import</span>(value = &#123;Person.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="导入配置类"><a href="#导入配置类" class="headerlink" title="导入配置类"></a>导入配置类</h2><ul>
<li><p>新建一个配置类，但是不用<code>@Configuration</code>标注，使用<code>@Import</code>在另外一个配置类上引入即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 这是一个配置，但是并没有使用<span class="doctag">@Configuration</span>这个注解，因此不会生效</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondConfiguration</span> </span>&#123;</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在另外一个配置类使用<code>@Import</code>注解引入上面的配置类，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span>(value = <span class="string">"MyConfiguration"</span>)</div><div class="line"><span class="meta">@Import</span>(value = &#123;SecondConfiguration.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="指定ImportSelector"><a href="#指定ImportSelector" class="headerlink" title="指定ImportSelector"></a>指定ImportSelector</h2><ul>
<li><p>使用ImportSelector需要自定义一个实现类，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义Selector，需要实现ImportSelector</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 筛选逻辑，返回的是String数组（需要注入到容器中的类的全类名）</div><div class="line">     * <span class="doctag">@param</span> importingClassMetadata AnnotationMetadata对象，对标注了<span class="doctag">@Import</span>这个注解的类中的所有注解信息，比如获取标注指定注解的方法</div><div class="line">     * <span class="doctag">@return</span> 返回的是需要注入的字符串数组（类的全类名）</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</div><div class="line">        <span class="comment">//获取@Import标注的类中被@Bean标注的方法元数据</span></div><div class="line">        Set&lt;MethodMetadata&gt; annotatedMethods = importingClassMetadata.getAnnotatedMethods(Bean.class.getName());</div><div class="line">        annotatedMethods.forEach(o-&gt;&#123;</div><div class="line">            System.out.println(o.getMethodName());</div><div class="line">        &#125;);</div><div class="line">        <span class="comment">//将Person类返回去，那么将会自动注入Person</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;Person.class.getName()&#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在配置类上使用<code>@Import</code>注解引入即可，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@Import</span>(value = &#123;FirstSelector.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="AnnotationMetadata"><a href="#AnnotationMetadata" class="headerlink" title="AnnotationMetadata"></a>AnnotationMetadata</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnnotationMetadata</span> <span class="keyword">extends</span> <span class="title">ClassMetadata</span>, <span class="title">AnnotatedTypeMetadata</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">//拿到Class上标注的所有注解，依赖于Class#getAnnotations</span></div><div class="line">	<span class="function">Set&lt;String&gt; <span class="title">getAnnotationTypes</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">// 拿到所有的元注解信息AnnotatedElementUtils#getMetaAnnotationTypes</span></div><div class="line">	<span class="comment">//annotationName:注解类型的全类名</span></div><div class="line">	<span class="function">Set&lt;String&gt; <span class="title">getMetaAnnotationTypes</span><span class="params">(String annotationName)</span></span>;</div><div class="line">	<span class="comment">// 是否包含指定注解 （annotationName：全类名）</span></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">hasAnnotation</span><span class="params">(String annotationName)</span></span>;</div><div class="line">	<span class="comment">//这个厉害了，依赖于AnnotatedElementUtils#hasMetaAnnotationTypes</span></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">hasMetaAnnotation</span><span class="params">(String metaAnnotationName)</span></span>;</div><div class="line">	<span class="comment">// 类里面只有有一个方法标注有指定注解，就返回true</span></div><div class="line">	<span class="comment">//getDeclaredMethods获得所有方法， AnnotatedElementUtils.isAnnotated是否标注有指定注解</span></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">hasAnnotatedMethods</span><span class="params">(String annotationName)</span></span>;</div><div class="line">	<span class="comment">// 注意返回的是MethodMetadata 原理基本同上</span></div><div class="line">	<span class="comment">// .getDeclaredMethods和AnnotatedElementUtils.isAnnotated  最后吧Method转为MethodMetadata</span></div><div class="line">	<span class="function">Set&lt;MethodMetadata&gt; <span class="title">getAnnotatedMethods</span><span class="params">(String annotationName)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="使用ImportBeanDefinitionRegistrar手动注册"><a href="#使用ImportBeanDefinitionRegistrar手动注册" class="headerlink" title="使用ImportBeanDefinitionRegistrar手动注册"></a>使用ImportBeanDefinitionRegistrar手动注册</h2><ul>
<li><p>需要自定义一个类实现<code>ImportBeanDefinitionRegistrar</code>，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义的FirstBeanDefinitionRegistrar，需要实现ImportBeanDefinitionRegistrar</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 自己手动注册Bean到ioc容器中</div><div class="line">     * <span class="doctag">@param</span> importingClassMetadata 获取<span class="doctag">@Import</span>标注的类上的注解信息，比如获取被指定注解标注的方法信息</div><div class="line">     * <span class="doctag">@param</span> registry  注册中心，可以获取指定bean的信息和手动注册bean</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</div><div class="line">        <span class="comment">//如果容器中没有Person这个Bean，就创建一个</span></div><div class="line">        <span class="keyword">if</span> (!registry.containsBeanDefinition(Person.class.getName()))&#123;</div><div class="line">            GenericBeanDefinition beanDefinition=<span class="keyword">new</span> GenericBeanDefinition();</div><div class="line">            beanDefinition.setBeanClass(Person.class);</div><div class="line">            <span class="comment">//手动注册</span></div><div class="line">            registry.registerBeanDefinition(<span class="string">"person"</span>,beanDefinition);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在配置类上使用<code>@Import</code>注解引入即可，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@Import</span>(value = &#123;FirstBeanDefinitionRegistrar.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="Primary"><a href="#Primary" class="headerlink" title="@Primary"></a>@Primary</h1><ul>
<li>在spring 中使用注解，常使用@Autowired， 默认是根据类型Type来自动注入的。但有些特殊情况，对同一个接口，可能会有几种不同的实现类，而默认只会采取其中一种的情况下 @Primary 的作用就出来了。</li>
<li>有两种使用方式，一种是结合<code>@Bean</code>，另外一种是结合<code>@Service,@Component,@Controller.....</code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="meta">@Primary</span></div><div class="line"><span class="function"><span class="keyword">public</span> User <span class="title">user1</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">"user1"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//第二种</span></div><div class="line"><span class="meta">@Primary</span></div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> Integer age;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h1><ul>
<li>标注在方法和属性上，用来自动为成员变量赋值</li>
<li>默认先根据属性的类型从ioc容器中查找，如果ioc容器中存在多个类型相同的属性，将会根据<strong>变量名</strong>从ioc容器中查找。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> UserService userService;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><ul>
<li><code>required</code>：指定该属性是否是必须的，默认为true，表示一定要为属性赋值，如果ioc容器中没有对应的Bean，那个将会报错，如果为false，会先从ioc容器中查找对应的Bean，如果存在就进行赋值，不存在就不赋值，不会报错。</li>
</ul>
<h1 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h1><ul>
<li>和<code>@Autowired</code>结合使用，用来从容器中注入指定名字的Bean</li>
<li>使用场景：容器中存在多个类型相同的Bean,那么此时仅仅使用<code>@Autowired</code>就不太适用了，此时就要结合该注解，指定需要注入的name。（当然除了<code>@Autowired</code>还是可以根据成员变量的名称进行注入的）<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="meta">@Qualifier</span>(value = <span class="string">"userService"</span>)</div><div class="line">    <span class="keyword">private</span> UserService userService;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h1><ul>
<li>从配置文件中读取相关配置注入到指定的成员属性中<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="meta">@PropertySource</span>(value = &#123;<span class="string">"classpath:user.properties"</span>&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> Integer age;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, Integer age)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h2><ul>
<li><code>value</code>：指定资源文件的位置</li>
<li><code>ignoreResourceNotFound</code>：是否忽略资源文件不存在，默认为false，表示如果资源文件不存在，那么将会抛出异常，如果为true，资源文件不存在的话，程序正常运行</li>
</ul>
<h1 id="Value"><a href="#Value" class="headerlink" title="@Value()"></a>@Value()</h1><ul>
<li>有三个典型的使用场景：<ul>
<li>获取配置文件中对应的值，为指定属性赋值</li>
<li>使用指定的值为属性赋值</li>
<li>通过表达式计算得到的值为属性赋值</li>
</ul>
</li>
</ul>
<h2 id="获取配置文件中的值为属性赋值"><a href="#获取配置文件中的值为属性赋值" class="headerlink" title="获取配置文件中的值为属性赋值"></a>获取配置文件中的值为属性赋值</h2><ul>
<li>使用<code>${}</code>的方式获取配置文件中设置的值<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;name&#125;"</span>)</div><div class="line"><span class="keyword">private</span> String name;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="使用指定的值"><a href="#使用指定的值" class="headerlink" title="使用指定的值"></a>使用指定的值</h2><ul>
<li>其中的<code>value</code>属性可以是自己随便指定的值，如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Value</span>(<span class="string">"陈加兵"</span>)</div><div class="line"><span class="keyword">private</span> String name;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="表达式赋值"><a href="#表达式赋值" class="headerlink" title="表达式赋值"></a>表达式赋值</h2><ul>
<li>表达式的计算需要使用<code>#{}</code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Value</span>(<span class="string">"#&#123;10+22&#125;"</span>)</div><div class="line"><span class="keyword">private</span> Integer age;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="Profile"><a href="#Profile" class="headerlink" title="@Profile"></a>@Profile</h1><ul>
<li>未完待续。。。。。。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Configuration&quot;&gt;&lt;a href=&quot;#Configuration&quot; class=&quot;headerlink&quot; title=&quot;@Configuration&quot;&gt;&lt;/a&gt;@Configuration&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;标注在类上，表明该类是一个配置类，相
    
    </summary>
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring中的Aware解析</title>
    <link href="http://chenjiabing666.github.io/2019/06/12/Spring%E4%B8%AD%E7%9A%84Aware%E8%A7%A3%E6%9E%90/"/>
    <id>http://chenjiabing666.github.io/2019/06/12/Spring中的Aware解析/</id>
    <published>2019-06-12T11:33:01.000Z</published>
    <updated>2019-06-23T14:05:13.567Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Spring框架中提供了许多实现了Aware接口的类，这些类主要是为了辅助Spring访问容器中的数据，比如<code>BeanNameAware</code>，这个类能够在Spring容器加载的过程中将Bean的名字（id）赋值给变量。</li>
</ul>
<h2 id="常用的Aware"><a href="#常用的Aware" class="headerlink" title="常用的Aware"></a>常用的Aware</h2><ul>
<li><code>BeanNameAware</code>：能够获取bean的名称，即是id</li>
<li><code>BeanFactoryAware</code>：获取BeanFactory实例</li>
<li><code>ApplicationContextAware</code>：获取<code>ApplicationContext</code></li>
<li><code>MessageSourceAware</code>：获取MessageSource</li>
<li><code>ResourceLoaderAware</code>：获取<code>ResourceLoader</code></li>
<li><code>EnvironmentAware</code>：获取<code>Environment</code></li>
</ul>
<h2 id="ApplicationContextAware"><a href="#ApplicationContextAware" class="headerlink" title="ApplicationContextAware"></a>ApplicationContextAware</h2><ul>
<li>ApplicationContext可以获取容器中的bean，但是必须注入才能使用，当一些类不能注入的时候怎么才能获得bean呢？比如Utils中的类，通常不能直接通过注入直接使用ApplicationContext，此时就需要借助<code>ApplicationContextAware</code>这个接口了。</li>
<li><code>ApplicationContextAware</code>的实现类如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义一个实现类，一定要注入到容器中</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextAwareImpl</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 容器启动的时候会调用这个方法，只需要将applicationContext设置即可</div><div class="line">     * <span class="doctag">@param</span> applicationContext 容器启动会自动注入</div><div class="line">     * <span class="doctag">@throws</span> BeansException</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        <span class="comment">//将其设置到ApplicationContextUtil</span></div><div class="line">        ApplicationContextUtil.setApplicationContext(applicationContext);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>ApplicationContextUtil</code>如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * ApplicationContext的工具类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextUtil</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * ApplicationContext对象，会ApplicationContextAwareImpl中的setApplicationContext方法中赋值</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title">getApplicationContext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> applicationContext;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</div><div class="line">        ApplicationContextUtil.applicationContext = applicationContext;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 根据类型获取指定的bean</div><div class="line">     * <span class="doctag">@param</span> requiredType Class</div><div class="line">     * <span class="doctag">@param</span> &lt;T&gt; 泛型</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType )</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> applicationContext.getBean(requiredType);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 根据名称和类型获取Bean</div><div class="line">     * <span class="doctag">@param</span> name bean的id</div><div class="line">     * <span class="doctag">@param</span> requiredType class</div><div class="line">     * <span class="doctag">@param</span> &lt;T&gt;</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name,Class&lt;T&gt; requiredType)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> applicationContext.getBean(name,requiredType);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>配置了如上的工具类，那么就可以直接使用ApplicationContextUtil获取ApplicationContext对象了，而不需要注入了，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">StringRedisTemplate redisTemplate=ApplicationContextUtil.getBean(<span class="string">"stringRedisTemplate"</span>,StringRedisTemplate.class);</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>spring底层的一些东西并不能通过自动注入直接从ioc容器中获取，但是spring提供了其他的一些方法获取相应的对象，比如一些<code>Aware</code>，要向成功获取指定的对象，必备的条件如下：<ul>
<li>实现<code>xxxAware</code>接口</li>
<li>自定义的类注入到容器中</li>
</ul>
</li>
</ul>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><ul>
<li>Aware的装配使用的BeanPostProcessor原理，在初始化之前调用set方法设置对应的值，相应的实现都在<code>org.springframework.context.support.ApplicationContextAwareProcessor#invokeAwareInterfaces</code>，源码如下：<ul>
<li>主要的逻辑就是判断相应bean的类型，调用相应的set方法<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareInterfaces</span><span class="params">(Object bean)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</div><div class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) &#123;</div><div class="line">				((EnvironmentAware) bean).setEnvironment(<span class="keyword">this</span>.applicationContext.getEnvironment());</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) &#123;</div><div class="line">				((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(</div><div class="line">						<span class="keyword">new</span> EmbeddedValueResolver(<span class="keyword">this</span>.applicationContext.getBeanFactory()));</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) &#123;</div><div class="line">				((ResourceLoaderAware) bean).setResourceLoader(<span class="keyword">this</span>.applicationContext);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware) &#123;</div><div class="line">				((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(<span class="keyword">this</span>.applicationContext);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware) &#123;</div><div class="line">				((MessageSourceAware) bean).setMessageSource(<span class="keyword">this</span>.applicationContext);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</div><div class="line">				((ApplicationContextAware) bean).setApplicationContext(<span class="keyword">this</span>.applicationContext);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://blog.csdn.net/iechenyb/article/details/83788338" target="_blank" rel="external">https://blog.csdn.net/iechenyb/article/details/83788338</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Spring框架中提供了许多实现了Aware接口的类，这些类主要是为了辅助Spring访问容器中的数据，比如&lt;code&gt;Bean
    
    </summary>
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>JDK8新特性</title>
    <link href="http://chenjiabing666.github.io/2019/06/12/JDK8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://chenjiabing666.github.io/2019/06/12/JDK8新特性/</id>
    <published>2019-06-12T06:58:55.000Z</published>
    <updated>2019-06-12T07:00:09.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDk8新特性"><a href="#JDk8新特性" class="headerlink" title="JDk8新特性"></a>JDk8新特性</h1><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><h3 id="集合的foreach"><a href="#集合的foreach" class="headerlink" title="集合的foreach"></a>集合的foreach</h3><ul>
<li><p>List</p>
<ul>
<li>这里的表示List中每一个元素，可以不指定类型，JDK会自动推测出类型，但是也是可以使用<code>()</code>加上类型</li>
<li>如果有一条语句可以直接在后面输出，如果有多行，那么可以在后面使用<code>{}</code>指定<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">76</span>).forEach(e-&gt; System.out.println(e));</div><div class="line">   Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">76</span>).forEach((Integer e)-&gt; System.out.println(e));</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Set</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Set&lt;Object&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">76</span>));</div><div class="line">   set.forEach(e-&gt; System.out.println(e));</div></pre></td></tr></table></figure>
</li>
<li><p>Map</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Map&lt;Object,Object&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">      map.put(<span class="string">"2"</span>,<span class="number">2</span>);</div><div class="line">      map.put(<span class="string">"4"</span>,<span class="number">5</span>);</div><div class="line">      <span class="comment">//a,b两个元素分别是key和value</span></div><div class="line">      map.forEach((a,b)-&gt;&#123;</div><div class="line">          System.out.println(a+<span class="string">"---"</span>+b);</div><div class="line">      &#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="lambda表达式轻松创建接口实例"><a href="#lambda表达式轻松创建接口实例" class="headerlink" title="lambda表达式轻松创建接口实例"></a>lambda表达式轻松创建接口实例</h3><ul>
<li>条件：该接口只能有一个需要实现的方法（默认方法除外）<ul>
<li><code>()-&gt;{}</code>：无参数的实现</li>
<li><code>item-&gt;{}</code>：单个参数的实现，jdk能够默认推断出参数的类型</li>
<li><code>(String item1,String item2)</code>：指定参数的类型</li>
</ul>
</li>
<li><code>FunctionalInterface</code>：标记这个接口只能定义一个方法（除了默认的方法）<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">display</span><span class="params">(String name)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</div><div class="line">       UserService userService=name -&gt; &#123;</div><div class="line">           <span class="keyword">return</span> name;</div><div class="line">       &#125;;</div><div class="line">       userService.display(<span class="string">"che"</span>);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="接口的默认方法和静态方法"><a href="#接口的默认方法和静态方法" class="headerlink" title="接口的默认方法和静态方法"></a>接口的默认方法和静态方法</h3><ul>
<li>默认方法不需要实现，但是可以被覆盖<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Demo1</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 接口的静态方法</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"cdc"</span>);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 默认方法可以不实现，但是可以被覆盖</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"cdddd"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><ul>
<li>Stream接口中包含许多对流操作的方法，这些方法分别为：<ul>
<li>filter()：对流的元素过滤</li>
<li>map()：将流的元素映射成另一个类型</li>
<li>distinct()：去除流中重复的元素</li>
<li>sorted()：对流的元素排序</li>
<li>forEach()：对流中的每个元素执行某个操作</li>
<li>peek()：与forEach()方法效果类似，不同的是，该方法会返回一个新的流，而forEach()无返回</li>
<li>limit()：截取流中前面几个元素</li>
<li>skip()：跳过流中前面几个元素</li>
<li>toArray()：将流转换为数组</li>
<li>reduce()：对流中的元素归约操作，将每个元素合起来形成一个新的值</li>
<li>collect()：对流的汇总操作，比如输出成List集合</li>
<li>anyMatch()：匹配流中的元素，类似的操作还有allMatch()和noneMatch()方法</li>
<li>findFirst()：查找第一个元素，类似的还有findAny()方法</li>
<li>max()：求最大值</li>
<li>min()：求最小值</li>
<li>count()：求总数</li>
</ul>
</li>
</ul>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><ul>
<li>过滤集合，实际是实现其中的test方法，返回的是一个Boolean类型的值，我们可以使用lambda表达式可以很轻松的实现集合的过滤<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">   <span class="meta">@Test</span>	</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</div><div class="line">       User user1 = <span class="keyword">new</span> User();</div><div class="line">       user1.setName(<span class="string">"chen"</span>);</div><div class="line">       user1.setAge(<span class="number">22</span>);</div><div class="line"></div><div class="line">       User user3 = <span class="keyword">new</span> User();</div><div class="line">       user3.setName(<span class="string">"zheng"</span>);</div><div class="line">       user3.setAge(<span class="number">22</span>);</div><div class="line"></div><div class="line">       User user2 = <span class="keyword">new</span> User();</div><div class="line">       user2.setName(<span class="string">"zhou"</span>);</div><div class="line">       user2.setAge(<span class="number">30</span>);</div><div class="line"></div><div class="line">       List&lt;User&gt; users=<span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">       users.add(user1);</div><div class="line">       users.add(user2);</div><div class="line">       users.add(user3);</div><div class="line"><span class="comment">/* 下面的语句类似如下</span></div><div class="line">        *   users.stream().filter(item-&gt;item.getAge()&gt;25).collect(Collectors.toList());</div><div class="line">        */	</div><div class="line">       List&lt;User&gt; collect = users.stream().filter(user -&gt; &#123;</div><div class="line">           <span class="keyword">if</span> (user.getAge() &gt; <span class="number">25</span>) &#123;</div><div class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">           &#125;</div><div class="line">       &#125;).collect(Collectors.toList());</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h4><ul>
<li><p>有两个实现的方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function">Stream&lt;T&gt; <span class="title">sorted</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span></span>;</div><div class="line"><span class="function">Stream&lt;T&gt; <span class="title">sorted</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
</li>
<li><p>例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Stream.of(<span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">8</span>)</div><div class="line">    .filter(n -&gt; n &gt; <span class="number">2</span>)     <span class="comment">// 对元素过滤，保留大于2的元素</span></div><div class="line">    .distinct()             <span class="comment">// 去重，类似于SQL语句中的DISTINCT</span></div><div class="line">    .skip(<span class="number">1</span>)                <span class="comment">// 跳过前面1个元素</span></div><div class="line">    .limit(<span class="number">2</span>)               <span class="comment">// 返回开头2个元素，类似于SQL语句中的SELECT TOP</span></div><div class="line">    .sorted()               <span class="comment">// 对结果排序</span></div><div class="line">    .forEach(System.out::println);</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//按照age排序，实际上就是实现Comparator的接口方法compareTo</span></div><div class="line">      users.sort((item1,item2)-&gt;&#123;</div><div class="line">          <span class="keyword">return</span> item1.getAge()-item2.getAge();</div><div class="line">      &#125;);</div></pre></td></tr></table></figure>
<h4 id="查找和匹配"><a href="#查找和匹配" class="headerlink" title="查找和匹配"></a>查找和匹配</h4><ul>
<li>Stream中提供的查找方法有anyMatch()、allMatch()、noneMatch()、findFirst()、findAny()，这些方法被用来查找或匹配某些元素是否符合给定的条件：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 检查流中的任意元素是否包含字符串"Java"</span></div><div class="line"><span class="keyword">boolean</span> hasMatch = Stream.of(<span class="string">"Java"</span>, <span class="string">"C#"</span>, <span class="string">"PHP"</span>, <span class="string">"C++"</span>, <span class="string">"Python"</span>)</div><div class="line">        .anyMatch(s -&gt; s.equals(<span class="string">"Java"</span>));</div><div class="line"></div><div class="line"><span class="comment">// 检查流中的所有元素是否都包含字符串"#"</span></div><div class="line"><span class="keyword">boolean</span> hasAllMatch = Stream.of(<span class="string">"Java"</span>, <span class="string">"C#"</span>, <span class="string">"PHP"</span>, <span class="string">"C++"</span>, <span class="string">"Python"</span>)</div><div class="line">        .allMatch(s -&gt; s.contains(<span class="string">"#"</span>));</div><div class="line"></div><div class="line"><span class="comment">// 检查流中的任意元素是否没有以"C"开头的字符串</span></div><div class="line"><span class="keyword">boolean</span> hasNoneMatch = Stream.of(<span class="string">"Java"</span>, <span class="string">"C#"</span>, <span class="string">"PHP"</span>, <span class="string">"C++"</span>, <span class="string">"Python"</span>)</div><div class="line">        .noneMatch(s -&gt; s.startsWith(<span class="string">"C"</span>));</div><div class="line"></div><div class="line"><span class="comment">// 查找元素</span></div><div class="line">Optional&lt;String&gt; element = Stream.of(<span class="string">"Java"</span>, <span class="string">"C#"</span>, <span class="string">"PHP"</span>, <span class="string">"C++"</span>, <span class="string">"Python"</span>)</div><div class="line">        .filter(s -&gt; s.contains(<span class="string">"C"</span>))</div><div class="line">        <span class="comment">// .findFirst()     // 查找第一个元素</span></div><div class="line">        .findAny();         <span class="comment">// 查找任意元素</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h4><h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><ul>
<li><p>map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</div><div class="line"><span class="comment">// 获取对应的平方数</span></div><div class="line">List&lt;Integer&gt; squaresList = numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList());</div></pre></td></tr></table></figure>
</li>
<li><p>map使用lambda表达式返回的类型就是最后的类型,下面我们将用户的年龄设置成两倍</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</div><div class="line">       User user1 = <span class="keyword">new</span> User();</div><div class="line">       user1.setName(<span class="string">"chen"</span>);</div><div class="line">       user1.setAge(<span class="number">22</span>);</div><div class="line"></div><div class="line">       User user3 = <span class="keyword">new</span> User();</div><div class="line">       user3.setName(<span class="string">"zheng"</span>);</div><div class="line">       user3.setAge(<span class="number">22</span>);</div><div class="line"></div><div class="line">       User user2 = <span class="keyword">new</span> User();</div><div class="line">       user2.setName(<span class="string">"zhou"</span>);</div><div class="line">       user2.setAge(<span class="number">40</span>);</div><div class="line"></div><div class="line">       List&lt;User&gt; users=<span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">       users.add(user1);</div><div class="line">       users.add(user2);</div><div class="line">       users.add(user3);</div><div class="line"></div><div class="line">       List&lt;User&gt; list = users.stream().map(item -&gt; &#123;</div><div class="line">           item.setAge(item.getAge() * <span class="number">2</span>);</div><div class="line">           <span class="keyword">return</span> item;</div><div class="line">       &#125;).collect(Collectors.toList());</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h5><ul>
<li>将两个元素进行归约操作，比如两个元素相加，但是这个操作的返回值一定要和操作之前的类型相同<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//归约操作，返回的是一个Optional类型的</span></div><div class="line">        Optional&lt;Integer&gt; optional = users.stream().map(item -&gt; item.getAge()).reduce((item1, item2) -&gt; item1 + item2);</div><div class="line">        <span class="keyword">if</span> (optional.isPresent())&#123;</div><div class="line">            System.out.println(optional.get());</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><ul>
<li><p>和关系数据库一样，流也提供了类似于数据库中GROUP BY分组的特性，由Collectors.groupingBy()方法提供：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//根据age进行分组，返回的是Map集合，key就是分组后的age，value是user对象</span></div><div class="line">        Map&lt;Integer, List&lt;User&gt;&gt; listMap = users.parallelStream().collect(Collectors.groupingBy(item -&gt; item.getAge()));</div><div class="line">        listMap.forEach((key,value)-&gt;&#123;</div><div class="line">            System.out.println(key+<span class="string">"---&gt;"</span>+value);</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>但实际情况可能比这复杂，比如将价格在0-50之间的书籍分成一组，50-100之间的分成一组，超过100的分成一组，这时候，我们可以直接使用Lambda表达式来表示这个分组逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//根据age进行分组，返回的是Map集合，key就是分组后的age，value是user对象</span></div><div class="line">        Map&lt;String, List&lt;User&gt;&gt; listMap = users.parallelStream().collect(Collectors.groupingBy(item -&gt; &#123;</div><div class="line">            <span class="keyword">if</span> (item.getAge() &gt; <span class="number">20</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="string">"A"</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> <span class="string">"B"</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;));</div><div class="line"></div><div class="line">        listMap.forEach((key,value)-&gt;&#123;</div><div class="line">            System.out.println(key+<span class="string">"---&gt;"</span>+value);</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><ul>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html" target="_blank" rel="external">文档</a></li>
<li><p><a href="https://zhuanlan.zhihu.com/p/40966718" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/40966718</a></p>
</li>
<li><p>创建方法：</p>
<ul>
<li><code>public static &lt;T&gt; Optional&lt;T&gt; of(T value)</code>：value的值不能为null</li>
<li><code>public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value)</code>：value允许为空</li>
</ul>
</li>
<li><p>常用方法</p>
<ul>
<li><code>public Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code>：过滤其中的元素，如果返回true，那么保留，返回false去除该元素</li>
<li><p><code>public T orElse(T other)</code>：如果该元素的值为null，那么指定该值为other</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">User user = <span class="keyword">new</span> User(<span class="number">22</span>, <span class="string">"chenjiabing"</span>);</div><div class="line">User user2 = Optional.ofNullable(user).filter(item-&gt;&#123;</div><div class="line">	<span class="keyword">return</span> item.getAge()&gt;<span class="number">30</span>;</div><div class="line">&#125;).orElse(<span class="keyword">null</span>);</div></pre></td></tr></table></figure>
</li>
<li><p><code>public T orElseGet(Supplier&lt;? extends T&gt; other)</code>：如果该值为空，那么就调用other的get方法，其中返回一个同种类型的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Optional.ofNullable(user).filter(item-&gt;&#123;</div><div class="line">	<span class="keyword">return</span> item.getAge()&gt;<span class="number">30</span>;</div><div class="line">&#125;).orElseGet(()-&gt;&#123;</div><div class="line">	System.out.println(<span class="string">"该值为空"</span>);</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">44</span>, <span class="string">"zhengjiahe"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p><code>public boolean isPresent()</code>：判断当前的元素是否为null，如果为null返回false，否则返回true</p>
</li>
<li><code>public void ifPresent(Consumer&lt;? super T&gt; consumer)</code>：如果不为空调用其中的方法</li>
<li><code>public &lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T,? extends U&gt; mapper)</code>：如果为空直接返回一个空的Optional，不会调用map中的apply方法，如果不为空，那么调用apply方法<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Optional&lt;Integer&gt; map = Optional.ofNullable(<span class="keyword">null</span>).map(item-&gt;&#123;</div><div class="line">	System.out.println(item);</div><div class="line">	<span class="comment">//返回值也决定着你的类型</span></div><div class="line">	<span class="keyword">return</span> Integer.MAX_VALUE;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h2><ul>
<li>针对集合操作的封装类，结合Stream编程客可以很简单的实现</li>
</ul>
<h3 id="toMap"><a href="#toMap" class="headerlink" title="toMap"></a>toMap</h3><ul>
<li>List直接转换为Map，使用JDK1.8的Stream编程</li>
<li><p><code>Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? super T, ? extends K&gt; keyMapper,Function&lt;? super T, ? extends U&gt; valueMapper)</code>：简单的将集合转换成Map，出现key重复的将直接抛出异常</p>
<ul>
<li><code>keyMapper</code>：指定的</li>
<li><code>valueMapper</code>：指定的value  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">        Map&lt;Integer, String&gt; map = users.stream().collect(Collectors.toMap(User::getAge, User::getName));</div><div class="line">`</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>public static &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? super T, ? extends K&gt; keyMapper,Function&lt;? super T, ? extends U&gt; valueMapper,BinaryOperator&lt;U&gt; mergeFunction)</code>：用于解决key冲突的情况</p>
<ul>
<li><code>mergeFunction</code>：用于当出现key冲突的情况下解决方法，其中只需要实现apply方法即可，两个参数分别是重复的map的value值，返回值是指定的值  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Map&lt;Integer, String&gt; map = users.stream().collect(Collectors.toMap(User::getAge, User::getName,(v1,v2)-&gt;v1+<span class="string">","</span>+v2));</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="toList"><a href="#toList" class="headerlink" title="toList"></a>toList</h3><ul>
<li>将结果转换成一个List集合<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; list = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).collect(Collectors.toList());</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="toSet"><a href="#toSet" class="headerlink" title="toSet"></a>toSet</h3><ul>
<li>将结果转换成一个Set集合<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Set&lt;Integer&gt; set = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).collect(Collectors.toSet());</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="groupingBy"><a href="#groupingBy" class="headerlink" title="groupingBy"></a>groupingBy</h3><ul>
<li>将所得的结果根据指定的内容进行分组，所得结果是一个Map类型的数据</li>
<li><p><code>public static &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt;
  groupingBy(Function&lt;? super T, ? extends K&gt; classifier)</code></p>
<ul>
<li>指定的key，value的默认类型为List<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Map&lt;Integer, List&lt;Integer&gt;&gt; map = Stream.of(<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).collect(</div><div class="line">           Collectors.groupingBy(Integer::intValue));</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>`public static <t, k,="" a,="" d=""><br>  Collector<t, ?,="" map<k,="" d="">&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier,</t,></t,></p>
<pre><code>Collector&lt;? super T, A, D&gt; downstream)`
</code></pre><ul>
<li>第一个参数是指定的key，第二个参数是指定的value的类型<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Map&lt;Integer, Set&lt;Integer&gt;&gt; map = Stream.of(<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).collect(</div><div class="line">           Collectors.groupingBy(Integer::intValue, Collectors.toSet()));</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JDk8新特性&quot;&gt;&lt;a href=&quot;#JDk8新特性&quot; class=&quot;headerlink&quot; title=&quot;JDk8新特性&quot;&gt;&lt;/a&gt;JDk8新特性&lt;/h1&gt;&lt;h2 id=&quot;函数式编程&quot;&gt;&lt;a href=&quot;#函数式编程&quot; class=&quot;headerlink&quot; ti
    
    </summary>
    
      <category term="java学习" scheme="http://chenjiabing666.github.io/categories/java%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java基础" scheme="http://chenjiabing666.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>springBoot制作docker镜像</title>
    <link href="http://chenjiabing666.github.io/2019/01/19/springBoot%E5%88%B6%E4%BD%9Cdocker%E9%95%9C%E5%83%8F/"/>
    <id>http://chenjiabing666.github.io/2019/01/19/springBoot制作docker镜像/</id>
    <published>2019-01-19T05:51:31.000Z</published>
    <updated>2019-01-19T05:52:29.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot制作docker镜像"><a href="#SpringBoot制作docker镜像" class="headerlink" title="SpringBoot制作docker镜像"></a>SpringBoot制作docker镜像</h1><h2 id="开启2375端口"><a href="#开启2375端口" class="headerlink" title="开启2375端口"></a>开启2375端口</h2><h2 id="修改docker配置文件"><a href="#修改docker配置文件" class="headerlink" title="修改docker配置文件"></a>修改docker配置文件</h2><ul>
<li><code>vim /usr/lib/systemd/system/docker.service</code></li>
<li>在<code>ExecStart=/usr/bin/dockerd</code>配置加上如下内容</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock</div></pre></td></tr></table></figure>
<ul>
<li>添加完之后的完整内容如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Type=notify</div><div class="line">NotifyAccess=main</div><div class="line">EnvironmentFile=-/run/containers/registries.conf</div><div class="line">EnvironmentFile=-/etc/sysconfig/docker</div><div class="line">EnvironmentFile=-/etc/sysconfig/docker-storage</div><div class="line">EnvironmentFile=-/etc/sysconfig/docker-network</div><div class="line">Environment=GOTRACEBACK=crash</div><div class="line">Environment=DOCKER_HTTP_HOST_COMPAT=1</div><div class="line">Environment=PATH=/usr/libexec/docker:/usr/bin:/usr/sbin</div><div class="line">ExecStart=/usr/bin/dockerd-current \</div><div class="line">          -H tcp://0.0.0.0:2375 \</div><div class="line">          -H unix:///var/run/docker.sock \</div><div class="line">          --add-runtime docker-runc=/usr/libexec/docker/docker-runc-current \</div><div class="line">          --default-runtime=docker-runc \</div><div class="line">          --exec-opt native.cgroupdriver=systemd \</div><div class="line">          --userland-proxy-path=/usr/libexec/docker/docker-proxy-current \</div><div class="line">          --init-path=/usr/libexec/docker/docker-init-current \</div><div class="line">          --seccomp-profile=/etc/docker/seccomp.json \</div><div class="line">          $OPTIONS \</div><div class="line">          $DOCKER_STORAGE_OPTIONS \</div><div class="line">          $DOCKER_NETWORK_OPTIONS \</div><div class="line">          $ADD_REGISTRY \</div><div class="line">          $BLOCK_REGISTRY \</div><div class="line">          $INSECURE_REGISTRY \</div><div class="line">          $REGISTRIES</div></pre></td></tr></table></figure>
<ul>
<li>重启docker</li>
</ul>
<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><ul>
<li>添加环境变量<code>DOCKER_HOST</code>的值为<code>tcp://ip:2375</code></li>
</ul>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><ul>
<li>将编写的Dockerfile文件放在<code>/src/main/docker</code>下，内容如下：</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> java:<span class="number">8</span></div><div class="line"></div><div class="line"><span class="keyword">MAINTAINER</span> https://chenjiabing666.github.io</div><div class="line"></div><div class="line"><span class="comment"># 指定虚拟卷，/tmp是tomcat运行时需要的，/usr/local/images是上传文件需要的，/usr/local/weblogs/demo是记录日志需要的</span></div><div class="line"><span class="keyword">VOLUME</span> ["/tmp","/usr/local/images","/usr/local/weblogs/demo"]</div><div class="line"></div><div class="line"><span class="comment"># 添加jar</span></div><div class="line"><span class="keyword">ADD</span> demo-server.jar demo.jar</div><div class="line"></div><div class="line"><span class="comment"># 暴露8080端口</span></div><div class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></div><div class="line"></div><div class="line"><span class="comment"># 运行jar</span></div><div class="line"><span class="keyword">CMD</span> ["java","-jar","demo.jar"]</div></pre></td></tr></table></figure>
<h2 id="配置maven插件"><a href="#配置maven插件" class="headerlink" title="配置maven插件"></a>配置maven插件</h2><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">&lt;build&gt;</div><div class="line">		&lt;finalName&gt;demo-server&lt;/finalName&gt;</div><div class="line">		&lt;plugins&gt;</div><div class="line">			&lt;!-- springBoot的maven打包插件 --&gt;</div><div class="line">			&lt;plugin&gt;</div><div class="line">				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</div><div class="line">			&lt;/plugin&gt;</div><div class="line"></div><div class="line">			&lt;plugin&gt;</div><div class="line">				&lt;groupId&gt;com.spotify&lt;/groupId&gt;</div><div class="line">				&lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;</div><div class="line">				&lt;version&gt;0.4.13&lt;/version&gt;</div><div class="line">				</div><div class="line">				&lt;!-- 将docker:build这个动作绑定在package这个动作上，只要maven install 即可上传到远程服务器 --&gt;</div><div class="line">				&lt;executions&gt;</div><div class="line">					&lt;execution&gt;</div><div class="line">						&lt;id&gt;build-image&lt;/id&gt;</div><div class="line">						&lt;phase&gt;package&lt;/phase&gt;</div><div class="line">						&lt;goals&gt;</div><div class="line">							&lt;goal&gt;build&lt;/goal&gt;</div><div class="line">						&lt;/goals&gt;</div><div class="line">					&lt;/execution&gt;</div><div class="line">				&lt;/executions&gt;</div><div class="line">				</div><div class="line">				&lt;configuration&gt;</div><div class="line">					</div><div class="line">					&lt;!-- 指定镜像的名称+版本，必须是满足[a-z,0-9]这个正则才行 --&gt;</div><div class="line">					&lt;imageName&gt;$&#123;project.artifactId&#125;:$&#123;project.version&#125;&lt;/imageName&gt;</div><div class="line">					</div><div class="line">					&lt;!-- 覆盖相同标签镜像 --&gt;</div><div class="line">					&lt;forceTags&gt;true&lt;/forceTags&gt;</div><div class="line">					</div><div class="line">					&lt;!-- 指定Dockerfile的文件位置 --&gt;</div><div class="line">					&lt;dockerDirectory&gt;$&#123;project.basedir&#125;/src/main/docker&lt;/dockerDirectory&gt;</div><div class="line">					</div><div class="line">					&lt;!-- 指定Dockerfile的文件位置 --&gt;</div><div class="line">					&lt;dockerHost&gt;http://39.105.123.197:2375&lt;/dockerHost&gt;</div><div class="line">					</div><div class="line">					&lt;!-- 指定jar包所在的位置 --&gt;</div><div class="line">					&lt;resources&gt;</div><div class="line">						&lt;resource&gt;</div><div class="line">							&lt;targetPath&gt;/&lt;/targetPath&gt;</div><div class="line">							&lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt;</div><div class="line">							&lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt;</div><div class="line">						&lt;/resource&gt;</div><div class="line">					&lt;/resources&gt;</div><div class="line">				&lt;/configuration&gt;</div><div class="line">			&lt;/plugin&gt;</div><div class="line">		&lt;/plugins&gt;</div><div class="line">	&lt;/build&gt;</div></pre></td></tr></table></figure>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><ul>
<li>我们制作镜像运行的时候需要挂载自己的虚拟卷，否则诸如创建文件夹和上传文件之类的都是在容器内创建的，不会在本机创建，因此我们需要将其挂载在自己的宿主机上，运行命令如下：<ul>
<li>使用<code>-v</code>挂载即可</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --name demo -p 8080:8080 -v /usr/local:/usr/local -v /tmp:/tmp -d 8877edd71d5a</div></pre></td></tr></table></figure>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><ul>
<li><a href="https://gitee.com/chenjiabing666/docker-server.git" target="_blank" rel="external">https://gitee.com/chenjiabing666/docker-server.git</a></li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://blog.csdn.net/qq_35615618/article/details/81201646" target="_blank" rel="external">https://blog.csdn.net/qq_35615618/article/details/81201646 </a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SpringBoot制作docker镜像&quot;&gt;&lt;a href=&quot;#SpringBoot制作docker镜像&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot制作docker镜像&quot;&gt;&lt;/a&gt;SpringBoot制作docker镜像&lt;/h1&gt;&lt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://chenjiabing666.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://chenjiabing666.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>docker搭建私有仓库</title>
    <link href="http://chenjiabing666.github.io/2018/12/30/docker%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    <id>http://chenjiabing666.github.io/2018/12/30/docker搭建私有仓库/</id>
    <published>2018-12-30T05:27:20.000Z</published>
    <updated>2018-12-30T05:27:46.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker私有仓库"><a href="#Docker私有仓库" class="headerlink" title="Docker私有仓库"></a>Docker私有仓库</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul>
<li><code>docker pull registry</code></li>
<li><code>docker run --name registry -p 5000:5000 -d registry</code></li>
<li>启动完成后访问<code>http:// 192.168.174.130:5000/v2/_catalog</code>即可看到如下的内容说明启动成功：</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	<span class="attr">"repositories"</span>: []</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p><strong>添加信任（无论是下载还是上传都需要添加，这里的ip和端口指定的是私有仓库的宿主机的ip）：</strong></p>
<ul>
<li><code>vim /etc/docker/daemon.json</code>，添加如下的内容：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">"insecure-registries":["192.168.174.130:5000"]</div></pre></td></tr></table></figure>
<ul>
<li>重启docker ,<code>systemctl restart docker</code></li>
</ul>
</li>
</ul>
<h2 id="上传镜像到私有仓库"><a href="#上传镜像到私有仓库" class="headerlink" title="上传镜像到私有仓库"></a>上传镜像到私有仓库</h2><ul>
<li><code>docker tag jdk8 192.168.174.130:5000/jdk8</code>： 标记该镜像<ul>
<li>指定仓库所在的ip和端口号</li>
<li>第一个jdk8是当前的镜像名称（或者填Id），后一个是上传到仓库中的名字，可以任意起</li>
</ul>
</li>
</ul>
<ul>
<li><p><code>docker images</code>：此时查看镜像，发现多了一个<code>192.168.174.130:5000/jdk8</code>的镜像</p>
</li>
<li><p><code>docker push 192.168.174.130:5000/jdk8</code> ：将标记的镜像上传到私有仓库中</p>
</li>
<li><p>此时再次访问<code>http:// 192.168.174.130:5000/v2/_catalog</code>，将会看到如下内容</p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"repositories"</span>: [</div><div class="line">    <span class="string">"jdk8"</span></div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><ul>
<li><p>添加信任</p>
<ul>
<li>vim /etc/docker/daemon.json`，添加如下的内容：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">"insecure-registries":["192.168.174.130:5000"]</div></pre></td></tr></table></figure>
<ul>
<li>重启docker ,<code>systemctl restart docker</code></li>
</ul>
</li>
</ul>
<ul>
<li>下载，需要指定ip和端口：<code>docker pull 192.168.174.130:5000/jdk8</code></li>
</ul>
<h2 id="Docker-Maven插件自动上传镜像到私有仓库"><a href="#Docker-Maven插件自动上传镜像到私有仓库" class="headerlink" title="Docker Maven插件自动上传镜像到私有仓库"></a>Docker Maven插件自动上传镜像到私有仓库</h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><h4 id="仓库所在服务器的配置"><a href="#仓库所在服务器的配置" class="headerlink" title="仓库所在服务器的配置"></a>仓库所在服务器的配置</h4><ul>
<li><p><strong>添加信任，同上</strong></p>
</li>
<li><p>修改 <code>/etc/sysconfig/docker</code>文件：<code>vim /etc/sysconfig/docker</code></p>
<ul>
<li><p>在最下面添加一行<code>DOCKER_OPTS=&#39;-H unix:///var/run/docker.sock -H 0.0.0.0:2375&#39;</code></p>
<ul>
<li><img src="https://github.com/chenjiabing666/BlogImage/blob/master/docker2.png?raw=true" alt=""></li>
</ul>
</li>
</ul>
</li>
<li><code>vim /lib/systemd/system/docker.service</code>添加如下内容<ul>
<li><img src="https://github.com/chenjiabing666/BlogImage/blob/master/docker1.png?raw=true" alt=""></li>
</ul>
</li>
</ul>
<ul>
<li>执行下面的命令刷新配置并且重启docker</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">systemctl daemon-reload</div><div class="line">systemctl restart docker</div></pre></td></tr></table></figure>
<ul>
<li><p>开启防火墙的端口：<code>firewall-cmd --zone=public --add-port=2375/tcp --permanent</code></p>
</li>
<li><p>重新载入配置<code>firewall-cmd --reload</code></p>
</li>
</ul>
<h4 id="项目中的配置"><a href="#项目中的配置" class="headerlink" title="项目中的配置"></a>项目中的配置</h4><ul>
<li>在pom.xml文件中添加如下内容：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></div><div class="line">		<span class="comment">&lt;!-- 指定的最终打成jar包的名字 --&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">finalName</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line">			<span class="comment">&lt;!-- SpringBoot的maven插件 --&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line"></div><div class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>docker-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">					<span class="comment">&lt;!-- 注意imageName需要指定的`IP:端口/image_name`的格式--&gt;</span></div><div class="line">					<span class="tag">&lt;<span class="name">imageName</span>&gt;</span>192.168.174.130:5000/$&#123;project.artifactId&#125;:$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">imageName</span>&gt;</span></div><div class="line">					<span class="comment">&lt;!-- 指定基础镜像，不需要运行，相当于 from hub.c.163.com/library/java:8-alpine --&gt;</span></div><div class="line">					<span class="tag">&lt;<span class="name">baseImage</span>&gt;</span>hub.c.163.com/library/java:8-alpine<span class="tag">&lt;/<span class="name">baseImage</span>&gt;</span></div><div class="line">					<span class="comment">&lt;!--覆盖相同标签镜像--&gt;</span></div><div class="line">					<span class="tag">&lt;<span class="name">forceTags</span>&gt;</span>true<span class="tag">&lt;/<span class="name">forceTags</span>&gt;</span>    </div><div class="line">					<span class="comment">&lt;!-- 运行jar包 --&gt;</span></div><div class="line">					<span class="tag">&lt;<span class="name">entryPoint</span>&gt;</span>["java", "-jar", "/$&#123;project.build.finalName&#125;.jar"]<span class="tag">&lt;/<span class="name">entryPoint</span>&gt;</span></div><div class="line">					<span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">						<span class="tag">&lt;<span class="name">resource</span>&gt;</span></div><div class="line">							<span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>/<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></div><div class="line">							<span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></div><div class="line">							<span class="tag">&lt;<span class="name">include</span>&gt;</span>$&#123;project.build.finalName&#125;.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></div><div class="line">						<span class="tag">&lt;/<span class="name">resource</span>&gt;</span></div><div class="line">					<span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div><div class="line">					<span class="comment">&lt;!-- 指定私有仓库所在服务器的2375端口，之前配置过可以远程访问的那个 --&gt;</span></div><div class="line">					<span class="tag">&lt;<span class="name">dockerHost</span>&gt;</span>http://192.168.174.130:2375<span class="tag">&lt;/<span class="name">dockerHost</span>&gt;</span></div><div class="line">				<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>在命令台运行如下的命令，即可完成生成镜像并且上传到私有仓库</strong><ul>
<li><code>mvn clean package docker:build -DpushImage</code></li>
</ul>
</li>
<li><strong>上述命令的解析如下：</strong><ul>
<li><code>mvn clean package</code>：maven打jar包</li>
<li><code>docker:build</code>：docker构建镜像的命令</li>
<li><code>-DpushImage</code>： 将生成的镜像上传到私有仓库中</li>
</ul>
</li>
</ul>
<ul>
<li><strong>执行并且运行成功之后访问<code>http://192.168.174.130:5000/v2/_catalog</code>，将会出现如下的内容</strong></li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"repositories"</span>: [</div><div class="line">    <span class="string">"demo"</span></div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>访问<code>http://192.168.174.130:5000/v2/demo/tags/list</code>，可以看到demo这个镜像的所有版本</strong></li>
</ul>
<p><img src="https://github.com/chenjiabing666/BlogImage/blob/master/docker3.png?raw=true" alt=""></p>
<ul>
<li>上面的运行完成之后，查看项目中自动生成Dockerfile，如下：</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> hub.c.<span class="number">163</span>.com/library/java:<span class="number">8</span>-alpine</div><div class="line"><span class="keyword">ADD</span> /demo.jar //</div><div class="line"><span class="keyword">ENTRYPOINT</span> ["java", "-jar", "/demo.jar"]</div></pre></td></tr></table></figure>
<h4 id="拉取上传的镜像并且运行"><a href="#拉取上传的镜像并且运行" class="headerlink" title="拉取上传的镜像并且运行"></a>拉取上传的镜像并且运行</h4><ul>
<li>在拉取之前需要添加信任</li>
<li>使用 <code>docker pull 192.168.174.130:5000/demo:0.0.1-SNAPSHOT</code>下载仓库中的镜像</li>
<li>运行镜像：<code>docker run --name demo -p 7001:7001 -d f7f36f3f3f06</code><ul>
<li><strong>其中生成的镜像端口为项目自己本身配置的端口，只需要映射出去即可</strong></li>
</ul>
</li>
<li>此时我们可以访问<code>http://192.168.174.128:7001/</code>，就能看到eureka注册中心的页面</li>
</ul>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><ul>
<li><a href="https://gitee.com/chenjiabing666/docker-maven.git" target="_blank" rel="external">https://gitee.com/chenjiabing666/docker-maven.git</a></li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://blog.csdn.net/qq_39623859/article/details/80072545" target="_blank" rel="external">https://blog.csdn.net/qq_39623859/article/details/80072545</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker私有仓库&quot;&gt;&lt;a href=&quot;#Docker私有仓库&quot; class=&quot;headerlink&quot; title=&quot;Docker私有仓库&quot;&gt;&lt;/a&gt;Docker私有仓库&lt;/h1&gt;&lt;h2 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; class=&quot;headerli
    
    </summary>
    
      <category term="docker" scheme="http://chenjiabing666.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="http://chenjiabing666.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Dockerfile</title>
    <link href="http://chenjiabing666.github.io/2018/12/30/Dockerfile/"/>
    <id>http://chenjiabing666.github.io/2018/12/30/Dockerfile/</id>
    <published>2018-12-30T05:26:02.000Z</published>
    <updated>2018-12-30T05:26:37.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h1><ul>
<li><p>镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p>
</li>
<li><p>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>FROM image:tag</code></td>
<td>指定基础镜像，有点继承的意思</td>
</tr>
<tr>
<td><code>MAINTAINER user_name</code></td>
<td>声明镜像的创建者</td>
</tr>
<tr>
<td><code>ENV key value</code></td>
<td>设置环境变量，可以设置多条,比如 ENV VERSION=1.0</td>
</tr>
<tr>
<td><code>RUN command</code></td>
<td>核心命令，多个命令用&amp;&amp;连接即可</td>
</tr>
<tr>
<td><code>ADD source_dir/file dest_dir/file</code></td>
<td>将宿主机的文件负复制到容器内，如果是一个压缩文件，将会自动解压缩</td>
</tr>
<tr>
<td><code>COPY source_dir/file dest_dir/file</code></td>
<td>和ADD命令类似，但是不能自动解压缩</td>
</tr>
<tr>
<td><code>WORKDIR path_dir</code></td>
<td>指定当前的工作目录，由于分层的概念，每一个命令的工作目录都不同，因此需要使用该命令显示指定工作目录</td>
</tr>
<tr>
<td>CMD args</td>
<td>在构建容器的时候使用，会docker run 后的args覆盖</td>
</tr>
<tr>
<td>ENTRYPOINT  args</td>
<td>和CMD相似，但是不会被docker run后的args覆盖</td>
</tr>
<tr>
<td>VOLUME</td>
<td>将本地文件夹挂载到容器中</td>
</tr>
</tbody>
</table>
<h2 id="配置镜像加速"><a href="#配置镜像加速" class="headerlink" title="配置镜像加速"></a>配置镜像加速</h2><ul>
<li>我们使用阿里云的镜像加速</li>
<li><code>vim /etc/docker/daemon.json</code>,设置如下内容即可：</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">        <span class="attr">"registry-mirrors"</span>:[<span class="string">"https://rxx4pnmv.mirror.aliyuncs.com"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="构建简单的JDK镜像"><a href="#构建简单的JDK镜像" class="headerlink" title="构建简单的JDK镜像"></a>构建简单的JDK镜像</h2><ul>
<li>新建一个<code>Dockerfile</code></li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 初始镜像,默认拉去lastest的</span></div><div class="line"><span class="keyword">FROM</span> centos</div><div class="line"><span class="comment"># 指定镜像的构建者</span></div><div class="line"><span class="keyword">MAINTAINER</span> chenjiabing666</div><div class="line"><span class="comment"># 切换工作目到usr，这个是容器中的目录</span></div><div class="line"><span class="keyword">WORKDIR</span> /usr</div><div class="line"><span class="comment"># 新建 /usr/local/java目录</span></div><div class="line"><span class="keyword">RUN</span> mkdir /usr/local/java</div><div class="line"><span class="comment"># 添加本地的jdk到容器中并且解压</span></div><div class="line"><span class="keyword">ADD</span> jdk-8u172-linux-x64.tar.gz /usr/local/java/</div><div class="line"><span class="comment"># 设置环境变量</span></div><div class="line"><span class="keyword">ENV</span> JAVA_HOME /usr/local/java/jdk1.<span class="number">8.0</span>_181</div><div class="line"><span class="keyword">ENV</span> CLASSPATH $JAVA_HOME/lib;$JAVA_HOME/jre/lib</div><div class="line"><span class="keyword">ENV</span> PATH $PATH:$JAVA_HOME/bin</div></pre></td></tr></table></figure>
<ul>
<li><code>docker build -t jdk8 .</code>：构建镜像</li>
<li><code>docker run --name jdk -di jdk8</code>：运行镜像</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://blog.csdn.net/wo18237095579/article/details/80540571" target="_blank" rel="external">https://blog.csdn.net/wo18237095579/article/details/80540571</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;DockerFile&quot;&gt;&lt;a href=&quot;#DockerFile&quot; class=&quot;headerlink&quot; title=&quot;DockerFile&quot;&gt;&lt;/a&gt;DockerFile&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们
    
    </summary>
    
      <category term="docker" scheme="http://chenjiabing666.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="http://chenjiabing666.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot实现BCrypt密码加密</title>
    <link href="http://chenjiabing666.github.io/2018/12/25/SpringBoot%E5%AE%9E%E7%8E%B0BCrypt%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86/"/>
    <id>http://chenjiabing666.github.io/2018/12/25/SpringBoot实现BCrypt密码加密/</id>
    <published>2018-12-25T13:07:15.000Z</published>
    <updated>2018-12-25T13:07:44.432Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-实现-BCrypt密码加密"><a href="#SpringBoot-实现-BCrypt密码加密" class="headerlink" title="SpringBoot 实现 BCrypt密码加密"></a>SpringBoot 实现 BCrypt密码加密</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>出于安全的考虑，一些敏感的信息是绝对不能以明文的方式存储在数据库中的，比如密码通常是通过哈希算法进行加密的。有很多标准的算法比如<code>SHA</code>和<code>MD5</code>，结合<code>salt</code>（盐）是一种不错的选择，但是如果知道其加密的规则还是相对不安全。</li>
<li>Spring security提供了<code>BCryptPasswordEncoder</code>类，使用Bcrypt强哈希方法来加密密码</li>
<li><strong>Bcrypt强哈希算法每次加密的结果都是不一样的。</strong></li>
</ul>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><ul>
<li><code>public String encode(CharSequence rawPassword)</code>： 对给定的内容进行加密，返回加密后的字符串</li>
<li><code>public boolean matches(CharSequence rawPassword, String encodedPassword)</code>： 比较给定的字符串和加密后的字符串是否是同一个<ul>
<li><code>rawPassword</code>：未加密的字符串</li>
<li><code>encodedPassword</code>： 加密后的字符串</li>
</ul>
</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li>引入spring security的依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>添加security的配置类，如下:<ul>
<li><strong>在其中注入<code>BCryptPasswordEncoder</code></strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Spring security的配置类</div><div class="line"> */</div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		http.authorizeRequests()</div><div class="line">		.antMatchers(<span class="string">"/**"</span>)</div><div class="line">		.permitAll()</div><div class="line">		.anyRequest()</div><div class="line">		.authenticated()</div><div class="line">		.and().csrf().disable();</div><div class="line">		<span class="keyword">super</span>.configure(http);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * 注入BCryptPasswordEncoder</div><div class="line">	 */</div><div class="line">	<span class="meta">@Bean</span></div><div class="line">	<span class="function"><span class="keyword">public</span> BCryptPasswordEncoder <span class="title">bCryptPasswordEncoder</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>主配置类添加<code>@EnableWebSecurity</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="meta">@EnableWebSecurity</span>   <span class="comment">//开启security</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthServerApplication</span> </span>&#123;</div></pre></td></tr></table></figure>
<ul>
<li>在业务层实现登录和注册的功能 ，对密码进行加密和校验</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="meta">@Transactional</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="meta">@Resource</span></div><div class="line">	<span class="keyword">private</span> UserRepository userRepository;</div><div class="line">	</div><div class="line">	<span class="meta">@Resource</span></div><div class="line">	<span class="keyword">private</span> BCryptPasswordEncoder bCryptPasswordEncoder;  <span class="comment">//注入bcryct加密</span></div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">add</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">		user.setPassword(bCryptPasswordEncoder.encode(user.getPassword())); <span class="comment">//对密码进行加密</span></div><div class="line">		User user2 = userRepository.save(user);</div><div class="line">		<span class="keyword">return</span> user2;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> ResultInfo <span class="title">login</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">		ResultInfo resultInfo=<span class="keyword">new</span> ResultInfo();</div><div class="line">		User user2 = userRepository.findByName(user.getName());  </div><div class="line">		<span class="keyword">if</span> (user2==<span class="keyword">null</span>) &#123;</div><div class="line">			resultInfo.setCode(<span class="string">"-1"</span>);</div><div class="line">			resultInfo.setMessage(<span class="string">"用户名不存在"</span>);</div><div class="line">			<span class="keyword">return</span> resultInfo;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="comment">//判断密码是否正确</span></div><div class="line">		<span class="keyword">if</span> (!bCryptPasswordEncoder.matches(user.getPassword(),user2.getPassword())) &#123;</div><div class="line">			resultInfo.setCode(<span class="string">"-1"</span>);</div><div class="line">			resultInfo.setMessage(<span class="string">"密码不正确"</span>);</div><div class="line">			<span class="keyword">return</span> resultInfo;</div><div class="line">		&#125;</div><div class="line">		resultInfo.setMessage(<span class="string">"登录成功"</span>);</div><div class="line">		<span class="keyword">return</span> resultInfo;</div><div class="line">	&#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><ul>
<li><a href="https://gitee.com/chenjiabing666/auth-server.git" target="_blank" rel="external">https://gitee.com/chenjiabing666/auth-server.git</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SpringBoot-实现-BCrypt密码加密&quot;&gt;&lt;a href=&quot;#SpringBoot-实现-BCrypt密码加密&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot 实现 BCrypt密码加密&quot;&gt;&lt;/a&gt;SpringBoot 实现 
    
    </summary>
    
      <category term="SpringBoot" scheme="http://chenjiabing666.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://chenjiabing666.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>zuul服务网关</title>
    <link href="http://chenjiabing666.github.io/2018/12/25/zuul%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/"/>
    <id>http://chenjiabing666.github.io/2018/12/25/zuul服务网关/</id>
    <published>2018-12-25T13:05:22.000Z</published>
    <updated>2019-01-14T12:30:08.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Zuul包含了对请求的路由和过滤两个主要的功能，其中路由功能负责将外部的请求转发到具体的微服务实例上，是实现外部访问统一入口的基础上，而过滤功能则负责对请求的处理过程进行干预，是实现请求校验，服务聚合等功能的基础。</li>
<li>Zuul和Eureka进行整合，将Zuul自身注册为Eureka服务治理下的应用，同时从Eureka中获取其他微服务的信息，也即以后访问微服务都是通过Zuul跳转后获得</li>
<li>代理+路由+过滤三大功能</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li>需要和Eureka客户端结合使用，依赖如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--zuul的依赖--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>添加配置，将其注册到eureka中，如下：</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="attr">server:</span></div><div class="line"><span class="attr">  port:</span> <span class="number">9001</span></div><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  client:</span></div><div class="line"><span class="attr">    serviceUrl:</span></div><div class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:7001/eureka</span>  <span class="comment"># eureka的暴露地址，直接注册</span></div><div class="line"><span class="attr">  instance:</span></div><div class="line"><span class="attr">    instance-id:</span> <span class="string">zuul.com</span></div><div class="line"><span class="attr">    prefer-ip-address:</span> <span class="literal">true</span></div><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  application:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">zuul</span>   <span class="comment">#应用的名称，在同一个eureka中必须不重复</span></div></pre></td></tr></table></figure>
<ul>
<li>在主启动类上添加<code>@EnableZuulProxy</code>这个注解，如下:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="meta">@EnableEurekaClient</span>  <span class="comment">//开启eurkea客户端</span></div><div class="line"><span class="meta">@EnableZuulProxy</span>   <span class="comment">//开启zuul</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptGetWayZuul9001Application</span> </span>&#123;</div></pre></td></tr></table></figure>
<ul>
<li>启动即可，在eureka中看到注册进入即可</li>
<li><strong>之后只需要通过zuul访问其他的微服务提供者即可，比如服务提供者的实例名称为<code>dept-provider</code>，那么通过zuul访问的路径为<code>http://localhost:9001/dept-provider/dept/1</code></strong></li>
</ul>
<h2 id="路由映射规则"><a href="#路由映射规则" class="headerlink" title="路由映射规则"></a>路由映射规则</h2><h3 id="代理名称"><a href="#代理名称" class="headerlink" title="代理名称"></a>代理名称</h3><ul>
<li>之前的配置访问的还是需要带上微服务的实例名称，但是我们不想微服务的实例名称暴露，那么此时就需要使用代理名称替代，配置如下:<ul>
<li>使用<code>ignored-services</code>忽略真实的服务名称访问，可以同时指定多个，其中服务名称必须和服务配置文件中一样。</li>
<li>在routes下指定多个路由映射规则</li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="attr">zuul:</span></div><div class="line">  <span class="comment"># 忽略真实的服务名称实例访问，是一个Set集合，可以指定多个，取消全部使用 "*"即可</span></div><div class="line"><span class="attr">  ignored-services:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">order-provider</span></div><div class="line">  <span class="comment">#routes下面指定代理规则，可以同时指定多个</span></div><div class="line"><span class="attr">  routes:</span></div><div class="line">    <span class="comment">#指定第一个规则，这里的名称任意</span></div><div class="line"><span class="attr">    api-order:</span></div><div class="line">      <span class="comment">#指定的实例名称</span></div><div class="line"><span class="attr">      serviceId:</span> <span class="string">order-provider</span></div><div class="line">      <span class="comment">#指定可以访问的路由</span></div><div class="line"><span class="attr">      path:</span> <span class="string">/api-order/**</span></div></pre></td></tr></table></figure>
<ul>
<li>按照上面的配置完成之后就可以直接使用映射的路由访问即可，如：<code>http://zuul.com:9001/api-order/order/1</code></li>
</ul>
<h2 id="设置统一前缀"><a href="#设置统一前缀" class="headerlink" title="设置统一前缀"></a>设置统一前缀</h2><ul>
<li>我们可以在所有的访问uri前面加上统一的前缀，配置如下:<ul>
<li>使用<code>zuul.prefix</code>加上统一的前缀即可</li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="attr">zuul:</span></div><div class="line">  <span class="comment">#加上统一的前缀，那么访问的时候一定要加上这个前缀才可以访问到</span></div><div class="line"><span class="attr">  prefix:</span> <span class="string">/chenjiabing</span></div><div class="line">  <span class="comment"># 忽略真实的服务名称实例访问，是一个Set集合，可以指定多个，取消全部使用 "*"即可</span></div><div class="line"><span class="attr">  ignored-services:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">order-provider</span></div><div class="line">  <span class="comment">#routes下面指定代理规则，可以同时指定多个</span></div><div class="line"><span class="attr">  routes:</span></div><div class="line">    <span class="comment">#指定第一个规则，这里的名称任意</span></div><div class="line"><span class="attr">    api-dept:</span></div><div class="line">      <span class="comment">#指定的实例名称</span></div><div class="line"><span class="attr">      serviceId:</span> <span class="string">order-provider</span></div><div class="line">      <span class="comment">#指定可以访问的路由</span></div><div class="line"><span class="attr">      path:</span> <span class="string">/api-order/**</span></div></pre></td></tr></table></figure>
<ul>
<li>通过上面的配置，此时的访问路径变成<code>http://zuul.com:9001/chenjiabing/api-order/order/1</code></li>
</ul>
<h2 id="某个uri取消路由"><a href="#某个uri取消路由" class="headerlink" title="某个uri取消路由"></a>某个uri取消路由</h2><ul>
<li><p>使用<code>zuul.ignored-services</code>是忽略一个或者多个微服务的全部接口，但是如果我们可以更细化</p>
</li>
<li><p>如果我们需要隐藏一些敏感的接口不给访问，我们可以在yml文件中配置，如下:</p>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">zuul:</span></div><div class="line"><span class="attr">  ignored-patterns:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">/api-order/order/list</span>   <span class="comment"># 取消指定的一个</span></div><div class="line"><span class="bullet">  -</span> <span class="string">/api-order/order/**</span>     <span class="comment"># 使用通配符去掉order下的全部接口</span></div></pre></td></tr></table></figure>
<h2 id="传递敏感头信息"><a href="#传递敏感头信息" class="headerlink" title="传递敏感头信息"></a>传递敏感头信息</h2><ul>
<li>默认zuul是不能传递头信息的，比如cookie，默认的设置了三个字段，如下:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Set&lt;String&gt; sensitiveHeaders = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(</div><div class="line">			Arrays.asList(<span class="string">"Cookie"</span>, <span class="string">"Set-Cookie"</span>, <span class="string">"Authorization"</span>));</div></pre></td></tr></table></figure>
<ul>
<li>如果我们想让它不过滤，只需要将其设置为空，或者不配置其他的，如下：<ul>
<li>将<code>sensitive-headers</code>这个值设置为空即可</li>
<li><strong>这个配置只是针对<code>order-provider</code>这个微服务起作用</strong></li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attr">zuul:</span></div><div class="line"><span class="attr">  routes:</span></div><div class="line">    <span class="comment">#指定第一个规则，这里的名称任意</span></div><div class="line"><span class="attr">    api-order:</span></div><div class="line">      <span class="comment">#指定的实例名称</span></div><div class="line"><span class="attr">      serviceId:</span> <span class="string">order-provider</span></div><div class="line">      <span class="comment">#指定可以访问的路由</span></div><div class="line"><span class="attr">      path:</span> <span class="string">/api-order/**</span></div><div class="line"><span class="attr">      sensitive-headers:</span>   <span class="comment"># 设置为空即可，那么就可以传递敏感头信息了</span></div></pre></td></tr></table></figure>
<ul>
<li>上面的配置是针对单个服务的设置，我们也可以配置针对所有的服务，如下：</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attr">zuul:</span></div><div class="line"><span class="attr">  sensitive-headers:</span>   <span class="comment"># 设置所有的服务都取消敏感头信息</span></div></pre></td></tr></table></figure>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul>
<li>Filter 的生命周期有 4 个，分别是 “PRE”、“ROUTING”、“POST” 和“ERROR”，整个生命周期可以用下图来表示 </li>
<li><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fqmg1wtyhdj30pl0fqdgt.jpg" alt=""></li>
<li>生命周期解释如下：<ul>
<li><strong><code>PRE</code>：</strong>这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现<strong>身份验证、鉴权、限流、参数校验、请求转发</strong>，在集群中选择请求的微服务、记录调试信息等。</li>
<li><strong><code>ROUTING</code>：</strong>这种过滤器将请求路由到微服务。这种过滤器用于构建发送给微服务的请求，并使用 Apache HttpClient 或 Netfilx Ribbon 请求微服务。</li>
<li><strong><code>POST</code>：</strong>这种过滤器在路由到微服务以后执行。这种过滤器可用来为<strong>响应添加标准的 HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端</strong>等。</li>
<li><strong><code>ERROR</code>：</strong>在其他阶段发生错误时执行该过滤器。 除了默认的过滤器类型，Zuul 还允许我们创建自定义的过滤器类型。例如，我们可以定制一种 STATIC 类型的过滤器，直接在 Zuul 中生成响应，而不将请求转发到后端的微服务。</li>
</ul>
</li>
</ul>
<h3 id="前置过滤器的使用"><a href="#前置过滤器的使用" class="headerlink" title="前置过滤器的使用"></a>前置过滤器的使用</h3><ul>
<li>利用前置过滤器实现检测token是否正确，如果不正确，那么直接返回权限不足401状态码，不路由微服务</li>
<li>继承<code>ZuulFilter</code></li>
<li>注入到ioc容器中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 	自定义过滤器，用于实现鉴权，前置过滤器</div><div class="line"> *  	继承ZuulFilter</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span>  <span class="comment">//一定要注入到ioc容器中</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 	判断过滤器是否被执行，返回true表示被会被执</div><div class="line">	 * 	 在这里我们可以限制过滤器的执行范围，可以根据指定的条件判断这个请求是否被过滤</div><div class="line">	 */</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 *	 过滤器的具体实现逻辑</div><div class="line">	 * <span class="doctag">@return</span></div><div class="line">	 * <span class="doctag">@throws</span> ZuulException</div><div class="line">	 */</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</div><div class="line">		RequestContext requestContext = RequestContext.getCurrentContext();  <span class="comment">//获取请求上下文</span></div><div class="line">		HttpServletRequest request = requestContext.getRequest();  <span class="comment">//获取HttpServletRequest</span></div><div class="line">		String token = request.getParameter(<span class="string">"token"</span>);  <span class="comment">//获取传递过来的请求参数</span></div><div class="line">		<span class="comment">//如果token是空的，返回权限不足，一般返回的状态码是401</span></div><div class="line">		<span class="keyword">if</span> (StringUtils.isEmpty(token)) &#123;</div><div class="line">			requestContext.setSendZuulResponse(<span class="keyword">false</span>);  <span class="comment">//设置false，此时的zuul不对此路由</span></div><div class="line">			requestContext.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value());  <span class="comment">//设置401</span></div><div class="line"><span class="comment">//			requestContext.setResponseBody("no power");  //设置响应的消息</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 	指定过滤器的类型，前置，后置.................</div><div class="line">	 * 1、其中FilterConstants这个常量类中定义了过滤器常用的变量</div><div class="line">	 * 	    public static final String ERROR_TYPE = "error";</div><div class="line">			public static final String POST_TYPE = "post";</div><div class="line">			public static final String PRE_TYPE = "pre";</div><div class="line">			public static final String ROUTE_TYPE = "route";	</div><div class="line">	 * <span class="doctag">@return</span></div><div class="line">	 */</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> FilterConstants.PRE_TYPE;    <span class="comment">//前置过滤器 pre</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 	过滤器执行的顺序，数字越小优先级越高</div><div class="line">	 * <span class="doctag">@return</span></div><div class="line">	 */</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">//一般前置过滤器放在org.springframework.cloud.netflix.zuul.filters.pre.PreDecorationFilter这个过滤器之前即可，只需要将其对应的顺序-1</span></div><div class="line">		<span class="keyword">return</span> FilterConstants.PRE_DECORATION_FILTER_ORDER-<span class="number">1</span>; </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="后置过滤器的使用"><a href="#后置过滤器的使用" class="headerlink" title="后置过滤器的使用"></a>后置过滤器的使用</h3><ul>
<li>利用后置过滤器在响应头中添加内容，和前置过滤器的使用一样，只是使用的过滤器的类型不用，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 后置过滤器，在响应头中添加一些内容</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span> <span class="comment">//注入</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddResponseHeaderFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</div><div class="line">		RequestContext requestContext = RequestContext.getCurrentContext();  <span class="comment">//获取请求上下文</span></div><div class="line">		HttpServletResponse response = requestContext.getResponse();  <span class="comment">//获取HttpServletResponse</span></div><div class="line">		response.addHeader(<span class="string">"X-Foo"</span>, <span class="string">"add header"</span>);  <span class="comment">//添加头信息</span></div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> FilterConstants.POST_TYPE; <span class="comment">//后置过滤器</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">//在org.springframework.cloud.netflix.zuul.filters.post.SendResponseFilter#filterOrder()这个过滤一起之前执行即可</span></div><div class="line">		<span class="keyword">return</span> FilterConstants.SEND_RESPONSE_FILTER_ORDER-<span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="禁用某种过滤器"><a href="#禁用某种过滤器" class="headerlink" title="禁用某种过滤器"></a>禁用某种过滤器</h2><ul>
<li>如果我们想要禁用某种过滤器（自定义或者zuul自身的），我们可以在配置中设置，格式：<code>zuul.&lt;SimpleClassName&gt;.&lt;filterType&gt;.disable=true</code>，比如禁用我们TokenFilter，如下：</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">zuul:</span></div><div class="line"><span class="attr">  TokenFilter:</span>  <span class="comment"># 类的名字</span></div><div class="line"><span class="attr">    pre:</span>        <span class="comment"># 类型</span></div><div class="line"><span class="attr">      disable:</span> <span class="literal">true</span></div></pre></td></tr></table></figure>
<h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><ul>
<li><a href="https://blog.csdn.net/tianyaleixiaowu/article/details/74942405" target="_blank" rel="external">https://blog.csdn.net/tianyaleixiaowu/article/details/74942405</a></li>
<li><a href="https://baike.baidu.com/item/%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95/6597000?fr=aladdin" target="_blank" rel="external">https://baike.baidu.com/item/%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95/6597000?fr=aladdin</a></li>
<li>系统按照恒定的速率往指定大小的桶里添加令牌，每来一个请求就消耗一个令牌，如果桶内没有令牌表示此事的请求流量已经超过设置的大小了，应该做出相应的响应或者直接抛出异常</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul>
<li>使用前置过滤器，在请求被转发之前调用，<strong>限流的过滤器应该是所有过滤器中优先级最大的</strong></li>
<li>使用google开源的组件<code>Guava</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.zuul.filters.support.FilterConstants;</div><div class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</div><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</div><div class="line"><span class="keyword">import</span> com.google.common.util.concurrent.RateLimiter;</div><div class="line"><span class="keyword">import</span> com.netflix.zuul.ZuulFilter;</div><div class="line"><span class="keyword">import</span> com.netflix.zuul.context.RequestContext;</div><div class="line"><span class="keyword">import</span> com.netflix.zuul.exception.ZuulException;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 	限流	，前置过滤器</div><div class="line"> * 	限流的过滤器的优先级应该是最高，数字最小</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RateLimiter RATE_LIMITER=RateLimiter.create(<span class="number">100</span>);  <span class="comment">//程每秒钟往桶里放置100个令牌</span></div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</div><div class="line">		</div><div class="line">		<span class="comment">/**</span></div><div class="line">		 * 	tryAcquire()：如果获取不到一个令牌,表示流量超时了，没有等待时间</div><div class="line">		 *  tryAcquire(int permits, long timeout, TimeUnit unit)：获取permits个令牌，如果在指定的时间timeout内，还是没有获取到指定的permits个令牌，那么就返回false</div><div class="line">		 */</div><div class="line">		<span class="keyword">if</span> (!RATE_LIMITER.tryAcquire()) &#123;</div><div class="line">			RequestContext requestContext = RequestContext.getCurrentContext();</div><div class="line">			requestContext.setSendZuulResponse(<span class="keyword">false</span>);  <span class="comment">//不路由</span></div><div class="line">			requestContext.setResponseStatusCode(HttpStatus.FORBIDDEN.value());  <span class="comment">//403拒绝访问</span></div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="comment">//也可以直接抛出异常</span></div><div class="line"><span class="comment">//		if (!RATE_LIMITER.tryAcquire()) &#123;</span></div><div class="line"><span class="comment">//			throw new RuntimeException();  //抛出异常</span></div><div class="line"><span class="comment">//		&#125;</span></div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> FilterConstants.PRE_TYPE;  <span class="comment">//前置</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">//org.springframework.cloud.netflix.zuul.filters.pre.ServletDetectionFilter#filterOrder()这个过滤器的优先级是最高的，只需要-1即可</span></div><div class="line">		<span class="keyword">return</span> FilterConstants.SERVLET_DETECTION_FILTER_ORDER-<span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="多维度限流"><a href="#多维度限流" class="headerlink" title="多维度限流"></a>多维度限流</h3><ul>
<li><a href="https://segmentfault.com/a/1190000012252677" target="_blank" rel="external">https://segmentfault.com/a/1190000012252677</a></li>
</ul>
<h2 id="鉴权"><a href="#鉴权" class="headerlink" title="鉴权"></a>鉴权</h2><ul>
<li><a href="https://www.jianshu.com/p/f89f5557990f" target="_blank" rel="external">https://www.jianshu.com/p/f89f5557990f</a></li>
<li>一些api只有具有某些权限的时候才可以被调用，比如用户的一些相关信息，只有在用户登录之后才可以调用，否则将会提示没有权限</li>
</ul>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><ul>
<li>我们在用户登录成功之后会在返回头中添加cookie的值为<code>openId=random(随机数)</code>，并且将其保存在<code>redis</code>中（key=openId_userId，value=random）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 登录的方法，登录成功响应头返回添加cookie</div><div class="line"> * <span class="doctag">@param</span> response</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user/login"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(HttpServletResponse response)</span> </span>&#123;</div><div class="line">	<span class="comment">//登录的逻辑。。。。。</span></div><div class="line">	 </div><div class="line">	<span class="comment">//设置cookie的值</span></div><div class="line">	Cookie cookie=<span class="keyword">new</span> Cookie(<span class="string">"openId"</span>, UUID.randomUUID().toString());  </div><div class="line">	cookie.setMaxAge(<span class="number">60</span>*<span class="number">60</span>);  </div><div class="line">	response.addCookie(cookie);  <span class="comment">//添加到响应头中</span></div><div class="line">	</div><div class="line">	<span class="comment">//添加到redis中，key=openId_userId,value=uuid的值</span></div><div class="line">	</div><div class="line">	<span class="keyword">return</span> <span class="string">"登录成功"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>我们事先将指定权限的接口uri存放在数据库中，在zuul中定义一个鉴权的过滤器，如果请求过来了，判断这个uri是否需要某种权限才能调用，如果不需要直接路由即可，如果需要那么判断<code>cookie</code>中是否有openId，如果没有表示没有登录，权限不够，如果有，需要判断和redis中的值是否相同，如果相同，表示有权限，直接路由到服务即可<ul>
<li><strong>这里将部分逻辑写在<code>shouldFilter()</code>方法中，限制范围（判断请求的uri是否需要鉴权），<code>run()</code>方法中只需要判断是否具有权限即可</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 	自定义过滤器，用于实现鉴权，前置过滤器</div><div class="line"> *  	继承ZuulFilter</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span>  <span class="comment">//一定要注入到ioc容器中</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="meta">@Resource</span>   </div><div class="line">	<span class="keyword">private</span> UriService uriservice;   <span class="comment">//注入</span></div><div class="line">    </div><div class="line">    <span class="meta">@Resource</span></div><div class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate; <span class="comment">//redis</span></div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 	判断过滤器是否被执行，返回true表示被会被执行（经过run方法）</div><div class="line">	 * 	只需要判断请求的uri是存在数据库中即可</div><div class="line">	 */</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</div><div class="line">		RequestContext context=RequestContext.getCurrentContext();  <span class="comment">//获取上下文</span></div><div class="line">		HttpServletRequest request = context.getRequest();  <span class="comment">//获取request</span></div><div class="line">		String uri=request.getRequestURI();  <span class="comment">//获取请求的uri</span></div><div class="line">		<span class="comment">/**</span></div><div class="line">		 * 	伪代码如下：</div><div class="line">		 *		1、List&lt;URL&gt; uriList=uriservice.getUrlList();  //获取需要权限访问的uri列表</div><div class="line">		 *		2、判断请求的uri是否在uriList中</div><div class="line">		 *			1、如果不存在，return false，表示不用执行过滤的逻辑（run方法）直接路由到指定的服务即可</div><div class="line">		 *			2、如果不存在返回true，表示执行过滤的逻辑（run方法）</div><div class="line">		 */</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 *  	过滤器的具体实现逻辑，经过shouldFilter方法之后，能够执行到这里的表示这个请求的uri需要验证权限</div><div class="line">	 * <span class="doctag">@return</span></div><div class="line">	 * <span class="doctag">@throws</span> ZuulException</div><div class="line">	 */</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</div><div class="line">		RequestContext requestContext = RequestContext.getCurrentContext();  <span class="comment">//获取请求上下文</span></div><div class="line">		HttpServletRequest request = requestContext.getRequest();  <span class="comment">//获取HttpServletRequest</span></div><div class="line">		Cookie[] cookies = request.getCookies();   <span class="comment">//获取cookie</span></div><div class="line">		</div><div class="line">		<span class="comment">/**</span></div><div class="line">		 *  伪代码如下：</div><div class="line">		 *			1、判断cookie中是否存在openId</div><div class="line">		 *				1、如果不存在，返回权限不足的提示信息</div><div class="line">		 *				2、如果存在，需要判断redis中存储的openId的值是否和携带过来的cookie值相同</div><div class="line">		 *					1、如果不相同，返回权限不足的提示信息</div><div class="line">		 *					2、如果相同，表示这个请求具有相应的权限</div><div class="line">		 */</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> FilterConstants.PRE_TYPE;    <span class="comment">//前置过滤器 pre</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">//一般前置过滤器放在org.springframework.cloud.netflix.zuul.filters.pre.PreDecorationFilter这个过滤器之前即可，只需要将其对应的顺序-1</span></div><div class="line">		<span class="keyword">return</span> FilterConstants.PRE_DECORATION_FILTER_ORDER-<span class="number">1</span>; </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</div><div class="line"><span class="keyword">import</span> org.springframework.web.cors.CorsConfiguration;</div><div class="line"><span class="keyword">import</span> org.springframework.web.cors.UrlBasedCorsConfigurationSource;</div><div class="line"><span class="keyword">import</span> org.springframework.web.filter.CorsFilter;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 跨域的配置类</div><div class="line"> */</div><div class="line"><span class="meta">@Configuration</span>   <span class="comment">//配置类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> </span>&#123;</div><div class="line">	<span class="meta">@Bean</span></div><div class="line">	<span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">final</span> UrlBasedCorsConfigurationSource source=<span class="keyword">new</span> UrlBasedCorsConfigurationSource();</div><div class="line">		<span class="keyword">final</span> CorsConfiguration config=<span class="keyword">new</span> CorsConfiguration();</div><div class="line">		config.setAllowCredentials(<span class="keyword">true</span>);   <span class="comment">//支持cookie跨域</span></div><div class="line">		config.setAllowedOrigins(Arrays.asList(<span class="string">"*"</span>));  <span class="comment">//配置允许跨域访问的域名，这里*表示全部</span></div><div class="line">		config.setAllowedHeaders(Arrays.asList(<span class="string">"*"</span>));  <span class="comment">//设置允许的头</span></div><div class="line">		config.setAllowedMethods(Arrays.asList(<span class="string">"*"</span>)); <span class="comment">//设置允许跨域的方法，GET,POST....,这里表示允许全部</span></div><div class="line">		config.setMaxAge(<span class="number">300l</span>);  <span class="comment">//缓存时间，在指定的时间内，对于相同的请求就不需要再次检查了</span></div><div class="line">		source.registerCorsConfiguration(<span class="string">"/**"</span>, config);</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(source);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="超时时间设置"><a href="#超时时间设置" class="headerlink" title="超时时间设置"></a>超时时间设置</h2><ul>
<li>我们在使用zuul访问服务的时候，一旦服务超过很短的时间没有响应，那么zuul就会自动熔断，默认的时间是<strong>2秒</strong>，但是可以通过配置修改，如下：<ul>
<li>由于zuul使用ribbon实现负载均衡，因此这里还需要配置ribbon的超时时间，否则配置将不会生效</li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="attr">zuul:</span></div><div class="line"><span class="attr">    host:</span>  <span class="comment"># 配置zuul的超时时间</span></div><div class="line"><span class="attr">        connect-timeout-millis:</span> <span class="number">60000</span>  <span class="comment"># 默认2秒，  </span></div><div class="line"><span class="attr">        socket-timeout-millis:</span> <span class="number">60000</span></div><div class="line">    </div><div class="line"><span class="attr">ribbon:</span>   <span class="comment"># zuul使用服务发现的时候，要想让上面的配置生效，必须配置ribbon的超时时间</span></div><div class="line"><span class="attr">  ReadTimeout:</span> <span class="number">60000</span>     <span class="comment"># 请求处理时间。</span></div><div class="line"><span class="attr">  ConnectTimeout:</span> <span class="number">60000</span>   <span class="comment"># 请求连接时间。</span></div></pre></td></tr></table></figure>
<h2 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h2><ul>
<li><strong>当请求的服务响应时间超时或者服务不可用的时候zuul会直接响应异常</strong>，我们可以设置熔断，只需要在zuul的服务中配置即可，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cn.tedu.zuul.hystrix;</div><div class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.InputStream;</div><div class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.zuul.filters.route.FallbackProvider;</div><div class="line"><span class="keyword">import</span> org.springframework.http.HttpHeaders;</div><div class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</div><div class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</div><div class="line"><span class="keyword">import</span> org.springframework.http.client.ClientHttpResponse;</div><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 设置zuul的熔断</div><div class="line"> * 实现FallbackProvider接口</div><div class="line"> * 出现熔断的情况如下：</div><div class="line"> * 	1、当请求的服务响应超时</div><div class="line"> * 	2、当请求的服务不能正常提供服务</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span>  <span class="comment">//注入到IOC容器</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderFallback</span> <span class="keyword">implements</span> <span class="title">FallbackProvider</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 这个方法返回的是serviceId，如果返回的单个服务，那么只针对一个服务熔断</div><div class="line">	 * 如果想要针对所有的服务进行配置熔断，只需要返回*即可</div><div class="line">	 */</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getRoute</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"order-provider"</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 发生熔断的响应方法</div><div class="line">	 */</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">fallbackResponse</span><span class="params">(String route, Throwable cause)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ClientHttpResponse() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> HttpStatus <span class="title">getStatusCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">				<span class="keyword">return</span> HttpStatus.OK;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRawStatusCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">				<span class="keyword">return</span> <span class="number">200</span>;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">getStatusText</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">				<span class="keyword">return</span> <span class="string">"OK"</span>;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">			&#125;</div><div class="line">			</div><div class="line">			<span class="comment">//设置响应的内容</span></div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> InputStream <span class="title">getBody</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">new</span> ByteArrayInputStream(<span class="string">"fallback"</span>.getBytes());</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> HttpHeaders <span class="title">getHeaders</span><span class="params">()</span> </span>&#123;</div><div class="line">				HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</div><div class="line">				headers.setContentType(MediaType.APPLICATION_JSON);</div><div class="line">				<span class="keyword">return</span> headers;</div><div class="line">			&#125;</div><div class="line">		&#125;;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="zuul的重试"><a href="#zuul的重试" class="headerlink" title="zuul的重试"></a>zuul的重试</h2><ul>
<li>有时候因为网络或者其它原因，服务可能会暂时的不可用，这个时候我们希望可以再次对服务进行重试，Zuul也帮我们实现了此功能，需要结合Spring Retry 一起来实现</li>
<li>依赖：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 超时重试 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.retry<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-retry<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>在配置文件中配置如下：<ul>
<li><strong>在zuul中开启重试机制</strong></li>
<li><strong>配置ribbon的重试次数</strong></li>
<li><em>默认请求超时时间很短，还可以配置ribbon的超时时间</em></li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="attr">zuul:</span></div><div class="line"><span class="attr">  retryable:</span> <span class="literal">true</span>  <span class="comment"># 开启重试机制</span></div><div class="line"></div><div class="line"><span class="attr">ribbon:</span>    <span class="comment"># zuul内部使用的是ribbon实现负载均衡的，因此配置ribbon的重试次数</span></div><div class="line"><span class="attr">  MaxAutoRetries:</span> <span class="number">2</span>   <span class="comment"># 同一个服务的最大重试次数</span></div><div class="line"><span class="attr">  MaxAutoRetriesNextServer:</span> <span class="number">2</span>   <span class="comment"># 对于切换的下一个实例的重试次数</span></div></pre></td></tr></table></figure>
<h2 id="Zuul的高可用"><a href="#Zuul的高可用" class="headerlink" title="Zuul的高可用"></a>Zuul的高可用</h2><ul>
<li>将多个zuul的微服务注册到Eureka中的（集群）</li>
<li>Nginx和Zuul混搭的方式，可以将Nginx的请求转发到多个zuul中，zuul再路由给指定的微服务</li>
</ul>
<h2 id="完整的配置"><a href="#完整的配置" class="headerlink" title="完整的配置"></a>完整的配置</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="attr">zuul:</span></div><div class="line"><span class="comment">#  TokenFilter:</span></div><div class="line"><span class="comment">#    pre:</span></div><div class="line"><span class="comment">#      disable: true</span></div><div class="line">  <span class="comment"># 忽略真实的服务名称实例访问，是一个Set集合，可以指定多个，取消全部使用 "*"即可</span></div><div class="line"><span class="attr">  sensitive-headers:</span>   <span class="comment"># 设置所有的服务都取消敏感头信息</span></div><div class="line"><span class="attr">  ignored-services:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">order-provider</span></div><div class="line"><span class="comment">#  ignored-patterns:</span></div><div class="line"><span class="comment">#  - /api-order/order/list   # 取消指定的一个</span></div><div class="line"><span class="comment">#  - /api-order/order/**     # 使用通配符去掉order下的全部接口</span></div><div class="line">  <span class="comment">#routes下面指定代理规则，可以同时指定多个</span></div><div class="line"><span class="attr">  routes:</span></div><div class="line">    <span class="comment">#指定第一个规则，这里的名称任意</span></div><div class="line"><span class="attr">    api-order:</span></div><div class="line">      <span class="comment">#指定的实例名称</span></div><div class="line"><span class="attr">      serviceId:</span> <span class="string">order-provider</span></div><div class="line">      <span class="comment">#指定可以访问的路由</span></div><div class="line"><span class="attr">      path:</span> <span class="string">/api-order/**</span></div></pre></td></tr></table></figure>
<h2 id="消费端的使用"><a href="#消费端的使用" class="headerlink" title="消费端的使用"></a>消费端的使用</h2><ul>
<li>前提：<ul>
<li>zuul微服务（zuul-server）注册到eureka注册中心</li>
<li>微服务提供者注册到Eureka注册中心，zuul-server配置的路由是api-order</li>
<li>服务消费者注册到Eureka中</li>
</ul>
</li>
<li>那么如果消费者想用通过zuul-server访问到服务提供者，那么可以直接写<code>http://zuul-server/api-order/order/{id}</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String URI_PRFIX=<span class="string">"http://zuul-server/api-order"</span>;  <span class="comment">//直接使用zuul网管连接订单的服务提供者</span></div><div class="line">	</div><div class="line">	<span class="meta">@Resource</span></div><div class="line">	<span class="keyword">private</span> RestTemplate restTemplate;</div><div class="line">	</div><div class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/order/&#123;id&#125;"</span>)</div><div class="line">	<span class="function"><span class="keyword">public</span> Order <span class="title">getOrder</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span>Integer id) </span>&#123;</div><div class="line">		<span class="keyword">return</span> restTemplate.getForObject(URI_PRFIX+<span class="string">"/order/"</span>+id, Order.class);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><ul>
<li><a href="https://gitee.com/chenjiabing666/zuul-server.git" target="_blank" rel="external">https://gitee.com/chenjiabing666/zuul-server.git</a></li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/FsvZgkvpI0S6rposacGiiQ" target="_blank" rel="external">https://mp.weixin.qq.com/s/FsvZgkvpI0S6rposacGiiQ</a></li>
<li><a href="https://windmt.com/2018/04/23/spring-cloud-11-zuul-filter/" target="_blank" rel="external">https://windmt.com/2018/04/23/spring-cloud-11-zuul-filter/</a></li>
<li><a href="https://cloud.spring.io/spring-cloud-netflix/2.0.x/single/spring-cloud-netflix.html#_router_and_filter_zuul" target="_blank" rel="external">https://cloud.spring.io/spring-cloud-netflix/2.0.x/single/spring-cloud-netflix.html#_router_and_filter_zuul</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Zuul&quot;&gt;&lt;a href=&quot;#Zuul&quot; class=&quot;headerlink&quot; title=&quot;Zuul&quot;&gt;&lt;/a&gt;Zuul&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h
    
    </summary>
    
      <category term="分布式" scheme="http://chenjiabing666.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://chenjiabing666.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Config统一配置中心</title>
    <link href="http://chenjiabing666.github.io/2018/12/25/Config(%E7%BB%9F%E4%B8%80%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83)/"/>
    <id>http://chenjiabing666.github.io/2018/12/25/Config(统一配置中心)/</id>
    <published>2018-12-24T16:24:18.000Z</published>
    <updated>2018-12-25T13:04:28.347Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Config-统一配置中心"><a href="#Config-统一配置中心" class="headerlink" title="Config 统一配置中心"></a>Config 统一配置中心</h1><h2 id="为什么使用？"><a href="#为什么使用？" class="headerlink" title="为什么使用？"></a>为什么使用？</h2><ul>
<li>方便维护：微服务可能成百个，如果一个个配置都是在项目中配置的话，会给运维造成不必要的麻烦</li>
<li>安全：配置统一是由运维来操作，如果涉及到数据库的账户和密码，肯定是不能让开发知道的</li>
</ul>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><ul>
<li>添加依赖:</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- config server的依赖 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">	</div><div class="line">	<span class="comment">&lt;!-- eureka客户端的依赖 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>配置如下：<ul>
<li>这里使用的是git仓库，当然也是可以使用svn</li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="attr">server:</span></div><div class="line"><span class="attr">  port:</span> <span class="number">3344</span></div><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  client:</span></div><div class="line"><span class="attr">    serviceUrl:</span></div><div class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:7001/eureka</span>  <span class="comment"># eureka的暴露地址，直接注册</span></div><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  application:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">config-server</span>   <span class="comment">#应用的名称，在同一个eureka中必须不重复</span></div><div class="line"><span class="attr">  cloud:</span></div><div class="line"><span class="attr">    config:</span></div><div class="line"><span class="attr">      server:</span></div><div class="line"><span class="attr">        git:</span></div><div class="line"><span class="attr">          uri:</span> <span class="attr">https://github.com/chenjiabing666/dept-config.git</span>  <span class="comment"># git仓库的地址，如果是ssh方式的不需要指定用户名和密码，但是需要在github上添加秘钥</span></div><div class="line"><span class="attr">          username:</span> <span class="string">******</span> <span class="comment"># 用户名</span></div><div class="line"><span class="attr">          password:</span> <span class="string">******</span>     <span class="comment"># 密码</span></div><div class="line"><span class="attr">          basedir:</span> <span class="attr">C:/images/config-server</span>   <span class="comment"># 本地的路径，将会自动在这个路径创建一个git仓库</span></div></pre></td></tr></table></figure>
<ul>
<li>在主启动类上添加<code>@EnableConfigServer</code>这个注解，如下:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="meta">@EnableEurekaClient</span>   <span class="comment">//开启eureka</span></div><div class="line"><span class="meta">@EnableConfigServer</span>  <span class="comment">//开启config sever</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerApplication</span> </span>&#123;</div></pre></td></tr></table></figure>
<ul>
<li>此时需要在远程的github仓库创建如下内容：</li>
<li><img src="https://github.com/chenjiabing666/BlogImage/blob/master/config.png?raw=true" alt=""></li>
<li>此时访问如下的路径：<code>http://localhost:3344/orderClient9002-{profile}.yml</code>，就会输出orderClient9002的内容<ul>
<li>如果后缀写的是<code>.json</code>就会以json格式输出，是<code>.properties</code>就会以properties的格式输出</li>
<li>如果输出报错说明配置的内容有错误</li>
</ul>
</li>
</ul>
<h3 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h3><ul>
<li><code>/name-{profile}.yml</code> <ul>
<li>name是github仓库中的文档名称</li>
<li>{profile}是springBoot的profile，可以指定任意的环境</li>
<li>这里默认是master分支的内容</li>
</ul>
</li>
<li><code>/label/name-{profile}.yml</code><ul>
<li>lable是仓库的分支名称</li>
</ul>
</li>
</ul>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><ul>
<li><a href="https://github.com/chenjiabing666/cloud-config-server.git" target="_blank" rel="external">https://github.com/chenjiabing666/cloud-config-server.git</a></li>
</ul>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>启动配置中心的服务端，将其注入到eureka的注册中心</li>
<li>客户端相通过注册中心找到服务端的实例，然后读取到github仓库中对应的配置</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>添加依赖：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 统一配置中心的客户端 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- eureka注册中心的客户端 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>在配置文件中（<code>bootstrap.xml</code>）中配置：<ul>
<li><strong><code>bootstrap.xml</code>是最高级的，其中的配置项不会被application.yml或者application.properties覆盖</strong></li>
<li><strong>其中一定要配置eureka的客户端，否则将不能找到统一配置中心的配置</strong></li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="attr">eureka:</span>   <span class="comment"># 配置eureka客户端，一定要bootstrap文件中配置，因为需要到注册中心获取配置中心的服务端的地址，如果配置在github上面的配置，那么将会找不到配置中心的服务端</span></div><div class="line"><span class="attr">  client:</span></div><div class="line"><span class="attr">    serviceUrl:</span></div><div class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:7001/eureka</span>  <span class="comment"># eureka的暴露地址，直接注册</span></div><div class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span></div><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  application:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">orderClient9002</span>   <span class="comment"># 配置项目的名称，也是github中对应配置文件的名称（去掉后缀）</span></div><div class="line"><span class="attr">  cloud:</span></div><div class="line"><span class="attr">    config:</span></div><div class="line"><span class="attr">      discovery:</span></div><div class="line"><span class="attr">        enabled:</span> <span class="literal">true</span>   <span class="comment"># 开启config的客户端</span></div><div class="line"><span class="attr">        service-id:</span> <span class="string">config-server</span>   <span class="comment"># 指定eureka中的配置中心服务端的实例名称</span></div><div class="line"><span class="attr">      profile:</span> <span class="string">dev</span>   <span class="comment"># 指定配置文件的环境</span></div><div class="line"><span class="attr">      label:</span> <span class="string">master</span>  <span class="comment"># 指定需要访问github上的分支，这里不填默认是master分支</span></div></pre></td></tr></table></figure>
<ul>
<li>在主启动类上不需要对应的注解，只需要添加eureka客户端的注解即可，如下:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="meta">@EnableEurekaClient</span>   <span class="comment">//开启eureka</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderClient9001Application</span> </span>&#123;</div></pre></td></tr></table></figure>
<h3 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3><ul>
<li><a href="https://github.com/chenjiabing666/config-client.git" target="_blank" rel="external">https://github.com/chenjiabing666/config-client.git</a></li>
</ul>
<h2 id="配置中心服务端的高可用"><a href="#配置中心服务端的高可用" class="headerlink" title="配置中心服务端的高可用"></a>配置中心服务端的高可用</h2><ul>
<li><strong>只需要同时开启多个服务端即可，相当于配置了一个集群</strong></li>
</ul>
<h2 id="spring-cloud-bus"><a href="#spring-cloud-bus" class="headerlink" title="spring cloud bus"></a>spring cloud bus</h2><ul>
<li>git仓库的配置改变了，但是统一配置中心并不能及时更新，因此我们需要一种机制能够保证git仓库中的配置改变了就会及时通知配置中心，bus就是这种机制</li>
</ul>
<h3 id="使用（bus-rabbitmq）"><a href="#使用（bus-rabbitmq）" class="headerlink" title="使用（bus + rabbitmq）"></a>使用（bus + rabbitmq）</h3><h4 id="配置中心的服务端"><a href="#配置中心的服务端" class="headerlink" title="配置中心的服务端"></a>配置中心的服务端</h4><ul>
<li>添加依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- spring cloud bus 消息总线的依赖 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>在配置文件中配置<strong>eureka</strong>和<strong>rabbitmq</strong></li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="attr">server:</span></div><div class="line"><span class="attr">  port:</span> <span class="number">3344</span></div><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  client:</span></div><div class="line"><span class="attr">    serviceUrl:</span></div><div class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:7001/eureka</span>  <span class="comment"># eureka的暴露地址，直接注册</span></div><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  application:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">config-server</span>   <span class="comment"># 应用的名称，在同一个eureka中必须不重复</span></div><div class="line"><span class="attr">  rabbitmq:</span>              <span class="comment"># rabbitmq配置的</span></div><div class="line"><span class="attr">    host:</span> <span class="number">39.105</span><span class="number">.123</span><span class="number">.197</span>  <span class="comment"># 主机的地址</span></div><div class="line"><span class="attr">    port:</span> <span class="number">5672</span>            <span class="comment"># 端口</span></div><div class="line"><span class="attr">    username:</span> <span class="string">guest</span>       <span class="comment"># 用户名</span></div><div class="line"><span class="attr">    password:</span> <span class="string">guest</span>      <span class="comment"># 密码</span></div><div class="line"><span class="attr">    virtual-host:</span> <span class="string">/</span>     <span class="comment"># 虚拟主机</span></div><div class="line"></div><div class="line"><span class="attr">  cloud:</span></div><div class="line"><span class="attr">    config:</span></div><div class="line"><span class="attr">      server:</span></div><div class="line"><span class="attr">        git:</span></div><div class="line"><span class="attr">          uri:</span> <span class="attr">https://github.com/chenjiabing666/dept-config.git</span>  <span class="comment"># git仓库的地址，如果是ssh方式的不需要指定用户名和密码，但是需要在github上添加秘钥</span></div><div class="line"><span class="attr">          username:</span> <span class="string">******</span> <span class="comment"># 用户名</span></div><div class="line"><span class="attr">          password:</span> <span class="string">******</span>     <span class="comment"># 密码</span></div><div class="line"><span class="attr">          basedir:</span> <span class="attr">C:/images/config-server</span>   <span class="comment"># 本地的路径，将会自动在这个路径创建一个git仓库</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>开启刷新配置的uri：</strong></li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="attr">management:</span>   <span class="comment"># 开启刷新配置的地址 /bus-refresh</span></div><div class="line"><span class="attr">  endpoints:</span></div><div class="line"><span class="attr">    web:</span></div><div class="line"><span class="attr">      exposure:</span></div><div class="line"><span class="attr">        include:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">bus-refresh</span></div></pre></td></tr></table></figure>
<ul>
<li>主启动类上添加eureka和config的server</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="meta">@EnableEurekaClient</span>   <span class="comment">//开启eureka</span></div><div class="line"><span class="meta">@EnableConfigServer</span>  <span class="comment">//开启config sever</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerApplication</span> </span>&#123;</div></pre></td></tr></table></figure>
<ul>
<li>启动之后将会发现在rabbitmq中新增了一个队列，如下:</li>
</ul>
<p><img src="https://github.com/chenjiabing666/BlogImage/blob/master/bus1.png?raw=true" alt=""></p>
<ul>
<li><strong>在github仓库中新增一个配置文件orderClient9001.yml:</strong></li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="attr">server:</span></div><div class="line"><span class="attr">  port:</span> <span class="number">9001</span></div><div class="line">  </div><div class="line"><span class="attr">person:</span></div><div class="line"><span class="attr">  name:</span> <span class="string">chenjaibing</span></div><div class="line"><span class="attr">  age:</span> <span class="number">20</span></div></pre></td></tr></table></figure>
<h5 id="完整的配置"><a href="#完整的配置" class="headerlink" title="完整的配置"></a>完整的配置</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="attr">server:</span></div><div class="line"><span class="attr">  port:</span> <span class="number">3344</span></div><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  client:</span></div><div class="line"><span class="attr">    serviceUrl:</span></div><div class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:7001/eureka</span>  <span class="comment"># eureka的暴露地址，直接注册</span></div><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  application:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">config-server</span>   <span class="comment"># 应用的名称，在同一个eureka中必须不重复</span></div><div class="line"><span class="attr">  rabbitmq:</span>              <span class="comment"># rabbitmq配置的</span></div><div class="line"><span class="attr">    host:</span> <span class="number">39.105</span><span class="number">.123</span><span class="number">.197</span>  <span class="comment"># 主机的地址</span></div><div class="line"><span class="attr">    port:</span> <span class="number">5672</span>            <span class="comment"># 端口</span></div><div class="line"><span class="attr">    username:</span> <span class="string">guest</span>       <span class="comment"># 用户名</span></div><div class="line"><span class="attr">    password:</span> <span class="string">guest</span>      <span class="comment"># 密码</span></div><div class="line"><span class="attr">    virtual-host:</span> <span class="string">/</span>     <span class="comment"># 虚拟主机</span></div><div class="line"></div><div class="line"><span class="attr">  cloud:</span></div><div class="line"><span class="attr">    config:</span></div><div class="line"><span class="attr">      server:</span></div><div class="line"><span class="attr">        git:</span></div><div class="line"><span class="attr">          uri:</span> <span class="attr">https://github.com/chenjiabing666/dept-config.git</span>  <span class="comment"># git仓库的地址，如果是ssh方式的不需要指定用户名和密码，但是需要在github上添加秘钥</span></div><div class="line"><span class="attr">          username:</span> <span class="string">chenjiabing666</span> <span class="comment"># 用户名</span></div><div class="line"><span class="attr">          password:</span> <span class="string">**********</span>     <span class="comment"># 密码</span></div><div class="line"><span class="attr">          basedir:</span> <span class="attr">C:/images/config-server</span>   <span class="comment"># 本地的路径，将会自动在这个路径创建一个git仓库</span></div><div class="line">          </div><div class="line"><span class="attr">management:</span>   <span class="comment"># 开启刷新配置的地址 /bus-refresh</span></div><div class="line"><span class="attr">  endpoints:</span></div><div class="line"><span class="attr">    web:</span></div><div class="line"><span class="attr">      exposure:</span></div><div class="line"><span class="attr">        include:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">bus-refresh</span></div></pre></td></tr></table></figure>
<h4 id="配置中心的客户端"><a href="#配置中心的客户端" class="headerlink" title="配置中心的客户端"></a>配置中心的客户端</h4><ul>
<li>添加依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- spring cloud bus 消息总线的依赖 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>添加eureka、rabbitmq、config client的配置（<strong>bootstrap.xml</strong>）</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="attr">eureka:</span>   <span class="comment"># 配置eureka客户端，一定要bootstrap文件中配置，因为需要到注册中心获取配置中心的服务端的地址，如果配置在github上面的配置，那么将会找不到配置中心的服务端</span></div><div class="line"><span class="attr">  client:</span></div><div class="line"><span class="attr">    serviceUrl:</span></div><div class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:7001/eureka</span>  <span class="comment"># eureka的暴露地址，直接注册</span></div><div class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span></div><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  application:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">orderClient9001</span>   <span class="comment"># 配置项目的名称，也是github中对应配置文件的名称（去掉后缀）</span></div><div class="line"><span class="attr">  rabbitmq:</span>              <span class="comment"># rabbitmq配置的</span></div><div class="line"><span class="attr">    host:</span> <span class="number">39.105</span><span class="number">.123</span><span class="number">.197</span>  <span class="comment"># 主机的地址</span></div><div class="line"><span class="attr">    port:</span> <span class="number">5672</span>            <span class="comment"># 端口</span></div><div class="line"><span class="attr">    username:</span> <span class="string">guest</span>       <span class="comment"># 用户名</span></div><div class="line"><span class="attr">    password:</span> <span class="string">guest</span>      <span class="comment"># 密码</span></div><div class="line"><span class="attr">    virtual-host:</span> <span class="string">/</span>     <span class="comment"># 虚拟主机</span></div><div class="line"><span class="attr">  cloud:</span></div><div class="line"><span class="attr">    config:</span></div><div class="line"><span class="attr">      discovery:</span></div><div class="line"><span class="attr">        enabled:</span> <span class="literal">true</span>   <span class="comment"># 开启config的客户端</span></div><div class="line"><span class="attr">        service-id:</span> <span class="string">config-server</span>   <span class="comment"># 指定eureka中的配置中心服务端的实例名称</span></div><div class="line"><span class="attr">      profile:</span> <span class="string">dev</span>   <span class="comment"># 指定配置文件的环境</span></div><div class="line"><span class="attr">      label:</span> <span class="string">master</span>  <span class="comment"># 指定需要访问github上的分支，这里不填默认是master分支</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>新增一个Person类，其中的属性来自配置文件，并且通过controller读取其中的值，用作测试</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">"person"</span>)  <span class="comment">//读取配置文件中前缀为person的值，并且赋值给其中的变量</span></div><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="keyword">private</span> String age;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonController</span> </span>&#123;</div><div class="line">	<span class="meta">@Resource</span></div><div class="line">	<span class="keyword">private</span> Person person;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 获取配置文件中的值</div><div class="line">	 * <span class="doctag">@return</span></div><div class="line">	 */</div><div class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/person"</span>)</div><div class="line">	<span class="function"><span class="keyword">public</span> Person <span class="title">getPerson</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> person;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在主启动类上只需要开启eureka客户端即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="meta">@EnableEurekaClient</span>   <span class="comment">//开启eureka</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderClient9001Application</span> </span>&#123;</div></pre></td></tr></table></figure>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><ul>
<li>启动eurkea，config server，config client</li>
<li>访问<code>http://localhost:9001/person</code>，返回一个person的信息</li>
<li>此时我们修改github仓库中的person的配置，再次访问<code>http://localhost:9001/person</code>,但是值并没有改变</li>
<li>我们通过post请求访问<code>http://localhost:3344/actuator/bus-refresh</code>（config server端的接口，自动生成的），再次获取person的信息之后，发现改变了，此时说明我们的配置成功了</li>
</ul>
<h4 id="在github中配置提交代码自动更新"><a href="#在github中配置提交代码自动更新" class="headerlink" title="在github中配置提交代码自动更新"></a>在github中配置提交代码自动更新</h4><ul>
<li>之前我们更新配置之后都是需要手动的post一个请求才会自动更新，现在我们可以在github中配置自动更新。<ul>
<li>在github仓库中的webhooks中配置一个post请求，地址写外网访问到bus-refresh即可。</li>
</ul>
</li>
</ul>
<h4 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h4><ul>
<li><a href="https://github.com/chenjiabing666/cloud-bus" target="_blank" rel="external">https://github.com/chenjiabing666/cloud-bus</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Config-统一配置中心&quot;&gt;&lt;a href=&quot;#Config-统一配置中心&quot; class=&quot;headerlink&quot; title=&quot;Config 统一配置中心&quot;&gt;&lt;/a&gt;Config 统一配置中心&lt;/h1&gt;&lt;h2 id=&quot;为什么使用？&quot;&gt;&lt;a href=&quot;#为什么
    
    </summary>
    
      <category term="分布式" scheme="http://chenjiabing666.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://chenjiabing666.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>spring sleuth 服务追踪</title>
    <link href="http://chenjiabing666.github.io/2018/12/25/spring-sleuth-%E6%9C%8D%E5%8A%A1%E8%BF%BD%E8%B8%AA/"/>
    <id>http://chenjiabing666.github.io/2018/12/25/spring-sleuth-服务追踪/</id>
    <published>2018-12-24T16:23:20.000Z</published>
    <updated>2018-12-24T16:23:47.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring-sleuth-服务追踪"><a href="#spring-sleuth-服务追踪" class="headerlink" title="spring  sleuth- 服务追踪"></a>spring  sleuth- 服务追踪</h1><h2 id="Zipkin"><a href="#Zipkin" class="headerlink" title="Zipkin"></a>Zipkin</h2><ul>
<li>Zipkin 是一个开放源代码分布式的跟踪系统，由Twitter公司开源，它致力于收集服务的定时数据，以解决微服务架构中的延迟问题，包括数据的收集、存储、查找和展现。</li>
<li>每个服务向zipkin报告计时数据，zipkin会根据调用关系通过Zipkin UI生成依赖关系图，显示了多少跟踪请求通过每个服务，该系统让开发者可通过一个 Web 前端轻松的收集和分析数据，例如用户每次请求服务的处理时间等，可方便的监测系统中存在的瓶颈。</li>
<li>Zipkin提供了可插拔数据存储方式：In-Memory、MySql、Cassandra以及Elasticsearch。接下来的测试为方便直接采用In-Memory方式进行存储，生产推荐Elasticsearch。</li>
</ul>
<h3 id="服务端的安装"><a href="#服务端的安装" class="headerlink" title="服务端的安装"></a>服务端的安装</h3><ul>
<li>使用docker安装：<code>docker run --name zipkin -d -p 9411:9411 openzipkin/zipkin</code></li>
<li>访问<code>http://localhost:9411/zipkin/</code>即可看到可视化的界面</li>
</ul>
<h3 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h3><ul>
<li>需要在每一个项目中（包括提供者，消费者，网关等），依赖如下:</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- zipkin的依赖 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- sleuth的依赖 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-sleuth<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>在上面所有的项目中添加如下的配置：<ul>
<li><strong>在开发环境中可以指定抽样的比例为1，在生产环境中可以使用默认的即可</strong></li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  zipkin:</span></div><div class="line"><span class="attr">    base-url:</span> <span class="attr">http://192.168.174.128:9411</span>   <span class="comment"># 指定zipkin的服务端的地址</span></div><div class="line"><span class="attr">  sleuth:</span></div><div class="line"><span class="attr">    web:</span></div><div class="line"><span class="attr">      client:</span></div><div class="line"><span class="attr">        enabled:</span> <span class="literal">true</span></div><div class="line"><span class="attr">    sampler:</span></div><div class="line"><span class="attr">      probability:</span> <span class="number">1.0</span> <span class="comment"># 将采样比例设置为 1.0，也就是全部都需要。默认是 0.1</span></div></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="http://www.ityouknow.com/springcloud/2018/02/02/spring-cloud-sleuth-zipkin.html" target="_blank" rel="external">http://www.ityouknow.com/springcloud/2018/02/02/spring-cloud-sleuth-zipkin.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;spring-sleuth-服务追踪&quot;&gt;&lt;a href=&quot;#spring-sleuth-服务追踪&quot; class=&quot;headerlink&quot; title=&quot;spring  sleuth- 服务追踪&quot;&gt;&lt;/a&gt;spring  sleuth- 服务追踪&lt;/h1&gt;&lt;h2 i
    
    </summary>
    
      <category term="分布式" scheme="http://chenjiabing666.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://chenjiabing666.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Hystrix断路器、熔断器</title>
    <link href="http://chenjiabing666.github.io/2018/12/25/Hystrix%E6%96%AD%E8%B7%AF%E5%99%A8%E3%80%81%E7%86%94%E6%96%AD%E5%99%A8/"/>
    <id>http://chenjiabing666.github.io/2018/12/25/Hystrix断路器、熔断器/</id>
    <published>2018-12-24T16:21:38.000Z</published>
    <updated>2018-12-24T16:22:01.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hystrix-断路器、熔断器"><a href="#Hystrix-断路器、熔断器" class="headerlink" title="Hystrix 断路器、熔断器"></a>Hystrix 断路器、熔断器</h1><h2 id="服务雪崩"><a href="#服务雪崩" class="headerlink" title="服务雪崩"></a>服务雪崩</h2><ul>
<li><p>在微服务架构中通常会有多个服务层调用，基础服务的故障可能会导致级联故障，进而造成整个系统不可用的情况，这种现象被称为服务雪崩效应。服务雪崩效应是一种因“服务提供者”的不可用导致“服务消费者”的不可用,并将不可用逐渐放大的过程。</p>
<p>如果下图所示：A作为服务提供者，B为A的服务消费者，C和D是B的服务消费者。A不可用引起了B的不可用，并将不可用像滚雪球一样放大到C和D时，雪崩效应就形成了。</p>
</li>
</ul>
<p><img src="http://www.itmind.net/assets/images/2017/springcloud/hystrix-1.png" alt=""></p>
<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><ul>
<li>Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，Hystrix能够保证在一个依赖出现问题的情况下，不会导致整个服务失败，避免级联故障，以提高分布式系统的弹性。</li>
<li>断路器本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期，可处理的备选响应（FallBack），而不是长时间等待或者抛出调用方法无法处理的异常，这样就保证了调用方线程不会被长时间，不必要的占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩</li>
</ul>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul>
<li>简单的说就是当程序出现异常的时候返回一个错误的状态告知其他的服务，而不是任由异常发展下去导致整个系统的瘫痪</li>
</ul>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul>
<li>服务提供者</li>
</ul>
<h2 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>什么是服务降级？当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作。</li>
<li>如果还是不理解，那么可以举个例子：假如目前有很多人想要给我付钱，但我的服务器除了正在运行支付的服务之外，还有一些其它的服务在运行，比如搜索、定时任务和详情等等。然而这些不重要的服务就占用了JVM的不少内存与CPU资源，为了能把钱都收下来（钱才是目标），我设计了一个动态开关，把这些不重要的服务直接在最外层拒掉，这样处理后的后端处理收钱的服务就有更多的资源来收钱了（收钱速度更快了），这就是一个简单的服务降级的使用场景。</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>服务降级主要用于什么场景呢？当整个微服务架构整体的负载超出了预设的上限阈值或即将到来的流量预计将会超过预设的阈值时，为了保证重要或基本的服务能正常运行，我们可以将一些 不重要或 不紧急 的服务或任务进行服务的 延迟使用 或 暂停使用。 </li>
</ul>
<h3 id="使用效果"><a href="#使用效果" class="headerlink" title="使用效果"></a>使用效果</h3><ul>
<li><strong>在客户端结合Feign配置熔断处理，当没有服务提供者或者服务出现异常的时候就会调用熔断Hystrix定制的接口，返回特定的错误信息</strong></li>
</ul>
<h3 id="使用Feign达到服务降级"><a href="#使用Feign达到服务降级" class="headerlink" title="使用Feign达到服务降级"></a>使用Feign达到服务降级</h3><ul>
<li><strong>服务降级是在客户端配置，与服务提供者无关</strong></li>
<li>添加依赖如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- feign的依赖 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- Hystrix的依赖 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- eureka的客户端依赖 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line">      <span class="comment">&lt;!-- ribbon的依赖 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>使用<code>@FeignClient</code>在<strong>公共模块上</strong>创建一个接口实现负载均衡，如下：<ul>
<li><code>@FeignClient(name=&quot;DEPT-PROVIDER&quot;,fallbackFactory=DeptFallBack.class)</code><ul>
<li><code>name</code>：指定服务提供者的实例名称</li>
<li><code>fallbackFactory</code>：熔断处理的接口，在下面会定义</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</div><div class="line"><span class="keyword">import</span> cn.tedu.provider.domain.Dept;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Hystrix和Feign结合实现服务的降级</div><div class="line"> * <span class="doctag">@FeignClient</span> 标注这个接口使用Feign实现负载均衡</div><div class="line"> * 	1、name指定了微服务提供者的实例名称</div><div class="line"> * 	2、fallbackFactory指定了熔断的接口，一旦出现异常就会调用这个接口的方法返回指定的熔断信息</div><div class="line"> */</div><div class="line"><span class="meta">@FeignClient</span>(name=<span class="string">"DEPT-PROVIDER"</span>,fallbackFactory=DeptFallBack.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DeptFeign</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 获取部门，使用Get方式请求</div><div class="line">	 * <span class="doctag">@param</span> id</div><div class="line">	 * <span class="doctag">@return</span></div><div class="line">	 */</div><div class="line">	<span class="meta">@RequestMapping</span>(value=<span class="string">"/dept/&#123;id&#125;"</span>,method=RequestMethod.GET)</div><div class="line">	<span class="function">Dept <span class="title">get</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span>Integer id)</span>;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 添加部门，使用POST请求的方式</div><div class="line">	 * <span class="doctag">@param</span> dept</div><div class="line">	 * <span class="doctag">@return</span></div><div class="line">	 */</div><div class="line">	<span class="meta">@RequestMapping</span>(value=<span class="string">"/dept"</span>,method=RequestMethod.POST)</div><div class="line">	<span class="function">Dept <span class="title">addDept</span><span class="params">(Dept dept)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在<strong>公共模块</strong>创建熔断处理的接口，如下：<ul>
<li><strong>这个类需要使用<code>FallbackFactory</code>，其中的泛型是Feign定义的接口</strong></li>
<li><strong>一定要使用<code>@Component</code>这个注解将其注入到IOC容器中</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</div><div class="line"><span class="keyword">import</span> cn.tedu.provider.domain.Dept;</div><div class="line"><span class="keyword">import</span> feign.hystrix.FallbackFactory;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  针对DeptFiegn接口的服务熔断的公共类，在其中可以对各个接口进行服务熔断响应进行定制</div><div class="line"> *  1、这个接口必须实现`feign.hystrix.FallbackFactory`</div><div class="line"> *  2、这个FallbackFactory中的泛型必须是`<span class="doctag">@FeignClient</span>`标注的接口（实现负载均衡）</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span>   <span class="comment">//一定要将其注入到容器中</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptFallBack</span> <span class="keyword">implements</span> <span class="title">FallbackFactory</span>&lt;<span class="title">DeptFeign</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 实现其中的方法</div><div class="line">	 */</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> DeptFeign <span class="title">create</span><span class="params">(Throwable cause)</span> </span>&#123;</div><div class="line">		<span class="comment">//直接return这个接口的对象，并且实现其中的所有接口方法，下面的每一个接口返回的信息就将是服务熔断返回的消息</span></div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> DeptFeign() &#123;</div><div class="line">			</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> Dept <span class="title">get</span><span class="params">(Integer id)</span> </span>&#123;   <span class="comment">//根据Id获取异常之后就会返回其中的信息</span></div><div class="line">				Dept dept=<span class="keyword">new</span> Dept();</div><div class="line">				dept.setDeptId(-<span class="number">1</span>);</div><div class="line">				dept.setDeptName(<span class="string">"服务熔断......"</span>);</div><div class="line">				<span class="keyword">return</span> dept;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> Dept <span class="title">addDept</span><span class="params">(Dept dept)</span> </span>&#123;  <span class="comment">//添加异常返回这个信息</span></div><div class="line">				dept.setDeptId(-<span class="number">1</span>);</div><div class="line">				dept.setDeptName(<span class="string">"服务熔断......"</span>);</div><div class="line">				<span class="keyword">return</span> dept;</div><div class="line">			&#125;&#125;;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在消费者端controller中调用Feign的接口即可，如果程序抛出异常或者没有服务提供者，那么将会调用定义好的熔断方法，返回对应的信息，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptController</span> </span>&#123;</div><div class="line">	<span class="meta">@Resource</span></div><div class="line">	<span class="keyword">private</span> DeptFeign deptFeign;  <span class="comment">//直接注入Feign接口，不过需要在主启动类上扫描该类所在的包或者父包</span></div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 根据部门Id获取部门</div><div class="line">	 * <span class="doctag">@param</span> id</div><div class="line">	 * <span class="doctag">@return</span></div><div class="line">	 */</div><div class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/dept/&#123;id&#125;"</span>)</div><div class="line">	<span class="function"><span class="keyword">public</span> Dept <span class="title">getDept</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id) </span>&#123;</div><div class="line">		<span class="keyword">return</span> deptFeign.get(id);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 添加部门，json方式提交</div><div class="line">	 * <span class="doctag">@param</span> dept</div><div class="line">	 * <span class="doctag">@return</span></div><div class="line">	 */</div><div class="line">	<span class="meta">@PostMapping</span>(<span class="string">"/dept"</span>)</div><div class="line">	<span class="function"><span class="keyword">public</span> Dept <span class="title">addDept</span><span class="params">(@RequestBody Dept dept)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> deptFeign.addDept(dept);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在消费者端开启feign对Hystrix的支持，如下：</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">feign:</span></div><div class="line"><span class="attr">  hystrix:</span></div><div class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></div></pre></td></tr></table></figure>
<ul>
<li>在消费者的启动类上添加注解，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="meta">@EnableEurekaClient</span>   <span class="comment">//开启eureka</span></div><div class="line"><span class="meta">@EnableCircuitBreaker</span>  <span class="comment">//开启熔断器</span></div><div class="line"><span class="meta">@EnableFeignClients</span>(basePackages= &#123;<span class="string">"cn.tedu.api.*"</span>&#125;)  <span class="comment">//由于是分模块开发，feignclient是定义在公共模块的，因此必须指定basePackages扫描@FeignClient所在的包</span></div><div class="line"><span class="meta">@ComponentScan</span>(basePackages= &#123;<span class="string">"cn.tedu.api.*"</span>,<span class="string">"cn.tedu.client.*"</span>&#125;) <span class="comment">//由于分模块开发，因此必须扫描Hystrix定义的fallbackFactory所在的包，同时也要扫描本模块所在的包，当然可以直接扫描cn.tedu.*这个包</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderClient9002Application</span> </span>&#123;</div></pre></td></tr></table></figure>
<ul>
<li>源码<ul>
<li><a href="https://gitee.com/chenjiabing666/order-api.git" target="_blank" rel="external">order-api</a></li>
<li><a href="https://gitee.com/chenjiabing666/order-client9002.git" target="_blank" rel="external">order-client</a></li>
</ul>
</li>
</ul>
<h3 id="使用RestTemplate服务降级"><a href="#使用RestTemplate服务降级" class="headerlink" title="使用RestTemplate服务降级"></a>使用RestTemplate服务降级</h3><ul>
<li>添加依赖，如下:</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- Hystrix的依赖 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>启动类上开启熔断</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="meta">@EnableEurekaClient</span>   <span class="comment">//开启eureka</span></div><div class="line"><span class="meta">@EnableCircuitBreaker</span>  <span class="comment">//开启服务熔断</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderClient9001Application</span> </span>&#123;</div></pre></td></tr></table></figure>
<h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><ul>
<li>第一种的实现方式就是每一个方法都对应一个熔断的方法（复杂，很难拓展和管理）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String URI_PRFIX=<span class="string">"http://zuul-server/api-order"</span>;  <span class="comment">//直接使用zuul网管连接订单的服务提供者</span></div><div class="line">	</div><div class="line">	<span class="meta">@Resource</span></div><div class="line">	<span class="keyword">private</span> RestTemplate restTemplate;</div><div class="line">	</div><div class="line">    <span class="comment">//使用@HystrixCommand这个注解，其中指定熔断后调用的方法</span></div><div class="line">	<span class="meta">@HystrixCommand</span>(fallbackMethod=<span class="string">"getOrderFallback"</span>)   </div><div class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/order/&#123;id&#125;"</span>)</div><div class="line">	<span class="function"><span class="keyword">public</span> Order <span class="title">getOrder</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span>Integer id) </span>&#123;</div><div class="line">		System.out.println(<span class="number">1</span>/<span class="number">0</span>);   <span class="comment">//特意出异常</span></div><div class="line">		<span class="keyword">return</span> restTemplate.getForObject(URI_PRFIX+<span class="string">"/order/"</span>+id, Order.class);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 	服务的熔断方法，只有当没有服务提供者提供服务或者程序出现异常的时候才会执行这个方法</div><div class="line">	 * 	注意：</div><div class="line">	 * 		1、返回的类型一定要相同或者是其子类</div><div class="line">	 * 		2、入参的参数和类型一定要相同</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> Order <span class="title">getOrderFallback</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span>Integer id) </span>&#123;</div><div class="line">		Order order=<span class="keyword">new</span> Order();</div><div class="line">		order.setOrderId(-<span class="number">1</span>);</div><div class="line">		order.setOrderNum(<span class="string">"太拥挤了，请稍后再试......"</span>);</div><div class="line">		<span class="keyword">return</span> order;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="默认的熔断"><a href="#默认的熔断" class="headerlink" title="默认的熔断"></a>默认的熔断</h3><ul>
<li>上面是针对一对一的熔断，每个接口都要写一个熔断方法，但是我们也可以针对一个类写一个默认的熔断方法即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 使用<span class="doctag">@DefaultProperties</span>指定默认的熔断方法</div><div class="line"> * 	1、需要熔断机制的接口上只需要添加<span class="doctag">@HystrixCommand</span>注解即可</div><div class="line"> * <span class="doctag">@author</span> Administrator</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@DefaultProperties</span>(defaultFallback=<span class="string">"defaultFallBack"</span>)   </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String URI_PRFIX=<span class="string">"http://zuul-server/api-order"</span>;  <span class="comment">//直接使用zuul网管连接订单的服务提供者</span></div><div class="line">	</div><div class="line">	<span class="meta">@Resource</span></div><div class="line">	<span class="keyword">private</span> RestTemplate restTemplate;</div><div class="line">	</div><div class="line">	<span class="meta">@HystrixCommand</span>   <span class="comment">//使用这个注解，其中指定熔断后调用的方法</span></div><div class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/order/&#123;id&#125;"</span>)</div><div class="line">	<span class="function"><span class="keyword">public</span> Order <span class="title">getOrder</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span>Integer id) </span>&#123;</div><div class="line">		System.out.println(<span class="number">1</span>/<span class="number">0</span>);</div><div class="line">		<span class="keyword">return</span> restTemplate.getForObject(URI_PRFIX+<span class="string">"/order/"</span>+id, Order.class);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 *  	默认的熔断方法</div><div class="line">	 *  	1、参数必须为空</div><div class="line">	 *  	2、返回的类型有特殊要求	</div><div class="line">	 *  		1、必须和出现熔断的方法的返回类型相同或者是其子类</div><div class="line">	 * <span class="doctag">@return</span></div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> Order <span class="title">defaultFallBack</span><span class="params">()</span> </span>&#123;</div><div class="line">		Order order=<span class="keyword">new</span> Order();</div><div class="line">		order.setOrderId(-<span class="number">1</span>);</div><div class="line">		order.setOrderNum(<span class="string">"太拥挤了，请稍后再试......"</span>);</div><div class="line">		<span class="keyword">return</span> order;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h2><h3 id="ribbon-Hystrix"><a href="#ribbon-Hystrix" class="headerlink" title="ribbon+ Hystrix"></a>ribbon+ Hystrix</h3><ul>
<li>熔断超时时间默认是<strong>1秒</strong>，即是当请求的服务在一秒之内没有执行完成，那么将会直接熔断，调用熔断方法，返回熔断信息，如下：<ul>
<li>请求这个接口将会直接熔断，因为这里等待的时间超过了设置的时间</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@HystrixCommand</span>  <span class="comment">//使用这个注解，其中指定熔断后调用的方法</span></div><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"/order/&#123;id&#125;"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> Order <span class="title">getOrder</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span>Integer id) </span>&#123;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		Thread.sleep(<span class="number">2000</span>);</div><div class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">		e.printStackTrace();</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> restTemplate.getForObject(URI_PRFIX+<span class="string">"/order/"</span>+id, Order.class);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="直接在-HystrixCommand注解中配置"><a href="#直接在-HystrixCommand注解中配置" class="headerlink" title="直接在@HystrixCommand注解中配置"></a>直接在@HystrixCommand注解中配置</h4><ul>
<li>我们可以通过配置改变这个默认的时间，如下：<ul>
<li>直接在<code>@HystrixCommand</code>的注解中配置</li>
<li>一些常用的常量配置都可以在<code>com.netflix.hystrix.HystrixCommandProperties</code>这个类中找到</li>
<li><strong>单位毫秒</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@HystrixCommand</span>(commandProperties=&#123;</div><div class="line">		<span class="meta">@HystrixProperty</span>(name=<span class="string">"execution.isolation.thread.timeoutInMilliseconds"</span>,value=<span class="string">"3000"</span>)</div><div class="line">	&#125;)   <span class="comment">//使用这个注解，其中指定熔断后调用的方法</span></div><div class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/order/&#123;id&#125;"</span>)</div><div class="line">	<span class="function"><span class="keyword">public</span> Order <span class="title">getOrder</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span>Integer id) </span>&#123;</div><div class="line"><span class="comment">//		System.out.println(1/0);</span></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			Thread.sleep(<span class="number">2000</span>);</div><div class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">			<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> restTemplate.getForObject(URI_PRFIX+<span class="string">"/order/"</span>+id, Order.class);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h4 id="配置文件中配置"><a href="#配置文件中配置" class="headerlink" title="配置文件中配置"></a>配置文件中配置</h4><ul>
<li>直接在配置文件中配置，但是在需要熔断的方法上面一定要加上<code>@HystrixCommand</code>这个注解</li>
<li>针对所有的方法设置超时时间，如下：</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="attr">hystrix:</span></div><div class="line"><span class="attr">  command:</span></div><div class="line"><span class="attr">    default:</span></div><div class="line"><span class="attr">      execution:</span></div><div class="line"><span class="attr">        isolation:</span></div><div class="line"><span class="attr">          thread:</span></div><div class="line"><span class="attr">            timeoutInMilliseconds:</span> <span class="number">3000</span></div></pre></td></tr></table></figure>
<ul>
<li>针对指定的方法设置超时时间，如下：<ul>
<li><strong>也可以对指定的方法指定<code>commandKey</code>,只需要在@HystrixCommand这个注解中指定这个属性即可，默认是方法的名称</strong></li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="attr">hystrix:</span></div><div class="line"><span class="attr">  command:</span></div><div class="line"><span class="attr">    getOrder:</span>  <span class="comment"># 方法名称</span></div><div class="line"><span class="attr">      execution:</span></div><div class="line"><span class="attr">        isolation:</span></div><div class="line"><span class="attr">          thread:</span></div><div class="line"><span class="attr">            timeoutInMilliseconds:</span> <span class="number">3000</span></div></pre></td></tr></table></figure>
<h3 id="Feign-Hystrix"><a href="#Feign-Hystrix" class="headerlink" title="Feign+Hystrix"></a>Feign+Hystrix</h3><ul>
<li>在使用Feign+Hystrix实现服务熔断的时候，虽然我们在配置文件中改变了hystrix的默认的熔断超时时间，但是并不作用，如下:</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="attr">hystrix:</span></div><div class="line"><span class="attr">  command:</span></div><div class="line"><span class="attr">    default:</span>  <span class="comment"># 方法名称</span></div><div class="line"><span class="attr">      execution:</span></div><div class="line"><span class="attr">        isolation:</span></div><div class="line"><span class="attr">          thread:</span></div><div class="line"><span class="attr">            timeoutInMilliseconds:</span> <span class="number">7000</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>上面的配置并不起作用，因为<code>Feign</code>也是使用<code>ribbon</code>的，ribbon也是有超时时间的，默认也是一秒，因此我们要想上面的配置生效，必须指定ribbon的超时时间，并且Hystrix的超时时间应该比ribbon的时间长，因为ribbon还有重试机制，只有当重试也失效之后才应该熔断，完整的配置如下</strong>:</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="attr">ribbon:</span>   <span class="comment"># 设置ribbon的超时时间，这里使用Feign会和Hystrix的超时间相互干扰</span></div><div class="line"><span class="attr">  ReadTimeout:</span> <span class="number">5000</span></div><div class="line"><span class="attr">  ConnectTimeout:</span> <span class="number">3000</span></div><div class="line"><span class="attr">  OkToRetryOnAllOperations:</span> <span class="literal">true</span>  <span class="comment">#对所有操作都进行重试。</span></div><div class="line"><span class="attr">  MaxAutoRetriesNextServer:</span> <span class="number">2</span>     <span class="comment"># 切换实例的重试次数。 </span></div><div class="line"><span class="attr">  MaxAutoRetries:</span> <span class="number">1</span>               <span class="comment"># 对当前实例的重试次数。</span></div><div class="line"></div><div class="line"><span class="attr">hystrix:</span></div><div class="line"><span class="attr">  command:</span></div><div class="line"><span class="attr">    default:</span>  </div><div class="line"><span class="attr">      execution:</span></div><div class="line"><span class="attr">        isolation:</span></div><div class="line"><span class="attr">          thread:</span></div><div class="line"><span class="attr">            timeoutInMilliseconds:</span> <span class="number">7000</span></div></pre></td></tr></table></figure>
<ul>
<li><a href="https://blog.csdn.net/east123321/article/details/82385816" target="_blank" rel="external">https://blog.csdn.net/east123321/article/details/82385816</a></li>
</ul>
<h2 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h2><h3 id="熔断器的状态机"><a href="#熔断器的状态机" class="headerlink" title="熔断器的状态机"></a>熔断器的状态机</h3><ul>
<li><img src="https://images2015.cnblogs.com/blog/978381/201705/978381-20170516093016728-916759277.png" alt=""></li>
</ul>
<ul>
<li><code>Closed</code>：熔断器关闭状态，调用失败次数积累，到了阈值（或一定比例）则启动熔断机制；</li>
<li><code>Open</code>：熔断器打开状态，此时对下游的调用都内部直接返回错误，不走网络，但设计了一个时钟选项，默认的时钟达到了一定时间（这个时间一般设置成平均故障处理时间，也就是MTTR），到了这个时间，进入半熔断状态；</li>
<li><code>Half-Open</code>：半熔断状态，允许定量的服务请求，如果调用都成功（或一定比例）则认为恢复了，关闭熔断器，否则认为还没好，又回到熔断器打开状态； </li>
</ul>
<h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>circuitBreaker.enabled</td>
<td>是否开启熔断器</td>
<td>默认true</td>
</tr>
<tr>
<td>circuitBreaker.sleepWindowInMilliseconds</td>
<td>熔断多少秒后去尝试请求</td>
<td>当熔断器处于open的时候，并且达到了这个阈值，熔断器处于half-open状态，当再次有请求过来的时候就会尝试再次请求服务，而不是直接熔断服务，当此时访问服务正常的话，那么熔断器就会关闭。默认值5000毫秒</td>
</tr>
<tr>
<td>circuitBreaker.requestVolumeThreshold</td>
<td>在使用统计信息做出打开/关闭决策之前，必须在统计窗口中进行的请求数量</td>
<td>默认20</td>
</tr>
<tr>
<td>circuitBreaker.errorThresholdPercentage</td>
<td>失败率达到多少百分比后熔断</td>
<td>默认值50，即是请求失败率达到50%熔断器处于open状态</td>
</tr>
<tr>
<td>commandKey</td>
<td></td>
<td>默认值：当前执行方法名</td>
</tr>
</tbody>
</table>
<h3 id="直接在-HystrixCommand注解中配置熔断"><a href="#直接在-HystrixCommand注解中配置熔断" class="headerlink" title="直接在@HystrixCommand注解中配置熔断"></a>直接在@HystrixCommand注解中配置熔断</h3><ul>
<li>添加依赖</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;!-- Hystrix的依赖 --&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">	&lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<ul>
<li>直接在消费者端使用即可，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 使用<span class="doctag">@DefaultProperties</span>指定默认的熔断方法</div><div class="line"> * 	1、需要熔断机制的接口上只需要添加<span class="doctag">@HystrixCommand</span>注解即可</div><div class="line"> * <span class="doctag">@author</span> Administrator</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@DefaultProperties</span>(defaultFallback=<span class="string">"defaultFallBack"</span>)   </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String URI_PRFIX=<span class="string">"http://zuul-server/api-order"</span>;  <span class="comment">//直接使用zuul网管连接订单的服务提供者</span></div><div class="line">	</div><div class="line">	<span class="meta">@Resource</span></div><div class="line">	<span class="keyword">private</span> RestTemplate restTemplate;</div><div class="line">	</div><div class="line">	<span class="meta">@HystrixCommand</span>(commandProperties=&#123;</div><div class="line">			<span class="meta">@HystrixProperty</span>(name=<span class="string">"execution.isolation.thread.timeoutInMilliseconds"</span>,value=<span class="string">"3000"</span>),  <span class="comment">//设置超时时间</span></div><div class="line">			<span class="meta">@HystrixProperty</span>(name=<span class="string">"circuitBreaker.enabled"</span>,value=<span class="string">"true"</span>),  <span class="comment">// 开启熔断</span></div><div class="line">			<span class="meta">@HystrixProperty</span>(name=<span class="string">"circuitBreaker.requestVolumeThreshold"</span>,value=<span class="string">"10"</span>),  <span class="comment">//最小请求数</span></div><div class="line">			<span class="meta">@HystrixProperty</span>(name=<span class="string">"circuitBreaker.sleepWindowInMilliseconds"</span>,value=<span class="string">"10000"</span>),  <span class="comment">//请求重试时间，单位毫秒</span></div><div class="line">			<span class="meta">@HystrixProperty</span>(name=<span class="string">"circuitBreaker.errorThresholdPercentage"</span>,value=<span class="string">"60"</span>),   <span class="comment">//失败率</span></div><div class="line">	&#125;)   <span class="comment">//使用这个注解，其中指定熔断后调用的方法</span></div><div class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/order/&#123;id&#125;"</span>)</div><div class="line">	<span class="function"><span class="keyword">public</span> Order <span class="title">getOrder</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span>Integer id) </span>&#123;</div><div class="line">		<span class="keyword">if</span> (id==<span class="number">1</span>) &#123;   <span class="comment">//模拟异常</span></div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> restTemplate.getForObject(URI_PRFIX+<span class="string">"/order/"</span>+id, Order.class);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 *  	默认的熔断方法</div><div class="line">	 *  	1、参数必须为空</div><div class="line">	 *  	2、返回的类型有特殊要求	</div><div class="line">	 *  		1、必须和出现熔断的方法的返回类型相同或者是其子类</div><div class="line">	 * <span class="doctag">@return</span></div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> Order <span class="title">defaultFallBack</span><span class="params">()</span> </span>&#123;</div><div class="line">		Order order=<span class="keyword">new</span> Order();</div><div class="line">		order.setOrderId(-<span class="number">1</span>);</div><div class="line">		order.setOrderNum(<span class="string">"太拥挤了，请稍后再试......"</span>);</div><div class="line">		<span class="keyword">return</span> order;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>上面的配置完成之后，先请求传入id=1，达到失败率50%，那么熔断器就会开启，此时再传入id=1，那么本应该正常访问的，但是此时会被熔断，经过10000毫秒之后，再次访问传入id=2，请求成功之后，表示熔断机制关闭了</strong></li>
</ul>
<h3 id="使用配置文件实现"><a href="#使用配置文件实现" class="headerlink" title="使用配置文件实现"></a>使用配置文件实现</h3><ul>
<li>在需要熔断的方法上面添加<code>@HystrixCommand</code>这个注解</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="attr">hystrix:</span></div><div class="line"><span class="attr">  command:</span></div><div class="line"><span class="attr">    default:</span>  <span class="comment"># 这里使用default，但是如果针对单个方法，可以使用方法名称</span></div><div class="line"><span class="attr">      execution:</span></div><div class="line"><span class="attr">        isolation:</span></div><div class="line"><span class="attr">          thread:</span></div><div class="line"><span class="attr">            timeoutInMilliseconds:</span> <span class="number">3000</span></div><div class="line"><span class="attr">      circuitBreaker:</span></div><div class="line"><span class="attr">        enabled:</span> <span class="literal">true</span></div><div class="line"><span class="attr">        requestVolumeThreshold:</span> <span class="number">10</span></div><div class="line"><span class="attr">        sleepWindowInMilliseconds:</span> <span class="number">10000</span></div><div class="line"><span class="attr">        errorThresholdPercentage:</span> <span class="number">60</span></div></pre></td></tr></table></figure>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><ul>
<li><a href="https://gitee.com/chenjiabing666/order-client.git" target="_blank" rel="external">https://gitee.com/chenjiabing666/order-client.git</a></li>
</ul>
<h2 id="Hystrix-Dashboard-图形化监控"><a href="#Hystrix-Dashboard-图形化监控" class="headerlink" title="Hystrix Dashboard  图形化监控"></a>Hystrix Dashboard  图形化监控</h2><ul>
<li>主要是用来监控服务提供者的情况（服务提供者必须实现了Hystrix的熔断机制才能被监控）</li>
</ul>
<h3 id="Hystrix-dashboard-服务端配置"><a href="#Hystrix-dashboard-服务端配置" class="headerlink" title="Hystrix-dashboard 服务端配置"></a>Hystrix-dashboard 服务端配置</h3><ul>
<li>添加依赖：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line">         <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">         <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>添加eureka客户端的依赖，并且将其注册到eureka中</li>
<li>在主启动类上添加对应的注解<code>@EnableHystrixDashboard</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="meta">@EnableHystrixDashboard</span>   <span class="comment">//开启Hystrix-dashboard</span></div><div class="line"><span class="meta">@EnableEurekaClient</span>     <span class="comment">//eureka的客户端</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixDashboardApplication</span> </span>&#123;</div></pre></td></tr></table></figure>
<ul>
<li>配置如下：</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attr">server:</span></div><div class="line"><span class="attr">  port:</span> <span class="number">3366</span></div><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  client:</span></div><div class="line"><span class="attr">    serviceUrl:</span></div><div class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:7001/eureka</span>  <span class="comment"># eureka的暴露地址，直接注册</span></div><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  application:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">hystrix-dashborad</span>   <span class="comment">#应用的名称，在同一个eureka中必须不重复</span></div></pre></td></tr></table></figure>
<ul>
<li>启动服务访问地址：<code>http://localhost:3366/hystrix</code>，将会出现如下界面:</li>
<li><img src="https://github.com/chenjiabing666/BlogImage/blob/master/hystrix1.png?raw=true" alt=""></li>
</ul>
<ul>
<li>源码：<a href="https://gitee.com/chenjiabing666/hystrix-dashboard.git" target="_blank" rel="external">https://gitee.com/chenjiabing666/hystrix-dashboard.git</a></li>
</ul>
<h3 id="被监控服务的创建"><a href="#被监控服务的创建" class="headerlink" title="被监控服务的创建"></a>被监控服务的创建</h3><ul>
<li>添加依赖：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- Hystrix的依赖 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>配置如下：<ul>
<li><strong>必须配置<code>endpoints</code>，否则将会连接补上</strong></li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="attr">hystrix:</span></div><div class="line"><span class="attr">  command:</span></div><div class="line"><span class="attr">    default:</span>  <span class="comment"># 这里使用default，但是如果针对单个方法，可以使用方法名称</span></div><div class="line"><span class="attr">      execution:</span></div><div class="line"><span class="attr">        isolation:</span></div><div class="line"><span class="attr">          thread:</span></div><div class="line"><span class="attr">            timeoutInMilliseconds:</span> <span class="number">3000</span></div><div class="line"><span class="attr">      circuitBreaker:</span></div><div class="line"><span class="attr">        enabled:</span> <span class="literal">true</span></div><div class="line"><span class="attr">        requestVolumeThreshold:</span> <span class="number">10</span></div><div class="line"><span class="attr">        sleepWindowInMilliseconds:</span> <span class="number">10000</span></div><div class="line"><span class="attr">        errorThresholdPercentage:</span> <span class="number">60</span></div><div class="line">        </div><div class="line"><span class="attr">ribbon:</span>   <span class="comment"># 设置ribbon的超时时间，这里使用Feign会和Hystrix的超时间相互干扰</span></div><div class="line"><span class="attr">  ReadTimeout:</span> <span class="number">5000</span></div><div class="line"><span class="attr">  ConnectTimeout:</span> <span class="number">3000</span></div><div class="line"><span class="attr">  OkToRetryOnAllOperations:</span> <span class="literal">true</span>  <span class="comment">#对所有操作都进行重试。</span></div><div class="line"><span class="attr">  MaxAutoRetriesNextServer:</span> <span class="number">2</span>     <span class="comment"># 切换实例的重试次数。 </span></div><div class="line"><span class="attr">  MaxAutoRetries:</span> <span class="number">1</span>               <span class="comment"># 对当前实例的重试次数。</span></div><div class="line">  </div><div class="line"><span class="attr">management:</span>    <span class="comment"># 配置节点，一定要配置，否则将不能连接上</span></div><div class="line"><span class="attr">  endpoints:</span></div><div class="line"><span class="attr">    web:</span></div><div class="line"><span class="attr">      exposure:</span></div><div class="line"><span class="attr">        include:</span> <span class="string">hystrix.stream</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>在主启动类上必须添加注解`@EnableCircuitBreaker</strong>`</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="meta">@EnableEurekaClient</span>   <span class="comment">//开启eureka</span></div><div class="line"><span class="meta">@EnableCircuitBreaker</span>   <span class="comment">//开启熔断</span></div><div class="line"><span class="meta">@EnableFeignClients</span>(basePackages= &#123;<span class="string">"cn.tedu.api.feign"</span>&#125;)  <span class="comment">//扫描FeignClient</span></div><div class="line"><span class="meta">@ComponentScan</span>(basePackages= &#123;<span class="string">"cn.tedu.*"</span>&#125;)   <span class="comment">//扫描Hystrix的fallbackFactory</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderClient9002Application</span> </span>&#123;</div></pre></td></tr></table></figure>
<ul>
<li><p>启动成功后在<code>hystrix-dashboard</code>添加如下地址即可被监控:</p>
<ul>
<li><code>http://localhost:9002/actuator/hystrix.stream</code></li>
</ul>
</li>
<li><p>源码（<code>order-client9002</code>）：<a href="https://github.com/chenjiabing666/order-parent.git" target="_blank" rel="external">https://github.com/chenjiabing666/order-parent.git</a></p>
</li>
</ul>
<h3 id="详细指标"><a href="#详细指标" class="headerlink" title="详细指标"></a>详细指标</h3><ul>
<li><img src="https://github.com/chenjiabing666/BlogImage/blob/master/hystrix2.jpg?raw=true" alt=""></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="熔断发生的场景"><a href="#熔断发生的场景" class="headerlink" title="熔断发生的场景"></a>熔断发生的场景</h3><ul>
<li>达到配置的超时时间</li>
<li>没有服务提供者提供服务</li>
<li>服务提供者程序发生异常</li>
</ul>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul>
<li>Feign+Hystrix的方式配置Hystrix的超时时间一定还要配置Ribbon的超时时间</li>
<li>Feign+Hystrix的熔断配置和Ribbon+Hystrix的配置方式基本相同</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.cnblogs.com/yawen/p/6655352.html" target="_blank" rel="external">https://www.cnblogs.com/yawen/p/6655352.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hystrix-断路器、熔断器&quot;&gt;&lt;a href=&quot;#Hystrix-断路器、熔断器&quot; class=&quot;headerlink&quot; title=&quot;Hystrix 断路器、熔断器&quot;&gt;&lt;/a&gt;Hystrix 断路器、熔断器&lt;/h1&gt;&lt;h2 id=&quot;服务雪崩&quot;&gt;&lt;a href
    
    </summary>
    
      <category term="分布式" scheme="http://chenjiabing666.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://chenjiabing666.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Feign（负载均衡）</title>
    <link href="http://chenjiabing666.github.io/2018/12/25/Feign%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://chenjiabing666.github.io/2018/12/25/Feign负载均衡/</id>
    <published>2018-12-24T16:20:36.000Z</published>
    <updated>2018-12-24T16:21:17.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Feign-负载均衡"><a href="#Feign-负载均衡" class="headerlink" title="Feign 负载均衡"></a>Feign 负载均衡</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用Feign 注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。</li>
<li>声明式的接口+注解</li>
<li>使用的是轮询的算法</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li><strong>添加依赖（消费者端和公共模块端）</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">&lt;!--feign的依赖--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--eureka客户端的依赖--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--ribbon的依赖--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>创建两个<strong>服务提供者</strong>，实例名称为<code>DEPT-PROVIDER</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptController</span> </span>&#123;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 根据Id获取部门</div><div class="line">	 * <span class="doctag">@param</span> id</div><div class="line">	 * <span class="doctag">@return</span></div><div class="line">	 */</div><div class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/dept/&#123;id&#125;"</span>)</div><div class="line">	<span class="function"><span class="keyword">public</span> Dept <span class="title">getDept</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id) </span>&#123;</div><div class="line">		Dept dept=<span class="keyword">new</span> Dept();</div><div class="line">		dept.setDeptId(id);</div><div class="line">		dept.setDeptName(<span class="string">"8081"</span>);</div><div class="line">		<span class="keyword">return</span> dept;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 添加部门</div><div class="line">	 * <span class="doctag">@param</span> dept</div><div class="line">	 */</div><div class="line">	<span class="meta">@PostMapping</span>(<span class="string">"/dept"</span>)</div><div class="line">	<span class="function"><span class="keyword">public</span> Dept <span class="title">addDept</span><span class="params">(@RequestBody Dept dept)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> dept;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>一般我们需要将feign接口写在公共的项目中，因为接口不止一个项目使用，可以提供给多个项目使用，在<code>dept-api</code>这个项目中添加如下的feign接口,其中<code>@FeignClient</code>这个注解的value属性必须和对应的服务提供者的实例名称相同</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cn.tedu.api.feign;</div><div class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</div><div class="line"><span class="keyword">import</span> cn.tedu.api.doamin.Dept;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 1、配置一个Feign的客户端，使用<span class="doctag">@FeignClient</span>()，其中的name是微服务提供者的实例名称</div><div class="line"> * 2、其中的restful风格的api只能使用RequestMapping，不能使用GetMapping等，有些版本可能会报错</div><div class="line"> * 3、怎样和提供者的api对应呢？</div><div class="line"> * 		1、并不是方法名称一致，根据uri来区分的，只要uri访问一致，那么就会匹配对应的服务提供者的api</div><div class="line"> * 		2、虽然不是根据方法名称来匹配，但是我们最好保持一致</div><div class="line"> */</div><div class="line"><span class="meta">@FeignClient</span>(<span class="string">"DEPT-PROVIDER"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DeptFeign</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 获取部门，使用Get方式请求</div><div class="line">	 * <span class="doctag">@param</span> id</div><div class="line">	 * <span class="doctag">@return</span></div><div class="line">	 */</div><div class="line">	<span class="meta">@RequestMapping</span>(value=<span class="string">"/dept/&#123;id&#125;"</span>,method=RequestMethod.GET)</div><div class="line">	<span class="function">Dept <span class="title">get</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span>Integer id)</span>;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 添加部门，使用POST请求的方式</div><div class="line">	 * <span class="doctag">@param</span> dept</div><div class="line">	 * <span class="doctag">@return</span></div><div class="line">	 */</div><div class="line">	<span class="meta">@RequestMapping</span>(value=<span class="string">"/dept"</span>,method=RequestMethod.POST)</div><div class="line">	<span class="function">Dept <span class="title">addDept</span><span class="params">(Dept dept)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>创建消费者，添加上面的dept-api这个坐标，直接注入<code>DeptFeign</code>这个接口实例即可使用，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptController</span> </span>&#123;</div><div class="line">	<span class="meta">@Resource</span></div><div class="line">	<span class="keyword">private</span> DeptFeign deptFeign;  <span class="comment">//直接注入Feign接口，不过需要在主启动类上扫描该类所在的包或者父包</span></div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 根据部门Id获取部门</div><div class="line">	 * <span class="doctag">@param</span> id</div><div class="line">	 * <span class="doctag">@return</span></div><div class="line">	 */</div><div class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/dept/&#123;id&#125;"</span>)</div><div class="line">	<span class="function"><span class="keyword">public</span> Dept <span class="title">getDept</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id) </span>&#123;</div><div class="line">		<span class="keyword">return</span> deptFeign.get(id);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 添加部门，json方式提交</div><div class="line">	 * <span class="doctag">@param</span> dept</div><div class="line">	 * <span class="doctag">@return</span></div><div class="line">	 */</div><div class="line">	<span class="meta">@PostMapping</span>(<span class="string">"/dept"</span>)</div><div class="line">	<span class="function"><span class="keyword">public</span> Dept <span class="title">addDept</span><span class="params">(@RequestBody Dept dept)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> deptFeign.addDept(dept);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在消费者的主启动类上添加<code>@EnableFeignClients</code>这个注解，注意一定要扫描带有<code>@FeignClient</code>这个注解的接口的包或者父包，将其注入到ioc容器中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="meta">@EnableEurekaClient</span>    <span class="comment">//eureka客户端</span></div><div class="line"><span class="meta">@EnableFeignClients</span>(basePackages= &#123;<span class="string">"cn.tedu.api"</span>&#125;)   <span class="comment">//开启Feign，其中basePackages扫描的包一定要是@FeignClient这个注解的所在包或者父包</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptConsumer8003Application</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		SpringApplication.run(DeptConsumer8003Application.class, args);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>消费者端的主启动类上需要使用<code>@EnableFeignClients</code>并且扫描带有<code>@FeignClient</code>这个注解的包或者父包</li>
<li>Feign是和Eureka结合使用的，因此需要添加Eureka的依赖，并且在主启动类上添加对应的注解<code>@EnableEurekaClient</code></li>
<li><strong>Feign的接口怎样和提供者的api对应呢？</strong><ul>
<li>并不是方法名称一致，根据uri来区分的，只要uri访问一致，那么就会匹配对应的服务提供者的api</li>
<li>虽然不是根据方法名称来匹配，但是我们最好保持一致</li>
</ul>
</li>
<li><strong>其中的restful风格的api只能使用<code>RequestMapping</code>，不能使用<code>GetMapping</code>等，有些版本可能会报错</strong></li>
<li>一般使用Feign定义接口都需要放在公共模块中，因为这些接口可能是公用的</li>
</ul>
<h2 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h2><ul>
<li>Feign是结合Ribbon使用的，负载均衡算法和Ribbon是一样的，默认采用的是轮询算法，如果需要改变，只需要注入Ribbon的已经有的算法即可，具体操作和Ribbon一样，只需要新建一个配置类类，直接注入接，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</div><div class="line"><span class="keyword">import</span> com.netflix.loadbalancer.IRule;</div><div class="line"><span class="keyword">import</span> com.netflix.loadbalancer.RandomRule;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Feign的负载均衡算法的配置类，和Ribbon一样</div><div class="line"> */</div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignRule</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 注入随机算法</div><div class="line">	 * <span class="doctag">@return</span></div><div class="line">	 */</div><div class="line">	<span class="meta">@Bean</span></div><div class="line">	<span class="function"><span class="keyword">public</span> IRule <span class="title">myRule</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> RandomRule();   <span class="comment">//直接创建一个随机算法返回即可</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Feign-负载均衡&quot;&gt;&lt;a href=&quot;#Feign-负载均衡&quot; class=&quot;headerlink&quot; title=&quot;Feign 负载均衡&quot;&gt;&lt;/a&gt;Feign 负载均衡&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerli
    
    </summary>
    
      <category term="分布式" scheme="http://chenjiabing666.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://chenjiabing666.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Ribbon（客户端负载均衡）</title>
    <link href="http://chenjiabing666.github.io/2018/12/25/Ribbon%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://chenjiabing666.github.io/2018/12/25/Ribbon客户端负载均衡/</id>
    <published>2018-12-24T16:19:33.000Z</published>
    <updated>2018-12-24T16:20:03.649Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ribbon-客户端负载均衡"><a href="#Ribbon-客户端负载均衡" class="headerlink" title="Ribbon - 客户端负载均衡"></a>Ribbon - 客户端负载均衡</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具。它是一个基于HTTP和TCP的客户端负载均衡器。它可以通过在客户端中配置ribbonServerList来设置服务端列表去轮询访问以达到均衡负载的作用。</li>
</ul>
<h2 id="使用（消费端）"><a href="#使用（消费端）" class="headerlink" title="使用（消费端）"></a>使用（消费端）</h2><ul>
<li>导入依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">      <span class="comment">&lt;!--eureka客户端--&gt;</span>		</div><div class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="comment">&lt;!--ribbon--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>在消费端添加如下配置，用来从eureka集群中轮询请求可访问的微服务，不用注册到eureka中，配置如下：</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attr">server:</span></div><div class="line"><span class="attr">  port:</span> <span class="number">8003</span></div><div class="line"><span class="attr">  servlet:</span></div><div class="line"><span class="attr">    context-path:</span> <span class="string">/dept-consumer</span></div><div class="line"><span class="attr">eureka:</span>  <span class="comment"># 配置eureka客户端，不用注册到eureka中</span></div><div class="line"><span class="attr">  client:</span></div><div class="line"><span class="attr">    serviceUrl:</span>   </div><div class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/,http://eureka7001.com:7001/eureka/</span>  <span class="comment"># eureka的暴露地址，指向集群中每一个eureka，多个用都好分隔  </span></div><div class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span>   <span class="comment"># 只是消费者，因此不用将自己注册到eureka中</span></div></pre></td></tr></table></figure>
<ul>
<li>在restTemplate的配置类中添加一个注解<code>@LoadBalanced</code>，配置如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</div><div class="line"><span class="keyword">import</span> org.springframework.http.client.ClientHttpRequestFactory;</div><div class="line"><span class="keyword">import</span> org.springframework.http.client.SimpleClientHttpRequestFactory;</div><div class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * RestTemplate的配置类</div><div class="line"> * <span class="doctag">@author</span> 陈加兵 	</div><div class="line"> * <span class="doctag">@since</span> 2018年12月6日 下午6:10:58</div><div class="line"> */</div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestConfig</span> </span>&#123;</div><div class="line">	<span class="meta">@Bean</span></div><div class="line">	<span class="meta">@LoadBalanced</span>  <span class="comment">//ribbon实现客户端的负载均衡，默认使用的是轮询的算法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">(ClientHttpRequestFactory factory)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate(factory);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ClientHttpRequestFactory <span class="title">simpleClientHttpRequestFactory</span><span class="params">()</span> </span>&#123;</div><div class="line">        SimpleClientHttpRequestFactory factory = <span class="keyword">new</span> SimpleClientHttpRequestFactory();</div><div class="line">        factory.setReadTimeout(<span class="number">5000</span>);<span class="comment">//单位为ms</span></div><div class="line">        factory.setConnectTimeout(<span class="number">5000</span>);<span class="comment">//单位为ms</span></div><div class="line">        <span class="keyword">return</span> factory;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>在主启动类上添加<code>@EnableEurekaClient</code>注解</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="meta">@EnableEurekaClient</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaClientApplication</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		SpringApplication.run(EurekaClientApplication.class, args);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>消费者的controller端直接使用微服务的名称访问即可，ribbon会自动根据名称在eureka中查询指定的微服务，不需要写明微服务的ip了</strong>，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptController</span> </span>&#123;</div><div class="line">	<span class="meta">@Resource</span></div><div class="line">	<span class="keyword">private</span> RestTemplate restTemplate;</div><div class="line">	<span class="comment">//请求路径直接使用微服务的名称即可EUREKA-PROVIDER，eureka-provider是微服务的项目名称(servlet.context-path)</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String URI_PREFIX=<span class="string">"http://EUREKA-PROVIDER/eureka-provider"</span>;  </div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 使用RestTemplate发出get请求</div><div class="line">	 */</div><div class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/dept/&#123;id&#125;"</span>)</div><div class="line">	<span class="function"><span class="keyword">public</span> Dept <span class="title">getDept</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span>Integer id) <span class="keyword">throws</span> RestClientException, URISyntaxException</span>&#123;</div><div class="line">		Map&lt;String, Object&gt; params=<span class="keyword">new</span> HashMap&lt;String, Object&gt;();</div><div class="line">		params.put(<span class="string">"id"</span>, id);</div><div class="line">		Dept dept = restTemplate.getForObject(URI_PREFIX+<span class="string">"/dept/&#123;id&#125;"</span>, Dept.class, params);</div><div class="line">		<span class="keyword">return</span> dept;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p><strong>创建两个提供者，提供相同的服务，使用同一个微服务的名称（<code>EUREKA-PROVIDER</code>），这个就相当于是一个集群了，需要改变的就是<code>端口</code>和<code>instance-id</code>，配置如下：</strong></p>
<ul>
<li>第一个服务提供者</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="attr">server:</span></div><div class="line"><span class="attr">  port:</span> <span class="number">8001</span></div><div class="line"><span class="attr">  servlet:</span></div><div class="line"><span class="attr">    context-path:</span> <span class="string">/eureka-provider</span>    <span class="comment"># 访问的项目名称在配置“集群”的时候也是必须一样的，否则不好调用</span></div><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  client:</span></div><div class="line"><span class="attr">    serviceUrl:</span></div><div class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/,http://eureka7001.com:7001/eureka/</span>  <span class="comment"># eureka的暴露地址，直接注册，使用的是eureka的集群</span></div><div class="line"><span class="attr">  instance:</span></div><div class="line"><span class="attr">    instance-id:</span> <span class="attr">eureka-provider:8001</span>    <span class="comment">## instance-id区别服务</span></div><div class="line"><span class="attr">    prefer-ip-address:</span> <span class="literal">true</span>       <span class="comment">## 访问路径可以显示服务主机的IP地址</span></div><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  application:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">eureka-provider</span>   <span class="comment">#微服务的名称，配置集群的时候必须相同</span></div></pre></td></tr></table></figure>
<ul>
<li>第二个服务提供者</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="attr">server:</span></div><div class="line"><span class="attr">  port:</span> <span class="number">8002</span></div><div class="line"><span class="attr">  servlet:</span></div><div class="line"><span class="attr">    context-path:</span> <span class="string">/eureka-provider</span>    <span class="comment"># 访问的项目名称在配置“集群”的时候也是必须一样的，否则不好调用</span></div><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  client:</span></div><div class="line"><span class="attr">    serviceUrl:</span></div><div class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/,http://eureka7001.com:7001/eureka/</span>  <span class="comment"># eureka的暴露地址，直接注册，使用的是eureka的集群</span></div><div class="line"><span class="attr">  instance:</span></div><div class="line"><span class="attr">    instance-id:</span> <span class="attr">eureka-provider:8002</span>    <span class="comment">## instance-id区别服务</span></div><div class="line"><span class="attr">    prefer-ip-address:</span> <span class="literal">true</span>       <span class="comment">## 访问路径可以显示服务主机的IP地址</span></div><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  application:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">eureka-provider</span>   <span class="comment">#微服务的名称，配置集群的时候必须相同</span></div></pre></td></tr></table></figure>
</li>
<li><p>微服务启动，如下图：</p>
</li>
<li><p><img src="https://github.com/chenjiabing666/BlogImage/blob/master/eureka4.png?raw=true" alt=""></p>
</li>
</ul>
<ul>
<li>此时访问<code>http://localhost:8003/dept/-consumer/dept/1</code>可以发现此时的负载均衡的策略默认使用的是轮询算法</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li><strong>负载均衡是在同一个功能的微服务中根据不同的策略选择不同的微服务，因此这些微服务对外暴露的实例名称要相同（spring.application.name）</strong></li>
<li><strong>ribbon是一个客户端的负载均衡，必须要连接eureka，才能在指定的微服务实例中按照策略选择</strong></li>
</ul>
<h2 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h2><ul>
<li><strong><code>RoundRobinRule</code>：轮询，默认的算法</strong></li>
<li><strong><code>RandomRule</code> ： 随机算法</strong></li>
<li><code>AvailabilityFilteringRule</code>：会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，还有并发的连接数量超过阈值的服务，然后对剩余的服务列表按照轮询策略进行访问</li>
<li><code>WeightedResponseTimeRule</code>：根据平均响应时间计算所有的权重，响应时间越快服务权重越大被选中的概率越高，刚启动时统计信息不足，则使用轮询策略，等统计信息足够，会自动切换到WeightedResponseTimeRule</li>
<li><strong><code>RetryRule</code>：先按照轮询策略获取服务，如果服务获取失败则在指定时间内会进行重试，获取可用的服务</strong></li>
<li><code>BestAvailableRule</code>：会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务</li>
<li><code>ZoneAvoidanceRule</code>：复合判断server所在区域的性能和server的可用性选择服务器</li>
</ul>
<h2 id="配置负载均衡策略"><a href="#配置负载均衡策略" class="headerlink" title="配置负载均衡策略"></a>配置负载均衡策略</h2><ul>
<li>直接创建一个配置类，注入想要使用的负载均衡算法即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> com.netflix.loadbalancer.IRule;</div><div class="line"><span class="keyword">import</span> com.netflix.loadbalancer.RandomRule;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Ribbon负载均衡算法的配置类</div><div class="line"> * 1、原理：如果用户没有注入自己的算法，那么ribbon默认使用的是轮询算法，如果注入了，那么将会使用注入的</div><div class="line"> */ </div><div class="line"><span class="meta">@Configuration</span>   <span class="comment">//表明这是一个配置类，相当于配置文件xml</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonRule</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 配置随机算法，改变默认的轮询算法</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">rule</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomRule();   <span class="comment">//直接返回随机算法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="自定义负载均衡算法"><a href="#自定义负载均衡算法" class="headerlink" title="自定义负载均衡算法"></a>自定义负载均衡算法</h2><ul>
<li>未完，待续……</li>
</ul>
<h2 id="超时时间设置"><a href="#超时时间设置" class="headerlink" title="超时时间设置"></a>超时时间设置</h2><ul>
<li>默认超时时间为1000毫秒，如果需要修改超时时间，配置如下:<ul>
<li>由于是http请求，因此这里代表的socket的连接时间和读取时间</li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">ribbon:</span> </div><div class="line"><span class="attr">  ReadTimeout:</span> <span class="number">5000</span>     <span class="comment"># 请求处理时间。</span></div><div class="line"><span class="attr">  ConnectTimeout:</span> <span class="number">9000</span>   <span class="comment"># 请求连接时间。</span></div></pre></td></tr></table></figure>
<h2 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h2><ul>
<li><a href="https://blog.csdn.net/akaks0/article/details/80039590" target="_blank" rel="external">https://blog.csdn.net/akaks0/article/details/80039590</a></li>
<li>全局配置如下：</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">ribbon:</span> </div><div class="line"><span class="attr">  OkToRetryOnAllOperations:</span> <span class="literal">true</span>  <span class="comment">#对所有操作都进行重试。</span></div><div class="line"><span class="attr">  MaxAutoRetriesNextServer:</span> <span class="number">2</span>     <span class="comment"># 切换实例的重试次数。 </span></div><div class="line"><span class="attr">  MaxAutoRetries:</span> <span class="number">1</span>               <span class="comment"># 对当前实例的重试次数。</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Ribbon-客户端负载均衡&quot;&gt;&lt;a href=&quot;#Ribbon-客户端负载均衡&quot; class=&quot;headerlink&quot; title=&quot;Ribbon - 客户端负载均衡&quot;&gt;&lt;/a&gt;Ribbon - 客户端负载均衡&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;
    
    </summary>
    
      <category term="分布式" scheme="http://chenjiabing666.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://chenjiabing666.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>spring cloud的资源</title>
    <link href="http://chenjiabing666.github.io/2018/12/25/Spring%20cloud%E7%9A%84%E4%BC%98%E7%A7%80%E8%B5%84%E6%BA%90/"/>
    <id>http://chenjiabing666.github.io/2018/12/25/Spring cloud的优秀资源/</id>
    <published>2018-12-24T16:19:33.000Z</published>
    <updated>2018-12-24T16:27:21.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="spring-cloud的资源"><a href="#spring-cloud的资源" class="headerlink" title="spring cloud的资源"></a>spring cloud的资源</h2><ul>
<li><a href="https://springcloud.cc/" target="_blank" rel="external">Springcloud中文网</a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html" target="_blank" rel="external">中文文档</a></li>
<li><a href="http://springcloud.cn/" target="_blank" rel="external">中国社区</a></li>
<li><a href="http://springcloud.fun/" target="_blank" rel="external">优质学习资源</a></li>
<li><a href="http://www.cnblogs.com/skyme/p/8976866.html" target="_blank" rel="external">SpringBoot学习资源</a></li>
<li><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/2.1.0.M3/single/spring-cloud-netflix.html" target="_blank" rel="external">官方文档</a></li>
<li><a href="http://www.itmuch.com/spring-cloud-sum-eureka/" target="_blank" rel="external">http://www.itmuch.com/spring-cloud-sum-eureka/</a></li>
<li><a href="https://yujunhao8831.github.io/2017/05/27/Spring-Cloud-Eureka-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="external">指南</a></li>
<li><a href="https://www.cnblogs.com/huangjuncong/tag/SpringCloud/" target="_blank" rel="external">https://www.cnblogs.com/huangjuncong/tag/SpringCloud/</a></li>
<li><a href="https://blog.csdn.net/u012702547/article/details/78547925" target="_blank" rel="external">https://blog.csdn.net/u012702547/article/details/78547925</a></li>
<li><a href="https://www.cnblogs.com/leeSmall/category/1185489.html" target="_blank" rel="external">https://www.cnblogs.com/leeSmall/category/1185489.html</a></li>
<li><a href="https://windmt.com/tags/Spring-Cloud/" target="_blank" rel="external">https://windmt.com/tags/Spring-Cloud/</a></li>
<li><a href="http://www.ityouknow.com" target="_blank" rel="external">http://www.ityouknow.com</a></li>
<li><a href="http://www.itmuch.com/categories/Spring-Cloud" target="_blank" rel="external">http://www.itmuch.com/categories/Spring-Cloud</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;spring-cloud的资源&quot;&gt;&lt;a href=&quot;#spring-cloud的资源&quot; class=&quot;headerlink&quot; title=&quot;spring cloud的资源&quot;&gt;&lt;/a&gt;spring cloud的资源&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;htt
    
    </summary>
    
      <category term="分布式" scheme="http://chenjiabing666.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://chenjiabing666.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
</feed>
