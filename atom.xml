<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>爱撒谎的男孩</title>
  <subtitle>一只程序猿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chenjiabing666.github.io/"/>
  <updated>2019-08-04T16:48:02.274Z</updated>
  <id>http://chenjiabing666.github.io/</id>
  
  <author>
    <name>Chenjiabing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mybatis源码解析</title>
    <link href="http://chenjiabing666.github.io/2019/08/05/mybatis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://chenjiabing666.github.io/2019/08/05/mybatis源码解析/</id>
    <published>2019-08-04T16:47:11.000Z</published>
    <updated>2019-08-04T16:48:02.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h1><ul>
<li>mybatis的全局配置类，其中封装了mybatis的全部配置，在mybaits加载全局配置文件和Mapper文件的时候，会将里面的xml中的各个元素解析出来，封装在其中。</li>
<li>主要的解析流程在<code>org.apache.ibatis.builder.xml.XMLConfigBuilder#parseConfiguration</code>有详细描述。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">//issue #117 read properties first</span></div><div class="line">      propertiesElement(root.evalNode(<span class="string">"properties"</span>));</div><div class="line">      Properties settings = settingsAsProperties(root.evalNode(<span class="string">"settings"</span>));</div><div class="line">      loadCustomVfs(settings);</div><div class="line">      loadCustomLogImpl(settings);</div><div class="line">      typeAliasesElement(root.evalNode(<span class="string">"typeAliases"</span>));</div><div class="line">      pluginElement(root.evalNode(<span class="string">"plugins"</span>));</div><div class="line">      objectFactoryElement(root.evalNode(<span class="string">"objectFactory"</span>));</div><div class="line">      objectWrapperFactoryElement(root.evalNode(<span class="string">"objectWrapperFactory"</span>));</div><div class="line">      reflectorFactoryElement(root.evalNode(<span class="string">"reflectorFactory"</span>));</div><div class="line">      settingsElement(settings);</div><div class="line">      <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></div><div class="line">      environmentsElement(root.evalNode(<span class="string">"environments"</span>));</div><div class="line">      databaseIdProviderElement(root.evalNode(<span class="string">"databaseIdProvider"</span>));</div><div class="line">      typeHandlerElement(root.evalNode(<span class="string">"typeHandlers"</span>));</div><div class="line">      mapperElement(root.evalNode(<span class="string">"mappers"</span>));</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing SQL Mapper Configuration. Cause: "</span> + e, e);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h1 id="MapperRegistry"><a href="#MapperRegistry" class="headerlink" title="MapperRegistry"></a>MapperRegistry</h1><ul>
<li>其中存放了所有的Mapper信息，相当于Mapper的注册中心</li>
<li>所有的Mapper信息都存放在<code>Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers</code>这个Map中，key是Mapper的全类名，value是MapperProxyFactory对象（用来创建代理对象）</li>
<li>在mybaits加载配置文件解析Mapper的时候，会调用<code>addMapper</code>方法，将其添加到Map中。在获取Mapper的时候会调用getMapper方法，利用MapperProxyFactory对象创建一个代理对象返回。</li>
</ul>
<h1 id="MappedStatement"><a href="#MappedStatement" class="headerlink" title="MappedStatement"></a>MappedStatement</h1><ul>
<li>封装了一个增删改查标签的全部属性，一个标签就是一个MappedStatement，保存在全局配置类中的<code>Map&lt;String, MappedStatement&gt; mappedStatements</code>中</li>
</ul>
<h1 id="MapperProxyFactory"><a href="#MapperProxyFactory" class="headerlink" title="MapperProxyFactory"></a>MapperProxyFactory</h1><ul>
<li>创建Mapper代理对象的工厂类，其中最重要的两个方法如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用MapperProxy创建一个代理对象</span></div><div class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</div><div class="line">      <span class="comment">//封装一个MapperProxy</span></div><div class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);</div><div class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h1 id="MapperProxy"><a href="#MapperProxy" class="headerlink" title="MapperProxy"></a>MapperProxy</h1><ul>
<li>Mapper的代理类，实现了<code>InvocationHandler</code>，当mapper调用方法的时候真正执行的方法是invoke</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</div><div class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.isDefault()) &#123;</div><div class="line">        <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</div><div class="line">    <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ul>
<li>其中的属性有<code>sqlSession</code>（其中的属性有全局配置类Configuration）、<code>mapperInterface</code>（mapper真正的接口）、<code>Map&lt;Method, MapperMethod&gt; methodCache</code></li>
</ul>
<h1 id="MapperMethod"><a href="#MapperMethod" class="headerlink" title="MapperMethod"></a>MapperMethod</h1><ul>
<li>封装了Mapper接口中的单个方法，其中有两个重要的属性，如下：<ul>
<li><code>SqlCommand</code>：封装方法的全类名和执行的增删改查的类型（SqlCommandType的枚举类型）</li>
<li><code>MethodSignature</code>：方法的签名，其中封装了该方法的一些信息，比如返回类型，返回值的类型等信息。</li>
</ul>
</li>
</ul>
<ul>
<li>其中有一个<code>public Object execute(SqlSession sqlSession, Object[] args)</code>方法，用来执行方法，如下：<ul>
<li>根据方法的不同类型，执行不同的逻辑</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</div><div class="line">    Object result;</div><div class="line">    <span class="keyword">switch</span> (command.getType()) &#123;</div><div class="line">      <span class="keyword">case</span> INSERT: &#123;</div><div class="line">        Object param = method.convertArgsToSqlCommandParam(args);</div><div class="line">        result = rowCountResult(sqlSession.insert(command.getName(), param));</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">case</span> UPDATE: &#123;</div><div class="line">        Object param = method.convertArgsToSqlCommandParam(args);</div><div class="line">        result = rowCountResult(sqlSession.update(command.getName(), param));</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">case</span> DELETE: &#123;</div><div class="line">        Object param = method.convertArgsToSqlCommandParam(args);</div><div class="line">        result = rowCountResult(sqlSession.delete(command.getName(), param));</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">case</span> SELECT:</div><div class="line">        <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</div><div class="line">          executeWithResultHandler(sqlSession, args);</div><div class="line">          result = <span class="keyword">null</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</div><div class="line">          result = executeForMany(sqlSession, args);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</div><div class="line">          result = executeForMap(sqlSession, args);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123;</div><div class="line">          result = executeForCursor(sqlSession, args);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          Object param = method.convertArgsToSqlCommandParam(args);</div><div class="line">          result = sqlSession.selectOne(command.getName(), param);</div><div class="line">          <span class="keyword">if</span> (method.returnsOptional()</div><div class="line">              &amp;&amp; (result == <span class="keyword">null</span> || !method.getReturnType().equals(result.getClass()))) &#123;</div><div class="line">            result = Optional.ofNullable(result);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> FLUSH:</div><div class="line">        result = sqlSession.flushStatements();</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Unknown execution method for: "</span> + command.getName());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Mapper method '"</span> + command.getName()</div><div class="line">          + <span class="string">" attempted to return null from a method with a primitive return type ("</span> + method.getReturnType() + <span class="string">")."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h1 id="BoundSql"><a href="#BoundSql" class="headerlink" title="BoundSql"></a>BoundSql</h1><ul>
<li>封装了SQL语句的信息，包括需要执行的sql语句，参数列表等信息，通过MappedStatement中getBoundSql()方法创建。</li>
</ul>
<h1 id="ResultHandler"><a href="#ResultHandler" class="headerlink" title="ResultHandler"></a>ResultHandler</h1><h1 id="TypeHandler"><a href="#TypeHandler" class="headerlink" title="TypeHandler"></a>TypeHandler</h1><h1 id="Mybatis四大关键类"><a href="#Mybatis四大关键类" class="headerlink" title="Mybatis四大关键类"></a>Mybatis四大关键类</h1><h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><ul>
<li>执行器：在mybaits中负责执行增删改查和事务的操作，mybatis会根据不同的executorType创建不同的执行器</li>
<li>Mybaits的执行器主要有如下的类型：<ul>
<li><code>ExecutorType.SIMPLE</code>：这个执行器类型不做特殊的事情。它为每个语句的执行创建一个新的预处理语句。</li>
<li><code>ExecutorType.REUSE</code>：这个执行器类型会复用预处理语句。</li>
<li><code>ExecutorType.BATCH</code>：这个执行器会批量执行所有更新语句，如果 SELECT 在它们中间执行，必要时请把它们区分开来以保证行为的易读性。</li>
</ul>
</li>
</ul>
<ul>
<li>我们通过SqlSessionFactory创建sqlSession的时候可以传入执行器的类型，如果不传入，默认使用Simple类型的，在源码中的创建的执行的逻辑如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//org.apache.ibatis.session.Configuration#newExecutor(org.apache.ibatis.transaction.Transaction, org.apache.ibatis.session.ExecutorType)</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</div><div class="line">    <span class="comment">//如果没有指定，使用默认的类型</span></div><div class="line">    executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</div><div class="line">    executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</div><div class="line">    Executor executor;</div><div class="line">    <span class="comment">//批量执行的执行器</span></div><div class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</div><div class="line">      executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</div><div class="line">      executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//缓存执行器，实现二级缓存</span></div><div class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</div><div class="line">      executor = <span class="keyword">new</span> CachingExecutor(executor);</div><div class="line">    &#125;</div><div class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</div><div class="line">    <span class="keyword">return</span> executor;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ul>
<li>实现类型如下：<ul>
<li>BatchExecutor：批量执行器</li>
<li>ReuseExecutor：复用执行器</li>
<li>SimpleExecutor：简单执行器，默认的</li>
<li>CachingExecutor：缓存执行器，mybaits中默认使用的执行器，用于二级缓存</li>
</ul>
</li>
</ul>
<h2 id="ParameterHandler"><a href="#ParameterHandler" class="headerlink" title="ParameterHandler"></a>ParameterHandler</h2><ul>
<li>主要作用就是设置为Statement设置参数</li>
</ul>
<h2 id="ResultSetHandler"><a href="#ResultSetHandler" class="headerlink" title="ResultSetHandler"></a>ResultSetHandler</h2><ul>
<li>主要作用就是对最后的结果进行处理</li>
</ul>
<h2 id="StatementHandler"><a href="#StatementHandler" class="headerlink" title="StatementHandler"></a>StatementHandler</h2><ul>
<li>顾名思义就是创建JDBC中的Statement，实现类如下：<ul>
<li><code>SimpleStatementHandler</code></li>
<li><code>PreparedStatementHandler</code></li>
<li><code>CallableStatementHandler</code></li>
</ul>
</li>
<li>主要的作用就是处理Statement，执行查询，对参数、查询结果进行处理。</li>
<li>主要的方法如下：<ul>
<li><code>Statement prepare(Connection connection, Integer transactionTimeout)</code>：创建Statement</li>
<li><code>void parameterize(Statement statement</code>：设置参数</li>
<li><code>void batch(Statement statement)</code>：批量处理</li>
<li><code>&lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler)</code>：执行查询</li>
</ul>
</li>
</ul>
<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><ul>
<li>分析源码执行流程，画出对应的流程图，方便理解和记忆</li>
</ul>
<h2 id="Mybatis创建MapperProxy"><a href="#Mybatis创建MapperProxy" class="headerlink" title="Mybatis创建MapperProxy"></a>Mybatis创建MapperProxy</h2><ul>
<li>包括了读取全局配置文件和Mapper文件生成全局配置类、创建Mapper代理对象的详细过程</li>
</ul>
<p><img src="https://raw.githubusercontent.com/chenjiabing666/BlogImage/master/mybatis%20crete%20mapper.png" alt=""></p>
<h2 id="Mybaits执行查询"><a href="#Mybaits执行查询" class="headerlink" title="Mybaits执行查询"></a>Mybaits执行查询</h2><ul>
<li>主要描述了mybaits通过代理对象如何执行查询语句到对查询结果的处理过程的详细描述</li>
</ul>
<p><img src="https://raw.githubusercontent.com/chenjiabing666/BlogImage/master/mybatis%20select%20all.png" alt=""></p>
<h2 id="Mybaits执行查询的简化版"><a href="#Mybaits执行查询的简化版" class="headerlink" title="Mybaits执行查询的简化版"></a>Mybaits执行查询的简化版</h2><ul>
<li>主要根据Mybatis中的重要的四大类，和SqlSession、TypeHandler进行简化描述，如下：<br><img src="https://raw.githubusercontent.com/chenjiabing666/BlogImage/master/mybatis%20select%20simple.png" alt=""></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Configuration&quot;&gt;&lt;a href=&quot;#Configuration&quot; class=&quot;headerlink&quot; title=&quot;Configuration&quot;&gt;&lt;/a&gt;Configuration&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;mybatis的全局配置类，其中封装了m
    
    </summary>
    
      <category term="MyBatis" scheme="http://chenjiabing666.github.io/categories/MyBatis/"/>
    
    
      <category term="MyBatis" scheme="http://chenjiabing666.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis深入学习</title>
    <link href="http://chenjiabing666.github.io/2019/08/05/mybatis%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    <id>http://chenjiabing666.github.io/2019/08/05/mybatis深入学习/</id>
    <published>2019-08-04T16:46:56.000Z</published>
    <updated>2019-08-04T16:48:48.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><ul>
<li>按照官方文档搭建即可</li>
</ul>
<h1 id="typeAliases（别名）"><a href="#typeAliases（别名）" class="headerlink" title="typeAliases（别名）"></a>typeAliases（别名）</h1><ul>
<li><p>在使用mybatis标签的时候，需要指定类的全类名，比如<code>resultType=xx.xxx.xx</code>，但是我们可以为类指定别名，那么就可以直接使用别名，避免全类名冗余【不推荐使用】</p>
</li>
<li><p>别名的配置有两种方式，这里我们讲解简单的配置方式，步骤如下：</p>
<ul>
<li>在mybatis的全局配置文件下指定别名的包扫描如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"cn.tedu.domain"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>在domain这个包下的所有类默认的别名是类名首字母小写，但是我们也可以使用注解指定，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Alias</span>(<span class="string">"author"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Author</span> </span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="内建的别名【推荐使用】"><a href="#内建的别名【推荐使用】" class="headerlink" title="内建的别名【推荐使用】"></a>内建的别名【推荐使用】</h2><ul>
<li>mybatis对java中基本类型和基本的引用类型内嵌了别名，我们可以直接使用别名进行指定，这样利于开发，内建的别名如下：</li>
</ul>
<table>
<thead>
<tr>
<th>别名</th>
<th>映射的类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>_byte</td>
<td>byte</td>
</tr>
<tr>
<td>_long</td>
<td>long</td>
</tr>
<tr>
<td>_short</td>
<td>short</td>
</tr>
<tr>
<td>_int</td>
<td>int</td>
</tr>
<tr>
<td>_integer</td>
<td>int</td>
</tr>
<tr>
<td>_double</td>
<td>double</td>
</tr>
<tr>
<td>_float</td>
<td>float</td>
</tr>
<tr>
<td>_boolean</td>
<td>boolean</td>
</tr>
<tr>
<td>string</td>
<td>String</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>integer</td>
<td>Integer</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>date</td>
<td>Date</td>
</tr>
<tr>
<td>decimal</td>
<td>BigDecimal</td>
</tr>
<tr>
<td>bigdecimal</td>
<td>BigDecimal</td>
</tr>
<tr>
<td>object</td>
<td>Object</td>
</tr>
<tr>
<td>map</td>
<td>Map</td>
</tr>
<tr>
<td>hashmap</td>
<td>HashMap</td>
</tr>
<tr>
<td>list</td>
<td>List</td>
</tr>
<tr>
<td>arraylist</td>
<td>ArrayList</td>
</tr>
<tr>
<td>collection</td>
<td>Collection</td>
</tr>
<tr>
<td>iterator</td>
<td>Iterator</td>
</tr>
</tbody>
</table>
<h1 id="参数处理"><a href="#参数处理" class="headerlink" title="参数处理"></a>参数处理</h1><ul>
<li>mybatis内部会将我们传入的参数封装成一个Map，key就是以<code>param1、param2....</code></li>
</ul>
<h2 id="单个参数"><a href="#单个参数" class="headerlink" title="单个参数"></a>单个参数</h2><ul>
<li>单个参数在sql语句中可以任意指定，比如#{a}…，或者可以使用<code>#{param1}</code></li>
</ul>
<h1 id="多个参数"><a href="#多个参数" class="headerlink" title="多个参数"></a>多个参数</h1><ul>
<li>使用<code>@Param</code>指定key，那么就可以在sql语句中直接使用这个key即可，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Select</span>(<span class="string">"select * from patient_info where ipt_num=#&#123;iptNum&#125; and status=#&#123;status&#125;"</span>)</div><div class="line">   <span class="function">Patient <span class="title">selectByIptNumAndInhos</span><span class="params">(@Param(<span class="string">"iptNum"</span>)</span> String iptNum, @<span class="title">Param</span><span class="params">(<span class="string">"status"</span>)</span> String status)</span>;</div></pre></td></tr></table></figure>
<ul>
<li>也可以直接使用mybatis中默认的key，即是param1…..</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Select</span>(<span class="string">"select * from patient_info where ipt_num=#&#123;param1&#125; and status=#&#123;param2&#125;"</span>)</div><div class="line">  <span class="function">Patient <span class="title">selectByIptNumAndInhos</span><span class="params">(String iptNum,String status)</span></span>;</div></pre></td></tr></table></figure>
<h2 id="参数是Map类型"><a href="#参数是Map类型" class="headerlink" title="参数是Map类型"></a>参数是Map类型</h2><ul>
<li>mybatis默认的会将参数转换为map，那么我们直接传入一个map那是再好不过了，此时的key就可以直接使用，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Select</span>(<span class="string">"select * from patient_info where ipt_num=#&#123;iptNum&#125; and status=#&#123;status&#125;"</span>)</div><div class="line"> <span class="function">Patient <span class="title">selectByIptAndInhosNumMap</span><span class="params">(Map ipts)</span></span>;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        SqlSessionFactory sqlSessionFactory = XmlConfigInit.getSqlSessionFactory();</div><div class="line">        PatientMapper mapper = sqlSessionFactory.openSession().getMapper(PatientMapper.class);</div><div class="line">        Map&lt;String,String&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        map.put(<span class="string">"iptNum"</span>,<span class="string">"15627656"</span>);</div><div class="line">        map.put(<span class="string">"status"</span>,<span class="string">"1"</span>);</div><div class="line">        Patient patient = mapper.selectByIptAndInhosNumMap(map);</div><div class="line">        System.out.println(patient);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="POJO【推荐使用】"><a href="#POJO【推荐使用】" class="headerlink" title="POJO【推荐使用】"></a>POJO【推荐使用】</h2><ul>
<li>对于POJO可以直接使用成员属性的名称就可以取值，这个经常使用，不再演示</li>
</ul>
<h1 id="返回结果封装"><a href="#返回结果封装" class="headerlink" title="返回结果封装"></a>返回结果封装</h1><ul>
<li>mybatis对于返回结果如何封装有多种实现方式，可以返回List，POJO，Map等类型的数据</li>
</ul>
<h2 id="返回POJO"><a href="#返回POJO" class="headerlink" title="返回POJO"></a>返回POJO</h2><ul>
<li>对于从数据库中查询单条数据库的时候，返回一个POJO只需要sql查询的字段和POJO类中的属性相同即可自动映射，当然我们也可以开启<strong>驼峰配置</strong></li>
<li><code>resultType</code>指定返回的POJO的全类名即可，或者指定别名</li>
<li>此处不演示</li>
</ul>
<h2 id="返回List"><a href="#返回List" class="headerlink" title="返回List"></a>返回List</h2><ul>
<li>同POJO，此时的resultType指定的仍然是List泛型的全类名或者别名</li>
</ul>
<h2 id="返回Map"><a href="#返回Map" class="headerlink" title="返回Map"></a>返回Map</h2><ul>
<li>mybatis还可以返回Map类型的数据，比如我们查询患者的信息，使用Map接收数据，key是患者的id，value就是POJO，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * 使用<span class="doctag">@MapKey</span>注解指定返回Map中的key，这里设定的是Patient中的id属性作为key</div><div class="line">    * <span class="doctag">@return</span></div><div class="line">    */</div><div class="line">   <span class="meta">@MapKey</span>(<span class="string">"id"</span>)</div><div class="line">   <span class="meta">@Select</span>(<span class="string">"select * from patient_info"</span>)</div><div class="line">   <span class="function">Map&lt;Integer,Patient&gt; <span class="title">selectAllReturnMap</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li>在返回的Map的时候需要指定POJO类的哪个字段作为Map的key，使用<code>@MapKey</code>这个注解指定</li>
</ul>
<h2 id="ResultMap"><a href="#ResultMap" class="headerlink" title="ResultMap"></a>ResultMap</h2><ul>
<li>mybatis还支持使用ResultMap自定义结果映射，此时的select语句中需要指定resultMap为当前的定义的id</li>
<li>经常使用，不再演示</li>
</ul>
<h1 id="分步查询"><a href="#分步查询" class="headerlink" title="分步查询"></a>分步查询</h1><ul>
<li><p>在mybatis中<code>collection</code>和<code>association</code>中都是可以使用分步查询</p>
</li>
<li><p>我们需要查询一个科室下的所有患者，那么实体类定义如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="meta">@ToString</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dept</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Integer id;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> List&lt;Patient&gt; patients;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="meta">@ToString</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Patient</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String userId;</div><div class="line">    <span class="keyword">private</span> Integer id;</div><div class="line">    <span class="keyword">private</span> String status;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>不采用分布查询，此时我们的resultMap应该如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"baseResultMap"</span> <span class="attr">type</span>=<span class="string">"cn.tedu.domain.Dept"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"patients"</span> <span class="attr">ofType</span>=<span class="string">"cn.tedu.domain.Patient"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"pid"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"userId"</span> <span class="attr">property</span>=<span class="string">"userId"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"pstatus"</span> <span class="attr">property</span>=<span class="string">"status"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></div><div class="line"></div><div class="line">//sql</div><div class="line"></div><div class="line"> SELECT</div><div class="line">        d.id AS id,</div><div class="line">        d.NAME AS NAME,</div><div class="line">        p.id AS pid,</div><div class="line">        p.user_id AS userId,</div><div class="line">        p.STATUS AS pstatus</div><div class="line">    FROM</div><div class="line">        dept_info d</div><div class="line">        LEFT JOIN patient_info p ON p.dept_id = d.id</div><div class="line">    WHERE</div><div class="line">        d.id =#&#123;id,jdbcType=INTEGER&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>但是我们也可以采用分布查询的方式，先查询出科室的信息，再根据科室的id查询出对应患者的信息，实现步骤如下：</p>
<ul>
<li>定义一个方法查找科室，此时的resultMap指定的是分步查询的id</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;select id="selectById" resultMap="ByStepResultMap"&gt;</div><div class="line">           SELECT</div><div class="line">       *</div><div class="line">   FROM</div><div class="line">       dept_info</div><div class="line">   WHERE</div><div class="line">       id =#&#123;id,jdbcType=INTEGER&#125;</div><div class="line">   &lt;/select&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>定义一个方法根据科室id查询患者信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Select</span>(<span class="string">"SELECT * from patient_info where dept_id=#&#123;deptId&#125;"</span>)</div><div class="line">    <span class="function">List&lt;Patient&gt; <span class="title">selectByDeptId</span><span class="params">(Integer deptId)</span></span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>在resultMap中指定分步查询</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--分步查询科室信息和患者信息--&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"ByStepResultMap"</span> <span class="attr">type</span>=<span class="string">"cn.tedu.domain.Dept"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span> /&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></div><div class="line">  </div><div class="line">       <span class="comment">&lt;!--ofType：指定级联属性的类型--&gt;</span></div><div class="line">       <span class="comment">&lt;!--select：指定分步查询患者信息的方法，全类名+方法名--&gt;</span></div><div class="line">       <span class="comment">&lt;!--column：指定查询科室获取的结果的哪一个字段作为查询患者方法的参数，可以指定多个</span></div><div class="line">                   如果指定多个，那么需要将参数封装成map，比如column="&#123;key1=column1,key2=column2&#125;"</div><div class="line">       --&gt;</div><div class="line">        <span class="comment">&lt;!--fetchType：在开启全局延迟加载的时候设置是否延迟加载，默认是延迟加载，可以设置为eager表示不延迟加载--&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"patients"</span> <span class="attr">ofType</span>=<span class="string">"cn.tedu.domain.Patient"</span></span></div><div class="line">                   <span class="attr">select</span>=<span class="string">"cn.tedu.mapper.PatientMapper.selectByDeptId"</span></div><div class="line">                   <span class="attr">column</span>=<span class="string">"id"</span>&gt;</div><div class="line">       <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><ul>
<li>mybatis默认是不使用延迟加载的，因此当使用分步查询的时候即使没有用到分步查询的结果仍然会发出sql语句</li>
<li>我们可以在全局配置文件中设置开启延迟加载，如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!--延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态。--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></div><div class="line">        <span class="comment">&lt;!--当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个属性会按需加载（参考 lazyLoadTriggerMethods)。--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"aggressiveLazyLoading"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></div></pre></td></tr></table></figure>
<h1 id="内置参数"><a href="#内置参数" class="headerlink" title="内置参数"></a>内置参数</h1><ul>
<li>mybatis中内置了两个参数，在写sql的时候可以直接拿来使用，如下：<ul>
<li><code>_parameter</code>：代表整个参数，如果是一个参数就表示这个参数，如果是多个参数，此时的参数会被封装成一个Map，那么_parameter此时就代表整个Map</li>
<li><code>_databaseId</code>：如果配置了databaseIdProvider标签，就代表当前数据库的别名</li>
</ul>
</li>
</ul>
<ul>
<li>实例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Select</span>(<span class="string">"SELECT * from patient_info where dept_id=#&#123;_parameter&#125;"</span>)</div><div class="line">   <span class="function">List&lt;Patient&gt; <span class="title">selectByDeptId</span><span class="params">(Integer deptId)</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li>如果是一个参数，并且是POJO对象，我们还可以使用<code>_parameter</code>判断是否为空，如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"_parameter!=null"</span>&gt;</span></div><div class="line">	.....</div><div class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>如果是多个参数，那么就表示一个Map，此时可以直接使用<code>_parameter.key1....</code>直接获取值即可，当然如果没有指定@Param注解，此时还可以使用<code>_parameter.param1,_parameter.param2...</code>直接获取对应的值</li>
</ul>
<h1 id="批量处理"><a href="#批量处理" class="headerlink" title="批量处理"></a>批量处理</h1><ul>
<li>Mybatis针对批量操作有两种常用的方法，第一种就死通过动态sql在sql语句中使用for-each拼写，第二种就是使用Mybaits自带的批量执行器（BatchExecutor），这里主要介绍第二种的方式</li>
<li>如何配置？有如下两种方式<ul>
<li>在全局配置文件的settings中配置一个属性<code>defaultExecutorType =BATCH</code>即可，不过这种方式将会导致所有的sql操作都会使用批量操作。</li>
<li>我们可以在获取SqlSession的时候指定执行类型，如下：<ul>
<li><code>SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH);</code>，此时当前的SqlSession执行的就是批量操作。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Mybaits-Spring执行批量处理"><a href="#Mybaits-Spring执行批量处理" class="headerlink" title="Mybaits-Spring执行批量处理"></a>Mybaits-Spring执行批量处理</h2><ul>
<li>Spring执行批量处理很简单，只需要在ioc容器中注入一个<code>SqlSessionTemplate</code>，并且设置批量处理的属性即可，如下：<ul>
<li>这种改变是全局的，慎用</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * 注入SqlSessionTemplate，替代SqlSessionFactory直接创建SqlSession，并且能够使用Spring的事务管理</div><div class="line">     * 如果需要使用批量处理，在构造方法中指定ExecutorType.BATCH即可，那么全部的操作的都会使用</div><div class="line">     * 【可以不配置，需要的时候使用】</div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">sqlSessionTemplate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        SqlSessionTemplate sqlSessionTemplate = <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory().getObject(),ExecutorType.BATCH);</div><div class="line">        <span class="keyword">return</span> sqlSessionTemplate;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="类型处理器（TypeHandler）"><a href="#类型处理器（TypeHandler）" class="headerlink" title="类型处理器（TypeHandler）"></a>类型处理器（TypeHandler）</h1><ul>
<li>用于处理Java类型和JDBC类型之前的映射关系，mybaits中内置了许多的类型处理器，一般我们在使用<code>#{}</code>中的jdbcType属性的时候，mybaits框架会为我们设置相应的处理器，比如jdbcType=DATE，那么mybatis默认对应的处理器就是<code>DateOnlyTypeHandler</code>（只有年月日），如果我们设置了jdbcType=TIMESTAMP，那么mybatis对Date类型的类型处理器就是<code>DateTypeHandler</code>，关于类型处理器和jdbcType的对应关系，看<a href="http://www.mybatis.org/mybatis-3/zh/configuration.html#typeHandlers" target="_blank" rel="external">官方文档中typeHandler这一节</a></li>
<li>内置处理器执行的时间：<ul>
<li>在StatementHandler创建Statement之后，会调用ParameterHandler设置参数，其中执行了类型处理器的setParametes的方法，设置对应的参数</li>
<li>在DefaultResultsetHandler处理执行结果的时候，会调用的TypeHandler中的<code>getResult</code>方法获取结果集</li>
</ul>
</li>
<li>TypeHandler中的方法如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 为预编译语句设置参数的时候执行，实际就是调用setxxx方法设置参数</div><div class="line">   * <span class="doctag">@param</span> ps PreparedStatement 对象</div><div class="line">   * <span class="doctag">@param</span> i</div><div class="line">   * <span class="doctag">@param</span> parameter 参数</div><div class="line">   * <span class="doctag">@param</span> jdbcType #&#123;&#125;中自定义的jdbcType</div><div class="line">   * <span class="doctag">@throws</span> SQLException</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, T parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException</span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 根据列名获取指定的值</div><div class="line">   * <span class="doctag">@param</span> rs ResultSet结果集</div><div class="line">   * <span class="doctag">@param</span> columnName 列名</div><div class="line">   * <span class="doctag">@return</span></div><div class="line">   * <span class="doctag">@throws</span> SQLException</div><div class="line">   */</div><div class="line">  <span class="function">T <span class="title">getResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException</span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 根据下标获取指定列的值</div><div class="line">   * <span class="doctag">@param</span> rs ResultSet结果集</div><div class="line">   * <span class="doctag">@param</span> columnIndex  下标</div><div class="line">   * <span class="doctag">@return</span></div><div class="line">   * <span class="doctag">@throws</span> SQLException</div><div class="line">   */</div><div class="line">  <span class="function">T <span class="title">getResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 调用存储过程的获取返回值的时候</div><div class="line">   * <span class="doctag">@param</span> cs</div><div class="line">   * <span class="doctag">@param</span> columnIndex</div><div class="line">   * <span class="doctag">@return</span></div><div class="line">   * <span class="doctag">@throws</span> SQLException</div><div class="line">   */</div><div class="line">  <span class="function">T <span class="title">getResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>虽然mybatis中内置了许多的类型处理器，但是我们也可以自定义类型处理器，并且作用到指定需要处理的类型中，自定义的方式有两种，如下：<ul>
<li>实现<code>TypeHandler</code>接口</li>
<li>继承<code>BaseTypeHandler</code>【推荐】</li>
</ul>
</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul>
<li>实例：我们需要将一个<code>List&lt;Auth&gt;</code>对象存入数据库的时候是以json字符串的形式，获取的是以List集合的形式，此时我们可以自定义一个TypeHandler，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义类型转换器，将List&lt;Auth&gt;数据存入数据库的时候是以json字符串存入的，获取返回的结果的时候是List集合</div><div class="line"> * <span class="doctag">@MappedJdbcTypes</span>(value = &#123;JdbcType.VARCHAR&#125;)：指定了映射的jdbcType的类型是VARCHAR</div><div class="line"> * <span class="doctag">@MappedTypes</span>(value = &#123;Auth.class&#125;)：指定了映射的java类型是Auth</div><div class="line"> */</div><div class="line"><span class="meta">@MappedJdbcTypes</span>(value = &#123;JdbcType.VARCHAR&#125;)</div><div class="line"><span class="meta">@MappedTypes</span>(value = &#123;Auth.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthTypeHandler</span> <span class="keyword">extends</span> <span class="title">BaseTypeHandler</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 将参数转换为json数据存入数据库</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, Object parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        String json = <span class="keyword">new</span> Gson().toJson(parameter);</div><div class="line">        ps.setString(i,json);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        String string = rs.getString(columnName);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Gson().fromJson(string,<span class="keyword">new</span> TypeToken&lt;List&lt;Auth&gt;&gt;()&#123;&#125;.getType());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getNullableResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        String string = rs.getString(columnIndex);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Gson().fromJson(string,<span class="keyword">new</span> TypeToken&lt;List&lt;Auth&gt;&gt;()&#123;&#125;.getType());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getNullableResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>需要在全局配置文件中设置TypeHandler的包扫描，如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--设置自动扫描包下的typeHandler--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"cn.tedu.typehandler"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>此时的类型处理器还是不起作用的，需要在insert、update的#{}中设置一下typehandler属性，如下：<ul>
<li>#{}中有一个typeHandler属性，指定自定义的TypeHandler即可</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertAdmin"</span> <span class="attr">parameterType</span>=<span class="string">"cn.tedu.domain.Admin"</span>&gt;</span></div><div class="line">        insert into t_admin(name,birthday,account,password,point,status,auths)</div><div class="line">         values (#&#123;name,jdbcType=VARCHAR&#125;,#&#123;birthday,jdbcType=DATE&#125;,</div><div class="line">         #&#123;account,jdbcType=VARCHAR&#125;,#&#123;password,jdbcType=VARCHAR&#125;,</div><div class="line">         #&#123;point,jdbcType=DOUBLE&#125;,#&#123;status,jdbcType=VARCHAR&#125;,#&#123;auths,jdbcType=VARCHAR,typeHandler=cn.tedu.typehandler.AuthTypeHandler&#125;)</div><div class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>对select语句设置类型处理器，只能在resultMap中设置，如下：<ul>
<li>在result中需要设置javaType，jdbcType，typeHandler三个属性，这里的auths就是需要映射的<code>List&lt;AUth&gt;</code></li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"cn.tedu.domain.Admin"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span> /&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"auths"</span> <span class="attr">property</span>=<span class="string">"auths"</span> <span class="attr">javaType</span>=<span class="string">"cn.tedu.domain.Auth"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">typeHandler</span>=<span class="string">"cn.tedu.typehandler.AuthTypeHandler"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></div><div class="line"></div><div class="line">   <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="枚举类型处理器"><a href="#枚举类型处理器" class="headerlink" title="枚举类型处理器"></a>枚举类型处理器</h2><ul>
<li>枚举的类型处理器默认是<code>EnumTypeHandler</code>，存入和取出都是存储的枚举的名称，也有一个<code>EnumOrdinalTypeHandler</code>是按照枚举的索引存储和查询的。</li>
<li>我们也可以自定义类型处理器来处理枚举类型。</li>
</ul>
<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><ul>
<li>插件的设计其实就是一个拦截器，在目标方法执行之前进行拦截，当然这里只是针对Mybatis中的四大对象进行拦截，四大对象如下：<ul>
<li><strong>Executor</strong></li>
<li><strong>StatementHandler</strong></li>
<li><strong>ParameterHandler</strong></li>
<li><strong>ResultSetHandler</strong></li>
</ul>
</li>
<li>Interceptor能够做到对四大对象中的每一个方法进行拦截</li>
<li>实现一个插件很简单，只需要实现<code>org.apache.ibatis.plugin.Interceptor</code>接口即可</li>
<li>对应Interceptor这个接口的方法解释如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 拦截器真正执行的方法，其中的invocation.proceed()是用来执行目标方法的，只有执行了这个proceed方法，目标方法才会执行，否则不执行</div><div class="line">   * <span class="doctag">@param</span> invocation</div><div class="line">   * <span class="doctag">@return</span> 返回目标方法执行的结果，return invocation.proceed();</div><div class="line">   * <span class="doctag">@throws</span> Throwable</div><div class="line">   */</div><div class="line">  <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 四大对象生成代理对象的方法，在四大对象创建的时候，都会调用一个pluginAll方法返回一个代理对象</div><div class="line">   * 这个方法不需要做修改，默认就行了</div><div class="line">   * <span class="doctag">@param</span> target 目标对象</div><div class="line">   * <span class="doctag">@return</span> 返回的代理对象（层层包装，表示只有一层）</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">default</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 在全局配置文件中&lt;plugin&gt;标签中设置properties属性，会封装在此方法的properties中</div><div class="line">   * <span class="doctag">@param</span> properties</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</div><div class="line">    <span class="comment">// NOP</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="实现一个简单的插件"><a href="#实现一个简单的插件" class="headerlink" title="实现一个简单的插件"></a>实现一个简单的插件</h2><ul>
<li>自定义一个插件，修改指定查询语句的入参。如下：<ul>
<li>实现原理其实很简单，因为mybaits的增删改查标签所有的信息都封装在MappedStatement中，我们只需要获取这个对象，然后通过属性判断即可。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Intercepts</span>注解标记这是一个拦截器,其中可以指定多个<span class="doctag">@Signature</span></div><div class="line"> * <span class="doctag">@Signature</span>：指定该拦截器拦截的是四大对象中的哪个方法</div><div class="line"> *      type：拦截器的四大对象的类型</div><div class="line"> *      method：拦截器的方法，方法名</div><div class="line"> *      args：入参的类型</div><div class="line"> */</div><div class="line"><span class="meta">@Intercepts</span>(</div><div class="line">        &#123;</div><div class="line">                <span class="meta">@Signature</span>(type = ParameterHandler.class,method =<span class="string">"setParameters"</span>,args = &#123;PreparedStatement.class&#125;)</div><div class="line">        &#125;</div><div class="line">)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstPlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        System.out.println(<span class="string">"拦截器执行："</span>+invocation.getTarget());</div><div class="line">        <span class="comment">//目标对象</span></div><div class="line">        Object target = invocation.getTarget();</div><div class="line">        <span class="comment">//获取目标对象中所有属性的值，因为ParameterHandler使用的是DefaultParameterHandler，因此里面的所有的属性都封装在其中</span></div><div class="line">        MetaObject metaObject = SystemMetaObject.forObject(target);</div><div class="line">        <span class="comment">//使用xxx.xxx.xx的方式可以层层获取属性值，这里获取的是mappedStatement中的id值</span></div><div class="line">        String value = (String) metaObject.getValue(<span class="string">"mappedStatement.id"</span>);</div><div class="line">        <span class="comment">//如果是指定的查询方法</span></div><div class="line">        <span class="keyword">if</span> (<span class="string">"cn.tedu.mapper.AdminMapper.selectById"</span>.equals(value))&#123;</div><div class="line">            <span class="comment">//设置参数的值是2，即是设置id=2，因为这里只有一个参数，可以这么设置，如果有多个需要需要循环</span></div><div class="line">            metaObject.setValue(<span class="string">"parameterObject"</span>, <span class="number">2</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//执行目标方法</span></div><div class="line">        <span class="keyword">return</span> invocation.proceed();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//可以省略</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//可以省略</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</div><div class="line">        System.out.println(properties);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>全局文件中配置：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--配置插件，其中的property可以设置自己的属性，可以封装到setProperties中的properties中--&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"cn.tedu.plugin.FirstPlugin"</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"11"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="重要的方法"><a href="#重要的方法" class="headerlink" title="重要的方法"></a>重要的方法</h2><ul>
<li><code>SystemMetaObject.forObject(target)</code>：可以获取目标类中所有的属性的值</li>
<li><code>metaObject.getValue(&quot;mappedStatement.id&quot;)</code>：可以使用xxx.xxx层层的获取属性的值</li>
<li><code>metaObject.setValue(name, value)</code>：设置属性的值</li>
</ul>
<h2 id="多个插件的执行顺序"><a href="#多个插件的执行顺序" class="headerlink" title="多个插件的执行顺序"></a>多个插件的执行顺序</h2><ul>
<li><p><strong>全局配置文件中配置插件的顺序，决定插件的执行顺序，是相反的顺序。</strong></p>
</li>
<li><p>如果有多个插件作用在同一个对象的同一个方法上，那么插件的执行顺序是怎样的？我们知道四大对象在创建的时候会调用拦截器中的plugin方法创建代理对象，这种代理实层层包装的，那么在后面的插件创建的代理是包裹在最外层的，因此肯定是先执行最外层的拦截器方法。</p>
</li>
</ul>
<h1 id="Spring整合Mybatis"><a href="#Spring整合Mybatis" class="headerlink" title="Spring整合Mybatis"></a>Spring整合Mybatis</h1><ul>
<li><a href="http://www.mybatis.org/spring/zh/index.html" target="_blank" rel="external">官方文档</a></li>
<li>添加依赖：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>配置数据源、事务管理器、SqlSessionFactoryBean<ul>
<li>这里使用了<code>@MapperScan</code>注解自动扫描Mapper接口</li>
<li>在<code>SqlSessionFactoryBean</code>中的配置中设置xml文件的位置和全局配置文件中的位置</li>
<li><code>SqlSessionTemplate</code>的注入能够让我们很方便的获取一个SqlSession和Mapper，一旦注入之后，所有的获取Mapper的代理对象都会执行其中的getMapper方法获取，因此如果这里设置了批量处理，那么改变是全局的。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 配置类</div><div class="line"> * <span class="doctag">@MapperScan</span>：扫描所有的Mapper接口</div><div class="line"> */</div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"cn.tedu.ssm"</span>&#125;)</div><div class="line"><span class="meta">@MapperScan</span>(basePackages = &#123;<span class="string">"cn.tedu.ssm.mapper"</span>&#125;)</div><div class="line"><span class="meta">@EnableAspectJAutoProxy</span></div><div class="line"><span class="meta">@EnableAsync</span></div><div class="line"><span class="meta">@EnableTransactionManagement</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 注册数据源</div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> DruidDataSource <span class="title">dataSource</span><span class="params">()</span></span>&#123;</div><div class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</div><div class="line">        dataSource.setUrl(DataConfig.URL);</div><div class="line">        dataSource.setUsername(DataConfig.USER);</div><div class="line">        dataSource.setPassword(DataConfig.PWD);</div><div class="line">        dataSource.setDriverClassName(DataConfig.DRIVER_NAME);</div><div class="line">        <span class="keyword">return</span> dataSource;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 配置SqlSessionFactoryBean，实际就是SqlSessionFactory</div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactoryBean <span class="title">sqlSessionFactory</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</div><div class="line">        <span class="comment">//设置数据源</span></div><div class="line">        sqlSessionFactoryBean.setDataSource(dataSource());</div><div class="line">        <span class="comment">//配置扫描mapepr.xml文件</span></div><div class="line">        PathMatchingResourcePatternResolver classPathResource = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</div><div class="line">        sqlSessionFactoryBean.setMapperLocations(classPathResource.getResources(<span class="string">"classpath:mappers/*.xml"</span>));</div><div class="line">        <span class="comment">//设置全局配置文件的位置</span></div><div class="line">        sqlSessionFactoryBean.setConfigLocation(classPathResource.getResource(<span class="string">"classpath:mybatis-config.xml"</span>));</div><div class="line">        <span class="keyword">return</span> sqlSessionFactoryBean;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 注入SqlSessionTemplate，替代SqlSessionFactory直接创建SqlSession，并且能够使用Spring的事务管理</div><div class="line">     * 如果需要使用批量处理，在构造方法中指定ExecutorType.BATCH即可，那么全部的操作的都会使用</div><div class="line">     * 【可以不配置，需要的时候使用】</div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">sqlSessionTemplate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        SqlSessionTemplate sqlSessionTemplate = <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory().getObject());</div><div class="line">        <span class="keyword">return</span> sqlSessionTemplate;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建事务管理器</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>在和Spring整合的时候，原先全局配置中配置的数据源，事务管理器等都会被忽略，默认会加载Spring配置的事务管理器和数据源。</li>
<li>如果想要配置TypeHandler、Plugin、TypeAlias等设置，在SqlSessionFactoryBean中都是可以直接配置的，因此在和Spring整合之后，Mybaits的全局配置文件中需要配置的东西很少，几乎可以不用。</li>
</ul>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><ul>
<li>全注解版的SSM整合，包括下面分页插件的整合：<a href="https://github.com/chenjiabing666/ssm-demo" target="_blank" rel="external">https://github.com/chenjiabing666/ssm-demo</a></li>
</ul>
<h1 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h1><ul>
<li><a href="https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md" target="_blank" rel="external">官方文档https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md</a></li>
<li>使用环境：ssm环境下配置</li>
<li>添加依赖：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">      &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</div><div class="line">      &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;</div><div class="line">      &lt;version&gt;5.1.6&lt;/version&gt;</div><div class="line"> &lt;/dependency&gt;</div></pre></td></tr></table></figure>
<ul>
<li>配置拦截器，在和Spring整合下就只需要在SqlSessionFactoryBean中配置拦截器即可，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * 配置SqlSessionFactoryBean，实际就是SqlSessionFactory</div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactoryBean <span class="title">sqlSessionFactory</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</div><div class="line">        <span class="comment">//设置数据源</span></div><div class="line">        sqlSessionFactoryBean.setDataSource(dataSource());</div><div class="line">        <span class="comment">//配置扫描mapepr.xml文件</span></div><div class="line">        PathMatchingResourcePatternResolver classPathResource = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</div><div class="line">        sqlSessionFactoryBean.setMapperLocations(classPathResource.getResources(<span class="string">"classpath:mappers/*.xml"</span>));</div><div class="line">        <span class="comment">//设置全局配置文件的位置</span></div><div class="line">        sqlSessionFactoryBean.setConfigLocation(classPathResource.getResource(<span class="string">"classpath:mybatis-config.xml"</span>));</div><div class="line">        <span class="comment">//配置插件</span></div><div class="line">        PageInterceptor pageInterceptor = <span class="keyword">new</span> PageInterceptor();</div><div class="line">        <span class="comment">//可以配置PageHelper中的参数映射关系，这里使用默认的，不需配置</span></div><div class="line"><span class="comment">//        pageInterceptor.setProperties();</span></div><div class="line">        sqlSessionFactoryBean.setPlugins(pageInterceptor);</div><div class="line">        <span class="keyword">return</span> sqlSessionFactoryBean;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>官方文档中有多种使用方式，我们使用面向接口的方式，如下：<ul>
<li>只需要在doSelect中调用查询全部的sql即可</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</div><div class="line">       SqlSessionTemplate sqlSessionTemplate = applicationContext.getBean(SqlSessionTemplate.class);</div><div class="line">       <span class="keyword">final</span> PatientMapper mapper = sqlSessionTemplate.getMapper(PatientMapper.class);</div><div class="line">       PageInfo&lt;Object&gt; pageInfo = PageHelper.startPage(<span class="number">1</span>, <span class="number">10</span>).doSelectPageInfo(<span class="keyword">new</span> ISelect() &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSelect</span><span class="params">()</span> </span>&#123;</div><div class="line">               mapper.selectAllPatient();</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h2 id="自己整合工具类"><a href="#自己整合工具类" class="headerlink" title="自己整合工具类"></a>自己整合工具类</h2><ul>
<li>在实际使用过程中上述的方式有点繁琐，本人自己整合一个工具类，能够很轻松的完成分页。</li>
<li>定义一个ParamReq类，如果有需要的分页的请求都继承这个类，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonIgnore;</div><div class="line"><span class="keyword">import</span> lombok.Data;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 所有需要分页的请求要继承的类，其中提供了分页需要的参数</div><div class="line"> * 默认的映射关系是:pageNum=pageNum;pageSize=pageSize;count=countSql;reasonable=reasonable;pageSizeZero=pageSizeZero</div><div class="line"> * 也可在设置拦截器的时候指定映射关系，具体看官方文档</div><div class="line"> * https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md</div><div class="line"> */</div><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageParam</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 当前第几页</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Integer pageNum=<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 每页查询的数量</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Integer pageSize=<span class="number">10</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 是否进行count查询，默认是true，查询</div><div class="line">     * 如果设置为false，那么总数total将会为-1，不进行count查询</div><div class="line">     */</div><div class="line">    <span class="meta">@JsonIgnore</span></div><div class="line">    <span class="keyword">private</span> Boolean countSql=<span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 分页合理化参数，默认值为false。当该参数设置为 true 时，pageNum&lt;=0 时会查询第一页， pageNum&gt;pages（超过总数时），会查询最后一页。默认false 时，直接根据参数进行查询。</div><div class="line">     */</div><div class="line">    <span class="meta">@JsonIgnore</span></div><div class="line">    <span class="keyword">private</span> Boolean reasonable;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 默认值为 false，当该参数设置为 true 时，如果 pageSize=0 或者 RowBounds.limit = 0 就会查询出全部的结果（相当于没有执行分页查询，但是返回结果仍然是 Page 类型）。</div><div class="line">     */</div><div class="line">    <span class="meta">@JsonIgnore</span></div><div class="line">    <span class="keyword">private</span> Boolean pageSizeZero=<span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>自定义执行接口，其实就是覆盖上面的doSelect方法，实现自己的执行查询的方法，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 分页需要实现的接口，在doExecute中只需调用查询全部数据的mapper即可</div><div class="line"> */</div><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutePageHelper</span> <span class="keyword">extends</span> <span class="title">ISelect</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 实现类应该覆盖的方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doExecute</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">doSelect</span><span class="params">()</span> </span>&#123;</div><div class="line">        doExecute();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>分页工具类，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 执行分页插件的工具类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageHelperUtils</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行PageHelper分页的方法</div><div class="line">     * <span class="doctag">@param</span> req 请求对象，继承PageParam类</div><div class="line">     * <span class="doctag">@param</span> executePageHelper ExecutePageHelper的接口实现类</div><div class="line">     * <span class="doctag">@param</span> &lt;T&gt; 泛型，需要返回结果的类型</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;  <span class="function">PageInfo&lt;T&gt; <span class="title">execute</span><span class="params">(PageParam req,ExecutePageHelper executePageHelper)</span></span>&#123;</div><div class="line">        <span class="comment">//这里直接传入req，其实其中的值是有映射关系的，在PageParam中有讲到</span></div><div class="line">        <span class="keyword">return</span> PageHelper.startPage(req).doSelectPageInfo(executePageHelper);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>测试：<ul>
<li>使用lambda表示可以方便的执行分页查询</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</div><div class="line">       SqlSessionTemplate sqlSessionTemplate = applicationContext.getBean(SqlSessionTemplate.class);</div><div class="line">       PatientMapper mapper = sqlSessionTemplate.getMapper(PatientMapper.class);</div><div class="line">       <span class="comment">//分页的请求类，继承ParamReq</span></div><div class="line">       UserReq req=<span class="keyword">new</span> UserReq();</div><div class="line">       PageInfo&lt;Patient&gt; pageInfo = PageHelperUtils.execute(req, mapper::selectAllPatient);</div><div class="line">       System.out.println(pageInfo.getList());</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;按照官方文档搭建即可&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;typeAliases（别名）&quot;&gt;&lt;a href=&quot;
    
    </summary>
    
      <category term="MyBatis" scheme="http://chenjiabing666.github.io/categories/MyBatis/"/>
    
    
      <category term="MyBatis" scheme="http://chenjiabing666.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Springmvc源码解读</title>
    <link href="http://chenjiabing666.github.io/2019/07/31/Springmvc%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://chenjiabing666.github.io/2019/07/31/Springmvc源码解读/</id>
    <published>2019-07-31T06:45:44.000Z</published>
    <updated>2019-07-31T06:46:45.729Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实现Controller的方式"><a href="#实现Controller的方式" class="headerlink" title="实现Controller的方式"></a>实现Controller的方式</h1><ul>
<li>如何实现一个controller，在源码中其实将controller叫做handler，我们通常知道实现controller的方式就是在类上添加一个<code>@Controller</code>和<code>@RequestMapping</code>注解，但是还有其他的方式定义一个controller</li>
</ul>
<h2 id="实现Controller"><a href="#实现Controller" class="headerlink" title="实现Controller"></a>实现Controller</h2><ul>
<li>使用Bean中的id指定路径，必须是以<code>/</code>开头</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>(value = <span class="string">"/user/test.do"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"userController run....."</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="实现HttpRequestHandler"><a href="#实现HttpRequestHandler" class="headerlink" title="实现HttpRequestHandler"></a>实现HttpRequestHandler</h2><ul>
<li>要求同上</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>(value = <span class="string">"/prod/test.do"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductController</span> <span class="keyword">implements</span> <span class="title">HttpRequestHandler</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"prodController run ....."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h2><ul>
<li>经常使用，不再细说</li>
</ul>
<h1 id="EnableWebMvc"><a href="#EnableWebMvc" class="headerlink" title="@EnableWebMvc"></a>@EnableWebMvc</h1><ul>
<li>该注解使Spring MVC 开启高级功能的入口，主要的作用就是加载了一个配置类<code>DelegatingWebMvcConfiguration</code>，其中创建了MVC默认的一些组件，比如<code>viewControllerHandlerMapping</code>、<code>RequestMappingHandlerMapping</code>、<code>BeanNameUrlHandlerMapping</code>、<code>RequestMappingHandlerAdapter</code> 等等。</li>
</ul>
<h1 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h1><ul>
<li>一个用于分发请求的Servlet，一个请求进来之后，Servlet会根据HandlerMapping将请求转发给对应的Handler（controller）处理。</li>
<li>其中重要的方法如下：<ul>
<li><code>protected void doDispatch(HttpServletRequest request, HttpServletResponse response)</code>：执行分发的流程</li>
<li><code>protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)</code>：渲染视图</li>
</ul>
</li>
</ul>
<h1 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h1><ul>
<li>顾名思义，就是保存Handler和Mapping之间的对应的关系，当然这种关系是多种的，有<strong>uri to beanName</strong>，有<strong>uri to HandlerMethod</strong>，不同的对应关系有不同的实现类处理，因此就衍生了后续的三种实现类。</li>
</ul>
<h2 id="BeanNameUrlHandlerMapping"><a href="#BeanNameUrlHandlerMapping" class="headerlink" title="BeanNameUrlHandlerMapping"></a>BeanNameUrlHandlerMapping</h2><ul>
<li>见名思意，这种肯定是uri to beanName的实现，用于存储实现了<code>Controller</code>和<code>HttpRequestHandler</code>接口的Handler的映射关系</li>
</ul>
<h2 id="SimpleUrlHandlerMapping"><a href="#SimpleUrlHandlerMapping" class="headerlink" title="SimpleUrlHandlerMapping"></a>SimpleUrlHandlerMapping</h2><ul>
<li>这种也是uri to Handler的实现，不过这种用于存储<code>View-controller</code>、<code>ResourceHttpRequestHandler</code>的映射关系</li>
</ul>
<h2 id="RequestMappingHandlerMapping"><a href="#RequestMappingHandlerMapping" class="headerlink" title="RequestMappingHandlerMapping"></a>RequestMappingHandlerMapping</h2><ul>
<li>这种用于实现uri to HandlerMethod的关系，从名称可以看出，这种是用于使用<code>@RequestMapping</code>注解的</li>
</ul>
<h1 id="HandlerExecutionChain"><a href="#HandlerExecutionChain" class="headerlink" title="HandlerExecutionChain"></a>HandlerExecutionChain</h1><ul>
<li>处理器执行链，其中存储了Handler和拦截器</li>
</ul>
<h1 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h1><ul>
<li>简单的说就是执行的Handler的适配类，定义了三个方法，如下：<ul>
<li><code>boolean supports(Object handler);</code>：判断当前的HandlerAdapter是否支持这个Handler</li>
<li><code>ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;</code>：执行Handler的方法</li>
<li><code>long getLastModified(HttpServletRequest request, Object handler);</code>：获取请求都中的<code>LastModified</code></li>
</ul>
</li>
</ul>
<ul>
<li>该接口有多个实现类，如下：<ul>
<li><code>RequestMappingHandlerAdapter</code>：匹配HandlerMethod</li>
<li><code>HttpRequestHandlerAdapter</code>：匹配实现了<code>HttpRequestHandler</code>接口的Handler</li>
<li><code>SimpleControllerHandlerAdapter</code>：匹配实现了Controller接口的Handler</li>
</ul>
</li>
</ul>
<h1 id="执行流程分析"><a href="#执行流程分析" class="headerlink" title="执行流程分析"></a>执行流程分析</h1><p><img src="https://raw.githubusercontent.com/chenjiabing666/BlogImage/master/springMVC%20-proceed.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;实现Controller的方式&quot;&gt;&lt;a href=&quot;#实现Controller的方式&quot; class=&quot;headerlink&quot; title=&quot;实现Controller的方式&quot;&gt;&lt;/a&gt;实现Controller的方式&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;如何实现一个contro
    
    </summary>
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Springmvc注解版开发</title>
    <link href="http://chenjiabing666.github.io/2019/07/31/Springmvc%E6%B3%A8%E8%A7%A3%E7%89%88%E5%BC%80%E5%8F%91/"/>
    <id>http://chenjiabing666.github.io/2019/07/31/Springmvc注解版开发/</id>
    <published>2019-07-31T06:45:22.000Z</published>
    <updated>2019-07-31T06:47:07.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h1><h2 id="搭建原理"><a href="#搭建原理" class="headerlink" title="搭建原理"></a>搭建原理</h2><p><img src="https://docs.spring.io/spring/docs/5.1.8.RELEASE/spring-framework-reference/images/mvc-context-hierarchy.png" alt=""></p>
<h2 id="springMVC版本"><a href="#springMVC版本" class="headerlink" title="springMVC版本"></a>springMVC版本</h2><ul>
<li>此次使用的版本是Spring 5.1.8</li>
</ul>
<h2 id="配置内嵌tomcat"><a href="#配置内嵌tomcat" class="headerlink" title="配置内嵌tomcat"></a>配置内嵌tomcat</h2><ul>
<li>为了简化开发，使用tomcat插件实现web项目的运行，只需要在pom.xml中配置一个插件即可，如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">uriEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">uriEncoding</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>之后在IDEA右侧的maven处可以看见tomcat7这个插件了，点击run即可运行</li>
</ul>
<h2 id="配置DispatcherServlet初始化器"><a href="#配置DispatcherServlet初始化器" class="headerlink" title="配置DispatcherServlet初始化器"></a>配置DispatcherServlet初始化器</h2><ul>
<li>配置的方式有多种，但是根据Spring文档推荐的方式如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cn.tedu.demo.config.AppConfig;</div><div class="line"><span class="keyword">import</span> cn.tedu.demo.config.WebMvcConfig;</div><div class="line"><span class="keyword">import</span> org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 配置DispatcherServlet初始化器，在容器启动的时候会加载初始化</div><div class="line"> * 入口就是/org/springframework/spring-web/5.1.8.RELEASE/spring-web-5.1.8.RELEASE.jar!/META-INF/services/javax.servlet.ServletContainerInitializer</div><div class="line"> * web容器在启动的时候会加载META-INF/service下的文件</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrartWebApplicationInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 配置主配置类，主配置类的作用就是配置业务所需要的各种Bean，比如dao，service</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class[]&#123;AppConfig.class&#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 配置MVC所需的配置类，该配置类的作用就是扫描controller，配置mvc的各种组件，比如视图解析器，拦截器等</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class[]&#123;WebMvcConfig.class&#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 配置servletMapping，相当于在DispatcherServlet中配置的url</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">"/"</span>&#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="主配置文件"><a href="#主配置文件" class="headerlink" title="主配置文件"></a>主配置文件</h2><ul>
<li>主配置文件主要的作用就是配置业务需求的Bean，比如dao，service层的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.FilterType;</div><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 业务逻辑的配置类，扫描所有的业务Bean，比如dao，service，排除所有的controller</div><div class="line"> */</div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"cn.tedu.demo"</span>&#125;,excludeFilters = &#123;<span class="meta">@ComponentScan</span>.Filter(type = FilterType.ANNOTATION,classes = &#123;Controller.class&#125;)&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="MVC配置类"><a href="#MVC配置类" class="headerlink" title="MVC配置类"></a>MVC配置类</h2><ul>
<li>MVC配置类主要的作用就是扫描Controller，配置各种组件，比如视图解析器，拦截器等等</li>
<li>重要的两点如下：<ul>
<li>使用<code>@EnableWebMvc</code>注解开启MVC功能，相当于xml文件中的<code>&lt;mvc:annotation-driven/&gt;</code></li>
<li>配置类需要实现<code>WebMvcConfigurer</code>，该接口下有各种方法，开发者可以实现其中的方法完成相关组件的生成</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cn.tedu.demo.interceptor.CustomInterceptor;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.FilterType;</div><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</div><div class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.*;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * MVC的配置类，扫描所有的controller，排除所有的业务类</div><div class="line"> * <span class="doctag">@EnableWebMvc</span> 注解开启mvc功能</div><div class="line"> * <span class="doctag">@ComponentScan</span> 注解中的属性useDefaultFilters（默认是true，扫描全部的Bean），这里我们定义了只扫描controller，因此要设置该属性为false，否则不起作用，排除Bean则不需要</div><div class="line"> */</div><div class="line"><span class="meta">@EnableWebMvc</span></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"cn.tedu.demo"</span>&#125;,includeFilters = &#123;<span class="meta">@ComponentScan</span>.Filter(type = FilterType.ANNOTATION,classes = &#123;Controller.class&#125;)&#125;,useDefaultFilters = <span class="keyword">false</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a>配置拦截器</h1><ul>
<li>自定义一个拦截器，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义一个拦截器，实现HandlerInterceptor</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 在拦截器方法之前执行</div><div class="line">     * <span class="doctag">@param</span> request request</div><div class="line">     * <span class="doctag">@param</span> response response</div><div class="line">     * <span class="doctag">@param</span> handler 拦截的handler</div><div class="line">     * <span class="doctag">@return</span> 如果返回false，后续的拦截器和拦截的handler不执行</div><div class="line">     * <span class="doctag">@throws</span> Exception</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"在之前执行"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在配置类设置自定义的拦截器，使得起作用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</div><div class="line">       <span class="comment">//创建</span></div><div class="line">       CustomInterceptor customInterceptor = <span class="keyword">new</span> CustomInterceptor();</div><div class="line">       <span class="comment">//添加自定义的拦截器</span></div><div class="line">       registry.addInterceptor(customInterceptor).addPathPatterns(<span class="string">"/**"</span>);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li>自定义的拦截器的真实实现类其实是<code>MappedInterceptor</code>，在源码中获取处理器执行链的时候会将其添加到执行链中。</li>
</ul>
<h1 id="配置过滤器"><a href="#配置过滤器" class="headerlink" title="配置过滤器"></a>配置过滤器</h1><ul>
<li>过滤器不属于SpringMVC，而是属于Servlet中的组件，因此配置过滤器使用的并不是MVC的配置，但是在Servlet3.0中也是提供了注解版的Servlet和Filter的生成方式，我们使用注解生成一个Filter，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义过滤器</div><div class="line"> */</div><div class="line"><span class="meta">@WebFilter</span>(filterName = <span class="string">"customFilter"</span>,urlPatterns = <span class="string">"/*"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"过滤器初始化"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"过滤器执行"</span>);</div><div class="line">        chain.doFilter(request,response);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"过滤器销毁"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="配置视图解析器"><a href="#配置视图解析器" class="headerlink" title="配置视图解析器"></a>配置视图解析器</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> </span>&#123;</div><div class="line">       registry.jsp(<span class="string">"/WEB_INF/"</span>,<span class="string">".jsp"</span>);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h1 id="配置ViewController"><a href="#配置ViewController" class="headerlink" title="配置ViewController"></a>配置ViewController</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</div><div class="line">        <span class="comment">//定义一个controller，访问路径是/index.do，跳转的视图是index.jsp</span></div><div class="line">        registry.addViewController(<span class="string">"/index.do"</span>).setViewName(<span class="string">"index"</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="配置MessageConverters"><a href="#配置MessageConverters" class="headerlink" title="配置MessageConverters"></a>配置MessageConverters</h1><ul>
<li>消息转换器用于对Request和Response的消息进行处理，比如将Response中的消息转换为指定JSON字符串的形式</li>
<li>默认的消息转换器对于日期的类型的转换是时间戳，即是返回的JSON字符串的日期类型是时间戳，接收的日期类型参数也只能是时间戳</li>
<li>如何配置消息转换器，只需要重写springmvc配置类中的方法即可。</li>
<li>我们使用的是<code>MappingJackson2HttpMessageConverter</code>这类转换器，但是其中依赖的是ObjectMapper，因此我们比如引入依赖，如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>在上述的MVC配置类中重写如下方法：<ul>
<li>设置日期的格式化格式是yyyy-MM-dd，此时返回和接收的格式就是<code>yyyy-MM-dd</code></li>
<li>在配置类中配置的消息转换器属于<strong>全局配置</strong>，所有的消息都会遵循这种配置。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</div><div class="line">       Jackson2ObjectMapperBuilder builder = <span class="keyword">new</span> Jackson2ObjectMapperBuilder()</div><div class="line">               .indentOutput(<span class="keyword">true</span>)</div><div class="line">               <span class="comment">//指定格式化的日期，这里只是举例，不建议在此处全局配置</span></div><div class="line">               .dateFormat(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>))</div><div class="line">               <span class="comment">//设置时区，默认是UTC，需要修改成北京时间</span></div><div class="line">               .timeZone(<span class="string">"GMT+8"</span>);</div><div class="line">       converters.add(<span class="keyword">new</span> MappingJackson2HttpMessageConverter(builder.build()));</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h2 id="注解版"><a href="#注解版" class="headerlink" title="注解版"></a>注解版</h2><ul>
<li>在实际的项目中这种方式太鸡肋，实际的需求有实际的变化，因此我们最好能够寻找一种灵活的处理方式，类似注解的方式。</li>
<li>在<code>jackson-databind</code>中提供了许多的注解，可以供我们使用，<strong>可以覆盖全局配置，和全局配置形成一种互补的作用</strong>。</li>
<li><code>@JsonFormat</code>：日期格式化注解，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//timeZone如果在全局配置过，可以不写	</span></div><div class="line"><span class="meta">@JsonFormat</span>(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>,timezone = <span class="string">"GMT+8"</span>)</div><div class="line">    <span class="keyword">private</span> Date birthDay;</div></pre></td></tr></table></figure>
<ul>
<li><code>@JsonIgnore</code>：在返回的JSON字符串中不显示</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@JsonIgnore</span></div><div class="line">   <span class="keyword">private</span> String name;</div></pre></td></tr></table></figure>
<ul>
<li>其他的注解请参考<a href="https://blog.51cto.com/7308310/2310930?source=dra" target="_blank" rel="external">https://blog.51cto.com/7308310/2310930?source=dra</a></li>
</ul>
<h1 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a>异常处理器</h1><ul>
<li>springMvc处理异常有三种方式，分别为：<ul>
<li><code>ExceptionHandlerExceptionResolver</code>：通过调用或 类中的<code>@ExceptionHandler</code>方法来解决异常，可以结合<code>@ControllerAdvice</code></li>
<li><code>DefaultHandlerExceptionResolver</code>：对一些特殊的异常进行处理</li>
<li><code>ResponseStatusExceptionResolver</code>：使用<code>@ResponseStatus</code>解析异常，并根据注解中的值将它们映射到HTTP状态代码 </li>
<li><code>SimpleMappingExceptionResolver</code>：异常和视图的映射，可以自定义指定的异常对应的视图</li>
</ul>
</li>
<li><strong>原理：主要的解析逻辑都是在<code>doResolveException</code>方法中完成的。</strong></li>
</ul>
<h2 id="异常处理器执行的顺序"><a href="#异常处理器执行的顺序" class="headerlink" title="异常处理器执行的顺序"></a>异常处理器执行的顺序</h2><ul>
<li>异常处理器的执行是有顺序的，优先级高的执行完之后，如果有对应的处理，那么后续的就不再执行。</li>
<li>异常处理器的执行顺序如下：<ul>
<li><code>ExceptionHandlerExceptionResolver</code></li>
<li><code>DefaultHandlerExceptionResolver</code></li>
<li><code>ResponseStatusExceptionResolver</code></li>
<li><code>SimpleMappingExceptionResolver</code></li>
</ul>
</li>
<li>四种异常处理器的顺序执行可以形成一种互补的配置。</li>
</ul>
<h2 id="SimpleMappingExceptionResolver"><a href="#SimpleMappingExceptionResolver" class="headerlink" title="SimpleMappingExceptionResolver"></a>SimpleMappingExceptionResolver</h2><ul>
<li>在配置中配置即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> SimpleMappingExceptionResolver <span class="title">simpleMappingExceptionResolver</span><span class="params">()</span></span>&#123;</div><div class="line">        SimpleMappingExceptionResolver resolver = <span class="keyword">new</span> SimpleMappingExceptionResolver();</div><div class="line">        <span class="comment">//设置默认的视图，如果有的异常没有指定处理，那么使用默认的视图</span></div><div class="line">        resolver.setDefaultErrorView(<span class="string">"index"</span>);</div><div class="line">        <span class="comment">//设置排除的异常</span></div><div class="line"><span class="comment">//        resolver.setExcludedExceptions();</span></div><div class="line">        <span class="comment">//指定异常视图映射</span></div><div class="line">        Properties properties=<span class="keyword">new</span> Properties();</div><div class="line">        properties.put(RuntimeException.class.getName(),<span class="string">"error"</span>);</div><div class="line">        resolver.setExceptionMappings(properties);</div><div class="line">        <span class="keyword">return</span> resolver;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="DefaultHandlerExceptionResolver"><a href="#DefaultHandlerExceptionResolver" class="headerlink" title="DefaultHandlerExceptionResolver"></a>DefaultHandlerExceptionResolver</h2><ul>
<li>此类异常解析器只能针对一些特殊的异常进行处理，如下：</li>
</ul>
<table>
<thead>
<tr>
<th>Exception</th>
<th>HTTP Status Code</th>
</tr>
</thead>
<tbody>
<tr>
<td>HttpRequestMethodNotSupportedException</td>
<td>405 (SC_METHOD_NOT_ALLOWED)</td>
</tr>
<tr>
<td>HttpMediaTypeNotSupportedException</td>
<td>415 (SC_UNSUPPORTED_MEDIA_TYPE)</td>
</tr>
<tr>
<td>HttpMediaTypeNotAcceptableException</td>
<td>406 (SC_NOT_ACCEPTABLE)</td>
</tr>
<tr>
<td>MissingPathVariableException</td>
<td>500 (SC_INTERNAL_SERVER_ERROR)</td>
</tr>
<tr>
<td>MissingServletRequestParameterException</td>
<td>400 (SC_BAD_REQUEST)</td>
</tr>
<tr>
<td>ServletRequestBindingException</td>
<td>400 (SC_BAD_REQUEST)</td>
</tr>
<tr>
<td>ConversionNotSupportedException</td>
<td>500 (SC_INTERNAL_SERVER_ERROR)</td>
</tr>
<tr>
<td>TypeMismatchException</td>
<td>400 (SC_BAD_REQUEST)</td>
</tr>
<tr>
<td>HttpMessageNotReadableException</td>
<td>400 (SC_BAD_REQUEST)</td>
</tr>
<tr>
<td>HttpMessageNotWritableException</td>
<td>500 (SC_INTERNAL_SERVER_ERROR)</td>
</tr>
<tr>
<td>MethodArgumentNotValidException</td>
<td>400 (SC_BAD_REQUEST)</td>
</tr>
<tr>
<td>MissingServletRequestPartException</td>
<td>400 (SC_BAD_REQUEST)</td>
</tr>
<tr>
<td>BindException</td>
<td>400 (SC_BAD_REQUEST)</td>
</tr>
<tr>
<td>NoHandlerFoundException</td>
<td>404 (SC_NOT_FOUND)</td>
</tr>
<tr>
<td>AsyncRequestTimeoutException</td>
<td>503 (SC_SERVICE_UNAVAILABLE)</td>
</tr>
</tbody>
</table>
<ul>
<li>不需要声明，默认存在</li>
</ul>
<h2 id="ResponseStatusExceptionResolver"><a href="#ResponseStatusExceptionResolver" class="headerlink" title="ResponseStatusExceptionResolver"></a>ResponseStatusExceptionResolver</h2><ul>
<li>在自定义的异常类上标注<code>@ResponseStatus</code>注解，当抛出此种异常的时候，将会响应定义的状态码和提示语</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ResponseStatus</span>(code = HttpStatus.FORBIDDEN,reason = <span class="string">"没有权限"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomException</span> <span class="keyword">extends</span>  <span class="title">RuntimeException</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ExceptionHandlerExceptionResolver"><a href="#ExceptionHandlerExceptionResolver" class="headerlink" title="ExceptionHandlerExceptionResolver"></a>ExceptionHandlerExceptionResolver</h2><ul>
<li>集合<code>@ControllerAdvice</code>和<code>@RestControllerAdvice</code>使用</li>
<li>方法中能够自动赋值的参数和返回值的类型都在Spring文档上有详细的记载，参考<code>https://docs.spring.io/spring/docs/5.1.8.RELEASE/spring-framework-reference/web.html#mvc-ann-exceptionhandler-args</code></li>
<li>详细的使用如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ControllerAdvice</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *</div><div class="line">     *处理FileNotFoundException，返回JSOn数据</div><div class="line">     */</div><div class="line">    <span class="meta">@ExceptionHandler</span>(value = ArrayIndexOutOfBoundsException.class)</div><div class="line">    <span class="meta">@ResponseBody</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handleFileNotFoundException</span><span class="params">(Exception ex, HttpServletRequest request, HandlerMethod method)</span></span>&#123;</div><div class="line">        System.out.println(request.getRequestURI());</div><div class="line">        System.out.println(method);</div><div class="line">        System.out.println(ex);</div><div class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@ExceptionHandler</span>(value = Exception.class)</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handleException</span><span class="params">(Exception ex, HttpServletRequest request, HandlerMethod method)</span></span>&#123;</div><div class="line">        System.out.println(request.getRequestURI());</div><div class="line">        System.out.println(method);</div><div class="line">        System.out.println(ex);</div><div class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="配置跨域请求"><a href="#配置跨域请求" class="headerlink" title="配置跨域请求"></a>配置跨域请求</h1><h2 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h2><ul>
<li>使用注解<code>@CrossOrigin</code>，可以标注在Controller上，也可以标注在方法上，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CrossOrigin</span></div><div class="line">   <span class="meta">@PostMapping</span>(<span class="string">"/getObj"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(@RequestBody AdminReq req)</span></span>&#123;</div><div class="line">       System.out.println(req);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Admin(<span class="string">"陈加兵"</span>,<span class="number">22</span>,<span class="keyword">new</span> Date(),<span class="keyword">new</span> Date());</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li>该注解中可以配置各种属性，这里不再细讲，在下面的全局配置中会涉及到。</li>
</ul>
<h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><ul>
<li>全局配置就是在MVC的配置文件中重写方法即可，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</div><div class="line">       registry.addMapping(<span class="string">"/api/**"</span>)</div><div class="line">               <span class="comment">//允许的源</span></div><div class="line">               .allowedOrigins(<span class="string">"https://domain2.com"</span>)</div><div class="line">               <span class="comment">//允许请求跨域的请求类型</span></div><div class="line">               .allowedMethods(<span class="string">"PUT"</span>, <span class="string">"DELETE"</span>)</div><div class="line">               <span class="comment">//允许的请求头</span></div><div class="line">               .allowedHeaders(<span class="string">"header1"</span>, <span class="string">"header2"</span>, <span class="string">"header3"</span>)</div><div class="line">               <span class="comment">//暴露的请求头</span></div><div class="line">               .exposedHeaders(<span class="string">"header1"</span>, <span class="string">"header2"</span>)</div><div class="line">               <span class="comment">//允许携带cookie等用户信息，这样才能实现登录</span></div><div class="line">               .allowCredentials(<span class="keyword">true</span>).maxAge(<span class="number">3600</span>);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h1 id="配置静态资源解析"><a href="#配置静态资源解析" class="headerlink" title="配置静态资源解析"></a>配置静态资源解析</h1><ul>
<li>springmvc中的DispatcherServlet如果设置了拦截的请求是<code>/</code>，那么也会拦截静态资源，但是我们可以在配置文件中配置，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</div><div class="line">       <span class="comment">//拦截的请求</span></div><div class="line">       registry.addResourceHandler(<span class="string">"/resources/**"</span>)</div><div class="line">               <span class="comment">//资源的位置</span></div><div class="line">               .addResourceLocations(<span class="string">"/public"</span>, <span class="string">"classpath:/static/"</span>)</div><div class="line">               <span class="comment">//缓存的时间，单位秒</span></div><div class="line">               .setCachePeriod(<span class="number">31556926</span>);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li>该配置会在ioc中注册一个<code>ResourceHttpRequestHandler</code>，封装在<strong>SimpleUrlHandlermapping</strong>中。</li>
</ul>
<h1 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h1><ul>
<li><code>@EnableMvc</code>注解其实就是注入了一个配置类<code>DelegatingWebMvcConfiguration</code>，那么我们可以将自定义的配置类实现该类即可完成MVC的高级功能，此时就不需要使用该注解了，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"cn.tedu.demo"</span>&#125;,includeFilters = &#123;<span class="meta">@ComponentScan</span>.Filter(type = FilterType.ANNOTATION,classes = &#123;Controller.class, Component.class&#125;)&#125;,useDefaultFilters = <span class="keyword">false</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvanceConfig</span> <span class="keyword">extends</span> <span class="title">DelegatingWebMvcConfiguration</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;项目搭建&quot;&gt;&lt;a href=&quot;#项目搭建&quot; class=&quot;headerlink&quot; title=&quot;项目搭建&quot;&gt;&lt;/a&gt;项目搭建&lt;/h1&gt;&lt;h2 id=&quot;搭建原理&quot;&gt;&lt;a href=&quot;#搭建原理&quot; class=&quot;headerlink&quot; title=&quot;搭建原理&quot;&gt;&lt;/a
    
    </summary>
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>一文搞懂Spring-AOP原理</title>
    <link href="http://chenjiabing666.github.io/2019/07/19/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82Spring-AOP%E5%8E%9F%E7%90%86/"/>
    <id>http://chenjiabing666.github.io/2019/07/19/一文搞懂Spring-AOP原理/</id>
    <published>2019-07-19T14:16:50.000Z</published>
    <updated>2019-07-21T17:19:02.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>面向切面编程，是面向对象编程的重要组成部分，在不改变业务逻辑功能的基础上，对<strong>横切逻辑</strong>进行扩展</li>
</ul>
<h1 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<h1 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h1><ul>
<li><code>@Before</code>（前置通知）：在业务方法执行之前调用</li>
<li><code>@After</code>（后置通知）：在方法之后执行</li>
<li><code>@AfterReturning</code>(正常返回通知)：在方法之后执行，只有在业务方法没有出现异常的时候才会执行</li>
<li><code>@AfterThrowing</code>(异常通知) ： 在方法之后执行，只有在业务方法出现异常的时候才会执行</li>
<li><code>@Around</code> （环绕通知）：在业务方法执行之前和之后执行</li>
</ul>
<h1 id="连接点"><a href="#连接点" class="headerlink" title="连接点"></a>连接点</h1><ul>
<li>业务层的所有方法，叫做连接点</li>
<li>业务类中可以被增强的方法都叫做连接点</li>
</ul>
<h1 id="切点"><a href="#切点" class="headerlink" title="切点"></a>切点</h1><ul>
<li>能切入切面逻辑的方法，叫做切点</li>
<li><strong>实际被增强的方法叫做切入点</strong> ，其他的那些没有被增强的方法(连接点)不是切点</li>
</ul>
<h1 id="切面"><a href="#切面" class="headerlink" title="切面"></a>切面</h1><ul>
<li>定义了增强方法的类就叫做切面</li>
</ul>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><ul>
<li>在配置类上开启切面，使用<code>@EnableAspectJAutoProxy</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ComponentScan</span>(value = &#123;<span class="string">"cn.tedu.demo"</span>&#125;)</div><div class="line"><span class="meta">@EnableAsync</span></div><div class="line"><span class="meta">@EnableAspectJAutoProxy</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstConfig</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<ul>
<li>使用五个不同的通知完成切入：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 切面，使用<span class="doctag">@Aspect</span>标注</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="meta">@Aspect</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomAspect</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 使用<span class="doctag">@PointCut</span>定义切入点</div><div class="line">     */</div><div class="line">    <span class="meta">@Pointcut</span>(value = <span class="string">"execution(* cn.tedu.demo.aspect.AspectInvok.invok(..))"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 前置通知，在指定方法之前执行</div><div class="line">     * <span class="doctag">@param</span> point JoinPoint对象，可以获取切点的各种属性，比如入参的参数等</div><div class="line">     */</div><div class="line">    <span class="meta">@Before</span>(value = <span class="string">"pointCut()"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint point)</span></span>&#123;</div><div class="line">        <span class="comment">//获取入参的参数的值</span></div><div class="line">        Object[] args = point.getArgs();</div><div class="line">        System.out.println(Arrays.asList(args));</div><div class="line">        <span class="comment">//获取MethodSignature，其中可以获取切点的各种属性，比如方法返回类型，参数等等</span></div><div class="line">        MethodSignature signature = (MethodSignature) point.getSignature();</div><div class="line">        String[] parameterNames = signature.getParameterNames();</div><div class="line">        System.out.println(Arrays.asList(parameterNames));</div><div class="line">        System.out.println(<span class="string">"在方法之前执行"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 在切点之后执行</div><div class="line">     * <span class="doctag">@param</span> point JoinPoint对象</div><div class="line">     */</div><div class="line">    <span class="meta">@After</span>(value = <span class="string">"pointCut()"</span>,argNames = <span class="string">"point"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(JoinPoint point)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"在方法之后执行"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 在方法前后都会执行</div><div class="line">     * <span class="doctag">@param</span> point</div><div class="line">     */</div><div class="line">    <span class="meta">@Around</span>(value = <span class="string">"pointCut()"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint point)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        System.out.println(<span class="string">"前置执行"</span>);</div><div class="line">        <span class="comment">//执行方法，可以获取返回值，否则方法将不会执行</span></div><div class="line">        Object result = point.proceed(point.getArgs());</div><div class="line">        System.out.println(<span class="string">"后置执行，执行的结果=="</span>+result);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 正常返回通知，</div><div class="line">     * <span class="doctag">@param</span> point Joinpoint对象</div><div class="line">     * <span class="doctag">@param</span> result 方法执行返回的结果，需要和<span class="doctag">@AfterReturning</span>注解中returning中的属性值相同，否则不能自动装配</div><div class="line">     */</div><div class="line">    <span class="meta">@AfterReturning</span>(value = <span class="string">"pointCut()"</span>,returning = <span class="string">"result"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(JoinPoint point,Object result)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"正常返回执行，执行的结果为："</span>+result);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 异常返回执行，程序出现异常了才会执行</div><div class="line">     * <span class="doctag">@param</span> point</div><div class="line">     * <span class="doctag">@param</span> ex 切入点执行抛出的异常，需要和<span class="doctag">@AfterThrowing</span>注解的throwing值相同，否则不能完成自动装配</div><div class="line">     */</div><div class="line">    <span class="meta">@AfterThrowing</span>(value = <span class="string">"pointCut()"</span>,throwing = <span class="string">"ex"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(JoinPoint point,Exception ex)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"异常返回执行，执行的异常为："</span>+ex);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="注解的实现"><a href="#注解的实现" class="headerlink" title="注解的实现"></a>注解的实现</h1><ul>
<li><a href="https://chenjiabing666.github.io/2018/11/03/java%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/">详细请看我的上一篇博客</a></li>
<li><p>定义一个注解，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</div><div class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> "陈加兵"</span>;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 22</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>定义一个切面，使用注解如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="meta">@Aspect</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomAspect</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 使用<span class="doctag">@PointCut</span>定义切入点</div><div class="line">     */</div><div class="line">    <span class="meta">@Pointcut</span>(value = <span class="string">"@annotation(cn.tedu.demo.aspect.MyAnnotation)"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 前置通知，在指定方法之前执行</div><div class="line">     * <span class="doctag">@param</span> point JoinPoint对象，可以获取切点的各种属性，比如入参的参数等</div><div class="line">     */</div><div class="line">    <span class="meta">@Before</span>(value = <span class="string">"pointCut()"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint point)</span></span>&#123;</div><div class="line">        <span class="comment">//获取MethodSignature，其中可以获取切点的各种属性，比如方法返回类型，参数等等</span></div><div class="line">        MethodSignature signature = (MethodSignature) point.getSignature();</div><div class="line">        Method method = signature.getMethod();</div><div class="line">        <span class="comment">//获取方法上指定的注解</span></div><div class="line">        MyAnnotation myAnnotation = method.getAnnotation(MyAnnotation.class);</div><div class="line">        System.out.println(<span class="string">"name="</span>+myAnnotation.name());</div><div class="line">        System.out.println(<span class="string">"在方法之前执行"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h1><ul>
<li>两个或者三个切入点，可以使用切入点表达式，比如<code>||</code>、<code>&amp;&amp;</code>、<code>!</code></li>
<li>如下我们定义两个切入点：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* cn.tedu.demo.service.UserService.addUser(..))"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut1</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">   <span class="meta">@Pointcut</span>(<span class="string">"execution(* cn.tedu.demo.service.UserService.deleteUserById(..))"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut2</span><span class="params">()</span></span>&#123;&#125;</div></pre></td></tr></table></figure>
<ul>
<li>我们使用表达式来定义第三个切入点<ul>
<li><code>@Pointcut(&quot;pointCut1()||pointCut2()&quot;)</code>：两个切入点只要满足其中一个就能匹配</li>
<li><code>@Pointcut(&quot;pointCut1()&amp;&amp;pointCut2()&quot;)</code>：两个切入点必须全部满足才能匹配</li>
<li><code>@Pointcut(&quot;!pointCut1()&amp;&amp;pointCut2()&quot;)</code>：不满足PointCut1并且满足pointCut2才能匹配</li>
</ul>
</li>
</ul>
<h1 id="切面执行顺序（Order）"><a href="#切面执行顺序（Order）" class="headerlink" title="切面执行顺序（Order）"></a>切面执行顺序（Order）</h1><ul>
<li>如果有多个切面匹配了同一个目标方法，那么切面如何执行，我们可以使用<code>@Order</code>指定的切入点的执行顺序，注意：<strong>@Order中的值越小优先级越高</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Aspect</span></div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="meta">@Order</span>(Ordered.LOWEST_PRECEDENCE-<span class="number">1</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</div><div class="line">    </div><div class="line"> <span class="meta">@Aspect</span></div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="meta">@Order</span>(Ordered.HIGHEST_PRECEDENCE-<span class="number">2</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect2</span> </span>&#123;</div></pre></td></tr></table></figure>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul>
<li>事务也是的一个切面，那么事务的优先级和自定义的切面优先级有什么关系呢？<ul>
<li>如果自定义事务的优先级比事务的优先级高，那么在动态代理的时候，获取的拦截器链就在事务的拦截器（TransactionInterceptor）之前，此时切面执行的逻辑和目标方法就不在同一个事务中</li>
<li>默认的事务的优先级是最低的，因此切面使用默认的是能够保证在同一个事务中执行的。</li>
<li>事务的优先级可以在<code>@EnableTransactionManagement</code>这个注解中设置</li>
<li>如果切面指定了优先级，但是还要保证和目标方法在同一个事务中，那么必须调整事务的优先级比自定义切面的优先级高。</li>
</ul>
</li>
<li>如何知道事务的优先级？<ul>
<li>在<code>ProxyTransactionManagementConfiguration</code>配置类中注入<code>BeanFactoryTransactionAttributeSourceAdvisor</code>会获取<code>EnableTransactionManagement</code>注解中的order值作为优先级</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span>(name = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME)</div><div class="line">	<span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</div><div class="line">	<span class="function"><span class="keyword">public</span> BeanFactoryTransactionAttributeSourceAdvisor <span class="title">transactionAdvisor</span><span class="params">()</span> </span>&#123;</div><div class="line">		BeanFactoryTransactionAttributeSourceAdvisor advisor = <span class="keyword">new</span> BeanFactoryTransactionAttributeSourceAdvisor();</div><div class="line">		advisor.setTransactionAttributeSource(transactionAttributeSource());</div><div class="line">		advisor.setAdvice(transactionInterceptor());</div><div class="line">        <span class="comment">//如果注解中的属性不为空</span></div><div class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.enableTx != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//直接设置order的值</span></div><div class="line">			advisor.setOrder(<span class="keyword">this</span>.enableTx.&lt;Integer&gt;getNumber(<span class="string">"order"</span>));</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> advisor;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ul>
<li>拦截器如果根据优先级排序？<ul>
<li>在创建代理对象的时候，会获取适用于当前Bean的所有Advisor，之后会根据优先级进行排序</li>
<li>在JDK获取拦截器链的时候实际就是循环便利ProxyFactory中存储的Advisor，将其中的Advice转换为MethodInterceptor，因此这个拦截器也是按照Advisor的顺序。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator#findEligibleAdvisors</span></div><div class="line"><span class="comment">//获取适用于当前bean的所有Advisor</span></div><div class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</div><div class="line">    	<span class="comment">//获取候选Advisor</span></div><div class="line">		List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</div><div class="line">    	<span class="comment">//获取能够适用于的当前Bean的advisor</span></div><div class="line">		List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</div><div class="line">		extendAdvisors(eligibleAdvisors);</div><div class="line">		<span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</div><div class="line">            <span class="comment">//对advisor排序</span></div><div class="line">			eligibleAdvisors = sortAdvisors(eligibleAdvisors);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> eligibleAdvisors;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//org.springframework.aop.framework.DefaultAdvisorChainFactory#getInterceptorsAndDynamicInterceptionAdvice</span></div><div class="line"><span class="comment">//直接获取ProxyFactory中的Advisor，循环遍历将其中的advice转换为MethodInterceptor</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(</span></span></div><div class="line">			Advised config, Method method, @Nullable Class&lt;?&gt; targetClass) &#123;</div><div class="line"></div><div class="line">		<span class="comment">// This is somewhat tricky... We have to process introductions first,</span></div><div class="line">		<span class="comment">// but we need to preserve order in the ultimate list.</span></div><div class="line">		AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();</div><div class="line">		Advisor[] advisors = config.getAdvisors();</div><div class="line">		List&lt;Object&gt; interceptorList = <span class="keyword">new</span> ArrayList&lt;&gt;(advisors.length);</div><div class="line">		Class&lt;?&gt; actualClass = (targetClass != <span class="keyword">null</span> ? targetClass : method.getDeclaringClass());</div><div class="line">		Boolean hasIntroductions = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">		<span class="keyword">for</span> (Advisor advisor : advisors) &#123;</div><div class="line">			<span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> PointcutAdvisor) &#123;</div><div class="line">				<span class="comment">// Add it conditionally.</span></div><div class="line">				PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;</div><div class="line">				<span class="keyword">if</span> (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) &#123;</div><div class="line">					MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();</div><div class="line">					<span class="keyword">boolean</span> match;</div><div class="line">					<span class="keyword">if</span> (mm <span class="keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;</div><div class="line">						<span class="keyword">if</span> (hasIntroductions == <span class="keyword">null</span>) &#123;</div><div class="line">							hasIntroductions = hasMatchingIntroductions(advisors, actualClass);</div><div class="line">						&#125;</div><div class="line">						match = ((IntroductionAwareMethodMatcher) mm).matches(method, actualClass, hasIntroductions);</div><div class="line">					&#125;</div><div class="line">					<span class="keyword">else</span> &#123;</div><div class="line">						match = mm.matches(method, actualClass);</div><div class="line">					&#125;</div><div class="line">					<span class="keyword">if</span> (match) &#123;</div><div class="line">						MethodInterceptor[] interceptors = registry.getInterceptors(advisor);</div><div class="line">						<span class="keyword">if</span> (mm.isRuntime()) &#123;</div><div class="line">							<span class="comment">// Creating a new object instance in the getInterceptors() method</span></div><div class="line">							<span class="comment">// isn't a problem as we normally cache created chains.</span></div><div class="line">							<span class="keyword">for</span> (MethodInterceptor interceptor : interceptors) &#123;</div><div class="line">								interceptorList.add(<span class="keyword">new</span> InterceptorAndDynamicMethodMatcher(interceptor, mm));</div><div class="line">							&#125;</div><div class="line">						&#125;</div><div class="line">						<span class="keyword">else</span> &#123;</div><div class="line">							interceptorList.addAll(Arrays.asList(interceptors));</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</div><div class="line">				IntroductionAdvisor ia = (IntroductionAdvisor) advisor;</div><div class="line">				<span class="keyword">if</span> (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) &#123;</div><div class="line">					Interceptor[] interceptors = registry.getInterceptors(advisor);</div><div class="line">					interceptorList.addAll(Arrays.asList(interceptors));</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				Interceptor[] interceptors = registry.getInterceptors(advisor);</div><div class="line">				interceptorList.addAll(Arrays.asList(interceptors));</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> interceptorList;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h1 id="Aspect实例化模型"><a href="#Aspect实例化模型" class="headerlink" title="Aspect实例化模型"></a>Aspect实例化模型</h1><h1 id="获取参数-args"><a href="#获取参数-args" class="headerlink" title="获取参数(args)"></a>获取参数(args)</h1><ul>
<li>在这之前如果我们想要获取目标方法的参数，我们常用的手段就是通过JoinPoint的API直接获取的，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MethodSignature signature = (MethodSignature) point.getSignature();</div><div class="line">String[] parameters = signature.getParameterNames();</div></pre></td></tr></table></figure>
<ul>
<li>但是我们也是可以通过args将入参绑定，如下：<ul>
<li>此时的args中的user就和通知方法中的user绑定了，spring会自动获取目标方法中的参数user为其绑定值</li>
<li><strong>注意：args中此时只指定了一个参数User，也就是意味着目标方法只能是带有User对象这一个参数的方法才能匹配，如果有其他的参数，那么这个通知将不起作用</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Before</span>(value = <span class="string">"pointCut1()&amp;&amp;args(user)"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint point,User user)</span></span>&#123;</div></pre></td></tr></table></figure>
<ul>
<li>我们可以使用的args指定一个或者多个参数，如：<code>args(user,..)</code>,此时匹配的目标方法中<strong>至少</strong>包含一个参数User对象才能匹配。</li>
</ul>
<h1 id="PointCut"><a href="#PointCut" class="headerlink" title="PointCut"></a>PointCut</h1><ul>
<li>PointCut这个接口有两部分组成，分别是<code>ClassFilter</code>和<code>MethodMatcher</code>，其实可以很好的理解，如何定义一个切入点？我们在定义切入点的时候，就是想对某一个类的全部方法，或者对某一个类的部方法进行切入，因此在判断能否作用到方法上的时候，先判断是否类能够匹配（ClassFilter的活），之后再判断方法是否匹配（MethodMatcher的活）。</li>
<li>PointCut的实现类有很多，其中比较重要的是AOP使用的<code>AspectJExpressionPointcut</code>【这个类主要是解析execution表达式的，这个类同时实现了ClassFilter和MethodMatcher，具备了两者的功能，因此可以直接使用该类进行切入点的匹配】、<code>AnnotationMatchingPointcut</code>【注解的PointCut，主要用来匹配注解,底层使用就是<code>AnnotationMethodMatcher</code>和<code>AnnotationMethodClassFilter</code>，后续会讲到】</li>
<li><p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pointcut</span> </span>&#123;</div><div class="line">	<span class="comment">//返回一个ClassFilter</span></div><div class="line">	<span class="function">ClassFilter <span class="title">getClassFilter</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">//返回一个MethodMatcher</span></div><div class="line">	<span class="function">MethodMatcher <span class="title">getMethodMatcher</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="comment">//TruePointCut，对应任何的方法都是匹配(总是匹配)</span></div><div class="line">	Pointcut TRUE = TruePointcut.INSTANCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>AspectJExpressionPointcut</code>演示如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAspectJExpressionPointCut</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</div><div class="line">     AspectJExpressionPointcut expressionPointcut = <span class="keyword">new</span> AspectJExpressionPointcut();</div><div class="line">     <span class="comment">//设置aspectj表达式，这个比较常用的表达式</span></div><div class="line">     expressionPointcut.setExpression(<span class="string">"execution(* cn.tedu.demo.service.UserService.addUser(..))"</span>);</div><div class="line">     <span class="comment">//匹配类</span></div><div class="line">     <span class="keyword">boolean</span> b = expressionPointcut.matches(UserService.class);</div><div class="line">     <span class="comment">//直接调用matches匹配方法</span></div><div class="line">     <span class="keyword">boolean</span> a = expressionPointcut.matches(UserService.class.getDeclaredMethod(<span class="string">"addUser"</span>, User.class), UserService.class);</div><div class="line">     System.out.println(a+<span class="string">"---&gt;"</span>+b);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<ul>
<li>AnnotationMatchingPointcut的演示如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAnnotationMatchingPointcut</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</div><div class="line">    <span class="comment">//第一个参数是注解，第二参数表示是否在接口和父类的查找该注解</span></div><div class="line">    AnnotationMatchingPointcut pointcut = <span class="keyword">new</span> AnnotationMatchingPointcut(Transactional.class, <span class="keyword">false</span>);</div><div class="line">    <span class="comment">//匹配方法上是否有@Transactional注解</span></div><div class="line">    <span class="keyword">boolean</span> a = pointcut.getMethodMatcher().matches(UserService.class.getDeclaredMethod(<span class="string">"addUser"</span>, User.class), UserService.class);</div><div class="line">    <span class="comment">//匹配类上是否有@Transactional注解</span></div><div class="line">    <span class="keyword">boolean</span> b = pointcut.getClassFilter().matches(UserService.class);</div><div class="line">    System.out.println(a+<span class="string">"---&gt;"</span>+b);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="PointCuts"><a href="#PointCuts" class="headerlink" title="PointCuts"></a>PointCuts</h1><ul>
<li>类似于MethodMatchers和ClassFilters，其中同样有union等，作用就是提供了一个matches方法，不需要自己写步骤先比较Class，再比较Method等操作，当然还有一些便捷的功能。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPointcuts</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</div><div class="line">    AnnotationMatchingPointcut annotationMatchingPointcut = <span class="keyword">new</span> AnnotationMatchingPointcut(Transactional.class, <span class="keyword">false</span>);</div><div class="line">    Class cls=UserService.class;</div><div class="line">    Method method = cls.getDeclaredMethod(<span class="string">"addUser"</span>, User.class);</div><div class="line">    <span class="comment">//调用matches方法，判断UserService的addUser方法是否有@Transactional注解</span></div><div class="line">    <span class="keyword">boolean</span> matches = Pointcuts.matches(annotationMatchingPointcut, method, cls);</div><div class="line">    System.out.println(matches);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="ClassFilter"><a href="#ClassFilter" class="headerlink" title="ClassFilter"></a>ClassFilter</h1><ul>
<li>类过滤器，就是判断类是否匹配</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassFilter</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">//判断方法</span></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Class&lt;?&gt; clazz)</span></span>;</div><div class="line">	</div><div class="line">    <span class="comment">//定义一个总是匹配的TrueClassFilter，其实就是matches方法总是返回true</span></div><div class="line">	ClassFilter TRUE = TrueClassFilter.INSTANCE;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>ClassFilter在spring底层有许多实现的类，比如AnnotationClassFilter（匹配指定注解）、TrueClassFilter（全部匹配）、AspectJExpressionPointcut（Aspect表达式匹配，APO重要的组件）</p>
</li>
<li><p>实例：使用AnnotationClassFilter测试该类是否有<code>@Transactional</code>注解</p>
<ul>
<li>该类有一个属性<code>checkInherited</code>，如果为false，那么只检查当前类是否有对应的注解，为true，那么会检查父类或者实现的接口存在，默认为false<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAnnotationClassFilter</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//指定checkInherited为true，会同时检查该类和父类及其实现的接口是否存在Transactional注解</span></div><div class="line">    AnnotationClassFilter annotationClassFilter = <span class="keyword">new</span> AnnotationClassFilter(Transactional.class, <span class="keyword">true</span>);</div><div class="line">    <span class="keyword">boolean</span> matches = annotationClassFilter.matches(UserServiceImpl.class);</div><div class="line">    System.out.println(matches);</div><div class="line">   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>我们也可以自定义自己的ClassFilter， 只需要实现其中的接口方法即可，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCustomClassFilter</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//自定义一个classFilter，判断指定的类是否是UserServiceImpl的接口或者父类或者同类</span></div><div class="line">    ClassFilter customFilter =cls-&gt; cls.isAssignableFrom(UserServiceImpl.class);</div><div class="line">    <span class="keyword">boolean</span> matches = customFilter.matches(UserService.class);</div><div class="line">    System.out.println(matches);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="ClassFilters"><a href="#ClassFilters" class="headerlink" title="ClassFilters"></a>ClassFilters</h1><ul>
<li>该抽象类中有两个ClassFilter，分别是<code>UnionClassFilter</code>【满足其中一个即返回true】、<code>IntersectionClassFilter</code>【必须满足所有的ClassFilter才返回true】</li>
<li>同样的对应有两个静态方法上面的两个Filter，如下：<ul>
<li><code>public static ClassFilter union(ClassFilter cf1, ClassFilter cf2)</code></li>
<li><code>public static ClassFilter intersection(ClassFilter cf1, ClassFilter cf2)</code></li>
</ul>
</li>
<li>实例<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClassFilters</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//类或者接口上必须有Transactional注解</span></div><div class="line">        AnnotationClassFilter annotationClassFilter = <span class="keyword">new</span> AnnotationClassFilter(Transactional.class,<span class="keyword">false</span>);</div><div class="line">        <span class="comment">//类或者接口必须是UserServiceImpl的父类或者接口或者同类</span></div><div class="line">        ClassFilter customFilter =cls-&gt; cls.isAssignableFrom(UserServiceImpl.class);</div><div class="line">        <span class="comment">//返回unionFilter，只要满足上面的一个ClassFilter即返回true</span></div><div class="line">        ClassFilter unionFilter = ClassFilters.union(annotationClassFilter, customFilter);</div><div class="line">        <span class="comment">//返回intersectionFilter，必须满足上面两个ClassFilter才会返回true</span></div><div class="line">        ClassFilter intersectionFilter = ClassFilters.intersection(annotationClassFilter, customFilter);</div><div class="line">        <span class="keyword">boolean</span> u = unionFilter.matches(UserService.class);</div><div class="line">        <span class="keyword">boolean</span> i = intersectionFilter.matches(UserService.class);</div><div class="line">        System.out.println(u);</div><div class="line">        System.out.println(i);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="MethodMatcher"><a href="#MethodMatcher" class="headerlink" title="MethodMatcher"></a>MethodMatcher</h1><ul>
<li>ClassFilter是匹配类，MethodMatcher是用来匹配方法</li>
<li>MethodMatcher有两个matches方法，分别是两个参数和三个参数的，两个参数用于静态匹配，只有两个参数的匹配返回true，isRuntime方法true，才应该调用三个参数的方法。如果isRuntime返回false，那么不应该调用三个参数的matches</li>
<li><p>接口的实现类有很多，如<code>StaticMethodMatcher</code>【只支持静态匹配，两个参数的matchs】、<code>AspectJExpressionPointcut</code>【AOP重要组件】、<code>TrueMethodMatcher</code>【总是匹配】、<code>AnnotationMethodMatcher</code>【注解匹配】</p>
</li>
<li><p>实例如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAnnotationMethodMatcher</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</div><div class="line">    <span class="comment">//检测方法上是否标注了Transactional注解，false指定了不检查当前类父类和接口</span></div><div class="line">    AnnotationMethodMatcher methodMatcher=<span class="keyword">new</span> AnnotationMethodMatcher(Transactional.class,<span class="keyword">false</span>);</div><div class="line">    Class cls=UserService.class;</div><div class="line">    Method method = cls.getDeclaredMethod(<span class="string">"addUser"</span>, User.class);</div><div class="line">    <span class="comment">//两个参数的mathces，三个参数的不支持【继承了StaticMethodMatcher】</span></div><div class="line">    <span class="keyword">boolean</span> matches = methodMatcher.matches(method, cls);</div><div class="line">    System.out.println(matches);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>当然也是可以自定义实现类，这里和上面的ClassFilter的差不多，就不再写了，自己发挥想象力</li>
</ul>
<h1 id="MethodMatchers"><a href="#MethodMatchers" class="headerlink" title="MethodMatchers"></a>MethodMatchers</h1><ul>
<li>同ClassFilters功能一样，其中提供了<code>UnionMethodMatcher类</code>【只要匹配一个即返回true】，<code>IntersectionMethodMatcher</code>【】</li>
<li>此处不再演示</li>
</ul>
<h1 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h1><ul>
<li>通知的接口，在aop中的每一个通知注解都有对应的接口，比如<code>BeforeAdvice</code>、<code>AfterAdvice</code>等</li>
<li>Advice的默认实现抽象类是<code>AbstractAspectJAdvice</code>，各种AspectJ的通知都会继承并拓展该类，其中封装了有关通知的全部信息，比如方法名称、方法Method对象、PointCut、Jpoint、pointCut表达式等等信息，其中最重要的一个方法就是<code>protected Object invokeAdviceMethodWithGivenArgs(Object[] args)</code>，该方法用于调用通知方法。</li>
<li>其中关于AspectJ的五种通知方法，类的命名方式是<code>AspectJXxxAdvice</code>，继承抽象类<code>AbstractAspectJAdvice</code>。</li>
<li>比如<code>AspectAfterAdvice</code>这个实现类，其中重要的方法就是invok，源码如下：<ul>
<li>通过源码就可以看出在方法之后执行是怎样的过程，先调用被增强的方法【原方法】、再调用被@After标注的通知方法。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//先执行被增强的方法</span></div><div class="line">			<span class="keyword">return</span> mi.proceed();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">finally</span> &#123;</div><div class="line">            <span class="comment">//再执行通知方法</span></div><div class="line">			invokeAdviceMethod(getJoinPointMatch(), <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h1 id="Advisor"><a href="#Advisor" class="headerlink" title="Advisor"></a>Advisor</h1><ul>
<li>顾问的意思，其中封装了Advice（通知）。</li>
</ul>
<h2 id="PointcutAdvisor"><a href="#PointcutAdvisor" class="headerlink" title="PointcutAdvisor"></a>PointcutAdvisor</h2><ul>
<li>继承了Advisor，是对Advice和PointCut的封装</li>
<li><code>AspectJExpressionPointcutAdvisor</code>：Aop中的一种Advisor，用于封装AspectJExpressionPointCut和Advice</li>
</ul>
<h1 id="proxyFactory"><a href="#proxyFactory" class="headerlink" title="proxyFactory"></a>proxyFactory</h1><ul>
<li>代理工厂：其中保存了代理对象的一切属性，包括advisor，类的信息，接口的信息等。</li>
<li>创建代理对象，实际调用的是<code>org.springframework.aop.framework.DefaultAopProxyFactory#createAopProxy</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</div><div class="line">		<span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</div><div class="line">			Class&lt;?&gt; targetClass = config.getTargetClass();</div><div class="line">			<span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</div><div class="line">						<span class="string">"Either an interface or a target is required for proxy creation."</span>);</div><div class="line">			&#125;</div><div class="line">            <span class="comment">//如果是接口，创建JDK的动态代理</span></div><div class="line">			<span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//创建Cglib动态代理</span></div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactoryTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 自定义一个BeforeAdvice</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomBeforAdvice</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span></span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">            String name = method.getName();</div><div class="line">            <span class="keyword">if</span> (StringUtils.equals(name,<span class="string">"addUser"</span>))&#123;</div><div class="line">                System.out.println(<span class="string">"在addUser之前执行"</span>);</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                System.out.println(<span class="string">"other"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Log</span></span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</div><div class="line">            System.out.println(<span class="string">"在之前执行"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</div><div class="line">        UserService userService=<span class="keyword">new</span> UserServiceImpl();</div><div class="line">        <span class="comment">//创建proxyFactory</span></div><div class="line">        ProxyFactory factory = <span class="keyword">new</span> ProxyFactory(userService);</div><div class="line">        <span class="comment">//创建自定义的BeforeAdvice</span></div><div class="line">        MethodBeforeAdvice advice=<span class="keyword">new</span> CustomBeforAdvice();</div><div class="line">        <span class="comment">//将Advice添加到proxyFactory中</span></div><div class="line">        factory.addAdvice(advice);</div><div class="line">        <span class="comment">//获取代理对象</span></div><div class="line">        UserService proxy = (UserService) factory.getProxy();</div><div class="line">        proxy.addUser(<span class="keyword">new</span> User(<span class="string">""</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</div><div class="line">        UserService userService=<span class="keyword">new</span> UserServiceImpl();</div><div class="line">        <span class="comment">//创建proxyFactory</span></div><div class="line">        ProxyFactory factory = <span class="keyword">new</span> ProxyFactory(userService);</div><div class="line">        Class aspectCls=Log.class;</div><div class="line">        Method aspectMethod = aspectCls.getMethod(<span class="string">"before"</span>);</div><div class="line">        <span class="comment">//构建aspectJ表达式切入点</span></div><div class="line">        AspectJExpressionPointcut aspectJExpressionPointcut = <span class="keyword">new</span> AspectJExpressionPointcut();</div><div class="line">        aspectJExpressionPointcut.setExpression(<span class="string">"execution(* cn.tedu.demo.service.UserService.addUser(..))"</span>);</div><div class="line">        <span class="comment">//创建AspectInstanceFactory（切面实例工厂）</span></div><div class="line">        AspectInstanceFactory aspectInstanceFactory=<span class="keyword">new</span> SimpleAspectInstanceFactory(aspectCls);</div><div class="line">        AspectJMethodBeforeAdvice advice=<span class="keyword">new</span> AspectJMethodBeforeAdvice(aspectMethod,aspectJExpressionPointcut,aspectInstanceFactory);</div><div class="line">        <span class="comment">//创建Advisor，其中封装了Advice和Advisor</span></div><div class="line">        Advisor advisor = <span class="keyword">new</span> AspectJPointcutAdvisor(advice);</div><div class="line">        ArrayList&lt;Advisor&gt; advisors = Lists.newArrayList(advisor);</div><div class="line">        <span class="comment">//添加ExposeInvocationInterceptor到advisor中，这个不是必须的，但是使用AspectJ expression pointcut是必须的</span></div><div class="line">        AspectJProxyUtils.makeAdvisorChainAspectJCapableIfNecessary(advisors);</div><div class="line">        <span class="comment">//将advisor添加到ProxyFactory中</span></div><div class="line">        factory.addAdvisors(advisors);</div><div class="line">        UserService proxy= (UserService) factory.getProxy();</div><div class="line">        proxy.addUser(<span class="keyword">new</span> User(<span class="string">"chen"</span>));</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="EnableAspectJAutoProxy"><a href="#EnableAspectJAutoProxy" class="headerlink" title="@EnableAspectJAutoProxy"></a>@EnableAspectJAutoProxy</h1><ul>
<li>从<code>@EnableAspectJAutoProxy</code>该注解中可以看出使用了<code>@Import(AspectJAutoProxyRegistrar.class)</code>，因此实际作用的类就是<code>AspectJAutoProxyRegistrar</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Import</span>(AspectJAutoProxyRegistrar.class)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</div></pre></td></tr></table></figure>
<h1 id="AspectJAutoProxyRegistrar"><a href="#AspectJAutoProxyRegistrar" class="headerlink" title="AspectJAutoProxyRegistrar"></a>AspectJAutoProxyRegistrar</h1><ul>
<li>该类实现<code>ImportBeanDefinitionRegistrar</code>【向容器中注入Bean】。</li>
<li>该类的主要作用就是向ioc容器中注入<code>AnnotationAutoProxyCreator</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AspectJAutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	* 向容器中注入AnnotationAutoProxyCreator</div><div class="line">	*/</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(</span></span></div><div class="line">			AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;</div><div class="line">		<span class="comment">//调用方法注册AnnotationAutoProxyCreator</span></div><div class="line">		AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</div><div class="line"></div><div class="line">        <span class="comment">//获取@EnableAspectJAutoProxy注解中两个属性的值</span></div><div class="line">		AnnotationAttributes enableAspectJAutoProxy =</div><div class="line">				AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);</div><div class="line">        <span class="comment">//判断注解属性的值</span></div><div class="line">		<span class="keyword">if</span> (enableAspectJAutoProxy != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">"proxyTargetClass"</span>)) &#123;</div><div class="line">				AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">"exposeProxy"</span>)) &#123;</div><div class="line">				AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="AnnotationAutoProxyCreator"><a href="#AnnotationAutoProxyCreator" class="headerlink" title="AnnotationAutoProxyCreator"></a>AnnotationAutoProxyCreator</h1><ul>
<li>注解版代理创建器，主要的作用就是利用<code>SmartInstantiationAwareBeanPostProcessor</code>后置处理器，在Bean实例化前后创建代理对象。有了后置处理器和BeanFactoryAware，可想而知，主要的实现都是从他们实现的方法进入的。</li>
<li>继承关系如下：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/chenjiabing666/BlogImage/master/spring_o1.png" alt=""></p>
<ul>
<li><p>创建代理对象的代码如下：</p>
<ul>
<li>真正的实现在<code>org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#wrapIfNecessary</code><ul>
<li>advisedBeans：存放所有的Bean，value是Boolean类型的值，如果为false表示不需要代理，反之则需要代理</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</div><div class="line">			<span class="keyword">return</span> bean;</div><div class="line">		&#125;</div><div class="line">    	<span class="comment">//如果为false，直接返回，不需要代理</span></div><div class="line">		<span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</div><div class="line">			<span class="keyword">return</span> bean;</div><div class="line">		&#125;</div><div class="line">    	<span class="comment">//判断是否是基础的切面类</span></div><div class="line">		<span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</div><div class="line">			<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</div><div class="line">			<span class="keyword">return</span> bean;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// 获取适用的Advisor</span></div><div class="line">		Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</div><div class="line">		<span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</div><div class="line">			<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</div><div class="line">            <span class="comment">//创建代理对象</span></div><div class="line">			Object proxy = createProxy(</div><div class="line">					bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</div><div class="line">			<span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</div><div class="line">			<span class="keyword">return</span> proxy;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</div><div class="line">		<span class="keyword">return</span> bean;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#createProxy</span></div><div class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, @Nullable String beanName,</span></span></div><div class="line">			@Nullable Object[] specificInterceptors, TargetSource targetSource) &#123;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</div><div class="line">			AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//创建代理工厂</span></div><div class="line">		ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</div><div class="line">		proxyFactory.copyFrom(<span class="keyword">this</span>);</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</div><div class="line">			<span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</div><div class="line">				proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				evaluateProxyInterfaces(beanClass, proxyFactory);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</div><div class="line">		proxyFactory.addAdvisors(advisors);</div><div class="line">		proxyFactory.setTargetSource(targetSource);</div><div class="line">		customizeProxyFactory(proxyFactory);</div><div class="line"></div><div class="line">		proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</div><div class="line">		<span class="keyword">if</span> (advisorsPreFiltered()) &#123;</div><div class="line">			proxyFactory.setPreFiltered(<span class="keyword">true</span>);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="BeanFactoryAspectJAdvisorsBuilder"><a href="#BeanFactoryAspectJAdvisorsBuilder" class="headerlink" title="BeanFactoryAspectJAdvisorsBuilder"></a>BeanFactoryAspectJAdvisorsBuilder</h1><ul>
<li>Advisor的构建器，主要的功能就是扫描的带有@Aspect注解的类，构造Advisor。</li>
<li>在<code>AbstractAdvisorAutoProxyCreator</code>的setFactory的方法中被创建。</li>
<li>其中最重要的方法就是buildAspectJAdvisors，用来构造Advisor</li>
</ul>
<h1 id="AspectJAdvisorFactory"><a href="#AspectJAdvisorFactory" class="headerlink" title="AspectJAdvisorFactory"></a>AspectJAdvisorFactory</h1><ul>
<li>Advisor工厂，主要是用来构造Advisor的，在BeanFactoryAspectJAdvisorsBuilder中被应用。</li>
<li><code>ReflectiveAspectJAdvisorFactory</code>是其实现类，AOP中就是使用该类构造Advisor</li>
<li>其中最重要的两个方法如下：<ul>
<li><code>private List&lt;Method&gt; getAdvisorMethods(Class&lt;?&gt; aspectClass)</code>：在切面类获取没有标注@PointCut的方法</li>
<li><code>public List&lt;Advisor&gt; getAdvisors(MetadataAwareAspectInstanceFactory aspectInstanceFactory)</code>：获取所有的Advisor</li>
</ul>
</li>
</ul>
<h1 id="JdkDynamicAopProxy"><a href="#JdkDynamicAopProxy" class="headerlink" title="JdkDynamicAopProxy"></a>JdkDynamicAopProxy</h1><ul>
<li>JDK的动态调用的主要类，实现了AopProxy、InvocationHandler</li>
<li>重要的属性：<ul>
<li><code>private final AdvisedSupport advised</code>：其中封装了代理类的属性，其实就是一个ProxyFactory，包括目标类，目标方法、advisor等信息。</li>
</ul>
</li>
<li>重要方法：<ul>
<li><code>public Object invoke(Object proxy, Method method, Object[] args)</code>：方法调用的类，实现了InvocationHandler的方法</li>
</ul>
</li>
</ul>
<h1 id="MethodInterceptor"><a href="#MethodInterceptor" class="headerlink" title="MethodInterceptor"></a>MethodInterceptor</h1><ul>
<li>方法拦截器接口，继承了Advice，Interceptor。AspectJxxxAdvice等通知的类中都实现了这个方法，其中有一个invoke方法，是执行方法调用的逻辑，在Spring的代理执行的过程中和ReflectiveMethodInvocation结合使用，完美的诠释了责任链的模式。</li>
<li><code>Object invoke(MethodInvocation invocation) throws Throwable</code>：执行方法的逻辑</li>
</ul>
<h2 id="AspectJAfterAdvice【示例】"><a href="#AspectJAfterAdvice【示例】" class="headerlink" title="AspectJAfterAdvice【示例】"></a>AspectJAfterAdvice【示例】</h2><ul>
<li>该类实现了MethodInterceptor，其中的Invoke实现如下：<ul>
<li>其中的<code>mi.proceed()</code>这个方法，是责任链模式的重要方法。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//调用其他的拦截器【因为这个拦截器是在方法之后执行的】</span></div><div class="line">			<span class="keyword">return</span> mi.proceed();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">finally</span> &#123;</div><div class="line">            <span class="comment">//最终调用通知方法</span></div><div class="line">			invokeAdviceMethod(getJoinPointMatch(), <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h1 id="MethodInvocation"><a href="#MethodInvocation" class="headerlink" title="MethodInvocation"></a>MethodInvocation</h1><ul>
<li>方法调用器，其中一个实现类是AOp中非常重要的组件（ReflectiveMethodInvocation）。</li>
</ul>
<h2 id="ReflectiveMethodInvocation"><a href="#ReflectiveMethodInvocation" class="headerlink" title="ReflectiveMethodInvocation"></a>ReflectiveMethodInvocation</h2><ul>
<li>该类在spring中的大致描述就是通过反射调用目标方法，是spring中内部使用的类。</li>
<li>该类其中的重要的方法就是<code>proceed</code>，通过责任链的模式执行拦截器中的方法，和MethodInterceptor完美的诠释了责任链设计模式。源码如下：<ul>
<li><strong>其实最重要的就是在内部调用了拦截器的invoke方法，但是在拦截器的invoke方法中还会递归的执行的proceed方法，这样的配置就完成了责任链的模式。</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">		<span class="comment">// 标记拦截器链执行的位置，初始值是-1，递归的结束条件</span></div><div class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;		</div><div class="line">            <span class="comment">//拦截器都执行完成了，那么通过反射执行目标方法</span></div><div class="line">			<span class="keyword">return</span> invokeJoinpoint();</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//获取拦截器</span></div><div class="line">		Object interceptorOrInterceptionAdvice =</div><div class="line">				<span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</div><div class="line">    	<span class="comment">//判断拦截器的类型</span></div><div class="line">		<span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</div><div class="line">			<span class="comment">// Evaluate dynamic method matcher here: static part will already have</span></div><div class="line">			<span class="comment">// been evaluated and found to match.</span></div><div class="line">			InterceptorAndDynamicMethodMatcher dm =</div><div class="line">					(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</div><div class="line">			Class&lt;?&gt; targetClass = (<span class="keyword">this</span>.targetClass != <span class="keyword">null</span> ? <span class="keyword">this</span>.targetClass : <span class="keyword">this</span>.method.getDeclaringClass());</div><div class="line">			<span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, targetClass, <span class="keyword">this</span>.arguments)) &#123;</div><div class="line">				<span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">				<span class="keyword">return</span> proceed();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			<span class="comment">//调用拦截器的invoke方法</span></div><div class="line">			<span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ul>
<li>实例如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="comment">//目标对象</span></div><div class="line">        UserService userService=<span class="keyword">new</span> UserServiceImpl();</div><div class="line">        <span class="comment">//新建一个ProxyFactory，创建代理</span></div><div class="line">        ProxyFactory factory = <span class="keyword">new</span> ProxyFactory();</div><div class="line">        factory.setTarget(userService);</div><div class="line">        <span class="comment">//设置接口，否则使用的是cglib代理</span></div><div class="line">        factory.setInterfaces(UserService.class);</div><div class="line">        <span class="comment">//获取代理对象</span></div><div class="line">        Object proxy = factory.getProxy();</div><div class="line">        <span class="comment">//切面</span></div><div class="line">        Class aspectCls=LogAspect.class;</div><div class="line">        <span class="comment">//通知方法</span></div><div class="line">        Method aspectMethod=aspectCls.getDeclaredMethod(<span class="string">"afterAdvice"</span>);</div><div class="line">        <span class="comment">//切面对象</span></div><div class="line">        <span class="keyword">final</span> Object aspectObj=<span class="keyword">new</span> LogAspect();</div><div class="line">        <span class="comment">//新建一个拦截器</span></div><div class="line">        MethodInterceptor afterInterceptor=<span class="keyword">new</span> MethodInterceptor() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">                CustomeInvocation ref=(CustomeInvocation)invocation;</div><div class="line">                <span class="keyword">try</span>&#123;</div><div class="line">                    <span class="comment">//执行其他的拦截器</span></div><div class="line">                    <span class="keyword">return</span> invocation.proceed();</div><div class="line">                &#125;<span class="keyword">finally</span> &#123;</div><div class="line">                    <span class="comment">//最后执行切面的方法</span></div><div class="line">                    ref.getAspectMethod().invoke(ref.getAspectObj(), ref.getAspectArgs());</div><div class="line"><span class="comment">//                    System.out.println("方法之后执行");</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        <span class="comment">//创建拦截器链</span></div><div class="line">        List&lt;Object&gt; interceptors=<span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        interceptors.add(afterInterceptor);</div><div class="line">        Method targetMethod=UserService.class.getMethod(<span class="string">"addUser"</span>, User.class);</div><div class="line">        Object[] args=<span class="keyword">new</span> Object[]&#123;<span class="keyword">new</span> User(<span class="string">"陈加兵"</span>)&#125;;</div><div class="line">        CustomeInvocation invocation = <span class="keyword">new</span> CustomeInvocation(proxy, userService, targetMethod, args, UserService.class,interceptors,aspectCls,aspectMethod,aspectObj,<span class="keyword">new</span> Object[]&#123;&#125;);</div><div class="line">        invocation.proceed();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 自定义一个Invocation，因为ReflectiveMethodInvocation是spring内部使用的，构造方法protected</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomeInvocation</span> <span class="keyword">extends</span>  <span class="title">ReflectiveMethodInvocation</span></span>&#123;</div><div class="line">        <span class="keyword">private</span> Method aspectMethod;</div><div class="line">        <span class="keyword">private</span> Class aspcetCls;</div><div class="line">        <span class="keyword">private</span> Object aspectObj;</div><div class="line">        <span class="keyword">private</span> Object[] aspectArgs;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * <span class="doctag">@param</span> proxy 代理</div><div class="line">         * <span class="doctag">@param</span> target 目标对象</div><div class="line">         * <span class="doctag">@param</span> method 目标方法</div><div class="line">         * <span class="doctag">@param</span> arguments 参数</div><div class="line">         * <span class="doctag">@param</span> targetClass 目标类</div><div class="line">         * <span class="doctag">@param</span> aspectMethod 通知方法</div><div class="line">         * <span class="doctag">@param</span>  aspctCls 切面类</div><div class="line">         * <span class="doctag">@param</span>  aspectObj 切面对象</div><div class="line">         * <span class="doctag">@param</span> interceptorsAndDynamicMethodMatchers 拦截器</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomeInvocation</span><span class="params">(Object proxy, Object target, Method method, Object[] arguments, Class&lt;?&gt; targetClass, List&lt;Object&gt; interceptorsAndDynamicMethodMatchers,Class aspctCls,Method aspectMethod,Object aspectObj,Object[] aspectArgs)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>(proxy, target, method, arguments, targetClass, interceptorsAndDynamicMethodMatchers);</div><div class="line">            <span class="keyword">this</span>.aspectMethod=aspectMethod;</div><div class="line">            <span class="keyword">this</span>.aspcetCls=aspctCls;</div><div class="line">            <span class="keyword">this</span>.aspectObj=aspectObj;</div><div class="line">            <span class="keyword">this</span>.aspectArgs=aspectArgs;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="JDK动态代理示例"><a href="#JDK动态代理示例" class="headerlink" title="JDK动态代理示例"></a>JDK动态代理示例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKDynamicProxy</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span>&#123;</div><div class="line">        <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span>  <span class="title">CustomSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"执行加法计算"</span>);</div><div class="line">            <span class="keyword">return</span> a+b;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 自定义的InvocationHandler</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 目标对象</div><div class="line">         */</div><div class="line">        <span class="keyword">private</span> Object targetObject;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomInvocationHandler</span><span class="params">(Object targetObject)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.targetObject = targetObject;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * <span class="doctag">@param</span> proxy 代理对象</div><div class="line">         * <span class="doctag">@param</span> method 真正执行的方法</div><div class="line">         * <span class="doctag">@param</span> args 方法参数</div><div class="line">         * <span class="doctag">@return</span></div><div class="line">         * <span class="doctag">@throws</span> Throwable</div><div class="line">         */</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">            String methodName = method.getName();</div><div class="line">            <span class="keyword">if</span> (methodName.equals(<span class="string">"add"</span>))&#123;</div><div class="line">                System.out.println(<span class="string">"invok调用"</span>);</div><div class="line">                Object invoke = method.invoke(targetObject, args);</div><div class="line">                <span class="keyword">return</span> invoke;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">        Subject subject=<span class="keyword">new</span> CustomSubject();</div><div class="line">        CustomInvocationHandler customInvocationHandler = <span class="keyword">new</span> CustomInvocationHandler(subject);</div><div class="line">        Subject proxy= (Subject) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),<span class="keyword">new</span> Class[]&#123;Subject.class&#125;, customInvocationHandler);</div><div class="line">        <span class="keyword">int</span> count = proxy.add(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">        System.out.println(count);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="AOP创建代理流程"><a href="#AOP创建代理流程" class="headerlink" title="AOP创建代理流程"></a>AOP创建代理流程</h1><p><img src="https://raw.githubusercontent.com/chenjiabing666/BlogImage/master/aop-create.png" alt=""></p>
<h1 id="AOP执行流程"><a href="#AOP执行流程" class="headerlink" title="AOP执行流程"></a>AOP执行流程</h1><ul>
<li><img src="https://raw.githubusercontent.com/chenjiabing666/BlogImage/master/AOP-proceed.png" alt=""></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;面向切面编程，是面向对象编程的重要组成部分，在不改变业务逻辑功能的基础上，对&lt;strong&gt;横切逻辑&lt;/strong&gt;进行扩展&lt;
    
    </summary>
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring解决循环依赖</title>
    <link href="http://chenjiabing666.github.io/2019/07/17/Spring%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    <id>http://chenjiabing666.github.io/2019/07/17/Spring解决循环依赖/</id>
    <published>2019-07-16T17:13:29.000Z</published>
    <updated>2019-07-16T17:14:14.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是循环依赖"><a href="#什么是循环依赖" class="headerlink" title="什么是循环依赖"></a>什么是循环依赖</h1><ul>
<li>循环依赖分为两种，一种是构造器的相互依赖，另外一种是属性的相互依赖。</li>
</ul>
<h2 id="属性的相互依赖"><a href="#属性的相互依赖" class="headerlink" title="属性的相互依赖"></a>属性的相互依赖</h2><ul>
<li>属性的相互依赖就是A类的属性中有B，B类的属性中有A，如下：<ul>
<li>这里仅仅是两个类的循环依赖，当然还有更多的类相互依赖</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> B b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> A a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="构造器的依赖"><a href="#构造器的依赖" class="headerlink" title="构造器的依赖"></a>构造器的依赖</h2><ul>
<li>构造器的依赖就是A类的构造器需要传入B类对象，B的构造器需要传入A类对象，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(B b)</span></span>&#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">B</span><span class="params">(A a)</span></span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h1><ul>
<li>Spring只能解决属性的循环依赖，构造器的循环依赖是不能解决的。</li>
<li>spring中解决循环依赖的核心思想就是利用<strong>三级缓存</strong>，先创建Bean，后为各个属性赋值具体什么是三级缓存呢？</li>
</ul>
<h2 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h2><ul>
<li>三级缓存的实现在<code>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry</code>类中，如下：<ul>
<li><code>private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);</code>：单例对象缓存池，beanName-&gt;Bean，其中存储的就是实例化，属性赋值成功之后的单例对象</li>
<li><code>private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;&gt;(16);</code>：早期的单例对象，beanName-&gt;Bean，其中存储的是实例化之后，属性未赋值的单例对象。</li>
<li><code>private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;&gt;(16);</code>：单例工厂的缓存，beanName-&gt;ObjectFactory</li>
</ul>
</li>
</ul>
<h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><ul>
<li>在分析之前，先写个实例，制造循环依赖，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Husband</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> Integer age;</div><div class="line">    <span class="comment">//丈夫依赖妻子</span></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> Wife wife;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Wife <span class="title">getWife</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> wife;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWife</span><span class="params">(Wife wife)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.wife = wife;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wife</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> Integer age;</div><div class="line">    <span class="comment">//妻子依赖丈夫</span></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> Husband husband;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Husband <span class="title">getHusband</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> husband;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHusband</span><span class="params">(Husband husband)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.husband = husband;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>解决循环依赖是在容器启动的时候实现的，我们分析源码可以知道，容器启动初始化的大部分过程都是在refresh方法中实现的，因此我们从refresh入口即可，流程如下：<ul>
<li>下面只分析与循环依赖有关的流程，其他的会省略</li>
</ul>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">1、finishBeanFactoryInitialization(beanFactory)：实例化所有饿加载的单例Bean</div><div class="line"></div><div class="line">2、org.springframework.beans.factory.config.ConfigurableListableBeanFactory#preInstantiateSingletons：真正的实现的方法</div><div class="line"></div><div class="line">3、org.springframework.beans.factory.support.AbstractBeanFactory#getBean：调用方法获取Bean</div><div class="line"></div><div class="line">4、org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean：真正getBean的方法</div><div class="line">	4.1 Object sharedInstance = getSingleton(beanName)：先尝试从三级缓存中获取Bean，第一次执行缓存中肯定是没有</div><div class="line">	4.2 BeanFactory parentBeanFactory = getParentBeanFactory()：检查父工厂中是否存在当前Bean</div><div class="line">	4.3 markBeanAsCreated(beanName)：将Bean放入alreadyCreated中，表示当前Bean已经创建了</div><div class="line">	4.4 String[] dependsOn = mbd.getDependsOn()：检查dependOn</div><div class="line">	4.5 Object bean = resolveBeforeInstantiation(beanName, mbdToUse)：执行后置处理器，在初始化之前执行</div><div class="line">	4.6 sharedInstance = getSingleton(beanName, () -&gt; &#123;：调用getSingleton方法，尝试从单例缓存池中获取Bean</div><div class="line">		4.6.1 Object singletonObject = this.singletonObjects.get(beanName)：从单例缓存池中获取</div><div class="line">		4.6.2 if (singletonObject == null) &#123;：如果缓存池中没有，那么执行后续的逻辑，如果有直接返回即可</div><div class="line">		4.6.3 单例池中没有的逻辑：singletonObject = singletonFactory.getObject()：调用createBean方法创建Bean</div><div class="line">		4.6.4 addSingleton(beanName, singletonObject)：创建Bean成功之后将其添加到单例缓存池中，并且将其从二三级缓存中移除（singletonFactories，earlySingletonObjects）</div><div class="line">		</div><div class="line">	4.7 return createBean(beanName, mbd, args)：三级缓存和父工厂中都没有当前的这个Bean，此时进入创建Bean的过程</div><div class="line">	</div><div class="line">5、org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean：真正执行创建Bean的逻辑</div><div class="line">	5.1 instanceWrapper = createBeanInstance(beanName, mbd, args)：调用构造器创建Bean，此时的Bean称为早期Bean，还未进行属性赋值</div><div class="line">	5.2 applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName)：执行MergedBeanDefinitionPostProcessor，也是一种后置处理器</div><div class="line">	5.3 addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean))：将早期Bean放入三级缓存singletonFactories中，并且从早期对象缓存earlySingletonObjects中删除，用来解决循环依赖。</div><div class="line">	if (!this.singletonObjects.containsKey(beanName)) &#123;</div><div class="line">				this.singletonFactories.put(beanName, singletonFactory);</div><div class="line">				this.earlySingletonObjects.remove(beanName);</div><div class="line">				this.registeredSingletons.add(beanName);</div><div class="line">			&#125;</div><div class="line">	5.4 populateBean(beanName, mbd, instanceWrapper)：此时执行当前Bean的属性赋值</div><div class="line">	</div><div class="line">6、org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#populateBean：进行属性的赋值</div><div class="line">	6.1 if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) ：执行实例化之后的后置处理器</div><div class="line">	6.2 for (BeanPostProcessor bp : getBeanPostProcessors()) ：执行属性赋值之前的后置处理器，返回PropertyVlaue，我们知道@Autowired注解就是后置处理器实现的，主要的逻辑就是在postProcessProperties方法中，并且我们的例子中是自动注入Wife和Husband的，所以逻辑一定是在这里实现的，进入</div><div class="line"></div><div class="line">7、org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#postProcessProperties：@Autowired注解解析，为标注该注解的属性赋值</div><div class="line">	7.1 org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement#inject：真正执行赋值的逻辑</div><div class="line">		7.1.1 value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter)：解析依赖</div><div class="line"></div><div class="line">8、org.springframework.beans.factory.support.DefaultListableBeanFactory#resolveDependency：解析标注@Autowired的依赖</div><div class="line">	8.1 org.springframework.beans.factory.support.DefaultListableBeanFactory#doResolveDependency：真正解析逻辑</div><div class="line">	8.2 instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, this)：从容器中获取指定的Bean，内部调用的又是getBean方法</div><div class="line"></div><div class="line">9、org.springframework.beans.factory.config.DependencyDescriptor#resolveCandidate：至此，又回到了getBean这个方法，从ioc容器中获取指定的Bean</div></pre></td></tr></table></figure>
<ul>
<li>流程图如下：<ul>
<li>红色是关于三级缓存的操作</li>
<li>蓝色是关于后置处理器的操作</li>
<li>唯一一个淡黄色是解决循环依赖的关键，重新调用doGetBean</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/chenjiabing666/BlogImage/blob/master/circleDependency.png?raw=true" alt=""></p>
<h2 id="结合上述例子分析"><a href="#结合上述例子分析" class="headerlink" title="结合上述例子分析"></a>结合上述例子分析</h2><p>1、Husband创建Bean，先判断缓存池中是否存在，存在直接返回，不存在进入createBean创建的流程，调用构造方法创建一个早期的Bean【未进行属性赋值】，创建成功将其放入二级缓存<code>earlySingletonObjects</code>中，之后又调用<code>addSingletonFactory</code>方法将其放入三级缓存中并且将二级缓存中的移除，之后调用<code>populateBean</code>为属性赋值，在@Autowired的后置处理器中查找需要注入的依赖，发现Husband中的一个属性<code>Wife</code>，因此调用<code>getBean</code>方法从容器中获取，但是此时的Wife还未创建，因此又进入了doGetBean的流程，但是此时Wife并没有创建，因此在一二三级缓存中不能获取，又执行createBean方法创建Wife，同样调用构造方法创建一个早期Bean放入二级缓存中，调用<code>addSingletonFactory</code>放入三级缓存并移除二级缓存，然后调用<code>populateBean</code>方法为Wife属性赋值，在@Autowired的后置处理器中查找需要注入的依赖，发现Wife类中有一个属性是Husband，因此调用getBean方法，再次调用doGetBean获取Husband，但是此时的Husband已经创建成功【未赋值】，存放在三级缓存中，因此直接从三级缓存中取出Husband赋值给Wife属性，至此Wife属性已经赋值成功，直接添加到一级缓存（<code>singletonObjects</code>）中并且移除三级缓存，直接返回给Husband赋值，因此Husband中的属性也持有了Wife的引用，都创建并且赋值成功了。</p>
<h1 id="为什么不能解决构造器的循环依赖"><a href="#为什么不能解决构造器的循环依赖" class="headerlink" title="为什么不能解决构造器的循环依赖"></a>为什么不能解决构造器的循环依赖</h1><ul>
<li>Spring解决循环依赖主要是依赖三级缓存，<strong>但是的在调用构造方法之前还未将其放入三级缓存之中</strong>，因此后续的依赖调用构造方法的时候并不能从三级缓存中获取到依赖的Bean，因此不能解决。</li>
</ul>
<h1 id="Spring为什么不能解决多例的循环依赖"><a href="#Spring为什么不能解决多例的循环依赖" class="headerlink" title="Spring为什么不能解决多例的循环依赖"></a>Spring为什么不能解决多例的循环依赖</h1><ul>
<li>多实例Bean是每次调用一次getBean都会执行一次构造方法并且未属性赋值，根本没有三级缓存，因此解决循环依赖。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是循环依赖&quot;&gt;&lt;a href=&quot;#什么是循环依赖&quot; class=&quot;headerlink&quot; title=&quot;什么是循环依赖&quot;&gt;&lt;/a&gt;什么是循环依赖&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;循环依赖分为两种，一种是构造器的相互依赖，另外一种是属性的相互依赖。&lt;/li&gt;
&lt;/ul
    
    </summary>
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring事务源码解析</title>
    <link href="http://chenjiabing666.github.io/2019/07/07/Spring%E4%BA%8B%E5%8A%A1%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://chenjiabing666.github.io/2019/07/07/Spring事务源码解析/</id>
    <published>2019-07-07T11:41:07.000Z</published>
    <updated>2019-07-20T10:21:12.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="配置注解版事务"><a href="#配置注解版事务" class="headerlink" title="配置注解版事务"></a>配置注解版事务</h1><h2 id="事务管理器"><a href="#事务管理器" class="headerlink" title="事务管理器"></a>事务管理器</h2><ul>
<li>事务管理器的接口是<code>PlatformTransactionManager</code>，其中定义了三个接口方法如下：<ul>
<li><code>TransactionStatus getTransaction(@Nullable TransactionDefinition definition)      throws TransactionException</code>：获取事务，如果当前没有事务，那么就根据传播级别创建一个事务。<ul>
<li><code>TransactionDefinition</code>：其中定义了事务的传播属性，比如默认的传播属性（当前没有事务就开启事务）等。</li>
</ul>
</li>
<li><code>void commit(TransactionStatus status) throws TransactionException;</code>：提交事务<ul>
<li><code>TransactionStatus</code>：其中定义了一些事务的状态和查询、判断事务状态的方法</li>
</ul>
</li>
<li><code>void rollback(TransactionStatus status) throws TransactionException;</code>：回滚事务</li>
</ul>
</li>
<li><code>PlatformTransactionManager</code>的实现类有很多，比如结合JDBC操作的<code>DataSourceTransactionManager</code>、配置JTA、Hibernate的事务管理器。</li>
</ul>
<h2 id="注入事务管理器【JDBC】"><a href="#注入事务管理器【JDBC】" class="headerlink" title="注入事务管理器【JDBC】"></a>注入事务管理器【JDBC】</h2><ul>
<li>注入<code>PlatformTransactionManager</code>，步骤如下：<ul>
<li>注入数据源，这里我们使用的是结合JDBC，因此需要注入对应的事务管理器<code>DataSourceTransactionManager</code></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//注入数据源，这里使用的是阿里的Druid，这里只是简单的配置</span></div><div class="line"><span class="meta">@Bean</span></div><div class="line">   <span class="function"><span class="keyword">public</span> DruidDataSource <span class="title">dataSource</span><span class="params">()</span></span>&#123;</div><div class="line">       DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</div><div class="line">       dataSource.setUsername(<span class="string">"******"</span>);</div><div class="line">       dataSource.setPassword(<span class="string">"*****"</span>);</div><div class="line">       dataSource.setUrl(<span class="string">"******"</span>);</div><div class="line">       dataSource.setInitialSize(<span class="number">10</span>);</div><div class="line">       dataSource.setMaxActive(<span class="number">20</span>);</div><div class="line">       dataSource.setMaxIdle(<span class="number">100000</span>);</div><div class="line">       <span class="keyword">return</span> dataSource;</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="comment">//注入事务管理器</span></div><div class="line"><span class="meta">@Bean</span></div><div class="line">   <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">(DataSource dataSource)</span> </span>&#123;</div><div class="line">       DataSourceTransactionManager dataSourceTransactionManager = <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</div><div class="line">       <span class="keyword">return</span> dataSourceTransactionManager;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li>开启事务，使用<code>@EnableTransactionManagement</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"cn.tedu.demo.*"</span>&#125;)</div><div class="line"><span class="meta">@EnableTransactionManagement</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<h1 id="源码解析事务"><a href="#源码解析事务" class="headerlink" title="源码解析事务"></a>源码解析事务</h1><h2 id="必知的知识和类"><a href="#必知的知识和类" class="headerlink" title="必知的知识和类"></a>必知的知识和类</h2><h3 id="PlatformTransactionManager"><a href="#PlatformTransactionManager" class="headerlink" title="PlatformTransactionManager"></a>PlatformTransactionManager</h3><ul>
<li>事务管理器的接口，其中定义一些事务的方法，有提交，回滚，获取事务的方法。</li>
<li>实现类如下：<ul>
<li><code>DataSourceTransactionManager</code>：适用于JDBC事务的管理</li>
<li><code>JtaTransactionManager</code>：适用于多数据源的事务管理，实现强一致性事务</li>
</ul>
</li>
</ul>
<h3 id="TransactionDefinition"><a href="#TransactionDefinition" class="headerlink" title="TransactionDefinition"></a>TransactionDefinition</h3><ul>
<li>该接口主要定义了事务的一些属性，比如事务的传播行为，隔离级别等数据。</li>
</ul>
<h3 id="EnableTransactionManagement"><a href="#EnableTransactionManagement" class="headerlink" title="@EnableTransactionManagement"></a>@EnableTransactionManagement</h3><ul>
<li>此注解的源码如下，其实真正起作用的就是<code>@Import(TransactionManagementConfigurationSelector.class)</code>，使用<code>@Import</code>这个注解向容器中注入了其他的Bean，详情请看我的<a href="https://chenjiabing666.github.io/2019/06/23/Spring%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/">Spring注解版开发，其中有@Import的使用</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Import</span>(TransactionManagementConfigurationSelector.class)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableTransactionManagement &#123;</div></pre></td></tr></table></figure>
<h3 id="TransactionManagementConfigurationSelector"><a href="#TransactionManagementConfigurationSelector" class="headerlink" title="TransactionManagementConfigurationSelector"></a>TransactionManagementConfigurationSelector</h3><ul>
<li>这个实现了<code>ImportSelector</code>，结合@Import注解使用，是@Import注解的注入Bean的其中一种方式，有一个必须重载的方法，如下：<ul>
<li>此方法返回的<code>BeanName</code>的数组的全部Bean将会被注入到容器中</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String[] selectImports(AnnotationMetadata importingClassMetadata);</div></pre></td></tr></table></figure>
<ul>
<li>TransactionManagementConfigurationSelector对上面的这个方法重写了，如下：<ul>
<li>主要流程就是根据<code>@EnableTransactionManagement</code>中mode属性返回对应的BeanName，如果值是<code>PROXY</code>【默认】，那么就会注入<code>AutoProxyRegistrar</code>、<code>ProxyTransactionManagementConfiguration</code>这两个Bean，那么这个方法的作用就是如此，因此我们需要看看注入的两个Bean到底是什么作用？</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">protected</span> String[] selectImports(AdviceMode adviceMode) &#123;</div><div class="line">	<span class="keyword">switch</span> (adviceMode) &#123;</div><div class="line">		<span class="keyword">case</span> PROXY:</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;AutoProxyRegistrar.class.getName(),</div><div class="line">					ProxyTransactionManagementConfiguration.class.getName()&#125;;</div><div class="line">		<span class="keyword">case</span> ASPECTJ:</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;determineTransactionAspectClass()&#125;;</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">determineTransactionAspectClass</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> (ClassUtils.isPresent(<span class="string">"javax.transaction.Transactional"</span>, getClass().getClassLoader()) ?</div><div class="line">			TransactionManagementConfigUtils.JTA_TRANSACTION_ASPECT_CONFIGURATION_CLASS_NAME :</div><div class="line">			TransactionManagementConfigUtils.TRANSACTION_ASPECT_CONFIGURATION_CLASS_NAME);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="AutoProxyRegistrar"><a href="#AutoProxyRegistrar" class="headerlink" title="AutoProxyRegistrar"></a>AutoProxyRegistrar</h4><ul>
<li>该类实现了<code>ImportBeanDefinitionRegistrar</code>，主要的作用就是根据<code>@EnableTransactionManagement</code>属性中的<code>mode</code>和<code>proxyTargetClass</code>，注入对应的<code>AutoProxyCreator</code>【APC】，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//importingClassMetadata：其中封装了配置类的所有注解</span></div><div class="line"><span class="comment">//registry：用于注入BeanDefintion</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</div><div class="line">       <span class="comment">//标记</span></div><div class="line">	<span class="keyword">boolean</span> candidateFound = <span class="keyword">false</span>;</div><div class="line">   	<span class="comment">//获取所有的注解类型</span></div><div class="line">	Set&lt;String&gt; annoTypes = importingClassMetadata.getAnnotationTypes();</div><div class="line">       <span class="comment">//遍历注解</span></div><div class="line">	<span class="keyword">for</span> (String annoType : annoTypes) &#123;</div><div class="line">           <span class="comment">//获取指定注解的全部属性的值</span></div><div class="line">		AnnotationAttributes candidate = AnnotationConfigUtils.attributesFor(importingClassMetadata, annoType);</div><div class="line">		<span class="keyword">if</span> (candidate == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		&#125;</div><div class="line">           <span class="comment">//获取对应的mode和proxyTargetClass属性的值</span></div><div class="line">		Object mode = candidate.get(<span class="string">"mode"</span>);</div><div class="line">		Object proxyTargetClass = candidate.get(<span class="string">"proxyTargetClass"</span>);</div><div class="line">           <span class="comment">//如果这些值都存在，那么可以判定配置类上标注了`@EnableTransactionManagement`这个注解</span></div><div class="line">		<span class="keyword">if</span> (mode != <span class="keyword">null</span> &amp;&amp; proxyTargetClass != <span class="keyword">null</span> &amp;&amp; AdviceMode.class == mode.getClass() &amp;&amp;	</div><div class="line">				Boolean.class == proxyTargetClass.getClass()) &#123;</div><div class="line">               <span class="comment">//标记设置为true</span></div><div class="line">			candidateFound = <span class="keyword">true</span>;</div><div class="line">               <span class="comment">//根据mode的值，注入不同的APC</span></div><div class="line">			<span class="keyword">if</span> (mode == AdviceMode.PROXY) &#123;</div><div class="line">				AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry);</div><div class="line">				<span class="keyword">if</span> ((Boolean) proxyTargetClass) &#123;</div><div class="line">					AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</div><div class="line">					<span class="keyword">return</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (!candidateFound &amp;&amp; logger.isInfoEnabled()) &#123;</div><div class="line">		String name = getClass().getSimpleName();</div><div class="line">		logger.info(String.format(<span class="string">"%s was imported but no annotations were found "</span> +</div><div class="line">				<span class="string">"having both 'mode' and 'proxyTargetClass' attributes of type "</span> +</div><div class="line">				<span class="string">"AdviceMode and boolean respectively. This means that auto proxy "</span> +</div><div class="line">				<span class="string">"creator registration and configuration may not have occurred as "</span> +</div><div class="line">				<span class="string">"intended, and components may not be proxied as expected. Check to "</span> +</div><div class="line">				<span class="string">"ensure that %s has been @Import'ed on the same class where these "</span> +</div><div class="line">				<span class="string">"annotations are declared; otherwise remove the import of %s "</span> +</div><div class="line">				<span class="string">"altogether."</span>, name, name, name));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>其中核心的代码就是注入不同的APC的代码，如下：</p>
<ul>
<li><p><code>AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry);</code></p>
<ul>
<li>实际作用的源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//cls是InfrastructureAdvisorAutoProxyCreator.class，APC的一种实现类</span></div><div class="line"><span class="comment">//注入的BeanName是org.springframework.aop.config.internalAutoProxyCreator</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerOrEscalateApcAsRequired</span><span class="params">(</span></span></div><div class="line">			Class&lt;?&gt; cls, BeanDefinitionRegistry registry, @Nullable Object source) &#123;</div><div class="line"></div><div class="line">		Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</div><div class="line">		<span class="comment">//判断对应的APC是否已经注入了</span></div><div class="line">		<span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</div><div class="line">			BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</div><div class="line">			<span class="keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;</div><div class="line">				<span class="keyword">int</span> currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());</div><div class="line">				<span class="keyword">int</span> requiredPriority = findPriorityForClass(cls);</div><div class="line">				<span class="keyword">if</span> (currentPriority &lt; requiredPriority) &#123;</div><div class="line">					apcDefinition.setBeanClassName(cls.getName());</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">    	<span class="comment">//没有注入，直接使用RootBeanDefinition注入，BeanName是org.springframework.aop.config.internalAutoProxyCreator</span></div><div class="line">		RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(cls);</div><div class="line">		beanDefinition.setSource(source);</div><div class="line">		beanDefinition.getPropertyValues().add(<span class="string">"order"</span>, Ordered.HIGHEST_PRECEDENCE);</div><div class="line">		beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</div><div class="line">		registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</div><div class="line">		<span class="keyword">return</span> beanDefinition;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><code>AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</code>：强制使用子类代理【cglib代理】，实际作用的源码如下：</p>
<ul>
<li>实际的作用就是设置了<strong>proxyTargetClass</strong>为true</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forceAutoProxyCreatorToUseClassProxying</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</div><div class="line">			BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</div><div class="line">			definition.getPropertyValues().add(<span class="string">"proxyTargetClass"</span>, Boolean.TRUE);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>该类是TransactionManagementSlector选择器注入的类，主要作用就是根据@EnableTranactionMangement注解中的mode和proxyTarget的值注入（AutoProxyCreator）【简称APC】，实际的APC的类型是<code>InfrastructureAdvisorAutoProxyCreator</code></li>
</ul>
<h4 id="ProxyTransactionManagementConfiguration"><a href="#ProxyTransactionManagementConfiguration" class="headerlink" title="ProxyTransactionManagementConfiguration"></a>ProxyTransactionManagementConfiguration</h4><ul>
<li>该类是一个配置类，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ProxyTransactionManagementConfiguration配置类</span></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTransactionManagementConfiguration</span> <span class="keyword">extends</span> <span class="title">AbstractTransactionManagementConfiguration</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//AbstractTransactionManagementConfiguration</span></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTransactionManagementConfiguration</span> <span class="keyword">implements</span> <span class="title">ImportAware</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<ul>
<li>从上面的源码可以知道抽象的<code>AbstractTransactionManagementConfiguration</code>类实现了<code>ImportAware</code>，那么其中的重载的方法一定是很重要的，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImportMetadata</span><span class="params">(AnnotationMetadata importMetadata)</span> </span>&#123;</div><div class="line">       <span class="comment">//获取@EnableTransactionMangement的属性值赋值给enableTx</span></div><div class="line">	<span class="keyword">this</span>.enableTx = AnnotationAttributes.fromMap(</div><div class="line">			importMetadata.getAnnotationAttributes(EnableTransactionManagement.class.getName(), <span class="keyword">false</span>));</div><div class="line">       <span class="comment">//如果为null，抛出异常</span></div><div class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.enableTx == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</div><div class="line">				<span class="string">"@EnableTransactionManagement is not present on importing class "</span> + importMetadata.getClassName());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>上述讲解了<code>AbstractTransactionManagementConfiguration</code>中的一个重要实现，其实就是将<code>@EnableTransactionMangement</code>的属性值赋值给enableTx</li>
<li>从<code>ProxyTransactionManagementConfiguration</code>的源码可以知道，其实就是向容器中注入了三个Bean，分别是<code>org.springframework.transaction.interceptor.BeanFactoryTransactionAttributeSourceAdvisor</code>、<code>org.springframework.transaction.interceptor.TransactionAttributeSource</code>、<code>org.springframework.transaction.interceptor.TransactionInterceptor</code></li>
</ul>
<h4 id="ImportAware"><a href="#ImportAware" class="headerlink" title="ImportAware"></a>ImportAware</h4><ul>
<li><p>该类的作用是获取标注在实现了该接口的配置类上的所有注解的元数据，包括注解的属性，值，类型等信息。</p>
</li>
<li><p>ImportAware同样实现了Aware接口，但是这个和BeanFactoryAware、ResourceLoaderAware等不同的是，这个接口必须是由配置类【即是标注了@Configuration注解】实现，并且需要结合@Import注解使用才能生效，否则不能生效，如下的使用方式将会生效。</p>
<ul>
<li><strong>一定要结合@Import使用，可以直接导入配置类，也可以使用selector方式的注入，总之是要结合@Import注解使用，否则不能生效</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"cn.tedu.demo.*"</span>&#125;)</div><div class="line"><span class="meta">@EnableTransactionManagement</span></div><div class="line"><span class="meta">@Import</span>(value = &#123;DruidConfig.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig</span>  </span>&#123;&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidConfig</span> <span class="keyword">implements</span> <span class="title">ImportAware</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImportMetadata</span><span class="params">(AnnotationMetadata importMetadata)</span> </span>&#123;</div><div class="line">        System.out.println(importMetadata);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="InfrastructureAdvisorAutoProxyCreator【-EnableTransactionManagement导入】"><a href="#InfrastructureAdvisorAutoProxyCreator【-EnableTransactionManagement导入】" class="headerlink" title="InfrastructureAdvisorAutoProxyCreator【@EnableTransactionManagement导入】"></a>InfrastructureAdvisorAutoProxyCreator【@EnableTransactionManagement导入】</h3><ul>
<li><p><strong>该APC是在@EnableTransactionMangement注解作用下注入到ioc容器中的</strong></p>
</li>
<li><p>代理创建器，继承了<code>AbstractAutoProxyCreator</code>，这个和注解版AOP的代理创建器（<code>AnnotationAwareAspectJAutoProxyCreator</code>）继承的是一个类，主要的作用就是<strong>创建代理对象</strong>，我们之前也是知道事务的底层其实就是使用AOP进行操作的，继承的关系图如下：</p>
</li>
</ul>
<p><img src="https://github.com/chenjiabing666/BlogImage/blob/master/t1.png?raw=true" alt=""></p>
<ul>
<li><strong>从上面的继承关系图可以很清晰的看到，这个类实现了不少的关于Bean生命周期的接口，因此我们只需要把实现的这些接口打上断点，即可清楚的分析出执行的流程了。这个和AOP讲解的类似，有些东西就不再一一讲述了</strong></li>
<li>主要的功能就是为标注了<code>@Transactional</code>创建代理对象，其中最重要的逻辑就是找到候选的增强器【事务的实现注入的增强器就是BeanFactoryTransactionAttributeSourceAdvisor】，主要的逻辑如下：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">1）在org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#wrapIfNecessary方法中是创建代理对象的主要方法，不过在这之前需要获取所有适用当前Bean的所有增强器（Advisor），调用的是Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);这个方法</div><div class="line">	1.1) 进入org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator#getAdvicesAndAdvisorsForBean方法，调用的是List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName)这段代码，获取可用的增强器</div><div class="line">	1.2） 进入，实际调用的是List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName)这段代码，获取能够作用在beanClass的增强器</div><div class="line">	1.3）进入，实际调用的是AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass)这段代码</div><div class="line">	1.4）一路跟进，最终到了org.springframework.aop.support.AopUtils#canApply(org.springframework.aop.Pointcut, ava.lang.Class&lt;?&gt;, boolean)，主要的逻辑开始了</div><div class="line">		1.4.1） 最重要的代码便是循环获取的接口，获取其中的方法，调用methodMatcher.matches(method, targetClass)匹配，源码如下：</div><div class="line">		for (Class&lt;?&gt; clazz : classes) &#123;</div><div class="line">			Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);</div><div class="line">			for (Method method : methods) &#123;</div><div class="line">				if (introductionAwareMethodMatcher != null ?</div><div class="line">						introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) :</div><div class="line">						methodMatcher.matches(method, targetClass)) &#123;</div><div class="line">					return true;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		1.4.2）跟进，进入了org.springframework.transaction.interceptor.AbstractFallbackTransactionAttributeSource#computeTransactionAttribute方法，主要的逻辑就是先判断当前Bean的所有方法是否有@Transactional注解，之后判断该类头上是否有@Transactional注解</div><div class="line">		1.4.3）最重要的解析是否存在@Transactional注解的方法就是org.springframework.transaction.annotation.SpringTransactionAnnotationParser#parseTransactionAnnotation(java.lang.reflect.AnnotatedElement)，其中的逻辑如下：</div><div class="line"></div><div class="line">		public TransactionAttribute parseTransactionAnnotation(AnnotatedElement element) &#123;</div><div class="line">		//获取注解@Transactional中的属性值</div><div class="line">		AnnotationAttributes attributes = AnnotatedElementUtils.findMergedAnnotationAttributes(</div><div class="line">				element, Transactional.class, false, false);</div><div class="line">		//如果属性值不为空，表示该类获取方法上标注了@Transactional注解</div><div class="line">		if (attributes != null) &#123;</div><div class="line">			//解析注解的属性值，封装在TransactionAttribute中返回</div><div class="line">			return parseTransactionAnnotation(attributes);</div><div class="line">		&#125;</div><div class="line">		else &#123;</div><div class="line">			return null;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	//解析注解的属性值，将其封装在TransactionAttribute中</div><div class="line">protected TransactionAttribute parseTransactionAnnotation(AnnotationAttributes attributes) &#123;</div><div class="line">		RuleBasedTransactionAttribute rbta = new RuleBasedTransactionAttribute();</div><div class="line"></div><div class="line">		Propagation propagation = attributes.getEnum("propagation");</div><div class="line">		rbta.setPropagationBehavior(propagation.value());</div><div class="line">		Isolation isolation = attributes.getEnum("isolation");</div><div class="line">		rbta.setIsolationLevel(isolation.value());</div><div class="line">		rbta.setTimeout(attributes.getNumber("timeout").intValue());</div><div class="line">		rbta.setReadOnly(attributes.getBoolean("readOnly"));</div><div class="line">		rbta.setQualifier(attributes.getString("value"));</div><div class="line"></div><div class="line">		List&lt;RollbackRuleAttribute&gt; rollbackRules = new ArrayList&lt;&gt;();</div><div class="line">		for (Class&lt;?&gt; rbRule : attributes.getClassArray("rollbackFor")) &#123;</div><div class="line">			rollbackRules.add(new RollbackRuleAttribute(rbRule));</div><div class="line">		&#125;</div><div class="line">		for (String rbRule : attributes.getStringArray("rollbackForClassName")) &#123;</div><div class="line">			rollbackRules.add(new RollbackRuleAttribute(rbRule));</div><div class="line">		&#125;</div><div class="line">		for (Class&lt;?&gt; rbRule : attributes.getClassArray("noRollbackFor")) &#123;</div><div class="line">			rollbackRules.add(new NoRollbackRuleAttribute(rbRule));</div><div class="line">		&#125;</div><div class="line">		for (String rbRule : attributes.getStringArray("noRollbackForClassName")) &#123;</div><div class="line">			rollbackRules.add(new NoRollbackRuleAttribute(rbRule));</div><div class="line">		&#125;</div><div class="line">		rbta.setRollbackRules(rollbackRules);</div><div class="line"></div><div class="line">		return rbta;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="SpringTransactionAnnotationParser"><a href="#SpringTransactionAnnotationParser" class="headerlink" title="SpringTransactionAnnotationParser"></a>SpringTransactionAnnotationParser</h3><ul>
<li>@Transactional注解解析器，主要的作用就是解析指定类或者方法【标注有@Transactional注解的】上的@Transactional注解中的属性值，将其封装在 <code>TransactionAttribute</code>中，主要的逻辑如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> TransactionAttribute <span class="title">parseTransactionAnnotation</span><span class="params">(AnnotatedElement element)</span> </span>&#123;</div><div class="line">    	<span class="comment">//获取注解中的所有属性值</span></div><div class="line">		AnnotationAttributes attributes = AnnotatedElementUtils.findMergedAnnotationAttributes(</div><div class="line">				element, Transactional.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">		<span class="keyword">if</span> (attributes != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//如果属性不为空，调用parseTransactionAnnotation方法封装</span></div><div class="line">			<span class="keyword">return</span> parseTransactionAnnotation(attributes);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">parseTransactionAnnotation</span><span class="params">(AnnotationAttributes attributes)</span> </span>&#123;</div><div class="line">		RuleBasedTransactionAttribute rbta = <span class="keyword">new</span> RuleBasedTransactionAttribute();</div><div class="line"></div><div class="line">    	<span class="comment">//封装传播行为和隔离级别</span></div><div class="line">		Propagation propagation = attributes.getEnum(<span class="string">"propagation"</span>);</div><div class="line">		rbta.setPropagationBehavior(propagation.value());</div><div class="line">		Isolation isolation = attributes.getEnum(<span class="string">"isolation"</span>);</div><div class="line">		rbta.setIsolationLevel(isolation.value());</div><div class="line">		rbta.setTimeout(attributes.getNumber(<span class="string">"timeout"</span>).intValue());</div><div class="line">		rbta.setReadOnly(attributes.getBoolean(<span class="string">"readOnly"</span>));</div><div class="line">		rbta.setQualifier(attributes.getString(<span class="string">"value"</span>));</div><div class="line">		</div><div class="line">    	<span class="comment">//封装回滚规则</span></div><div class="line">		List&lt;RollbackRuleAttribute&gt; rollbackRules = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">		<span class="keyword">for</span> (Class&lt;?&gt; rbRule : attributes.getClassArray(<span class="string">"rollbackFor"</span>)) &#123;</div><div class="line">			rollbackRules.add(<span class="keyword">new</span> RollbackRuleAttribute(rbRule));</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span> (String rbRule : attributes.getStringArray(<span class="string">"rollbackForClassName"</span>)) &#123;</div><div class="line">			rollbackRules.add(<span class="keyword">new</span> RollbackRuleAttribute(rbRule));</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span> (Class&lt;?&gt; rbRule : attributes.getClassArray(<span class="string">"noRollbackFor"</span>)) &#123;</div><div class="line">			rollbackRules.add(<span class="keyword">new</span> NoRollbackRuleAttribute(rbRule));</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span> (String rbRule : attributes.getStringArray(<span class="string">"noRollbackForClassName"</span>)) &#123;</div><div class="line">			rollbackRules.add(<span class="keyword">new</span> NoRollbackRuleAttribute(rbRule));</div><div class="line">		&#125;</div><div class="line">		rbta.setRollbackRules(rollbackRules);</div><div class="line"></div><div class="line">		<span class="keyword">return</span> rbta;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="AnnotationTransactionAttributeSource【-EnableTransactionManagement导入】"><a href="#AnnotationTransactionAttributeSource【-EnableTransactionManagement导入】" class="headerlink" title="AnnotationTransactionAttributeSource【@EnableTransactionManagement导入】"></a>AnnotationTransactionAttributeSource【@EnableTransactionManagement导入】</h3><ul>
<li><p>该类的作用就是获取目标类和目标方法上的@Transactional注解的属性信息，封装在缓存中。</p>
</li>
<li><p>实现了<code>TransactionAttributeSource</code>，简单的说这个类中封装了所有类、方法上标注的@Transactional注解的属性值【以TransactionAttribute的属性保存在<code>private final Map&lt;Object, TransactionAttribute&gt; attributeCache = new ConcurrentHashMap&lt;&gt;(1024)</code>，key是通过类，方法生成的<code>MethodClassKey</code>对象，value是TransactionAttribute】</p>
</li>
<li><p>重要的属性：</p>
<ul>
<li><strong>attributeCache中存储了所有类的方法的对应的@Transactional注解属性的值，后续在执行事务的时候，就是直接从这个缓存中直接获取的。</strong></li>
</ul>
</li>
<li><p>其中有几个重要的方法，如下：</p>
<ul>
<li><code>public TransactionAttribute getTransactionAttribute(Method method, @Nullable Class&lt;?&gt; targetClass)</code>：根据类、方法获取指定的TransactionAttribute ，具体的实现在<code>AbstractFallbackTransactionAttributeSource</code>类中，源码如下：<ul>
<li><strong>其中findTransactionAttribute()方法没有继续跟进，因为其中的执行逻辑就是使用注解解析器（SpringTransactionalAnnotationParser）进行对@Transactional注解的解析，封装在TransactionAttribute返回。</strong></li>
<li><strong>attributeCache</strong>中存储了所有类的方法的对应的@Transactional注解属性的值，后续在执行事务的时候，就是直接从这个缓存中直接获取的。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//method：指定的方法，targetClass指定的类</span></div><div class="line"><span class="function"><span class="keyword">public</span> TransactionAttribute <span class="title">getTransactionAttribute</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>&#123;</div><div class="line">    	<span class="comment">//如果是Object，直接返回null</span></div><div class="line">		<span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// 第一步先直接从缓存中取值，如果存在，直接返回即可</span></div><div class="line">		Object cacheKey = getCacheKey(method, targetClass);</div><div class="line">		TransactionAttribute cached = <span class="keyword">this</span>.attributeCache.get(cacheKey);</div><div class="line">		<span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="comment">// Value will either be canonical value indicating there is no transaction attribute,</span></div><div class="line">			<span class="comment">// or an actual transaction attribute.</span></div><div class="line">			<span class="keyword">if</span> (cached == NULL_TRANSACTION_ATTRIBUTE) &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				<span class="keyword">return</span> cached;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			<span class="comment">//如果缓存中没有，那么需要调用computeTransactionAttribute方法去ioc中解析</span></div><div class="line">			TransactionAttribute txAttr = computeTransactionAttribute(method, targetClass);</div><div class="line">			<span class="comment">//将取出的值存入缓存中，下次再取就不需要解析了，直接取值即可</span></div><div class="line">			<span class="keyword">if</span> (txAttr == <span class="keyword">null</span>) &#123;</div><div class="line">				<span class="keyword">this</span>.attributeCache.put(cacheKey, NULL_TRANSACTION_ATTRIBUTE);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//获取方法的名称，全类名+方法名的形式</span></div><div class="line">				String methodIdentification = ClassUtils.getQualifiedMethodName(method, targetClass);</div><div class="line">				<span class="keyword">if</span> (txAttr <span class="keyword">instanceof</span> DefaultTransactionAttribute) &#123;</div><div class="line">					((DefaultTransactionAttribute) txAttr).setDescriptor(methodIdentification);</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</div><div class="line">					logger.trace(<span class="string">"Adding transactional method '"</span> + methodIdentification + <span class="string">"' with attribute: "</span> + txAttr);</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">this</span>.attributeCache.put(cacheKey, txAttr);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> txAttr;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**********************************computeTransactionAttribute****************/</span></div><div class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">computeTransactionAttribute</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>&#123;</div><div class="line">		<span class="comment">//如果方法不是public类型的，直接返回null</span></div><div class="line">		<span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">//如果method方法是在接口中定义的方法，那么获取接口实现类的方法。</span></div><div class="line">		Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);</div><div class="line"></div><div class="line">		<span class="comment">// 尝试获取目标方法上标注的@Transactional注解的属性【因为这个注解可以标注在方法和类上】</span></div><div class="line">		TransactionAttribute txAttr = findTransactionAttribute(specificMethod);</div><div class="line">		<span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">return</span> txAttr;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// 获取标注在类上的注解的属性</span></div><div class="line">		txAttr = findTransactionAttribute(specificMethod.getDeclaringClass());</div><div class="line">		<span class="keyword">if</span> (txAttr != <span class="keyword">null</span> &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123;</div><div class="line">			<span class="keyword">return</span> txAttr;</div><div class="line">		&#125;</div><div class="line">    </div><div class="line">		<span class="keyword">if</span> (specificMethod != method) &#123;</div><div class="line">			<span class="comment">// Fallback is to look at the original method.</span></div><div class="line">			txAttr = findTransactionAttribute(method);</div><div class="line">			<span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</div><div class="line">				<span class="keyword">return</span> txAttr;</div><div class="line">			&#125;</div><div class="line">			<span class="comment">// Last fallback is the class of the original method.</span></div><div class="line">			txAttr = findTransactionAttribute(method.getDeclaringClass());</div><div class="line">			<span class="keyword">if</span> (txAttr != <span class="keyword">null</span> &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123;</div><div class="line">				<span class="keyword">return</span> txAttr;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>protected TransactionAttribute findTransactionAttribute(Class&lt;?&gt; clazz)</code>：获取指定类上的@Transactional的属性值</p>
</li>
<li><p><code>protected TransactionAttribute findTransactionAttribute(Method method)</code>：获取指定方法的上的@Transactional属性的值</p>
</li>
<li><p><code>protected TransactionAttribute determineTransactionAttribute(AnnotatedElement element)</code>：获取@Transactional属性值的真正调用的方法，执行的逻辑就是使用前面讲过的SpringTransactionAnnotationParser进行注解的解析，代码如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">determineTransactionAttribute</span><span class="params">(AnnotatedElement element)</span> </span>&#123;</div><div class="line">    	<span class="comment">//遍历可用的事务注解解析器-&gt;this.annotationParsers</span></div><div class="line">		<span class="keyword">for</span> (TransactionAnnotationParser annotationParser : <span class="keyword">this</span>.annotationParsers) &#123;</div><div class="line">            <span class="comment">//调用解析的方法，进行解析</span></div><div class="line">			TransactionAttribute attr = annotationParser.parseTransactionAnnotation(element);</div><div class="line">			<span class="keyword">if</span> (attr != <span class="keyword">null</span>) &#123;</div><div class="line">				<span class="keyword">return</span> attr;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"><span class="comment">/***org.springframework.transaction.annotation.SpringTransactionAnnotationParser#parseTransactionAnnotation(java.lang.reflect.AnnotatedElement)****/</span></div><div class="line"><span class="function"><span class="keyword">public</span> TransactionAttribute <span class="title">parseTransactionAnnotation</span><span class="params">(AnnotatedElement element)</span> </span>&#123;</div><div class="line">    	<span class="comment">//直接获取元素上@Transactional注解的属性，如果获取都了，将其解析成TransactionAttribute对象返回即可</span></div><div class="line">		AnnotationAttributes attributes = AnnotatedElementUtils.findMergedAnnotationAttributes(</div><div class="line">				element, Transactional.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">		<span class="keyword">if</span> (attributes != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">return</span> parseTransactionAnnotation(attributes);</div><div class="line">		&#125;</div><div class="line">    	<span class="comment">//不存在该注解，那么直接返回null</span></div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<h3 id="BeanFactoryTransactionAttributeSourceAdvisor【-EnableTransactionManagement导入】"><a href="#BeanFactoryTransactionAttributeSourceAdvisor【-EnableTransactionManagement导入】" class="headerlink" title="BeanFactoryTransactionAttributeSourceAdvisor【@EnableTransactionManagement导入】"></a>BeanFactoryTransactionAttributeSourceAdvisor【@EnableTransactionManagement导入】</h3><ul>
<li>事务的增强器，其中封装了TransactionInterceptor、TransactionAttributeSource 、TransactionAttributeSourcePointcut</li>
</ul>
<h3 id="TransactionInterceptor【重要】"><a href="#TransactionInterceptor【重要】" class="headerlink" title="TransactionInterceptor【重要】"></a>TransactionInterceptor【重要】</h3><ul>
<li><p>事务拦截器，顾名思义，就是在方法执行之前进行一些操作，开启事务就是使用拦截器在调用方法之前开启的。</p>
</li>
<li><p>其中几个重要的方法，如下：</p>
<ul>
<li><code>public Object invoke(MethodInvocation invocation)</code>：jdk动态代理执行拦截器链的时候会执行的方法，内部真正调用的是父类<code>TransactionAspectSupport</code>的invokeWithinTransaction方法</li>
<li><code>protected Object invokeWithinTransaction(Method method, @Nullable Class&lt;?&gt; targetClass,      final InvocationCallback invocation)</code>：以事务的方式调用，关于事务的周期，比如开启，提交，回滚等等都是从此方法进入的，源码如下：<ul>
<li><strong><code>TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</code>：从此段代码进去是开启事务的逻辑</strong></li>
<li><strong><code>completeTransactionAfterThrowing(txInfo, ex);</code>：从此段代码进入是出现异常回滚事务的逻辑</strong></li>
<li><strong><code>commitTransactionAfterReturning(txInfo);</code>：从此段代码进入是提交事务的逻辑</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeWithinTransaction</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass,</span></span></div><div class="line">			<span class="keyword">final</span> InvocationCallback invocation) <span class="keyword">throws</span> Throwable &#123;</div><div class="line"></div><div class="line">		<span class="comment">// If the transaction attribute is null, the method is non-transactional.</span></div><div class="line">		TransactionAttributeSource tas = getTransactionAttributeSource();</div><div class="line">		<span class="keyword">final</span> TransactionAttribute txAttr = (tas != <span class="keyword">null</span> ? tas.getTransactionAttribute(method, targetClass) : <span class="keyword">null</span>);</div><div class="line">		<span class="keyword">final</span> PlatformTransactionManager tm = determineTransactionManager(txAttr);</div><div class="line">		<span class="keyword">final</span> String joinpointIdentification = methodIdentification(method, targetClass, txAttr);</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || !(tm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</div><div class="line">			<span class="comment">// Standard transaction demarcation with getTransaction and commit/rollback calls.</span></div><div class="line">			TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</div><div class="line">			Object retVal = <span class="keyword">null</span>;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				<span class="comment">// This is an around advice: Invoke the next interceptor in the chain.</span></div><div class="line">				<span class="comment">// This will normally result in a target object being invoked.</span></div><div class="line">				retVal = invocation.proceedWithInvocation();</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">				<span class="comment">// target invocation exception</span></div><div class="line">				completeTransactionAfterThrowing(txInfo, ex);</div><div class="line">				<span class="keyword">throw</span> ex;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">finally</span> &#123;</div><div class="line">				cleanupTransactionInfo(txInfo);</div><div class="line">			&#125;</div><div class="line">			commitTransactionAfterReturning(txInfo);</div><div class="line">			<span class="keyword">return</span> retVal;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="TransactionAttributeSourcePointcut"><a href="#TransactionAttributeSourcePointcut" class="headerlink" title="TransactionAttributeSourcePointcut"></a>TransactionAttributeSourcePointcut</h2><ul>
<li>事务的切入点，实现了MethodMatcher，主要用于方法的匹配</li>
<li>matches方法的源码如下：<ul>
<li>判断依据就是获取目标方法的@Transactional注解的属性，如果为null，那么就没有事务，反之则表示有事务开启。</li>
<li><code>getTransactionAttribute</code>方法调用的是<code>AbstractFallbackTransactionAttributeSource</code>类中的，主要逻辑是先从缓存中取，如果缓存中没有，通过<code>SpringTransactionalAnnotationParser</code>解析。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (TransactionalProxy.class.isAssignableFrom(targetClass) ||</div><div class="line">				PlatformTransactionManager.class.isAssignableFrom(targetClass) ||</div><div class="line">				PersistenceExceptionTranslator.class.isAssignableFrom(targetClass)) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line">		TransactionAttributeSource tas = getTransactionAttributeSource();</div><div class="line">    	<span class="comment">//获取目标方法的@Transactional注解的属性</span></div><div class="line">		<span class="keyword">return</span> (tas == <span class="keyword">null</span> || tas.getTransactionAttribute(method, targetClass) != <span class="keyword">null</span>);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h2 id="调用标注-Transactional方法"><a href="#调用标注-Transactional方法" class="headerlink" title="调用标注@Transactional方法"></a>调用标注@Transactional方法</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><ul>
<li>事务默认使用的是JDK的动态代理，并不是cglib代理</li>
<li>方法或者类上标注了@Transactional注解</li>
<li>配置类标注了@EnableTransactionManagement，开启事务</li>
</ul>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><ul>
<li>调用标注有@Transactional注解的方法，进入了<code>org.springframework.aop.framework.JdkDynamicAopProxy#invoke</code>方法，进行了JDK的动态代理，源码如下：<ul>
<li><strong><code>this.advised</code>：其实就是ProxyFactory（代理工厂），其中在创建代理对象的时候，封装了targetSource和事务增强器（BeanFactoryTransactionAttributeSourceAdvisor）</strong></li>
<li><strong>其中最重要的一段代码就是<code>List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</code>，获取适用于该方法的拦截器链</strong></li>
<li><strong><code>retVal = invocation.proceed();</code>：通过拦截器执行该方法，内部实现了事务的一些逻辑。</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//proxy 代理对象  method方法，args参数</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">		MethodInvocation invocation;</div><div class="line">		Object oldProxy = <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</div><div class="line">		<span class="comment">//获取targetSource</span></div><div class="line">		TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</div><div class="line">		Object target = <span class="keyword">null</span>;</div><div class="line">		</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//判断方法是否是equals、hashCode方法</span></div><div class="line">			<span class="keyword">if</span> (!<span class="keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</div><div class="line">				<span class="comment">// The target does not implement the equals(Object) method itself.</span></div><div class="line">				<span class="keyword">return</span> equals(args[<span class="number">0</span>]);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</div><div class="line">				<span class="comment">// The target does not implement the hashCode() method itself.</span></div><div class="line">				<span class="keyword">return</span> hashCode();</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (method.getDeclaringClass() == DecoratingProxy.class) &#123;</div><div class="line">				<span class="comment">// There is only getDecoratedClass() declared -&gt; dispatch to proxy config.</span></div><div class="line">				<span class="keyword">return</span> AopProxyUtils.ultimateTargetClass(<span class="keyword">this</span>.advised);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</div><div class="line">					method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</div><div class="line">				<span class="comment">// Service invocations on ProxyConfig with the proxy config...</span></div><div class="line">				<span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.advised, method, args);</div><div class="line">			&#125;</div><div class="line">			<span class="comment">//封装返回值</span></div><div class="line">			Object retVal;</div><div class="line"></div><div class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</div><div class="line">				<span class="comment">// Make invocation available if necessary.</span></div><div class="line">				oldProxy = AopContext.setCurrentProxy(proxy);</div><div class="line">				setProxyContext = <span class="keyword">true</span>;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="comment">//获取目标对象和目标类</span></div><div class="line">			target = targetSource.getTarget();</div><div class="line">			Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</div><div class="line"></div><div class="line">			<span class="comment">//获取拦截器链【重要方法】</span></div><div class="line">			List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</div><div class="line"></div><div class="line">			<span class="comment">//拦截器链为空表示没有使用事务，直接调用即可</span></div><div class="line">			<span class="keyword">if</span> (chain.isEmpty()) &#123;</div><div class="line">				<span class="comment">//获取能够适用的参数</span></div><div class="line">				Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</div><div class="line">                <span class="comment">//直接调用方法</span></div><div class="line">				retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				<span class="comment">//拦截器链不为空，需要拦截执行，创建ReflectiveMethodInvocation</span></div><div class="line">				invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</div><div class="line">				<span class="comment">//通过拦截器链执行</span></div><div class="line">				retVal = invocation.proceed();</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="comment">// 判断返回值类型</span></div><div class="line">			Class&lt;?&gt; returnType = method.getReturnType();</div><div class="line">            <span class="comment">//如果返回值是对象本身，即是return this,那么返回的必须还是代理对象proxy，否则后续的方法不能使用代理对象了。</span></div><div class="line">			<span class="keyword">if</span> (retVal != <span class="keyword">null</span> &amp;&amp; retVal == target &amp;&amp;</div><div class="line">					returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;</div><div class="line">					!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</div><div class="line">				<span class="comment">// Special case: it returned "this" and the return type of the method</span></div><div class="line">				<span class="comment">// is type-compatible. Note that we can't help if the target sets</span></div><div class="line">				<span class="comment">// a reference to itself in another returned object.</span></div><div class="line">				retVal = proxy;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (retVal == <span class="keyword">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(</div><div class="line">						<span class="string">"Null return value from advice does not match primitive return type for: "</span> + method);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> retVal;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">finally</span> &#123;</div><div class="line">			<span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</div><div class="line">				<span class="comment">// Must have come from TargetSource.</span></div><div class="line">				targetSource.releaseTarget(target);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (setProxyContext) &#123;</div><div class="line">				<span class="comment">// Restore old proxy.</span></div><div class="line">				AopContext.setCurrentProxy(oldProxy);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ul>
<li>继续上面的获取拦截器链的方法，如下：<ul>
<li>第一次调用是需要执行<code>this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(this, method, targetClass);</code>方法，后续是直接从缓存中获取即可</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>&#123;</div><div class="line">    <span class="comment">//获取key</span></div><div class="line">		MethodCacheKey cacheKey = <span class="keyword">new</span> MethodCacheKey(method);</div><div class="line">    	<span class="comment">//获取缓存中的数据</span></div><div class="line">		List&lt;Object&gt; cached = <span class="keyword">this</span>.methodCache.get(cacheKey);</div><div class="line">    <span class="comment">//缓存为空，调用this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice方法</span></div><div class="line">		<span class="keyword">if</span> (cached == <span class="keyword">null</span>) &#123;</div><div class="line">			cached = <span class="keyword">this</span>.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(</div><div class="line">					<span class="keyword">this</span>, method, targetClass);</div><div class="line">            <span class="comment">//存入缓存中</span></div><div class="line">			<span class="keyword">this</span>.methodCache.put(cacheKey, cached);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> cached;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ul>
<li>进入<code>org.springframework.aop.framework.DefaultAdvisorChainFactory#getInterceptorsAndDynamicInterceptionAdvice</code>方法，如下：<ul>
<li>该方法执行成功返回的List就是适用于方法上的拦截器链，事务的拦截器是<strong>TransactionIntercept</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(</span></span></div><div class="line">			Advised config, Method method, @Nullable Class&lt;?&gt; targetClass) &#123;</div><div class="line">		<span class="comment">//获取GlobalAdvisorAdapterRegistry</span></div><div class="line">		AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();</div><div class="line">    	<span class="comment">//获取ProxyFacotry中的增强器</span></div><div class="line">		Advisor[] advisors = config.getAdvisors();</div><div class="line">    	<span class="comment">//存储可用的全部拦截器</span></div><div class="line">		List&lt;Object&gt; interceptorList = <span class="keyword">new</span> ArrayList&lt;&gt;(advisors.length);</div><div class="line">    	<span class="comment">//获取真正的目标类</span></div><div class="line">		Class&lt;?&gt; actualClass = (targetClass != <span class="keyword">null</span> ? targetClass : method.getDeclaringClass());</div><div class="line">		Boolean hasIntroductions = <span class="keyword">null</span>;</div><div class="line">		<span class="comment">//遍历增强器，事务的增强器是BeanFactoryTransactionAttributeSourceAdvisor</span></div><div class="line">		<span class="keyword">for</span> (Advisor advisor : advisors) &#123;</div><div class="line">            <span class="comment">//判断是否是PointcutAdvisor类型的，事务的增强器就是这种类型的</span></div><div class="line">			<span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> PointcutAdvisor) &#123;</div><div class="line">				<span class="comment">// 强转</span></div><div class="line">				PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;</div><div class="line">                <span class="comment">//判断增强器是否之前已经过滤或者此增强器匹配目标类</span></div><div class="line">				<span class="keyword">if</span> (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) &#123;</div><div class="line">					MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();</div><div class="line">                    <span class="comment">//标记是否匹配</span></div><div class="line">					<span class="keyword">boolean</span> match;</div><div class="line">                    <span class="comment">//判断类型</span></div><div class="line">					<span class="keyword">if</span> (mm <span class="keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;</div><div class="line">						<span class="keyword">if</span> (hasIntroductions == <span class="keyword">null</span>) &#123;</div><div class="line">							hasIntroductions = hasMatchingIntroductions(advisors, actualClass);</div><div class="line">						&#125;</div><div class="line">						match = ((IntroductionAwareMethodMatcher) mm).matches(method, actualClass, hasIntroductions);</div><div class="line">					&#125;</div><div class="line">					<span class="keyword">else</span> &#123;	</div><div class="line">                        <span class="comment">//匹配是否适用，其实内部就是判断TransactionAttributeSource中的attributeCache的value是否为null</span></div><div class="line">						match = mm.matches(method, actualClass);</div><div class="line">					&#125;</div><div class="line">                    <span class="comment">//匹配了，添加</span></div><div class="line">					<span class="keyword">if</span> (match) &#123;</div><div class="line">                        <span class="comment">//判断增强器中的advice是否是MethodInterceptor等类型</span></div><div class="line">						MethodInterceptor[] interceptors = registry.getInterceptors(advisor);</div><div class="line">						<span class="keyword">if</span> (mm.isRuntime()) &#123;</div><div class="line">							<span class="comment">// Creating a new object instance in the getInterceptors() method</span></div><div class="line">							<span class="comment">// isn't a problem as we normally cache created chains.</span></div><div class="line">							<span class="keyword">for</span> (MethodInterceptor interceptor : interceptors) &#123;</div><div class="line">								interceptorList.add(<span class="keyword">new</span> InterceptorAndDynamicMethodMatcher(interceptor, mm));</div><div class="line">							&#125;</div><div class="line">						&#125;</div><div class="line">						<span class="keyword">else</span> &#123;</div><div class="line">							interceptorList.addAll(Arrays.asList(interceptors));</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">            <span class="comment">//类型是IntroductionAdvisor</span></div><div class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</div><div class="line">				IntroductionAdvisor ia = (IntroductionAdvisor) advisor;</div><div class="line">				<span class="keyword">if</span> (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) &#123;</div><div class="line">					Interceptor[] interceptors = registry.getInterceptors(advisor);</div><div class="line">					interceptorList.addAll(Arrays.asList(interceptors));</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				Interceptor[] interceptors = registry.getInterceptors(advisor);</div><div class="line">				interceptorList.addAll(Arrays.asList(interceptors));</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> interceptorList;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ul>
<li>拦截器链正确返回后，此时代码就执行到了<code>retVal = invocation.proceed();</code>，进入，源码如下：<ul>
<li><strong>真正以事务执行的方法是在父类<code>TransactionAspectSupport</code>中的<code>invokeWithinTransaction</code>方法</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//此方法是循环调用的，每一个拦截器调用都会执行一遍，因此currentInterceptorIndex是表示执行到的拦截器下标</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">		<span class="comment">//如果拦截器全部执行完成，那么就开始调用目标方法了</span></div><div class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</div><div class="line">			<span class="keyword">return</span> invokeJoinpoint();</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//获取当前的拦截器</span></div><div class="line">		Object interceptorOrInterceptionAdvice =</div><div class="line">				<span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</div><div class="line">    	<span class="comment">//判断拦截器类型是InterceptorAndDynamicMethodMatcher，事务的拦截器显然不是，跳过执行</span></div><div class="line">		<span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</div><div class="line">			<span class="comment">// Evaluate dynamic method matcher here: static part will already have</span></div><div class="line">			<span class="comment">// been evaluated and found to match.</span></div><div class="line">			InterceptorAndDynamicMethodMatcher dm =</div><div class="line">					(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</div><div class="line">			Class&lt;?&gt; targetClass = (<span class="keyword">this</span>.targetClass != <span class="keyword">null</span> ? <span class="keyword">this</span>.targetClass : <span class="keyword">this</span>.method.getDeclaringClass());</div><div class="line">			<span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, targetClass, <span class="keyword">this</span>.arguments)) &#123;</div><div class="line">				<span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				<span class="comment">// Dynamic matching failed.</span></div><div class="line">				<span class="comment">// Skip this interceptor and invoke the next in the chain.</span></div><div class="line">				<span class="keyword">return</span> proceed();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			<span class="comment">//执行拦截器的invoke方法</span></div><div class="line">			<span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"><span class="comment">//org.springframework.transaction.interceptor.TransactionInterceptor#invoke</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">		Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="keyword">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="keyword">null</span>);</div><div class="line">    	<span class="comment">//执行父类的invokeWithinTransaction方法</span></div><div class="line">		<span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>org.springframework.transaction.interceptor.TransactionAspectSupport#invokeWithinTransaction</code><ul>
<li><strong>final PlatformTransactionManager tm = determineTransactionManager(txAttr)：获取事务管理器</strong></li>
<li><strong>TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification)：内部重要的逻辑就是调用doBegin开启事务。</strong></li>
<li><strong>commitTransactionAfterReturning(txInfo)：提交事务，调用是org.springframework.jdbc.datasource.DataSourceTransactionManager#doCommit方法</strong></li>
<li><strong>completeTransactionAfterThrowing(txInfo, ex)：对事务的异常处理，根据@Transactional中的定义的异常，做出不同的处理，内部做了事务的回滚，最终回滚的方法是<code>org.springframework.jdbc.datasource.DataSourceTransactionManager#doRollback</code></strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeWithinTransaction</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass,</span></span></div><div class="line">			<span class="keyword">final</span> InvocationCallback invocation) <span class="keyword">throws</span> Throwable &#123;</div><div class="line">		<span class="comment">//获取TransactionAttributeSource</span></div><div class="line">		TransactionAttributeSource tas = getTransactionAttributeSource();</div><div class="line">    	<span class="comment">//获取TransactionAttribute，如果为null，那么是以非事务的方式执行</span></div><div class="line">		<span class="keyword">final</span> TransactionAttribute txAttr = (tas != <span class="keyword">null</span> ? tas.getTransactionAttribute(method, targetClass) : <span class="keyword">null</span>);</div><div class="line">    	<span class="comment">//获取事务管理器，见下方的方法</span></div><div class="line">		<span class="keyword">final</span> PlatformTransactionManager tm = determineTransactionManager(txAttr);</div><div class="line">		<span class="keyword">final</span> String joinpointIdentification = methodIdentification(method, targetClass, txAttr);</div><div class="line">		<span class="comment">//判断</span></div><div class="line">		<span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || !(tm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</div><div class="line">			<span class="comment">//创建TransactionInfo，此处就会开启事务</span></div><div class="line">			TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</div><div class="line">			Object retVal = <span class="keyword">null</span>;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				<span class="comment">//再次调用invoke方法，执行下一个拦截器</span></div><div class="line">				retVal = invocation.proceedWithInvocation();</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">				<span class="comment">//对事务的异常处理，根据@Transactional中的定义的异常，做出不同的处理，内部做了事务的回滚</span></div><div class="line">				completeTransactionAfterThrowing(txInfo, ex);</div><div class="line">				<span class="keyword">throw</span> ex;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">finally</span> &#123;</div><div class="line">                <span class="comment">//重新设置TransactionInfo信息</span></div><div class="line">				cleanupTransactionInfo(txInfo);</div><div class="line">			&#125;</div><div class="line">            <span class="comment">//正确返回之后，提交事务，调用的是org.springframework.jdbc.datasource.DataSourceTransactionManager#doCommit</span></div><div class="line">			commitTransactionAfterReturning(txInfo);</div><div class="line">            <span class="comment">//返回结果</span></div><div class="line">			<span class="keyword">return</span> retVal;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"><span class="comment">//determineTransactionManager：获取事务管理器，先获取自身的，后获取注入的事务管理器，放入缓存中，下次直接用</span></div><div class="line"><span class="function"><span class="keyword">protected</span> PlatformTransactionManager <span class="title">determineTransactionManager</span><span class="params">(@Nullable TransactionAttribute txAttr)</span> </span>&#123;</div><div class="line">		<span class="comment">//如果TransactionAttribute为null，不以事务的形式执行</span></div><div class="line">		<span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || <span class="keyword">this</span>.beanFactory == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">return</span> getTransactionManager();</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//获取@Transactional中的qualifier属性的值，根据名称获取事务管理器</span></div><div class="line">		String qualifier = txAttr.getQualifier();</div><div class="line">		<span class="keyword">if</span> (StringUtils.hasText(qualifier)) &#123;</div><div class="line">            <span class="comment">//根据BeanName获取事务管理器</span></div><div class="line">			<span class="keyword">return</span> determineQualifiedTransactionManager(<span class="keyword">this</span>.beanFactory, qualifier);</div><div class="line">		&#125;</div><div class="line">    	<span class="comment">//根据transactionManagerBeanName获取事务管理器</span></div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.transactionManagerBeanName)) &#123;</div><div class="line">			<span class="keyword">return</span> determineQualifiedTransactionManager(<span class="keyword">this</span>.beanFactory, <span class="keyword">this</span>.transactionManagerBeanName);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//获取默认的事务管理器</span></div><div class="line">			PlatformTransactionManager defaultTransactionManager = getTransactionManager();</div><div class="line">			<span class="keyword">if</span> (defaultTransactionManager == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">//获取缓存中的事务管理器</span></div><div class="line">				defaultTransactionManager = <span class="keyword">this</span>.transactionManagerCache.get(DEFAULT_TRANSACTION_MANAGER_KEY);</div><div class="line">				<span class="keyword">if</span> (defaultTransactionManager == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">//从ioc容器中获取事务管理器</span></div><div class="line">					defaultTransactionManager = <span class="keyword">this</span>.beanFactory.getBean(PlatformTransactionManager.class);</div><div class="line">                    <span class="comment">//放入缓存</span></div><div class="line">					<span class="keyword">this</span>.transactionManagerCache.putIfAbsent(</div><div class="line">							DEFAULT_TRANSACTION_MANAGER_KEY, defaultTransactionManager);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> defaultTransactionManager;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"><span class="comment">//createTransactionIfNecessary</span></div><div class="line"><span class="function"><span class="keyword">protected</span> TransactionInfo <span class="title">createTransactionIfNecessary</span><span class="params">(@Nullable PlatformTransactionManager tm,</span></span></div><div class="line">			@Nullable TransactionAttribute txAttr, <span class="keyword">final</span> String joinpointIdentification) &#123;</div><div class="line"></div><div class="line">		<span class="comment">// 如果TransactionAttribute中没有指定name，那么使用joinpointIdentification【方法的全类名+方法名】</span></div><div class="line">		<span class="keyword">if</span> (txAttr != <span class="keyword">null</span> &amp;&amp; txAttr.getName() == <span class="keyword">null</span>) &#123;</div><div class="line">			txAttr = <span class="keyword">new</span> DelegatingTransactionAttribute(txAttr) &#123;</div><div class="line">				<span class="meta">@Override</span></div><div class="line">				<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">					<span class="keyword">return</span> joinpointIdentification;</div><div class="line">				&#125;</div><div class="line">			&#125;;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">    	<span class="comment">//TransactionStatus中存储的是事务运行的各个状态</span></div><div class="line">		TransactionStatus status = <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">if</span> (tm != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">//获取事务的当前状态，内部调用最重要的方法是doBegin，开启事务，设置自动提交为false</span></div><div class="line">				status = tm.getTransaction(txAttr);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">					logger.debug(<span class="string">"Skipping transactional joinpoint ["</span> + joinpointIdentification +</div><div class="line">							<span class="string">"] because no transaction manager has been configured"</span>);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//org.springframework.jdbc.datasource.DataSourceTransactionManager#doBegin</span></div><div class="line"><span class="comment">//主要的作用是开启事务con.setAutoCommit(false);</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBegin</span><span class="params">(Object transaction, TransactionDefinition definition)</span> </span>&#123;</div><div class="line">		DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;</div><div class="line">		Connection con = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="keyword">if</span> (!txObject.hasConnectionHolder() ||</div><div class="line">					txObject.getConnectionHolder().isSynchronizedWithTransaction()) &#123;</div><div class="line">                <span class="comment">//获取数据库连接</span></div><div class="line">				Connection newCon = obtainDataSource().getConnection();</div><div class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">					logger.debug(<span class="string">"Acquired Connection ["</span> + newCon + <span class="string">"] for JDBC transaction"</span>);</div><div class="line">				&#125;</div><div class="line">				txObject.setConnectionHolder(<span class="keyword">new</span> ConnectionHolder(newCon), <span class="keyword">true</span>);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			txObject.getConnectionHolder().setSynchronizedWithTransaction(<span class="keyword">true</span>);</div><div class="line">			con = txObject.getConnectionHolder().getConnection();</div><div class="line"></div><div class="line">			Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);</div><div class="line">			txObject.setPreviousIsolationLevel(previousIsolationLevel);</div><div class="line"></div><div class="line">			<span class="comment">//如果是自动提交的，那么设置不是自动提交</span></div><div class="line">			<span class="keyword">if</span> (con.getAutoCommit()) &#123;</div><div class="line">				txObject.setMustRestoreAutoCommit(<span class="keyword">true</span>);</div><div class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">					logger.debug(<span class="string">"Switching JDBC Connection ["</span> + con + <span class="string">"] to manual commit"</span>);</div><div class="line">				&#125;</div><div class="line">				con.setAutoCommit(<span class="keyword">false</span>);</div><div class="line">			&#125;</div><div class="line">			<span class="comment">//准备工作，如果标记了readOnly=true，那么设置事务事只读的。</span></div><div class="line">			prepareTransactionalConnection(con, definition);</div><div class="line">			txObject.getConnectionHolder().setTransactionActive(<span class="keyword">true</span>);</div><div class="line">			</div><div class="line">            <span class="comment">//判断设置的超时时间</span></div><div class="line">			<span class="keyword">int</span> timeout = determineTimeout(definition);</div><div class="line">			<span class="keyword">if</span> (timeout != TransactionDefinition.TIMEOUT_DEFAULT) &#123;</div><div class="line">				txObject.getConnectionHolder().setTimeoutInSeconds(timeout);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="comment">// Bind the connection holder to the thread.</span></div><div class="line">			<span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</div><div class="line">				TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">			<span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</div><div class="line">				DataSourceUtils.releaseConnection(con, obtainDataSource());</div><div class="line">				txObject.setConnectionHolder(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> CannotCreateTransactionException(<span class="string">"Could not open JDBC Connection for transaction"</span>, ex);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"><span class="comment">//org.springframework.jdbc.datasource.DataSourceTransactionManager#doCommit</span></div><div class="line"><span class="comment">//提交事务</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doCommit</span><span class="params">(DefaultTransactionStatus status)</span> </span>&#123;</div><div class="line">		DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();</div><div class="line">		Connection con = txObject.getConnectionHolder().getConnection();</div><div class="line">		<span class="keyword">if</span> (status.isDebug()) &#123;</div><div class="line">			logger.debug(<span class="string">"Committing JDBC transaction on Connection ["</span> + con + <span class="string">"]"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//提交事务</span></div><div class="line">			con.commit();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (SQLException ex) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> TransactionSystemException(<span class="string">"Could not commit JDBC transaction"</span>, ex);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h2 id="事务生成AOP代理流程"><a href="#事务生成AOP代理流程" class="headerlink" title="事务生成AOP代理流程"></a>事务生成AOP代理流程</h2><p><img src="https://raw.githubusercontent.com/chenjiabing666/BlogImage/master/Transaction%20created.png" alt=""></p>
<h2 id="事务执行流程"><a href="#事务执行流程" class="headerlink" title="事务执行流程"></a>事务执行流程</h2><p><img src="https://raw.githubusercontent.com/chenjiabing666/BlogImage/master/transaction%20proceed.png" alt=""></p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li>事务执行流程：<ul>
<li>标注@EnableTransactionManagement，内部使用@Import注解导入了几个Bean，分别是<code>InfrastructureAdvisorAutoProxyCreator</code>、<code>BeanFactoryTransactionAttributeSourceAdvisor</code>、<code>AnnotationTransactionAttributeSource</code>、<code>TransactionInterceptor</code></li>
<li>对类上或者方法上标注了@Transactional注解的类生成代理对象，调用AbstractAutoProxyCreator中的<code>wrapIfNecessary</code>生成<ul>
<li>重要的逻辑就是使用SpringAnnotationTransactionParser解析每一个类每一个方法上标注的@Transactional注解的属性值，封装在TransactionalAttribute中，最终将这些TransactionalAttribut统一封装在TransactionalAttributeSource中【使用<code>attributeCache</code>进行缓存】</li>
<li>最终将增强器Advisor和拦截器封装在ProxyFactory中</li>
</ul>
</li>
<li>执行的时候先调用<code>org.springframework.aop.framework.JdkDynamicAopProxy#invoke</code>方法<ul>
<li>先获取适用的拦截器链，最终以循环调用的方式（类似）执行拦截器</li>
<li>调用TransactionInterceptor中的invoke方法，最终执行的<code>TransactionAspect</code>中的invokeWithTransactional方法，在这方法内部涉及了事务的生命周期，如开启事务，回滚事务，提交事务等等操作，都是从此方法进入的。最终执行的处理是调用事务管理器中的<code>doXXX</code>方法，比如<code>doCommit</code>方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;配置注解版事务&quot;&gt;&lt;a href=&quot;#配置注解版事务&quot; class=&quot;headerlink&quot; title=&quot;配置注解版事务&quot;&gt;&lt;/a&gt;配置注解版事务&lt;/h1&gt;&lt;h2 id=&quot;事务管理器&quot;&gt;&lt;a href=&quot;#事务管理器&quot; class=&quot;headerlink&quot; ti
    
    </summary>
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring中的事件</title>
    <link href="http://chenjiabing666.github.io/2019/06/30/Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6/"/>
    <id>http://chenjiabing666.github.io/2019/06/30/Spring中的事件/</id>
    <published>2019-06-30T06:22:07.000Z</published>
    <updated>2019-06-30T06:22:33.196Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>学过编程语言的肯定知道事件，在JS中事件，Android中的事件，大多是鼠标点击，键盘事件，手指滑动事件等等。在Spring中也有一些事件，比如容器启动、容器关闭、容器刷新都是一个事件。</li>
<li>既然有了事件，自然少不了事件监听器，事件分发器等，后续会详细介绍</li>
</ul>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="Spring中内置的事件"><a href="#Spring中内置的事件" class="headerlink" title="Spring中内置的事件"></a>Spring中内置的事件</h2><ul>
<li><code>ContextStartedEvent</code>：容器启动的时候触发(start方法)</li>
<li><code>ContextRefreshedEvent</code>：容器刷新的时候触发(onRefresh，在finisRefresh中调用)</li>
<li><code>ContextStoppedEvent</code>：容器停止的时候触发(stop方法)</li>
<li><code>ContextClosedEvent</code>：容器关闭的时候触发(close方法)</li>
</ul>
<h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><ul>
<li>Spring中自定义事件只需要继承<code>ApplicationEvent</code>即可完成一个自定义的Spring事件<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义事件，继承ApplicationEvent</div><div class="line"> */</div><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 需要携带的消息，可以是任意类型的数据，相当于传递数据</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> String message;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造方法</div><div class="line">     * <span class="doctag">@param</span> source 事件发生的类</div><div class="line">     * <span class="doctag">@param</span> message 携带的消息</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FirstEvent</span><span class="params">(Object source,String message)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(source);</div><div class="line">        <span class="keyword">this</span>.message=message;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h1><ul>
<li>监听器用来监听事件触发，一旦事件触发了，监听器会执行相应的操作。</li>
<li>监听器的实现有两种方式：<ul>
<li>实现<code>ApplicationListener</code>接口</li>
<li>使用<code>@EventListener</code>注解</li>
</ul>
</li>
</ul>
<h2 id="实现ApplicationListener接口"><a href="#实现ApplicationListener接口" class="headerlink" title="实现ApplicationListener接口"></a>实现ApplicationListener接口</h2><ul>
<li><p>创建监听器需要两个条件：</p>
<ul>
<li>实现ApplicationListener接口</li>
<li>将该自定义的监听器注入到ioc容器中<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义一个监听器，实现ApplicationListener，指定的泛型就是需要监听的事件</div><div class="line"> * 监听ContextRefreshedEvent，当容器完成刷新的时候该监听器就会监听到并执行onApplicationEvent方法</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 重载方法，被监听的事件触发了就会调用这个方法</div><div class="line">     * <span class="doctag">@param</span> event 触发事件的对象</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"容器刷新的监听器启动了........"</span>);</div><div class="line">        System.out.println(event.getSource()+<span class="string">"----&gt;"</span>+event.getTimestamp()+<span class="string">"----"</span>+event.getApplicationContext());</div><div class="line">        System.out.println(<span class="string">"........................................."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>此时只要启动容器，自定义的监听器就会起作用，当然我们监听的是Spring内置的事件，在容器启动的时候Spring会使用事件发布器发布事件，此时才是真正的触发事件，我们自定义的事件并不能被监听，除非被事件发布器发布。</p>
</li>
</ul>
<h2 id="使用-EventListener注解"><a href="#使用-EventListener注解" class="headerlink" title="使用@EventListener注解"></a>使用@EventListener注解</h2><ul>
<li>常见的属性：<ul>
<li><code>classes</code>：Class数组，指定需要监听的事件</li>
<li><code>condition</code>：指定条件，默认监听<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 注解方式实现事件监听器</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomEventListener</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 使用<span class="doctag">@EventListener</span>监听事件</div><div class="line">     * <span class="doctag">@param</span> event 传入的事件源</div><div class="line">     */</div><div class="line">    <span class="meta">@EventListener</span>(classes = &#123;ApplicationEvent.class&#125;)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerContextRefreshEvent</span><span class="params">(ApplicationEvent event)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextRefreshedEvent) &#123;</div><div class="line">            ContextRefreshedEvent e=(ContextRefreshedEvent)event;</div><div class="line">            System.out.println(<span class="string">"ContextRefreshedEvent启动了........"</span>);</div><div class="line">            System.out.println(event.getSource() + <span class="string">"----&gt;"</span> + event.getTimestamp() + <span class="string">"----"</span> + e.getApplicationContext());</div><div class="line">            System.out.println(<span class="string">"........................................."</span>);</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(event <span class="keyword">instanceof</span> ContextStartedEvent)&#123;</div><div class="line">            ContextStartedEvent e=(ContextStartedEvent)event;</div><div class="line">            System.out.println(<span class="string">"ContextStartedEvent启动了........"</span>);</div><div class="line">            System.out.println(event.getSource() + <span class="string">"----&gt;"</span> + event.getTimestamp() + <span class="string">"----"</span> + e.getApplicationContext());</div><div class="line">            System.out.println(<span class="string">"........................................."</span>);</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(event <span class="keyword">instanceof</span> ContextStoppedEvent)&#123;</div><div class="line">            ContextStoppedEvent e=(ContextStoppedEvent)event;</div><div class="line">            System.out.println(<span class="string">"ContextStoppedEvent启动了........"</span>);</div><div class="line">            System.out.println(event.getSource() + <span class="string">"----&gt;"</span> + event.getTimestamp() + <span class="string">"----"</span> + e.getApplicationContext());</div><div class="line">            System.out.println(<span class="string">"........................................."</span>);</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(event <span class="keyword">instanceof</span> ContextClosedEvent)&#123;</div><div class="line">            ContextClosedEvent e=(ContextClosedEvent)event;</div><div class="line">            System.out.println(<span class="string">"ContextClosedEvent启动了........"</span>);</div><div class="line">            System.out.println(event.getSource() + <span class="string">"----&gt;"</span> + event.getTimestamp() + <span class="string">"----"</span> + e.getApplicationContext());</div><div class="line">            System.out.println(<span class="string">"........................................."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 可以不指定classes，默认监听的是方法参数中的事件</div><div class="line">     * <span class="doctag">@param</span> event 事件源</div><div class="line">     */</div><div class="line">    <span class="meta">@EventListener</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleFirstEvent</span><span class="params">(FirstEvent event)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"firstEvent事件启动了，。。。。。。。。。"</span>);</div><div class="line">        System.out.println(event.getSource()+<span class="string">"----&gt;"</span>+event.getMessage());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="事件发布"><a href="#事件发布" class="headerlink" title="事件发布"></a>事件发布</h1><ul>
<li>Spring中发布事件的接口是<code>ApplicationEventPublisher</code>，我们可以自定义自己的类，当然也可以使用spring现成的类</li>
</ul>
<h2 id="Spring的事件发布类"><a href="#Spring的事件发布类" class="headerlink" title="Spring的事件发布类"></a>Spring的事件发布类</h2><ul>
<li>ApplicationContext</li>
<li>AnnotationConfigApplicationContext</li>
</ul>
<h2 id="直接注入"><a href="#直接注入" class="headerlink" title="直接注入"></a>直接注入</h2><ul>
<li><p>在容器启动刷新的时候已经注入了<code>ApplicationEventPublisher</code>的实现，我们可以直接注入使用。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义的事件发布器</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomPublisher</span>  </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 直接注入ApplicationEventPublisher</div><div class="line">     */</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 发布事件</div><div class="line">     * <span class="doctag">@param</span> event 指定的事件</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span></span>&#123;</div><div class="line">        applicationEventPublisher.publishEvent(event);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</div><div class="line">    CustomPublisher customPublisher = applicationContext.getBean(CustomPublisher.class);</div><div class="line">    customPublisher.publishEvent(<span class="keyword">new</span> FirstEvent(<span class="keyword">this</span>,<span class="string">"启动自定义事件"</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="使用ApplicationEventPublisherAware注入"><a href="#使用ApplicationEventPublisherAware注入" class="headerlink" title="使用ApplicationEventPublisherAware注入"></a>使用ApplicationEventPublisherAware注入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义的事件发布器，实现ApplicationEventPublisherAware接口</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomPublisher</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 发布事件</div><div class="line">     * <span class="doctag">@param</span> event 指定的事件</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span></span>&#123;</div><div class="line">        applicationEventPublisher.publishEvent(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.applicationEventPublisher=applicationEventPublisher;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="事件多播器"><a href="#事件多播器" class="headerlink" title="事件多播器"></a>事件多播器</h1><ul>
<li>何为事件多播器【<code>ApplicationEventMulticaster</code>】？<ul>
<li>简单的说事件多播器就是一个管理事件监听器并且广播事件【根据指定的事件调用指定的监听器而已】</li>
</ul>
</li>
<li>spring中两个实现类分别为<code>AbstractApplicationEventMulticaster</code>、<code>SimpleApplicationEventMulticaster</code></li>
<li>如何广播事件？【如何通过指定的事件调用指定的监听器】<ul>
<li>真正的实现在<code>org.springframework.context.event.SimpleApplicationEventMulticaster#multicastEvent(org.springframework.context.ApplicationEvent, org.springframework.core.ResolvableType)</code>这个方法中，如下：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, @Nullable ResolvableType eventType)</span> </span>&#123;</div><div class="line">		ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</div><div class="line">        <span class="comment">//遍历事件监听器</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">final</span> ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</div><div class="line">            <span class="comment">//判断是否设置了Executor，如果存在，那么就异步执行</span></div><div class="line">			Executor executor = getTaskExecutor();</div><div class="line">			<span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</div><div class="line">				executor.execute(() -&gt; invokeListener(listener, event));</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//否则的话，同步执行，调用invokeListener</span></div><div class="line">				invokeListener(listener, event);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/****************************************invokeListener******************************/</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeListener</span><span class="params">(ApplicationListener&lt;?&gt; listener, ApplicationEvent event)</span> </span>&#123;</div><div class="line">    	<span class="comment">//如果有异常处理器，就try-catch执行</span></div><div class="line">		ErrorHandler errorHandler = getErrorHandler();</div><div class="line">		<span class="keyword">if</span> (errorHandler != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				doInvokeListener(listener, event);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">catch</span> (Throwable err) &#123;</div><div class="line">                <span class="comment">//如果有异常了，执行异常处理器的handleError方法</span></div><div class="line">				errorHandler.handleError(err);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//没有异常处理器直接执行</span></div><div class="line">			doInvokeListener(listener, event);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"><span class="comment">/*******************************doInvokeListener****************************/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doInvokeListener</span><span class="params">(ApplicationListener listener, ApplicationEvent event)</span> </span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//此时真正调用监听器中的方法</span></div><div class="line">			listener.onApplicationEvent(event);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (ClassCastException ex) &#123;</div><div class="line">			String msg = ex.getMessage();</div><div class="line">			<span class="keyword">if</span> (msg == <span class="keyword">null</span> || matchesClassCastMessage(msg, event.getClass())) &#123;</div><div class="line">				<span class="comment">// Possibly a lambda-defined listener which we could not resolve the generic event type for</span></div><div class="line">				<span class="comment">// -&gt; let's suppress the exception and just log a debug message.</span></div><div class="line">				Log logger = LogFactory.getLog(getClass());</div><div class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">					logger.debug(<span class="string">"Non-matching event type for listener: "</span> + listener, ex);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				<span class="keyword">throw</span> ex;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h1 id="异步事件"><a href="#异步事件" class="headerlink" title="异步事件"></a>异步事件</h1><ul>
<li>前面创建的事件和监听器都是同步进行，我们可以使用异步事件</li>
</ul>
<h2 id="使用-Async实现异步"><a href="#使用-Async实现异步" class="headerlink" title="使用@Async实现异步"></a>使用@Async实现异步</h2><ul>
<li><p>Spring中可以使用<code>@Async</code>注解标注方法异步执行，不过需要在配置类上开启异步功能，使用<code>@EnableAsync</code>注解，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ComponentScan</span>(value = &#123;<span class="string">"cn.tedu.demo"</span>&#125;)</div><div class="line"><span class="meta">@EnableAsync</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstConfig</span> </span>&#123;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>此时可以在监听方法上标注<code>@Async</code>注解，使得事件异步执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 注解方式实现事件监听器</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomEventListener</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 可以不指定classes，默认监听的是方法参数中的事件</div><div class="line">     * <span class="doctag">@Async</span> : 指定这个方法异步执行</div><div class="line">     * <span class="doctag">@param</span> event 事件源</div><div class="line">     */</div><div class="line">    <span class="meta">@EventListener</span></div><div class="line">    <span class="meta">@Async</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleFirstEvent</span><span class="params">(FirstEvent event)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"firstEvent事件启动了，。。。。。。。。。"</span>);</div><div class="line">        System.out.println(event.getSource()+<span class="string">"----&gt;"</span>+event.getMessage());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="自定义事件多播器"><a href="#自定义事件多播器" class="headerlink" title="自定义事件多播器"></a>自定义事件多播器</h2><ul>
<li>从源码我们可以知道，spring容器加载的时候先获取的是ioc容器中的，如果不存在，那么才会新建一个<code>SimpleApplicationEventMulticaster</code>，我们可以自己注入一个多播器直接使用即可。</li>
<li><p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</div><div class="line">		ConfigurableListableBeanFactory beanFactory = getBeanFactory();</div><div class="line">		<span class="comment">//判断ioc容器中是否存在id为applicationEventMulticaster事件多播器</span></div><div class="line">		<span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</div><div class="line">		    <span class="comment">//直接使用ioc容器中的</span></div><div class="line">			<span class="keyword">this</span>.applicationEventMulticaster =</div><div class="line">					beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</div><div class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</div><div class="line">				logger.trace(<span class="string">"Using ApplicationEventMulticaster ["</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">"]"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">		    <span class="comment">//新建一个，不过没有设置TaskExector</span></div><div class="line">			<span class="keyword">this</span>.applicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</div><div class="line">			beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</div><div class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</div><div class="line">				logger.trace(<span class="string">"No '"</span> + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + <span class="string">"' bean, using "</span> +</div><div class="line">						<span class="string">"["</span> + <span class="keyword">this</span>.applicationEventMulticaster.getClass().getSimpleName() + <span class="string">"]"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>从源码中【<code>org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(org.springframework.context.ApplicationEvent, org.springframework.core.ResolvableType)</code>】我们可以看出监听器的执行是先判断多播器中是否存在<code>Executor</code>,如果存在，那么就单独开启一个线程执行，否则就同步执行，我们在初始化多播器的时候，可以为其设置一个<code>Executor</code>，那么就可以异步执行了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, @Nullable ResolvableType eventType)</span> </span>&#123;</div><div class="line">		ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">final</span> ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</div><div class="line">			Executor executor = getTaskExecutor();</div><div class="line">			<span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</div><div class="line">				executor.execute(() -&gt; invokeListener(listener, event));</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				invokeListener(listener, event);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>实现：在配置类注入一个多播器即可，bean的id一定要是<code>applicationEventMulticaster</code>，同时为其设置一个<code>executor</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义一个事件多播器，用来管理监听器和执行监听器</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="meta">@Bean</span>(name = <span class="string">"applicationEventMulticaster"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> ApplicationEventMulticaster <span class="title">applicationEventMulticaster</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//事件多播器</span></div><div class="line">    SimpleApplicationEventMulticaster simpleApplicationEventMulticaster=<span class="keyword">new</span> SimpleApplicationEventMulticaster();</div><div class="line">    <span class="comment">//设置executor</span></div><div class="line">    SimpleAsyncTaskExecutor executor=<span class="keyword">new</span> SimpleAsyncTaskExecutor();</div><div class="line">    simpleApplicationEventMulticaster.setTaskExecutor(executor);</div><div class="line">    <span class="comment">//设置一个事件异常处理器，当监听器执行出现错误了会进行补救</span></div><div class="line">    simpleApplicationEventMulticaster.setErrorHandler(t-&gt;&#123;</div><div class="line">        <span class="comment">//这里可以针对不同的异常进行处理，在监听器中trycatch，不同执行抛出不同异常即可分类处理</span></div><div class="line">        System.out.println(<span class="string">"监听事件执行报错了"</span>);</div><div class="line">        System.out.println(t.getMessage());</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> simpleApplicationEventMulticaster;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><ul>
<li>在spring源码中和事件涉及到的主要概念如下：<ul>
<li>事件（ApplicationEvent）</li>
<li>监听器（ApplicationEventListener）</li>
<li>事件发布器（ApplicationEventPublisher）</li>
<li>事件多播器（ApplicationEventMulticaster）</li>
</ul>
</li>
<li>具体源码层面的涉及如下：<ul>
<li>容器刷新<code>refresh</code>方法中：<ul>
<li><code>initApplicationEventMulticaster()</code>：初始化事件多播器</li>
<li><code>registerListeners();</code>：注册事件监听器</li>
<li><code>finishRefresh()</code>方法中调用<code>publishEvent(new ContextRefreshedEvent(this))</code>方法发布容器刷新事件。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>​    </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;学过编程语言的肯定知道事件，在JS中事件，Android中的事件，大多是鼠标点击，键盘事件，手指滑动事件等等。在Spring中也
    
    </summary>
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>BeanFactoryPostProcessor解析</title>
    <link href="http://chenjiabing666.github.io/2019/06/27/BeanFactoryPostProcessor%E8%A7%A3%E6%9E%90/"/>
    <id>http://chenjiabing666.github.io/2019/06/27/BeanFactoryPostProcessor解析/</id>
    <published>2019-06-27T15:34:47.000Z</published>
    <updated>2019-06-27T15:35:13.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>Spring IoC容器允许BeanFactoryPostProcessor在容器实例化任何bean之前读取bean的定义(配置元数据)，并可以修改它。同时可以定义多个BeanFactoryPostProcessor，通过设置’order’属性来确定各个BeanFactoryPostProcessor执行顺序。</li>
</ul>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"MyBeanFactoryPostProcessor开始执行"</span>);</div><div class="line">        String[] beanDefinitionNames = beanFactory.getBeanDefinitionNames();</div><div class="line">        <span class="keyword">for</span> (String name : beanDefinitionNames) &#123;</div><div class="line">            <span class="keyword">if</span> (name.equals(<span class="string">"user"</span>))&#123;</div><div class="line">                BeanDefinition beanDefinition = beanFactory.getBeanDefinition(name);</div><div class="line">                MutablePropertyValues propertyValues = beanDefinition.getPropertyValues();</div><div class="line">                propertyValues.add(<span class="string">"name"</span>,<span class="string">"Jack"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><ul>
<li>在刷新ioc容器的方法<code>org.springframework.context.support.AbstractApplicationContext.refresh</code>中执行，如下图：<br><img src="https://github.com/chenjiabing666/BlogImage/blob/master/spring20.png?raw=true" alt=""></li>
</ul>
<h1 id="BeanDefinitionRegistryPostProcessor"><a href="#BeanDefinitionRegistryPostProcessor" class="headerlink" title="BeanDefinitionRegistryPostProcessor"></a>BeanDefinitionRegistryPostProcessor</h1><ul>
<li>后续更新。。。。</li>
</ul>
<h1 id="MergedBeanDefinitionPostProcessor"><a href="#MergedBeanDefinitionPostProcessor" class="headerlink" title="MergedBeanDefinitionPostProcessor"></a>MergedBeanDefinitionPostProcessor</h1><ul>
<li>后续更新</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Spring IoC容器允许BeanFactoryPostProcessor在容器实例化任何bean之前读取bean的定义(配置
    
    </summary>
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>BeanWrapper解析</title>
    <link href="http://chenjiabing666.github.io/2019/06/27/BeanWrapper%E8%A7%A3%E6%9E%90/"/>
    <id>http://chenjiabing666.github.io/2019/06/27/BeanWrapper解析/</id>
    <published>2019-06-27T15:33:20.000Z</published>
    <updated>2019-06-27T15:33:53.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>BeanWrapper是Spring底层经常使用的一个接口，简单来说是对Bean的一种包装，包括对Bean的属性、方法，数据等。</li>
<li>唯一的一个实现类是<code>BeanWrapperImpl</code>，继承和实现关系图如下：<br><img src="https://github.com/chenjiabing666/BlogImage/blob/master/ssss.png?raw=true" alt=""></li>
</ul>
<h1 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h1><ul>
<li><code>public BeanWrapperImpl(Object object)</code>：指定对象构造</li>
<li><code>public BeanWrapperImpl(Class&lt;?&gt; clazz)</code>：指定Class构造，内部会通过反射调用clazz的默认无参构造方法进行实例化</li>
<li><code>public final Object getWrappedInstance()</code>：获取对象实例</li>
<li><code>public PropertyDescriptor getPropertyDescriptor(String propertyName</code>：获取指定属性的PropertyDescriptor </li>
<li><code>public PropertyDescriptor[] getPropertyDescriptors()</code>：获取所有属性的PropertyDescriptor【包括继承而来的】</li>
<li><code>public Object getPropertyValue(String propertyName)</code>：获取指定属性的值</li>
</ul>
<h1 id="PropertyDescriptor"><a href="#PropertyDescriptor" class="headerlink" title="PropertyDescriptor"></a>PropertyDescriptor</h1><ul>
<li>简称属性描述器，是对属性的封装，包括属性的类型，值，get和set方法，可以通过属性描述器可以很简单的获取和修改对应的值。</li>
<li>两个概念如下：<ul>
<li><code>ReadMethod</code>：即是对应属性的get方法</li>
<li><code>WriteMethod</code>：即是对应属性的set方法</li>
</ul>
</li>
</ul>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><ul>
<li>我们可以同<code>BeanWrapper</code>和<code>PropertyDescriptor</code>可以很轻松实现属性的复制，下面是本人手写的一个复制的工具类【当然这个是很粗糙的，和BeanUtils中的copyPropreties方法不能相提并论，不喜勿喷】<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 对象复制【浅克隆】</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewCopyUtils</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLASS=<span class="string">"class"</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 复制对象【只能复制基本数据类型，浅克隆】</div><div class="line">     * <span class="doctag">@param</span> source 源对象</div><div class="line">     * <span class="doctag">@param</span> target 目标对象</div><div class="line">     * <span class="doctag">@param</span> ingoreAgrs 忽略的属性</div><div class="line">     * <span class="doctag">@throws</span> Exception</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyProperties</span><span class="params">(Object source,Object target,String... ingoreAgrs)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">if</span> (source.getClass().isInterface()||target.getClass().isInterface())&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"source和target不能为接口"</span>);</div><div class="line">        &#125;</div><div class="line">        BeanWrapper sourceWrap = createBeanWrap(source);</div><div class="line">        BeanWrapper targetWrap = createBeanWrap(target);</div><div class="line">        PropertyDescriptor[] targetPds = targetWrap.getPropertyDescriptors();</div><div class="line">        PropertyDescriptor[] sourcePds = sourceWrap.getPropertyDescriptors();</div><div class="line">        <span class="comment">//根据名称分组，减少一层循环</span></div><div class="line">        Map&lt;String, List&lt;PropertyDescriptor&gt;&gt; map = Arrays.asList(sourcePds).parallelStream().filter(o -&gt; !StringUtils.equals(CLASS, o.getName())).collect(Collectors.groupingBy(o -&gt; o.getName()));</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; targetPds.length; i++) &#123;</div><div class="line">            PropertyDescriptor tpd=targetPds[i];</div><div class="line">            <span class="comment">//去掉class属性和不要的复制的属性</span></div><div class="line">            <span class="keyword">if</span> (!StringUtils.equals(CLASS,tpd.getName())&amp;&amp; !Arrays.asList(ingoreAgrs).contains(tpd.getName()))&#123;</div><div class="line">                List&lt;PropertyDescriptor&gt; list = map.getOrDefault(tpd.getName(), <span class="keyword">null</span>);</div><div class="line">                <span class="keyword">if</span> (Objects.nonNull(list))&#123;</div><div class="line">                    Method writeMethod = tpd.getWriteMethod();</div><div class="line">                    Method readMethod = list.get(<span class="number">0</span>).getReadMethod();</div><div class="line">                    <span class="keyword">if</span> (Objects.isNull(writeMethod)&amp;&amp;Objects.isNull(readMethod))&#123;</div><div class="line">                        <span class="keyword">throw</span>  <span class="keyword">new</span> Exception(<span class="string">"属性必须有get和set方法"</span>);</div><div class="line">                    &#125;</div><div class="line">                    Object o = readMethod.invoke(source);</div><div class="line">                    writeMethod.invoke(target,o);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造BeanWrapImpl</div><div class="line">     * <span class="doctag">@param</span> source 对象</div><div class="line">     * <span class="doctag">@return</span> BeanWrapper</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanWrapper <span class="title">createBeanWrap</span><span class="params">(Object source)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanWrapperImpl(source);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;BeanWrapper是Spring底层经常使用的一个接口，简单来说是对Bean的一种包装，包括对Bean的属性、方法，数据等。
    
    </summary>
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>InstantiationAwareBeanPostProcessor源码解析</title>
    <link href="http://chenjiabing666.github.io/2019/06/25/InstantiationAwareBeanPostProcessor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://chenjiabing666.github.io/2019/06/25/InstantiationAwareBeanPostProcessor源码解析/</id>
    <published>2019-06-25T13:24:43.000Z</published>
    <updated>2019-06-25T13:54:19.629Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>继承<code>BeanPostProcessor</code>接口，在此基础上又定义了三个方法，分别在Bean<strong>实例化前后【不是初始化】</strong>执行。</li>
<li>从上面的介绍可以看到，这个接口相对于BeanPostProcessor功能更加强大，一个接口承担了Bean的实例化前后、初始化前后责任。</li>
</ul>
<h1 id="Bean加载顺序"><a href="#Bean加载顺序" class="headerlink" title="Bean加载顺序"></a>Bean加载顺序</h1><ul>
<li>ioc容器创建加载Bean的执行顺序如下：<ul>
<li>InstantiationAwareBeanPostProcessor接口中的<code>postProcessBeforeInstantiation</code>，在实例化之前调用</li>
<li>Bean的实例化，调用构造方法</li>
<li>InstantiationAwareBeanPostProcessor接口中的<code>postProcessAfterInstantiation</code>，在实例化之后调用</li>
<li>InstantiationAwareBeanPostProcessor接口中的<code>postProcessPropertyValues</code><strong>【当postProcessAfterInstantiation返回true才执行】</strong></li>
<li>BeanPostProcessor接口中的<code>postProcessBeforeInitialization</code>，在初始化之前调用</li>
<li>InitializingBean中的afterProperties方法，执行初始化</li>
<li>BeanPostProcessor接口中的<code>postProcessAfterInitialization</code>，在实例化之后调用</li>
</ul>
</li>
</ul>
<h1 id="InstantiationAwareBeanPostProcessor接口方法的执行顺序"><a href="#InstantiationAwareBeanPostProcessor接口方法的执行顺序" class="headerlink" title="InstantiationAwareBeanPostProcessor接口方法的执行顺序"></a>InstantiationAwareBeanPostProcessor接口方法的执行顺序</h1><ul>
<li>正常的执行顺序如下：<ul>
<li>postProcessBeforeInstantiation</li>
<li>postProcessAfterInstantiation</li>
<li>postProcessProperties</li>
<li>postProcessBeforeInitialization</li>
<li>postProcessAfterInitialization</li>
</ul>
</li>
</ul>
<h1 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h1><ul>
<li><p><code>Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName)</code>：在实例化之前执行【构造方法之前执行】</p>
<ul>
<li>返回值：如果返回的不为<code>null</code>，那么后续的Bean的创建流程【实例化、初始化afterProperties】都不会执行，而是直接使用返回的快捷Bean，此时的正常执行顺序如下：<ul>
<li>InstantiationAwareBeanPostProcessor接口中的<code>postProcessBeforeInstantiation</code>，在实例化之前调用</li>
<li>BeanPostProcessor接口中的<code>postProcessAfterInitialization</code>，在实例化之后调用<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.resolveBeforeInstantiation </div><div class="line">* 作用：在实例化之前解析是否有快捷创建的Bean，既是通过postProcessBeforeInstantiation返回的Bean</div><div class="line">* 内部调用两个重要的方法：</div><div class="line">*   1、applyBeanPostProcessorsBeforeInstantiation：内部遍历调用postProcessBeforeInstantiation方法【在实例化之前调用】</div><div class="line">*   2、applyBeanPostProcessorsAfterInitialization：如果postProcessBeforeInstantiation方法返回了快捷的Bean，内部遍历调用postProcessBeforeInstantiation方法【在初始化之后调用】</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">resolveBeforeInstantiation</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</div><div class="line">		Object bean = <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;</div><div class="line">			<span class="comment">// Make sure bean class is actually resolved at this point.</span></div><div class="line">			<span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</div><div class="line">				Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);</div><div class="line">				<span class="keyword">if</span> (targetType != <span class="keyword">null</span>) &#123;</div><div class="line">				    <span class="comment">//调用方法，内部遍历调用postProcessBeforeInstantiation方法【在实例化之前调用】</span></div><div class="line">					bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</div><div class="line">					<span class="comment">//如果返回了快捷的Bean</span></div><div class="line">					<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</div><div class="line">					    <span class="comment">//如果postProcessBeforeInstantiation方法返回了快捷的Bean，内部遍历调用postProcessBeforeInstantiation方法【在初始化之后调用】</span></div><div class="line">						bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			mbd.beforeInstantiationResolved = (bean != <span class="keyword">null</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> bean;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	*   org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInstantiation</div><div class="line">	*   作用：调用postProcessBeforeInstantiation方法</div><div class="line">    */</div><div class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">applyBeanPostProcessorsBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span></span></div><div class="line">    			<span class="keyword">throws</span> BeansException &#123;</div><div class="line">	        <span class="comment">//遍历所有的后置处理器</span></div><div class="line">    		<span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</div><div class="line">    		    <span class="comment">//判断是否是InstantiationAwareBeanPostProcessor类型的，如果是的，调用postProcessBeforeInstantiation方法获取快捷Bean</span></div><div class="line">    			<span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</div><div class="line">    				InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</div><div class="line">    				Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);</div><div class="line">    				<span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</div><div class="line">    					<span class="keyword">return</span> result;</div><div class="line">    				&#125;</div><div class="line">    			&#125;</div><div class="line">    		&#125;</div><div class="line">    		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	*   org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization</div><div class="line">	*   作用：遍历调用postProcessAfterInitialization</div><div class="line">	*/</div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></div><div class="line">    			<span class="keyword">throws</span> BeansException &#123;</div><div class="line">    		Object result = existingBean;</div><div class="line">    		<span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</div><div class="line">    			result = beanProcessor.postProcessAfterInitialization(result, beanName);</div><div class="line">    			<span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">    				<span class="keyword">return</span> result;</div><div class="line">    			&#125;</div><div class="line">    		&#125;</div><div class="line">    		<span class="keyword">return</span> result;</div><div class="line">    	&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException</code>：正常情况下在实例化之后在执行<code>populateBean</code>之前调用</p>
<ul>
<li>返回值：如果有指定的bean的时候返回false，那么后续的属性填充和属性依赖注入【<code>populateBean</code>】将不会执行，同时后续的<code>postProcessPropertyValues</code>将不会执行,但是初始化和<code>BeanPostProcessor</code>的仍然会执行。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean</div><div class="line">* 填充指定Bean的属性</div><div class="line">* 在该方法内部遍历所有的BeanPostPorcessor，调用postProcessAfterInstantiation方法</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, BeanWrapper bw)</span> </span>&#123;</div><div class="line">        <span class="comment">//获取属性</span></div><div class="line">		PropertyValues pvs = mbd.getPropertyValues();</div><div class="line">		<span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">if</span> (!pvs.isEmpty()) &#123;</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</div><div class="line">						mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to null instance"</span>);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				<span class="comment">// Skip property population phase for null instance.</span></div><div class="line">				<span class="keyword">return</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">        <span class="comment">//**********************逻辑开始执行********************</span></div><div class="line">        <span class="comment">//标志，判断是否继续执行属性填充，默认为false</span></div><div class="line">		<span class="keyword">boolean</span> continueWithPropertyPopulation = <span class="keyword">true</span>;</div><div class="line">        <span class="comment">//判断ioc容器中是否存在InstantiationAwareBeanPostProcessors(</span></div><div class="line">		<span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</div><div class="line">		    <span class="comment">//遍历所有的BeanPostProcessor</span></div><div class="line">			<span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</div><div class="line">			    <span class="comment">//判断类型是InstantiationAwareBeanPostProcessor</span></div><div class="line">				<span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</div><div class="line">					InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</div><div class="line">					<span class="comment">//执行postProcessAfterInstantiation方法</span></div><div class="line">					<span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</div><div class="line">					    <span class="comment">//返回结果为false，那么赋值continueWithPropertyPopulation=false，表示不继续执行属性填充</span></div><div class="line">						continueWithPropertyPopulation = <span class="keyword">false</span>;</div><div class="line">						<span class="keyword">break</span>;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">        <span class="comment">//如果continueWithPropertyPopulation为false，直接返回，不执行下面的步骤</span></div><div class="line">		<span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">        <span class="comment">//</span></div><div class="line">		<span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</div><div class="line">				mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</div><div class="line">			MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</div><div class="line"></div><div class="line">			<span class="comment">// Add property values based on autowire by name if applicable.</span></div><div class="line">			<span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</div><div class="line">				autowireByName(beanName, mbd, bw, newPvs);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="comment">// Add property values based on autowire by type if applicable.</span></div><div class="line">			<span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</div><div class="line">				autowireByType(beanName, mbd, bw, newPvs);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			pvs = newPvs;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</div><div class="line">		<span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</div><div class="line">			PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</div><div class="line">			<span class="keyword">if</span> (hasInstAwareBpps) &#123;</div><div class="line">			    <span class="comment">//同样是遍历BeanPostProcessor</span></div><div class="line">				<span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</div><div class="line">					<span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</div><div class="line">						InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</div><div class="line">						<span class="comment">//执行postProcessPropertyValues方法</span></div><div class="line">						pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</div><div class="line">						<span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</div><div class="line">							<span class="keyword">return</span>;</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (needsDepCheck) &#123;</div><div class="line">				checkDependencies(beanName, mbd, filteredPds, pvs);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//重要的一步，设置属性</span></div><div class="line">		applyPropertyValues(beanName, mbd, bw, pvs);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</code>：实例化之后调用，在方法<code>applyPropertyValues</code>【属性填充】之前</p>
<ul>
<li>返回值：如果返回null，那么将不会进行后续的属性填充，比如依赖注入等，如果返回的pvs额外的添加了属性，那么后续会填充到该类对应的属性中。</li>
<li>pvs：PropertyValues对象，用于封装指定类的对象，简单来说就是PropertyValue的集合，里面相当于以key-value形式存放类的属性和值</li>
<li>pds：PropertyDescriptor对象数组，PropertyDescriptor相当于存储类的属性，不过可以调用set，get方法设置和获取对应属性的值<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean的代码片段</div><div class="line">*/</div><div class="line"><span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</div><div class="line">			PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</div><div class="line">			<span class="keyword">if</span> (hasInstAwareBpps) &#123;</div><div class="line">			    <span class="comment">//遍历调用postProcessPropertyValues方法</span></div><div class="line">				<span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</div><div class="line">					<span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</div><div class="line">						InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</div><div class="line">						pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</div><div class="line">						<span class="comment">//如果返回的pvs是null，直接返回</span></div><div class="line">						<span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</div><div class="line">							<span class="keyword">return</span>;</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (needsDepCheck) &#123;</div><div class="line">				checkDependencies(beanName, mbd, filteredPds, pvs);</div><div class="line">			&#125;</div><div class="line">		&#125;   </div><div class="line">        <span class="comment">//执行真正的属性填充</span></div><div class="line">		applyPropertyValues(beanName, mbd, bw, pvs);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><ul>
<li>只是写了<code>InstantiationAwareBeanPostProcessor</code>定义的方法，另外的<code>BeanPostProcessor</code>的方法，<a href="https://chenjiabing666.github.io/2019/06/23/Bean%E7%9A%84%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8/">请看上一篇文章</a><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInstantiationAwareBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">InstantiationAwareBeanPostProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 在实例化之前调用，如果返回null，一切按照正常顺序执行，如果返回的是一个实例的对象，那么这个将会跳过实例化、初始化的过程</div><div class="line">     * <span class="doctag">@param</span> beanClass</div><div class="line">     * <span class="doctag">@param</span> beanName</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (beanClass == User.class) &#123;</div><div class="line">            System.out.println(<span class="string">"postProcessBeforeInstantiation执行"</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 在实例化之后，postProcessBeforeInitialization之前执行</div><div class="line">     * <span class="doctag">@param</span> bean</div><div class="line">     * <span class="doctag">@param</span> beanName</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     * <span class="doctag">@throws</span> BeansException</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> User) &#123;</div><div class="line">            System.out.println(<span class="string">"postProcessAfterInstantiation执行"</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 实例化之后调用，属性填充之前</div><div class="line">     * <span class="doctag">@param</span> pvs PropertyValues对象，用于封装指定类的对象，简单来说就是PropertyValue的集合，里面相当于以key-value形式存放类的属性和值</div><div class="line">     * <span class="doctag">@param</span> pds PropertyDescriptor对象数组，PropertyDescriptor相当于存储类的属性，不过可以调用set，get方法设置和获取对应属性的值</div><div class="line">     * <span class="doctag">@param</span> bean 当前的bean</div><div class="line">     * <span class="doctag">@param</span> beanName beanName</div><div class="line">     * <span class="doctag">@return</span> 如果返回null，那么将不会进行后续的属性填充，比如依赖注入等，如果返回的pvs额外的添加了属性，那么后续会填充到该类对应的属性中。</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (pvs <span class="keyword">instanceof</span> MutablePropertyValues&amp;&amp;bean <span class="keyword">instanceof</span> User)&#123;</div><div class="line">           MutablePropertyValues mutablePropertyValues= (MutablePropertyValues) pvs;</div><div class="line">           HashMap&lt;Object, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">           map.put(<span class="string">"name"</span>,<span class="string">"陈加兵"</span>);</div><div class="line">           map.put(<span class="string">"age"</span>,<span class="number">44</span>);</div><div class="line">           mutablePropertyValues.addPropertyValues(map);</div><div class="line">           <span class="keyword">return</span> mutablePropertyValues;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**使用pds设置值</span></div><div class="line">        if (bean instanceof User) &#123;</div><div class="line">            for (PropertyDescriptor descriptor:pds) &#123;</div><div class="line">                try &#123;</div><div class="line">                    if ("name".equals(descriptor.getName())) &#123;</div><div class="line">                        descriptor.getWriteMethod().invoke(bean, "陈加兵");</div><div class="line">                    &#125;else if("age".equals(descriptor.getName()))&#123;</div><div class="line">                        descriptor.getWriteMethod().invoke(bean,40);</div><div class="line">                    &#125;</div><div class="line">                &#125;catch (Exception e)&#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return null;</div><div class="line">        &#125;**/</div><div class="line">        <span class="keyword">return</span> pvs;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> User) &#123;</div><div class="line">            System.out.println(<span class="string">"postProcessBeforeInitialization执行"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> bean;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> User) &#123;</div><div class="line">            System.out.println(<span class="string">"postProcessAfterInitialization执行"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> bean;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="源码梳理"><a href="#源码梳理" class="headerlink" title="源码梳理"></a>源码梳理</h1><ul>
<li>无论是BeanPostProcessor还是<code>InstantiationAwareBeanPostProcessor</code>都是在对象实例化和初始化前后执行的逻辑，因此我们主要的代码都在<code>getBean</code>，<code>doGetBean</code>，<code>cerateBean</code>方法中</li>
<li><code>BeanPostProcessor</code>的两个方法的执行源码请看<a href="https://chenjiabing666.github.io/2019/06/23/Bean%E7%9A%84%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8/">上一篇的文章</a></li>
<li>步骤如下：<ul>
<li><img src="https://github.com/chenjiabing666/BlogImage/blob/master/spring4.png?raw=true" alt=""></li>
<li><img src="https://github.com/chenjiabing666/BlogImage/blob/master/spring5.png?raw=true" alt=""></li>
<li><img src="https://github.com/chenjiabing666/BlogImage/blob/master/spring6.png?raw=true" alt=""></li>
<li><img src="https://github.com/chenjiabing666/BlogImage/blob/master/spring7.png?raw=true" alt=""></li>
<li><img src="https://github.com/chenjiabing666/BlogImage/blob/master/spring8.png?raw=true" alt=""></li>
<li><img src="https://github.com/chenjiabing666/BlogImage/blob/master/spring9.png?raw=true" alt=""></li>
<li><img src="https://github.com/chenjiabing666/BlogImage/blob/master/spring10.png?raw=true" alt=""></li>
<li><img src="https://github.com/chenjiabing666/BlogImage/blob/master/spring11.png?raw=true" alt=""></li>
<li><img src="https://github.com/chenjiabing666/BlogImage/blob/master/spring12.png?raw=true" alt=""></li>
</ul>
</li>
</ul>
<h1 id="Autowired源码解析"><a href="#Autowired源码解析" class="headerlink" title="Autowired源码解析"></a>Autowired源码解析</h1><ul>
<li>从源码可以看出，Autowired的功能实现最重要的一个接口就是<code>AutowiredAnnotationBeanPostProcessor</code>，继承关系如下：<br><img src="https://github.com/chenjiabing666/BlogImage/blob/master/spring13.png?raw=true" alt=""></li>
<li>从继承关系图可以看出，实际上关键的实现了<code>InstantiationAwareBeanPostProcessor</code>这个接口。</li>
<li>源码实现如下图：<br><img src="https://github.com/chenjiabing666/BlogImage/blob/master/spring14.png?raw=true" alt=""></li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>源码：<ul>
<li>ioc容器创建Bean的方法是从<code>createBean</code>方法进入的，真正执行创建的Bean的是<code>doCreateBean</code>方法，我们从createBean开始往下走<ul>
<li>调用<code>resolveBeforeInstantiation</code>方法【在doCreatBean之前执行，即是实例化之前】，在内部遍历BeanPostProcessor调用<code>postProcessBeforeInstantiation</code>方法</li>
<li>如果<code>postProcessBeforeInstantiation</code>方法返回null，那么需要执行实例化的过程，调用<code>doCreatBean</code>实例化Bean。<ul>
<li><code>doCreateBean</code>内部分为两步：①调用createBeanInstance实例化Bean；②调用<code>populateBean</code>设置Bean的属性</li>
</ul>
</li>
<li>在<code>populateBean</code>内部分为如下的步骤：<ul>
<li>调用<code>postProcessAfterInstantiation</code>【实例化之后调用】，分为两种情况：①返回false，后续的<code>postProcessPropertyValues</code>将不再执行，属性也不在进行设置；②返回true，程序照常进行，调用<code>postProcessPropertyValues</code>，属性设置的过程正常进行</li>
</ul>
</li>
<li>执行完<code>populateBean</code>之后将会调用<code>initializeBean</code>【初始化Bean，调用afterPropertiesSet方法】，在内部就涉及到BeanPostProcessor定义的接口了，步骤如下：<ul>
<li>执行<code>applyBeanPostProcessorsBeforeInitialization</code>方法调用<code>postProcessBeforeInitialization</code>【在初始化之前调用】方法</li>
<li>执行<code>invokeInitMethods</code>方法，内部其实是调用afterPropeertiesSet方法，进行初始化</li>
<li>执行<code>applyBeanPostProcessorsAfterInitialization</code>，内部调用<code>postProcessAfterInitialization</code>【在实例化之后调用】方法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;继承&lt;code&gt;BeanPostProcessor&lt;/code&gt;接口，在此基础上又定义了三个方法，分别在Bean&lt;strong&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>FactoryBean解析</title>
    <link href="http://chenjiabing666.github.io/2019/06/23/FactoryBean%E8%A7%A3%E6%9E%90/"/>
    <id>http://chenjiabing666.github.io/2019/06/23/FactoryBean解析/</id>
    <published>2019-06-23T13:49:47.000Z</published>
    <updated>2019-06-23T13:50:08.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>简单的说FactoryBean实际上是一个Bean，并不是一个工厂，它能够为我们创建一个Bean，但是创建的这个Bean实际指向的并不是FactoryBean类型的，而是其中<code>getObject</code>方法返回类型的对象。</li>
</ul>
<h1 id="接口解析"><a href="#接口解析" class="headerlink" title="接口解析"></a>接口解析</h1><ul>
<li>FactoryBean中有三个需要实现的方法，如下：<ul>
<li><code>getObject()</code> ：获取返回的对象，此处返回的对象会被注入到ioc容器中</li>
<li><code>public Class&lt;?&gt; getObjectType()</code>：返回创建Bean类型</li>
<li><code>public boolean isSingleton()</code>：返回是否创建单例，如果返回true，那么创建的对象将是单例的，返回false，创建的是多实例的对象。</li>
</ul>
</li>
</ul>
<h1 id="自定义实现"><a href="#自定义实现" class="headerlink" title="自定义实现"></a>自定义实现</h1><ul>
<li><p>自定义一个FactoryBean，实现Admin的注入，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义FactoryBean，用来创建对象</div><div class="line"> * 1、<span class="doctag">@Component</span> :将创建的MyFactoryBean注入到容器中</div><div class="line"> * 2、实现FactoryBean</div><div class="line"> * 3、指定泛型&lt;T&gt;</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Admin</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Admin <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"创建Admin"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Admin();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</div><div class="line">        <span class="keyword">return</span> Admin.class;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>此时即可从容器中获取到对应的Bean了，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFactoryBean</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//根据id获取实例，这里实际获取的是getObject返回的对象</span></div><div class="line">    Admin admin1 = applicationContext.getBean(<span class="string">"myFactoryBean"</span>, Admin.class);</div><div class="line">    System.out.println(admin1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>以上是获取的实例Bean，现在我们就想获取MyBeanFactory本身这个对象，可以在id的前面加上<code>&amp;</code>即可，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFactoryBean2</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//根据&amp;id获取实例，实际获取的就是MyFactoryBean的对象</span></div><div class="line">    MyFactoryBean bean = applicationContext.getBean(<span class="string">"&amp;myFactoryBean"</span>, MyFactoryBean.class);</div><div class="line">    System.out.println(bean);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><ul>
<li>指定的是FactoryBean的id，为什么获取的是getObject返回的对象？<ul>
<li>简单的逻辑：判断传入的类型是否是<code>FactoryBean</code>类型，如果是该类型的，调用getObject方法返回对象即可。</li>
<li>在源码中可以看到调用的是<code>org.springframework.beans.factory.support.FactoryBeanRegistrySupport#doGetObjectFromFactoryBean</code>方法</li>
<li><img src="https://github.com/chenjiabing666/BlogImage/blob/master/spring2.png?raw=true" alt=""></li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;简单的说FactoryBean实际上是一个Bean，并不是一个工厂，它能够为我们创建一个Bean，但是创建的这个Bean实际指向
    
    </summary>
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Bean的后置处理器</title>
    <link href="http://chenjiabing666.github.io/2019/06/23/Bean%E7%9A%84%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>http://chenjiabing666.github.io/2019/06/23/Bean的后置处理器/</id>
    <published>2019-06-23T13:48:55.000Z</published>
    <updated>2019-06-23T13:49:26.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>调用顺序：在Bean的初始化前后调用，分别对应了其中的两个方法</li>
<li>Bean的后置处理器对应的接口是<code>BeanPostProcessor</code>，其中定义了两个方法，如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 在Bean初始化之前执行，即是在执行Bean的构造方法之后，在执行InitializingBean的afterPropertiesSet方法之前执行</div><div class="line">	 */</div><div class="line">	<span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">         * 在Bean的初始化之后执行，即是在InitializingBean的afterPropertiesSet方法之后执行</div><div class="line">	 */</div><div class="line">	<span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>在Bean的初始化前后做一些自己的逻辑处理，比如为Bean设置一些额外的属性。<ul>
<li>最典型的例子就是spring中的Aware接口的实现，都是利用<code>BeanPostProcessor</code>在Bean初始化之前进行调用set方法设置相应的属性【详情请看<code>ApplicationContextAwareProcessor</code>源码】</li>
<li><code>@Autowired</code>的实现依赖注入也是使用的BeanPostProcessor的原理，详情请看<code>AutowiredAnnotationBeanPostProcessor</code>的源码</li>
</ul>
</li>
</ul>
<h2 id="自定义后置处理器"><a href="#自定义后置处理器" class="headerlink" title="自定义后置处理器"></a>自定义后置处理器</h2><ul>
<li>必备条件：<ul>
<li>自定义的后置处理器必须注入到容器中</li>
<li>必须实现<code>BeanPostProcessor</code>接口，实现其中的方法</li>
</ul>
</li>
</ul>
<ul>
<li><p>自定义一个User类，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 实现InitializingBean接口，定义初始化方法，在构造方法之后执行</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">InitializingBean</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Integer age;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, Integer age)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"执行构造方法"</span>);</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"执行初始化方法，在构造方法执行之后执行"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>自定义后置处理器，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 1、自定义的后置处理器,实现BeanPostProcessor</div><div class="line"> * 2、必须注入到容器中才能执行</div><div class="line"> * 3、后置处理器是每一个Bean实例化前后都会调用的，并不能指定某一个</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 在Bean初始化之前执行，即是在执行Bean的构造方法之后，在执行InitializingBean的afterPropertiesSet方法之前执行</div><div class="line">     * <span class="doctag">@param</span> bean bean的对象</div><div class="line">     * <span class="doctag">@param</span> beanName bean的名字，即是在ioc容器中的id</div><div class="line">     * <span class="doctag">@return</span> 一定不能null</div><div class="line">     * <span class="doctag">@throws</span> BeansException</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        <span class="comment">//如果这个Bean是User类型</span></div><div class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> User)&#123;</div><div class="line">            System.out.println(<span class="string">"在User的初始化方法【afterPropertiesSet】之前执行"</span>);</div><div class="line">            <span class="comment">//改变属性的值</span></div><div class="line">            User user=(User)bean;</div><div class="line">            user.setName(<span class="string">"马云"</span>);</div><div class="line">            user.setAge(<span class="number">40</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> bean;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 在Bean的初始化之后执行，即是在InitializingBean的afterPropertiesSet方法之后执行</div><div class="line">     * <span class="doctag">@param</span> bean bean的对象</div><div class="line">     * <span class="doctag">@param</span> beanName bean的名字，即是在ioc容器中的id</div><div class="line">     * <span class="doctag">@return</span> 一定不能null</div><div class="line">     * <span class="doctag">@throws</span> BeansException</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> User)&#123;</div><div class="line">            System.out.println(<span class="string">"在User的初始化方法【afterPropertiesSet】之后执行"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> bean;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><ul>
<li>最重要的就是后置处理器两个方法的执行顺序：<ul>
<li>为什么<code>postProcessBeforeInitialization</code>在构造方法之后，初始化之前调用？</li>
<li>为什么<code>postProcessAfterInitialization</code>在初始化之后调用？</li>
</ul>
</li>
<li>我们分别在自定义的后置处理器上打上断点，通过debug模式跟踪代码，程序的入口测试类如下：<ul>
<li>使用<code>AnnotationConfigApplicationContext</code>启动容器<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstConfigTest</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> AnnotationConfigApplicationContext applicationContext;</div><div class="line"></div><div class="line">    <span class="meta">@Before</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initApplicationContext</span><span class="params">()</span> </span>&#123;</div><div class="line">        applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(FirstConfig.class);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>执行AnnotationConfigApplicationContext的构造方法<code>public AnnotationConfigApplicationContext(Class&lt;?&gt;... annotatedClasses)</code>： <ol>
<li><code>register(annotatedClasses)</code>：注入指定的配置类<code>FirstConfig</code></li>
<li><strong>【<code>refresh()</code>：刷新容器，在这个执行结束之后会完成Bean的加载，详情见第2步】</strong></li>
</ol>
</li>
<li>进入<code>org.springframework.context.support.AbstractApplicationContext#refresh</code>方法：<ol>
<li><code>prepareRefresh();</code>：在刷新容器之前做一些准备工作，比如设置激活状态【activate】,设置启动时间【startupDate】</li>
<li><code>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</code><ol>
<li><code>refreshBeanFactory()</code>：刷新BeanFactory，如果之前存在了就删除创建新的，返回的是</li>
<li>返回<code>ConfigurableListableBeanFactory</code>类型的Bean工厂</li>
</ol>
</li>
<li><code>prepareBeanFactory(beanFactory);</code>：对新创建的Bean工厂设置一些属性配置<ol>
<li>设置ClassLoader、表达式解析器、属性注入器</li>
<li><strong>设置<code>ApplicationContextAwareProcessor</code>这个后置处理器到<code>org.springframework.beans.factory.support.AbstractBeanFactory#beanPostProcessors</code>该成员变量中、去除一些不能自动注入的类【ResourceLoaderAware、ApplicationEventPublisherAware、MessageSourceAware、ApplicationContextAware、EnvironmentAware】，因为这些Aware类型的类需要后续自定义实现的</strong></li>
<li><strong>向容器中注入一些能够自动注入的类【BeanFactory，ResourceLoader，ApplicationEventPublisher，ApplicationContext】，这些类能够直接通过<code>@Autowired</code>直接注入使用</strong></li>
<li><strong>向容器中注入一些运行环境的Bean【<code>ConfigurableEnvironment</code>、<code>systemProperties(Map&lt;String,Object&gt;</code>其中存放的是配置参数)】，这些Bean可以直接自动注入使用</strong></li>
</ol>
</li>
<li><code>invokeBeanFactoryPostProcessors(beanFactory)</code>：调用已经注册在容器中的BeanFactory后置处理器</li>
<li><code>registerBeanPostProcessors(beanFactory)</code>：向ioc容器中注册BeanFactoryProcessor</li>
<li><code>initMessageSource()</code>：初始化MessageSource</li>
<li><code>initApplicationEventMulticaster()</code>：初始化事件分发器</li>
<li><code>registerListeners()</code>：注册事件监听器，用来监听事件</li>
<li><strong>【<code>finishBeanFactoryInitialization(beanFactory)</code>：初始化单例、非懒加载的Bean】，详情见步骤3</strong></li>
<li><code>finishRefresh()</code>：发布事件</li>
</ol>
</li>
<li>进入<code>org.springframework.context.support.AbstractApplicationContext#finishBeanFactoryInitialization</code>:<ol>
<li>初始化类型转换类</li>
<li>初始化<code>LoadTimeWeaverAware</code>，用于方法织入</li>
<li>冻结BeanDefinition，表示后面的BeanDefinition不能再改变</li>
<li><strong>【<code>beanFactory.preInstantiateSingletons()</code>：初始化Bean，详情请看第4步】</strong></li>
</ol>
</li>
<li><p>进入到<code>org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons</code>方法中，用于初始化Bean</p>
<ol>
<li>遍历所有的BeanNames，判断当前Bean是否是FactoryBean，如果不是运行getBean方法</li>
</ol>
</li>
<li><p>进入到<code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#initializeBean</code>，如下图所示，将是完整的逻辑，可以看出后置处理器为什么是在初始化之前和之后执行。</p>
<ol>
<li><img src="https://raw.githubusercontent.com/chenjiabing666/BlogImage/master/spring1.png" alt=""></li>
</ol>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>从源码可以看出，最核心的执行就是在<code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#initializeBean</code>的方法中，主要的代码逻辑是在初始化之前调用对应的before方法，在之后调用after方法。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;调用顺序：在Bean的初始化前后调用，分别对应了其中的两个方法&lt;/li&gt;
&lt;li&gt;Bean的后置处理器对应的接口是&lt;code&gt;B
    
    </summary>
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring注解开发</title>
    <link href="http://chenjiabing666.github.io/2019/06/23/Spring%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/"/>
    <id>http://chenjiabing666.github.io/2019/06/23/Spring注解开发/</id>
    <published>2019-06-23T03:17:49.000Z</published>
    <updated>2019-06-23T03:18:16.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h1><ul>
<li>标注在类上，表明该类是一个配置类，相当于之前写的spring的xml文件，通常与<code>@Bean</code>结合使用</li>
<li>该注解同时拥有了<code>@Component</code>的作用，将当前类注入ioc容器<ul>
<li>其中有一个<code>value</code>属性，指定注入ioc容器的名称，默认是类名首字母小写</li>
<li>源码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Configuration &#123;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h1><ul>
<li>在配置类中使用该注解</li>
<li>标注在方法上，默认将方法的返回对象注入到ioc容器，名称默认使用的是方法名<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 配置类</div><div class="line"> */</div><div class="line"><span class="meta">@Configuration</span>(value = <span class="string">"MyConfiguration"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 注入一个User对象，ioc容器中的name是user，类型是User类型</div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">"name"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul>
<li><code>name</code>：指定注入ioc容器中的名称</li>
<li><code>value</code>：同name</li>
<li><code>autowireCandidate</code>：是否能够自动注入，默认是true，如果指定了属性为false，那么不能使用<code>@Autowired</code>或者<code>@Resource</code>自动注入</li>
<li><code>initMethod</code>：指定初始化方法，在构造方法之后执行</li>
<li><code>destroyMethod</code>：指定销毁方法，在容器关闭的时候执行</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 配置类</div><div class="line"> */</div><div class="line"><span class="meta">@Configuration</span>(value = <span class="string">"MyConfiguration"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 注入一个User对象，ioc容器中的name是user，类型是User类型</div><div class="line">     * init是User类中的init方法，destory是User类中的destory方法</div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>,destroyMethod = <span class="string">"destory"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user1</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">"name"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* User类</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Integer id;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Integer id, String name)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"执行构造方法"</span>);</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"初始化方法"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"销毁方法"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h1><ul>
<li>指定对象的作用域名，标注在类上或者方法上，默认是单实例</li>
</ul>
<h2 id="四大作用域"><a href="#四大作用域" class="headerlink" title="四大作用域"></a>四大作用域</h2><ul>
<li><code>singleton</code>：单例，默认值，当容器启动的时候会创建对象放入ioc容器中，后续获取只是从容器中创建，并不会再次调用构造方法new出来</li>
<li><code>prototype</code>：多实例，容器启动的时候并不会创建该对象，而是当需要用到的才调用构造方法new出来（不放入ioc容器，每次用到就new一个）</li>
<li><code>request</code>：该属性仅对HTTP请求产生作用，使用该属性定义Bean时，每次HTTP请求都会创建一个新的Bean，适用于WebApplicationContext环境。</li>
<li><code>session</code>：该属性仅用于HTTP Session，同一个Session共享一个Bean实例。不同Session使用不同的实例。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * 指定多实例，每次用到都会调用</div><div class="line">    */</div><div class="line">   <span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>,destroyMethod = <span class="string">"destory"</span>)</div><div class="line">   <span class="meta">@Scope</span>(value = <span class="string">"prototype"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> User <span class="title">user1</span><span class="params">()</span></span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">"name"</span>);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h1 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h1><ul>
<li>标注在方法或者在类上，只有在满足其中的匹配条件才会将对象注入到ioc容器中。</li>
<li>只有一个属性value，是一个<code>Condition</code>数组，要向实现相应的功能，可以自定义一个类，实现<code>Condition</code>这个接口即可。</li>
<li><p>这个注解在SpringBoot中将会有很多的扩展，这里就不多说了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * 指定多实例，每次用到都会调用</div><div class="line">     * <span class="doctag">@Conditional</span> 只有里面全部都匹配才会正常注入到容器中</div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>,destroyMethod = <span class="string">"destory"</span>)</div><div class="line">    <span class="meta">@Conditional</span>(value = &#123;FirstCondition.class&#125;)</div><div class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user1</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">"name"</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>下面看看<code>FirstCondition</code>这个类具体实现</p>
<ul>
<li>只需要实现接口中的<code>matches</code>方法即可，返回true表示符合条件，否则不满足条件，只有满足条件才会注入到ioc容器中<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义的条件判断，实现Condition接口</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 如果返回true表示符合条件，反之不符合条件</div><div class="line">     * <span class="doctag">@param</span> context ConditionContext对象，可以获取上下文的信息</div><div class="line">     * <span class="doctag">@param</span> metadata AnnotatedTypeMetadata对象，可以获取标注在该方法上面的注解信息</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</div><div class="line">        <span class="comment">//获取Environment，用来获取运行环境中的一些变量</span></div><div class="line">        Environment environment = context.getEnvironment();</div><div class="line">        <span class="comment">//获取在properties文件中配置的参数，表示是否注入相关属性</span></div><div class="line">        Boolean isAutowired = environment.&lt;Boolean&gt;getProperty(<span class="string">"isAutowired"</span>, Boolean.class);</div><div class="line">        <span class="keyword">return</span> isAutowired;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="ConditionContext"><a href="#ConditionContext" class="headerlink" title="ConditionContext"></a>ConditionContext</h2><ul>
<li>主要的功能是获取上下文的对象，比如BeanFactory<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConditionContext</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	* 获取 BeanDefinitionRegistry，可以自己手动注册对象到ioc容器中</div><div class="line">    */</div><div class="line">	<span class="function">BeanDefinitionRegistry <span class="title">getRegistry</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 获取BeanFacotory，操作ioc容器，比如获取对应的Bean，判断ioc中是否已经注入   </div><div class="line">	 */</div><div class="line">	<span class="meta">@Nullable</span></div><div class="line">	<span class="function">ConfigurableListableBeanFactory <span class="title">getBeanFactory</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回当前的运行环境，可以获取运行环境中的一下参数，或者一些配置文件中的数据</div><div class="line">	 */</div><div class="line">	<span class="function">Environment <span class="title">getEnvironment</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 获取资源加载器</div><div class="line">	 */</div><div class="line">	<span class="function">ResourceLoader <span class="title">getResourceLoader</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 获取类加载器 </div><div class="line">	 */</div><div class="line">	<span class="meta">@Nullable</span></div><div class="line">	<span class="function">ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="AnnotatedTypeMetadata"><a href="#AnnotatedTypeMetadata" class="headerlink" title="AnnotatedTypeMetadata"></a>AnnotatedTypeMetadata</h2><ul>
<li>主要的作用就是获取标注了<code>@Conditional</code>这个注解的方法上的注解和对应的参数等信息<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnnotatedTypeMetadata</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	* 判断方法上是否有对应的注解 </div><div class="line">    * <span class="doctag">@param</span> annotationName 注解类的全类名，getName()</div><div class="line">    */</div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isAnnotated</span><span class="params">(String annotationName)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	*  获取对应注解的全部属性的值，key是属性，value是属性的值</div><div class="line">    * <span class="doctag">@param</span> annotationName 注解类的全类名，getName()</div><div class="line">    */</div><div class="line">	<span class="meta">@Nullable</span></div><div class="line">	<span class="function">Map&lt;String, Object&gt; <span class="title">getAnnotationAttributes</span><span class="params">(String annotationName)</span></span>;</div><div class="line"></div><div class="line">	<span class="meta">@Nullable</span></div><div class="line">	<span class="function">Map&lt;String, Object&gt; <span class="title">getAnnotationAttributes</span><span class="params">(String annotationName, <span class="keyword">boolean</span> classValuesAsString)</span></span>;</div><div class="line"></div><div class="line">	<span class="meta">@Nullable</span></div><div class="line">	<span class="function">MultiValueMap&lt;String, Object&gt; <span class="title">getAllAnnotationAttributes</span><span class="params">(String annotationName)</span></span>;</div><div class="line"></div><div class="line">	<span class="meta">@Nullable</span></div><div class="line">	<span class="function">MultiValueMap&lt;String, Object&gt; <span class="title">getAllAnnotationAttributes</span><span class="params">(String annotationName, <span class="keyword">boolean</span> classValuesAsString)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h1><ul>
<li>标注在方法上，用来在类加载并且属性赋值之后调用，通常用来初始化，和<code>@Bean</code>中的<code>init-menthd</code>指定的作用相同<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@PostConstruct</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"初始化方法"</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="PreDestroy"><a href="#PreDestroy" class="headerlink" title="@PreDestroy"></a>@PreDestroy</h1><ul>
<li>标注在方法上，容器销毁执行，相当于<code>@Bean</code>中的<code>destroy-method</code>属性<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@PreDestroy</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"销毁方法"</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h1><ul>
<li>用来形式化的注入，主要形式有：<ul>
<li>直接导入类</li>
<li>导入配置类</li>
<li>指定ImportSelector</li>
<li>使用ImportBeanDefinitionRegistrar手动注册</li>
</ul>
</li>
</ul>
<h2 id="直接导入类"><a href="#直接导入类" class="headerlink" title="直接导入类"></a>直接导入类</h2><ul>
<li>直接在 <code>value</code>属性中指定需要导入的类即可，如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span>(value = <span class="string">"MyConfiguration"</span>)</div><div class="line"><span class="meta">@Import</span>(value = &#123;Person.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="导入配置类"><a href="#导入配置类" class="headerlink" title="导入配置类"></a>导入配置类</h2><ul>
<li><p>新建一个配置类，但是不用<code>@Configuration</code>标注，使用<code>@Import</code>在另外一个配置类上引入即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 这是一个配置，但是并没有使用<span class="doctag">@Configuration</span>这个注解，因此不会生效</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondConfiguration</span> </span>&#123;</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在另外一个配置类使用<code>@Import</code>注解引入上面的配置类，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span>(value = <span class="string">"MyConfiguration"</span>)</div><div class="line"><span class="meta">@Import</span>(value = &#123;SecondConfiguration.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="指定ImportSelector"><a href="#指定ImportSelector" class="headerlink" title="指定ImportSelector"></a>指定ImportSelector</h2><ul>
<li><p>使用ImportSelector需要自定义一个实现类，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义Selector，需要实现ImportSelector</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 筛选逻辑，返回的是String数组（需要注入到容器中的类的全类名）</div><div class="line">     * <span class="doctag">@param</span> importingClassMetadata AnnotationMetadata对象，对标注了<span class="doctag">@Import</span>这个注解的类中的所有注解信息，比如获取标注指定注解的方法</div><div class="line">     * <span class="doctag">@return</span> 返回的是需要注入的字符串数组（类的全类名）</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</div><div class="line">        <span class="comment">//获取@Import标注的类中被@Bean标注的方法元数据</span></div><div class="line">        Set&lt;MethodMetadata&gt; annotatedMethods = importingClassMetadata.getAnnotatedMethods(Bean.class.getName());</div><div class="line">        annotatedMethods.forEach(o-&gt;&#123;</div><div class="line">            System.out.println(o.getMethodName());</div><div class="line">        &#125;);</div><div class="line">        <span class="comment">//将Person类返回去，那么将会自动注入Person</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;Person.class.getName()&#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在配置类上使用<code>@Import</code>注解引入即可，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@Import</span>(value = &#123;FirstSelector.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="AnnotationMetadata"><a href="#AnnotationMetadata" class="headerlink" title="AnnotationMetadata"></a>AnnotationMetadata</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnnotationMetadata</span> <span class="keyword">extends</span> <span class="title">ClassMetadata</span>, <span class="title">AnnotatedTypeMetadata</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">//拿到Class上标注的所有注解，依赖于Class#getAnnotations</span></div><div class="line">	<span class="function">Set&lt;String&gt; <span class="title">getAnnotationTypes</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">// 拿到所有的元注解信息AnnotatedElementUtils#getMetaAnnotationTypes</span></div><div class="line">	<span class="comment">//annotationName:注解类型的全类名</span></div><div class="line">	<span class="function">Set&lt;String&gt; <span class="title">getMetaAnnotationTypes</span><span class="params">(String annotationName)</span></span>;</div><div class="line">	<span class="comment">// 是否包含指定注解 （annotationName：全类名）</span></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">hasAnnotation</span><span class="params">(String annotationName)</span></span>;</div><div class="line">	<span class="comment">//这个厉害了，依赖于AnnotatedElementUtils#hasMetaAnnotationTypes</span></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">hasMetaAnnotation</span><span class="params">(String metaAnnotationName)</span></span>;</div><div class="line">	<span class="comment">// 类里面只有有一个方法标注有指定注解，就返回true</span></div><div class="line">	<span class="comment">//getDeclaredMethods获得所有方法， AnnotatedElementUtils.isAnnotated是否标注有指定注解</span></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">hasAnnotatedMethods</span><span class="params">(String annotationName)</span></span>;</div><div class="line">	<span class="comment">// 注意返回的是MethodMetadata 原理基本同上</span></div><div class="line">	<span class="comment">// .getDeclaredMethods和AnnotatedElementUtils.isAnnotated  最后吧Method转为MethodMetadata</span></div><div class="line">	<span class="function">Set&lt;MethodMetadata&gt; <span class="title">getAnnotatedMethods</span><span class="params">(String annotationName)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="使用ImportBeanDefinitionRegistrar手动注册"><a href="#使用ImportBeanDefinitionRegistrar手动注册" class="headerlink" title="使用ImportBeanDefinitionRegistrar手动注册"></a>使用ImportBeanDefinitionRegistrar手动注册</h2><ul>
<li><p>需要自定义一个类实现<code>ImportBeanDefinitionRegistrar</code>，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义的FirstBeanDefinitionRegistrar，需要实现ImportBeanDefinitionRegistrar</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 自己手动注册Bean到ioc容器中</div><div class="line">     * <span class="doctag">@param</span> importingClassMetadata 获取<span class="doctag">@Import</span>标注的类上的注解信息，比如获取被指定注解标注的方法信息</div><div class="line">     * <span class="doctag">@param</span> registry  注册中心，可以获取指定bean的信息和手动注册bean</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</div><div class="line">        <span class="comment">//如果容器中没有Person这个Bean，就创建一个</span></div><div class="line">        <span class="keyword">if</span> (!registry.containsBeanDefinition(Person.class.getName()))&#123;</div><div class="line">            GenericBeanDefinition beanDefinition=<span class="keyword">new</span> GenericBeanDefinition();</div><div class="line">            beanDefinition.setBeanClass(Person.class);</div><div class="line">            <span class="comment">//手动注册</span></div><div class="line">            registry.registerBeanDefinition(<span class="string">"person"</span>,beanDefinition);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在配置类上使用<code>@Import</code>注解引入即可，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@Import</span>(value = &#123;FirstBeanDefinitionRegistrar.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="Primary"><a href="#Primary" class="headerlink" title="@Primary"></a>@Primary</h1><ul>
<li>在spring 中使用注解，常使用@Autowired， 默认是根据类型Type来自动注入的。但有些特殊情况，对同一个接口，可能会有几种不同的实现类，而默认只会采取其中一种的情况下 @Primary 的作用就出来了。</li>
<li>有两种使用方式，一种是结合<code>@Bean</code>，另外一种是结合<code>@Service,@Component,@Controller.....</code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="meta">@Primary</span></div><div class="line"><span class="function"><span class="keyword">public</span> User <span class="title">user1</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">"user1"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//第二种</span></div><div class="line"><span class="meta">@Primary</span></div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> Integer age;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h1><ul>
<li>标注在方法和属性上，用来自动为成员变量赋值</li>
<li>默认先根据属性的类型从ioc容器中查找，如果ioc容器中存在多个类型相同的属性，将会根据<strong>变量名</strong>从ioc容器中查找。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> UserService userService;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><ul>
<li><code>required</code>：指定该属性是否是必须的，默认为true，表示一定要为属性赋值，如果ioc容器中没有对应的Bean，那个将会报错，如果为false，会先从ioc容器中查找对应的Bean，如果存在就进行赋值，不存在就不赋值，不会报错。</li>
</ul>
<h1 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h1><ul>
<li>和<code>@Autowired</code>结合使用，用来从容器中注入指定名字的Bean</li>
<li>使用场景：容器中存在多个类型相同的Bean,那么此时仅仅使用<code>@Autowired</code>就不太适用了，此时就要结合该注解，指定需要注入的name。（当然除了<code>@Autowired</code>还是可以根据成员变量的名称进行注入的）<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="meta">@Qualifier</span>(value = <span class="string">"userService"</span>)</div><div class="line">    <span class="keyword">private</span> UserService userService;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h1><ul>
<li>从配置文件中读取相关配置注入到指定的成员属性中<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="meta">@PropertySource</span>(value = &#123;<span class="string">"classpath:user.properties"</span>&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> Integer age;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, Integer age)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h2><ul>
<li><code>value</code>：指定资源文件的位置</li>
<li><code>ignoreResourceNotFound</code>：是否忽略资源文件不存在，默认为false，表示如果资源文件不存在，那么将会抛出异常，如果为true，资源文件不存在的话，程序正常运行</li>
</ul>
<h1 id="Value"><a href="#Value" class="headerlink" title="@Value()"></a>@Value()</h1><ul>
<li>有三个典型的使用场景：<ul>
<li>获取配置文件中对应的值，为指定属性赋值</li>
<li>使用指定的值为属性赋值</li>
<li>通过表达式计算得到的值为属性赋值</li>
</ul>
</li>
</ul>
<h2 id="获取配置文件中的值为属性赋值"><a href="#获取配置文件中的值为属性赋值" class="headerlink" title="获取配置文件中的值为属性赋值"></a>获取配置文件中的值为属性赋值</h2><ul>
<li>使用<code>${}</code>的方式获取配置文件中设置的值<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;name&#125;"</span>)</div><div class="line"><span class="keyword">private</span> String name;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="使用指定的值"><a href="#使用指定的值" class="headerlink" title="使用指定的值"></a>使用指定的值</h2><ul>
<li>其中的<code>value</code>属性可以是自己随便指定的值，如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Value</span>(<span class="string">"陈加兵"</span>)</div><div class="line"><span class="keyword">private</span> String name;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="表达式赋值"><a href="#表达式赋值" class="headerlink" title="表达式赋值"></a>表达式赋值</h2><ul>
<li>表达式的计算需要使用<code>#{}</code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Value</span>(<span class="string">"#&#123;10+22&#125;"</span>)</div><div class="line"><span class="keyword">private</span> Integer age;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="Profile"><a href="#Profile" class="headerlink" title="@Profile"></a>@Profile</h1><ul>
<li>未完待续。。。。。。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Configuration&quot;&gt;&lt;a href=&quot;#Configuration&quot; class=&quot;headerlink&quot; title=&quot;@Configuration&quot;&gt;&lt;/a&gt;@Configuration&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;标注在类上，表明该类是一个配置类，相
    
    </summary>
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring中的Aware解析</title>
    <link href="http://chenjiabing666.github.io/2019/06/12/Spring%E4%B8%AD%E7%9A%84Aware%E8%A7%A3%E6%9E%90/"/>
    <id>http://chenjiabing666.github.io/2019/06/12/Spring中的Aware解析/</id>
    <published>2019-06-12T11:33:01.000Z</published>
    <updated>2019-06-23T14:05:13.567Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Spring框架中提供了许多实现了Aware接口的类，这些类主要是为了辅助Spring访问容器中的数据，比如<code>BeanNameAware</code>，这个类能够在Spring容器加载的过程中将Bean的名字（id）赋值给变量。</li>
</ul>
<h2 id="常用的Aware"><a href="#常用的Aware" class="headerlink" title="常用的Aware"></a>常用的Aware</h2><ul>
<li><code>BeanNameAware</code>：能够获取bean的名称，即是id</li>
<li><code>BeanFactoryAware</code>：获取BeanFactory实例</li>
<li><code>ApplicationContextAware</code>：获取<code>ApplicationContext</code></li>
<li><code>MessageSourceAware</code>：获取MessageSource</li>
<li><code>ResourceLoaderAware</code>：获取<code>ResourceLoader</code></li>
<li><code>EnvironmentAware</code>：获取<code>Environment</code></li>
</ul>
<h2 id="ApplicationContextAware"><a href="#ApplicationContextAware" class="headerlink" title="ApplicationContextAware"></a>ApplicationContextAware</h2><ul>
<li>ApplicationContext可以获取容器中的bean，但是必须注入才能使用，当一些类不能注入的时候怎么才能获得bean呢？比如Utils中的类，通常不能直接通过注入直接使用ApplicationContext，此时就需要借助<code>ApplicationContextAware</code>这个接口了。</li>
<li><code>ApplicationContextAware</code>的实现类如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义一个实现类，一定要注入到容器中</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextAwareImpl</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 容器启动的时候会调用这个方法，只需要将applicationContext设置即可</div><div class="line">     * <span class="doctag">@param</span> applicationContext 容器启动会自动注入</div><div class="line">     * <span class="doctag">@throws</span> BeansException</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        <span class="comment">//将其设置到ApplicationContextUtil</span></div><div class="line">        ApplicationContextUtil.setApplicationContext(applicationContext);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>ApplicationContextUtil</code>如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * ApplicationContext的工具类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextUtil</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * ApplicationContext对象，会ApplicationContextAwareImpl中的setApplicationContext方法中赋值</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title">getApplicationContext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> applicationContext;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</div><div class="line">        ApplicationContextUtil.applicationContext = applicationContext;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 根据类型获取指定的bean</div><div class="line">     * <span class="doctag">@param</span> requiredType Class</div><div class="line">     * <span class="doctag">@param</span> &lt;T&gt; 泛型</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType )</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> applicationContext.getBean(requiredType);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 根据名称和类型获取Bean</div><div class="line">     * <span class="doctag">@param</span> name bean的id</div><div class="line">     * <span class="doctag">@param</span> requiredType class</div><div class="line">     * <span class="doctag">@param</span> &lt;T&gt;</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name,Class&lt;T&gt; requiredType)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> applicationContext.getBean(name,requiredType);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>配置了如上的工具类，那么就可以直接使用ApplicationContextUtil获取ApplicationContext对象了，而不需要注入了，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">StringRedisTemplate redisTemplate=ApplicationContextUtil.getBean(<span class="string">"stringRedisTemplate"</span>,StringRedisTemplate.class);</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>spring底层的一些东西并不能通过自动注入直接从ioc容器中获取，但是spring提供了其他的一些方法获取相应的对象，比如一些<code>Aware</code>，要向成功获取指定的对象，必备的条件如下：<ul>
<li>实现<code>xxxAware</code>接口</li>
<li>自定义的类注入到容器中</li>
</ul>
</li>
</ul>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><ul>
<li>Aware的装配使用的BeanPostProcessor原理，在初始化之前调用set方法设置对应的值，相应的实现都在<code>org.springframework.context.support.ApplicationContextAwareProcessor#invokeAwareInterfaces</code>，源码如下：<ul>
<li>主要的逻辑就是判断相应bean的类型，调用相应的set方法<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareInterfaces</span><span class="params">(Object bean)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</div><div class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) &#123;</div><div class="line">				((EnvironmentAware) bean).setEnvironment(<span class="keyword">this</span>.applicationContext.getEnvironment());</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) &#123;</div><div class="line">				((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(</div><div class="line">						<span class="keyword">new</span> EmbeddedValueResolver(<span class="keyword">this</span>.applicationContext.getBeanFactory()));</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) &#123;</div><div class="line">				((ResourceLoaderAware) bean).setResourceLoader(<span class="keyword">this</span>.applicationContext);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware) &#123;</div><div class="line">				((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(<span class="keyword">this</span>.applicationContext);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware) &#123;</div><div class="line">				((MessageSourceAware) bean).setMessageSource(<span class="keyword">this</span>.applicationContext);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</div><div class="line">				((ApplicationContextAware) bean).setApplicationContext(<span class="keyword">this</span>.applicationContext);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://blog.csdn.net/iechenyb/article/details/83788338" target="_blank" rel="external">https://blog.csdn.net/iechenyb/article/details/83788338</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Spring框架中提供了许多实现了Aware接口的类，这些类主要是为了辅助Spring访问容器中的数据，比如&lt;code&gt;Bean
    
    </summary>
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>JDK8新特性</title>
    <link href="http://chenjiabing666.github.io/2019/06/12/JDK8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://chenjiabing666.github.io/2019/06/12/JDK8新特性/</id>
    <published>2019-06-12T06:58:55.000Z</published>
    <updated>2019-06-12T07:00:09.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDk8新特性"><a href="#JDk8新特性" class="headerlink" title="JDk8新特性"></a>JDk8新特性</h1><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><h3 id="集合的foreach"><a href="#集合的foreach" class="headerlink" title="集合的foreach"></a>集合的foreach</h3><ul>
<li><p>List</p>
<ul>
<li>这里的表示List中每一个元素，可以不指定类型，JDK会自动推测出类型，但是也是可以使用<code>()</code>加上类型</li>
<li>如果有一条语句可以直接在后面输出，如果有多行，那么可以在后面使用<code>{}</code>指定<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">76</span>).forEach(e-&gt; System.out.println(e));</div><div class="line">   Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">76</span>).forEach((Integer e)-&gt; System.out.println(e));</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Set</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Set&lt;Object&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">76</span>));</div><div class="line">   set.forEach(e-&gt; System.out.println(e));</div></pre></td></tr></table></figure>
</li>
<li><p>Map</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Map&lt;Object,Object&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">      map.put(<span class="string">"2"</span>,<span class="number">2</span>);</div><div class="line">      map.put(<span class="string">"4"</span>,<span class="number">5</span>);</div><div class="line">      <span class="comment">//a,b两个元素分别是key和value</span></div><div class="line">      map.forEach((a,b)-&gt;&#123;</div><div class="line">          System.out.println(a+<span class="string">"---"</span>+b);</div><div class="line">      &#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="lambda表达式轻松创建接口实例"><a href="#lambda表达式轻松创建接口实例" class="headerlink" title="lambda表达式轻松创建接口实例"></a>lambda表达式轻松创建接口实例</h3><ul>
<li>条件：该接口只能有一个需要实现的方法（默认方法除外）<ul>
<li><code>()-&gt;{}</code>：无参数的实现</li>
<li><code>item-&gt;{}</code>：单个参数的实现，jdk能够默认推断出参数的类型</li>
<li><code>(String item1,String item2)</code>：指定参数的类型</li>
</ul>
</li>
<li><code>FunctionalInterface</code>：标记这个接口只能定义一个方法（除了默认的方法）<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">display</span><span class="params">(String name)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</div><div class="line">       UserService userService=name -&gt; &#123;</div><div class="line">           <span class="keyword">return</span> name;</div><div class="line">       &#125;;</div><div class="line">       userService.display(<span class="string">"che"</span>);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="接口的默认方法和静态方法"><a href="#接口的默认方法和静态方法" class="headerlink" title="接口的默认方法和静态方法"></a>接口的默认方法和静态方法</h3><ul>
<li>默认方法不需要实现，但是可以被覆盖<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Demo1</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 接口的静态方法</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"cdc"</span>);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 默认方法可以不实现，但是可以被覆盖</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"cdddd"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><ul>
<li>Stream接口中包含许多对流操作的方法，这些方法分别为：<ul>
<li>filter()：对流的元素过滤</li>
<li>map()：将流的元素映射成另一个类型</li>
<li>distinct()：去除流中重复的元素</li>
<li>sorted()：对流的元素排序</li>
<li>forEach()：对流中的每个元素执行某个操作</li>
<li>peek()：与forEach()方法效果类似，不同的是，该方法会返回一个新的流，而forEach()无返回</li>
<li>limit()：截取流中前面几个元素</li>
<li>skip()：跳过流中前面几个元素</li>
<li>toArray()：将流转换为数组</li>
<li>reduce()：对流中的元素归约操作，将每个元素合起来形成一个新的值</li>
<li>collect()：对流的汇总操作，比如输出成List集合</li>
<li>anyMatch()：匹配流中的元素，类似的操作还有allMatch()和noneMatch()方法</li>
<li>findFirst()：查找第一个元素，类似的还有findAny()方法</li>
<li>max()：求最大值</li>
<li>min()：求最小值</li>
<li>count()：求总数</li>
</ul>
</li>
</ul>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><ul>
<li>过滤集合，实际是实现其中的test方法，返回的是一个Boolean类型的值，我们可以使用lambda表达式可以很轻松的实现集合的过滤<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">   <span class="meta">@Test</span>	</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</div><div class="line">       User user1 = <span class="keyword">new</span> User();</div><div class="line">       user1.setName(<span class="string">"chen"</span>);</div><div class="line">       user1.setAge(<span class="number">22</span>);</div><div class="line"></div><div class="line">       User user3 = <span class="keyword">new</span> User();</div><div class="line">       user3.setName(<span class="string">"zheng"</span>);</div><div class="line">       user3.setAge(<span class="number">22</span>);</div><div class="line"></div><div class="line">       User user2 = <span class="keyword">new</span> User();</div><div class="line">       user2.setName(<span class="string">"zhou"</span>);</div><div class="line">       user2.setAge(<span class="number">30</span>);</div><div class="line"></div><div class="line">       List&lt;User&gt; users=<span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">       users.add(user1);</div><div class="line">       users.add(user2);</div><div class="line">       users.add(user3);</div><div class="line"><span class="comment">/* 下面的语句类似如下</span></div><div class="line">        *   users.stream().filter(item-&gt;item.getAge()&gt;25).collect(Collectors.toList());</div><div class="line">        */	</div><div class="line">       List&lt;User&gt; collect = users.stream().filter(user -&gt; &#123;</div><div class="line">           <span class="keyword">if</span> (user.getAge() &gt; <span class="number">25</span>) &#123;</div><div class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">           &#125;</div><div class="line">       &#125;).collect(Collectors.toList());</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h4><ul>
<li><p>有两个实现的方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function">Stream&lt;T&gt; <span class="title">sorted</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span></span>;</div><div class="line"><span class="function">Stream&lt;T&gt; <span class="title">sorted</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
</li>
<li><p>例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Stream.of(<span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">8</span>)</div><div class="line">    .filter(n -&gt; n &gt; <span class="number">2</span>)     <span class="comment">// 对元素过滤，保留大于2的元素</span></div><div class="line">    .distinct()             <span class="comment">// 去重，类似于SQL语句中的DISTINCT</span></div><div class="line">    .skip(<span class="number">1</span>)                <span class="comment">// 跳过前面1个元素</span></div><div class="line">    .limit(<span class="number">2</span>)               <span class="comment">// 返回开头2个元素，类似于SQL语句中的SELECT TOP</span></div><div class="line">    .sorted()               <span class="comment">// 对结果排序</span></div><div class="line">    .forEach(System.out::println);</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//按照age排序，实际上就是实现Comparator的接口方法compareTo</span></div><div class="line">      users.sort((item1,item2)-&gt;&#123;</div><div class="line">          <span class="keyword">return</span> item1.getAge()-item2.getAge();</div><div class="line">      &#125;);</div></pre></td></tr></table></figure>
<h4 id="查找和匹配"><a href="#查找和匹配" class="headerlink" title="查找和匹配"></a>查找和匹配</h4><ul>
<li>Stream中提供的查找方法有anyMatch()、allMatch()、noneMatch()、findFirst()、findAny()，这些方法被用来查找或匹配某些元素是否符合给定的条件：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 检查流中的任意元素是否包含字符串"Java"</span></div><div class="line"><span class="keyword">boolean</span> hasMatch = Stream.of(<span class="string">"Java"</span>, <span class="string">"C#"</span>, <span class="string">"PHP"</span>, <span class="string">"C++"</span>, <span class="string">"Python"</span>)</div><div class="line">        .anyMatch(s -&gt; s.equals(<span class="string">"Java"</span>));</div><div class="line"></div><div class="line"><span class="comment">// 检查流中的所有元素是否都包含字符串"#"</span></div><div class="line"><span class="keyword">boolean</span> hasAllMatch = Stream.of(<span class="string">"Java"</span>, <span class="string">"C#"</span>, <span class="string">"PHP"</span>, <span class="string">"C++"</span>, <span class="string">"Python"</span>)</div><div class="line">        .allMatch(s -&gt; s.contains(<span class="string">"#"</span>));</div><div class="line"></div><div class="line"><span class="comment">// 检查流中的任意元素是否没有以"C"开头的字符串</span></div><div class="line"><span class="keyword">boolean</span> hasNoneMatch = Stream.of(<span class="string">"Java"</span>, <span class="string">"C#"</span>, <span class="string">"PHP"</span>, <span class="string">"C++"</span>, <span class="string">"Python"</span>)</div><div class="line">        .noneMatch(s -&gt; s.startsWith(<span class="string">"C"</span>));</div><div class="line"></div><div class="line"><span class="comment">// 查找元素</span></div><div class="line">Optional&lt;String&gt; element = Stream.of(<span class="string">"Java"</span>, <span class="string">"C#"</span>, <span class="string">"PHP"</span>, <span class="string">"C++"</span>, <span class="string">"Python"</span>)</div><div class="line">        .filter(s -&gt; s.contains(<span class="string">"C"</span>))</div><div class="line">        <span class="comment">// .findFirst()     // 查找第一个元素</span></div><div class="line">        .findAny();         <span class="comment">// 查找任意元素</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h4><h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><ul>
<li><p>map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</div><div class="line"><span class="comment">// 获取对应的平方数</span></div><div class="line">List&lt;Integer&gt; squaresList = numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList());</div></pre></td></tr></table></figure>
</li>
<li><p>map使用lambda表达式返回的类型就是最后的类型,下面我们将用户的年龄设置成两倍</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</div><div class="line">       User user1 = <span class="keyword">new</span> User();</div><div class="line">       user1.setName(<span class="string">"chen"</span>);</div><div class="line">       user1.setAge(<span class="number">22</span>);</div><div class="line"></div><div class="line">       User user3 = <span class="keyword">new</span> User();</div><div class="line">       user3.setName(<span class="string">"zheng"</span>);</div><div class="line">       user3.setAge(<span class="number">22</span>);</div><div class="line"></div><div class="line">       User user2 = <span class="keyword">new</span> User();</div><div class="line">       user2.setName(<span class="string">"zhou"</span>);</div><div class="line">       user2.setAge(<span class="number">40</span>);</div><div class="line"></div><div class="line">       List&lt;User&gt; users=<span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">       users.add(user1);</div><div class="line">       users.add(user2);</div><div class="line">       users.add(user3);</div><div class="line"></div><div class="line">       List&lt;User&gt; list = users.stream().map(item -&gt; &#123;</div><div class="line">           item.setAge(item.getAge() * <span class="number">2</span>);</div><div class="line">           <span class="keyword">return</span> item;</div><div class="line">       &#125;).collect(Collectors.toList());</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h5><ul>
<li>将两个元素进行归约操作，比如两个元素相加，但是这个操作的返回值一定要和操作之前的类型相同<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//归约操作，返回的是一个Optional类型的</span></div><div class="line">        Optional&lt;Integer&gt; optional = users.stream().map(item -&gt; item.getAge()).reduce((item1, item2) -&gt; item1 + item2);</div><div class="line">        <span class="keyword">if</span> (optional.isPresent())&#123;</div><div class="line">            System.out.println(optional.get());</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><ul>
<li><p>和关系数据库一样，流也提供了类似于数据库中GROUP BY分组的特性，由Collectors.groupingBy()方法提供：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//根据age进行分组，返回的是Map集合，key就是分组后的age，value是user对象</span></div><div class="line">        Map&lt;Integer, List&lt;User&gt;&gt; listMap = users.parallelStream().collect(Collectors.groupingBy(item -&gt; item.getAge()));</div><div class="line">        listMap.forEach((key,value)-&gt;&#123;</div><div class="line">            System.out.println(key+<span class="string">"---&gt;"</span>+value);</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>但实际情况可能比这复杂，比如将价格在0-50之间的书籍分成一组，50-100之间的分成一组，超过100的分成一组，这时候，我们可以直接使用Lambda表达式来表示这个分组逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//根据age进行分组，返回的是Map集合，key就是分组后的age，value是user对象</span></div><div class="line">        Map&lt;String, List&lt;User&gt;&gt; listMap = users.parallelStream().collect(Collectors.groupingBy(item -&gt; &#123;</div><div class="line">            <span class="keyword">if</span> (item.getAge() &gt; <span class="number">20</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="string">"A"</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> <span class="string">"B"</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;));</div><div class="line"></div><div class="line">        listMap.forEach((key,value)-&gt;&#123;</div><div class="line">            System.out.println(key+<span class="string">"---&gt;"</span>+value);</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><ul>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html" target="_blank" rel="external">文档</a></li>
<li><p><a href="https://zhuanlan.zhihu.com/p/40966718" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/40966718</a></p>
</li>
<li><p>创建方法：</p>
<ul>
<li><code>public static &lt;T&gt; Optional&lt;T&gt; of(T value)</code>：value的值不能为null</li>
<li><code>public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value)</code>：value允许为空</li>
</ul>
</li>
<li><p>常用方法</p>
<ul>
<li><code>public Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code>：过滤其中的元素，如果返回true，那么保留，返回false去除该元素</li>
<li><p><code>public T orElse(T other)</code>：如果该元素的值为null，那么指定该值为other</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">User user = <span class="keyword">new</span> User(<span class="number">22</span>, <span class="string">"chenjiabing"</span>);</div><div class="line">User user2 = Optional.ofNullable(user).filter(item-&gt;&#123;</div><div class="line">	<span class="keyword">return</span> item.getAge()&gt;<span class="number">30</span>;</div><div class="line">&#125;).orElse(<span class="keyword">null</span>);</div></pre></td></tr></table></figure>
</li>
<li><p><code>public T orElseGet(Supplier&lt;? extends T&gt; other)</code>：如果该值为空，那么就调用other的get方法，其中返回一个同种类型的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Optional.ofNullable(user).filter(item-&gt;&#123;</div><div class="line">	<span class="keyword">return</span> item.getAge()&gt;<span class="number">30</span>;</div><div class="line">&#125;).orElseGet(()-&gt;&#123;</div><div class="line">	System.out.println(<span class="string">"该值为空"</span>);</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">44</span>, <span class="string">"zhengjiahe"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p><code>public boolean isPresent()</code>：判断当前的元素是否为null，如果为null返回false，否则返回true</p>
</li>
<li><code>public void ifPresent(Consumer&lt;? super T&gt; consumer)</code>：如果不为空调用其中的方法</li>
<li><code>public &lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T,? extends U&gt; mapper)</code>：如果为空直接返回一个空的Optional，不会调用map中的apply方法，如果不为空，那么调用apply方法<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Optional&lt;Integer&gt; map = Optional.ofNullable(<span class="keyword">null</span>).map(item-&gt;&#123;</div><div class="line">	System.out.println(item);</div><div class="line">	<span class="comment">//返回值也决定着你的类型</span></div><div class="line">	<span class="keyword">return</span> Integer.MAX_VALUE;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h2><ul>
<li>针对集合操作的封装类，结合Stream编程客可以很简单的实现</li>
</ul>
<h3 id="toMap"><a href="#toMap" class="headerlink" title="toMap"></a>toMap</h3><ul>
<li>List直接转换为Map，使用JDK1.8的Stream编程</li>
<li><p><code>Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? super T, ? extends K&gt; keyMapper,Function&lt;? super T, ? extends U&gt; valueMapper)</code>：简单的将集合转换成Map，出现key重复的将直接抛出异常</p>
<ul>
<li><code>keyMapper</code>：指定的</li>
<li><code>valueMapper</code>：指定的value  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">        Map&lt;Integer, String&gt; map = users.stream().collect(Collectors.toMap(User::getAge, User::getName));</div><div class="line">`</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>public static &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? super T, ? extends K&gt; keyMapper,Function&lt;? super T, ? extends U&gt; valueMapper,BinaryOperator&lt;U&gt; mergeFunction)</code>：用于解决key冲突的情况</p>
<ul>
<li><code>mergeFunction</code>：用于当出现key冲突的情况下解决方法，其中只需要实现apply方法即可，两个参数分别是重复的map的value值，返回值是指定的值  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Map&lt;Integer, String&gt; map = users.stream().collect(Collectors.toMap(User::getAge, User::getName,(v1,v2)-&gt;v1+<span class="string">","</span>+v2));</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="toList"><a href="#toList" class="headerlink" title="toList"></a>toList</h3><ul>
<li>将结果转换成一个List集合<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; list = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).collect(Collectors.toList());</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="toSet"><a href="#toSet" class="headerlink" title="toSet"></a>toSet</h3><ul>
<li>将结果转换成一个Set集合<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Set&lt;Integer&gt; set = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).collect(Collectors.toSet());</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="groupingBy"><a href="#groupingBy" class="headerlink" title="groupingBy"></a>groupingBy</h3><ul>
<li>将所得的结果根据指定的内容进行分组，所得结果是一个Map类型的数据</li>
<li><p><code>public static &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt;
  groupingBy(Function&lt;? super T, ? extends K&gt; classifier)</code></p>
<ul>
<li>指定的key，value的默认类型为List<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Map&lt;Integer, List&lt;Integer&gt;&gt; map = Stream.of(<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).collect(</div><div class="line">           Collectors.groupingBy(Integer::intValue));</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>`public static <t, k,="" a,="" d=""><br>  Collector<t, ?,="" map<k,="" d="">&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier,</t,></t,></p>
<pre><code>Collector&lt;? super T, A, D&gt; downstream)`
</code></pre><ul>
<li>第一个参数是指定的key，第二个参数是指定的value的类型<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Map&lt;Integer, Set&lt;Integer&gt;&gt; map = Stream.of(<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).collect(</div><div class="line">           Collectors.groupingBy(Integer::intValue, Collectors.toSet()));</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JDk8新特性&quot;&gt;&lt;a href=&quot;#JDk8新特性&quot; class=&quot;headerlink&quot; title=&quot;JDk8新特性&quot;&gt;&lt;/a&gt;JDk8新特性&lt;/h1&gt;&lt;h2 id=&quot;函数式编程&quot;&gt;&lt;a href=&quot;#函数式编程&quot; class=&quot;headerlink&quot; ti
    
    </summary>
    
      <category term="java学习" scheme="http://chenjiabing666.github.io/categories/java%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java基础" scheme="http://chenjiabing666.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>springBoot制作docker镜像</title>
    <link href="http://chenjiabing666.github.io/2019/01/19/springBoot%E5%88%B6%E4%BD%9Cdocker%E9%95%9C%E5%83%8F/"/>
    <id>http://chenjiabing666.github.io/2019/01/19/springBoot制作docker镜像/</id>
    <published>2019-01-19T05:51:31.000Z</published>
    <updated>2019-01-19T05:52:29.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot制作docker镜像"><a href="#SpringBoot制作docker镜像" class="headerlink" title="SpringBoot制作docker镜像"></a>SpringBoot制作docker镜像</h1><h2 id="开启2375端口"><a href="#开启2375端口" class="headerlink" title="开启2375端口"></a>开启2375端口</h2><h2 id="修改docker配置文件"><a href="#修改docker配置文件" class="headerlink" title="修改docker配置文件"></a>修改docker配置文件</h2><ul>
<li><code>vim /usr/lib/systemd/system/docker.service</code></li>
<li>在<code>ExecStart=/usr/bin/dockerd</code>配置加上如下内容</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock</div></pre></td></tr></table></figure>
<ul>
<li>添加完之后的完整内容如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Type=notify</div><div class="line">NotifyAccess=main</div><div class="line">EnvironmentFile=-/run/containers/registries.conf</div><div class="line">EnvironmentFile=-/etc/sysconfig/docker</div><div class="line">EnvironmentFile=-/etc/sysconfig/docker-storage</div><div class="line">EnvironmentFile=-/etc/sysconfig/docker-network</div><div class="line">Environment=GOTRACEBACK=crash</div><div class="line">Environment=DOCKER_HTTP_HOST_COMPAT=1</div><div class="line">Environment=PATH=/usr/libexec/docker:/usr/bin:/usr/sbin</div><div class="line">ExecStart=/usr/bin/dockerd-current \</div><div class="line">          -H tcp://0.0.0.0:2375 \</div><div class="line">          -H unix:///var/run/docker.sock \</div><div class="line">          --add-runtime docker-runc=/usr/libexec/docker/docker-runc-current \</div><div class="line">          --default-runtime=docker-runc \</div><div class="line">          --exec-opt native.cgroupdriver=systemd \</div><div class="line">          --userland-proxy-path=/usr/libexec/docker/docker-proxy-current \</div><div class="line">          --init-path=/usr/libexec/docker/docker-init-current \</div><div class="line">          --seccomp-profile=/etc/docker/seccomp.json \</div><div class="line">          $OPTIONS \</div><div class="line">          $DOCKER_STORAGE_OPTIONS \</div><div class="line">          $DOCKER_NETWORK_OPTIONS \</div><div class="line">          $ADD_REGISTRY \</div><div class="line">          $BLOCK_REGISTRY \</div><div class="line">          $INSECURE_REGISTRY \</div><div class="line">          $REGISTRIES</div></pre></td></tr></table></figure>
<ul>
<li>重启docker</li>
</ul>
<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><ul>
<li>添加环境变量<code>DOCKER_HOST</code>的值为<code>tcp://ip:2375</code></li>
</ul>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><ul>
<li>将编写的Dockerfile文件放在<code>/src/main/docker</code>下，内容如下：</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> java:<span class="number">8</span></div><div class="line"></div><div class="line"><span class="keyword">MAINTAINER</span> https://chenjiabing666.github.io</div><div class="line"></div><div class="line"><span class="comment"># 指定虚拟卷，/tmp是tomcat运行时需要的，/usr/local/images是上传文件需要的，/usr/local/weblogs/demo是记录日志需要的</span></div><div class="line"><span class="keyword">VOLUME</span> ["/tmp","/usr/local/images","/usr/local/weblogs/demo"]</div><div class="line"></div><div class="line"><span class="comment"># 添加jar</span></div><div class="line"><span class="keyword">ADD</span> demo-server.jar demo.jar</div><div class="line"></div><div class="line"><span class="comment"># 暴露8080端口</span></div><div class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></div><div class="line"></div><div class="line"><span class="comment"># 运行jar</span></div><div class="line"><span class="keyword">CMD</span> ["java","-jar","demo.jar"]</div></pre></td></tr></table></figure>
<h2 id="配置maven插件"><a href="#配置maven插件" class="headerlink" title="配置maven插件"></a>配置maven插件</h2><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">&lt;build&gt;</div><div class="line">		&lt;finalName&gt;demo-server&lt;/finalName&gt;</div><div class="line">		&lt;plugins&gt;</div><div class="line">			&lt;!-- springBoot的maven打包插件 --&gt;</div><div class="line">			&lt;plugin&gt;</div><div class="line">				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</div><div class="line">			&lt;/plugin&gt;</div><div class="line"></div><div class="line">			&lt;plugin&gt;</div><div class="line">				&lt;groupId&gt;com.spotify&lt;/groupId&gt;</div><div class="line">				&lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;</div><div class="line">				&lt;version&gt;0.4.13&lt;/version&gt;</div><div class="line">				</div><div class="line">				&lt;!-- 将docker:build这个动作绑定在package这个动作上，只要maven install 即可上传到远程服务器 --&gt;</div><div class="line">				&lt;executions&gt;</div><div class="line">					&lt;execution&gt;</div><div class="line">						&lt;id&gt;build-image&lt;/id&gt;</div><div class="line">						&lt;phase&gt;package&lt;/phase&gt;</div><div class="line">						&lt;goals&gt;</div><div class="line">							&lt;goal&gt;build&lt;/goal&gt;</div><div class="line">						&lt;/goals&gt;</div><div class="line">					&lt;/execution&gt;</div><div class="line">				&lt;/executions&gt;</div><div class="line">				</div><div class="line">				&lt;configuration&gt;</div><div class="line">					</div><div class="line">					&lt;!-- 指定镜像的名称+版本，必须是满足[a-z,0-9]这个正则才行 --&gt;</div><div class="line">					&lt;imageName&gt;$&#123;project.artifactId&#125;:$&#123;project.version&#125;&lt;/imageName&gt;</div><div class="line">					</div><div class="line">					&lt;!-- 覆盖相同标签镜像 --&gt;</div><div class="line">					&lt;forceTags&gt;true&lt;/forceTags&gt;</div><div class="line">					</div><div class="line">					&lt;!-- 指定Dockerfile的文件位置 --&gt;</div><div class="line">					&lt;dockerDirectory&gt;$&#123;project.basedir&#125;/src/main/docker&lt;/dockerDirectory&gt;</div><div class="line">					</div><div class="line">					&lt;!-- 指定Dockerfile的文件位置 --&gt;</div><div class="line">					&lt;dockerHost&gt;http://39.105.123.197:2375&lt;/dockerHost&gt;</div><div class="line">					</div><div class="line">					&lt;!-- 指定jar包所在的位置 --&gt;</div><div class="line">					&lt;resources&gt;</div><div class="line">						&lt;resource&gt;</div><div class="line">							&lt;targetPath&gt;/&lt;/targetPath&gt;</div><div class="line">							&lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt;</div><div class="line">							&lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt;</div><div class="line">						&lt;/resource&gt;</div><div class="line">					&lt;/resources&gt;</div><div class="line">				&lt;/configuration&gt;</div><div class="line">			&lt;/plugin&gt;</div><div class="line">		&lt;/plugins&gt;</div><div class="line">	&lt;/build&gt;</div></pre></td></tr></table></figure>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><ul>
<li>我们制作镜像运行的时候需要挂载自己的虚拟卷，否则诸如创建文件夹和上传文件之类的都是在容器内创建的，不会在本机创建，因此我们需要将其挂载在自己的宿主机上，运行命令如下：<ul>
<li>使用<code>-v</code>挂载即可</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --name demo -p 8080:8080 -v /usr/local:/usr/local -v /tmp:/tmp -d 8877edd71d5a</div></pre></td></tr></table></figure>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><ul>
<li><a href="https://gitee.com/chenjiabing666/docker-server.git" target="_blank" rel="external">https://gitee.com/chenjiabing666/docker-server.git</a></li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://blog.csdn.net/qq_35615618/article/details/81201646" target="_blank" rel="external">https://blog.csdn.net/qq_35615618/article/details/81201646 </a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SpringBoot制作docker镜像&quot;&gt;&lt;a href=&quot;#SpringBoot制作docker镜像&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot制作docker镜像&quot;&gt;&lt;/a&gt;SpringBoot制作docker镜像&lt;/h1&gt;&lt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://chenjiabing666.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://chenjiabing666.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>docker搭建私有仓库</title>
    <link href="http://chenjiabing666.github.io/2018/12/30/docker%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    <id>http://chenjiabing666.github.io/2018/12/30/docker搭建私有仓库/</id>
    <published>2018-12-30T05:27:20.000Z</published>
    <updated>2018-12-30T05:27:46.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker私有仓库"><a href="#Docker私有仓库" class="headerlink" title="Docker私有仓库"></a>Docker私有仓库</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul>
<li><code>docker pull registry</code></li>
<li><code>docker run --name registry -p 5000:5000 -d registry</code></li>
<li>启动完成后访问<code>http:// 192.168.174.130:5000/v2/_catalog</code>即可看到如下的内容说明启动成功：</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	<span class="attr">"repositories"</span>: []</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p><strong>添加信任（无论是下载还是上传都需要添加，这里的ip和端口指定的是私有仓库的宿主机的ip）：</strong></p>
<ul>
<li><code>vim /etc/docker/daemon.json</code>，添加如下的内容：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">"insecure-registries":["192.168.174.130:5000"]</div></pre></td></tr></table></figure>
<ul>
<li>重启docker ,<code>systemctl restart docker</code></li>
</ul>
</li>
</ul>
<h2 id="上传镜像到私有仓库"><a href="#上传镜像到私有仓库" class="headerlink" title="上传镜像到私有仓库"></a>上传镜像到私有仓库</h2><ul>
<li><code>docker tag jdk8 192.168.174.130:5000/jdk8</code>： 标记该镜像<ul>
<li>指定仓库所在的ip和端口号</li>
<li>第一个jdk8是当前的镜像名称（或者填Id），后一个是上传到仓库中的名字，可以任意起</li>
</ul>
</li>
</ul>
<ul>
<li><p><code>docker images</code>：此时查看镜像，发现多了一个<code>192.168.174.130:5000/jdk8</code>的镜像</p>
</li>
<li><p><code>docker push 192.168.174.130:5000/jdk8</code> ：将标记的镜像上传到私有仓库中</p>
</li>
<li><p>此时再次访问<code>http:// 192.168.174.130:5000/v2/_catalog</code>，将会看到如下内容</p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"repositories"</span>: [</div><div class="line">    <span class="string">"jdk8"</span></div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><ul>
<li><p>添加信任</p>
<ul>
<li>vim /etc/docker/daemon.json`，添加如下的内容：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">"insecure-registries":["192.168.174.130:5000"]</div></pre></td></tr></table></figure>
<ul>
<li>重启docker ,<code>systemctl restart docker</code></li>
</ul>
</li>
</ul>
<ul>
<li>下载，需要指定ip和端口：<code>docker pull 192.168.174.130:5000/jdk8</code></li>
</ul>
<h2 id="Docker-Maven插件自动上传镜像到私有仓库"><a href="#Docker-Maven插件自动上传镜像到私有仓库" class="headerlink" title="Docker Maven插件自动上传镜像到私有仓库"></a>Docker Maven插件自动上传镜像到私有仓库</h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><h4 id="仓库所在服务器的配置"><a href="#仓库所在服务器的配置" class="headerlink" title="仓库所在服务器的配置"></a>仓库所在服务器的配置</h4><ul>
<li><p><strong>添加信任，同上</strong></p>
</li>
<li><p>修改 <code>/etc/sysconfig/docker</code>文件：<code>vim /etc/sysconfig/docker</code></p>
<ul>
<li><p>在最下面添加一行<code>DOCKER_OPTS=&#39;-H unix:///var/run/docker.sock -H 0.0.0.0:2375&#39;</code></p>
<ul>
<li><img src="https://github.com/chenjiabing666/BlogImage/blob/master/docker2.png?raw=true" alt=""></li>
</ul>
</li>
</ul>
</li>
<li><code>vim /lib/systemd/system/docker.service</code>添加如下内容<ul>
<li><img src="https://github.com/chenjiabing666/BlogImage/blob/master/docker1.png?raw=true" alt=""></li>
</ul>
</li>
</ul>
<ul>
<li>执行下面的命令刷新配置并且重启docker</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">systemctl daemon-reload</div><div class="line">systemctl restart docker</div></pre></td></tr></table></figure>
<ul>
<li><p>开启防火墙的端口：<code>firewall-cmd --zone=public --add-port=2375/tcp --permanent</code></p>
</li>
<li><p>重新载入配置<code>firewall-cmd --reload</code></p>
</li>
</ul>
<h4 id="项目中的配置"><a href="#项目中的配置" class="headerlink" title="项目中的配置"></a>项目中的配置</h4><ul>
<li>在pom.xml文件中添加如下内容：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></div><div class="line">		<span class="comment">&lt;!-- 指定的最终打成jar包的名字 --&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">finalName</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line">			<span class="comment">&lt;!-- SpringBoot的maven插件 --&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line"></div><div class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>docker-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">					<span class="comment">&lt;!-- 注意imageName需要指定的`IP:端口/image_name`的格式--&gt;</span></div><div class="line">					<span class="tag">&lt;<span class="name">imageName</span>&gt;</span>192.168.174.130:5000/$&#123;project.artifactId&#125;:$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">imageName</span>&gt;</span></div><div class="line">					<span class="comment">&lt;!-- 指定基础镜像，不需要运行，相当于 from hub.c.163.com/library/java:8-alpine --&gt;</span></div><div class="line">					<span class="tag">&lt;<span class="name">baseImage</span>&gt;</span>hub.c.163.com/library/java:8-alpine<span class="tag">&lt;/<span class="name">baseImage</span>&gt;</span></div><div class="line">					<span class="comment">&lt;!--覆盖相同标签镜像--&gt;</span></div><div class="line">					<span class="tag">&lt;<span class="name">forceTags</span>&gt;</span>true<span class="tag">&lt;/<span class="name">forceTags</span>&gt;</span>    </div><div class="line">					<span class="comment">&lt;!-- 运行jar包 --&gt;</span></div><div class="line">					<span class="tag">&lt;<span class="name">entryPoint</span>&gt;</span>["java", "-jar", "/$&#123;project.build.finalName&#125;.jar"]<span class="tag">&lt;/<span class="name">entryPoint</span>&gt;</span></div><div class="line">					<span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">						<span class="tag">&lt;<span class="name">resource</span>&gt;</span></div><div class="line">							<span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>/<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></div><div class="line">							<span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></div><div class="line">							<span class="tag">&lt;<span class="name">include</span>&gt;</span>$&#123;project.build.finalName&#125;.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></div><div class="line">						<span class="tag">&lt;/<span class="name">resource</span>&gt;</span></div><div class="line">					<span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div><div class="line">					<span class="comment">&lt;!-- 指定私有仓库所在服务器的2375端口，之前配置过可以远程访问的那个 --&gt;</span></div><div class="line">					<span class="tag">&lt;<span class="name">dockerHost</span>&gt;</span>http://192.168.174.130:2375<span class="tag">&lt;/<span class="name">dockerHost</span>&gt;</span></div><div class="line">				<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>在命令台运行如下的命令，即可完成生成镜像并且上传到私有仓库</strong><ul>
<li><code>mvn clean package docker:build -DpushImage</code></li>
</ul>
</li>
<li><strong>上述命令的解析如下：</strong><ul>
<li><code>mvn clean package</code>：maven打jar包</li>
<li><code>docker:build</code>：docker构建镜像的命令</li>
<li><code>-DpushImage</code>： 将生成的镜像上传到私有仓库中</li>
</ul>
</li>
</ul>
<ul>
<li><strong>执行并且运行成功之后访问<code>http://192.168.174.130:5000/v2/_catalog</code>，将会出现如下的内容</strong></li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"repositories"</span>: [</div><div class="line">    <span class="string">"demo"</span></div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>访问<code>http://192.168.174.130:5000/v2/demo/tags/list</code>，可以看到demo这个镜像的所有版本</strong></li>
</ul>
<p><img src="https://github.com/chenjiabing666/BlogImage/blob/master/docker3.png?raw=true" alt=""></p>
<ul>
<li>上面的运行完成之后，查看项目中自动生成Dockerfile，如下：</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> hub.c.<span class="number">163</span>.com/library/java:<span class="number">8</span>-alpine</div><div class="line"><span class="keyword">ADD</span> /demo.jar //</div><div class="line"><span class="keyword">ENTRYPOINT</span> ["java", "-jar", "/demo.jar"]</div></pre></td></tr></table></figure>
<h4 id="拉取上传的镜像并且运行"><a href="#拉取上传的镜像并且运行" class="headerlink" title="拉取上传的镜像并且运行"></a>拉取上传的镜像并且运行</h4><ul>
<li>在拉取之前需要添加信任</li>
<li>使用 <code>docker pull 192.168.174.130:5000/demo:0.0.1-SNAPSHOT</code>下载仓库中的镜像</li>
<li>运行镜像：<code>docker run --name demo -p 7001:7001 -d f7f36f3f3f06</code><ul>
<li><strong>其中生成的镜像端口为项目自己本身配置的端口，只需要映射出去即可</strong></li>
</ul>
</li>
<li>此时我们可以访问<code>http://192.168.174.128:7001/</code>，就能看到eureka注册中心的页面</li>
</ul>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><ul>
<li><a href="https://gitee.com/chenjiabing666/docker-maven.git" target="_blank" rel="external">https://gitee.com/chenjiabing666/docker-maven.git</a></li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://blog.csdn.net/qq_39623859/article/details/80072545" target="_blank" rel="external">https://blog.csdn.net/qq_39623859/article/details/80072545</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker私有仓库&quot;&gt;&lt;a href=&quot;#Docker私有仓库&quot; class=&quot;headerlink&quot; title=&quot;Docker私有仓库&quot;&gt;&lt;/a&gt;Docker私有仓库&lt;/h1&gt;&lt;h2 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; class=&quot;headerli
    
    </summary>
    
      <category term="docker" scheme="http://chenjiabing666.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="http://chenjiabing666.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Dockerfile</title>
    <link href="http://chenjiabing666.github.io/2018/12/30/Dockerfile/"/>
    <id>http://chenjiabing666.github.io/2018/12/30/Dockerfile/</id>
    <published>2018-12-30T05:26:02.000Z</published>
    <updated>2018-12-30T05:26:37.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h1><ul>
<li><p>镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p>
</li>
<li><p>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>FROM image:tag</code></td>
<td>指定基础镜像，有点继承的意思</td>
</tr>
<tr>
<td><code>MAINTAINER user_name</code></td>
<td>声明镜像的创建者</td>
</tr>
<tr>
<td><code>ENV key value</code></td>
<td>设置环境变量，可以设置多条,比如 ENV VERSION=1.0</td>
</tr>
<tr>
<td><code>RUN command</code></td>
<td>核心命令，多个命令用&amp;&amp;连接即可</td>
</tr>
<tr>
<td><code>ADD source_dir/file dest_dir/file</code></td>
<td>将宿主机的文件负复制到容器内，如果是一个压缩文件，将会自动解压缩</td>
</tr>
<tr>
<td><code>COPY source_dir/file dest_dir/file</code></td>
<td>和ADD命令类似，但是不能自动解压缩</td>
</tr>
<tr>
<td><code>WORKDIR path_dir</code></td>
<td>指定当前的工作目录，由于分层的概念，每一个命令的工作目录都不同，因此需要使用该命令显示指定工作目录</td>
</tr>
<tr>
<td>CMD args</td>
<td>在构建容器的时候使用，会docker run 后的args覆盖</td>
</tr>
<tr>
<td>ENTRYPOINT  args</td>
<td>和CMD相似，但是不会被docker run后的args覆盖</td>
</tr>
<tr>
<td>VOLUME</td>
<td>将本地文件夹挂载到容器中</td>
</tr>
</tbody>
</table>
<h2 id="配置镜像加速"><a href="#配置镜像加速" class="headerlink" title="配置镜像加速"></a>配置镜像加速</h2><ul>
<li>我们使用阿里云的镜像加速</li>
<li><code>vim /etc/docker/daemon.json</code>,设置如下内容即可：</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">        <span class="attr">"registry-mirrors"</span>:[<span class="string">"https://rxx4pnmv.mirror.aliyuncs.com"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="构建简单的JDK镜像"><a href="#构建简单的JDK镜像" class="headerlink" title="构建简单的JDK镜像"></a>构建简单的JDK镜像</h2><ul>
<li>新建一个<code>Dockerfile</code></li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 初始镜像,默认拉去lastest的</span></div><div class="line"><span class="keyword">FROM</span> centos</div><div class="line"><span class="comment"># 指定镜像的构建者</span></div><div class="line"><span class="keyword">MAINTAINER</span> chenjiabing666</div><div class="line"><span class="comment"># 切换工作目到usr，这个是容器中的目录</span></div><div class="line"><span class="keyword">WORKDIR</span> /usr</div><div class="line"><span class="comment"># 新建 /usr/local/java目录</span></div><div class="line"><span class="keyword">RUN</span> mkdir /usr/local/java</div><div class="line"><span class="comment"># 添加本地的jdk到容器中并且解压</span></div><div class="line"><span class="keyword">ADD</span> jdk-8u172-linux-x64.tar.gz /usr/local/java/</div><div class="line"><span class="comment"># 设置环境变量</span></div><div class="line"><span class="keyword">ENV</span> JAVA_HOME /usr/local/java/jdk1.<span class="number">8.0</span>_181</div><div class="line"><span class="keyword">ENV</span> CLASSPATH $JAVA_HOME/lib;$JAVA_HOME/jre/lib</div><div class="line"><span class="keyword">ENV</span> PATH $PATH:$JAVA_HOME/bin</div></pre></td></tr></table></figure>
<ul>
<li><code>docker build -t jdk8 .</code>：构建镜像</li>
<li><code>docker run --name jdk -di jdk8</code>：运行镜像</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://blog.csdn.net/wo18237095579/article/details/80540571" target="_blank" rel="external">https://blog.csdn.net/wo18237095579/article/details/80540571</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;DockerFile&quot;&gt;&lt;a href=&quot;#DockerFile&quot; class=&quot;headerlink&quot; title=&quot;DockerFile&quot;&gt;&lt;/a&gt;DockerFile&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们
    
    </summary>
    
      <category term="docker" scheme="http://chenjiabing666.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="http://chenjiabing666.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot实现BCrypt密码加密</title>
    <link href="http://chenjiabing666.github.io/2018/12/25/SpringBoot%E5%AE%9E%E7%8E%B0BCrypt%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86/"/>
    <id>http://chenjiabing666.github.io/2018/12/25/SpringBoot实现BCrypt密码加密/</id>
    <published>2018-12-25T13:07:15.000Z</published>
    <updated>2018-12-25T13:07:44.432Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-实现-BCrypt密码加密"><a href="#SpringBoot-实现-BCrypt密码加密" class="headerlink" title="SpringBoot 实现 BCrypt密码加密"></a>SpringBoot 实现 BCrypt密码加密</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>出于安全的考虑，一些敏感的信息是绝对不能以明文的方式存储在数据库中的，比如密码通常是通过哈希算法进行加密的。有很多标准的算法比如<code>SHA</code>和<code>MD5</code>，结合<code>salt</code>（盐）是一种不错的选择，但是如果知道其加密的规则还是相对不安全。</li>
<li>Spring security提供了<code>BCryptPasswordEncoder</code>类，使用Bcrypt强哈希方法来加密密码</li>
<li><strong>Bcrypt强哈希算法每次加密的结果都是不一样的。</strong></li>
</ul>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><ul>
<li><code>public String encode(CharSequence rawPassword)</code>： 对给定的内容进行加密，返回加密后的字符串</li>
<li><code>public boolean matches(CharSequence rawPassword, String encodedPassword)</code>： 比较给定的字符串和加密后的字符串是否是同一个<ul>
<li><code>rawPassword</code>：未加密的字符串</li>
<li><code>encodedPassword</code>： 加密后的字符串</li>
</ul>
</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li>引入spring security的依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>添加security的配置类，如下:<ul>
<li><strong>在其中注入<code>BCryptPasswordEncoder</code></strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Spring security的配置类</div><div class="line"> */</div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		http.authorizeRequests()</div><div class="line">		.antMatchers(<span class="string">"/**"</span>)</div><div class="line">		.permitAll()</div><div class="line">		.anyRequest()</div><div class="line">		.authenticated()</div><div class="line">		.and().csrf().disable();</div><div class="line">		<span class="keyword">super</span>.configure(http);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * 注入BCryptPasswordEncoder</div><div class="line">	 */</div><div class="line">	<span class="meta">@Bean</span></div><div class="line">	<span class="function"><span class="keyword">public</span> BCryptPasswordEncoder <span class="title">bCryptPasswordEncoder</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>主配置类添加<code>@EnableWebSecurity</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="meta">@EnableWebSecurity</span>   <span class="comment">//开启security</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthServerApplication</span> </span>&#123;</div></pre></td></tr></table></figure>
<ul>
<li>在业务层实现登录和注册的功能 ，对密码进行加密和校验</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="meta">@Transactional</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="meta">@Resource</span></div><div class="line">	<span class="keyword">private</span> UserRepository userRepository;</div><div class="line">	</div><div class="line">	<span class="meta">@Resource</span></div><div class="line">	<span class="keyword">private</span> BCryptPasswordEncoder bCryptPasswordEncoder;  <span class="comment">//注入bcryct加密</span></div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">add</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">		user.setPassword(bCryptPasswordEncoder.encode(user.getPassword())); <span class="comment">//对密码进行加密</span></div><div class="line">		User user2 = userRepository.save(user);</div><div class="line">		<span class="keyword">return</span> user2;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> ResultInfo <span class="title">login</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">		ResultInfo resultInfo=<span class="keyword">new</span> ResultInfo();</div><div class="line">		User user2 = userRepository.findByName(user.getName());  </div><div class="line">		<span class="keyword">if</span> (user2==<span class="keyword">null</span>) &#123;</div><div class="line">			resultInfo.setCode(<span class="string">"-1"</span>);</div><div class="line">			resultInfo.setMessage(<span class="string">"用户名不存在"</span>);</div><div class="line">			<span class="keyword">return</span> resultInfo;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="comment">//判断密码是否正确</span></div><div class="line">		<span class="keyword">if</span> (!bCryptPasswordEncoder.matches(user.getPassword(),user2.getPassword())) &#123;</div><div class="line">			resultInfo.setCode(<span class="string">"-1"</span>);</div><div class="line">			resultInfo.setMessage(<span class="string">"密码不正确"</span>);</div><div class="line">			<span class="keyword">return</span> resultInfo;</div><div class="line">		&#125;</div><div class="line">		resultInfo.setMessage(<span class="string">"登录成功"</span>);</div><div class="line">		<span class="keyword">return</span> resultInfo;</div><div class="line">	&#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><ul>
<li><a href="https://gitee.com/chenjiabing666/auth-server.git" target="_blank" rel="external">https://gitee.com/chenjiabing666/auth-server.git</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SpringBoot-实现-BCrypt密码加密&quot;&gt;&lt;a href=&quot;#SpringBoot-实现-BCrypt密码加密&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot 实现 BCrypt密码加密&quot;&gt;&lt;/a&gt;SpringBoot 实现 
    
    </summary>
    
      <category term="SpringBoot" scheme="http://chenjiabing666.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://chenjiabing666.github.io/tags/SpringBoot/"/>
    
  </entry>
  
</feed>
