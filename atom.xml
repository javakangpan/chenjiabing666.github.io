<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>爱撒谎的男孩</title>
  <subtitle>一只程序猿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chenjiabing666.github.io/"/>
  <updated>2018-06-26T15:00:10.064Z</updated>
  <id>http://chenjiabing666.github.io/</id>
  
  <author>
    <name>Chenjiabing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL性能优化</title>
    <link href="http://chenjiabing666.github.io/2018/06/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://chenjiabing666.github.io/2018/06/26/MySQL性能优化/</id>
    <published>2018-06-26T14:59:48.000Z</published>
    <updated>2018-06-26T15:00:10.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL性能优化"><a href="#MySQL性能优化" class="headerlink" title="MySQL性能优化"></a>MySQL性能优化</h1><h2 id="查看数据库性能参数"><a href="#查看数据库性能参数" class="headerlink" title="查看数据库性能参数"></a>查看数据库性能参数</h2><ul>
<li><code>show status like &quot;value&quot;</code> ：value是要查询的参数值，常用的值如下：</li>
<li><img src="http://ono60m7tl.bkt.clouddn.com/sql1.png" alt=""></li>
</ul>
<h2 id="优化查询"><a href="#优化查询" class="headerlink" title="优化查询"></a>优化查询</h2><h3 id="分析查询语句"><a href="#分析查询语句" class="headerlink" title="分析查询语句"></a>分析查询语句</h3><ul>
<li>Mysql中提供<code>explain</code>和<code>describe</code>来分析查询语句</li>
<li>格式：<code>explain select selectStatemnt</code><ul>
<li><code>explain select * from user where id=1</code>;</li>
<li>查询结果如下：</li>
<li><img src="http://ono60m7tl.bkt.clouddn.com/sql2.png" alt=""></li>
</ul>
</li>
<li>查询的参数分析如下:</li>
</ul>
<p><img src="http://ono60m7tl.bkt.clouddn.com/sql3.png" alt=""></p>
<p><img src="http://ono60m7tl.bkt.clouddn.com/sql4.png" alt=""></p>
<p><img src="http://ono60m7tl.bkt.clouddn.com/sql5.png" alt=""></p>
<p><img src="http://ono60m7tl.bkt.clouddn.com/sql6.png" alt=""></p>
<p><img src="http://ono60m7tl.bkt.clouddn.com/sql7.png" alt=""></p>
<p><img src="http://ono60m7tl.bkt.clouddn.com/sql8.png" alt=""></p>
<p><img src="http://ono60m7tl.bkt.clouddn.com/sql9.png" alt=""></p>
<h3 id="使用索引查询的优化注意点"><a href="#使用索引查询的优化注意点" class="headerlink" title="使用索引查询的优化注意点"></a>使用索引查询的优化注意点</h3><ul>
<li>索引是可以提高查询速度，但是并不是使用带有索引的字段查询时，索引都能起作用</li>
<li>使用索引有几种特殊的情况，在这些特殊的情况下，有可能使用索引字段查询时，索引并没有起作用。下面会详细介绍</li>
</ul>
<h4 id="1-使用LIKE关键字查询"><a href="#1-使用LIKE关键字查询" class="headerlink" title="1. 使用LIKE关键字查询"></a>1. 使用LIKE关键字查询</h4><ul>
<li><strong>使用<code>Like</code>关键字查询的时候，如果匹配字符串的第一个字符为<code>%</code>，那么索引不会起作用。只有<code>%</code>不在第一个位置，索引才会起作用。</strong></li>
<li>我们使用<code>name</code>字段的索引<code>name_index</code>查询用户信息，如下<ul>
<li><code>explain select * from user where name like &quot;%a&quot;;</code> ： 我们看到查询出来的信息，字段<code>possible_keys</code>的值为<code>NULL</code>，这里表示没有使用<code>name</code>的索引<code>name_index</code>，并且这里的<code>rows</code>显示扫描的行数</li>
<li><code>explain select * from user where name like &quot;J%&quot;;</code> ：显示的<code>possible_keys</code>字段的值是<code>name_index</code>，表示使用了<code>name</code>字段的索引进行查询了</li>
</ul>
</li>
</ul>
<h4 id="2-使用组合索引查询"><a href="#2-使用组合索引查询" class="headerlink" title="2. 使用组合索引查询"></a>2. 使用组合索引查询</h4><ul>
<li><strong>Mysql可以为多列创建索引，可以同时为16个字段创建索引。对于组合索引，只有查询条件中使用了这些字段的<code>第一个字段</code>时，才会使用索引查询。</strong></li>
<li>我们分析查询用户信息的语句，看看对于组合索引的使用<ol>
<li>创建组合索引<code>name_age_index</code> ：<code>create index name_age_index on user(name,age)</code></li>
<li>使用分析查询语句：<code>explain select * from user where age=22;</code>  ：这里查询没有使用第一个字段<code>name</code>字段查询，显示<code>possible_keys</code>为<code>NULL</code>表示没有相关索引</li>
<li>使用分析查询语句：<code>explain select * from user where name=&quot;Jack&quot;</code> ：这里使用了第一个字段进行查询，显示的<code>possible_keys</code>为<code>name_index</code>，<code>key</code>为<code>name_index</code>表示使用了<code>name_index</code>进行查询了</li>
<li><code>explain select * from user where name=&quot;Jack&quot; and age=22</code> ： 同样是使用了<code>name_index</code>索引进行查询</li>
</ol>
</li>
</ul>
<h4 id="3-使用or关键字查询语句"><a href="#3-使用or关键字查询语句" class="headerlink" title="3. 使用or关键字查询语句"></a>3. 使用or关键字查询语句</h4><ul>
<li>在查询条件中只有<code>or</code>关键字，并且<code>or</code>的前后的两个条件的列都是索引的时候，查询中才会使用索引，否则不使用索引。</li>
<li>我们仍然分析查询用户信息的语句，使用<code>OR</code>关键字查询<ul>
<li>为字段<code>age</code>创建索引：<code>create index age_index on user(age)</code></li>
<li>分析查询：<code>explain select * from user where id=1 or name=&quot;Jack&quot;;</code>  ：由于这里的<code>name</code>字段没有创建索引，显示的<code>key</code>为<code>NULL</code>表示该条查询语句并没有使用索引查询</li>
<li>分析查询：<code>explain select * from user where id=1 or age=22;</code> ：由于<code>id</code>和<code>age</code>都创建了索引并且<code>key</code>显示为<code>PRIMARY,age_index</code>，表示使用了索引查询</li>
</ul>
</li>
</ul>
<h3 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a>优化子查询</h3><ul>
<li>子查询就是一个<code>select</code>语句中嵌套多个<code>select</code>语句，虽然子查询使用起来方便灵活，但是执行的效率并不高。在执行子查询的时候需要为内层的查询语句结果建立一个临时表，然后外层的语句从临时表中查询数据。查询完毕之后再撤销临时表。因此子查询的速度会受到一定的影响。</li>
<li>在Mysql中，可以使用连接<code>Join</code>查询代替子查询，连接查询不需要建立临时表，速度要比子查询要快。如果查询中使用索引的话，性能会更好</li>
</ul>
<h2 id="优化数据库结构"><a href="#优化数据库结构" class="headerlink" title="优化数据库结构"></a>优化数据库结构</h2><h3 id="1-将字段很多的表分解成多个表"><a href="#1-将字段很多的表分解成多个表" class="headerlink" title="1. 将字段很多的表分解成多个表"></a>1. 将字段很多的表分解成多个表</h3><ul>
<li>对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。因为当一个表的数据量很大的时候，会由于使用频率低的字段存在而变慢。</li>
</ul>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ul>
<li>假设会员表（members）存储会员登录认证信息，该表中有很多字段，如<code>id</code>，姓名，密码，地址，电话，个人描述等字段。其中地址，电话，个人描述字段并不常用。我们可以将这些字段分离出来形成一张新的表（member_detail）。表中有<code>member_id</code>，<code>address</code>，<code>phone</code>，<code>description</code>。其中<code>member_id</code>表示会员编号和<code>members</code>表中的<code>id</code>字段值对应</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">create table members(</div><div class="line">	id int(11) primary key auto_increment,</div><div class="line">    name varchar(20) default null,</div><div class="line">    password varchar(20) default null,</div><div class="line">    last_login_time datetime default null,</div><div class="line">    last_login_ip varchar(100) default null</div><div class="line">);</div><div class="line"></div><div class="line">create table member_detail(</div><div class="line">	member_id int(11) not null default 0,</div><div class="line">    address varchar(100) default null,</div><div class="line">    phone varchar(16) default null,</div><div class="line">    description text</div><div class="line">);</div></pre></td></tr></table></figure>
<ul>
<li>如果我们需要查询会员信息，可以使用连接查询：<code>select * from members left join member_detail on members.id=member_detail.member_id;</code></li>
<li>通过这种分解可以提高查询效率，可以优化数据库的性能，因为我们大部分时间需要查询和操作的表就是<code>members</code></li>
</ul>
<h3 id="2-增加中间表"><a href="#2-增加中间表" class="headerlink" title="2. 增加中间表"></a>2. 增加中间表</h3><ul>
<li><strong>对于需要经常联合查询的表，可以使用建立中间表用以提高查询速度。通过建立中间表，把需要经常联合查询的数据插入到中间表中，然后把原来的联合查询改为对中间表的查询，以此来提高查询效率。</strong></li>
<li>假设有一个会员信息表(vip)，其中存储的是每一个会员的信息，还有一个会员组信息表（<code>vip_group</code>)其中存储的是会员组的信息，比如<code>名称</code>，<code>备注信息</code>。现在我们需要经常查询的是会员的名字及其所在会员组的信息，使用联合查询的语句如下：<ul>
<li><code>select vip.name,vg.name,vg.remark from vip left join vip_group on vip.groupId=vg.id</code></li>
</ul>
</li>
<li>我们可以添加一个中间表<code>temp_group</code>，表中存储的是会员名，会员组名称，会员组信息，我们将连接查询的结果添加到中间表中，那么我们以后就可以直接到中间表中查询了，不用每次都联合查询了。</li>
</ul>
<h3 id="3-增加冗余字段"><a href="#3-增加冗余字段" class="headerlink" title="3. 增加冗余字段"></a>3. 增加冗余字段</h3><ul>
<li>设计数据库的时候应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致优雅。但是，合理的增加冗余字段可以提高查询速度。</li>
<li>表的规范程度越高，表与表之间的关系就越多，需要连接查询的情况就越多。例如，员工信息表存储在staff表中，部门信息存储在department表中，通过staff表中的department_id字段与department建立联系。如果要查询一个员工所在部门的名称，必须从staff表中查找员工所在部门编号，然后根据这个编号从department表中查找部门的名称。如果经常需要进行这个操作，连接查询会浪费很多时间。此时我们可以在staff表中添加一个<code>department_name</code>字段，用来记录部门名称，这样就不需要每次连接操作了。</li>
<li>冗余字段会导致很多问题，比如字段的值在一个表中改变了，在另外一个表中也要更新这个数据，很可能造成数据不一致，因此要根据实际需要综合分析是否使用冗余字段</li>
</ul>
<p>##　优化插入记录的速度</p>
<ul>
<li>插入记录的时候，影响插入速度的只要是索引、唯一性校验、一次插入多条记录等。根据这些情况，可以分别进行优化</li>
</ul>
<h3 id="1-禁用唯一性检查"><a href="#1-禁用唯一性检查" class="headerlink" title="1. 禁用唯一性检查"></a>1. 禁用唯一性检查</h3><ul>
<li>插入数据之前执行<code>set unique_checks=0</code>来禁止对唯一性索引的检查，执行完成之后再执行<code>set unique_checks=1</code></li>
</ul>
<h3 id="2-禁用外键检查"><a href="#2-禁用外键检查" class="headerlink" title="2. 禁用外键检查"></a>2. 禁用外键检查</h3><ul>
<li>插入数据之前执行禁止外键检查，数据插入完成之后再恢复对外键的检查，语句如下：<ul>
<li><code>set foreign_key_checks=0</code> ：禁用</li>
<li><code>set foreign_key_checks=1</code> ：启用外键检查</li>
</ul>
</li>
</ul>
<h3 id="3-禁止自动提交"><a href="#3-禁止自动提交" class="headerlink" title="3. 禁止自动提交"></a>3. 禁止自动提交</h3><ul>
<li>插入数据之前禁止事务的自动提交，在数据插入完成之后，执行恢复自动提交<ul>
<li><code>set autocommit=0</code></li>
<li><code>set autocommit=1</code></li>
</ul>
</li>
</ul>
<h2 id="优化Mysql服务器"><a href="#优化Mysql服务器" class="headerlink" title="优化Mysql服务器"></a>优化Mysql服务器</h2><ul>
<li>对硬件的优化，对Mysql服务的参数进行优化</li>
</ul>
<h3 id="优化服务器硬件"><a href="#优化服务器硬件" class="headerlink" title="优化服务器硬件"></a>优化服务器硬件</h3><ul>
<li><img src="http://ono60m7tl.bkt.clouddn.com/sql11.png" alt=""></li>
</ul>
<h3 id="优化MySQL参数"><a href="#优化MySQL参数" class="headerlink" title="优化MySQL参数"></a>优化MySQL参数</h3><p><img src="http://ono60m7tl.bkt.clouddn.com/sql12.png" alt=""></p>
<p><img src="http://ono60m7tl.bkt.clouddn.com/sql13.png" alt=""></p>
<p><img src="http://ono60m7tl.bkt.clouddn.com/sql14.png" alt=""></p>
<p><img src="http://ono60m7tl.bkt.clouddn.com/sql15.png" alt=""></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="http://www.cnblogs.com/clsn/p/8214048.html" target="_blank" rel="external">http://www.cnblogs.com/clsn/p/8214048.html</a></li>
<li><a href="https://blog.csdn.net/u013087513/article/details/77899412" target="_blank" rel="external">https://blog.csdn.net/u013087513/article/details/77899412</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MySQL性能优化&quot;&gt;&lt;a href=&quot;#MySQL性能优化&quot; class=&quot;headerlink&quot; title=&quot;MySQL性能优化&quot;&gt;&lt;/a&gt;MySQL性能优化&lt;/h1&gt;&lt;h2 id=&quot;查看数据库性能参数&quot;&gt;&lt;a href=&quot;#查看数据库性能参数&quot; class
    
    </summary>
    
      <category term="数据库干货篇" scheme="http://chenjiabing666.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B2%E8%B4%A7%E7%AF%87/"/>
    
    
      <category term="SQL" scheme="http://chenjiabing666.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL触发器</title>
    <link href="http://chenjiabing666.github.io/2018/06/26/MySQL%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <id>http://chenjiabing666.github.io/2018/06/26/MySQL触发器/</id>
    <published>2018-06-26T14:58:57.000Z</published>
    <updated>2018-06-26T14:59:16.857Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL触发器"><a href="#MySQL触发器" class="headerlink" title="MySQL触发器"></a>MySQL触发器</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>MySQL的触发器和存储过程一样，都是嵌入到MysQL中的一段程序，不过触发器不要调用，而是由事件触发的，这些事件包括<code>insert</code>，<code>update</code>，<code>delete</code>语句，如果定义了触发程序，当数据执行这些语句的时候就会激发触发器执行相应的操作。</li>
</ul>
<h2 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h2><h3 id="创建一行执行语句的触发器"><a href="#创建一行执行语句的触发器" class="headerlink" title="创建一行执行语句的触发器"></a>创建一行执行语句的触发器</h3><ul>
<li>格式：<code>create trigger trigger_name trigger_time trigger_event on table for each row trigger_stmt</code><ul>
<li><code>trigger_name</code> ：触发器的名字</li>
<li><code>trigger_time</code>： 触发器触发的时机，取值为<code>before</code>，<code>after</code><ul>
<li><code>before</code>：表示在激发触发器的语句执行之前执行触发器的执行语句</li>
<li><code>after</code>：表示在激发触发器的语句执行之后执行触发器的执行语句</li>
</ul>
</li>
<li><code>trigger_event</code>：触发事件，取值为<code>insert</code>，<code>update</code>，<code>delete</code><ul>
<li><code>insert</code> ：比如Mysql中的<code>insert</code>和<code>replace</code>语句就会触发这个事件</li>
<li><code>update</code>：更新某一行的数据会激发这个事件，比如<code>update</code>语句</li>
<li><code>delete</code>：删除某一行的时候激发触发器，可能通过<code>delete</code>或者<code>replace</code>语句激发</li>
</ul>
</li>
<li><code>table</code>：标识建立触发器的表名，即是当那张表发生了<code>insert</code>，<code>update</code>，<code>delete</code>事件激发触发器</li>
<li><code>trigger_stmt</code>：触发器执行的语句<ul>
<li>执行语句中不能返回结果集</li>
</ul>
</li>
</ul>
</li>
<li>实例：<ul>
<li><code>new.age</code>：获取新插入的字段<code>age</code>的值</li>
<li><code>new.name</code> ： 获取新插入的<code>name</code>字段的值</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">-- 创建user表</div><div class="line">create table user(id int primary key auto_increment,name varchar(10),age int); </div><div class="line"></div><div class="line">-- 设置用户变量@sum，用于统计年龄</div><div class="line">set @sum=0;  </div><div class="line"></div><div class="line">-- 插入数据,将会在插入数据之前激发触发器，执行触发器中定义的语句，计算出插入的年龄总和赋值给@sum</div><div class="line">insert into user(name,age) values(&quot;Jack&quot;,22),(&quot;Tom&quot;,33);</div><div class="line"></div><div class="line">-- 创建触发器，insert事件，在user表插入数据之前执行语句，其中的new.age是获取插入的每一行的age字段的值</div><div class="line">create trigger sum before  insert on user for each row set @sum=@sum+new.age;</div></pre></td></tr></table></figure>
<h3 id="创建多行执行语句的触发器"><a href="#创建多行执行语句的触发器" class="headerlink" title="创建多行执行语句的触发器"></a>创建多行执行语句的触发器</h3><ul>
<li>格式：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">	create trigger trigger_name trigger_time trigger_event on table for each row</div><div class="line">		begin</div><div class="line">			-- 语句执行列表</div><div class="line">		end </div><div class="line">		//</div><div class="line">delimiter ;</div></pre></td></tr></table></figure>
<ul>
<li>实例<ul>
<li>如果修改的名字和已经存在的重复，那么就设置异常（主键冲突）取消后面的更新语句，不过这个一定要使用<code>before</code>的触发时间</li>
<li><strong><code>new.name</code> : 表示修改之后的<code>name</code>字段的值，如果没有修改，那么和之前的一样</strong></li>
<li><strong><code>old.name</code> ：表示修改之前的<code>name</code>字段的值</strong></li>
<li><strong>触发器不能撤销后面的操作，如果想要撤销操作可以制造异常，那么后面的语句就不会执行了，如下面的程序制造了主键冲突的异常</strong></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">-- 创建user表</div><div class="line">create table user(id int primary key auto_increment,name varchar(10),age int);</div><div class="line"></div><div class="line">-- 创建触发器</div><div class="line">delimiter //</div><div class="line">	create trigger testUpdate before update on user for each row </div><div class="line">		begin</div><div class="line">			declare total int default 0;  -- 创建一个total变量，统计数量</div><div class="line">			select count(*) from user where name=new.name into total;  -- 根据修改之后的name查询出数量赋值给total</div><div class="line">			if old.name!=new.name&amp;&amp;total!=0  -- count!=0并且确实修改了名字表示修改的名字重复</div><div class="line">				then set new.id=1;   -- 名字重复导致主键冲突抛出异常，这样后续的语句就不会执行了</div><div class="line">			end if;</div><div class="line">		end</div><div class="line">		//</div><div class="line">delimiter ;</div></pre></td></tr></table></figure>
<h2 id="查看触发器"><a href="#查看触发器" class="headerlink" title="查看触发器"></a>查看触发器</h2><h3 id="查看所有触发器"><a href="#查看所有触发器" class="headerlink" title="查看所有触发器"></a>查看所有触发器</h3><ul>
<li><code>show triggers [from database]</code>  ： 查看当前数据的所有的触发器 <ul>
<li><code>show triggers from test \G</code> : 查看<code>test</code>数据库中的所有触发器</li>
<li><code>show triggers \G</code> ： 有条理的显示所有触发器</li>
</ul>
</li>
</ul>
<h3 id="查看指定的触发器"><a href="#查看指定的触发器" class="headerlink" title="查看指定的触发器"></a>查看指定的触发器</h3><ul>
<li>如果需要查看指定的触发器，那么可以从<code>information_schema</code>数据库中的<code>triggers</code>表中查询指定的触发器<ul>
<li><code>select * from information_schema.triggers where trigger_name=&quot;testUpdate&quot;\G</code> <ul>
<li><code>where</code>后面是条件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h2><ul>
<li><code>drop db.trigger_name</code> : 删除指定数据库中的触发器<ul>
<li><code>db</code> ：数据库的名字</li>
<li><code>trigger_name</code> ：触发器的名字</li>
</ul>
</li>
</ul>
<h2 id="触发器执行的顺序"><a href="#触发器执行的顺序" class="headerlink" title="触发器执行的顺序"></a>触发器执行的顺序</h2><ul>
<li>我们建立的数据库一般都是<code>InnoDB</code>数据库，其上建立的表是事务性表，也就是事务安全的。这时，若SQL语句或触发器执行失败，MySQL 会回滚事务，有：<ul>
<li>如果 BEFORE 触发器执行失败，SQL 无法正确执行。</li>
<li>SQL 执行失败时，AFTER 型触发器不会触发。</li>
<li>AFTER 类型的触发器执行失败，SQL 会回滚。</li>
</ul>
</li>
</ul>
<h2 id="NEW-和-OLD"><a href="#NEW-和-OLD" class="headerlink" title="NEW 和 OLD"></a>NEW 和 OLD</h2><ul>
<li>在<code>INSERT</code> 型触发器中，<code>NEW</code>用来表示将要（<code>BEFORE</code>）或已经（<code>AFTER</code>）插入的新数据；</li>
<li>在<code>UPDATE</code>型触发器中，<code>OLD</code> 用来表示将要或已经被修改的原数据，<code>NEW</code> 用来表示将要或已经修改为的新数据；</li>
<li>在 <code>DELETE</code>型触发器中，<code>OLD</code> 用来表示将要或已经被删除的原数据；</li>
</ul>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ul>
<li><code>NEW/OLD.columName</code> : 比如获取更新后的<code>name</code>字段的值<ul>
<li><code>new.name</code></li>
</ul>
</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li><code>OLD</code> 是只读的，不可以使用<code>set</code>修改</li>
<li><code>new</code>是可以修改的，我们可以在触发器中使用<code>set</code>语句修改</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MySQL触发器&quot;&gt;&lt;a href=&quot;#MySQL触发器&quot; class=&quot;headerlink&quot; title=&quot;MySQL触发器&quot;&gt;&lt;/a&gt;MySQL触发器&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
      <category term="数据库干货篇" scheme="http://chenjiabing666.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B2%E8%B4%A7%E7%AF%87/"/>
    
    
      <category term="SQL" scheme="http://chenjiabing666.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中的锁</title>
    <link href="http://chenjiabing666.github.io/2018/06/26/MySQL%E4%B8%AD%E7%9A%84%E9%94%81/"/>
    <id>http://chenjiabing666.github.io/2018/06/26/MySQL中的锁/</id>
    <published>2018-06-26T14:58:12.000Z</published>
    <updated>2018-06-26T14:58:43.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL中的锁"><a href="#MySQL中的锁" class="headerlink" title="MySQL中的锁"></a>MySQL中的锁</h1><h2 id="数据库引擎"><a href="#数据库引擎" class="headerlink" title="数据库引擎"></a>数据库引擎</h2><ul>
<li>数据库的引擎分为<code>MyISAM</code>和<code>InnoDB</code>和其他的</li>
<li>不同的数据库引擎默认使用的锁是不同的</li>
<li><code>MyISAM</code>默认使用的是<strong>表级别锁</strong>，<code>InnoDB</code>默认使用的是<code>行级锁</code></li>
<li>我们在使用的时候，一般都是使用<code>InnoDB</code>，支持事务，事务安全等功能</li>
</ul>
<h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><ul>
<li><strong>表级锁</strong>：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</li>
<li><strong>行级锁</strong>：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li>
<li><strong>页面锁</strong>：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</li>
</ul>
<h2 id="InnoDB锁的模式"><a href="#InnoDB锁的模式" class="headerlink" title="InnoDB锁的模式"></a>InnoDB锁的模式</h2><ul>
<li>InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁。</li>
<li><p>行级锁和表级锁本来就有许多不同之处，另外，事务的引入也带来了一些新问题。</p>
</li>
<li><p><strong>默认使用的是行级锁</strong></p>
</li>
</ul>
<h3 id="1-事务（Transaction）及其ACID属性"><a href="#1-事务（Transaction）及其ACID属性" class="headerlink" title="1.事务（Transaction）及其ACID属性"></a>1.事务（Transaction）及其ACID属性</h3><ul>
<li><p>事务是由一组SQL语句组成的逻辑处理单元，事务具有4属性，通常称为事务的ACID属性。</p>
</li>
<li><p>原性性（Actomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</p>
</li>
<li>一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以操持完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。</li>
<li>隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。</li>
<li>持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。</li>
</ul>
<h3 id="2-并发事务带来的问题"><a href="#2-并发事务带来的问题" class="headerlink" title="2.并发事务带来的问题"></a>2.并发事务带来的问题</h3><ul>
<li><p>相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持可以支持更多的用户。但并发事务处理也会带来一些问题，主要包括以下几种情况。</p>
</li>
<li><p><strong>更新丢失</strong>（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题——最后的更新覆盖了其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改保存其更改副本的编辑人员覆盖另一个编辑人员所做的修改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题</p>
</li>
<li><strong>脏读</strong>（Dirty Reads）：一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读”。</li>
<li><strong>不可重复读</strong>（Non-Repeatable Reads）：一个事务在读取某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。</li>
<li><strong>幻读</strong>（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。</li>
</ul>
<h3 id="3-事务隔离级别"><a href="#3-事务隔离级别" class="headerlink" title="3.事务隔离级别"></a>3.事务隔离级别</h3><ul>
<li>在并发事务处理带来的问题中，“更新丢失”通常应该是完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据<strong>加必要的锁</strong>来解决，因此，防止更新丢失应该是应用的责任。</li>
<li>“脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。数据库实现事务隔离的方式，基本可以分为以下两种。</li>
<li>一种是在读取数据前，对其加锁，阻止其他事务对数据进行修改。</li>
<li><p>另一种是不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot），并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度，好像是数据库可以提供同一数据的多个版本，因此，这种技术叫做数据多版本并发控制（ＭultiVersion Concurrency Control，简称MVCC或MCC），也经常称为多版本数据库。</p>
</li>
<li><p>数据库的事务隔离级别越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的，同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。</p>
</li>
<li><p>为了解决“隔离”与“并发”的矛盾，ISO/ANSI SQL92定义了４个事务隔离级别，每个级别的隔离程度不同，允许出现的副作用也不同，应用可以根据自己业务逻辑要求，通过选择不同的隔离级别来平衡＂隔离＂与＂并发＂的矛盾</p>
</li>
</ul>
<h3 id="事务４种隔离级别比较"><a href="#事务４种隔离级别比较" class="headerlink" title="事务４种隔离级别比较"></a>事务４种隔离级别比较</h3><table>
<thead>
<tr>
<th>隔离级别/读数据一致性及允许的并发副作用</th>
<th>读数据一致性</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>未提交读（Read uncommitted）</td>
<td>最低级别，只能保证不读取物理上损坏的数据</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>已提交度（Read committed）</td>
<td>语句级</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可重复读（Repeatable read）</td>
<td>事务级</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>可序列化（Serializable）</td>
<td>最高级别，事务级</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody>
</table>
<h3 id="两种行级锁"><a href="#两种行级锁" class="headerlink" title="两种行级锁"></a>两种行级锁</h3><ol>
<li><p><strong>共享锁（S）</strong>：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁</p>
<ul>
<li><p><strong>共享锁好像只读锁，可以允许多个事务同时读这行数据，但是不允许修改（排他锁）</strong></p>
</li>
<li><p>如果一个事务获取共享锁了，那么其他事务只能获取这一行的共享锁，而不能获取这行的排他锁</p>
</li>
</ul>
</li>
<li><p><strong>排他锁（X）</strong>：允许获得排他锁的事务更新数据，但是组织其他事务获得相同数据集的共享锁和排他锁。</p>
<ul>
<li><strong>相当于只写锁，只能同时允许一个事务对该行数据的更新，并且也不允许其他的事务读这行的数据</strong></li>
<li>如果一个事务获取了这行数据的排他锁，那么其他的事务将不能获取这行数据的共享锁和排它锁，只有等待前一个事务释放才有机会获取</li>
</ul>
</li>
</ol>
<ul>
<li><strong>对于<code>UPDATE</code>、<code>DELETE</code>和<code>INSERT</code>语句，InnoDB会自动给涉及及数据集加排他锁（Ｘ）</strong></li>
<li><strong>对于普通<code>SELECT</code>语句，InnoDB不会任何锁；事务可以通过以下语句显示给记录集加共享锁或排锁。</strong><ul>
<li>共享锁（Ｓ）：<code>SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE</code></li>
<li>排他锁（X）：<code>SELECT * FROM table_name WHERE ... FOR UPDATE</code></li>
</ul>
</li>
</ul>
<h3 id="两种表级锁"><a href="#两种表级锁" class="headerlink" title="两种表级锁"></a>两种表级锁</h3><ul>
<li><strong>意向共享锁（IS）</strong>：表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的IS锁</li>
<li><strong>意向排他锁（IX）</strong>：类似上面，表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得该表的IX锁。</li>
<li><strong>意向锁是InnoDB自动加的，不需用户干预</strong></li>
</ul>
<h3 id="InnoDB行锁兼容模式"><a href="#InnoDB行锁兼容模式" class="headerlink" title="InnoDB行锁兼容模式"></a>InnoDB行锁兼容模式</h3><ul>
<li><strong>当一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之如果请求不兼容，则该事务就等待锁释放。</strong></li>
</ul>
<table>
<thead>
<tr>
<th>当前锁模式/是否兼容/请求锁模式</th>
<th>X</th>
<th>IX</th>
<th>S</th>
<th>IS</th>
</tr>
</thead>
<tbody>
<tr>
<td>X</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
</tr>
<tr>
<td>IX</td>
<td>冲突</td>
<td>兼容</td>
<td>冲突</td>
<td>兼容</td>
</tr>
<tr>
<td>S</td>
<td>冲突</td>
<td>冲突</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>IS</td>
<td>冲突</td>
<td>兼容</td>
<td>兼容</td>
<td>兼容</td>
</tr>
</tbody>
</table>
<h3 id="InnoDB行锁实现原理"><a href="#InnoDB行锁实现原理" class="headerlink" title="InnoDB行锁实现原理"></a>InnoDB行锁实现原理</h3><ul>
<li><strong>InnoDB行锁是通过给<code>索引项</code>加锁实现的，如果没有索引，InnoDB会通过隐藏的聚簇索引来对记录加锁。</strong></li>
<li><strong>也就是说：如果不通过索引条件检索数据，那么InnoDB将对表中所有数据加锁，实际效果跟表锁一样。</strong></li>
</ul>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul>
<li>我们知道数据库会为主键<code>id</code>创建唯一性索引，如果一个事务执行<code>select * from user where id=1 for update</code>，那么执行完成之后数据库仅仅是为<code>id=1</code>这行的数据添加<code>排他锁</code>，其他事务对其他行的数据还是可以获取共享锁和排他锁的，即是其他事务还是可以对其他行的数据执行增删改查的。但是对于<code>id=1</code>这行的数据只能<code>select</code>不能更新插入。如果执行了<code>update user set name=&quot;Jack&quot; where id=1</code>，会自动为<code>id=1</code>这行数据添加排他锁，其他的事务对改行数据不能做任何的操作（可以<code>select</code>），但是可以对其他行的数据仍然可以执行操作</li>
<li>此时如果一个事务执行了<code>update user set name=&quot;Jack&quot; where age=22</code>，因为<code>age</code>不是索引，那么会自动添加<code>表级锁</code>锁住<code>user</code>表中的全部数据，那么此时所有的数据在另外一个事务中只能查询了，不能执行更新和插入了</li>
<li>此时如果我们为<code>age</code>添加索引：<code>create index age_index on user(age)</code>，再执行<code>update user set name=&quot;Jack&quot; where age=22</code>，那么此时添加的就是<code>行级锁</code>，仅仅锁住的是<code>age=22</code>的那些行，另外的事务还是可以操作其他行的数据</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul>
<li>加入共享锁，<code>where id</code>，id默认是唯一索引</li>
<li><img src="https://www.2cto.com/uploadfile/Collfiles/20150810/20150810092332321.png" alt=""></li>
</ul>
<ul>
<li>排他锁的例子<ul>
<li>使用<code>select * from .... for update</code> 添加排他锁</li>
</ul>
</li>
<li><img src="https://www.2cto.com/uploadfile/Collfiles/20150810/20150810092333322.png" alt=""></li>
</ul>
<h3 id="行锁的三种情形"><a href="#行锁的三种情形" class="headerlink" title="行锁的三种情形"></a>行锁的三种情形</h3><ul>
<li><strong>以下的三种情形都是针对索引项的，不是索引项的会自动使用表级锁锁住全表</strong></li>
</ul>
<ol>
<li><strong>Record lock</strong> ：对<strong>索引项</strong>加锁，即锁定一条记录。</li>
<li><strong>Gap lock：</strong>对<strong>索引项</strong>之间的<code>间隙</code>、对第一条记录前的间隙或最后一条记录后的间隙加锁，即锁定一个范围的记录，不包含记录本身</li>
<li><strong>Next-key Lock</strong>：锁定一个范围的记录并包含记录本身（上面两者的结合）。</li>
</ol>
<h4 id="间隙锁（Next-Key锁）"><a href="#间隙锁（Next-Key锁）" class="headerlink" title="间隙锁（Next-Key锁）"></a>间隙锁（Next-Key锁）</h4><ul>
<li><p>只针对带有区间的操作，比如<code>&gt;30</code>或者<code>&lt;3</code>等</p>
</li>
<li><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙(GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制不是所谓的间隙锁（Next-Key锁）。</p>
</li>
<li><p>举例来说，假如emp表中只有101条记录，其<code>empid</code>（主键，唯一索引）的值分别是1,2,…,100,101，下面的SQL：</p>
<p><code>SELECT * FROM emp WHERE empid &gt; 100 FOR UPDATE</code></p>
</li>
<li><p>是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。</p>
</li>
<li><p>InnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求，对于上面的例子，要是不使用间隙锁，如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另一方面，是为了满足其恢复和复制的需要。有关其恢复和复制对机制的影响，以及不同隔离级别下InnoDB使用间隙锁的情况。</p>
</li>
<li><p>很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。</p>
</li>
</ul>
<h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><ul>
<li>我们给<code>age</code>添加了索引，那么在一个事务中执行<code>select * from user where age&gt;22 for update</code> 或者<code>update user set name=&quot;Jack&quot; where age&gt;22</code> ，都会为<code>user</code>表中<code>age&gt;22</code>这个区间的数据添加<code>间隙锁</code>那么只要<code>age</code>的范围在<code>22~positive infinity</code>之间的数据另外一个事务都不可以更新或者插入，在<code>age&lt;=22</code>之间的数据是可以操作的，比如<code>insert</code>，<code>update</code></li>
</ul>
<h3 id="什么时候使用表锁"><a href="#什么时候使用表锁" class="headerlink" title="什么时候使用表锁"></a>什么时候使用表锁</h3><ul>
<li><p>对于InnoDB表，在绝大部分情况下都应该使用行级锁，因为事务和行锁往往是我们之所以选择InnoDB表的理由。但在个另特殊事务中，也可以考虑使用表级锁。</p>
</li>
<li><p>第一种情况是：事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度。</p>
</li>
<li><p>第二种情况是：事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。</p>
</li>
<li><p>当然，应用中这两种事务不能太多，否则，就应该考虑使用ＭyISAＭ表。</p>
</li>
<li><p>在InnoDB下 ，使用表锁要注意以下两点。</p>
</li>
<li><p>（１）使用LOCK TALBES虽然可以给InnoDB加表级锁，但必须说明的是，表锁不是由InnoDB存储引擎层管理的，而是由其上一层ＭySQL Server负责的，仅当autocommit=0、innodb_table_lock=1（默认设置）时，InnoDB层才能知道MySQL加的表锁，ＭySQL Server才能感知InnoDB加的行锁，这种情况下，InnoDB才能自动识别涉及表级锁的死锁；否则，InnoDB将无法自动检测并处理这种死锁。</p>
</li>
<li><p>（２）在用LOCAK TABLES对InnoDB锁时要注意，要将AUTOCOMMIT设为0，否则ＭySQL不会给表加锁；事务结束前，不要用UNLOCAK TABLES释放表锁，因为UNLOCK TABLES会隐含地提交事务；COMMIT或ROLLBACK产不能释放用LOCAK TABLES加的表级锁，必须用UNLOCK TABLES释放表锁，正确的方式见如下语句。</p>
</li>
<li><p>例如，如果需要写表t1并从表t读，可以按如下做：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SET AUTOCOMMIT=0;</div><div class="line">LOCAK TABLES t1 WRITE, t2 READ, ...;</div><div class="line">[do something with tables t1 and here];</div><div class="line">COMMIT;</div><div class="line">UNLOCK TABLES;</div></pre></td></tr></table></figure>
<h3 id="关于死锁"><a href="#关于死锁" class="headerlink" title="关于死锁"></a>关于死锁</h3><ul>
<li>ＭyISAM表锁是deadlock free的，这是因为ＭyISAM总是一次性获得所需的全部锁，要么全部满足，要么等待，因此不会出现死锁。但是在InnoDB中，除单个SQL组成的事务外，锁是逐步获得的，这就决定了InnoDB发生死锁是可能的。</li>
<li>发生死锁后，InnoDB一般都能自动检测到，并使一个事务释放锁并退回，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及锁的情况下，InnoDB并不能完全自动检测到死锁，这需要通过设置锁等待超时参数innodb_lock_wait_timeout来解决。需要说明的是，这个参数并不是只用来解决死锁问题，在并发访问比较高的情况下，如果大量事务因无法立即获取所需的锁而挂起，会占用大量计算机资源，造成严重性能问题，甚至拖垮数据库。我们通过设置合适的锁等待超时阈值，可以避免这种情况发生。</li>
<li>通常来说，死锁都是应用设计的问题，通过调整业务流程、数据库对象设计、事务大小、以及访问数据库的SQL语句，绝大部分都可以避免。下面就通过实例来介绍几种死锁的常用方法。</li>
<li>（１）在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序为访问表，这样可以大大降低产生死锁的机会。如果两个session访问两个表的顺序不同，发生死锁的机会就非常高！但如果以相同的顺序来访问，死锁就可能避免。</li>
<li>（２）在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低死锁的可能。</li>
<li>（３）在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应该先申请共享锁，更新时再申请排他锁，甚至死锁。</li>
<li>（４）在REPEATEABLE-READ隔离级别下，如果两个线程同时对相同条件记录用SELECT…ROR UPDATE加排他锁，在没有符合该记录情况下，两个线程都会加锁成功。程序发现记录尚不存在，就试图插入一条新记录，如果两个线程都这么做，就会出现死锁。这种情况下，将隔离级别改成READ COMMITTED，就可以避免问题。</li>
<li>（５）当隔离级别为READ COMMITED时，如果两个线程都先执行SELECT…FOR UPDATE，判断是否存在符合条件的记录，如果没有，就插入记录。此时，只有一个线程能插入成功，另一个线程会出现锁等待，当第１个线程提交后，第２个线程会因主键重出错，但虽然这个线程出错了，却会获得一个排他锁！这时如果有第３个线程又来申请排他锁，也会出现死锁。对于这种情况，可以直接做插入操作，然后再捕获主键重异常，或者在遇到主键重错误时，总是执行ROLLBACK释放获得的排他锁。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>对于ＭyISAM的表锁，主要有以下几点</strong><br>（１）共享读锁（S）之间是兼容的，但共享读锁（S）和排他写锁（X）之间，以及排他写锁之间（X）是互斥的，也就是说读和写是串行的。</p>
<p>（２）在一定条件下，ＭyISAM允许查询和插入并发执行，我们可以利用这一点来解决应用中对同一表和插入的锁争用问题。</p>
<p>（３）ＭyISAM默认的锁调度机制是写优先，这并不一定适合所有应用，用户可以通过设置LOW_PRIPORITY_UPDATES参数，或在INSERT、UPDATE、DELETE语句中指定LOW_PRIORITY选项来调节读写锁的争用。</p>
<p>（４）由于表锁的锁定粒度大，读写之间又是串行的，因此，如果更新操作较多，ＭyISAM表可能会出现严重的锁等待，可以考虑采用InnoDB表来减少锁冲突。</p>
<p><strong>对于InnoDB表，主要有以下几点</strong></p>
<p>（１）InnoDB的行销是基于索引实现的，如果不通过索引访问数据，InnoDB会使用表锁。</p>
<p>（２）InnoDB间隙锁机制，以及InnoDB使用间隙锁的原因。</p>
<p>（３）在不同的隔离级别下，InnoDB的锁机制和一致性读策略不同。</p>
<p>（４）ＭySQL的恢复和复制对InnoDB锁机制和一致性读策略也有较大影响。</p>
<p>（５）锁冲突甚至死锁很难完全避免。</p>
<p><strong>在了解InnoDB的锁特性后，用户可以通过设计和SQL调整等措施减少锁冲突和死锁，包括：</strong></p>
<ul>
<li>尽量使用较低的隔离级别</li>
<li>精心设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会。</li>
<li>选择合理的事务大小，小事务发生锁冲突的几率也更小。</li>
<li>给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁。</li>
<li>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大减少死锁的机会。</li>
<li>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响。</li>
<li>不要申请超过实际需要的锁级别；除非必须，查询时不要显示加锁。</li>
<li>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="http://www.cnblogs.com/chenqionghe/p/4845693.html" target="_blank" rel="external">http://www.cnblogs.com/chenqionghe/p/4845693.html</a></li>
<li><a href="http://www.cnblogs.com/chenqionghe/p/4845693.html" target="_blank" rel="external">http://www.cnblogs.com/chenqionghe/p/4845693.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MySQL中的锁&quot;&gt;&lt;a href=&quot;#MySQL中的锁&quot; class=&quot;headerlink&quot; title=&quot;MySQL中的锁&quot;&gt;&lt;/a&gt;MySQL中的锁&lt;/h1&gt;&lt;h2 id=&quot;数据库引擎&quot;&gt;&lt;a href=&quot;#数据库引擎&quot; class=&quot;headerlink
    
    </summary>
    
      <category term="数据库干货篇" scheme="http://chenjiabing666.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B2%E8%B4%A7%E7%AF%87/"/>
    
    
      <category term="SQL" scheme="http://chenjiabing666.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Mysql存储过程和存储函数</title>
    <link href="http://chenjiabing666.github.io/2018/06/26/Mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0/"/>
    <id>http://chenjiabing666.github.io/2018/06/26/Mysql存储过程和存储函数/</id>
    <published>2018-06-26T14:56:37.000Z</published>
    <updated>2018-06-26T14:57:55.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql存储过程和存储函数"><a href="#Mysql存储过程和存储函数" class="headerlink" title="Mysql存储过程和存储函数"></a>Mysql存储过程和存储函数</h1><h2 id="存储过程的好处"><a href="#存储过程的好处" class="headerlink" title="存储过程的好处"></a>存储过程的好处</h2><ul>
<li><strong>增强SQL语言的功能和灵活性</strong>：存储过程可以用控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。</li>
<li><strong>标准组件式编程</strong>：存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。而且数据库专业人员可以随时对存储过程进行修改，对应用程序源代码毫无影响。</li>
<li><strong>较快的执行速度</strong>：如果某一操作包含大量的Transaction-SQL代码或分别被多次执行，那么存储过程要比批处理的执行速度快很多。因为存储过程是预编译的。在首次运行一个存储过程时查询，优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的Transaction-SQL语句在每次运行时都要进行编译和优化，速度相对要慢一些。</li>
<li>减少网络流量：针对同一个数据库对象的操作（如查询、修改），如果这一操作所涉及的Transaction-SQL语句被组织进存储过程，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而大大减少网络流量并降低了网络负载。</li>
<li>作为一种安全机制来充分利用：通过对执行某一存储过程的权限进行限制，能够实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全。</li>
</ul>
<h2 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h2><h3 id="创建存储函数"><a href="#创建存储函数" class="headerlink" title="创建存储函数"></a>创建存储函数</h3><ul>
<li>在Mysql中有许多已经存在的存储函数，比如<code>CONCAT(..)</code>,<code>LENGTH(str)</code>。但是我们也可以自己定义存储函数。</li>
<li>格式如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">delimiter //    -- 指定分割符</div><div class="line">	create function fun_name()</div><div class="line">	returns type     -- type是执行存储函数返回的类型</div><div class="line">	begin </div><div class="line">	-- 执行其他的语句</div><div class="line">	return ();   -- 返回的数据</div><div class="line">	end</div><div class="line">	//</div><div class="line"></div><div class="line">delimiter ;  -- 指定创建结束</div></pre></td></tr></table></figure>
<ul>
<li><code>returns type</code> : 指定存储函数返回的类型，比如<code>returns char(50)</code>,<code>returns int</code></li>
<li><strong>存储函数有且只有一个返回值</strong></li>
<li><code>return ()</code> : 存储函数的返回值，这里的返回值类型需要和<code>returns type</code>中的类型一致，如果不一致会强制转换<ul>
<li><code>return (select name from user where id=1);</code></li>
</ul>
</li>
<li>下面我们创建一个存储函数，返回<code>user</code>表中的<code>id=1</code>的<code>name</code>值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">	create function selectUserById()</div><div class="line">	returns varchar(50) </div><div class="line">	begin </div><div class="line">	return (select name from user where id=1);</div><div class="line">	end</div><div class="line">	//</div><div class="line">	delimiter ;</div></pre></td></tr></table></figure>
<h4 id="指定参数"><a href="#指定参数" class="headerlink" title="指定参数"></a>指定参数</h4><ul>
<li><strong>在存储函数创建的时候还可以指定参数，这个参数是用户调用的时候输入的。</strong></li>
<li><strong>存储函数中的参数默认是<code>IN</code>参数，而存储过程中的参数可以是<code>IN</code>、<code>OUT</code>、<code>INOUT</code></strong></li>
<li>直接使用<code>parameter 类型</code>指定即可，如果有多个参数可以使用<code>,</code>分割</li>
<li>在调用的时候直接使用<code>select funName(parmeter1,....);</code>即可</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">	create function selectUserById(uid int)</div><div class="line">	returns varchar(50) </div><div class="line">	begin </div><div class="line">	return (select name from user where id=uid);</div><div class="line">	end</div><div class="line">	//</div><div class="line">	delimiter ;</div></pre></td></tr></table></figure>
<h3 id="调用存储函数"><a href="#调用存储函数" class="headerlink" title="调用存储函数"></a>调用存储函数</h3><ul>
<li>存储函数是依赖数据库的，因此我们需要在指定的数据库中调用，或者前面指定数据库的名称<ul>
<li><code>select selectUserById();</code>  : 直接在存储函数所在数据库中调用</li>
<li><code>select dbName.selectUserById();</code>  : 直接使用数据库的名称调用</li>
</ul>
</li>
</ul>
<h3 id="删除存储函数"><a href="#删除存储函数" class="headerlink" title="删除存储函数"></a>删除存储函数</h3><ul>
<li><code>drop function selectUserById;</code> ：直接在存储函数所在数据库中直接删除存储函数</li>
<li><code>drop function dbName.selectUserById;</code> ：使用数据库名称删除存储函数</li>
</ul>
<h3 id="查看存储函数状态"><a href="#查看存储函数状态" class="headerlink" title="查看存储函数状态"></a>查看存储函数状态</h3><ul>
<li>格式：<code>show function status [like pattern]</code>    ： 查看存储函数的状态<ul>
<li><code>show function status \G</code> : 查看所有的存储函数状态,<code>\G</code>是一种特定格式的输出</li>
<li><code>show function status like &#39;select%&#39;\G</code> ：查看<code>select</code>开头的存储函数状态，<code>\G</code>是一种特定格式的输入。</li>
</ul>
</li>
</ul>
<h3 id="查看存储函数的定义"><a href="#查看存储函数的定义" class="headerlink" title="查看存储函数的定义"></a>查看存储函数的定义</h3><ul>
<li>格式：<code>show create function dbName.funName</code><ul>
<li><code>show create function test.selectUserById \G;</code>  ：查询<code>test</code>数据库中的存储函数<code>selectUserById</code>的定义，<code>\G</code>是一种特定的输出格式</li>
</ul>
</li>
</ul>
<h3 id="修改存储函数"><a href="#修改存储函数" class="headerlink" title="修改存储函数"></a>修改存储函数</h3><p><img src="http://ono60m7tl.bkt.clouddn.com/storefunction1.png" alt=""></p>
<h2 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h2><ul>
<li>变量的作用范围是<code>begin.....end</code>程序中</li>
</ul>
<h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><ul>
<li>格式：<code>declare var_name,.... type [default value]</code> <ul>
<li><code>declare age int default 22</code> ：定义一个<strong>局部变量</strong><code>age</code>，类型为<code>int</code>，默认值为<code>22</code></li>
<li><code>declare var1,var2,var3 int</code> ： 定义三个<strong>局部变量</strong>，类型为<code>int</code></li>
</ul>
</li>
<li><strong>全部变量的声明一定要在赋值的前面，否则报错</strong></li>
</ul>
<h3 id="定义用户变量"><a href="#定义用户变量" class="headerlink" title="定义用户变量"></a>定义用户变量</h3><ul>
<li>用户变量以<code>@</code>开头</li>
<li><code>set @pin=10</code></li>
</ul>
<h3 id="为变量赋值"><a href="#为变量赋值" class="headerlink" title="为变量赋值"></a>为变量赋值</h3><ul>
<li>格式：<code>set var1=value1,[var2=value2,....]</code><ul>
<li><code>set age=33;</code> ： 设置age的值为33</li>
<li><code>set var1=22,var2=33</code>: 同时设置多个值</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">declare var1,var2,var3 int;</div><div class="line">set var1=22,var2=33;</div><div class="line">set var3=var1+var2;</div></pre></td></tr></table></figure>
<ul>
<li>使用<code>select col_name[,...] into var_name[,....]  table_expr</code> : 使用<code>select</code>查询得到的结果赋值给变量<ul>
<li>这个<code>select</code>把选定的列的值直接赋值给对应位置的变量</li>
<li><code>table_expr</code>: 可以是表的查询条件，其中包含<code>from 表名</code></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">declare uname varchar(10);  -- 定义变量uname</div><div class="line">declare uage int;    -- 定义变量uage</div><div class="line">select name,age into uname,uage from user where id=1;  -- 将id=1的用户姓名和年龄赋值给变量</div></pre></td></tr></table></figure>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="在存储函数中使用"><a href="#在存储函数中使用" class="headerlink" title="在存储函数中使用"></a>在存储函数中使用</h4><ul>
<li>在存储函数中定义局部变量，并且获取输出</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">	create function selectUserById(uid int)</div><div class="line">	returns varchar(50) </div><div class="line">	begin </div><div class="line">	declare uname varchar(50);</div><div class="line">	select name into uname from user where id=uid;</div><div class="line">	return uname;</div><div class="line">	end</div><div class="line">	//</div><div class="line">	delimiter ;</div></pre></td></tr></table></figure>
<h4 id="在存储过程中使用"><a href="#在存储过程中使用" class="headerlink" title="在存储过程中使用"></a>在存储过程中使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">	create procedure selectUserById(IN uid int)</div><div class="line">		begin</div><div class="line">			declare offest,count int;   -- 定义偏移量</div><div class="line">			set offest=0,count=2;       -- 赋值</div><div class="line">			if uid is not null          -- 如果uid不为null，按照id查询</div><div class="line">				then select * from user where id=uid;  -- 按照id查询</div><div class="line">				else select * from user limit offest,count;  -- 否则uid为null，按照分页查询前面两个</div><div class="line">			end if;</div><div class="line">		end </div><div class="line">		//</div><div class="line">delimiter ;</div></pre></td></tr></table></figure>
<ul>
<li><code>call selectUserById(1)</code>;  ： 查询<code>id=1</code>的用户信息</li>
<li><code>call selectUserById(null);</code>  ：查询所有的用户信息，显示前面两个</li>
</ul>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul>
<li>MySQL存储过程可使用两种风格的注释：<ul>
<li>双杠：–，该风格一般用于单行注释</li>
<li>C风格： 一般用于多行注释</li>
</ul>
</li>
</ul>
<h2 id="流程控制标签的使用"><a href="#流程控制标签的使用" class="headerlink" title="流程控制标签的使用"></a>流程控制标签的使用</h2><ul>
<li>在<code>begin</code>和<code>end</code>之间使用</li>
</ul>
<h3 id="IF-THEN-ELSEIF-ELSE-ENDIF"><a href="#IF-THEN-ELSEIF-ELSE-ENDIF" class="headerlink" title="IF - THEN - ELSEIF - ELSE -ENDIF"></a>IF - THEN - ELSEIF - ELSE -ENDIF</h3><ul>
<li>格式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">begin</div><div class="line">	if expression   -- 判断条件</div><div class="line">    	then .... ;   -- 条件成立执行</div><div class="line">    	elseif .....;   -- 其他条件</div><div class="line">    	else ..... ;  -- 条件相反执行</div><div class="line">    endif;   		  -- 结束if</div><div class="line">end</div></pre></td></tr></table></figure>
<ul>
<li><p>可以不是成对出现，比如只有<code>if</code>，或者<code>if-else</code></p>
</li>
<li><p><strong>如果没有<code>else</code>，那么可以省略，比如<code>if - then - endif</code></strong></p>
</li>
<li>判断相等使用<code>=</code></li>
</ul>
<ul>
<li>实例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">	create procedure selectUserById(IN uid int)</div><div class="line">		begin</div><div class="line">			declare offest,count int;   -- 定义偏移量</div><div class="line">			set offest=0,count=2;       -- 赋值</div><div class="line">			if uid is not null          -- 如果uid不为null，按照id查询</div><div class="line">				then select * from user where id=uid;  -- 按照id查询</div><div class="line">				else select * from user limit offest,count;  -- 否则uid为null，按照分页查询前面两个</div><div class="line">			end if;</div><div class="line">		end </div><div class="line">		//</div><div class="line">delimiter ;</div></pre></td></tr></table></figure>
<h3 id="CASE-WHEN-THEN-ELSE-END-CASE"><a href="#CASE-WHEN-THEN-ELSE-END-CASE" class="headerlink" title="CASE - WHEN - THEN - ELSE - END CASE"></a>CASE - WHEN - THEN - ELSE - END CASE</h3><ul>
<li>这个和java中的<code>switch-case-default</code>相似</li>
<li>格式：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">case expr</div><div class="line">	when value1 then ....;</div><div class="line">	when value2  then .....;</div><div class="line">	when......;</div><div class="line">	....</div><div class="line">	else  .......;</div><div class="line">end case;</div></pre></td></tr></table></figure>
<ul>
<li>实例<ul>
<li>创建一个存储过程，使用<code>case</code></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">	create procedure deleteUserById(IN uid int)</div><div class="line">		begin</div><div class="line">			case uid   -- uid做选择</div><div class="line">				when 1   -- uid==1</div><div class="line">					then delete from user where id=1;   </div><div class="line">				when 2   -- uid==2</div><div class="line">					then delete from user where id=2;</div><div class="line">				else   </div><div class="line">					delete from user;	  -- 删除全部</div><div class="line">			end case;</div><div class="line">		end;</div><div class="line">		//</div><div class="line">delimiter ;</div></pre></td></tr></table></figure>
<h3 id="LOOP-ENDLOOP"><a href="#LOOP-ENDLOOP" class="headerlink" title="LOOP - ENDLOOP"></a>LOOP - ENDLOOP</h3><ul>
<li><code>LOOP</code>只是创建一个循环执行的过程，并不进行条件判断，这个和<code>while</code>不一样，不需要判断条件，如果不跳出，那么将会永远的执行的下去。<strong>但是我们可以使用<code>leave</code>跳出循环</strong></li>
<li>格式：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[LOOP_LABEL]:LOOP</div><div class="line">	statement;</div><div class="line">END LOOP [LOOP_LABEL];</div></pre></td></tr></table></figure>
<ul>
<li>实例<ul>
<li>执行这个语句可以插入<code>9</code>条数据，如果<code>i&gt;=10</code>跳出循环</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">	create procedure insertUserByName(IN uname varchar(50))</div><div class="line">		begin	</div><div class="line">			declare i int default 0;</div><div class="line">			add_loop:loop  -- 开始循环</div><div class="line">				set i=i+1;  -- id++操作</div><div class="line">				insert into user(name) values(uname);  -- 插入语句</div><div class="line">				if i&gt;=10</div><div class="line">					then leave add_loop;   -- 使用leave跳出循环</div><div class="line">				end if;</div><div class="line">			end loop add_loop;   -- 结束循环</div><div class="line">		end</div><div class="line">		//</div><div class="line">delimiter ;</div></pre></td></tr></table></figure>
<h3 id="LEAVE"><a href="#LEAVE" class="headerlink" title="LEAVE"></a>LEAVE</h3><ul>
<li>和循环一起使用，用于退出循环控制，见上面的例子</li>
</ul>
<h3 id="ITERATE"><a href="#ITERATE" class="headerlink" title="ITERATE"></a>ITERATE</h3><ul>
<li><p>格式：<code>iterate label</code></p>
</li>
<li><p><code>iterate</code>只可以出现在<code>LOOP</code>，<code>REPEAT</code>，<code>WHIE</code>语句内，表示再次循环的意思，<code>label</code>表示循环的标志</p>
</li>
<li>实例<ul>
<li>如果<code>p&lt;10</code>重复执行<code>p++</code></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">	create procedure doiterate()</div><div class="line">		begin	</div><div class="line">			declare p int default 0;  -- 定义局部变量</div><div class="line">			my_loop:loop</div><div class="line">				set p=p+1;  -- p++</div><div class="line">                if p&lt;10 </div><div class="line">                	then iterate my_loop;  -- 继续执行前面的循环的语句，p++</div><div class="line">                elseif p&gt;20</div><div class="line">                	then leave my_loop;</div><div class="line">                end if</div><div class="line">        			select &quot;p在10到20之间&quot;   -- 输出语句</div><div class="line">			end loop my_loop;</div><div class="line">		end</div><div class="line">		//</div><div class="line">delimiter ;</div></pre></td></tr></table></figure>
<h3 id="REPEAT"><a href="#REPEAT" class="headerlink" title="REPEAT"></a>REPEAT</h3><ul>
<li>这个也是循环语句，相当于<code>do-while</code></li>
<li>格式：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[repeat_loop]: repeat</div><div class="line">	statement_list;</div><div class="line">	until exper    -- 没有分号</div><div class="line">	end repeat;</div></pre></td></tr></table></figure>
<ul>
<li>实例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">	create procedure dorepeat()</div><div class="line">		begin	</div><div class="line">			declare p int default 0;  -- 定义局部变量</div><div class="line">			my_loop:repeat</div><div class="line">				set p=p+1;</div><div class="line">				select p;</div><div class="line">				until p&gt;10  -- 当p&gt;10的时候循环结束</div><div class="line">			end repeat my_loop;</div><div class="line">		end</div><div class="line">		//</div><div class="line">delimiter ;</div></pre></td></tr></table></figure>
<h3 id="WHILE"><a href="#WHILE" class="headerlink" title="WHILE"></a>WHILE</h3><ul>
<li>这个和<code>REPEAT</code>不同，先进行判断，然后才执行语句</li>
<li>格式：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[while_label]:while expr do</div><div class="line">	statement_list;</div><div class="line">	end while [while_lable];</div></pre></td></tr></table></figure>
<ul>
<li>实例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">	create procedure dowhile()</div><div class="line">		begin	</div><div class="line">			declare p int default 0;  -- 定义局部变量</div><div class="line">			my_loop:while p&lt;10  do   -- 满足条件才执行</div><div class="line">				set p=p+1;   -- p++</div><div class="line">			end while my_loop;    -- 结束循环</div><div class="line">		end</div><div class="line">		//</div><div class="line">delimiter ;</div></pre></td></tr></table></figure>
<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><ul>
<li>存储过程没有返回值</li>
</ul>
<h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><ul>
<li>格式：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">create procedure p_name([IN,OUT,INOUT]parameter 类型.....)</div><div class="line">	begin</div><div class="line">	-- 执行功能</div><div class="line">	end</div><div class="line">	//</div><div class="line">delimiter ;</div></pre></td></tr></table></figure>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li>存储过程根据需要可能会有输入、输出、输入输出参数，如果有多个参数用”,”分割开。MySQL存储过程的参数用在存储过程的定义，共有三种参数类型,IN,OUT,INOUT:<ul>
<li><strong>IN</strong>参数的值必须在调用存储过程时指定，在存储过程中修改该参数的值不能被返回，为默认值</li>
<li><strong>OUT</strong>:该值可在存储过程内部被改变，并可返回</li>
<li><strong>INOUT</strong>:调用时指定，并且可被改变和返回</li>
</ul>
</li>
</ul>
<h3 id="过程体"><a href="#过程体" class="headerlink" title="过程体"></a>过程体</h3><ul>
<li>过程体的开始与结束使用<code>BEGIN</code>与<code>END</code>进行标识。</li>
</ul>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><ul>
<li>定义一个根据<code>id</code>查询的查询用户信息的存储过程，这里的id是由用户输入的，因此可以使用<code>IN</code>参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">	create procedure selectUserById(IN uid int)</div><div class="line">		begin</div><div class="line">			select * from user where id=uid;</div><div class="line">		end</div><div class="line">		//</div><div class="line">delimiter ;</div></pre></td></tr></table></figure>
<h3 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h3><ul>
<li>格式：<code>call procedure_name(...)</code><ul>
<li><code>call selectUserById(1);</code>  :  直接在当前的数据库中调用存储过程<code>selectUserById</code></li>
<li><code>call db_name.selectUsrById(1)</code> : 指定数据库的名字调用</li>
</ul>
</li>
</ul>
<h3 id="查看存储过程的状态"><a href="#查看存储过程的状态" class="headerlink" title="查看存储过程的状态"></a>查看存储过程的状态</h3><ul>
<li>格式：<code>show procedure status like pattern \G</code><ul>
<li><code>show procedure status like &quot;select%&quot;\G</code> : 查看<code>select</code>开头的存储过程状态</li>
<li><code>show procedure status \G</code> : 查看所有的存储过程状态</li>
</ul>
</li>
<li>查询的结果如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">*************************** 1. row ***************************</div><div class="line">                  Db: test   -- 数据库名称</div><div class="line">                Name: selectUserById     -- 存储过程的名字</div><div class="line">                Type: PROCEDURE  </div><div class="line">             Definer: root@localhost</div><div class="line">            Modified: 2018-06-25 22:25:44</div><div class="line">             Created: 2018-06-25 22:25:44</div><div class="line">       Security_type: DEFINER</div><div class="line">             Comment: </div><div class="line">character_set_client: utf8</div><div class="line">collation_connection: utf8_general_ci</div><div class="line">  Database Collation: utf8_general_ci</div><div class="line">1 row in set (0.01 sec)</div></pre></td></tr></table></figure>
<h3 id="查看存储过程的定义"><a href="#查看存储过程的定义" class="headerlink" title="查看存储过程的定义"></a>查看存储过程的定义</h3><ul>
<li>格式：<code>show create procedure  db.pro_name</code><ul>
<li><code>show create procedure test.selectUserById\G</code> : 查询数据库<code>test</code>中存储过程的定义</li>
</ul>
</li>
<li>返回的结果如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">*************************** 1. row ***************************</div><div class="line">           Procedure: selectUserById</div><div class="line">            sql_mode: ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</div><div class="line">    Create Procedure: CREATE DEFINER=`root`@`localhost` PROCEDURE `selectUserById`(IN uid int)</div><div class="line">begin</div><div class="line">select * from user where id=uid;</div><div class="line">end</div><div class="line">character_set_client: utf8</div><div class="line">collation_connection: utf8_general_ci</div><div class="line">  Database Collation: utf8_general_ci</div></pre></td></tr></table></figure>
<h3 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h3><ul>
<li>格式<code>drop procedure pro_name</code><ul>
<li><code>drop procedure selectUserById</code> : 删除当前数据库的<code>selectUserById</code>的存储过程</li>
<li><code>drop procedure test.selectUserById;</code>: 删除<code>test</code>数据库的<code>selectUserById</code>的存储过程</li>
</ul>
</li>
</ul>
<h2 id="游标cursor"><a href="#游标cursor" class="headerlink" title="游标cursor"></a>游标cursor</h2><ul>
<li>在面对大量的数据的时候，游标能够一行一行的读取数据</li>
</ul>
<h3 id="声明游标"><a href="#声明游标" class="headerlink" title="声明游标"></a>声明游标</h3><ul>
<li>格式：<code>declare cursor_name cursor for select_statement</code><ul>
<li><code>cursor_name</code> : 游标的变量名称</li>
<li><code>select_statement</code> ：表示<code>select</code>语句，用于返回一个结果集给游标</li>
</ul>
</li>
<li>比如： <code>declare users cursor for select name,age from user;</code></li>
</ul>
<h3 id="打开游标"><a href="#打开游标" class="headerlink" title="打开游标"></a>打开游标</h3><ul>
<li>格式：<code>open cursor_name;</code> <ul>
<li><code>open users</code></li>
</ul>
</li>
</ul>
<h3 id="使用游标获取一行数据"><a href="#使用游标获取一行数据" class="headerlink" title="使用游标获取一行数据"></a>使用游标获取一行数据</h3><ul>
<li>格式：<code>fetch cursor_name into var_name[,var_name,...]</code><ul>
<li><code>cursor_name</code>：表示游标的名称</li>
<li><code>var_name</code> ： 表示将<code>select</code>语句查询到的一行信息存入到该参数中，<strong><code>var_name</code>必须在声明游标之前定义好</strong></li>
</ul>
</li>
<li>比如： <code>fetch user into uname,uage</code></li>
</ul>
<h3 id="关闭游标"><a href="#关闭游标" class="headerlink" title="关闭游标"></a>关闭游标</h3><ul>
<li>格式：<code>close cursor_name</code></li>
</ul>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><ul>
<li>使用游标获取<code>user</code>表中的一行数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">    create procedure selectOneUser()</div><div class="line">        begin</div><div class="line">        	declare uname varchar(50);  -- 定义uname存储</div><div class="line">        	declare uage int;   -- 定义uage存储</div><div class="line">        	declare users cursor for select name,age from user; -- 声明游标</div><div class="line">        	open users;      -- 打开游标</div><div class="line">        	fetch users into uname,uage;  -- 获取一行数据到存储到uname和uage中</div><div class="line">        	select uname as name,uage as age;    -- 输出一行的结果</div><div class="line">        	close users;    -- 关闭游标</div><div class="line">        end</div><div class="line">        //</div><div class="line">delimiter ;</div><div class="line"></div><div class="line">call selectOneUser();  -- 调用存储过程，此时只是输出第一行的数据</div></pre></td></tr></table></figure>
<ul>
<li>使用循环获取所有的数据<ul>
<li><strong>这里使用循环获取，首先需要使用<code>select count(*)</code>获取总数</strong></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">    create procedure selectUsers()</div><div class="line">        begin</div><div class="line">        	declare uname varchar(50);  -- 定义uname存储</div><div class="line">        	declare uage int;   -- 定义uage存储</div><div class="line">        	declare total int default 0;  -- 定义count，这个用来统计总数</div><div class="line">        	declare i int default 1;  -- 用来循环</div><div class="line">        	declare users cursor for select name,age from user; -- 声明游标</div><div class="line">        	select count(*) from user into total;   -- 查询总数</div><div class="line">        	open users;      -- 打开游标</div><div class="line">        	-- 开始循环遍历</div><div class="line">    		my_loop:while i&lt;=total do</div><div class="line">                set i=i+1;  -- i++</div><div class="line">                fetch users into uname,uage;  -- 获取一行数据到存储到uname和uage中</div><div class="line">                select uname as name,uage as age;    -- 输出一行的结果</div><div class="line">    		end while my_loop;</div><div class="line">        	close users;    -- 关闭游标</div><div class="line">        end</div><div class="line">        //</div><div class="line">delimiter ;</div><div class="line"></div><div class="line">call selectUsers();  -- 调用存储过程，获取全部数据</div></pre></td></tr></table></figure>
<ul>
<li>使用<code>HANDLER</code>判断游标是否还有元素<ul>
<li><code>continue HANDLER for not found</code></li>
<li>当游标中没有值的时候就会指定返回的值</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">    create procedure selectUsers()</div><div class="line">        begin</div><div class="line">        	declare uname varchar(50);  -- 定义uname存储</div><div class="line">        	declare uage int;   -- 定义uage存储</div><div class="line">        	declare flag int default 1;  -- 创建结束游标的标志，默认值为1</div><div class="line">        	declare users cursor for select name,age from user; -- 声明游标</div><div class="line">        	declare continue HANDLER for not found set flag=0;  -- 指定游标结束时的返回值</div><div class="line">        	open users;      -- 打开游标</div><div class="line">        	my_loop:loop</div><div class="line">        		if flag=0  -- 这里使用=，否则报错</div><div class="line">        			 then leave my_loop;  -- 跳出循环</div><div class="line">        		end if;</div><div class="line">        		fetch users into uname,uage;  -- 获取一行数据到存储到uname和uage中</div><div class="line">				select uname as name,uage as age;    -- 输出一行的结果</div><div class="line">        	end loop my_loop;</div><div class="line">        	close users;    -- 关闭游标</div><div class="line">        end</div><div class="line">        //</div><div class="line">delimiter ;</div></pre></td></tr></table></figure>
<h2 id="存储过程和存储函数的区别"><a href="#存储过程和存储函数的区别" class="headerlink" title="存储过程和存储函数的区别"></a>存储过程和存储函数的区别</h2><ol>
<li>存储函数可以使用<code>return</code>返回一个返回值，但是存储过程不能有返回值，如果需要实现返回的功能，可以使用<code>OUT</code>参数实现返回</li>
<li>存储函数只能有输入参数，而且不能带in, 而存储过程可以有多个in,out,inout参数。</li>
<li>存储过程中的语句功能更强大，存储过程可以实现很复杂的业务逻辑，而函数有很多限制，如不能在函数中使用<code>insert</code>,<code>update</code>,<code>delete</code>,<code>create</code>等语句；<strong>存储函数只完成查询的工作，可接受输入参数并返回一个结果，也就是函数实现的功能针对性比较强。</strong></li>
<li><strong>存储过程可以调用存储函数。但函数不能调用存储过程。</strong></li>
<li>存储过程一般是作为一个独立的部分来执行(call调用)。而函数可以作为查询语句的一个部分来调用。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>存储过程中可以使用<code>call</code>调用其他的存储过程，但是不能使用<code>drop</code>语句删除其他的存储过程</li>
<li><strong>存储过程的参数不要和数据库表的字段相同，否则将出现无法预料的结果</strong></li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.cnblogs.com/mark-chan/p/5384139.html" target="_blank" rel="external">https://www.cnblogs.com/mark-chan/p/5384139.html</a></li>
</ul>
<p>​    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">delimiter //</div><div class="line">	create function selectUserById()</div><div class="line">	returns varchar(50) </div><div class="line">	begin </div><div class="line">	declare uname varchar(50);</div><div class="line">	select name into uname from user where id=2;</div><div class="line">	return uname;</div><div class="line">	end</div><div class="line">	//</div><div class="line">	delimiter ;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mysql存储过程和存储函数&quot;&gt;&lt;a href=&quot;#Mysql存储过程和存储函数&quot; class=&quot;headerlink&quot; title=&quot;Mysql存储过程和存储函数&quot;&gt;&lt;/a&gt;Mysql存储过程和存储函数&lt;/h1&gt;&lt;h2 id=&quot;存储过程的好处&quot;&gt;&lt;a href=
    
    </summary>
    
      <category term="数据库干货篇" scheme="http://chenjiabing666.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B2%E8%B4%A7%E7%AF%87/"/>
    
    
      <category term="SQL" scheme="http://chenjiabing666.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之Callable、Future、FutureTask</title>
    <link href="http://chenjiabing666.github.io/2018/06/26/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCallable%E3%80%81Future%E3%80%81FutureTask/"/>
    <id>http://chenjiabing666.github.io/2018/06/26/并发编程之Callable、Future、FutureTask/</id>
    <published>2018-06-26T14:55:49.000Z</published>
    <updated>2018-06-26T14:56:09.650Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程之Callable、Future、FutureTask"><a href="#并发编程之Callable、Future、FutureTask" class="headerlink" title="并发编程之Callable、Future、FutureTask"></a>并发编程之Callable、Future、FutureTask</h1><ul>
<li>　在前面的文章中我们讲述了创建线程的2种方式，一种是直接继承<code>Thread</code>，另外一种就是实现<code>Runnable</code>接口。</li>
<li>这2种方式都有一个缺陷就是：在执行完任务之后无法获取执行结果。</li>
<li>如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。</li>
<li>而自从Java 1.5开始，就提供了<code>Callable</code>和<code>Future</code>，通过它们可以在任务执行完毕之后得到任务执行结果。</li>
</ul>
<h2 id="Callable与Runnable"><a href="#Callable与Runnable" class="headerlink" title="Callable与Runnable"></a>Callable与Runnable</h2><ul>
<li>先说一下java.lang.Runnable吧，它是一个接口，在它里面只声明了一个run()方法</li>
<li><strong>由于run()方法返回值为void类型，所以在执行完任务之后无法返回任何结果。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>Callable</code>位于<code>java.util.concurrent</code>包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做call()<ul>
<li>可以看到，这是一个泛型接口，call()函数返回的类型就是传递进来的V类型。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Computes a result, or throws an exception if unable to do so.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> computed result</div><div class="line">     * <span class="doctag">@throws</span> Exception if unable to compute a result</div><div class="line">     */</div><div class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>那么怎么使用<code>Callable</code>呢？一般情况下是配合<code>ExecutorService</code>来使用的，在<code>ExecutorService</code>接口中声明了若干个<code>submit</code>方法的重载版本：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</div><div class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</div><div class="line">Future&lt;?&gt; submit(Runnable task);</div></pre></td></tr></table></figure>
<h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><ul>
<li>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</li>
<li>Future类位于java.util.concurrent包下，它是一个接口：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</div><div class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></div><div class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>cancel</code>方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。</li>
<li><code>isCancelled</code>方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</li>
<li><code>isDone</code>方法表示任务是否已经完成，若任务完成，则返回true；</li>
<li><code>get()</code>方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</li>
<li><code>get(long timeout, TimeUnit unit)</code>用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。</li>
</ul>
<h3 id="三种功能"><a href="#三种功能" class="headerlink" title="三种功能"></a>三种功能</h3><p>　　1）判断任务是否完成；</p>
<p>　　2）能够中断任务；</p>
<p>　　3）能够获取任务执行结果。</p>
<h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><ul>
<li>我们先来看一下FutureTask的实现：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>FutureTask类实现了RunnableFuture接口，我们看一下RunnableFuture接口的实现：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>可以看出RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</strong></li>
</ul>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><ul>
<li>事实上，FutureTask是Future接口的一个唯一实现类。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="使用Callable-Future获取执行结果"><a href="#使用Callable-Future获取执行结果" class="headerlink" title="使用Callable+Future获取执行结果"></a>使用Callable+Future获取执行结果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ExecutorService executor = Executors.newCachedThreadPool();</div><div class="line">        Task task = <span class="keyword">new</span> Task();</div><div class="line">        Future&lt;Integer&gt; result = executor.submit(task);</div><div class="line">        executor.shutdown();</div><div class="line">         </div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</div><div class="line">            e1.printStackTrace();</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        System.out.println(<span class="string">"主线程在执行任务"</span>);</div><div class="line">         </div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            System.out.println(<span class="string">"task运行结果"</span>+result.get());</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        System.out.println(<span class="string">"所有任务执行完毕"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"子线程在进行计算"</span>);</div><div class="line">        Thread.sleep(<span class="number">3000</span>);</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</div><div class="line">            sum += i;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用Callable-FutureTask获取执行结果"><a href="#使用Callable-FutureTask获取执行结果" class="headerlink" title="使用Callable+FutureTask获取执行结果"></a>使用Callable+FutureTask获取执行结果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//第一种方式</span></div><div class="line">        ExecutorService executor = Executors.newCachedThreadPool();</div><div class="line">        Task task = <span class="keyword">new</span> Task();</div><div class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(task);</div><div class="line">        executor.submit(futureTask);</div><div class="line">        executor.shutdown();</div><div class="line">         </div><div class="line">        <span class="comment">//第二种方式，注意这种方式和第一种方式效果是类似的，只不过一个使用的是ExecutorService，一个使用的是Thread</span></div><div class="line">        <span class="comment">/*Task task = new Task();</span></div><div class="line">        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task);</div><div class="line">        Thread thread = new Thread(futureTask);</div><div class="line">        thread.start();*/</div><div class="line">         </div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</div><div class="line">            e1.printStackTrace();</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        System.out.println(<span class="string">"主线程在执行任务"</span>);</div><div class="line">         </div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            System.out.println(<span class="string">"task运行结果"</span>+futureTask.get());</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        System.out.println(<span class="string">"所有任务执行完毕"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"子线程在进行计算"</span>);</div><div class="line">        Thread.sleep(<span class="number">3000</span>);</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</div><div class="line">            sum += i;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;并发编程之Callable、Future、FutureTask&quot;&gt;&lt;a href=&quot;#并发编程之Callable、Future、FutureTask&quot; class=&quot;headerlink&quot; title=&quot;并发编程之Callable、Future、FutureTas
    
    </summary>
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之线程池的使用</title>
    <link href="http://chenjiabing666.github.io/2018/06/26/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://chenjiabing666.github.io/2018/06/26/并发编程之线程池的使用/</id>
    <published>2018-06-26T14:54:59.000Z</published>
    <updated>2018-06-26T14:55:36.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程之线程池的使用"><a href="#并发编程之线程池的使用" class="headerlink" title="并发编程之线程池的使用"></a>并发编程之线程池的使用</h1><ul>
<li>转载自<a href="http://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="external">http://www.cnblogs.com/dolphin0520/p/3932921.html</a></li>
<li><a href="https://blog.csdn.net/wanghao_0206/article/details/76460877" target="_blank" rel="external">https://blog.csdn.net/wanghao_0206/article/details/76460877</a></li>
</ul>
<h2 id="Java中的ThreadPoolExecutor类"><a href="#Java中的ThreadPoolExecutor类" class="headerlink" title="Java中的ThreadPoolExecutor类"></a>Java中的ThreadPoolExecutor类</h2><blockquote>
<p><code>java.uitl.concurrent.ThreadPoolExecutor</code>类是线程池中最核心的一个类，因此如果要透彻地了解Java中的线程池，必须先了解这个类。下面我们来看一下ThreadPoolExecutor类的具体实现源码。</p>
<p>在ThreadPoolExecutor类中提供了四个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</div><div class="line">&gt;     .....</div><div class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></div><div class="line">&gt;             BlockingQueue&lt;Runnable&gt; workQueue);</div><div class="line">&gt;  </div><div class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></div><div class="line">&gt;             BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory);</div><div class="line">&gt;  </div><div class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></div><div class="line">&gt;             BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler);</div><div class="line">&gt;  </div><div class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></div><div class="line">&gt;         BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler);</div><div class="line">&gt;     ...</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>从上面的代码可以得知，<code>ThreadPoolExecutor</code>继承了<code>AbstractExecutorService</code>类，并提供了四个构造器，事实上，通过观察每个构造器的源码具体实现，发现前面三个构造器都是调用的第四个构造器进行的初始化工作。</strong></p>
<ul>
<li><code>corePoolSize</code>：核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到<strong>缓存队列</strong>当中；</li>
<li><code>maximumPoolSize</code>：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；</li>
<li><code>keepAliveTime</code>：<strong>表示线程没有任务执行时最多保持多久时间会终止</strong>。默认情况下，只有当线程池中的线程数大于<code>corePoolSize</code>时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；</li>
<li><code>unit</code>：参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; TimeUnit.DAYS;               <span class="comment">//天</span></div><div class="line">&gt; TimeUnit.HOURS;             <span class="comment">//小时</span></div><div class="line">&gt; TimeUnit.MINUTES;           <span class="comment">//分钟</span></div><div class="line">&gt; TimeUnit.SECONDS;           <span class="comment">//秒</span></div><div class="line">&gt; TimeUnit.MILLISECONDS;      <span class="comment">//毫秒</span></div><div class="line">&gt; TimeUnit.MICROSECONDS;      <span class="comment">//微妙</span></div><div class="line">&gt; TimeUnit.NANOSECONDS;       <span class="comment">//纳秒</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<ul>
<li><code>workQueue</code>：一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：<ul>
<li><code>SynchronousQueue</code></li>
<li><code>ArrayBlockingQueue</code></li>
<li><code>LinkedBlockingQueue</code></li>
</ul>
</li>
<li><code>threadFactory</code>：线程工厂，主要用来创建线程</li>
<li><code>handler</code>：表示当拒绝处理任务时的策略，有以下四种取值：<ul>
<li><code>ThreadPoolExecutor.AbortPolicy</code>:丢弃任务并抛出RejectedExecutionException异常。 </li>
<li><code>ThreadPoolExecutor.DiscardPolicy</code>：也是丢弃任务，但是不抛出异常</li>
<li><code>ThreadPoolExecutor.DiscardOldestPolicy</code> :丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li>
<li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：由调用线程处理该任务 </li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </div><div class="line">         <span class="comment">//指定各种参数和缓存队列</span></div><div class="line">         ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">200</span>, TimeUnit.MILLISECONDS,</div><div class="line">                 <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>));</div><div class="line">          </div><div class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">15</span>;i++)&#123;</div><div class="line">             MyTask myTask = <span class="keyword">new</span> MyTask(i);</div><div class="line">             executor.execute(myTask);   <span class="comment">//执行线程</span></div><div class="line">             System.out.println(<span class="string">"线程池中线程数目："</span>+executor.getPoolSize()+<span class="string">"，队列中等待执行的任务数目："</span>+</div><div class="line">             executor.getQueue().size()+<span class="string">"，已执行玩别的任务数目："</span>+executor.getCompletedTaskCount());</div><div class="line">         &#125;</div><div class="line">         executor.shutdown();   <span class="comment">//终止执行，等待缓存队列中的线程全部执行完成之后才会终止</span></div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//线程</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> taskNum;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.taskNum = num;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"正在执行task "</span>+taskNum);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.currentThread().sleep(<span class="number">4000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"task "</span>+taskNum+<span class="string">"执行完毕"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>从执行结果可以看出，当线程池中线程的数目大于5时，便将任务放入任务缓存队列里面，当任务缓存队列满了之后，便创建新的线程。如果上面程序中，将for循环中改成执行20个任务，就会抛出任务拒绝异常了。</li>
</ul>
<h2 id="使用工具类Executors"><a href="#使用工具类Executors" class="headerlink" title="使用工具类Executors"></a>使用工具类Executors</h2><ul>
<li>不过在java doc中，并不提倡我们直接使用<code>ThreadPoolExecutor</code>，而是使用Executors类中提供的几个静态方法来创建线程池</li>
<li>几个静态方法可以创建<code>ExecutorService</code>实例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Executors.newCachedThreadPool();        <span class="comment">//创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE</span></div><div class="line">Executors.newSingleThreadExecutor();   <span class="comment">//创建容量为1的缓冲池</span></div><div class="line">Executors.newFixedThreadPool(<span class="keyword">int</span>);    <span class="comment">//创建固定容量大小的缓冲池</span></div></pre></td></tr></table></figure>
<ul>
<li>源码如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</div><div class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</div><div class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</div><div class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</div><div class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</div><div class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>从它们的具体实现来看，它们实际上也是调用了ThreadPoolExecutor，只不过参数都已配置好</li>
<li><code>newFixedThreadPool</code>创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的<code>LinkedBlockingQueue</code>；</li>
<li><code>newSingleThreadExecutor</code>将corePoolSize和maximumPoolSize都设置为1，也使用的LinkedBlockingQueue；</li>
<li><code>newCachedThreadPool</code>将corePoolSize设置为0，将maximumPoolSize设置为<code>Integer.MAX_VALUE</code>，使用的<code>SynchronousQueue</code>，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。</li>
<li>实际中，如果Executors提供的三个静态方法能满足要求，就尽量使用它提供的三个方法，因为自己去手动配置<code>ThreadPoolExecutor</code>的参数有点麻烦，要根据实际任务的类型和数量来进行配置。</li>
<li>另外，如果<code>ThreadPoolExecutor</code>达不到要求，可以自己继承<code>ThreadPoolExecutor</code>类进行重写。</li>
</ul>
<h3 id="使用实例-1"><a href="#使用实例-1" class="headerlink" title="使用实例"></a>使用实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadFactory</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		MyThread thread=<span class="keyword">new</span> MyThread();  <span class="comment">//创建MyThread</span></div><div class="line">		<span class="comment">//创建固定大小的线程池</span></div><div class="line">		ExecutorService pService=Executors.newFixedThreadPool(<span class="number">10</span>);</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</div><div class="line">			pService.execute(<span class="keyword">new</span> Thread(thread));   <span class="comment">//在线程池中获取线程并且执行</span></div><div class="line">		&#125;</div><div class="line">		pService.shutdown();   <span class="comment">//执行完毕之后关闭</span></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">	<span class="keyword">private</span>  Integer count=<span class="number">0</span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">			System.out.println(<span class="string">"线程池开始使用"</span>);</div><div class="line">			System.out.println(<span class="string">"执行其他的操作"</span>);</div><div class="line">			System.out.println(count++);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a>AbstractExecutorService</h2><ul>
<li><code>AbstractExecutorService</code>是一个抽象类，它实现了<code>ExecutorService</code>接口。</li>
</ul>
<h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h2><ul>
<li><p>继承<code>Executor</code>接口</p>
</li>
<li><p>源码</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></div><div class="line">        <span class="keyword">throws</span> InterruptedException;</div><div class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</div><div class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</div><div class="line">    Future&lt;?&gt; submit(Runnable task);</div><div class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</div><div class="line">        <span class="keyword">throws</span> InterruptedException;</div><div class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</div><div class="line">                                  <span class="keyword">long</span> timeout, TimeUnit unit)</div><div class="line">        <span class="keyword">throws</span> InterruptedException;</div><div class="line"> </div><div class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></div><div class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException;</div><div class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></div><div class="line">                    <span class="keyword">long</span> timeout, TimeUnit unit)</div><div class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><ul>
<li>源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ThreadPoolExecutor、AbstractExecutorService、ExecutorService和Executor的关系"><a href="#ThreadPoolExecutor、AbstractExecutorService、ExecutorService和Executor的关系" class="headerlink" title="ThreadPoolExecutor、AbstractExecutorService、ExecutorService和Executor的关系"></a>ThreadPoolExecutor、AbstractExecutorService、ExecutorService和Executor的关系</h2><ul>
<li><code>Executor</code>是一个顶层接口，在它里面只声明了一个方法<code>execute(Runnable)</code>，返回值为void，参数为<code>Runnable</code>类型，从字面意思可以理解，就是用来执行传进去的任务的；</li>
<li>然后<code>ExecutorService</code>接口继承了<code>Executor</code>接口，并声明了一些方法：<code>submit</code>、<code>invokeAll</code>、<code>invokeAny</code>以及<code>shutDown</code>等；</li>
<li>抽象类<code>AbstractExecutorService</code>实现了<code>ExecutorService</code>接口，基本实现了<code>ExecutorService</code>中声明的所有方法；</li>
<li><p>然后<code>ThreadPoolExecutor</code>继承了类<code>AbstractExecutorService</code>。</p>
</li>
<li><p>在<code>ThreadPoolExecutor</code>类中有几个非常重要的方法：</p>
<ul>
<li><code>execute()</code>方法实际上是Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</li>
<li><code>submit()</code>方法是在ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，在ThreadPoolExecutor中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和execute()方法不同，它能够返回任务执行的结果，去看submit()方法的实现，会发现它实际上还是调用的execute()方法，只不过它利用了Future来获取任务执行结果（Future相关内容将在下一篇讲述）。</li>
<li><code>shutdown()</code>和<code>shutdownNow()</code>是用来关闭线程池的。</li>
</ul>
</li>
</ul>
<h2 id="深入剖析线程池实现原理"><a href="#深入剖析线程池实现原理" class="headerlink" title="深入剖析线程池实现原理"></a>深入剖析线程池实现原理</h2><h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><ul>
<li>在<code>ThreadPoolExecutor</code>中定义了一个<code>volatile</code>变量，另外定义了几个<code>static final</code>变量表示线程池的各个状态：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> runState;   </div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = <span class="number">0</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   = <span class="number">1</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       = <span class="number">2</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED = <span class="number">3</span>;</div></pre></td></tr></table></figure>
<ul>
<li><code>runState</code>表示当前线程池的状态，它是一个volatile变量用来保证线程之间的可见性；下面的几个static final变量表示runState可能的几个取值。</li>
<li>当创建线程池后，初始时，线程池处于<code>RUNNING</code>状态；</li>
<li>如果调用了<code>shutdown()</code>方法，则线程池处于<code>SHUTDOWN</code>状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；</li>
<li>如果调用了<code>shutdownNow()</code>方法，则线程池处于<code>STOP</code>状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；</li>
<li>当线程池处于<code>SHUTDOWN</code>或<code>STOP</code>状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为<code>TERMINATED</code>状态。</li>
</ul>
<h3 id="任务的执行"><a href="#任务的执行" class="headerlink" title="任务的执行"></a>任务的执行</h3><ul>
<li>在了解将任务提交给线程池到任务执行完毕整个过程之前，我们先来看一下ThreadPoolExecutor类中其他的一些比较重要成员变量：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;              <span class="comment">//任务缓存队列，用来存放等待执行的任务</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();   <span class="comment">//线程池的主要状态锁，对线程池状态（比如线程池大小</span></div><div class="line">                                                              <span class="comment">//、runState等）的改变都要使用这个锁</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();  <span class="comment">//用来存放工作集</span></div><div class="line"> </div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span>  keepAliveTime;    <span class="comment">//线程存货时间   </span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;   <span class="comment">//是否允许为核心线程设置存活时间</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span>   corePoolSize;     <span class="comment">//核心池的大小（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span>   maximumPoolSize;   <span class="comment">//线程池最大能容忍的线程数</span></div><div class="line"> </div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span>   poolSize;       <span class="comment">//线程池中当前的线程数</span></div><div class="line"> </div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler; <span class="comment">//任务拒绝策略</span></div><div class="line"> </div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;   <span class="comment">//线程工厂，用来创建线程</span></div><div class="line"> </div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;   <span class="comment">//用来记录线程池中曾经出现过的最大线程数</span></div><div class="line"> </div><div class="line"><span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;   <span class="comment">//用来记录已经执行完毕的任务个数</span></div></pre></td></tr></table></figure>
<blockquote>
<p>每个变量的作用都已经标明出来了，这里要重点解释一下corePoolSize、maximumPoolSize、largestPoolSize三个变量。</p>
<p>corePoolSize在很多地方被翻译成核心池大小，其实我的理解这个就是线程池的大小。举个简单的例子：</p>
<p>假如有一个工厂，工厂里面有10个工人，每个工人同时只能做一件任务。</p>
<p>因此只要当10个工人中有工人是空闲的，来了任务就分配给空闲的工人做；</p>
<p>当10个工人都有任务在做时，如果还来了任务，就把任务进行排队等待；</p>
<p>如果说新任务数目增长的速度远远大于工人做任务的速度，那么此时工厂主管可能会想补救措施，比如重新招4个临时工人进来；</p>
<p>然后就将任务也分配给这4个临时工人做；</p>
<p>如果说着14个工人做任务的速度还是不够，此时工厂主管可能就要考虑不再接收新的任务或者抛弃前面的一些任务了。</p>
<p>当这14个工人当中有人空闲时，而新任务增长的速度又比较缓慢，工厂主管可能就考虑辞掉4个临时工了，只保持原来的10个工人，毕竟请额外的工人是要花钱的。</p>
<p>这个例子中的corePoolSize就是10，而maximumPoolSize就是14（10+4）。</p>
<p>也就是说corePoolSize就是线程池大小，maximumPoolSize在我看来是线程池的一种补救措施，即任务量突然过大时的一种补救措施。</p>
<p>不过为了方便理解，在本文后面还是将corePoolSize翻译成核心池大小。</p>
<p>largestPoolSize只是一个用来起记录作用的变量，用来记录线程池中曾经有过的最大线程数目，跟线程池的容量没有任何关系。</p>
</blockquote>
<h3 id="线程池中的线程初始化"><a href="#线程池中的线程初始化" class="headerlink" title="线程池中的线程初始化"></a>线程池中的线程初始化</h3><ul>
<li>默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。</li>
<li><p>在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到：</p>
</li>
<li><p>prestartCoreThread()：初始化一个核心线程；</p>
</li>
<li>prestartAllCoreThreads()：初始化所有核心线程</li>
</ul>
<h3 id="任务缓存队列及排队策略"><a href="#任务缓存队列及排队策略" class="headerlink" title="任务缓存队列及排队策略"></a>任务缓存队列及排队策略</h3><ul>
<li>在前面我们多次提到了任务缓存队列，即workQueue，它用来存放等待执行的任务。</li>
<li><code>workQueue</code>的类型为<code>BlockingQueue&lt;Runnable&gt;</code>，通常可以取下面三种类型：<ul>
<li><code>ArrayBlockingQueue</code>：基于数组的先进先出队列，此队列创建时必须指定大小</li>
<li><code>LinkedBlockingQueue</code>：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为<code>Integer.MAX_VALUE</code>；</li>
<li><code>synchronousQueue</code>：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务</li>
</ul>
</li>
</ul>
<h3 id="任务拒绝策略"><a href="#任务拒绝策略" class="headerlink" title="任务拒绝策略"></a>任务拒绝策略</h3><ul>
<li>当线程池的任务缓存队列已满并且线程池中的线程数目达到<code>maximumPoolSize</code>，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</div><div class="line">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</div><div class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</div><div class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</div></pre></td></tr></table></figure>
<h3 id="线程池关闭"><a href="#线程池关闭" class="headerlink" title="线程池关闭"></a>线程池关闭</h3><ul>
<li><code>ThreadPoolExecutor</code>提供了两个方法，用于线程池的关闭，分别是<code>shutdown()</code>和<code>shutdownNow()</code>，其中：<ul>
<li><code>shutdown()</code>：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</li>
<li><code>shutdownNow()</code>：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</li>
</ul>
</li>
</ul>
<h3 id="线程池容量的动态调整"><a href="#线程池容量的动态调整" class="headerlink" title="线程池容量的动态调整"></a>线程池容量的动态调整</h3><ul>
<li><code>ThreadPoolExecutor</code>提供了动态调整线程池容量大小的方法：<code>setCorePoolSize()</code>和<code>setMaximumPoolSize()</code><ul>
<li><code>setCorePoolSize</code>：设置核心池大小</li>
<li><code>setMaximumPoolSize</code>：设置线程池最大能创建的线程数目大小</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;并发编程之线程池的使用&quot;&gt;&lt;a href=&quot;#并发编程之线程池的使用&quot; class=&quot;headerlink&quot; title=&quot;并发编程之线程池的使用&quot;&gt;&lt;/a&gt;并发编程之线程池的使用&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;转载自&lt;a href=&quot;http://www.cnblo
    
    </summary>
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型</title>
    <link href="http://chenjiabing666.github.io/2018/06/26/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://chenjiabing666.github.io/2018/06/26/Java内存模型/</id>
    <published>2018-06-26T14:54:04.000Z</published>
    <updated>2018-06-26T14:54:42.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><ul>
<li>Java内存模型规范了Java虚拟机与计算机内存是如何协同工作的。Java虚拟机是一个完整的计算机的一个模型，因此这个模型自然也包含一个内存模型——又称为Java内存模型。</li>
<li>如果你想设计表现良好的并发程序，理解Java内存模型是非常重要的。Java内存模型规定了如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。</li>
<li>原始的Java内存模型存在一些不足，因此Java内存模型在Java1.5时被重新修订。这个版本的Java内存模型在Java8中人在使用。</li>
</ul>
<h3 id="Java内存模型内部原理"><a href="#Java内存模型内部原理" class="headerlink" title="Java内存模型内部原理"></a>Java内存模型内部原理</h3><ul>
<li>Java内存模型把Java虚拟机内部划分为线程栈和堆。这张图演示了Java内存模型的逻辑视图。</li>
</ul>
<p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-1.png" alt="Java Memory Model"></p>
<ul>
<li>每一个运行在Java虚拟机里的线程都拥有自己的线程栈。这个线程栈包含了这个线程调用的方法当前执行点相关的信息。一个线程仅能访问自己的线程栈。一个线程创建的本地变量对其它线程不可见，仅自己可见。即使两个线程执行同样的代码，这两个线程任然在在自己的线程栈中的代码来创建本地变量。因此，每个线程拥有每个本地变量的独有版本。</li>
<li><strong>所有原始类型的本地变量都存放在线程栈上，因此对其它线程不可见。一个线程可能向另一个线程传递一个原始类型变量的拷贝，但是它不能共享这个原始类型变量自身。</strong></li>
<li><strong>堆上包含在Java程序中创建的所有对象，无论是哪一个对象创建的。这包括原始类型的对象版本。如果一个对象被创建然后赋值给一个局部变量，或者用来作为另一个对象的成员变量，这个对象任然是存放在堆上。</strong></li>
<li>下面这张图演示了调用栈和本地变量存放在线程栈上，对象存放在堆上。</li>
</ul>
<p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-2.png" alt="enter image description here"></p>
<ul>
<li><strong>一个本地变量可能是原始类型，在这种情况下，它总是“呆在”线程栈上。</strong></li>
<li><strong>一个本地变量也可能是指向一个对象的一个引用。在这种情况下，<code>引用</code>（这个本地变量）存放在线程栈上，但是对象本身存放在堆上。</strong><ul>
<li>线程栈中存放的是堆上对象的引用，我们可以通过线程栈中的引用访问到这个对象</li>
</ul>
</li>
<li><strong>一个对象可能包含方法，这些方法可能包含本地变量。这些本地变量任然存放在线程栈上，即使这些方法所属的对象存放在堆上。</strong><ul>
<li>放在堆上的对象可以有多个方法，如果这个方法中存在本地变量，那么这些本地变量都是存放在线程栈中的</li>
</ul>
</li>
<li><strong>一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。</strong></li>
<li><strong>静态成员变量跟随着类定义一起也存放在堆上。</strong><ul>
<li>一个堆上的对象中如果存在静态成员变量，那么这个静态成员变量也是存放在堆上</li>
</ul>
</li>
<li><strong>存放在堆上的对象可以被所有持有对这个对象引用的线程访问。当一个线程可以访问一个对象时，它也可以访问这个对象的成员变量。如果两个线程同时调用同一个对象上的同一个方法，它们将会都访问这个对象的成员变量，但是每一个线程都拥有这个本地变量的私有拷贝。</strong></li>
<li>下图演示了上面提到的点：</li>
</ul>
<p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-3.png" alt="enter image description here"></p>
<ul>
<li>两个线程拥有一些列的本地变量。其中一个本地变量（Local Variable 2）执行堆上的一个共享对象（Object 3）。这两个线程分别拥有同一个对象的不同引用。这些引用都是本地变量，因此存放在各自线程的线程栈上。这两个不同的引用指向堆上同一个对象。</li>
<li>注意，这个共享对象（Object 3）持有Object2和Object4一个引用作为其成员变量（如图中Object3指向Object2和Object4的箭头）。通过在Object3中这些成员变量引用，这两个线程就可以访问Object2和Object4。</li>
<li>这张图也展示了指向堆上两个不同对象的一个本地变量。在这种情况下，指向两个不同对象的引用不是同一个对象。理论上，两个线程都可以访问Object1和Object5，如果两个线程都拥有两个对象的引用。但是在上图中，每一个线程仅有一个引用指向两个对象其中之一。</li>
<li>因此，什么类型的Java代码会导致上面的内存图呢？如下所示：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> class MyRunnable implements <span class="title">Runnable</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        methodOne();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> localVariable1 = <span class="number">45</span>;</div><div class="line"></div><div class="line">        MySharedObject localVariable2 =</div><div class="line">            MySharedObject.sharedInstance;</div><div class="line"></div><div class="line">        <span class="comment">//... do more with local variables.</span></div><div class="line"></div><div class="line">        methodTwo();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodTwo</span><span class="params">()</span> </span>&#123;</div><div class="line">        Integer localVariable1 = <span class="keyword">new</span> Integer(<span class="number">99</span>);</div><div class="line"></div><div class="line">        <span class="comment">//... do more with local variable.</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySharedObject</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//static variable pointing to instance of MySharedObject</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MySharedObject sharedInstance =</div><div class="line">        <span class="keyword">new</span> MySharedObject();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//member variables pointing to two objects on the heap</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> Integer object2 = <span class="keyword">new</span> Integer(<span class="number">22</span>);</div><div class="line">    <span class="keyword">public</span> Integer object4 = <span class="keyword">new</span> Integer(<span class="number">44</span>);</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">long</span> member1 = <span class="number">12345</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">long</span> member1 = <span class="number">67890</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果两个线程同时执行<code>run()</code>方法，就会出现上图所示的情景。<code>run()</code>方法调用<code>methodOne()</code>方法，<code>methodOne()</code>调用<code>methodTwo()</code>方法。</li>
<li><code>methodOne()</code>声明了一个原始类型的本地变量和一个引用类型的本地变量。</li>
<li>每个线程执行<code>methodOne()</code>都会在它们对应的线程栈上创建<code>localVariable1</code>和<code>localVariable2</code>的私有拷贝。<code>localVariable1</code>变量彼此完全独立，仅“生活”在每个线程的线程栈上。一个线程看不到另一个线程对它的<code>localVariable1</code>私有拷贝做出的修改。</li>
<li>每个线程执行<code>methodOne()</code>时也将会创建它们各自的<code>localVariable2</code>拷贝。然而，两个<code>localVariable2</code>的不同拷贝都指向堆上的同一个对象。代码中通过一个静态变量设置<code>localVariable2</code>指向一个对象引用。仅存在一个静态变量的一份拷贝，这份拷贝存放在堆上。因此，<code>localVariable2</code>的两份拷贝都指向由<code>MySharedObject</code>指向的静态变量的同一个实例。<code>MySharedObject</code>实例也存放在堆上。它对应于上图中的Object3。</li>
<li>注意，<code>MySharedObject</code>类也包含两个成员变量。这些成员变量随着这个对象存放在堆上。这两个成员变量指向另外两个<code>Integer</code>对象。这些<code>Integer</code>对象对应于上图中的Object2和Object4.</li>
<li>注意，<code>methodTwo()</code>创建一个名为<code>localVariable</code>的本地变量。这个成员变量是一个指向一个<code>Integer</code>对象的对象引用。这个方法设置<code>localVariable1</code>引用指向一个新的<code>Integer</code>实例。在执行<code>methodTwo</code>方法时，<code>localVariable1</code>引用将会在每个线程中存放一份拷贝。这两个<code>Integer</code>对象实例化将会被存储堆上，但是每次执行这个方法时，这个方法都会创建一个新的<code>Integer</code>对象，两个线程执行这个方法将会创建两个不同的<code>Integer</code>实例。<code>methodTwo</code>方法创建的<code>Integer</code>对象对应于上图中的Object1和Object5。</li>
<li>还有一点，<code>MySharedObject</code>类中的两个<code>long</code>类型的成员变量是原始类型的。因为，这些变量是成员变量，所以它们任然随着该对象存放在堆上，仅有本地变量存放在线程栈上。</li>
</ul>
<h3 id="硬件内存架构"><a href="#硬件内存架构" class="headerlink" title="硬件内存架构"></a>硬件内存架构</h3><ul>
<li>现代硬件内存模型与Java内存模型有一些不同。理解内存模型架构以及Java内存模型如何与它协同工作也是非常重要的。这部分描述了通用的硬件内存架构，下面的部分将会描述Java内存是如何与它“联手”工作的。</li>
<li>下面是现代计算机硬件架构的简单图示：</li>
</ul>
<p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-4.png" alt="enter image description here"></p>
<ul>
<li>一个现代计算机通常由两个或者多个CPU。其中一些CPU还有多核。从这一点可以看出，在一个有两个或者多个CPU的现代计算机上同时运行多个线程是可能的。每个CPU在某一时刻运行一个线程是没有问题的。这意味着，如果你的Java程序是多线程的，在你的Java程序中每个CPU上一个线程可能同时（并发）执行。</li>
<li>每个CPU都包含一系列的寄存器，它们是CPU内内存的基础。CPU在寄存器上执行操作的速度远大于在主存上执行的速度。这是因为CPU访问寄存器的速度远大于主存。</li>
<li>每个CPU可能还有一个CPU缓存层。实际上，绝大多数的现代CPU都有一定大小的缓存层。CPU访问缓存层的速度快于访问主存的速度，但通常比访问内部寄存器的速度还要慢一点。一些CPU还有多层缓存，但这些对理解Java内存模型如何和内存交互不是那么重要。只要知道CPU中可以有一个缓存层就可以了。</li>
<li>一个计算机还包含一个主存。所有的CPU都可以访问主存。主存通常比CPU中的缓存大得多。</li>
<li>通常情况下，当一个CPU需要读取主存时，它会将主存的部分读到CPU缓存中。它甚至可能将缓存中的部分内容读到它的内部寄存器中，然后在寄存器中执行操作。当CPU需要将结果写回到主存中去时，它会将内部寄存器的值刷新到缓存中，然后在某个时间点将值刷新回主存。</li>
<li>当CPU需要在缓存层存放一些东西的时候，存放在缓存中的内容通常会被刷新回主存。CPU缓存可以在某一时刻将数据局部写到它的内存中，和在某一时刻局部刷新它的内存。它不会再某一时刻读/写整个缓存。通常，在一个被称作“cache lines”的更小的内存块中缓存被更新。一个或者多个缓存行可能被读到缓存，一个或者多个缓存行可能再被刷新回主存。</li>
</ul>
<h3 id="Java内存模型和硬件内存架构之间的桥接"><a href="#Java内存模型和硬件内存架构之间的桥接" class="headerlink" title="Java内存模型和硬件内存架构之间的桥接"></a>Java内存模型和硬件内存架构之间的桥接</h3><ul>
<li>上面已经提到，Java内存模型与硬件内存架构之间存在差异。硬件内存架构没有区分线程栈和堆。对于硬件，<strong>所有的线程栈和堆都分布在主内中</strong>。部分线程栈和堆可能有时候会出现在CPU缓存中和CPU内部的寄存器中。如下图所示：</li>
</ul>
<p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-5.png" alt="enter image description here"></p>
<ul>
<li>当对象和变量被存放在计算机中各种不同的内存区域中时，就可能会出现一些具体的问题。主要包括如下两个方面：<ul>
<li>线程对共享变量修改的可见性</li>
<li>当读，写和检查共享变量时出现race conditions</li>
</ul>
</li>
<li>下面我们专门来解释以下这两个问题。</li>
</ul>
<h4 id="共享对象可见性"><a href="#共享对象可见性" class="headerlink" title="共享对象可见性"></a>共享对象可见性</h4><ul>
<li>如果两个或者更多的线程在没有正确的使用<code>volatile</code>声明或者同步的情况下共享一个对象，一个线程更新这个共享对象可能对其它线程来说是不接见的。</li>
<li>想象一下，共享对象被初始化在主存中。跑在CPU上的一个线程将这个共享对象读到CPU缓存中。然后修改了这个对象。只要CPU缓存没有被刷新会主存，对象修改后的版本对跑在其它CPU上的线程都是不可见的。这种方式可能导致每个线程拥有这个共享对象的私有拷贝，每个拷贝停留在不同的CPU缓存中。</li>
<li>下图示意了这种情形。跑在左边CPU的线程拷贝这个共享对象到它的CPU缓存中，然后将count变量的值修改为2。这个修改对跑在右边CPU上的其它线程是不可见的，因为修改后的count的值还没有被刷新回主存中去。</li>
</ul>
<p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-6.png" alt="enter image description here"></p>
<ul>
<li>解决这个问题你可以使用Java中的<code>volatile</code>关键字。<code>volatile</code>关键字可以保证直接从主存中读取一个变量，如果这个变量被修改后，总是会被写回到主存中去。</li>
</ul>
<h4 id="Race-Conditions"><a href="#Race-Conditions" class="headerlink" title="Race Conditions"></a>Race Conditions</h4><ul>
<li>如果两个或者更多的线程共享一个对象，多个线程在这个共享对象上更新变量，就有可能发生<a href="http://tutorials.jenkov.com/java-concurrency/race-conditions-and-critical-sections.html" target="_blank" rel="external">race conditions</a>。</li>
<li>想象一下，如果线程A读一个共享对象的变量count到它的CPU缓存中。再想象一下，线程B也做了同样的事情，但是往一个不同的CPU缓存中。现在线程A将<code>count</code>加1，线程B也做了同样的事情。现在<code>count</code>已经被增在了两个，每个CPU缓存中一次。</li>
<li>如果这些增加操作被顺序的执行，变量<code>count</code>应该被增加两次，然后原值+2被写回到主存中去。</li>
<li>然而，两次增加都是在没有适当的同步下并发执行的。无论是线程A还是线程B将<code>count</code>修改后的版本写回到主存中取，修改后的值仅会被原值大1，尽管增加了两次。</li>
<li>下图演示了上面描述的情况：</li>
</ul>
<p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-7.png" alt="enter image description here"></p>
<ul>
<li>解决这个问题可以使用<a href="http://tutorials.jenkov.com/java-concurrency/synchronized.html" target="_blank" rel="external">Java同步块</a>。一个同步块可以保证在同一时刻仅有一个线程可以进入代码的临界区。同步块还可以保证代码块中所有被访问的变量将会从主存中读入，当线程退出同步代码块时，所有被更新的变量都会被刷新回主存中去，不管这个变量是否被声明为volatile。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java内存模型&quot;&gt;&lt;a href=&quot;#Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型&quot;&gt;&lt;/a&gt;Java内存模型&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Java内存模型规范了Java虚拟机与计算机内存是如何协同工作的。Java虚拟机
    
    </summary>
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之线程管理</title>
    <link href="http://chenjiabing666.github.io/2018/06/26/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://chenjiabing666.github.io/2018/06/26/并发编程之线程管理/</id>
    <published>2018-06-26T14:53:22.000Z</published>
    <updated>2018-06-26T14:53:47.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程之线程管理"><a href="#并发编程之线程管理" class="headerlink" title="并发编程之线程管理"></a>并发编程之线程管理</h1><h2 id="线程的未捕获异常与监控"><a href="#线程的未捕获异常与监控" class="headerlink" title="线程的未捕获异常与监控"></a>线程的未捕获异常与监控</h2><ul>
<li>如果线程的<code>run</code>方法抛出异常未被铺货（Uncaught Exception），那么随着run方法的退出，相应的线程也会提前终止。对于线程的这种异常终止，我们如何得知并做出可能的补救动作，例如重新创建并启动一个替代线程。</li>
<li>Jdk中使用<code>UncaughtExceptionHandler</code>接口实现了对线程的异常信息的监控和处理<ul>
<li>其中有一个<code>uncaughtException(Thread a, Throwable e)</code>方法，在这里我们可以将线程抛出的异常信息记录到日志中，或者开启一个替代线程继续提供服务</li>
</ul>
</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</div><div class="line"> </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    ErrHandler handle = <span class="keyword">null</span>;</div><div class="line">    ThreadA a = <span class="keyword">null</span>;</div><div class="line">    a = <span class="keyword">new</span> ThreadA();   <span class="comment">//创建线程对象</span></div><div class="line">    handle = <span class="keyword">new</span> ErrHandler();   <span class="comment">//创建UncaughtExceptionHandler</span></div><div class="line">    a.setUncaughtExceptionHandler((UncaughtExceptionHandler) handle);</div><div class="line">    a.start();   <span class="comment">//启动</span></div><div class="line"> </div><div class="line">  &#125;</div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义的一个UncaughtExceptionHandler</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrHandler</span> <span class="keyword">implements</span> <span class="title">UncaughtExceptionHandler</span> </span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 这里可以做任何针对异常的处理,比如记录日志等等</div><div class="line">   * <span class="doctag">@param</span> a : 抛出异常的线程对象</div><div class="line">   * <span class="doctag">@param</span> e : 抛出的异常信息，可以获取异常信息</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread a, Throwable e)</span> </span>&#123;</div><div class="line">	  <span class="comment">//做一些日志管理</span></div><div class="line">    System.out.println(<span class="string">"This is:"</span> + a.getName() + <span class="string">",Message:"</span></div><div class="line">        + e.getMessage());</div><div class="line">    <span class="comment">//开启一个另外的线程提供服务</span></div><div class="line">    System.out.println(<span class="string">"现在执行另外一个替代线程提供服务......"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/**</span></div><div class="line"> * 拥有UncaughtExceptionHandler的线程</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">double</span> i = <span class="number">12</span> / <span class="number">0</span>;<span class="comment">// 抛出异常的地方</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a>线程工厂</h2><ul>
<li><a href="http://ifeve.com/thread-management-13/" target="_blank" rel="external">http://ifeve.com/thread-management-13/</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;并发编程之线程管理&quot;&gt;&lt;a href=&quot;#并发编程之线程管理&quot; class=&quot;headerlink&quot; title=&quot;并发编程之线程管理&quot;&gt;&lt;/a&gt;并发编程之线程管理&lt;/h1&gt;&lt;h2 id=&quot;线程的未捕获异常与监控&quot;&gt;&lt;a href=&quot;#线程的未捕获异常与监控&quot; c
    
    </summary>
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之信号量</title>
    <link href="http://chenjiabing666.github.io/2018/06/26/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    <id>http://chenjiabing666.github.io/2018/06/26/并发编程之信号量/</id>
    <published>2018-06-26T14:52:41.000Z</published>
    <updated>2018-06-26T14:53:03.266Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程之信号量"><a href="#并发编程之信号量" class="headerlink" title="并发编程之信号量"></a>并发编程之信号量</h1><h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p>1、Semaphore可以控同时访问的线程个数</p>
<p>2、Semaphore类位于java.util.concurrent包下，它提供了2个构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//参数permits表示许可数目，即同时可以允许多少线程进行访问</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;         </div><div class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</div><div class="line">&#125;</div><div class="line"><span class="comment">//这个多了一个参数fair表示是否是公平的，即等待时间越久的越先获取许可</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;    </div><div class="line">    sync = (fair)? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3、重要方法，acquire()、release()方法：</p>
<ul>
<li>acquire()用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可</li>
<li>release()用来释放许可。注意，在释放许可之前，必须先获获得许可</li>
<li>这4个方法都会被阻塞</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  &#125;     <span class="comment">//获取一个许可</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;    <span class="comment">//获取permits个许可</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123; &#125;          <span class="comment">//释放一个许可</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123; &#125;    <span class="comment">//释放permits个许可</span></div></pre></td></tr></table></figure>
<ul>
<li>不阻塞的方法如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回false</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span> </span>&#123; &#125;;    </div><div class="line"><span class="comment">//尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;  </div><div class="line"><span class="comment">//尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回false</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123; &#125;; </div><div class="line"><span class="comment">//尝试获取permits个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;</div></pre></td></tr></table></figure>
<ul>
<li>通过availablePermits()方法得到可用的许可数目</li>
</ul>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><ul>
<li>我们知道读锁可以允许多个线程同时进行读取，我们可以使用信号量来限制线程个数，如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSemaphore</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Semaphore semaphore=<span class="keyword">new</span> Semaphore(<span class="number">5</span>,<span class="keyword">true</span>);  <span class="comment">//创建5个信号量同时用与读文件</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantReadWriteLock rwLock= <span class="keyword">new</span> ReentrantReadWriteLock();</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Lock rLock=rwLock.readLock();  <span class="comment">//获取读锁</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">//执行10个线程，通过信号量控制，只能5个线程5个线程的执行</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">			MyThread thread=<span class="keyword">new</span> MyThread();</div><div class="line">			thread.setName(<span class="string">"线程"</span>+(i+<span class="number">1</span>));</div><div class="line">			thread.start();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">			reader();</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//读方法</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</div><div class="line">			rLock.lock();  <span class="comment">//获取读锁</span></div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				semaphore.acquire();  <span class="comment">//获取信号量，信号量-1，如果没有成功获取，那么阻塞</span></div><div class="line">				System.out.println(<span class="keyword">this</span>.getName()+<span class="string">"正在读文件"</span>);</div><div class="line">				Thread.sleep(<span class="number">1000</span>);</div><div class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;<span class="keyword">finally</span>&#123;</div><div class="line">				semaphore.release();  <span class="comment">//释放信号量</span></div><div class="line">				rLock.unlock();  <span class="comment">//释放锁</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;并发编程之信号量&quot;&gt;&lt;a href=&quot;#并发编程之信号量&quot; class=&quot;headerlink&quot; title=&quot;并发编程之信号量&quot;&gt;&lt;/a&gt;并发编程之信号量&lt;/h1&gt;&lt;h2 id=&quot;详解&quot;&gt;&lt;a href=&quot;#详解&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之阻塞队列</title>
    <link href="http://chenjiabing666.github.io/2018/06/26/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>http://chenjiabing666.github.io/2018/06/26/并发编程之阻塞队列/</id>
    <published>2018-06-26T14:51:59.000Z</published>
    <updated>2018-06-26T14:52:13.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程之阻塞队列"><a href="#并发编程之阻塞队列" class="headerlink" title="并发编程之阻塞队列"></a>并发编程之阻塞队列</h1><h2 id="1-什么是阻塞队列"><a href="#1-什么是阻塞队列" class="headerlink" title="1. 什么是阻塞队列"></a>1. 什么是阻塞队列</h2><p>阻塞队列（BlockingQueue）是 Java 5 并发新特性中的内容，阻塞队列的接口是 java.util.concurrent.BlockingQueue，它提供了两个附加操作：当队列中为空时，从队列中获取元素的操作将被阻塞；当队列满时，向队列中添加元素的操作将被阻塞。</p>
<p>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器。</p>
<p>阻塞队列提供了四种操作方法：</p>
<p><img src="https://images2015.cnblogs.com/blog/658141/201705/658141-20170519005431775-619484268.png" alt="img"></p>
<ul>
<li>抛出异常：当队列满时，再向队列中插入元素，则会抛出IllegalStateException异常。当队列空时，再向队列中获取元素，则会抛出NoSuchElementException异常。</li>
<li>返回特殊值：当队列满时，向队列中添加元素，则返回false，否则返回true。当队列为空时，向队列中获取元素，则返回null，否则返回元素。</li>
<li>一直阻塞：当阻塞队列满时，如果生产者向队列中插入元素，则队列会一直阻塞当前线程，直到队列可用或响应中断退出。当阻塞队列为空时，如果消费者线程向阻塞队列中获取数据，则队列会一直阻塞当前线程，直到队列空闲或响应中断退出。</li>
<li>超时退出：当队列满时，如果生产线程向队列中添加元素，则队列会阻塞生产线程一段时间，超过指定的时间则退出返回false。当队列为空时，消费线程从队列中移除元素，则队列会阻塞一段时间，如果超过指定时间退出返回null。</li>
</ul>
<h2 id="2-Java中的阻塞队列"><a href="#2-Java中的阻塞队列" class="headerlink" title="2. Java中的阻塞队列"></a>2. Java中的阻塞队列</h2><p>JDK7提供了7个阻塞队列。分别是</p>
<p><img src="https://images2015.cnblogs.com/blog/658141/201705/658141-20170519005458666-1469668426.png" alt="img"></p>
<p>下面分别简单介绍一下：</p>
<ol>
<li><strong>ArrayBlockingQueue</strong>：是一个用数组实现的<strong>有界阻塞队列</strong>，此队列按照先进先出（FIFO）的原则对元素进行排序。支持公平锁和非公平锁。【注：每一个线程在获取锁的时候可能都会排队等待，如果在等待时间上，先获取锁的线程的请求一定先被满足，那么这个锁就是公平的。反之，这个锁就是不公平的。公平的获取锁，也就是当前等待时间最长的线程先获取锁】</li>
<li><strong>LinkedBlockingQueue</strong>：一个由链表结构组成的有界队列，此队列的长度为<code>Integer.MAX_VALUE</code>。此队列按照先进先出的顺序进行排序。<strong>既可以实现无界队列也可以实现无界队列</strong></li>
<li><strong>PriorityBlockingQueue：</strong> 一个支持线程优先级排序的无界队列，默认自然序进行排序，也可以自定义实现compareTo()方法来指定元素排序规则，不能保证同优先级元素的顺序。</li>
<li><strong>DelayQueue：</strong> 一个实现PriorityBlockingQueue实现延迟获取的无界队列，在创建元素时，可以指定多久才能从队列中获取当前元素。只有延时期满后才能从队列中获取元素。（DelayQueue可以运用在以下应用场景：1.缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。2.定时任务调度。使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，从比如TimerQueue就是使用DelayQueue实现的。）</li>
<li><strong>SynchronousQueue：</strong> 一个不存储元素的阻塞队列，每一个put操作必须等待take操作，否则不能添加元素。支持公平锁和非公平锁。SynchronousQueue的一个使用场景是在线程池里。Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。</li>
<li><strong>LinkedTransferQueue：</strong> 一个由链表结构组成的无界阻塞队列，相当于其它队列，LinkedTransferQueue队列多了transfer和tryTransfer方法。</li>
<li><strong>LinkedBlockingDeque：</strong> 一个由链表结构组成的双向阻塞队列。队列头部和尾部都可以添加和移除元素，多线程并发时，可以将锁的竞争最多降到一半。</li>
</ol>
<p>Java中线程安全的内置队列还有两个：ConcurrentLinkedQueue和LinkedTransferQueue，它们使用了CAS这种无锁的方式来实现了线程安全的队列。无锁的方式性能好，但是队列是无界的，用在生产系统中，生产者生产速度过快，可能导致内存溢出。有界的阻塞队列ArrayBlockingQueue和LinkedBlockingQueue，为了减少Java的垃圾回收对系统性能的影响，会尽量选择array/heap格式的数据结构。这样的话就只剩下ArrayBlockingQueue。（先埋个坑在这儿，近来接触到了disruptor，感觉妙不可言。<a href="https://github.com/LMAX-Exchange/disruptor" target="_blank" rel="external">disruptor</a>）</p>
<h2 id="3-阻塞队列的实现原理"><a href="#3-阻塞队列的实现原理" class="headerlink" title="3. 阻塞队列的实现原理"></a>3. 阻塞队列的实现原理</h2><p>这里分析下ArrayBlockingQueue的实现原理。</p>
<p><strong>构造方法</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ArrayBlockingQueue(<span class="keyword">int</span> capacity);</div><div class="line">ArrayBlockingQueue(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair);</div><div class="line">ArrayBlockingQueue(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair, Collection&lt;? extends E&gt; c)</div></pre></td></tr></table></figure>
<p>ArrayBlockingQueue提供了三种构造方法，参数含义如下：</p>
<ul>
<li>capacity：容量，即队列大小。</li>
<li>fair：是否公平锁。</li>
<li>c：队列初始化元素，顺序按照Collection遍历顺序。</li>
</ul>
<p><strong>插入元素</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    checkNotNull(e);</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> (count == items.length)</div><div class="line">            notFull.await();</div><div class="line">        enqueue(e);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从源码可以看出，生产者首先获得锁lock，然后判断队列是否已经满了，如果满了，则等待，直到被唤醒，然后调用enqueue插入元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></div><div class="line">    <span class="comment">// assert items[putIndex] == null;</span></div><div class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</div><div class="line">    items[putIndex] = x;</div><div class="line">    <span class="keyword">if</span> (++putIndex == items.length)</div><div class="line">        putIndex = <span class="number">0</span>;</div><div class="line">    count++;</div><div class="line">    notEmpty.signal();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上是enqueue的实现，实现的操作是插入元素到一个环形数组，然后唤醒notEmpty上阻塞的线程。</p>
<p><strong>获取元素</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</div><div class="line">            notEmpty.await();</div><div class="line">        <span class="keyword">return</span> dequeue();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从源码可以看出，消费者首先获得锁，然后判断队列是否为空，为空，则等待，直到被唤醒，然后调用dequeue获取元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></div><div class="line">    <span class="comment">// assert items[takeIndex] != null;</span></div><div class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    E x = (E) items[takeIndex];</div><div class="line">    items[takeIndex] = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</div><div class="line">        takeIndex = <span class="number">0</span>;</div><div class="line">    count--;</div><div class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</div><div class="line">        itrs.elementDequeued();</div><div class="line">    notFull.signal();</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上是dequeue的实现，获取环形数组当前takeIndex的元素，并及时将当前元素置为null，设置下一次takeIndex的值takeIndex++，然后唤醒notFull上阻塞的线程。</p>
<p>还有其他方法<code>offer(E e)</code>、<code>poll()</code>、<code>add(E e)</code>、<code>remove()</code>、 <code>offer(E e, long timeout, TimeUnit unit)</code>等的实现，因为常用take和put，这些方法就不一一赘述了。</p>
<h2 id="4-阻塞队列的基本使用"><a href="#4-阻塞队列的基本使用" class="headerlink" title="4. 阻塞队列的基本使用"></a>4. 阻塞队列的基本使用</h2><p>使用阻塞队列实现生产者-消费者模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by noly on 2017/5/19.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ArrayBlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">10</span>);</div><div class="line"></div><div class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(queue);</div><div class="line">        Producer producer = <span class="keyword">new</span> Producer(queue);</div><div class="line"></div><div class="line">        producer.start();</div><div class="line">        consumer.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ArrayBlockingQueue&lt;Integer&gt; queue;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(ArrayBlockingQueue&lt;Integer&gt; queue)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.queue = queue;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Integer i = queue.take();</div><div class="line">                System.out.println(<span class="string">"消费者从队列取出元素:"</span> + i);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ArrayBlockingQueue&lt;Integer&gt; queue;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(ArrayBlockingQueue&lt;Integer&gt; queue)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.queue = queue;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                queue.put(i);</div><div class="line">                System.out.println(<span class="string">"生产者向队列插入元素:"</span> + i);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果不使用阻塞队列，使用Object.wait()和Object.notify()、非阻塞队列实现生产者-消费者模式，考虑线程间的通讯，会非常麻烦。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;并发编程之阻塞队列&quot;&gt;&lt;a href=&quot;#并发编程之阻塞队列&quot; class=&quot;headerlink&quot; title=&quot;并发编程之阻塞队列&quot;&gt;&lt;/a&gt;并发编程之阻塞队列&lt;/h1&gt;&lt;h2 id=&quot;1-什么是阻塞队列&quot;&gt;&lt;a href=&quot;#1-什么是阻塞队列&quot; class
    
    </summary>
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之死锁</title>
    <link href="http://chenjiabing666.github.io/2018/06/26/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%AD%BB%E9%94%81/"/>
    <id>http://chenjiabing666.github.io/2018/06/26/并发编程之死锁/</id>
    <published>2018-06-26T14:50:58.000Z</published>
    <updated>2018-06-26T14:51:22.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程之死锁"><a href="#并发编程之死锁" class="headerlink" title="并发编程之死锁"></a>并发编程之死锁</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</li>
</ul>
<h2 id="产生的条件"><a href="#产生的条件" class="headerlink" title="产生的条件"></a>产生的条件</h2><ol>
<li><code>互斥条件</code>：所谓互斥就是线程在某一时间内独占资源。<ol>
<li>每一次的资源只能被一个线程使用</li>
</ol>
</li>
<li><code>请求与保持条件</code>：一个线程因请求资源而阻塞时，对已获得的资源保持不放。 <ol>
<li>一个线程在获取资源的时候，此时另外一个线程请求资源的时候保持不放</li>
</ol>
</li>
<li><code>不剥夺条件</code>:线程已获得资源，在末使用完之前，不能强行剥夺。<ol>
<li>资源只能被持有者线程主动释放，不能被强行剥夺</li>
</ol>
</li>
<li><code>循环等待条件</code>:若干线程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li><strong>我们可以把锁看做一个资源，这个资源正好符合<code>互斥条件</code>，<code>不剥夺条件</code>的要求。那么可能产生死锁的代码特征就是在持有一个锁的情况下去申请另外一个锁，这个通常就是意味着嵌套</strong></li>
<li>一个线程在已经持有一个锁的情况下再次申请这个锁（比如，一个类的同步方法调用该类的另外一个同步方法）并不会导致死锁，这是因为Java中的锁（包括内部锁<code>synchronized</code>和显示锁<code>Lock</code>）都是可重入的（<code>Reentrant</code>），这种情况下线程再次申请这个锁是可以成功的。<strong>因此我们必须使用不同对象的锁</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.demo.test;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 一个简单的死锁类</div><div class="line"> * t1先运行，这个时候flag==true,先锁定obj1,然后睡眠1秒钟</div><div class="line"> * 而t1在睡眠的时候，另一个线程t2启动，flag==false,先锁定obj2,然后也睡眠1秒钟</div><div class="line"> * t1睡眠结束后需要锁定obj2才能继续执行，而此时obj2已被t2锁定</div><div class="line"> * t2睡眠结束后需要锁定obj1才能继续执行，而此时obj1已被t1锁定</div><div class="line"> * t1、t2相互等待，都需要得到对方锁定的资源才能继续执行，从而死锁。 </div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object obj1 = <span class="keyword">new</span> Object();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object obj2 = <span class="keyword">new</span> Object();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeadLock</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.flag = flag;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"运行"</span>);</div><div class="line">        </div><div class="line">        <span class="keyword">if</span>(flag)&#123;</div><div class="line">            <span class="keyword">synchronized</span>(obj1)&#123;</div><div class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"已经锁住obj1"</span>);</div><div class="line">                <span class="keyword">try</span> &#123;  </div><div class="line">                    Thread.sleep(<span class="number">1000</span>);  </div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                    e.printStackTrace();  </div><div class="line">                &#125;  </div><div class="line">                <span class="keyword">synchronized</span>(obj2)&#123;</div><div class="line">                    <span class="comment">// 执行不到这里</span></div><div class="line">                    System.out.println(<span class="string">"1秒钟后，"</span>+Thread.currentThread().getName()</div><div class="line">                                + <span class="string">"锁住obj2"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">synchronized</span>(obj2)&#123;</div><div class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"已经锁住obj2"</span>);</div><div class="line">                <span class="keyword">try</span> &#123;  </div><div class="line">                    Thread.sleep(<span class="number">1000</span>);  </div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                    e.printStackTrace();  </div><div class="line">                &#125;  </div><div class="line">                <span class="keyword">synchronized</span>(obj1)&#123;</div><div class="line">                    <span class="comment">// 执行不到这里</span></div><div class="line">                    System.out.println(<span class="string">"1秒钟后，"</span>+Thread.currentThread().getName()</div><div class="line">                                + <span class="string">"锁住obj1"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><ol>
<li>锁排序法，相关线程使用全局统一的顺序申请锁</li>
<li>加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）<ol>
<li>比如使用<code>tryLock(timeout)</code> : 尝试获取锁，如果获取不到不会持续等待</li>
</ol>
</li>
<li>死锁检测</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、让程序每次至多只能获得一个锁。当然，在多线程环境下，这种情况通常并不现实。</p>
<p>2、设计时考虑清楚锁的顺序，尽量减少嵌在的加锁交互数量。</p>
<p>3、既然死锁的产生是两个线程无限等待对方持有的锁，那么只要等待时间有个上限不就好了。当然synchronized不具备这个功能，但是我们可以使用Lock类中的tryLock方法去尝试获取锁，这个方法可以指定一个超时时限，在等待超过该时限之后便会返回一个失败信息。</p>
<h2 id="参看文章"><a href="#参看文章" class="headerlink" title="参看文章"></a>参看文章</h2><ul>
<li><a href="http://www.cnblogs.com/xiaoxi/p/8311034.html" target="_blank" rel="external">http://www.cnblogs.com/xiaoxi/p/8311034.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;并发编程之死锁&quot;&gt;&lt;a href=&quot;#并发编程之死锁&quot; class=&quot;headerlink&quot; title=&quot;并发编程之死锁&quot;&gt;&lt;/a&gt;并发编程之死锁&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定
    
    </summary>
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之线程协作</title>
    <link href="http://chenjiabing666.github.io/2018/06/26/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C/"/>
    <id>http://chenjiabing666.github.io/2018/06/26/并发编程之线程协作/</id>
    <published>2018-06-26T14:50:23.000Z</published>
    <updated>2018-06-26T14:50:40.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程之线程协作"><a href="#并发编程之线程协作" class="headerlink" title="并发编程之线程协作"></a>并发编程之线程协作</h1><h2 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait / notify / notifyAll"></a>wait / notify / notifyAll</h2><ul>
<li><code>Object.wait()/Object.notify()/Object.notifyAll()</code>可用于实现等待和通知。</li>
<li><p><code>wait()</code>方法可以使其执行的线程被暂停，该方法用来实现等待。</p>
<ul>
<li>进入阻塞状态(Block)</li>
<li><strong>只有在持有一个对象的锁的时候才可以调用<code>wait()</code>方法，因此<code>Object.wait()</code>总是放在相应对象所领导的临界区中，必须和<code>synchronized</code>关键字进行使用</strong></li>
<li><strong>在执行wait方法的同时也会释放同步锁，从而线程进入阻塞状态</strong></li>
</ul>
</li>
<li><p><code>notify()</code>用于唤醒一个被暂停的线程，调用该方法可以实现通知</p>
<ul>
<li><strong>必须使用和<code>wait()</code>方法一样的对象调用</strong></li>
<li>必须使用<code>synchronized</code>关键字，并且在执行完毕之后会释放同步锁</li>
<li><strong>唤醒的是当前对象上的任意一个等待的线程</strong></li>
<li>被唤醒的等待线程在其占用的处理器继续运行的时候，需要再次申请Object对应的内部锁(synchronized)</li>
</ul>
</li>
<li><code>notifyAll()</code> 用于唤醒当前对象中的全部等待线程</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">		MyThread thread=<span class="keyword">new</span> MyThread();</div><div class="line">		<span class="keyword">new</span> Thread(thread,<span class="string">"线程1"</span>).start();</div><div class="line">		Thread.sleep(<span class="number">2000</span>);</div><div class="line">		thread.testNotifyAll();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Object object=<span class="keyword">new</span> Object();  <span class="comment">//创建一个Object对象，用于线程同步锁和调用wait方法</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;   <span class="comment">//保护条件</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">0</span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.testWait();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//测试等待</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWait</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="comment">//循环执行</span></div><div class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">            <span class="comment">//必须和调用wait的方法是一个对象</span></div><div class="line">			<span class="keyword">synchronized</span> (object) &#123;</div><div class="line">				<span class="keyword">while</span>(!<span class="keyword">this</span>.flag)&#123;</div><div class="line">					<span class="keyword">try</span> &#123;</div><div class="line">						System.out.println(Thread.currentThread().getName()+<span class="string">" 等待被唤醒...."</span>);</div><div class="line">						object.wait();</div><div class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">						System.out.println(<span class="string">"线程被终止....."</span>);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">this</span>.doAction();  <span class="comment">//执行其他的动作</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//测试唤醒线程，随机唤醒一个线程</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNotify</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">synchronized</span> (object) &#123;</div><div class="line">			<span class="keyword">this</span>.flag=<span class="keyword">true</span>;  </div><div class="line">			<span class="comment">//从当前object的等待线程中随机唤醒一个线程</span></div><div class="line">			object.notify();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//唤醒所有线程</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNotifyAll</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">synchronized</span> (object) &#123;</div><div class="line">			<span class="keyword">this</span>.flag=<span class="keyword">true</span>;</div><div class="line">			object.notifyAll();  <span class="comment">//唤醒当前对象上的所有等待线程</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//执行其他动作</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"执行其他的功能"</span>);</div><div class="line">		count++;</div><div class="line">		<span class="keyword">if</span> (count==<span class="number">10</span>) &#123;</div><div class="line">			flag=<span class="keyword">false</span>;   <span class="comment">//改变flag的值 ，将会wait</span></div><div class="line">		&#125; </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="条件变量condition"><a href="#条件变量condition" class="headerlink" title="条件变量condition"></a>条件变量condition</h2><ul>
<li>和<code>wait，notify()</code>思想一样，不过这个要和显示锁<code>Lock</code>结合使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span>  Lock lock=<span class="keyword">new</span> ReentrantLock();  <span class="comment">//创建显示锁</span></div><div class="line">	<span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">final</span> Condition condition=lock.newCondition();  <span class="comment">//创建条件变量</span></div><div class="line">	<span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;   <span class="comment">//保护条件</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">		Thread thread1=<span class="keyword">new</span> Thread()&#123;</div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				testWait();</div><div class="line">			&#125;;</div><div class="line">		&#125;;</div><div class="line">		thread1.start();</div><div class="line">		</div><div class="line">		</div><div class="line">		Thread thread2=<span class="keyword">new</span> Thread()&#123;</div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				testSignal();</div><div class="line">			&#125;;</div><div class="line">		&#125;;</div><div class="line">		thread2.start();</div><div class="line">		</div><div class="line">		</div><div class="line">		</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWait</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">			lock.lock();  <span class="comment">//获取显示锁</span></div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				<span class="keyword">if</span> (!flag) &#123;</div><div class="line">					condition.await();</div><div class="line">				&#125;</div><div class="line">				doAction();</div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException exception) &#123;</div><div class="line">				exception.printStackTrace();</div><div class="line">			&#125;<span class="keyword">finally</span>&#123;</div><div class="line">				lock.unlock();  <span class="comment">//释放锁</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSignal</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">			lock.lock();  <span class="comment">//获取锁</span></div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				<span class="keyword">if</span> (flag) &#123;</div><div class="line">					System.out.println(<span class="string">"执行其他的动作"</span>);</div><div class="line">				&#125;<span class="keyword">else</span> &#123;</div><div class="line">					flag=<span class="keyword">true</span>;</div><div class="line">					Thread.sleep(<span class="number">5000</span>);</div><div class="line">					condition.signal();  <span class="comment">//唤醒线程</span></div><div class="line">				&#125;</div><div class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;<span class="keyword">finally</span>&#123;</div><div class="line">				lock.unlock();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"执行其他的动作"</span>);</div><div class="line">		flag=<span class="keyword">false</span>;  <span class="comment">//改变flag</span></div><div class="line">	&#125;</div><div class="line">		</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="倒计时协调器-CountDownLatch"><a href="#倒计时协调器-CountDownLatch" class="headerlink" title="倒计时协调器 CountDownLatch"></a>倒计时协调器 CountDownLatch</h2><h2 id="栅栏-CycliBarrier"><a href="#栅栏-CycliBarrier" class="headerlink" title="栅栏 CycliBarrier"></a>栅栏 CycliBarrier</h2><h2 id="阻塞队列BlockingQueue"><a href="#阻塞队列BlockingQueue" class="headerlink" title="阻塞队列BlockingQueue"></a>阻塞队列BlockingQueue</h2><h2 id="信号量Semaphore"><a href="#信号量Semaphore" class="headerlink" title="信号量Semaphore"></a>信号量Semaphore</h2><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="http://www.cnblogs.com/dolphin0520/p/3920385.html" target="_blank" rel="external">http://www.cnblogs.com/dolphin0520/p/3920385.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;并发编程之线程协作&quot;&gt;&lt;a href=&quot;#并发编程之线程协作&quot; class=&quot;headerlink&quot; title=&quot;并发编程之线程协作&quot;&gt;&lt;/a&gt;并发编程之线程协作&lt;/h1&gt;&lt;h2 id=&quot;wait-notify-notifyAll&quot;&gt;&lt;a href=&quot;#wait
    
    </summary>
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之volatile</title>
    <link href="http://chenjiabing666.github.io/2018/06/26/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bvolatile/"/>
    <id>http://chenjiabing666.github.io/2018/06/26/并发编程之volatile/</id>
    <published>2018-06-26T14:49:47.000Z</published>
    <updated>2018-06-26T14:50:08.635Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程之volatile"><a href="#并发编程之volatile" class="headerlink" title="并发编程之volatile"></a>并发编程之volatile</h1><ul>
<li>volatile称之为轻量级锁，保证了可见性和原子性。</li>
<li>volatile不会引起上下文切换，因此是轻量级的</li>
</ul>
<h2 id="volatile的作用"><a href="#volatile的作用" class="headerlink" title="volatile的作用"></a>volatile的作用</h2><ul>
<li><p>保障可见性，有序性和<code>Long</code>，<code>double</code>类型变量读写操作的原子性</p>
</li>
<li><p><code>volatile</code>仅仅能保证对其修饰的变量的写操作以及读操作本身的原子性，而这并不表示volatile变量的赋值操作一定具有原子性，例如，如下对<code>volatile</code>修饰的变量count的赋值操作并不是原子操作：<code>count++</code></p>
<ul>
<li><code>count++</code>可以分为如下步骤<ul>
<li>读取count的值</li>
<li><code>count+1</code></li>
<li>将<code>count+1</code>的值赋值给<code>count</code></li>
</ul>
</li>
<li>如果<code>count</code>是一个共享变量，那个该赋值操作实际上是一个<code>read-modify-write</code>操作。其执行过程中其他线程可能已经更新了<code>count</code>的值，因此该操作不具备不可分割性，也就不是原子操作。如果变量count是一个局部变量，那么该赋值操作就是一个原子操作。</li>
</ul>
</li>
</ul>
<ul>
<li><strong>一般而言如果对volatile修饰的赋值操作，其右边的表达式中只要设计共享变量（包括被volatile修饰的变量本身），那么这个赋值操作就不是原子操作，此时就需要结合<code>锁</code>来保证原子性了</strong></li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="保证可见性原理"><a href="#保证可见性原理" class="headerlink" title="保证可见性原理"></a>保证可见性原理</h3><ul>
<li>对volatile修饰的变量的读操作之前插入一个<code>加载屏障</code>，能够刷新处理器缓存，使其读取的读取到的变量都是线程更新后的最新值。</li>
<li>对volatile修饰的变量的写操作(修改)之后插入一个<code>存储屏障</code>，能够冲刷处理器缓存，保证后续的线程读取到的值是最新的。</li>
</ul>
<h3 id="保证有序性原理"><a href="#保证有序性原理" class="headerlink" title="保证有序性原理"></a>保证有序性原理</h3><ul>
<li>结合释放屏障和获取屏障保证了有序性</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>volatile的写操作相当于锁的释放的效果，java虚拟机会在该操作之前插入一个释放屏障，并在该操作只有插入一个存储屏障<ul>
<li>释放屏障禁止了volatile写操作与该操作之前的任何读写操作进行重排序，从而保证了volatile写操作之前的任何读写操作会先于volatile写操作之前提交，即其他线程看到写线程对volatile变量的更新时，写线程在更新volatile变量之前执行的内存操作的结果对于度鲜橙必然是可见的。即是保障了有序性</li>
<li>存储屏障保证了在写操作之后的更新能够冲刷处理器缓存，使得后续的读线程能够获取最新的值</li>
</ul>
</li>
<li>volatile的读操作相当于获取锁的效果，Java虚拟机会在该操作之前插入一个加载屏障，并在该操作之后插入一个获取屏障<ul>
<li>加载屏障用于刷新处理器缓存区，保证读取到volatile修饰变量的最新值，保证可见性</li>
<li>获取屏障禁止volatile读操作之后的任何读写操作与volatile读操作进行重排序。因此保证了有序性</li>
</ul>
</li>
</ul>
<h2 id="volatile变量的开销"><a href="#volatile变量的开销" class="headerlink" title="volatile变量的开销"></a>volatile变量的开销</h2><ol>
<li>volatile变量的读写不会导致上下文切换，因此开销比锁小</li>
<li>读取volatile变量每次都需要从高速缓存或者主内存中读取，而无法暂存在寄存器中，因此可能比读取普通变量的成本要高</li>
</ol>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>使用volatile变量作为状态标志。比如<code>volatile int flag=false</code>,其他线程会读取该状态作为执行某一个操作的依据</li>
<li>单例模式下的双重校验锁的实现效果，其中必须使用<code>volatile</code>，否则并不能保证<code>对象</code>可见性</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="http://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="external">http://www.cnblogs.com/dolphin0520/p/3920373.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;并发编程之volatile&quot;&gt;&lt;a href=&quot;#并发编程之volatile&quot; class=&quot;headerlink&quot; title=&quot;并发编程之volatile&quot;&gt;&lt;/a&gt;并发编程之volatile&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;volatile称之为轻量级锁，保证了可
    
    </summary>
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之线程同步机制的底层助手内存屏障</title>
    <link href="http://chenjiabing666.github.io/2018/06/26/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%8A%A9%E6%89%8B%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/"/>
    <id>http://chenjiabing666.github.io/2018/06/26/并发编程之线程同步机制的底层助手内存屏障/</id>
    <published>2018-06-26T14:49:10.000Z</published>
    <updated>2018-06-26T14:49:31.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程同步机制的底层助手-：内存屏障"><a href="#线程同步机制的底层助手-：内存屏障" class="headerlink" title="线程同步机制的底层助手 ：内存屏障"></a>线程同步机制的底层助手 ：内存屏障</h1><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ul>
<li>我们知道<code>锁</code>是可以保证<code>可见性</code>的，线程在获取锁和释放锁的时候会分别执行两个动作来保证可见性:<ul>
<li><code>刷新处理器缓存</code> ：保证了持有该锁的线程能够读取到前一个线程对共享数据的更新</li>
<li><code>冲刷处理器缓存</code> ：保证了持有该锁的线程对共享数据所做的更新会对后续获取该锁的线程来说是保持可见的</li>
</ul>
</li>
<li>Java虚拟机是借助<code>内存屏障</code>（<code>Memory Barrier</code>）实现上述的两个动作。</li>
</ul>
<h2 id="按照可见性划分"><a href="#按照可见性划分" class="headerlink" title="按照可见性划分"></a>按照可见性划分</h2><ul>
<li>按照可见性划分内存屏障分为<code>加载屏障(Load Barrier)</code>和<code>存储屏障(Store Barrier)</code></li>
<li>加载屏障的作用是刷新处理器缓存暴保证获取该锁的线程能够读取到前一个线程对共享数据的更新</li>
<li>存储屏障的作用是冲刷处理器缓存保证当前线程对共享变量的更新对后续获取该锁的线程来说是可见的</li>
</ul>
<h2 id="保证可见性的原理"><a href="#保证可见性的原理" class="headerlink" title="保证可见性的原理"></a>保证可见性的原理</h2><ul>
<li>Java虚拟机会在<code>MonitorExit(释放锁)</code>对应的机器指令之后插入一个存储屏障，这个就保障了写线程在释放锁之前在临界区中对共享变量所做的更新对度鲜橙的处理器来说是可同步的。相应的Java虚拟机会在<code>MonitorEnter（申请锁）</code>对应的机器码之前插入一个加载屏障，这个使得线程能够获取到前面线程对共享数据的更新</li>
</ul>
<h2 id="按照有序性划分"><a href="#按照有序性划分" class="headerlink" title="按照有序性划分"></a>按照有序性划分</h2><ul>
<li>按照有序性划分，内存屏障分为<code>获取屏障(Acquire Barrier)</code>和<code>释放屏障（Release Barrier）</code></li>
<li>获取屏障的使用方式是在一个读操作（包括<code>Read-Modify-Write</code>）之后插入获取屏障，其作用是禁止该读操作与后面的任何读写操作之间进行重排序，这相当于在进行后续操作之前先要获取相应共享数据的所有权。</li>
<li>释放屏障的使用方式是在一个写操作之前插入释放屏障，其作用是禁止该写操作与前面的任何读写操作之间进行重排序。这相当于在对响应共享数据操作技术后释放所有权。</li>
</ul>
<h2 id="保证可见性和原子性详解图形"><a href="#保证可见性和原子性详解图形" class="headerlink" title="保证可见性和原子性详解图形"></a>保证可见性和原子性详解图形</h2><p><img src="http://ono60m7tl.bkt.clouddn.com/diceng1.png" alt="内存屏障在锁中的使用"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线程同步机制的底层助手-：内存屏障&quot;&gt;&lt;a href=&quot;#线程同步机制的底层助手-：内存屏障&quot; class=&quot;headerlink&quot; title=&quot;线程同步机制的底层助手 ：内存屏障&quot;&gt;&lt;/a&gt;线程同步机制的底层助手 ：内存屏障&lt;/h1&gt;&lt;h2 id=&quot;前提&quot;&gt;&lt;
    
    </summary>
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之上下文切换</title>
    <link href="http://chenjiabing666.github.io/2018/06/26/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/"/>
    <id>http://chenjiabing666.github.io/2018/06/26/并发编程之上下文切换/</id>
    <published>2018-06-26T14:47:28.000Z</published>
    <updated>2018-06-26T14:47:49.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程之上下文切换"><a href="#多线程之上下文切换" class="headerlink" title="多线程之上下文切换"></a>多线程之上下文切换</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>在单处理器的情况下，每个线程的执行时间是根据<code>时间片</code>大小决定或者自身的其他原因，如果一个线程被迫或者主动暂停运行时，另外一个线程(可能是同一个进程中的线程或者其他进程中的)可以被操作系统(线程调度器)选中占用处理器开始或者继续运行。这种一个线程被暂停，即是被剥夺处理器使用的权利，另外一个线程被选中开始或者继续运行的过程就叫做<code>上下文切换</code></p>
<p>一个线程被剥夺处理器的使用权而被暂停运行就被称之为<code>切出</code></p>
<p>一个线程被操作系统（线程调用器）选中占用处理器开始或者继续运行就被称之为<code>切入</code></p>
<p><strong>在线程的数量大于核心处理器的数量的时候，我们看到连续运行的线程，实际上是以断断续续的运行方式使其任务进展的。这种方式意味着在切入和切出的时候操作系统需要保存和恢复相应线程的进入信息，即是切入和切出的那一刻线程执行的任务进行到什么程度了（如计算结果以及执行到了哪条指令）。这个保存的进度信息叫做<code>上下文</code></strong></p>
<p>在切出的时候，操作系统需要将上下文信息保存在内存中，以便稍后处理器继续运行该线程的时候能够在此信息的基础上继续运行</p>
<p>在切入的时候操作系统需要从内存中加载和恢复被选中的线程上下文信息，以在之前的基础上继续运行</p>
<p><img src="http://ono60m7tl.bkt.clouddn.com/shangxiawen1.png" alt="上下文"></p>
</blockquote>
<h2 id="上下文切换的分类和诱因"><a href="#上下文切换的分类和诱因" class="headerlink" title="上下文切换的分类和诱因"></a>上下文切换的分类和诱因</h2><h3 id="自发性的上下文切换"><a href="#自发性的上下文切换" class="headerlink" title="自发性的上下文切换"></a>自发性的上下文切换</h3><blockquote>
<p>自发性上下文切换是指线程由于自身因素导致的切出。一个线程在运行过程中执行下列方法可能会导致线程自发性的上下文切换</p>
<ol>
<li><code>sleep()</code></li>
<li><code>wait()</code></li>
<li><code>yield(()</code> ： 这个方法可能导致</li>
<li><code>join()</code></li>
<li><code>LockSupport.park()</code></li>
<li><strong>线程发起了<code>IO</code>操作（如读取文件） 或者等待其他线程的持有的锁也会导致自发性上下文切换</strong></li>
</ol>
</blockquote>
<h3 id="非自发性上下文切换"><a href="#非自发性上下文切换" class="headerlink" title="非自发性上下文切换"></a>非自发性上下文切换</h3><blockquote>
<p>由于线程调度器的原因被迫切出</p>
<ol>
<li>时间片用完</li>
<li>一个更高优先级的线程需要运行</li>
<li>垃圾回收器在执行垃圾回收的过程中可能也是需要暂停线程才能完成工作</li>
</ol>
</blockquote>
<h2 id="上下文切换的花销"><a href="#上下文切换的花销" class="headerlink" title="上下文切换的花销"></a>上下文切换的花销</h2><blockquote>
<p>上下文切换的花销是必须的，即使在多核的处理器系统中上下文切换也是必须的，因为我们需要执行的线程的数量总是大于处理器的数量。</p>
</blockquote>
<h3 id="直接开销"><a href="#直接开销" class="headerlink" title="直接开销"></a>直接开销</h3><ol>
<li>操作系统保存和恢复上下文所需要的开销，主要是时间的开销</li>
<li>线程调度器进行线程调度的开销（比如按照一定规则决定哪一个线程会占用处理器）</li>
</ol>
<h3 id="间接开销"><a href="#间接开销" class="headerlink" title="间接开销"></a>间接开销</h3><ol>
<li>处理高速缓存重新加载的开销，一个被迫切出的线程在另外一个处理器切入运行，由于这个处理器之前可能没有运行过该线程，那么这个线程在运行过程中需访问的变量仍然需要该处理器从主内存或者通过一致性协议从其他处理器加载到高速缓存之中，这个也是需要时间消耗的</li>
<li>上下文切换可能导致整个一级高速缓存被冲刷（Flush），即一级高速缓存中的内容会被写入下一级高速缓存或者主内存中。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;多线程之上下文切换&quot;&gt;&lt;a href=&quot;#多线程之上下文切换&quot; class=&quot;headerlink&quot; title=&quot;多线程之上下文切换&quot;&gt;&lt;/a&gt;多线程之上下文切换&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之多线程状态</title>
    <link href="http://chenjiabing666.github.io/2018/06/26/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/"/>
    <id>http://chenjiabing666.github.io/2018/06/26/并发编程之多线程状态/</id>
    <published>2018-06-26T14:46:48.000Z</published>
    <updated>2018-06-26T14:47:05.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程状态"><a href="#多线程状态" class="headerlink" title="多线程状态"></a>多线程状态</h1><p>总的执行图：</p>
<p><img src="http://blog.java1234.com/static/userImages/20161213/1481630405946085486.png" alt="QQ鍥剧墖20161213195251.png"></p>
<p>所有状态：</p>
<p>1，创建状态(<code>new</code>)</p>
<p>在程序中用构造方法创建了一个线程对象后，新的线程对象便处于新建状态，此时，它已经有了相应的</p>
<p>内存空间和其他资源，但还处于不可运行状态。新建一个线程对象可采用Thread 类的构造方法来实现，例</p>
<p>如，“Thread thread=new Thread();”。</p>
<p>2，就绪状态(<code>Runnable</code>)</p>
<p>新建线程对象后，调用该线程的start()方法就可以启动线程。当线程启动时，线程进入就绪状态。此时，</p>
<p>线程将进入线程队列排队，等待CPU 服务，这表明它已经具备了运行条件。</p>
<p>3，运行状态(<code>Running</code>)</p>
<p>当就绪状态的线程被调用并获得处理器资源时，线程就进入了运行状态。此时，自动调用该线程对象</p>
<p>的run()方法。run()方法定义了该线程的操作和功能。</p>
<p>4，堵塞状态(<code>Block</code>)</p>
<p>一个正在执行的线程在某些特殊情况下，如被人为挂起或需要执行耗时的输入/输出操作时，将让出</p>
<p>CPU 并暂时中止自己的执行，进入堵塞状态。堵塞时，线程不能进入排队队列，只有当引起堵塞的原因被</p>
<p>消除后，线程才可以转入就绪状态。</p>
<p>5，死亡状态(<code>Dead</code>)</p>
<p>线程调用stop()方法时或run()方法执行结束后，即处于死亡状态。处于死亡状态的线程不具有继续运</p>
<p>行的能力。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;多线程状态&quot;&gt;&lt;a href=&quot;#多线程状态&quot; class=&quot;headerlink&quot; title=&quot;多线程状态&quot;&gt;&lt;/a&gt;多线程状态&lt;/h1&gt;&lt;p&gt;总的执行图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://blog.java1234.com/static/us
    
    </summary>
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之三大性质</title>
    <link href="http://chenjiabing666.github.io/2018/06/26/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E4%B8%89%E5%A4%A7%E6%80%A7%E8%B4%A8/"/>
    <id>http://chenjiabing666.github.io/2018/06/26/并发编程之三大性质/</id>
    <published>2018-06-26T14:45:20.000Z</published>
    <updated>2018-06-26T14:46:17.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程的三大性质"><a href="#多线程的三大性质" class="headerlink" title="多线程的三大性质"></a>多线程的三大性质</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><ul>
<li><strong>对共享变量更新操作的时候，要保证执行不可分割，比如银行转账，一旦在多线程的环境下将其分割了，那么可能造成的后果可能是转账的账户钱少了，但是转到的账户的钱可能不是那么多或者根本没有转过去</strong></li>
<li>在单线程的环境下没有所谓的原子性，都是顺序执行的</li>
<li>多线程的环境下对共享变量的访问(读写)才会涉及原子性</li>
<li>使用<code>Lock</code>和<code>sychronized</code>可以解决原子性问题</li>
</ul>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><ul>
<li>在多线程的环境下，一个线程的对共享变量的更新，后续的线程访问这个共享变量的时候能否立即读取这个更新后的结果</li>
</ul>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ol>
<li>程序中的变量可能是被分配到寄存器中，而不是主内存中。每个处理器都有寄存器，而一个处理器的寄存器不能读取另外一个处理器的寄存器的内容。因此如果两个线程运行在不同的处理器上，而共享变量被分配到寄存器上存储，那么可见性问题就出现了</li>
<li>每一个处理器都有自己的高速缓存区，即使共享变量在主存中， 在线程执行的时候会将复制一个副本存放在高速缓存中，一个线程更新共享变量之后会更新到高速缓存中，还没有来得及更新到主存中的时候，另外的线程就开始执行了，那么此时的共享变量就不是更新之后的，出现了可见性问题</li>
<li>处理器并不是直接与主内存直接打交道执行读写操作的，而是通过寄存器，高速缓存，写缓冲器和无效化队列等部件执行内存的读写。</li>
</ol>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ul>
<li>虽然每个处理器不能直接读写不同处理器的高速缓存，但是我们可以<code>缓存一致协议</code>来读取其他处理器中的高速缓存的内容，并将读取的内容更新到自己的高速缓存。这种一个处理器从其自身处理器缓存之外的其他存储部件中读取数据并将其更新到该处理器高速缓存的过程称之为<code>缓存同步</code></li>
<li>使用<code>voliate</code>关键字可以解决可见性问题<ul>
<li><code>public voliate int a</code> </li>
</ul>
</li>
</ul>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><blockquote>
<p>即程序执行的顺序按照代码的先后顺序执行</p>
</blockquote>
<h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;              </div><div class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">i = <span class="number">1</span>;                <span class="comment">//语句1  </span></div><div class="line">flag = <span class="keyword">true</span>;          <span class="comment">//语句2</span></div></pre></td></tr></table></figure>
<blockquote>
<p> 上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。</p>
<p>下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p>
<p>比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。</p>
<p>但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">10</span>;    <span class="comment">//语句1</span></div><div class="line"><span class="keyword">int</span> r = <span class="number">2</span>;    <span class="comment">//语句2</span></div><div class="line">a = a + <span class="number">3</span>;    <span class="comment">//语句3</span></div><div class="line">r = a*a;     <span class="comment">//语句4</span></div></pre></td></tr></table></figure>
<blockquote>
<p>这段代码有4个语句，那么可能的一个执行顺序是：</p>
</blockquote>
<p>　　<img src="https://images0.cnblogs.com/blog/288799/201408/212305263939989.jpg" alt="img"></p>
<p>　　</p>
<blockquote>
<p>那么可不可能是这个执行顺序呢： 语句2   语句1    语句4   语句3</p>
<p>不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。</p>
<p>虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//线程1:</span></div><div class="line">context = loadContext();   <span class="comment">//语句1</span></div><div class="line">inited = <span class="keyword">true</span>;             <span class="comment">//语句2</span></div><div class="line"> </div><div class="line"><span class="comment">//线程2:</span></div><div class="line"><span class="keyword">while</span>(!inited )&#123;</div><div class="line">  sleep()</div><div class="line">&#125;</div><div class="line">doSomethingwithconfig(context);</div></pre></td></tr></table></figure>
<blockquote>
<p>上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p>
<p>从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</p>
<p>也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p>
</blockquote>
<h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><ul>
<li>使用<code>voliate</code></li>
</ul>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="http://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="external">http://www.cnblogs.com/dolphin0520/p/3920373.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;多线程的三大性质&quot;&gt;&lt;a href=&quot;#多线程的三大性质&quot; class=&quot;headerlink&quot; title=&quot;多线程的三大性质&quot;&gt;&lt;/a&gt;多线程的三大性质&lt;/h1&gt;&lt;h2 id=&quot;原子性&quot;&gt;&lt;a href=&quot;#原子性&quot; class=&quot;headerlink&quot; ti
    
    </summary>
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/categories/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java并发编程" scheme="http://chenjiabing666.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB使用总结</title>
    <link href="http://chenjiabing666.github.io/2018/06/26/MongoDB%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://chenjiabing666.github.io/2018/06/26/MongoDB使用总结/</id>
    <published>2018-06-26T14:43:56.000Z</published>
    <updated>2018-06-26T14:44:38.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MongoDB使用总结"><a href="#MongoDB使用总结" class="headerlink" title="MongoDB使用总结"></a>MongoDB使用总结</h1><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><ul>
<li><code>show dbs</code>  : 显示所有的数据库</li>
<li><code>use user</code>  : 选择数据库<code>user</code>，如果这个数据库存在，那么就使用，不存在就新建，但是此时的数据库中根本不存在数据，因此使用<code>show dbs</code>不能显示该数据库</li>
<li><code>db.dropDatabase()</code>   : 删除数据库，其中的<code>db</code>表示当前数据库</li>
</ul>
<h2 id="集合操作-表"><a href="#集合操作-表" class="headerlink" title="集合操作(表)"></a>集合操作(表)</h2><ul>
<li>在MongoDB中，数据库中的集合相当于SQL中的表，一个数据库中可以存在多个集合，每一个集合都是一个JSON文档形式的存储</li>
<li><code>show tables</code>  : 显示所有的集合</li>
<li><code>show collections</code> : 显示所有的集合</li>
</ul>
<h3 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h3><ul>
<li><code>db.createCollection(name, options)</code></li>
<li><a href="http://www.runoob.com/mongodb/mongodb-create-collection.html" target="_blank" rel="external">文档</a></li>
</ul>
<h3 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h3><ul>
<li><code>db.collection.drop()</code><ul>
<li><code>db.user.drop()</code> : 删除<code>user</code>集合</li>
</ul>
</li>
</ul>
<h2 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h2><ul>
<li>一个集合中可以包含多条文档，一个文档就相当于SQL中的一条数据，这里的文档是JSON格式的文档</li>
</ul>
<h3 id="插入文档"><a href="#插入文档" class="headerlink" title="插入文档"></a>插入文档</h3><ul>
<li><p><code>db.collectionName.insert(JSON)</code> </p>
<ul>
<li><code>db.user.insert({name:&quot;陈加兵&quot;,age:22})</code>  : 向user集合中插入一条文档，如果这个<code>user</code>集合不存在，那么就会新建一个，这个方法默认会为我们插入一个<code>_id</code></li>
</ul>
</li>
</ul>
<h3 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h3><p>update() 方法用于更新已存在的文档。语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">db.collection.update(</div><div class="line">   &lt;query&gt;,</div><div class="line">   &lt;update&gt;,</div><div class="line">   &#123;</div><div class="line">     upsert: &lt;boolean&gt;,</div><div class="line">     multi: &lt;boolean&gt;,</div><div class="line">     writeConcern: &lt;document&gt;</div><div class="line">   &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<p><strong>参数说明：</strong></p>
<ul>
<li><strong>query</strong> : update的查询条件，类似sql update查询内where后面的。</li>
<li><strong>update</strong> : update的对象和一些更新的操作符（如$,​$inc…）等，也可以理解为sql update查询内set后面的</li>
<li><strong>upsert</strong> : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。</li>
<li><strong>multi</strong> : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。</li>
<li><strong>writeConcern</strong> :可选，抛出异常的级别。 </li>
</ul>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ul>
<li><code>db.user.update({name:&quot;jack&quot;},{$set:{name:&quot;tom&quot;}})</code>  ：相当于sql语句中的<code>update user set name=&quot;tom&quot; where name=&quot;jack&quot;</code>,不过这里默认只是更新一条</li>
<li><code>db.user.update({name:&quot;陈加兵&quot;},{$set:{name:&quot;郑元梅&quot;}},{multi:true})</code>    ： 更新所有的数据</li>
<li><code>db.user.update({name:&quot;陈加兵&quot;},{$set:{name:&quot;郑元梅&quot;}},{upsert:true})</code>  : 更新数据，如果不存在就插入</li>
<li><strong>这里的query条件也是可以使用逻辑比较的，比如<code>age&gt;12</code>，后续在讲到查询文档的时候会详细描述</strong></li>
</ul>
<h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><ul>
<li>删除格式，默认是删除多条，但是我们可以设置<code>justone : true</code>或者<code>justone：1</code>即可删除一条数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.collection.remove(</div><div class="line">   &lt;query&gt;,</div><div class="line">   &#123;</div><div class="line">     justOne: &lt;boolean&gt;,</div><div class="line">     writeConcern: &lt;document&gt;</div><div class="line">   &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<ul>
<li><code>db.user.remove({name:&quot;陈加兵&quot;})</code>  : 删除全部<code>name=陈加兵</code>的文档</li>
<li><code>db.user.remove({})</code> : 删除集合user中的全部文档</li>
<li><code>db.user.remove({})</code>  : 删除全部文档，因为这里没有条件</li>
<li><code>db.user.remove({name:&quot;陈加兵&quot;},{justone:true})</code> : 只删除一条文档</li>
</ul>
<h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><ul>
<li><p><code>db.collection.findOne(query,projection)</code>  ： 只显示满足条件的一条文档</p>
</li>
<li><p>格式：<code>db.collection.find(query,projection)</code>  ： 查询满足条件的全部文档</p>
<ul>
<li><code>query</code> ：可选， 查询的条件，相当于where子句</li>
<li><code>projection</code>： 可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）</li>
</ul>
</li>
</ul>
<h4 id="插入数据（准备）"><a href="#插入数据（准备）" class="headerlink" title="插入数据（准备）"></a>插入数据（准备）</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">db.user.insert(&#123;name:"Jack",age:22&#125;)</div><div class="line">db.user.insert(&#123;name:"Tom",age:40&#125;)</div><div class="line">db.user.insert(&#123;name:"Mary",age:25&#125;)</div><div class="line">db.user.insert(&#123;name:"Lucy",age:22&#125;)</div></pre></td></tr></table></figure>
<h4 id="查询全部"><a href="#查询全部" class="headerlink" title="查询全部"></a>查询全部</h4><ul>
<li><code>db.user.find().pretty()</code> ： 这里没有指定查询条件，那么就是查询全部</li>
</ul>
<h4 id="指定显示字段"><a href="#指定显示字段" class="headerlink" title="指定显示字段"></a>指定显示字段</h4><ul>
<li>默认显示全部的字段，但是我们可以指定<code>projection</code>来显示指定的字段</li>
<li><code>inclusion模式</code>，指定返回的键，比如<code>db.user.find({},{name:1})</code>,这里只会显示<code>_id</code>和<code>name</code>这两个字段，其他的字段都是不会显示的</li>
<li><code>exclusion模式</code>，指定不反回的键，比如<code>db.user.find({},{name:0})</code> : 这里只会显示<code>age</code>和<code>_id</code>,只有<code>name</code>不显示</li>
<li><strong>两种模式不可以混用，比如<code>db.user.find({},{name:1,age:0})</code> ,这个是不可以的</strong></li>
</ul>
<h4 id="指定查询条件"><a href="#指定查询条件" class="headerlink" title="指定查询条件"></a>指定查询条件</h4><ul>
<li><code>db.user.find({name:&quot;Jack&quot;})</code>   ： 查询<code>name=Jack</code>的全部文档内容</li>
<li><code>db.user.find({name:&quot;Jack&quot;},{name:0})</code>  : 不显示<code>name</code>字段</li>
</ul>
<h4 id="AND条件"><a href="#AND条件" class="headerlink" title="AND条件"></a>AND条件</h4><ul>
<li><code>db.user.find({name:&quot;Jack&quot;,age:22})</code>  ： 查询<code>name=Jack并且age=22</code>的文档信息</li>
<li><code>db.user.find({$and:[{expression1},{expression2},{experssion3},......]})</code><ul>
<li><code>db.user.find({$and:[{name:&quot;Jack&quot;},{age:22}]})</code> : 和上面一样的效果</li>
</ul>
</li>
</ul>
<h4 id="OR-条件"><a href="#OR-条件" class="headerlink" title="OR 条件"></a>OR 条件</h4><ul>
<li><code>db.user.find({$or:[{expression1},{expression2},{expression3}......]})</code><ul>
<li><code>db.user.find({$or:[{name:&quot;Jack&quot;},{age:25}]})</code>  : 查找<code>name=Jack或者age=25</code>的文档信息</li>
</ul>
</li>
</ul>
<h4 id="AND-和-OR-联合使用"><a href="#AND-和-OR-联合使用" class="headerlink" title="AND 和 OR 联合使用"></a>AND 和 OR 联合使用</h4><ul>
<li><code>db.user.find({name:&quot;Jack&quot;,$or:[{_id:1},{age:22}]})</code> : 查找<code>name=Jack and (_id=1 or age=22)</code></li>
</ul>
<h4 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h4><ul>
<li><code>(&gt;) 大于 - $gt</code></li>
<li><code>(&lt;) 小于 - $lt</code></li>
<li><code>(&gt;=) 大于等于 - $gte</code></li>
<li><code>(&lt;= ) 小于等于 - $lte</code></li>
<li><code>(!=) 不等于  - $ne</code></li>
</ul>
<h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><ul>
<li><code>db.user.find({age:{$gt:22}})</code>  : 查找 <code>age&gt;22</code>的信息</li>
<li><code>db.user.find({age:{$gte:22},name:&quot;Jack&quot;})</code>  : 查找<code>age&gt;=22 and name=Jack</code>的信息</li>
</ul>
<h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><ul>
<li>指定显示记录的条数</li>
<li><code>db.user.find().limit(2)</code> : 只显示两条记录</li>
<li><code>db.user.find({name:&quot;Jack&quot;}).limit(2)</code></li>
</ul>
<h4 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h4><ul>
<li>跳过的条数</li>
<li><code>db.user.find().skip(10)</code> : 跳过前面的十条记录，显示后面的</li>
</ul>
<h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><ul>
<li>显示第三页，每页显示10条信息，相当于SQL中的<code>select * from user limit 20,5</code><ul>
<li><code>db.user.find().skip(20).limit(5)</code></li>
</ul>
</li>
</ul>
<h4 id="sort-排序"><a href="#sort-排序" class="headerlink" title="sort 排序"></a>sort 排序</h4><ul>
<li>在MongoDB中使用使用<code>sort()</code>方法对数据进行排序，sort()方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中<code>1</code> 为升序排列，而<code>-1</code>是用于降序排列。</li>
<li><code>db.collection.find().sort({key:1})</code>  </li>
<li><code>db.user.find().sort({age:-1})</code>   : 按照<code>age</code>降序排列</li>
<li><code>db.user.find({},{name:1,age:1}).sort({age:-1,name:1})</code>  : 按照name升序，age降序排列</li>
</ul>
<h4 id="limit，skip，sort执行顺序"><a href="#limit，skip，sort执行顺序" class="headerlink" title="limit，skip，sort执行顺序"></a>limit，skip，sort执行顺序</h4><ul>
<li>执行顺序为：<code>sort()</code> — &gt; <code>skip()</code>  —-&gt; <code>limit()</code>  ,这个相当于SQL中的<code>select * from name where group by  having order by limit m,n</code> 这种顺序一样</li>
</ul>
<h4 id="in"><a href="#in" class="headerlink" title="$in"></a>$in</h4><ul>
<li>表示一个数据在多个数据中，类似于SQL中的<code>in</code></li>
<li><code>db.user.find({age:{$in:[22,33,44]}})</code>  : 查找<code>age in (22,33,44)之中的任意一个</code></li>
</ul>
<h4 id="nin"><a href="#nin" class="headerlink" title="$nin"></a>$nin</h4><ul>
<li>相当于SQL中的<code>not in</code></li>
<li><code>db.user.find({age:{$nin:[22,33,44]}})</code></li>
</ul>
<h4 id="exists"><a href="#exists" class="headerlink" title="$exists"></a>$exists</h4><ul>
<li>表示不存在 </li>
<li><code>db.user.find({sex:{$exists:false}})</code>  : 查找不存在<code>sex</code>这个字段的文档</li>
</ul>
<h4 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h4><blockquote>
<p><strong>$slice操作符控制查询返回的数组中元素的个数。此操作符根据参数{ field: value } 指定键名和键值选择出文档集合，并且该文档集合中指定array键将返回从指定数量的元素。如果count的值大于数组中元素的数量，该查询返回数组中的所有元素的。</strong></p>
<p><strong>语法：db.collection.find( { field: value }, { array: {$slice: count }});</strong></p>
<ul>
<li><strong>下面将查询grades中的前两个数</strong></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">db.user.find(&#123;name:&apos;jack&apos;&#125;,&#123;grades:&#123;$slice:2&#125;,name:1,age:1,&apos;school.name&apos;:1&#125;);</div><div class="line"></div><div class="line">//输出，可以看出这里的grades只输出了前面两个</div><div class="line"></div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;59057c16f551d8c9003d31df&quot;), &quot;name&quot; : &quot;jack&quot;, &quot;age&quot; : 22, &quot;grades&quot; : [ 22, 33 ], &quot;school&quot; : &#123; &quot;name&quot; : &quot;shida&quot; &#125; &#125;</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><strong>下面将输出后3个数据</strong></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">db.user.find(&#123;name:&apos;jhon&apos;&#125;,&#123;grades:&#123;$slice:-3&#125;,name:1&#125;);</div><div class="line"></div><div class="line">//输出</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;59057c16f551d8c9003d31e0&quot;), &quot;name&quot; : &quot;jhon&quot;, &quot;grades&quot; : [ 22, 44, 88 ] &#125;</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><strong>下面介绍指定一个数组作为参数。数组参数使用[ skip , limit ] 格式，其中第一个值表示在数组中跳过的项目数,第二个值表示返回的项目数。</strong></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">db.user.find(&#123;name:&apos;jack&apos;&#125;,&#123;grades:&#123;$slice:[2,2]&#125;,name:1&#125;);  //这里将会跳过前面的两个，直接得到后面的两个数据</div><div class="line"></div><div class="line"></div><div class="line">//输出</div><div class="line"></div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;59057c16f551d8c9003d31df&quot;), &quot;name&quot; : &quot;jack&quot;, &quot;grades&quot; : [ 44, 55 ] &#125;</div></pre></td></tr></table></figure>
<h4 id="count"><a href="#count" class="headerlink" title="count"></a>count</h4><ul>
<li>统计数量</li>
<li><code>db.user.find().count()</code>  : 统计全部的数量</li>
<li><code>db.user.find({name:&quot;Jack&quot;}).count()</code>  : 统计<code>name=Jack</code>的人数</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li><p><code>db.collection.ensureIndex({key1:1})</code> : 创建索引，其中的<code>key</code>的值如果为1表示按照升序创建索引，-1表示降序创建索引</p>
<ul>
<li><code>db.user.ensureIndex({name:1})</code> ： 单个索引</li>
<li><code>db.user.ensureIndex({name:1,age:-1})</code>  : 复合索引</li>
</ul>
</li>
<li><code>ensureIndex()</code> 接收可选参数，可选参数列表如下：</li>
</ul>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>background</td>
<td>Boolean</td>
<td>建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 “background” 可选参数。 “background” 默认值为<strong>false</strong>。</td>
</tr>
<tr>
<td>unique</td>
<td>Boolean</td>
<td>建立的索引是否唯一。指定为true创建唯一索引。默认值为<strong>false</strong>.</td>
</tr>
<tr>
<td>name</td>
<td>string</td>
<td>索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称。</td>
</tr>
<tr>
<td>dropDups</td>
<td>Boolean</td>
<td>在建立唯一索引时是否删除重复记录,指定 true 创建唯一索引。默认值为 <strong>false</strong>.</td>
</tr>
<tr>
<td>sparse</td>
<td>Boolean</td>
<td>对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档.。默认值为 <strong>false</strong>.</td>
</tr>
<tr>
<td>expireAfterSeconds</td>
<td>integer</td>
<td>指定一个以秒为单位的数值，完成 TTL设定，设定集合的生存时间。</td>
</tr>
<tr>
<td>v</td>
<td>index version</td>
<td>索引的版本号。默认的索引版本取决于mongod创建索引时运行的版本。</td>
</tr>
<tr>
<td>weights</td>
<td>document</td>
<td>索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重。</td>
</tr>
<tr>
<td>default_language</td>
<td>string</td>
<td>对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语</td>
</tr>
<tr>
<td>language_override</td>
<td>string</td>
<td>对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language.</td>
</tr>
</tbody>
</table>
<ul>
<li><code>db.user.ensureIndex({age:1},{background:true})</code>  : 在后台创建索引</li>
</ul>
<h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><ul>
<li><p><a href="https://blog.csdn.net/congcong68/article/details/51619882" target="_blank" rel="external">参考文章</a></p>
</li>
<li><p><code>db.collection.aggregate(pipeline,options)</code></p>
<ul>
<li><code>db.user.aggregate([{$group:{_id:null,count:{$sum:1}}}])</code> : 查询总数，相当于<code>select count(*) from user</code>,这里的聚合函数<code>$sum</code>表示求和，可以使用<code>$</code>引用集合中的字段，也可以直接使用数字，这里填写<code>1</code>就表示查询到一条记录就加一，那么最后显示的就是总数了。<ul>
<li><strong><code>_id</code> : 表示需要分组的字段，如果为<code>null</code>表示不分组</strong></li>
</ul>
</li>
<li><code>db.user.aggregate([{$group:{_id:&quot;$name&quot;,sum_age:{$sum:&quot;$age&quot;}}}])</code> : 根据字段<code>name</code>分组,对字段<code>age</code>求和，输入如下</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="attr">"_id"</span> : <span class="string">"Mary"</span>, <span class="attr">"sum_age"</span> : <span class="number">75</span> &#125;</div><div class="line">&#123; <span class="attr">"_id"</span> : <span class="string">"Jack"</span>, <span class="attr">"sum_age"</span> : <span class="number">66</span> &#125;</div><div class="line">&#123; <span class="attr">"_id"</span> : <span class="string">"zhengyunamei"</span>, <span class="attr">"sum_age"</span> : <span class="number">0</span> &#125;</div><div class="line">&#123; <span class="attr">"_id"</span> : <span class="string">"Tom"</span>, <span class="attr">"sum_age"</span> : <span class="number">120</span> &#125;</div><div class="line">&#123; <span class="attr">"_id"</span> : <span class="string">"陈加兵"</span>, <span class="attr">"sum_age"</span> : <span class="number">22</span> &#125;</div><div class="line">&#123; <span class="attr">"_id"</span> : <span class="string">"Lucy"</span>, <span class="attr">"sum_age"</span> : <span class="number">66</span> &#125;</div><div class="line">&#123; <span class="attr">"_id"</span> : <span class="string">"郑元梅"</span>, <span class="attr">"sum_age"</span> : <span class="number">22</span> &#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>db.user.aggregate([{$group:{_id:null,max_age:{$max:&quot;$age&quot;}}}])</code>  : 求出年龄最大的人信息</p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="attr">"_id"</span> : <span class="literal">null</span>, <span class="attr">"max_age"</span> : <span class="number">40</span> &#125;</div></pre></td></tr></table></figure>
<h3 id="常用的聚合"><a href="#常用的聚合" class="headerlink" title="常用的聚合"></a>常用的聚合</h3><table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>$sum</td>
<td>计算总和。</td>
<td>db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$sum : “$likes”}}}])</td>
</tr>
<tr>
<td>$avg</td>
<td>计算平均值</td>
<td>db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$avg : “$likes”}}}])</td>
</tr>
<tr>
<td>$min</td>
<td>获取集合中所有文档对应值得最小值。</td>
<td>db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$min : “$likes”}}}])</td>
</tr>
<tr>
<td>$max</td>
<td>获取集合中所有文档对应值得最大值。</td>
<td>db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$max : “$likes”}}}])</td>
</tr>
<tr>
<td>$push</td>
<td>在结果文档中插入值到一个数组中。</td>
<td>db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$push: “$url”}}}])</td>
</tr>
<tr>
<td>$addToSet</td>
<td>在结果文档中插入值到一个数组中，但不创建副本。</td>
<td>db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$addToSet : “$url”}}}])</td>
</tr>
<tr>
<td>$first</td>
<td>根据资源文档的排序获取第一个文档数据。</td>
<td>db.mycol.aggregate([{$group : {_id : “$by_user”, first_url : {$first : “$url”}}}])</td>
</tr>
<tr>
<td>$last</td>
<td>根据资源文档的排序获取最后一个文档数据</td>
<td>db.mycol.aggregate([{$group : {_id : “$by_user”, last_url : {$last : “$url”}}}])</td>
</tr>
</tbody>
</table>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道在Unix和Linux中一般用于将当前命令的输出结果作为下一个命令的参数。</p>
<p>MongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理。管道操作是可以重复的。</p>
<p>表达式：处理输入文档并输出。表达式是无状态的，只能用于计算当前聚合管道的文档，不能处理其它的文档。</p>
<p>这里我们介绍一下聚合框架中常用的几个操作：</p>
<ul>
<li><code>$project</code>：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。</li>
<li><code>$match</code>：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。</li>
<li><code>$limit</code>：用来限制MongoDB聚合管道返回的文档数。</li>
<li><code>$skip</code>：在聚合管道中跳过指定数量的文档，并返回余下的文档。</li>
<li><code>$unwind</code>：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。</li>
<li><code>$group</code>：将集合中的文档分组，可用于统计结果。</li>
<li><code>$sort</code>：将输入文档排序后输出。</li>
<li><code>$geoNear</code>：输出接近某一地理位置的有序文档。</li>
</ul>
<h4 id="math"><a href="#math" class="headerlink" title="$math"></a>$math</h4><ul>
<li>这个相当于where语句，用来过滤文档的</li>
<li><strong>这个位置是非常重要的，如果在<code>$group</code>之前就是<code>where子句</code>，如果在之后，那么相当于`having子句</strong>`</li>
<li><code>db.user.aggregate([{$match:{name:&quot;Jack&quot;}},{$group:{_id:null,count:{$sum:1}}}])</code> ： 统计<code>name=Jack</code>的人数<ul>
<li>这个命令相当于SQL中的<code>select count(*) from user where name=&quot;Jack&quot;</code></li>
<li>我们可以使用<code>db.user.find({name:&quot;Jack&quot;}).count()</code>同样可以查询、</li>
</ul>
</li>
<li><code>db.user.aggregate([{$match:{age:{$gt:20}}},{$group:{_id:&quot;$name&quot;,sum_age:{$sum:&quot;$age&quot;}}}])</code><ul>
<li>相当于SQL中的<code>select _id,sum(age) as sum_age from user where age&gt;20 group by name</code></li>
</ul>
</li>
<li><code>db.user.aggregate([{$group:{_id:&quot;$name&quot;,sum_age:{$sum:&quot;$age&quot;}}},{$match:{sum_age:{$gte:75}}}])</code><ul>
<li><code>select _id,sum(age) as sum_age from user group by name having sum_age&gt;=75</code></li>
</ul>
</li>
<li><code>db.user.aggregate([{$match:{name:&quot;Tom&quot;}},{$group:{_id:&quot;$name&quot;,sum_age:{$sum:&quot;$age&quot;}}},{$match:{sum_age:{$gte:75}}}])</code><ul>
<li><code>select _id,sum(age) as sum_age from user where name=&quot;Tom&quot; group by name having sum_age&gt;=75</code></li>
</ul>
</li>
</ul>
<h4 id="limit-1"><a href="#limit-1" class="headerlink" title="$limit"></a>$limit</h4><ul>
<li>控制显示的条数，因为使用聚合之后，不能再使用<code>limit()</code>方法来限制</li>
<li><code>db.user.aggregate([{$group:{_id:&quot;$name&quot;,sum_age:{$sum:&quot;$age&quot;}}},{$limit:1}])</code> ： 根据姓名分组之后显示一条数据<ul>
<li>相当于 <code>select _id,sum(age) as sum_age from user group by name limit 0,1</code></li>
</ul>
</li>
<li><code>db.user.aggregate([{$match:{name:&quot;Tom&quot;}},{$group:{_id:&quot;$name&quot;,sum_age:{$sum:&quot;$age&quot;}}},{$match:{sum_age:{$gte:75}}},{$skip:0},{$limit:1}])</code><ul>
<li><code>select _id ,sum(age) as sum_age from user where name=&quot;Tom&quot; group by name having age&gt;=75 limit 0,1</code></li>
</ul>
</li>
</ul>
<h4 id="sort"><a href="#sort" class="headerlink" title="$sort"></a>$sort</h4><ul>
<li>排序输出</li>
<li><code>db.collection.aggregate([{},{},{},......,{$sort:{key:1}}])</code> </li>
<li><code>db.user.aggregate([{$match:{name:&quot;Tom&quot;}},{$group:{_id:&quot;$name&quot;,sum_age:{sum:&quot;age&quot;}}},{$match:{sum_age:{$gte:75}}},{$sort:{sum_age:1}},{$skip:0},{$limit:1}])</code><ul>
<li><code>select _id ,sum(age) as sum_age from user where name=&quot;Tom&quot; group by name having age&gt;=75 order by sum_age asc limit 0,1</code></li>
</ul>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>常用的格式： <code>db.collection.aggregate([{$match:{key:value,...},{$group:{_id:value,..}},{$match:{key:value,....}},{$sort:{key:1,key2:-1}},{$skip:num},{$limit:num}])</code><ul>
<li>对应SQL中的语句为：<code>select _id,key1,key2 from collection where group by order by limit n,m</code></li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MongoDB使用总结&quot;&gt;&lt;a href=&quot;#MongoDB使用总结&quot; class=&quot;headerlink&quot; title=&quot;MongoDB使用总结&quot;&gt;&lt;/a&gt;MongoDB使用总结&lt;/h1&gt;&lt;h2 id=&quot;数据库操作&quot;&gt;&lt;a href=&quot;#数据库操作&quot; class
    
    </summary>
    
      <category term="数据库干货篇" scheme="http://chenjiabing666.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B2%E8%B4%A7%E7%AF%87/"/>
    
    
      <category term="MongoDB" scheme="http://chenjiabing666.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Git使用总结</title>
    <link href="http://chenjiabing666.github.io/2018/06/26/Git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://chenjiabing666.github.io/2018/06/26/Git使用总结/</id>
    <published>2018-06-26T14:42:21.000Z</published>
    <updated>2018-06-26T14:42:56.385Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git使用总结"><a href="#Git使用总结" class="headerlink" title="Git使用总结"></a>Git使用总结</h1><h2 id="开发策略"><a href="#开发策略" class="headerlink" title="开发策略"></a>开发策略</h2><ul>
<li>在实际开发的时候一定要在分支上开发，修复问题，开发完成之后再合并到主分支(master)上，这样可以保证在不损坏主分支的情况下删除或者撤销内容</li>
</ul>
<h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><h3 id="冲突产生"><a href="#冲突产生" class="headerlink" title="冲突产生"></a>冲突产生</h3><ul>
<li><p>假设现在有一个<code>master分支</code>，其中有一个提交之后的文件<code>demo.txt</code>，那么我们使用<code>git checkout -b dev</code>创建一个新的分支并且切换到这个dev分支</p>
<ul>
<li><code>echo chenjiabing &gt;&gt; demo.txt</code>：在文件的末尾追加一个文件</li>
<li><code>git add file.txt</code> :  添加到暂存区</li>
<li><code>git commit -m &quot;this is at dev</code>：提交</li>
<li><code>git checkout master</code> : 切换到主分支</li>
<li><code>echo 陈加兵 &gt;&gt;demo.txt</code> ： 切换到主分支，在主分支中在文件的末尾追加<code>陈加兵</code>，<strong>(这里一定要在文件末尾，因为在dev分支中修改的位置就是文件末尾)</strong></li>
<li><code>git add demo.txt</code> : 添加到暂存区</li>
<li><code>git commit -m &quot;this is at master&quot;</code> : 提交</li>
<li><code>git merge dev</code> ：快速合并分支dev到master分支上，那么现在将会出现版本冲突的问题，不能合并成功。此时的<code>demo.txt</code>的文件内容为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Git is a distributed version control system.</div><div class="line">Git is free software distributed under the GPL.</div><div class="line">Git has a mutable index called stage.</div><div class="line">Git tracks changes of files.</div><div class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</div><div class="line">陈加兵</div><div class="line">=======</div><div class="line">chenjiabing</div><div class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h3><ul>
<li><strong>此时在<code>master分支</code>中修改<code>demo.txt</code>中的内容，直到满意为止即可</strong><ul>
<li><code>git add demo.txt</code> : 添加</li>
<li><code>git commit -m &quot;this is finally&quot;</code> :提交</li>
</ul>
</li>
</ul>
<h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><ul>
<li>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</li>
<li>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</li>
<li><code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code></li>
</ul>
<h2 id="Bug分支-git-stash"><a href="#Bug分支-git-stash" class="headerlink" title="Bug分支(git stash)"></a>Bug分支(git stash)</h2><ul>
<li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137602359178794d966923e5c4134bc8bf98dfb03aea3000" target="_blank" rel="external">Bug分支</a></li>
<li><code>git stash</code>  将当前的工作现场存储起来</li>
<li><code>git stash list</code> ： 列出所有的工作现场</li>
<li><code>git stash pop</code> :  回复当前分支的工作现场，并且还删除了stash中的内容</li>
</ul>
<h2 id="添加公钥到Github中"><a href="#添加公钥到Github中" class="headerlink" title="添加公钥到Github中"></a>添加公钥到Github中</h2><ul>
<li><p>如果你没有在git中配置邮箱和用户名，那么需要先配置</p>
<ul>
<li><code>git config --global user.name &quot;CSDN id&quot;</code> </li>
<li><code>git config --global user.email &quot;your email&quot;</code></li>
</ul>
</li>
<li><code>cd ~/.ssh</code>： 进入主目录的<code>ssh文件夹</code>中，查看是否已经存在秘钥文件<code>id_rusa.pub</code>，如果不存在，那么需要生成秘钥</li>
<li><code>ssh-keygen -t rsa -C &quot;your email&quot;</code>  ：   生成公钥</li>
<li>此时在<code>~/.ssh</code>文件夹下就有了<code>id_rusa.pub</code>文件夹，那么将其中的内容全部复制到github中的SSH中</li>
<li><strong>注意： 添加远程仓库的时候一定要使用ssh形式，否则将会要求输入密码</strong><ul>
<li><code>git remote add git@github.com:chenjiabing666/LearnGit.git</code></li>
</ul>
</li>
</ul>
<h2 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li><code>git clone git@github.com:chenjiabing666/LearnGit.git</code> ：直接clone远程仓库到本地仓库，此时的本地仓库也有了push的权利，不过只能看到一个主分支<code>master</code> ，但是这个远程仓库还有<code>dev</code>分支和<code>Bug</code>分支<ul>
<li><code>git checkout -b dev orgin/dev</code>  : 直接在本地创建一个分支dev并且和远程仓库的分支关联起来，那么就可以获取远程dev分支上的文件了</li>
</ul>
</li>
<li><code>git remote</code> : 查看远程仓库的名称，这个只显示名称，使用<code>git clone</code>的方法关联远程仓库，默认的名字为<code>orgin</code></li>
<li><code>git remote -v</code> : 显示远程仓库的名称和链接</li>
<li><code>git remote add shortName url</code>   : 添加一个新的远程仓库<ul>
<li><code>git remote add learn git@github.com:chenjiabing666/LearnGit.git</code> </li>
</ul>
</li>
<li><code>git remote rename 旧名称 新名称</code>  ： 修改远程仓库的名称<ul>
<li><code>git remote rename orgin demo</code></li>
</ul>
</li>
<li><code>git remote remove 名称</code>  ： 删除远程仓库<ul>
<li><code>git remote remvoe orgin</code> </li>
</ul>
</li>
<li><code>git push 仓库名称  [分支名称]</code>  ： 将提交的文件推送到远程仓库<ul>
<li><code>git push orgin</code>  : 将文件推送到远程仓库的主分支<code>master</code></li>
<li>假设我们新建了一个<code>dev分支</code> 使用命令<code>git checkout -b dev</code> ,那么我们需要将这个dev分支推送到远程仓库中的<code>dev分支</code>上，使用<code>git push orgin dev</code> 。<strong>需要注意的是必须在当前的本地仓库的dev分支才能推送,并且这个本地仓库的名称要和远程仓库一样</strong></li>
</ul>
</li>
<li><code>git pull</code>  : 从远程仓库中拉取本地仓库分支中没有的文件并且合并到当前分支<ul>
<li>假设小明在<code>master分支</code>上提交了一个<code>file.txt</code>文件，但是小李的本地仓库中并没有<code>file.txt</code>这个文件，此时小李就需要从远程仓库中把这个文件拉取到自己的本地仓库的master分支上<ul>
<li><code>git checkout master</code>  : 切换到主分支</li>
<li><code>git pull</code> : 拉取远程仓库的最新文件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><h4 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h4><ul>
<li><code>git push 名称 分支名称</code> ： 推送分支到远程仓库中<ul>
<li><code>git push orgin Bug</code>  : 推送本地的分支Bug推送到远程仓库中，那么仓库中默认的分支名就是<code>Bug</code></li>
</ul>
</li>
<li>对于一些需要合作完成的分支需要推送到远程仓库，并不是所有的分支都需要推送到远程仓库的</li>
</ul>
<h4 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h4><ul>
<li>在多人协作完成项目的时候，都需要向<code>主分支master</code>和<code>dev分支</code>上面推送各自的修改</li>
<li>我们使用<code>git clone</code>一个远程仓库的时候，默认情况下只能看到<code>master</code>分支，我们可以使用<code>git branch</code>查看分支。此时我们需要在<code>dev</code>分支上面操作，那么就必须将远程仓库中的dev分支创建到本地，我们可以使用<code>git checkout -b dev orgin/dev</code> ，那么远程仓库的中的dev分支就创建到本地了，那么此时我们就可以在dev分支上面操作了<ul>
<li><code>git push orgin dev</code> : 修改完成之后推送到远程仓库中</li>
</ul>
</li>
<li>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code><ul>
<li>如果远程仓库中有一个<code>demo分支</code>，本地也有一个<code>demo</code>分支，但是这个本地的<code>demo分支</code>并不是使用<code>git checkout -b demo orgin/demo</code>检出的，而是直接创建的，那么我们此时需要使用<code>git pull</code>拉取远程仓库中demo分支中的文件到本地的demo分支就会发现出现错误，因为没有与远程的demo分支关联，此时我们就需要使用<code>git branch --set-upstream demo orgin/demo</code></li>
</ul>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>因此，多人协作的工作模式通常是这样：</p>
<ol>
<li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li>
<li><strong>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</strong></li>
<li>如果合并有冲突，则解决冲突，并在本地提交；</li>
<li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li>
</ol>
<p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p>
<h3 id="标签的使用"><a href="#标签的使用" class="headerlink" title="标签的使用"></a>标签的使用</h3><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><ul>
<li><p><code>git tag  v1.0</code>  : 在当前分支上添加一个标签</p>
</li>
<li><p><code>git tag -a v1.0 -m &quot;备注信息&quot;</code>  ： 添加一个标签并且备注信息</p>
</li>
<li><p><code>git tag</code>  : 列出当前分支上面的所有标签</p>
</li>
</ul>
<h4 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h4><ul>
<li><code>git tag -d v1.0</code>   : 删除指定的标签</li>
<li><code>git push origin v1.0</code> : 推送标签到远程仓库，因为标签的创建不会自动推送到远程，必须手动推送</li>
<li><code>git push orgin --tags</code>  : 一次性推送全部的标签</li>
</ul>
<h4 id="删除远程标签"><a href="#删除远程标签" class="headerlink" title="删除远程标签"></a>删除远程标签</h4><ol>
<li>先删除本地标签 : <code>git tag -d v1.0</code></li>
<li>使用<code>push</code>删除远程标签 ： <code>git push orgin :refs/tags/v1.0</code></li>
</ol>
<h2 id="添加所有文件"><a href="#添加所有文件" class="headerlink" title="添加所有文件"></a>添加所有文件</h2><ul>
<li><code>git add -A</code></li>
<li>之后直接提交即可 : <code>git commit -m &quot;&quot;</code></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Git使用总结&quot;&gt;&lt;a href=&quot;#Git使用总结&quot; class=&quot;headerlink&quot; title=&quot;Git使用总结&quot;&gt;&lt;/a&gt;Git使用总结&lt;/h1&gt;&lt;h2 id=&quot;开发策略&quot;&gt;&lt;a href=&quot;#开发策略&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
      <category term="Git" scheme="http://chenjiabing666.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="http://chenjiabing666.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo使用总结</title>
    <link href="http://chenjiabing666.github.io/2018/06/26/Dubbo%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://chenjiabing666.github.io/2018/06/26/Dubbo使用总结/</id>
    <published>2018-06-26T14:41:16.000Z</published>
    <updated>2018-06-26T14:41:47.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dubbo常见问题"><a href="#Dubbo常见问题" class="headerlink" title="Dubbo常见问题"></a>Dubbo常见问题</h1><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><ul>
<li><a href="http://dubbo.apache.org/books/dubbo-user-book/demos/preflight-check.html" target="_blank" rel="external">中文文档</a></li>
</ul>
<h2 id="启动检查"><a href="#启动检查" class="headerlink" title="启动检查"></a>启动检查</h2><blockquote>
<p>Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题，默认 <code>check=&quot;true&quot;</code><br>可以通过 <code>check=&quot;false&quot;</code> 关闭检查，比如，测试时，有些服务不关心，或者出现了循环依赖，必须有一方先启动。</p>
<p>另外，如果你的 Spring 容器是懒加载的，或者通过 API 编程延迟引用服务，请关闭 check，否则服务临时不可用时，会抛出异常，拿到 null 引用，如果 <code>check=&quot;false&quot;</code>，总是会返回引用，当服务恢复时，能自动连上</p>
<p><strong>如果在服务提供者没有上线的情况下，我们需要提前将消费者上线，那么就可以关闭启动检查，这样当消费者启动但是不调用服务的情况下不会报错，保证正常启动</strong></p>
</blockquote>
<h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><h4 id="关闭某个服务的检查"><a href="#关闭某个服务的检查" class="headerlink" title="关闭某个服务的检查"></a>关闭某个服务的检查</h4><ol>
<li><p><code>&lt;dubbo:reference id=&quot;helloService&quot; interface=&quot;cn.tedu.service.IHelloService&quot; check=&quot;false&quot;/&gt;</code> ：关闭某个服务的启动时检查</p>
<ol>
<li>这个只会关闭当前的服务器的检查，还是会检查其他的服务</li>
<li>在没有对应服务提供者的情况下如果调用这个服务那么将会报错</li>
<li>在消费者中配置</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDubbo</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		ClassPathXmlApplicationContext context=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"appliactionContext.xml"</span>);</div><div class="line">		IHelloService helloService=context.getBean(<span class="string">"helloService"</span>,IHelloService.class);</div><div class="line">        <span class="comment">//现在没有调用服务的情况下不会报错，但是如果调用了HelloService中的方法，那么将会报错</span></div><div class="line"><span class="comment">//		helloService.sayHello();</span></div><div class="line">		context.close();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>如果没有关闭检查，那么会出现如下的错误</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Exception in thread "main" org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'helloService': FactoryBean threw exception on object creation; nested exception is java.lang.IllegalStateException: Failed to check the status of the service cn.tedu.service.IHelloService. No provider available for the service cn.tedu.service.IHelloService from the url zookeeper://39.105.123.197:2181/com.alibaba.dubbo.registry.RegistryService?application=dubbo-consum01&amp;dubbo=2.5.3&amp;interface=cn.tedu.service.IHelloService&amp;methods=sayHello&amp;pid=10974&amp;revision=0.0.1&amp;side=consumer&amp;timestamp=1529667926718 to the consumer 10.18.236.4 use dubbo version 2.5.3</div><div class="line">	at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.doGetObjectFromFactoryBean(FactoryBeanRegistrySupport.java:175)</div><div class="line">	at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.getObjectFromFactoryBean(FactoryBeanRegistrySupport.java:103)</div><div class="line">	at org.springframework.beans.factory.support.AbstractBeanFactory.getObjectForBeanInstance(AbstractBeanFactory.java:1634)</div><div class="line">	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:254)</div><div class="line">	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202)</div><div class="line">	at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1086)</div><div class="line">	at TestDubbo.main(TestDubbo.java:9)</div><div class="line">Caused by: java.lang.IllegalStateException: Failed to check the status of the service cn.tedu.service.IHelloService. No provider available for the service cn.tedu.service.IHelloService from the url zookeeper://39.105.123.197:2181/com.alibaba.dubbo.registry.RegistryService?application=dubbo-consum01&amp;dubbo=2.5.3&amp;interface=cn.tedu.service.IHelloService&amp;methods=sayHello&amp;pid=10974&amp;revision=0.0.1&amp;side=consumer&amp;timestamp=1529667926718 to the consumer 10.18.236.4 use dubbo version 2.5.3</div><div class="line">	at com.alibaba.dubbo.config.ReferenceConfig.createProxy(ReferenceConfig.java:420)</div><div class="line">	at com.alibaba.dubbo.config.ReferenceConfig.init(ReferenceConfig.java:300)</div><div class="line">	at com.alibaba.dubbo.config.ReferenceConfig.get(ReferenceConfig.java:138)</div><div class="line">	at com.alibaba.dubbo.config.spring.ReferenceBean.getObject(ReferenceBean.java:65)</div><div class="line">	at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.doGetObjectFromFactoryBean(FactoryBeanRegistrySupport.java:168)</div><div class="line">	... 6 more</div></pre></td></tr></table></figure>
<h4 id="关闭所有服务的检查"><a href="#关闭所有服务的检查" class="headerlink" title="关闭所有服务的检查"></a>关闭所有服务的检查</h4><blockquote>
<p>关闭所有服务的检查</p>
<p>在消费者的配置文件中配置即可</p>
<p><code>&lt;dubbo:consumer check=&quot;false&quot; /&gt;</code></p>
</blockquote>
<h4 id="关闭注册中心启动时检查"><a href="#关闭注册中心启动时检查" class="headerlink" title="关闭注册中心启动时检查"></a>关闭注册中心启动时检查</h4><blockquote>
<p>注册订阅失败的时候报错</p>
<p><code>&lt;dubbo:registry check=&quot;false&quot; /&gt;</code></p>
</blockquote>
<h4 id="dubbo-properties"><a href="#dubbo-properties" class="headerlink" title="dubbo.properties"></a>dubbo.properties</h4><ul>
<li><p>在<code>src/main/resource</code>文件夹下新建<code>dubbo.properties</code></p>
</li>
<li><p><strong>在其中添加如下内容</strong></p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dubbo.reference.com.foo.BarService.check=false</div><div class="line">dubbo.reference.check=false</div><div class="line">dubbo.consumer.check=false</div><div class="line">dubbo.registry.check=false</div></pre></td></tr></table></figure>
</li>
<li><p><strong>只需要添加这个文件即可，会自动设置</strong></p>
</li>
</ul>
<h2 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h2><ul>
<li><p>这个在集群部署的时候会用到，比如多台机器提供的是同一个服务，那么当浏览器请求服务的时候到底该调用哪台机器上的服务才会更好，此时就需要用到负载均衡策略</p>
</li>
<li><p><a href="https://www.cnblogs.com/qingfengbuluo/p/5527930.html" target="_blank" rel="external">优秀博文</a></p>
</li>
</ul>
<h2 id="多协议"><a href="#多协议" class="headerlink" title="多协议"></a>多协议</h2><ul>
<li>在dubbo中存在8中不同的协议，这些协议的作用都是不同的，此时我们需要根据服务的功能来使用不同的协议，比如我们需要上传文件，那么就需要能够传输大文件的协议</li>
<li>默认是dubbo协议，也是用的最多的协议</li>
</ul>
<h3 id="不同服务不同协议"><a href="#不同服务不同协议" class="headerlink" title="不同服务不同协议"></a>不同服务不同协议</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 多协议配置 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"rmi"</span> <span class="attr">port</span>=<span class="string">"1099"</span> /&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 使用dubbo协议暴露服务，直接使用protocol关键词引用上面配置的协议 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.hello.api.HelloService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> <span class="attr">ref</span>=<span class="string">"helloService"</span> <span class="attr">protocol</span>=<span class="string">"dubbo"</span> /&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 使用rmi协议暴露服务 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.hello.api.DemoService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> <span class="attr">ref</span>=<span class="string">"demoService"</span> <span class="attr">protocol</span>=<span class="string">"rmi"</span> /&gt;</span></div></pre></td></tr></table></figure>
<h3 id="多协议暴露服务"><a href="#多协议暴露服务" class="headerlink" title="多协议暴露服务"></a>多协议暴露服务</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 多协议配置 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"hessian"</span> <span class="attr">port</span>=<span class="string">"8080"</span> /&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 使用多个协议暴露服务 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">id</span>=<span class="string">"helloService"</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.hello.api.HelloService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> <span class="attr">protocol</span>=<span class="string">"dubbo,hessian"</span> /&gt;</span></div></pre></td></tr></table></figure>
<h2 id="多版本"><a href="#多版本" class="headerlink" title="多版本"></a>多版本</h2><ul>
<li>当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。<br>可以按照以下的步骤进行版本迁移：<ol>
<li>在低压力时间段，先升级一半提供者为新版本</li>
<li>再将所有消费者升级为新版本</li>
<li>然后将剩下的一半提供者升级为新版本</li>
</ol>
</li>
<li>直接使用<code>version</code>指定版本即可</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li>我们有一个<code>HelloService</code>接口，但是有两个实现类，分别为<code>HelloServiceImpl1</code>,<code>HelloServiceImpl2</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl1</span> <span class="keyword">implements</span> <span class="title">IHelloService</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"say helloService1"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl2</span> <span class="keyword">implements</span> <span class="title">IHelloService</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"say helloservice2"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>配置服务提供者，需要根据版本的不同提供服务</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 配置应用名字，用来标识每一个应用，这里的name最好和工程名字一样 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"dubbo-provider01"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:application</span>&gt;</span></div><div class="line">	</div><div class="line">	<span class="comment">&lt;!-- 使用zookeeper注册中心暴露服务 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://39.105.123.197:2181"</span> /&gt;</span></div><div class="line">	</div><div class="line">	<span class="comment">&lt;!-- 配置服务的接口实现类，这样当提供服务调用的接口的时候才能找到对应的实现类 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloService1"</span> <span class="attr">class</span>=<span class="string">"cn.tedu.servivceImpl.HelloServiceImpl1"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">	</div><div class="line">	<span class="comment">&lt;!-- 配置服务的接口实现类，这样当提供服务调用的接口的时候才能找到对应的实现类 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloService2"</span> <span class="attr">class</span>=<span class="string">"cn.tedu.servivceImpl.HelloServiceImpl2"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">	</div><div class="line">    </div><div class="line">	<span class="comment">&lt;!-- 配置服务提供者,版本为1.0，使用的是helloService1实现类 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"cn.tedu.service.IHelloService"</span> <span class="attr">ref</span>=<span class="string">"helloService1"</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></div><div class="line">		</div><div class="line">	<span class="comment">&lt;!-- 配置服务提供者,版本为2.0，使用的是helloService2实现类 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"cn.tedu.service.IHelloService"</span> <span class="attr">ref</span>=<span class="string">"helloService2"</span> <span class="attr">version</span>=<span class="string">"2.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>配置服务消费者，需要指定版本号区分调用的服务<ul>
<li>根据版本号区分调用哪个服务</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--调用2.0版本的服务--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"helloService2"</span> <span class="attr">interface</span>=<span class="string">"cn.tedu.service.IHelloService"</span> <span class="attr">version</span>=<span class="string">"2.0"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--调用1.0版本的服务--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"helloService1"</span> <span class="attr">interface</span>=<span class="string">"cn.tedu.service.IHelloService"</span> <span class="attr">version</span>=<span class="string">"1.0"</span>/&gt;</span></div></pre></td></tr></table></figure>
<h2 id="服务分组"><a href="#服务分组" class="headerlink" title="服务分组"></a>服务分组</h2><ul>
<li>当一个接口有多种实现的时候，我们可以使用分组区分调用的服务功能</li>
<li>假设一个支付的接口<code>PayService</code>，其中实现的类有微信支付<code>WeChatPayServiceImpl</code>和支付宝支付<code>AliPayServiceImpl</code>,那么我们可以使用分组进行区分两种服务</li>
</ul>
<h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><ul>
<li>在服务提供者的配置文件中定义</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aliPayServiceImpl"</span> <span class="attr">class</span>=<span class="string">"cn.tedu.serviceImpl.AliPayServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"weChatPayServiceImpl"</span> <span class="attr">class</span>=<span class="string">"cn.tedu.serviceImpl.WeChatPayServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--使用group区分不同的服务功能 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">group</span>=<span class="string">"alipay"</span> <span class="attr">interface</span>=<span class="string">"cn.tedu.service.PayService"</span> <span class="attr">ref</span>=<span class="string">"aliPayServiceImpl"</span> /&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">group</span>=<span class="string">"weChatPay"</span> <span class="attr">interface</span>=<span class="string">"cn.tedu.service.PayService"</span> <span class="attr">ref</span>=<span class="string">"weChatPayServiceImpl"</span> /&gt;</span></div></pre></td></tr></table></figure>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul>
<li>在消费者的配置文件中配置即可，使用<code>group</code>指定需要引用的服务</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"alipayService"</span> <span class="attr">interface</span>=<span class="string">"cn.tedu.service.PayService"</span> <span class="attr">group</span>=<span class="string">"alipay"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"weChatPayService"</span> <span class="attr">interface</span>=<span class="string">"cn.tedu.service.PayService"</span> <span class="attr">group</span>=<span class="string">"weChatPay"</span>/&gt;</span></div></pre></td></tr></table></figure>
<h2 id="令牌验证"><a href="#令牌验证" class="headerlink" title="令牌验证"></a>令牌验证</h2><p>通过令牌验证在注册中心控制权限，以决定要不要下发令牌给消费者，可以防止消费者绕过注册中心访问提供者，另外通过注册中心可灵活改变授权方式，而不需修改或升级提供者</p>
<p><img src="http://dubbo.apache.org/books/dubbo-user-book/sources/images/dubbo-token.jpg" alt="/user-guide/images/dubbo-token.jpg"></p>
<p>可以全局设置开启令牌验证：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--随机token令牌，使用UUID生成--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">token</span>=<span class="string">"true"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--固定token令牌，相当于密码--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">token</span>=<span class="string">"123456"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>也可在服务级别设置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--随机token令牌，使用UUID生成--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">token</span>=<span class="string">"true"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--固定token令牌，相当于密码--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">token</span>=<span class="string">"123456"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>还可在协议级别设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!--随机token令牌，使用UUID生成--&gt;</div><div class="line">&lt;dubbo:protocol name=&quot;dubbo&quot; token=&quot;true&quot; /&gt;</div></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!--固定token令牌，相当于密码--&gt;</div><div class="line">&lt;dubbo:protocol name=&quot;dubbo&quot; token=&quot;123456&quot; /&gt;</div></pre></td></tr></table></figure>
<h2 id="dubbo控制台的安装部署"><a href="#dubbo控制台的安装部署" class="headerlink" title="dubbo控制台的安装部署"></a>dubbo控制台的安装部署</h2><ul>
<li>下载dubbo-admin.war : <strong>链接：<a href="https://pan.baidu.com/s/1ggeIIHX" target="_blank" rel="external">https://pan.baidu.com/s/1ggeIIHX</a> 密码：ck4h</strong></li>
<li><a href="https://blog.csdn.net/enson16855/article/details/9140771" target="_blank" rel="external">优秀博文</a></li>
</ul>
<h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><p>如果事件处理的逻辑能迅速完成，并且不会发起新的 IO 请求，比如只是在内存中记个标识，则直接在 IO 线程上处理更快，因为减少了线程池调度。</p>
<p>但如果事件处理逻辑较慢，或者需要发起新的 IO 请求，比如需要查询数据库，则必须派发到线程池，否则 IO 线程阻塞，将导致不能接收其它请求。</p>
<p>如果用 IO 线程处理事件，又在事件处理过程中发起新的 IO 请求，比如在连接事件中发起登录请求，会报“可能引发死锁”异常，但不会真死锁。</p>
<p><img src="http://dubbo.apache.org/books/dubbo-user-book/sources/images/dubbo-protocol.jpg" alt="dubbo-protocol"></p>
<p>因此，需要通过不同的派发策略和不同的线程池配置的组合来应对不同的场景:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">dispatcher</span>=<span class="string">"all"</span> <span class="attr">threadpool</span>=<span class="string">"fixed"</span> <span class="attr">threads</span>=<span class="string">"100"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>Dispatcher</p>
<ul>
<li><code>all</code> 所有消息都派发到线程池，包括请求，响应，连接事件，断开事件，心跳等。</li>
<li><code>direct</code> 所有消息都不派发到线程池，全部在 IO 线程上直接执行。</li>
<li><code>message</code> 只有请求响应消息派发到线程池，其它连接断开事件，心跳等消息，直接在 IO 线程上执行。</li>
<li><code>execution</code> 只请求消息派发到线程池，不含响应，响应和其它连接断开事件，心跳等消息，直接在 IO 线程上执行。</li>
<li><code>connection</code> 在 IO 线程上，将连接断开事件放入队列，有序逐个执行，其它消息派发到线程池。</li>
</ul>
<p>ThreadPool</p>
<ul>
<li><code>fixed</code> 固定大小线程池，启动时建立线程，不关闭，一直持有。(缺省)</li>
<li><code>cached</code> 缓存线程池，空闲一分钟自动删除，需要时重建。</li>
<li><code>limited</code> 可伸缩线程池，但池中的线程数只会增长不会收缩。只增长不收缩的目的是为了避免收缩时突然来了大流量引起的性能问题。</li>
<li><code>eager</code> 优先创建<code>Worker</code>线程池。在任务数量大于<code>corePoolSize</code>但是小于<code>maximumPoolSize</code>时，优先创建<code>Worker</code>来处理任务。当任务数量大于<code>maximumPoolSize</code>时，将任务放入阻塞队列中。阻塞队列充满时抛出<code>RejectedExecutionException</code>。(相比于<code>cached</code>:<code>cached</code>在任务数量超过<code>maximumPoolSize</code>时直接抛出异常而不是将任务放入阻塞队列)</li>
</ul>
<h2 id="多注册中心"><a href="#多注册中心" class="headerlink" title="多注册中心"></a>多注册中心</h2><p>Dubbo 支持同一服务向多注册中心同时注册，或者不同服务分别注册到不同的注册中心上去，甚至可以同时引用注册在不同注册中心上的同名服务。另外，注册中心是支持自定义扩展的 <a href="http://dubbo.apache.org/books/dubbo-user-book/demos/multi-registry.html#fn_1" target="_blank" rel="external">1</a>。</p>
<h3 id="多注册中心注册"><a href="#多注册中心注册" class="headerlink" title="多注册中心注册"></a>多注册中心注册</h3><p>比如：中文站有些服务来不及在青岛部署，只在杭州部署，而青岛的其它应用需要引用此服务，就可以将服务同时注册到两个注册中心。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"world"</span>  /&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 多注册中心配置 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">"hangzhouRegistry"</span> <span class="attr">address</span>=<span class="string">"10.20.141.150:9090"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">"qingdaoRegistry"</span> <span class="attr">address</span>=<span class="string">"10.20.141.151:9010"</span> <span class="attr">default</span>=<span class="string">"false"</span> /&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 向多个注册中心注册 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.hello.api.HelloService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> <span class="attr">ref</span>=<span class="string">"helloService"</span> <span class="attr">registry</span>=<span class="string">"hangzhouRegistry,qingdaoRegistry"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="不同服务使用不同注册中心"><a href="#不同服务使用不同注册中心" class="headerlink" title="不同服务使用不同注册中心"></a>不同服务使用不同注册中心</h3><p>比如：CRM 有些服务是专门为国际站设计的，有些服务是专门为中文站设计的。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"world"</span>  /&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 多注册中心配置 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">"chinaRegistry"</span> <span class="attr">address</span>=<span class="string">"10.20.141.150:9090"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">"intlRegistry"</span> <span class="attr">address</span>=<span class="string">"10.20.154.177:9010"</span> <span class="attr">default</span>=<span class="string">"false"</span> /&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 向中文站注册中心注册 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.hello.api.HelloService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> <span class="attr">ref</span>=<span class="string">"helloService"</span> <span class="attr">registry</span>=<span class="string">"chinaRegistry"</span> /&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 向国际站注册中心注册 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.hello.api.DemoService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> <span class="attr">ref</span>=<span class="string">"demoService"</span> <span class="attr">registry</span>=<span class="string">"intlRegistry"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="多注册中心引用"><a href="#多注册中心引用" class="headerlink" title="多注册中心引用"></a>多注册中心引用</h3><p>比如：CRM 需同时调用中文站和国际站的 PC2 服务，PC2 在中文站和国际站均有部署，接口及版本号都一样，但连的数据库不一样。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"world"</span>  /&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 多注册中心配置 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">"chinaRegistry"</span> <span class="attr">address</span>=<span class="string">"10.20.141.150:9090"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">"intlRegistry"</span> <span class="attr">address</span>=<span class="string">"10.20.154.177:9010"</span> <span class="attr">default</span>=<span class="string">"false"</span> /&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 引用中文站服务 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"chinaHelloService"</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.hello.api.HelloService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> <span class="attr">registry</span>=<span class="string">"chinaRegistry"</span> /&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 引用国际站站服务 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"intlHelloService"</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.hello.api.HelloService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> <span class="attr">registry</span>=<span class="string">"intlRegistry"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果只是测试环境临时需要连接两个不同注册中心，使用竖号分隔多个不同注册中心地址：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"world"</span>  /&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 多注册中心配置，竖号分隔表示同时连接多个不同注册中心，同一注册中心的多个集群地址用逗号分隔 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"10.20.141.150:9090|10.20.154.177:9010"</span> /&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 引用服务 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"helloService"</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.hello.api.HelloService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="分组聚合"><a href="#分组聚合" class="headerlink" title="分组聚合"></a>分组聚合</h2><p>按组合并返回结果 <a href="http://dubbo.apache.org/books/dubbo-user-book/demos/group-merger.html#fn_1" target="_blank" rel="external">1</a>，比如菜单服务，接口一样，但有多种实现，用group区分，现在消费方需从每种group中调用一次返回结果，合并结果返回，这样就可以实现聚合菜单项。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>搜索所有分组</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">"com.xxx.MenuService"</span> <span class="attr">group</span>=<span class="string">"*"</span> <span class="attr">merger</span>=<span class="string">"true"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>合并指定分组</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">"com.xxx.MenuService"</span> <span class="attr">group</span>=<span class="string">"aaa,bbb"</span> <span class="attr">merger</span>=<span class="string">"true"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>指定方法合并结果，其它未指定的方法，将只调用一个 Group</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">"com.xxx.MenuService"</span> <span class="attr">group</span>=<span class="string">"*"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"getMenuItems"</span> <span class="attr">merger</span>=<span class="string">"true"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></div></pre></td></tr></table></figure>
<p>某个方法不合并结果，其它都合并结果</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">"com.xxx.MenuService"</span> <span class="attr">group</span>=<span class="string">"*"</span> <span class="attr">merger</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"getMenuItems"</span> <span class="attr">merger</span>=<span class="string">"false"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></div></pre></td></tr></table></figure>
<p>指定合并策略，缺省根据返回值类型自动匹配，如果同一类型有两个合并器时，需指定合并器的名称 <a href="http://dubbo.apache.org/books/dubbo-user-book/demos/group-merger.html#fn_2" target="_blank" rel="external">2</a></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">"com.xxx.MenuService"</span> <span class="attr">group</span>=<span class="string">"*"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"getMenuItems"</span> <span class="attr">merger</span>=<span class="string">"mymerge"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></div></pre></td></tr></table></figure>
<p>指定合并方法，将调用返回结果的指定方法进行合并，合并方法的参数类型必须是返回结果类型本身</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">"com.xxx.MenuService"</span> <span class="attr">group</span>=<span class="string">"*"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"getMenuItems"</span> <span class="attr">merger</span>=<span class="string">".addAll"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="配置文件覆盖策略"><a href="#配置文件覆盖策略" class="headerlink" title="配置文件覆盖策略"></a>配置文件覆盖策略</h2><ul>
<li>消费者中的相同的配置将会覆盖提供者的配置</li>
<li><img src="https://images2015.cnblogs.com/blog/270324/201609/270324-20160910122039394-1078905366.png" alt=""></li>
</ul>
<h2 id="回声测试"><a href="#回声测试" class="headerlink" title="回声测试"></a>回声测试</h2><ul>
<li>回声测试用于检测服务是否可用，回声测试按照正常请求流程执行，能够测试整个调用是否通畅，可用于监控。所有服务自动实现 <code>EchoService</code> 接口，只需将任意服务引用强制转型为 <code>EchoService</code>，即可使用。</li>
<li>Spring 配置：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"memberService"</span> <span class="attr">interface</span>=<span class="string">"com.xxx.MemberService"</span> /&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 远程服务引用</span></div><div class="line">MemberService memberService = ctx.getBean(<span class="string">"memberService"</span>); </div><div class="line"></div><div class="line">EchoService echoService = (EchoService) memberService; <span class="comment">// 强制转型为EchoService</span></div><div class="line"></div><div class="line"><span class="comment">// 回声测试可用性</span></div><div class="line">String status = echoService.$echo(<span class="string">"OK"</span>); </div><div class="line"></div><div class="line"><span class="keyword">assert</span>(status.equals(<span class="string">"OK"</span>));</div></pre></td></tr></table></figure>
<h2 id="上下文信息"><a href="#上下文信息" class="headerlink" title="上下文信息"></a>上下文信息</h2><ul>
<li><code>RpcContext</code>是一个 <code>ThreadLocal</code>的临时状态记录器，当接收到 RPC 请求，或发起 RPC 请求时，RpcContext 的状态都会变化。比如：A 调 B，B 再调 C，则 B 机器上，在 B 调 C 之前，RpcContext 记录的是 A 调 B 的信息，在 B 调 C 之后，RpcContext 记录的是 B 调 C 的信息。</li>
<li>RpcContext的状态是随时变化的，只会存储最近调用的信息</li>
</ul>
<h3 id="服务消费方"><a href="#服务消费方" class="headerlink" title="服务消费方"></a>服务消费方</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDubbo</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		ClassPathXmlApplicationContext context=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"appliactionContext.xml"</span>);</div><div class="line">		IHelloService helloService=context.getBean(<span class="string">"helloService"</span>,IHelloService.class);</div><div class="line">		<span class="comment">//执行服务，只有执行服务才会认定为消费端</span></div><div class="line">		helloService.sayHello();</div><div class="line">		<span class="comment">//测试是否是消费者</span></div><div class="line">		Boolean flag=RpcContext.getContext().isConsumerSide();</div><div class="line">		System.out.println(flag);</div><div class="line">		<span class="comment">//获取提供者的ip地址</span></div><div class="line">		String ip=RpcContext.getContext().getRemoteHost();</div><div class="line">		System.out.println(ip);</div><div class="line">		<span class="comment">//获取调用者的名称，这里的application是&lt;dubbo:application&gt;标签中的名字</span></div><div class="line">		String parameters=RpcContext.getContext().getUrl().getParameter(<span class="string">"application"</span>);</div><div class="line">		System.out.println(parameters);</div><div class="line">		context.close();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="服务提供方"><a href="#服务提供方" class="headerlink" title="服务提供方"></a>服务提供方</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XxxServiceImpl</span> <span class="keyword">implements</span> <span class="title">XxxService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">xxx</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 本端是否为提供端，这里会返回true</span></div><div class="line">        <span class="keyword">boolean</span> isProviderSide = RpcContext.getContext().isProviderSide();</div><div class="line">        <span class="comment">// 获取调用方IP地址</span></div><div class="line">        String clientIP = RpcContext.getContext().getRemoteHost();</div><div class="line">        <span class="comment">// 获取当前服务配置信息，所有配置信息都将转换为URL的参数</span></div><div class="line">        String application = RpcContext.getContext().getUrl().getParameter(<span class="string">"application"</span>);</div><div class="line">        <span class="comment">// 注意：每发起RPC调用，上下文状态会变化</span></div><div class="line">        yyyService.yyy();</div><div class="line">        <span class="comment">// 此时本端变成消费端，这里会返回false</span></div><div class="line">        <span class="keyword">boolean</span> isProviderSide = RpcContext.getContext().isProviderSide();</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="隐式参数"><a href="#隐式参数" class="headerlink" title="隐式参数"></a>隐式参数</h2><blockquote>
<p>可以通过 <code>RpcContext</code> 上的 <code>setAttachment</code> 和 <code>getAttachment</code> 在服务消费方和提供方之间进行参数的隐式传递。 <a href="http://dubbo.apache.org/books/dubbo-user-book/demos/attachment.html#fn_1" target="_blank" rel="external">1</a></p>
</blockquote>
<p><img src="http://dubbo.apache.org/books/dubbo-user-book/sources/images/context.png" alt="/user-guide/images/context.png"></p>
<h3 id="在服务消费方端设置隐式参数"><a href="#在服务消费方端设置隐式参数" class="headerlink" title="在服务消费方端设置隐式参数"></a>在服务消费方端设置隐式参数</h3><blockquote>
<p><code>setAttachment</code> 设置的 KV 对，在完成下面一次远程调用会被清空，即多次远程调用要多次设置。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RpcContext.getContext().setAttachment(<span class="string">"index"</span>, <span class="string">"1"</span>); <span class="comment">// 隐式传参，后面的远程调用都会隐式将这些参数发送到服务器端，类似cookie，用于框架集成，不建议常规业务使用</span></div><div class="line">xxxService.xxx(); <span class="comment">// 远程调用</span></div><div class="line"><span class="comment">// ...</span></div></pre></td></tr></table></figure>
<h3 id="在服务提供方端获取隐式参数"><a href="#在服务提供方端获取隐式参数" class="headerlink" title="在服务提供方端获取隐式参数"></a>在服务提供方端获取隐式参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XxxServiceImpl</span> <span class="keyword">implements</span> <span class="title">XxxService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">xxx</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 获取客户端隐式传入的参数，用于框架集成，不建议常规业务使用</span></div><div class="line">        String index = RpcContext.getContext().getAttachment(<span class="string">"index"</span>); </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>注意：path, group, version, dubbo, token, timeout 几个 key 是保留字段，请使用其它值。<a href="http://dubbo.apache.org/books/dubbo-user-book/demos/attachment.html#reffn_1" target="_blank" rel="external"> ↩</a></li>
</ol>
</blockquote>
<h2 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h2><p>基于 NIO 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小。 <a href="http://dubbo.apache.org/books/dubbo-user-book/demos/async-call.html#fn_1" target="_blank" rel="external">1</a></p>
<p><img src="http://dubbo.apache.org/books/dubbo-user-book/sources/images/future.jpg" alt="/user-guide/images/future.jpg"></p>
<p>在 consumer.xml 中配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"fooService"</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.foo.FooService"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"findFoo"</span> <span class="attr">async</span>=<span class="string">"true"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"barService"</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.bar.BarService"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"findBar"</span> <span class="attr">async</span>=<span class="string">"true"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></div></pre></td></tr></table></figure>
<p>调用代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 此调用会立即返回null</span></div><div class="line">fooService.findFoo(fooId);</div><div class="line"><span class="comment">// 拿到调用的Future引用，当结果返回后，会被通知和设置到此Future</span></div><div class="line">Future&lt;Foo&gt; fooFuture = RpcContext.getContext().getFuture(); </div><div class="line"></div><div class="line"><span class="comment">// 此调用会立即返回null</span></div><div class="line">barService.findBar(barId);</div><div class="line"><span class="comment">// 拿到调用的Future引用，当结果返回后，会被通知和设置到此Future</span></div><div class="line">Future&lt;Bar&gt; barFuture = RpcContext.getContext().getFuture(); </div><div class="line"></div><div class="line"><span class="comment">// 此时findFoo和findBar的请求同时在执行，客户端不需要启动多线程来支持并行，而是借助NIO的非阻塞完成</span></div><div class="line"></div><div class="line"><span class="comment">// 如果foo已返回，直接拿到返回值，否则线程wait住，等待foo返回后，线程会被notify唤醒</span></div><div class="line">Foo foo = fooFuture.get(); </div><div class="line"><span class="comment">// 同理等待bar返回</span></div><div class="line">Bar bar = barFuture.get(); </div><div class="line"></div><div class="line"><span class="comment">// 如果foo需要5秒返回，bar需要6秒返回，实际只需等6秒，即可获取到foo和bar，进行接下来的处理。</span></div></pre></td></tr></table></figure>
<p>你也可以设置是否等待消息发出： <a href="http://dubbo.apache.org/books/dubbo-user-book/demos/async-call.html#fn_2" target="_blank" rel="external">2</a></p>
<ul>
<li><code>sent=&quot;true&quot;</code> 等待消息发出，消息发送失败将抛出异常。</li>
<li><code>sent=&quot;false&quot;</code> 不等待消息发出，将消息放入 IO 队列，即刻返回。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"findFoo"</span> <span class="attr">async</span>=<span class="string">"true"</span> <span class="attr">sent</span>=<span class="string">"true"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>如果你只是想异步，完全忽略返回值，可以配置 <code>return=&quot;false&quot;</code>，以减少 Future 对象的创建和管理成本：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"findFoo"</span> <span class="attr">async</span>=<span class="string">"true"</span> <span class="attr">return</span>=<span class="string">"false"</span> /&gt;</span></div></pre></td></tr></table></figure>
<blockquote>
<ol>
<li><p><code>2.0.6</code> 及其以上版本支持<a href="http://dubbo.apache.org/books/dubbo-user-book/demos/async-call.html#reffn_1" target="_blank" rel="external"> ↩</a></p>
</li>
<li><p>异步总是不等待返回<a href="http://dubbo.apache.org/books/dubbo-user-book/demos/async-call.html#reffn_2" target="_blank" rel="external"> ↩</a></p>
</li>
</ol>
</blockquote>
<h2 id="本地存根"><a href="#本地存根" class="headerlink" title="本地存根"></a>本地存根</h2><ul>
<li><p><strong>dubbo的本地存根的原理是：</strong>远程服务后，客户端通常只剩下接口，而实现全在服务器端，但提供方有些时候想在客户端也执行部分逻辑，那么就在服务消费者这一端提供了一个Stub类，然后当消费者调用provider方提供的dubbo服务时，客户端生成 Proxy 实例，这个Proxy实例就是我们正常调用dubbo远程服务要生成的代理实例，然后消费者这方会把 Proxy 通过构造函数传给 消费者方的Stub ，然后把 Stub 暴露给用户，Stub 可以决定要不要去调 Proxy。会通过代理类去完成这个调用，这样在Stub类中，就可以做一些额外的事，来对服务的调用过程进行优化或者容错的处理。附图：</p>
<p><img src="https://images2017.cnblogs.com/blog/296430/201801/296430-20180109111413879-348600461.png" alt="img"></p>
</li>
<li><p><strong>总结：如果消费者想用在调用远程服务的同时还想在之前或者之后实现自己的部分逻辑，那么就需要在消费者端定义一个代理类，其实在消费者调用服务的时候，实际上是调用的代理类。不过其中代理类返回的数据是可以传递给服务提供者的</strong></p>
</li>
</ul>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><p> <strong>1. 定义一个服务接口和服务实现类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserInterface</span> </span>&#123;</div><div class="line">    </div><div class="line">    </div><div class="line">       <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(Integer id)</span> </span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">implements</span> <span class="title">UserInterface</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(Integer id)</span> </span>&#123;</div><div class="line">        User user  = <span class="keyword">new</span> User() ;</div><div class="line">        user.setId(id);</div><div class="line">        user.setName(<span class="string">"hu"</span>);</div><div class="line">        <span class="keyword">return</span> user;</div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>服务分布配置</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dubbo:service</span>  <span class="attr">interface</span>=<span class="string">"org.huxin.dubbo.test.user.service.UserInterface"</span> <span class="attr">ref</span>=<span class="string">"userService"</span> <span class="attr">protocol</span>=<span class="string">"dubbo"</span>    <span class="attr">retries</span>=<span class="string">"0"</span>/&gt;</span></div><div class="line">        </div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"org.huxin.dubbo.test.user.service.impl.UserService"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>3.服务消费者的Stub类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceStub</span> <span class="keyword">implements</span> <span class="title">UserInterface</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//必须定义这个接口，以便接收dubbo在调用远程服务生成的服务代理类</span></div><div class="line">    <span class="keyword">private</span> UserInterface userLocalService ;</div><div class="line">    </div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">//这个构造函数必须要提供，dubbo框架会在消费者这一方调用这个方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceStub</span><span class="params">(UserInterface userLocalService )</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.userLocalService = userLocalService  ;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(Integer id)</span> </span>&#123;</div><div class="line"></div><div class="line">　　　　　　　　User user = <span class="keyword">null</span> ;</div><div class="line">　　　　　　　　<span class="keyword">try</span> &#123;</div><div class="line">　　　　　　　　　　<span class="keyword">if</span> (id == <span class="number">1</span>) &#123;</div><div class="line">　　　　　　　　　　　　user = <span class="keyword">this</span>.userLocalService.getUserById(id) ;</div><div class="line">　　　　　　　　　　&#125;<span class="keyword">else</span> &#123;</div><div class="line">　　　　　　　　　　　　user = <span class="keyword">new</span> User(); </div><div class="line">　　　　　　　　　　　　user.setName(<span class="string">"系统用户"</span>);</div><div class="line">　　　　　　　　　　&#125;</div><div class="line">　　　　　　　　&#125;<span class="keyword">catch</span>(Exception e) &#123;</div><div class="line">　　　　　　　　　　user = <span class="keyword">new</span> User(); </div><div class="line">　　　　　　　　　　user.setName(<span class="string">"异常用户"</span>);</div><div class="line">　　　　　　　　&#125;</div><div class="line"></div><div class="line">              <span class="keyword">return</span> user ;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>服务消费方的配置</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">interface</span>=<span class="string">"org.huxin.dubbo.test.user.service.UserInterface"</span> </span></div><div class="line">                   <span class="attr">stub</span>=<span class="string">"org.huxin.dubbo.test.UserServiceStub"</span> <span class="attr">protocol</span>=<span class="string">"dubbo"</span>/&gt;</div></pre></td></tr></table></figure>
<p>5.测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetUserById</span><span class="params">()</span></span>&#123;</div><div class="line">        Integer id = <span class="number">2</span> ;</div><div class="line">            UserInterface  userService = context.getBean(UserInterface.class) ;</div><div class="line">        User user = userService.getUserById( id) ;</div><div class="line">        System.out.println(user.getName()); </div><div class="line">         </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>实际上调用<code>getUserById(id)</code>这个方法是代理类<code>UserServiceStub</code>的方法，返回的User对象也是这个这个方法返回的</li>
</ul>
<h2 id="本地伪装"><a href="#本地伪装" class="headerlink" title="本地伪装"></a>本地伪装</h2><ul>
<li><a href="http://dubbo.apache.org/books/dubbo-user-book/demos/local-mock.html" target="_blank" rel="external">本地伪装</a></li>
</ul>
<h2 id="延迟暴露"><a href="#延迟暴露" class="headerlink" title="延迟暴露"></a>延迟暴露</h2><ul>
<li><a href="http://dubbo.apache.org/books/dubbo-user-book/demos/delay-publish.html" target="_blank" rel="external">延迟暴露</a></li>
</ul>
<h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><ul>
<li><a href="http://dubbo.apache.org/books/dubbo-user-book/demos/concurrency-control.html" target="_blank" rel="external">并发控制</a></li>
</ul>
<h2 id="连接控制"><a href="#连接控制" class="headerlink" title="连接控制"></a>连接控制</h2><ul>
<li>限制连接个数</li>
<li><a href="http://dubbo.apache.org/books/dubbo-user-book/demos/concurrency-control.html" target="_blank" rel="external">连接控制</a></li>
</ul>
<h2 id="延迟连接"><a href="#延迟连接" class="headerlink" title="延迟连接"></a>延迟连接</h2><ul>
<li><a href="http://dubbo.apache.org/books/dubbo-user-book/demos/lazy-connect.html" target="_blank" rel="external">延迟连接</a></li>
</ul>
<h2 id="粘滞连接"><a href="#粘滞连接" class="headerlink" title="粘滞连接"></a>粘滞连接</h2><p>粘滞连接用于有状态服务，尽可能让客户端总是向同一提供者发起调用，除非该提供者挂了，再连另一台。</p>
<p>粘滞连接将自动开启<a href="http://dubbo.apache.org/books/dubbo-user-book/demos/lazy-connect.html" target="_blank" rel="external">延迟连接</a>，以减少长连接数。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">sticky</span>=<span class="string">"true"</span> /&gt;</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Dubbo常见问题&quot;&gt;&lt;a href=&quot;#Dubbo常见问题&quot; class=&quot;headerlink&quot; title=&quot;Dubbo常见问题&quot;&gt;&lt;/a&gt;Dubbo常见问题&lt;/h1&gt;&lt;h2 id=&quot;官方文档&quot;&gt;&lt;a href=&quot;#官方文档&quot; class=&quot;headerli
    
    </summary>
    
      <category term="Dubbo" scheme="http://chenjiabing666.github.io/categories/Dubbo/"/>
    
    
      <category term="Dubbo" scheme="http://chenjiabing666.github.io/tags/Dubbo/"/>
    
  </entry>
  
</feed>
