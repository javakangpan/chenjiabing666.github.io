<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>爱撒谎的男孩</title>
  <subtitle>一只程序猿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chenjiabing666.github.io/"/>
  <updated>2020-04-01T02:38:57.101Z</updated>
  <id>http://chenjiabing666.github.io/</id>
  
  <author>
    <name>Chenjiabing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>接口幂等性如何设计？</title>
    <link href="http://chenjiabing666.github.io/2020/04/01/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%EF%BC%9F/"/>
    <id>http://chenjiabing666.github.io/2020/04/01/接口幂等性如何设计？/</id>
    <published>2020-04-01T02:38:34.000Z</published>
    <updated>2020-04-01T02:38:57.101Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>现在这个时代大家可能最关心的就是钱了，那么有没有想过你银行转账给你没有一次是转多的，要么失败，要么成功，为什么不能失误一下多转一笔呢？醒醒吧年轻人，别做梦了，做银行的能那么傻x吗？</li>
<li>今天我们就来谈一谈为什么银行转账不能多给我转一笔？关乎到钱的问题，小伙伴们打起精神！！！</li>
<li>要想要理解上述的疑惑，不得不提的一个概念就是幂等性，至于什么是幂等性，如何通过代码实现幂等性，下面将会详细讲述。</li>
</ul>
<h2 id="什么是幂等性"><a href="#什么是幂等性" class="headerlink" title="什么是幂等性"></a>什么是幂等性</h2><ul>
<li>所谓幂等性通俗的将就是一次请求和多次请求同一个资源产生相同的副作用。用数学语言表达就是<code>f(x)=f(f(x))</code>。</li>
<li>维基百科的幂等性定义如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。</div><div class="line">在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“setTrue()”函数就是一个幂等函数,无论多次执行，其结果都是一样的，更复杂的操作幂等保证是利用唯一交易号(流水号)实现.</div></pre></td></tr></table></figure>
<h2 id="为什么需要幂等性"><a href="#为什么需要幂等性" class="headerlink" title="为什么需要幂等性"></a>为什么需要幂等性</h2><ul>
<li>在系统高并发的环境下，很有可能因为网络，阻塞等等问题导致客户端或者调用方并不能及时的收到服务端的反馈甚至是调用超时的问题。总之，就是请求方调用了你的服务，但是没有收到任何的信息，完全懵逼的状态。比如订单的问题，可能会遇到如下的几个问题：</li>
</ul>
<ol>
<li>创建订单时，第一次调用服务超时，再次调用是否产生两笔订单？</li>
<li>订单创建成功去减库存时，第一次减库存超时，是否会多扣一次？</li>
<li>订单支付时，服务端扣钱成功，但是接口反馈超时，此时再次调用支付，是否会多扣一笔呢？</li>
</ol>
<ul>
<li>作为消费者，前两种能接受，第三种情况就MMP了，哈哈哈！！！这种情况一般有如下两种解决方式</li>
</ul>
<ol>
<li>服务方提供一个查询操作是否成功的api，第一次超时之后，调用方调用查询接口，如果查到了就走成功的流程，失败了就走失败的流程。</li>
<li>另一种就是服务方需要使用幂等的方式保证一次和多次的请求结果一致。</li>
</ol>
<h2 id="HTTP的幂等性"><a href="#HTTP的幂等性" class="headerlink" title="HTTP的幂等性"></a>HTTP的幂等性</h2><ul>
<li>GET：只是获取资源，对资源本身没有任何副作用，天然的幂等性。</li>
<li>HEAD：本质上和GET一样，获取头信息，主要是探活的作用，具有幂等性。</li>
<li>OPTIONS：获取当前URL所支持的方法，因此也是具有幂等性的。</li>
<li>DELETE：用于删除资源，有副作用，但是它应该满足幂等性，比如根据id删除某一个资源，调用方可以调用N次而不用担心引起的错误（根据业务需求而变）。</li>
<li>PUT：用于更新资源，有副作用，但是它应该满足幂等性，比如根据id更新数据，调用多次和N次的作用是相同的（根据业务需求而变）。</li>
<li>POST：用于添加资源，多次提交很可能产生副作用，比如订单提交，多次提交很可能产生多笔订单。</li>
</ul>
<h2 id="幂等性的实现方式"><a href="#幂等性的实现方式" class="headerlink" title="幂等性的实现方式"></a>幂等性的实现方式</h2><ul>
<li>对于客户端交互的接口，可以在前端拦截一部分，例如防止表单重复提交，按钮置灰，隐藏，不可点击等方式。但是前端进行拦截器显然是针对普通用户，懂点技术的都可以模拟请求调用接口，所以后端幂等性很重要。</li>
<li>后端的幂等性如何实现？将会从以下几个方面介绍。</li>
</ul>
<h3 id="数据库去重表"><a href="#数据库去重表" class="headerlink" title="数据库去重表"></a>数据库去重表</h3><ul>
<li>在往数据库中插入数据的时候，利用数据库唯一索引特性，保证数据唯一。比如订单的流水号，也可以是多个字段的组合。</li>
<li>实现比较简单，读者可以自己实现看看，这里不再提供demo了。</li>
</ul>
<h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><ul>
<li>很多业务中多有多个状态，比如订单的状态有提交、待支付、已支付、取消、退款等等状态。后端可以根据不同的状态去保证幂等性，比如在退款的时候，一定要保证这笔订单是已支付的状态。</li>
<li>业务中常常出现，读者可以自己实现看看，不再提供demo。</li>
</ul>
<h3 id="TOKEN机制"><a href="#TOKEN机制" class="headerlink" title="TOKEN机制"></a>TOKEN机制</h3><ul>
<li>针对客户端连续点击或者调用方的超时重试等情况，例如提交订单，此种操作就可以用Token的机制实现防止重复提交。</li>
<li>TOKEN机制如何实现？简单的说就是调用方在调用接口的时候先向后端请求一个全局ID（TOKEN），请求的时候携带这个全局ID一起请求，后端需要对这个全局ID校验来保证幂等操作，流程如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/repeat/1.png" alt=""></p>
<ul>
<li>主要的流程步骤如下：<ul>
<li>客户端先发送获取token的请求，服务端会生成一个全局唯一的ID保存在redis中，同时把这个ID返回给客户端。</li>
<li>客户端调用业务请求的时候必须携带这个token，一般放在请求头上。</li>
<li>服务端会校验这个Token，如果校验成功，则执行业务。</li>
<li>如果校验失败，则表示重复操作，直接返回指定的结果给客户端。</li>
</ul>
</li>
<li>通过以上的流程分析，唯一的重点就是这个全局唯一ID如何生成，在分布式服务中往往都会有一个生成全局ID的服务来保证ID的唯一性，但是工程量和实现难度比较大，UUID的数据量相对有些大，此处陈某选择的是雪花算法生成全局唯一ID，不了解雪花算法的读者下一篇文章会着重介绍。</li>
</ul>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul>
<li>陈某选择的环境是SpringBoot+Redis单机环境+注解+拦截器的方式实现，只是演示一下思想，具体的代码可以参照实现。</li>
<li>redis如何实现，获取Token接口将全局唯一Id存入Redis（一定要设置失效时间，根据业务需求），业务请求的时候直接从redis中删除，根据delete的返回值判断，返回true表示第一次请求，返回false表示重复请求。代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenServiceImpl</span> <span class="keyword">implements</span> <span class="title">TokenService</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getToken</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//获取全局唯一id</span></div><div class="line">        <span class="keyword">long</span> nextId = SnowflakeUtil.nextId();</div><div class="line">        <span class="comment">//存入redis，设置10分钟失效</span></div><div class="line">        stringRedisTemplate.opsForValue().set(String.valueOf(nextId), UUID.randomUUID().toString(),<span class="number">10</span>, TimeUnit.MINUTES);</div><div class="line">        <span class="keyword">return</span> String.valueOf(nextId);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">    * 删除记录，true表示第一次提交，false重复提交</div><div class="line">    */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">checkToken</span><span class="params">(String token)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> stringRedisTemplate.delete(token);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>注解的实现如下，标注在controller类上表示当前类上全部接口都做幂等，标注单个方法上，表示单个接口做幂等操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Description</span> 幂等操作的注解</div><div class="line"> * <span class="doctag">@Author</span> CJB</div><div class="line"> * <span class="doctag">@Date</span> 2020/3/25 10:19</div><div class="line"> */</div><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RepeatLimiter &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>请求头的拦截器，用于提取请求头和校验请求头，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Description</span> 获取请求头的信息，具体校验逻辑读者自己实现</div><div class="line"> * <span class="doctag">@Author</span> CJB</div><div class="line"> * <span class="doctag">@Date</span> 2020/3/25 11:09</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderIntercept</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//获取token</span></div><div class="line">        String token = request.getHeader(HeaderConstant.TOKEN);</div><div class="line">        <span class="comment">//校验逻辑</span></div><div class="line">        <span class="keyword">if</span> (!validToken(token))</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TokenInvalidException(<span class="string">"TOKEN失效"</span>);</div><div class="line">        <span class="comment">//获取其他的参数.....</span></div><div class="line">        RequestHeader header = RequestHeader.builder()</div><div class="line">                .token(token)</div><div class="line">                .build();</div><div class="line">        <span class="comment">//放入request中</span></div><div class="line">        request.setAttribute(HeaderConstant.HEADER_INFO,header);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 校验token，逻辑自己实现</div><div class="line">     * <span class="doctag">@param</span> token</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validToken</span><span class="params">(String token)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> Boolean.TRUE;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>保证幂等性的拦截器，直接从redis中删除token，成功则第一次提交，不成功则重复提交。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepeatIntercept</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> TokenService tokenService;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> HandlerMethod)&#123;</div><div class="line">            <span class="comment">//获取方法上的参数</span></div><div class="line">            RepeatLimiter repeatLimiter = AnnotationUtils.findAnnotation(((HandlerMethod) handler).getMethod(), RepeatLimiter.class);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (Objects.isNull(repeatLimiter))&#123;</div><div class="line">                <span class="comment">//获取controller类上注解</span></div><div class="line">                repeatLimiter=AnnotationUtils.findAnnotation(((HandlerMethod) handler).getBean().getClass(),RepeatLimiter.class);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//使用注解，需要拦截验证</span></div><div class="line">            <span class="keyword">if</span> (Objects.nonNull(repeatLimiter))&#123;</div><div class="line">                <span class="comment">//获取全局token，表单提交的唯一id</span></div><div class="line">                RequestHeader info = RequestContextUtils.getHeaderInfo();</div><div class="line"></div><div class="line">                <span class="comment">//没有携带token，抛异常，这里的异常需要全局捕获</span></div><div class="line">                <span class="keyword">if</span> (StringUtils.isEmpty(info.getToken()))</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RepeatException();</div><div class="line"></div><div class="line">                <span class="comment">//校验token</span></div><div class="line">                Boolean flag = tokenService.checkToken(info.getToken());</div><div class="line"></div><div class="line">                <span class="comment">//删除失败，表示</span></div><div class="line">                <span class="keyword">if</span> (Boolean.FALSE.equals(flag))</div><div class="line">                    <span class="comment">//抛出重复提交的异常</span></div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RepeatException();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>接口幂等实现，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/order"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> OrderService orderService;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 下单</div><div class="line">     * <span class="doctag">@param</span> order</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@PostMapping</span></div><div class="line">    <span class="meta">@RepeatLimiter</span>  <span class="comment">//幂等性保证</span></div><div class="line">    <span class="function"><span class="keyword">public</span> CommenResult <span class="title">add</span><span class="params">(@RequestBody Order order)</span></span>&#123;</div><div class="line">        orderService.save(order);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommenResult(<span class="string">"200"</span>,<span class="string">"下单成功"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><ul>
<li>发送getToken的请求获取Token</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/repeat/2.png" alt=""></p>
<ul>
<li>携带Token下单第一次：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/repeat/3.png" alt=""></p>
<ul>
<li>第二次下单：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/repeat/4.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;现在这个时代大家可能最关心的就是钱了，那么有没有想过你银行转账给你没有一次是转多的，要么失败，要么成功，为什么不能失误一下多转一
    
    </summary>
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Mysql性能优化：什么是索引下推？</title>
    <link href="http://chenjiabing666.github.io/2020/04/01/Mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%EF%BC%9F/"/>
    <id>http://chenjiabing666.github.io/2020/04/01/Mysql性能优化：什么是索引下推？/</id>
    <published>2020-04-01T02:37:30.000Z</published>
    <updated>2020-04-01T02:37:58.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>索引下推（index condition pushdown ）简称ICP，在Mysql5.6的版本上推出，用于优化查询。</li>
<li>在不使用ICP的情况下，在使用非主键索引（又叫普通索引或者二级索引）进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件 。</li>
<li>在使用ICP的情况下，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。</li>
<li>索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。 </li>
</ul>
<h2 id="开撸"><a href="#开撸" class="headerlink" title="开撸"></a>开撸</h2><ul>
<li>在开始之前先先准备一张用户表(user)，其中主要几个字段有：id、name、age、address。建立联合索引（name，age）。</li>
<li>假设有一个需求，要求匹配姓名第一个为陈的所有用户，sql语句如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span>  <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'陈%'</span></div></pre></td></tr></table></figure>
<ul>
<li>根据 “最佳左前缀” 的原则，这里使用了联合索引（name，age）进行了查询，性能要比全表扫描肯定要高。</li>
<li>问题来了，如果有其他的条件呢？假设又有一个需求，要求匹配姓名第一个字为陈，年龄为20岁的用户，此时的sql语句如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span>  <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'陈%'</span> <span class="keyword">and</span> age=<span class="number">20</span></div></pre></td></tr></table></figure>
<ul>
<li>这条sql语句应该如何执行呢？下面对Mysql5.6之前版本和之后版本进行分析。</li>
</ul>
<h3 id="Mysql5-6之前的版本"><a href="#Mysql5-6之前的版本" class="headerlink" title="Mysql5.6之前的版本"></a>Mysql5.6之前的版本</h3><ul>
<li>5.6之前的版本是没有索引下推这个优化的，因此执行的过程如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/1.png" alt=""></p>
<ul>
<li>会忽略age这个字段，直接通过name进行查询，在(name,age)这课树上查找到了两个结果，id分别为2,1，然后拿着取到的id值一次次的回表查询，因此这个过程需要<strong>回表两次</strong>。</li>
</ul>
<h3 id="Mysql5-6及之后版本"><a href="#Mysql5-6及之后版本" class="headerlink" title="Mysql5.6及之后版本"></a>Mysql5.6及之后版本</h3><ul>
<li>5.6版本添加了索引下推这个优化，执行的过程如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/2.png" alt=""></p>
<ul>
<li>InnoDB并没有忽略age这个字段，而是在索引内部就判断了age是否等于20，对于不等于20的记录直接跳过，因此在(name,age)这棵索引树中只匹配到了一个记录，此时拿着这个id去主键索引树中回表查询全部数据，这个过程只需要回表一次。</li>
</ul>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><ul>
<li>当然上述的分析只是原理上的，我们可以实战分析一下，因此陈某装了Mysql5.6版本的Mysql，解析了上述的语句，如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/3.png" alt=""></p>
<ul>
<li>根据explain解析结果可以看出Extra的值为<strong>Using index condition</strong>，表示已经使用了索引下推。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>索引下推在<strong>非主键索引</strong>上的优化，可以有效减少回表的次数，大大提升了查询的效率。</li>
<li>关闭索引下推可以使用如下命令，配置文件的修改不再讲述了，毕竟这么优秀的功能干嘛关闭呢：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">set</span> optimizer_switch=<span class="string">'index_condition_pushdown=off'</span>;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;索引下推（index condition pushdown ）简称ICP，在Mysql5.6的版本上推出，用于优化查询。&lt;/li
    
    </summary>
    
      <category term="数据库干货篇" scheme="http://chenjiabing666.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B2%E8%B4%A7%E7%AF%87/"/>
    
    
      <category term="SQL" scheme="http://chenjiabing666.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Mysql性能优化：为什么使用覆盖索引?</title>
    <link href="http://chenjiabing666.github.io/2020/04/01/Mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95/"/>
    <id>http://chenjiabing666.github.io/2020/04/01/Mysql性能优化：为什么使用覆盖索引/</id>
    <published>2020-04-01T02:36:34.000Z</published>
    <updated>2020-04-01T02:36:54.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li><p>相信读者看过很多MYSQL索引优化的文章，其中有很多优化的方法，比如最佳左前缀，覆盖索引等方法，但是你真正理解为什么要使用最佳左前缀，为什么使用覆盖索引会提升查询的效率吗？</p>
</li>
<li><p>本篇文章将从MYSQL内部结构上讲一下为什么覆盖索引能够提升效率。</p>
</li>
</ul>
<h2 id="InnoDB索引模型"><a href="#InnoDB索引模型" class="headerlink" title="InnoDB索引模型"></a>InnoDB索引模型</h2><ul>
<li>在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。</li>
<li>每一个索引在InnoDB里面对应一棵B+树。</li>
</ul>
<h2 id="主键索引和非主键索引的区别"><a href="#主键索引和非主键索引的区别" class="headerlink" title="主键索引和非主键索引的区别"></a>主键索引和非主键索引的区别</h2><ul>
<li>主键索引又叫聚簇索引 ，非主键索引又叫普通索引，那么这两种索引有什么区别呢？</li>
<li>主键索引的叶子节点存放的是整行数据，非主键索引的叶子节点存放的是主键的值。</li>
<li>假设有一张User表（id,age,name,address），其中有id和age两个字段，其中id是主键，age是普通索引，有几行数据u1-u5的(id,age)的值是(100,1)、(200,2)、(300,3)、(500,5)和(600,6) ，此时的两棵树的示例如下：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95/1.png" alt=""></p>
<ul>
<li>从上图可以看出来，基于主键索引的树的叶子节点存放的是整行User数据，基于普通索引age的叶子节点存放的是id（主键）的值。</li>
</ul>
<h2 id="什么是回表？"><a href="#什么是回表？" class="headerlink" title="什么是回表？"></a>什么是回表？</h2><ul>
<li>假设有一条查询语句如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age=<span class="number">3</span>;</div></pre></td></tr></table></figure>
<ul>
<li><p>上面这条sql语句执行的过程如下：</p>
<p>1、根据age这个普通索引在age索引树上搜索，得到主键id的值为300。</p>
<p>2、因为age索引树并没有存储User的全部数据，因此需要根据在age索引树上查询到的主键id的值300再到id索引树搜索一次，查询到了u3。</p>
<p>3、返回结果。</p>
</li>
<li><p>上述执行的过程中，从age索引树再到id索引树的查询的过程叫做回表（回到主键索引树搜索的过程）。</p>
</li>
<li><p>也就是说通过非主键索引的查询需要多扫描一棵索引树，因此需要尽量使用主键索引查询。</p>
</li>
</ul>
<h2 id="为什么使用覆盖索引？"><a href="#为什么使用覆盖索引？" class="headerlink" title="为什么使用覆盖索引？"></a>为什么使用覆盖索引？</h2><ul>
<li>有了上述提及到的几个概念，便能很清楚的理解为什么覆盖索引能够提升查询效率了，因为少了一次回表的过程。</li>
<li>假设我们使用覆盖索引查询，语句如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select id from user where age=3;</div></pre></td></tr></table></figure>
<ul>
<li>这条语句执行过程很简单，直接在age索引树中就能查询到id的值，不用再去id索引树中查找其他的数据，避免了回表。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>覆盖索引的使用能够减少树的搜索次数，避免了回表，显著提升了查询性能，因此覆盖索引是一个常用的性能优化手段。</li>
<li>留给读者一个问题：身份证是一个人的唯一识别凭证，如果有根据身份证号查询市民信息的需求，我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？ </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;相信读者看过很多MYSQL索引优化的文章，其中有很多优化的方法，比如最佳左前缀，覆盖索引等方法，但是你真正理解为什么要使用
    
    </summary>
    
      <category term="数据库干货篇" scheme="http://chenjiabing666.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B2%E8%B4%A7%E7%AF%87/"/>
    
    
      <category term="SQL" scheme="http://chenjiabing666.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>一条查询语句到底是如何执行的?</title>
    <link href="http://chenjiabing666.github.io/2020/04/01/%E4%B8%80%E6%9D%A1%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/"/>
    <id>http://chenjiabing666.github.io/2020/04/01/一条查询语句到底是如何执行的/</id>
    <published>2020-04-01T02:35:30.000Z</published>
    <updated>2020-04-01T02:35:49.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li><p>Mysql在中小型企业中是个香饽饽，目前主流的数据库之一，几乎没有一个后端开发者不会使用的，但是作为一个老司机，仅仅会用真的不够。</p>
</li>
<li><p>今天陈某透过一个简单的查询语句来讲述在Mysql内部的执行过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select * from table where id=10;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="撸它"><a href="#撸它" class="headerlink" title="撸它"></a>撸它</h2><ul>
<li>首先通过一张图片来了解一下Mysql的基础架构，如下：</li>
</ul>
<p>  <img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/MYSQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/1.png" alt=""></p>
<ul>
<li>从上图可以看出，Mysql大致分为Server层和存储引擎层两部分。</li>
<li>Server层包括连接器、查询缓存、分析器、优化器等，其中包含了Mysql的大多数核心功能以及所有的内置函数（如日期，时间函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</li>
<li>存储引擎层负责数据的存储和提取。它的架构是可插拔式的，支持InnoDB、MyISAM等多个存储引擎。Mysql中主流的存储引擎是InnoDB，由于它对事务的支持让它从Mysql5.5.5版本开始成为了默认的存储引擎。</li>
<li>大致了解了整体架构，现在说说每一个基础的模块都承担着怎样的责任。</li>
</ul>
<h3 id="1-连接器"><a href="#1-连接器" class="headerlink" title="1. 连接器"></a>1. 连接器</h3><ul>
<li><p>顾名思义，是客户端和Mysql之间连接的媒介，负责登录、获取权限、维持连接和管理连接。连接命令一般如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql [-h] ip [- P] port -u [user] -p</div></pre></td></tr></table></figure>
</li>
<li><p>在完成经典的TCP握手后，连接器会开始认证身份，要求输入密码。</p>
<ul>
<li>密码认证通过，连接器会查询出拥有的权限，即使管理员修改了权限，也不会影响你这次的连接，只有重新连接才会生效。</li>
<li>密码认证失败，会收到提示信息Access denied for user。</li>
</ul>
</li>
<li><p>连接完成后，没有后续动作的连接将会变成空闲连接，你可以输入<code>show processlist</code>命令看到它。如下图，其中的Command这一列显示为sleep的这一行表示在系统里面有一个空闲连接。</p>
</li>
</ul>
<p>  <img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/MYSQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/2.png" alt=""></p>
<ul>
<li><p>客户端如果太长时间没有执行动作，连接器将会自动断开，这个时间由参数<code>wait_timeout</code>控制，默认值是8小时。</p>
</li>
<li><p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p>
</li>
</ul>
<h3 id="2-查询缓存【废材，8-0-版本完全删除】"><a href="#2-查询缓存【废材，8-0-版本完全删除】" class="headerlink" title="2. 查询缓存【废材，8.0 版本完全删除】"></a>2. 查询缓存【废材，8.0 版本完全删除】</h3><ul>
<li><p>连接建立完成后，你就可以select语句了，执行之前会查询缓存。</p>
</li>
<li><p>查询缓存在Mysql中的是默认关闭的，因为缓存命中率非常低，只要有对表执行一个更新操作，这个表的所有查询缓存都将被清空。怎么样？一句废材足以形容了！！！</p>
</li>
<li><p>废材的东西不必多讲，主流的Redis的缓存你不用，别再搞这废材了。</p>
</li>
</ul>
<h3 id="3-分析器"><a href="#3-分析器" class="headerlink" title="3. 分析器"></a>3. 分析器</h3><ul>
<li><p>如果没有命中查询缓存，就要执行查询了，但是在执行查询之前，需要对SQL语句做解析，判断你这条语句有没有语法错误。</p>
</li>
<li><p>分析器会做 ‘词法分析’ ，你输入的无非可就是多个字符串和空格组成的SQL语句，MYSQL需要识别出里面的字符串是什么，代表什么，有没有关键词等。</p>
</li>
<li><p>MYSQL会从你输入的select 这个关键字识别出来是一个查询语句，table是表名，id是列名。</p>
</li>
<li><p>做完这些会做 ‘语法分析’ ，根据MYSQL定义的规则来判断你的SQL语句有没有语法错误，如果你的语法不对，就会收到类似如下的提醒：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;elect * from t where ID=1&apos; at line 1</div></pre></td></tr></table></figure>
</li>
<li><p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。</p>
</li>
</ul>
<h3 id="4-优化器"><a href="#4-优化器" class="headerlink" title="4. 优化器"></a>4. 优化器</h3><ul>
<li><p>经过分析器词法和语法的分析，此时就能知道这条SQL语句是干什么的。但是在开始执行之前，MYSQL底层还要使用优化器对这条SQL语句进行优化处理。</p>
</li>
<li><p>MYSQL内部会对这条SQL进行评估，比如涉及到多个索引会比较使用哪个索引代价更小、多表join的时候会考虑决定各个表的连接顺序。</p>
</li>
<li><p>优化器的作用一句话总结：根据MYSQL内部的算法决定如何执行这条SQL语句来达到MYSQL认为代价最小目的。</p>
</li>
<li><p>优化器阶段完成后，这个语句的执行方案就确定了，接下来就交给执行器执行了。</p>
</li>
</ul>
<h3 id="5-执行器"><a href="#5-执行器" class="headerlink" title="5. 执行器"></a>5. 执行器</h3><ul>
<li><p>MYSQL通过分析器知道了要做什么，通过优化器知道了如何做，于是就进入了执行器阶段。</p>
</li>
<li><p>执行器开始执行之前，需要检查一下用户对表table有没有执行的权限，没有返回权限不足的错误，有的话就执行。</p>
</li>
<li><p>执行也是分类的，如果Id不是索引则全表扫描，一行一行的查找，如果是索引则在索引组织表中查询，索引的查询很复杂，其中涉及到B+树等算法，这里不再详细介绍。</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>一条SQL语句在MYSQL内部执行的过程涉及到的内部模块有：连接器、查询缓存、分析器、优化器、执行器、存储引擎。</p>
</li>
<li><p>至此，MYSQL的基础架构已经讲完了。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Mysql在中小型企业中是个香饽饽，目前主流的数据库之一，几乎没有一个后端开发者不会使用的，但是作为一个老司机，仅仅会用真
    
    </summary>
    
      <category term="数据库干货篇" scheme="http://chenjiabing666.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B2%E8%B4%A7%E7%AF%87/"/>
    
    
      <category term="SQL" scheme="http://chenjiabing666.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Mysql中的三类锁，你知道吗？</title>
    <link href="http://chenjiabing666.github.io/2020/04/01/Mysql%E4%B8%AD%E7%9A%84%E4%B8%89%E7%B1%BB%E9%94%81%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F/"/>
    <id>http://chenjiabing666.github.io/2020/04/01/Mysql中的三类锁，你知道吗？/</id>
    <published>2020-04-01T02:31:58.000Z</published>
    <updated>2020-04-01T02:34:41.438Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li><p>正所谓有人(锁)的地方就有江湖(事务)，人在江湖飘，怎能一无所知？</p>
</li>
<li><p>今天来细说一下Mysql中的三类锁，分别是全局锁、表级锁、行级锁。</p>
</li>
</ul>
<h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><ul>
<li>全局锁简单的说就是锁住整个数据库实例，命令是<code>Flush tables with read lock</code>。当你需要为整个数据库处于只读的状态的时候，可以使用这个命令。</li>
<li>一旦使用全局锁，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。 </li>
<li>全局锁的使用场景大部分都是用来<strong>数据库备份</strong>。</li>
</ul>
<h3 id="为什么备份要加全局锁？"><a href="#为什么备份要加全局锁？" class="headerlink" title="为什么备份要加全局锁？"></a>为什么备份要加全局锁？</h3><ul>
<li>用户买东西，首先会从余额里扣除金额，然后在订单里添加商品。如果备份数据库，不加锁，并且备份顺序为先备份用余额，再备份订单商品，有可能备份了用户余额后，用户下订单买东西提交事务，然后再备份订单商品表， 此时订单商品已存在。最后备份出来的数据为。最后用户余额为买东西前的余额，没有减少，但是订单商品却多了。演示如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/1.png" alt=""></p>
<ul>
<li>这种情况可能用户会觉得赚了，但是如果备份顺序反过来，先备份商品表再备份余额表，用户就会发现我付了钱，但是商品没有加，这中结果就会更加的严重。 </li>
<li>因此保证备份数据的一致性很重要，必要的手段就是加锁。</li>
</ul>
<h3 id="全局锁有什么坏处？"><a href="#全局锁有什么坏处？" class="headerlink" title="全局锁有什么坏处？"></a>全局锁有什么坏处？</h3><ul>
<li>全局锁是个啥？介绍完了读者心里已经有数了，让这个库只读？这是多么可怕的操作，简单列举几个危险之处：<ul>
<li>如果在主库备份，备份期间不能执行任何更新操作，会导致整个业务停摆，高并发情况下更甚。</li>
<li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。</li>
</ul>
</li>
</ul>
<h3 id="全局备份比较好的解决方案"><a href="#全局备份比较好的解决方案" class="headerlink" title="全局备份比较好的解决方案"></a>全局备份比较好的解决方案</h3><ul>
<li>全局锁远瞅不错，近瞅吓一跳，陈某在此不推荐使用。</li>
<li>其实 官方自带的逻辑备份工具是mysqldump。当<strong>mysqldump</strong>使用参数<strong>–single-transaction</strong>的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。 </li>
<li>一致性备份是好，但前提是存储引擎支持事务，这也是MyISAM被InnoDB取代的原因之一。</li>
</ul>
<h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><ul>
<li>MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。 </li>
<li>表锁一般是在数据库引擎不支持行锁的时候才会被用到的 。</li>
<li>MDL会直到事务提交才释放，在做<strong>表结构变更</strong>的时候，你一定要小心不要导致锁住线上查询和更新 。</li>
</ul>
<h3 id="如何加表锁"><a href="#如何加表锁" class="headerlink" title="如何加表锁"></a>如何加表锁</h3><ul>
<li>显式加表锁和解锁的语句很简单，如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">lock</span> <span class="keyword">tables</span> tb_name <span class="keyword">read</span>/write;</div><div class="line"></div><div class="line"><span class="keyword">unlock</span> <span class="keyword">tables</span>;</div></pre></td></tr></table></figure>
<ul>
<li>需要注意，lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。 </li>
<li>举个例子, 如果在某个线程A中执行<strong>lock tables t1 read, t2 write;</strong> 这个语句，则其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行<strong>unlock tables</strong>之前，也只能执行读t1、读写t2的操作。连写t1都不允许，自然也不能访问其他表。 </li>
</ul>
<h3 id="MDL"><a href="#MDL" class="headerlink" title="MDL"></a>MDL</h3><ul>
<li>MDL不需要显式使用，在访问一个表的时候会被自动加上。 </li>
<li>当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。 </li>
<li><strong>读锁</strong>之间不互斥，因此你可以有多个线程同时对一张表增删改查。 </li>
<li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。 </li>
</ul>
<h3 id="查询表级锁争用"><a href="#查询表级锁争用" class="headerlink" title="查询表级锁争用"></a>查询表级锁争用</h3><ul>
<li>查询表级锁的争用可以通过以下参数分析获得：<ul>
<li><code>Table_locks_immediate</code>：能够立即获得表级锁的次数 </li>
<li><code>Table_locks_waited</code>： 不能立即获取表级锁而需要等待的次数 </li>
</ul>
</li>
<li>查询语句如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'table_locks_waited'</span></div></pre></td></tr></table></figure>
<ul>
<li>如果<code>Table_locks_waited</code>的值比较大，则说明存在着较严重的表级锁争用情况。 </li>
</ul>
<h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><ul>
<li>MySQL的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如MyISAM引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB是支持行锁的，这也是MyISAM被InnoDB替代的重要原因之一。 </li>
<li><strong>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁</strong>。 </li>
<li><strong>在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。</strong> </li>
<li>行级锁分为排它锁（写锁）、共享锁（读锁）、间隙锁。</li>
</ul>
<h3 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h3><ul>
<li>排他锁，也称写锁，独占锁，当前写操作没有完成前，它会阻断其他写锁和读锁。 </li>
<li>Mysql中的更新语句(update/delete/insert)会自动加上排它锁。</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/2.png" alt=""></p>
<ul>
<li>如上图，事务B中的update语句被阻塞了，直到事务A提交才能执行更新操作。</li>
<li>排他锁也可以手动添加，如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</div></pre></td></tr></table></figure>
<ul>
<li>注意以下两点：<ul>
<li>行锁是针对索引加锁的，上述例子中id是主键索引。</li>
<li><strong>加了排他锁并不是其他的事务不能读取这行的数据，而是不能再在这行上面加锁了。</strong></li>
</ul>
</li>
</ul>
<h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><ul>
<li>当我们用范围条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但<strong>并不存在</strong>的记录，叫做”间隙(GAP)”。InnoDB也会对这个”间隙”加锁，这种锁机制就是所谓的间隙锁(Next-Key锁)。 </li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/3.png" alt=""></p>
<ul>
<li>如上图，给id&gt;5中并不存在的数据加上了间隙锁，当插入id=6的数据时被阻塞了。</li>
<li>这是一个坑：<strong>若执行的条件是范围过大，则InnoDB会将整个范围内所有的索引键值全部锁定，很容易对性能造成影响</strong> </li>
</ul>
<h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3><ul>
<li>共享锁，也称读锁，多用于判断数据是否存在，多个读操作可以同时进行而不会互相影响。当如果事务对读锁进行修改操作，很可能会造成死锁。如下图所示。 </li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/4.png" alt=""></p>
<h3 id="分析行锁定"><a href="#分析行锁定" class="headerlink" title="分析行锁定"></a>分析行锁定</h3><ul>
<li>通过检查InnoDB_row_lock 状态变量分析系统上的行锁的争夺情况 。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'innodb_row_lock%'</span></div></pre></td></tr></table></figure>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/5.png" alt=""></p>
<ul>
<li>innodb_row_lock_current_waits: 当前正在等待锁定的数量。</li>
<li>innodb_row_lock_time: 从系统启动到现在锁定总时间长度；非常重要的参数</li>
<li>innodb_row_lock_time_avg: 每次等待所花平均时间；非常重要的参数。</li>
<li>innodb_row_lock_time_max: 从系统启动到现在等待最常的一次所花的时间； </li>
<li>innodb_row_lock_waits: 系统启动后到现在总共等待的次数；非常重要的参数。直接决定优化的方向和策略。 </li>
</ul>
<h3 id="死锁解决方案"><a href="#死锁解决方案" class="headerlink" title="死锁解决方案"></a>死锁解决方案</h3><p>1、直接进入等待，直到超时。这个超时时间可以通过参数<strong>innodb_lock_wait_timeout</strong>来设置，默认50秒。注意超时时间不能设置太短，如果仅仅是短暂的等待，一旦设置时间很短，很快便解锁了，会出现误伤。</p>
<p>2、发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数<strong>innodb_deadlock_detect</strong>设置为on，表示开启这个逻辑，默认开启。 主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。 当并发很高的时候，检测死锁将会消耗大量的资源，因此控制并发也是很重要的一种策略。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;正所谓有人(锁)的地方就有江湖(事务)，人在江湖飘，怎能一无所知？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;今天来细说一下Mys
    
    </summary>
    
      <category term="数据库干货篇" scheme="http://chenjiabing666.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B2%E8%B4%A7%E7%AF%87/"/>
    
    
      <category term="SQL" scheme="http://chenjiabing666.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>IDEA调试技巧</title>
    <link href="http://chenjiabing666.github.io/2020/03/23/IDEA%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
    <id>http://chenjiabing666.github.io/2020/03/23/IDEA调试技巧/</id>
    <published>2020-03-23T08:15:12.000Z</published>
    <updated>2020-03-23T08:15:44.491Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>前天面试了一个985高校的实习生，问了他平时用什么开发工具，他想也没想的说IDEA，于是我抛砖引玉的问了一下IDEA的调试用过吧，你说说怎么设置断点条件？那孩子懵了，想了好一会对我说没用过，甚至都没听说过这个。</li>
<li>作为一名资深的老司机，IDEA调试可以说是家常便饭，如果不会debug，我都不信你读过源码，就别和我说原理了，直接pass掉。</li>
</ul>
<h2 id="基本界面"><a href="#基本界面" class="headerlink" title="基本界面"></a>基本界面</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODU2MTU0LzIwMTcwOS84NTYxNTQtMjAxNzA5MDUyMjE0MTgxNDctMTIwNTA0MzAyMC5wbmc" alt=""></p>
<p>① 以Debug模式启动服务，左边的一个按钮则是以Run模式启动。在开发中，我一般会直接启动Debug模式，方便随时调试代码。 </p>
<p>② 断点：在左边行号栏单击左键，或者快捷键Ctrl+F8 打上/取消断点，断点行的颜色可自己去设置。 </p>
<p>③ Debug窗口：访问请求到达第一个断点后，会自动激活Debug窗口。如果没有自动激活，可以去设置里设置。</p>
<p>④ 调试按钮：一共有8个按钮，调试的主要功能就对应着这几个按钮，鼠标悬停在按钮上可以查看对应的快捷键。</p>
<p>⑤ 服务按钮：可以在这里关闭/启动服务，设置断点等。 </p>
<p>⑥ 方法调用栈：这里显示了该线程调试所经过的所有方法，勾选右上角的[Show All Frames]按钮，就不会显示其它类库的方法了，否则这里会有一大堆的方法。 </p>
<p>⑦ Variables：在变量区可以查看当前断点之前的当前方法内的变量。 </p>
<p>⑧  Watches：查看变量，可以将Variables区中的变量拖到Watches中查看 。</p>
<h2 id="变量查看"><a href="#变量查看" class="headerlink" title="变量查看"></a>变量查看</h2><ul>
<li>在调试过程中往往需要观察变量的变化来判断业务逻辑，我们可以在以下的四个地方观察。</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032301.png" alt=""></p>
<p>① 最常用的变量的观察区域variables</p>
<p>② IDEA中最人性化的地方之一，会将变量的值阴影显示在变量的后面。</p>
<p>③ watch区域，眼镜的形状，一般不会展开。如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032302.png" alt=""></p>
<p>点击’+’号可以新增需要观察的变量，点击’-‘号可以删除。</p>
<p>④ 鼠标悬停在变量上也会出现变量的值，点击展开即可查看。</p>
<h2 id="计算表达式"><a href="#计算表达式" class="headerlink" title="计算表达式"></a>计算表达式</h2><ul>
<li>在调试业务逻辑的时候一般总会遇到某个条件或者某个变量的计算值的还不知道的情况下就需要判断下一行代码，那么此处就需要用到计算表达式的功能。计算表达式有两种方法，如下：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032303.png" alt=""></p>
<p>① 选择需要计算的代码，鼠标右键—-&gt;Evaluate Expression—&gt;Evaluate即可计算。</p>
<p>② 直接点击计算器形状控件即可弹出计算的窗口，将代码复制进去即可，注意复制进去的代码一定要符合逻辑，比如局部变量一定要是已经声明的。</p>
<h2 id="断点条件设置"><a href="#断点条件设置" class="headerlink" title="断点条件设置"></a>断点条件设置</h2><ul>
<li>对于新手要看Spring源码的话，再遇到调试UserService的doGetBean的方法时可能要崩溃，因为doGetBean在容器启动的时候可能会被调用几十次，你把断点打在doGetBean方法体中能让你生不如死。</li>
<li>设置断点条件有两种方式：<ul>
<li>①直接在断点上右键，添加condition条件即可。</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032304.png" alt=""></li>
<li>② view breakpoints(ctrl+shift+8)显示所有的断点，在condition中添加条件即可。</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032305.png" alt=""></li>
</ul>
</li>
</ul>
<ul>
<li>异常断点：设置了异常断点后，比如空指针异常，在程序出现需要拦截的异常时会自动定位到指定的行。如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032306.png" alt=""></p>
<p>① ctrl+shift+F8显示所有断点，点击+号添加<code>Java Exception Breakpoints</code>。</p>
<p>② debug运行，一旦有代码出现该异常，会自动定位到指定代码。</p>
<h2 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h2><ul>
<li>通常我们在调试的时候，一个请求过来被拦截了，此时想要发起另外一个请求是无法重新发的，因为另外一个请求被阻塞了，只有当前线程执行完成之后才会走其他的线程。在IDEA中可以改变一下阻塞级别，有两种方法：<ul>
<li>断点上右键—&gt;选择Thread—-&gt;Make Default，如下图：</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032307.png" alt=""></li>
<li>显示所有断点(crtl+shift+F8)，选中某一个断点，选择Thread，Make Default即可。如下图：</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032308.png" alt=""></li>
</ul>
</li>
<li>设置了阻塞级别，此时就可以在线程切换了，如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032309.png" alt=""></p>
<h2 id="强制抛异常"><a href="#强制抛异常" class="headerlink" title="强制抛异常"></a>强制抛异常</h2><p>这是IDEA 2018年加入的新功能，可以直接在调试中抛出指定的异常。使用方法跟上面的弃栈帧类似，右击栈帧并选择<strong>Throw Exception</strong>，然后输入抛异常的代码，比如<code>throw new NullPointerException</code>，操作如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032310.png" alt=""></p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032311.png" alt=""></p>
<h2 id="强制返回"><a href="#强制返回" class="headerlink" title="强制返回"></a>强制返回</h2><ul>
<li>这是IDEA2015版时增加的功能，类似上面的手动抛异常，只不过是返回一个指定值罢了。使用方法跟上面也都类似，右击栈帧并选择<strong>Force Return</strong>，然后输入要返回的值即可。如果是<code>void</code>的方法那就更简单了，连返回值都不用输。如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032312.png" alt=""></p>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;前天面试了一个985高校的实习生，问了他平时用什么开发工具，他想也没想的说IDEA，于是我抛砖引玉的问了一下IDEA的调试用过吧
    
    </summary>
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Spring生命周期</title>
    <link href="http://chenjiabing666.github.io/2020/03/23/Spring%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://chenjiabing666.github.io/2020/03/23/Spring生命周期/</id>
    <published>2020-03-23T02:13:32.000Z</published>
    <updated>2020-03-23T02:15:15.480Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>Spring中Bean的生命周期从容器的启动到停止，涉及到的源码主要是在<code>org.springframework.context.support.AbstractApplicationContext.refresh</code>方法中，下面也是围绕其中的逻辑进行讲解。</li>
</ul>
<h2 id="开撸"><a href="#开撸" class="headerlink" title="开撸"></a>开撸</h2><p>【1】 prepareRefresh()</p>
<p> 内部其实很简单，就是设置一些标志，比如开始时间，激活的状态等。</p>
<p>【2】prepareBeanFactory(beanFactory)</p>
<p>做一些简单的准备工作，此处不再赘述！！！</p>
<p>【3】postProcessBeanFactory(beanFactory)</p>
<p>主要的作用就是添加了一个后置处理器<code>ServletContextAwareProcessor</code></p>
<p>【4】invokeBeanFactoryPostProcessors(beanFactory)</p>
<p>调用容器中的所有的<strong>BeanFactoryPostProcessor</strong>中的<strong>postProcessBeanFactory</strong>方法，按照优先级调用，主要实现逻辑在org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List<org.springframework.beans.factory.config.beanfactorypostprocessor>)<br>    (1) 执行所有BeanDefinitionRegistryPostProcessor(对BeanFactoryPostProcessor的扩展，运行在普通的实现类之前注册bean)的方法，同样是内部按照优先级进行排序调用<br>    (2) 对剩余的进行按照优先级排序调用，同样是内部进行排序执行</org.springframework.beans.factory.config.beanfactorypostprocessor></p>
<p>【5】<strong>registerBeanPostProcessors(beanFactory)</strong></p>
<p>注册所有的<strong>BeanPostProcessor</strong>（后置处理器），按照优先级注册，分别是PriorityOrdered，Ordered，普通的，内部的。主要的实现逻辑在PostProcessorRegistrationDelegate.registerBeanPostProcessors()</p>
<p>【6】initMessageSource()<br>注册MessageSource,提供消息国际化等功能</p>
<p>【7】initApplicationEventMulticaster();</p>
<p>注册事件广播器ApplicationEventMulticaster，用于spring事件的广播和事件监听器的处理</p>
<p>【8】registerListeners()</p>
<p>注册事件监听器ApplicationListener，并且广播一些早期的事件，主要的逻辑在org.springframework.context.support.AbstractApplicationContext.registerListeners</p>
<p>【9】finishBeanFactoryInitialization(beanFactory)</p>
<p>实例化所有非懒加载的Bean，spring生命周期中的主要方法，主要逻辑在org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons，深入进去其实就是getBean()方法创建，详情向下看。</p>
<p>【10】finishRefresh()</p>
<p>主要的功能是发布事件ContextRefreshedEvent</p>
<p>【11】destroyBeans()</p>
<p>容器启动出现异常时销毁Bean</p>
<p>以上就是Spring容器启动的过程，主要的逻辑都在org.springframework.context.support.AbstractApplicationContext#refresh中，其他的都很容易理解，现在我们着重分析一下单例Bean的创建过程，入口是第9步。</p>
<h2 id="实例化单例Bean"><a href="#实例化单例Bean" class="headerlink" title="实例化单例Bean"></a>实例化单例Bean</h2><p>【1】debug进入，实际主要的逻辑都在org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons方法中，逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取所有注入到ioc容器中的bean定义信息</span></div><div class="line">List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</div><div class="line">		<span class="comment">//循环创建</span></div><div class="line">		<span class="keyword">for</span> (String beanName : beanNames) &#123;</div><div class="line">			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</div><div class="line">            <span class="comment">//非抽象，单例，非懒加载的bean初始化</span></div><div class="line">			<span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</div><div class="line">                <span class="comment">//如果是FactoryBean</span></div><div class="line">				<span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</div><div class="line">                    <span class="comment">//getBean</span></div><div class="line">					Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</div><div class="line">                    <span class="comment">//非FactoryBean，getBean</span></div><div class="line">				<span class="keyword">else</span> &#123;</div><div class="line">					getBean(beanName);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<p>以上源码总结得知，最终实例化Bean的方法肯定在getBean中的，debug进入，得知doGetBean是大boss，spring源码有趣的是最终的实现都是在doxxxx()。</p>
<p>【2】AbstractBeanFactory#doGetBean，由于篇幅太短，就不贴源码了，只贴关键代码</p>
<p>实例化的主要流程全部都在这里，下面一一解析即可。</p>
<p>(1) Object sharedInstance = getSingleton(beanName)</p>
<p>从早期的缓存中获取，如果存在返回Bean，实例化</p>
<p>（2）BeanFactory parentBeanFactory = getParentBeanFactory()</p>
<p>从父工厂的中获取Bean</p>
<p>（3）if (mbd.isSingleton()) </p>
<p>分单例和多例进行分开创建Bean，这里只分析单例Bean的创建</p>
<p>（4）sharedInstance = getSingleton(beanName, () -&gt; {   try {      return createBean(beanName, mbd, args);   }</p>
<p>createBean方法创建Bean，进入createBean(）</p>
<p>​    a. Object bean = resolveBeforeInstantiation(beanName, mbdToUse)：执行所有的InstantiationAwareBeanPostProcessor中的<strong>postProcessBeforeInstantiation</strong>，在实例化之前调用，返回null继续下一步，返回一个bean，那么bean实例化完成，将调用其中的<strong>postProcessAfterInstantiation</strong>方法</p>
<p>​       b. Object beanInstance = doCreateBean(beanName, mbdToUse, args)：创建Bean的完成过程</p>
<p>​    c. 进入<strong>doCreateBean</strong>，instanceWrapper = createBeanInstance(beanName, mbd, args)：创建Bean的实例</p>
<p>​    d. populateBean(beanName, mbd, instanceWrapper)：属性装配，执行InstantiationAwareBeanPostProcessor的<strong>postProcessAfterInstantiation</strong>，再执行<strong>postProcessProperties</strong>方法。</p>
<p>​    e. exposedObject = initializeBean(beanName, exposedObject, mbd)：初始化Bean，debug进入</p>
<p>​    f. invokeAwareMethods(beanName, bean)：调用<strong>BeanNameAware</strong>，<strong>BeanClassLoaderAware</strong>，<strong>BeanFactoryAware</strong>中的对应方法</p>
<p>​    g. wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName)：调用BeanPostProcessord中的<strong>postProcessBeforeInitialization</strong>方法</p>
<p>​    h. invokeInitMethods(beanName, wrappedBean, mbd)：执行<strong>InitializingBean</strong>中的<strong>afterPropertiesSet</strong></p>
<p>​    i. wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName)：调用<strong>BeanPostProcessor</strong>中的<strong>postProcessAfterInitialization</strong>方法</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上是spring容器从启动到销毁的全部过程，根据源码陈某画了一张生命周期的图，仅供参考，请勿转载！！！</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/lifecy.png" alt=""></p>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Spring中Bean的生命周期从容器的启动到停止，涉及到的源码主要是在&lt;code&gt;org.springframework.co
    
    </summary>
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>接口限流算法</title>
    <link href="http://chenjiabing666.github.io/2020/03/23/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/"/>
    <id>http://chenjiabing666.github.io/2020/03/23/接口限流算法/</id>
    <published>2020-03-23T01:38:58.000Z</published>
    <updated>2020-03-23T01:39:56.213Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>前几天和一个朋友讨论了他们公司的系统问题，传统的单体应用，集群部署，他说近期服务的并发量可能会出现瞬时增加的风险，虽然部署了集群，但是通过压测后发现请求延迟仍然是很大，想问问我有什么改进的地方。我沉思了一会，现在去改架构显然是不可能的，于是我给出了一个建议，让他去做个接口限流，这样能够保证瞬时并发量飙高也不会出现请求延迟的问题，用户的体验度也会上去。</li>
<li>至于什么是接口限流？怎么实现接口限流？如何实现单机应用的限流？如何实现分布式应用的限流？本篇文章将会详细阐述。</li>
</ul>
<h2 id="限流的常见几种算法"><a href="#限流的常见几种算法" class="headerlink" title="限流的常见几种算法"></a>限流的常见几种算法</h2><ul>
<li>常见的限流算法有很多，但是最常用的算法无非以下四种。</li>
</ul>
<h3 id="固定窗口计数器"><a href="#固定窗口计数器" class="headerlink" title="固定窗口计数器"></a>固定窗口计数器</h3><p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/8ded7a2b90e1482093f92fff555b3615.png" alt=""></p>
<ul>
<li>固定算法的概念如下</li>
</ul>
<ol>
<li>将时间划分为多个窗口</li>
<li>在每个窗口内每有一次请求就将计数器加一</li>
<li>如果计数器超过了限制数量，则本窗口内所有的请求都被丢弃当时间到达下一个窗口时，计数器重置。</li>
</ol>
<ul>
<li>固定窗口计数器是最为简单的算法，但这个算法有时会让通过请求量允许为限制的两倍。考虑如下情况：限制 1 秒内最多通过 5 个请求，在第一个窗口的最后半秒内通过了 5 个请求，第二个窗口的前半秒内又通过了 5 个请求。这样看来就是在 1 秒内通过了 10 个请求。 </li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/4d03e8e43a8edc3f32376d90e52b85f4.png" alt=""></p>
<h3 id="滑动窗口计数器"><a href="#滑动窗口计数器" class="headerlink" title="滑动窗口计数器"></a>滑动窗口计数器</h3><p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/ae4d3cd14efb8dc7046d691c90264715.png" alt=""></p>
<ul>
<li>滑动窗口计数器算法概念如下：</li>
</ul>
<ol>
<li>将时间划分为多个区间；</li>
<li>在每个区间内每有一次请求就将计数器加一维持一个时间窗口，占据多个区间；</li>
<li>每经过一个区间的时间，则抛弃最老的一个区间，并纳入最新的一个区间；</li>
<li>如果当前窗口内区间的请求计数总和超过了限制数量，则本窗口内所有的请求都被丢弃。</li>
</ol>
<ul>
<li>滑动窗口计数器是通过将窗口再细分，并且按照时间 “ 滑动 “，这种算法避免了固定窗口计数器带来的双倍突发请求，但时间区间的精度越高，算法所需的空间容量就越大。</li>
</ul>
<h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/75938d1010138ce66e38c6ed0392f103.png" alt=""></p>
<ul>
<li>漏桶算法概念如下：</li>
</ul>
<ol>
<li>将每个请求视作 “ 水滴 “ 放入 “ 漏桶 “ 进行存储；</li>
<li>“漏桶 “ 以固定速率向外 “ 漏 “ 出请求来执行如果 “ 漏桶 “ 空了则停止 “ 漏水”；</li>
<li>如果 “ 漏桶 “ 满了则多余的 “ 水滴 “ 会被直接丢弃。</li>
</ol>
<ul>
<li>漏桶算法多使用队列实现，服务的请求会存到队列中，服务的提供方则按照固定的速率从队列中取出请求并执行，过多的请求则放在队列中排队或直接拒绝。</li>
<li>漏桶算法的缺陷也很明显，当短时间内有大量的突发请求时，即便此时服务器没有任何负载，每个请求也都得在队列中等待一段时间才能被响应。</li>
</ul>
<h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/eca0e5eaa35dac938c673fecf2ec9a93.png" alt=""></p>
<ul>
<li>令牌桶算法概念如下：</li>
</ul>
<ol>
<li>令牌以固定速率生成。</li>
<li>生成的令牌放入令牌桶中存放，如果令牌桶满了则多余的令牌会直接丢弃，当请求到达时，会尝试从令牌桶中取令牌，取到了令牌的请求可以执行。</li>
<li>如果桶空了，那么尝试取令牌的请求会被直接丢弃。</li>
</ol>
<ul>
<li>令牌桶算法既能够将所有的请求平均分布到时间区间内，又能接受服务器能够承受范围内的突发请求，因此是目前使用较为广泛的一种限流算法。 </li>
</ul>
<h2 id="单体应用实现"><a href="#单体应用实现" class="headerlink" title="单体应用实现"></a>单体应用实现</h2><ul>
<li>在传统的单体应用中限流只需要考虑到多线程即可，使用Google开源工具类guava即可。其中有一个RateLimiter专门实现了单体应用的限流，使用的是令牌桶算法。</li>
<li>单体应用的限流不是本文的重点，官网上现成的API，读者自己去看看即可，这里不再详细解释。</li>
</ul>
<h2 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h2><ul>
<li>分布式限流和熔断现在有很多的现成的工具，比如Hystrix，Sentinel  等，但是还是有些企业不引用外来类库，因此就需要自己实现。</li>
<li>Redis作为单线程多路复用的特性，很显然能够胜任这项任务。</li>
</ul>
<h3 id="Redis如何实现"><a href="#Redis如何实现" class="headerlink" title="Redis如何实现"></a>Redis如何实现</h3><ul>
<li>使用令牌桶的算法实现，根据前面的介绍，我们了解到令牌桶算法的基础需要两个个变量，分别是桶容量，产生令牌的速率。</li>
<li>这里我们实现的就是每秒产生的速率加上一个桶容量。但是如何实现呢？这里有几个问题。</li>
<li><p>需要保存什么数据在redis中？</p>
<ul>
<li>当前桶的容量，最新的请求时间</li>
</ul>
</li>
<li>以什么数据结构存储？<ul>
<li>因为是针对接口限流，每个接口的业务逻辑不同，对并发的处理也是不同，因此要细化到每个接口的限流，此时我们选用HashMap的结构，hashKey是接口的唯一id，可以是请求的uri，里面的分别存储当前桶的容量和最新的请求时间。</li>
</ul>
</li>
<li>如何计算需要放令牌？<ul>
<li>根据redis保存的上次的请求时间和当前时间比较，如果相差大于的<strong>产生令牌的时间（陈某实现的是1秒）</strong>则再次产生令牌，此时的桶容量为当前令牌+产生的令牌</li>
</ul>
</li>
<li>如何保证redis的原子性？<ul>
<li>保证redis的原子性，使用lua脚本即可解决。</li>
</ul>
</li>
<li>有了上述的几个问题，便能很容易的实现。</li>
</ul>
<h3 id="开撸"><a href="#开撸" class="headerlink" title="开撸"></a>开撸</h3><p>1、lua脚本如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">local</span> ratelimit_info = redis.<span class="built_in">pcall</span>(<span class="string">'HMGET'</span>,KEYS[<span class="number">1</span>],<span class="string">'last_time'</span>,<span class="string">'current_token'</span>)</div><div class="line"><span class="keyword">local</span> last_time = ratelimit_info[<span class="number">1</span>]</div><div class="line"><span class="keyword">local</span> current_token = <span class="built_in">tonumber</span>(ratelimit_info[<span class="number">2</span>])</div><div class="line"><span class="keyword">local</span> max_token = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</div><div class="line"><span class="keyword">local</span> token_rate = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</div><div class="line"><span class="keyword">local</span> current_time = <span class="built_in">tonumber</span>(ARGV[<span class="number">3</span>])</div><div class="line"><span class="keyword">if</span> current_token == <span class="literal">nil</span> <span class="keyword">then</span></div><div class="line">  current_token = max_token</div><div class="line">  last_time = current_time</div><div class="line"><span class="keyword">else</span></div><div class="line">  <span class="keyword">local</span> past_time = current_time-last_time</div><div class="line">  </div><div class="line">  <span class="keyword">if</span> past_time&gt;<span class="number">1000</span> <span class="keyword">then</span></div><div class="line">	  current_token = current_token+token_rate</div><div class="line">	  last_time = current_time</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  ## 防止溢出</div><div class="line">  <span class="keyword">if</span> current_token&gt;max_token <span class="keyword">then</span></div><div class="line">    current_token = max_token</div><div class="line">	last_time = current_time</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="keyword">local</span> result = <span class="number">0</span></div><div class="line"><span class="keyword">if</span>(current_token&gt;<span class="number">0</span>) <span class="keyword">then</span></div><div class="line">  result = <span class="number">1</span></div><div class="line">  current_token = current_token<span class="number">-1</span></div><div class="line">  last_time = current_time</div><div class="line"><span class="keyword">end</span></div><div class="line">redis.call(<span class="string">'HMSET'</span>,KEYS[<span class="number">1</span>],<span class="string">'last_time'</span>,last_time,<span class="string">'current_token'</span>,current_token)</div><div class="line"><span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<ul>
<li>调用lua脚本出四个参数，分别是接口方法唯一id，桶容量，每秒产生令牌的数量，当前请求的时间戳。</li>
</ul>
<p>2、 SpringBoot代码实现</p>
<ul>
<li>采用Spring-data-redis实现lua脚本的执行。</li>
<li>Redis序列化配置：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * 重新注入模板</div><div class="line">    */</div><div class="line">   <span class="meta">@Bean</span>(value = <span class="string">"redisTemplate"</span>)</div><div class="line">   <span class="meta">@Primary</span></div><div class="line">   <span class="function"><span class="keyword">public</span> RedisTemplate <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span>&#123;</div><div class="line">       RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</div><div class="line">       template.setConnectionFactory(redisConnectionFactory);</div><div class="line">       ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</div><div class="line">       objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</div><div class="line">       objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</div><div class="line">       <span class="comment">//设置序列化方式，key设置string 方式，value设置成json</span></div><div class="line">       StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</div><div class="line">       Jackson2JsonRedisSerializer jsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</div><div class="line">       jsonRedisSerializer.setObjectMapper(objectMapper);</div><div class="line">       template.setEnableDefaultSerializer(<span class="keyword">false</span>);</div><div class="line">       template.setKeySerializer(stringRedisSerializer);</div><div class="line">       template.setHashKeySerializer(stringRedisSerializer);</div><div class="line">       template.setValueSerializer(jsonRedisSerializer);</div><div class="line">       template.setHashValueSerializer(jsonRedisSerializer);</div><div class="line">       <span class="keyword">return</span> template;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li>限流工具类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Description</span> 限流工具类</div><div class="line"> * <span class="doctag">@Author</span> CJB</div><div class="line"> * <span class="doctag">@Date</span> 2020/3/19 17:21</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLimiterUtils</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StringRedisTemplate stringRedisTemplate=ApplicationContextUtils.applicationContext.getBean(StringRedisTemplate.class);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * lua脚本，限流</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String TEXT=<span class="string">"local ratelimit_info = redis.pcall('HMGET',KEYS[1],'last_time','current_token')\n"</span> +</div><div class="line">            <span class="string">"local last_time = ratelimit_info[1]\n"</span> +</div><div class="line">            <span class="string">"local current_token = tonumber(ratelimit_info[2])\n"</span> +</div><div class="line">            <span class="string">"local max_token = tonumber(ARGV[1])\n"</span> +</div><div class="line">            <span class="string">"local token_rate = tonumber(ARGV[2])\n"</span> +</div><div class="line">            <span class="string">"local current_time = tonumber(ARGV[3])\n"</span> +</div><div class="line">            <span class="string">"if current_token == nil then\n"</span> +</div><div class="line">            <span class="string">"  current_token = max_token\n"</span> +</div><div class="line">            <span class="string">"  last_time = current_time\n"</span> +</div><div class="line">            <span class="string">"else\n"</span> +</div><div class="line">            <span class="string">"  local past_time = current_time-last_time\n"</span> +</div><div class="line">            <span class="string">"  \n"</span> +</div><div class="line">            <span class="string">"  if past_time&gt;1000 then\n"</span> +</div><div class="line">            <span class="string">"\t  current_token = current_token+token_rate\n"</span> +</div><div class="line">            <span class="string">"\t  last_time = current_time\n"</span> +</div><div class="line">            <span class="string">"  end\n"</span> +</div><div class="line">            <span class="string">"\n"</span> +</div><div class="line">            <span class="string">"  if current_token&gt;max_token then\n"</span> +</div><div class="line">            <span class="string">"    current_token = max_token\n"</span> +</div><div class="line">            <span class="string">"\tlast_time = current_time\n"</span> +</div><div class="line">            <span class="string">"  end\n"</span> +</div><div class="line">            <span class="string">"end\n"</span> +</div><div class="line">            <span class="string">"\n"</span> +</div><div class="line">            <span class="string">"local result = 0\n"</span> +</div><div class="line">            <span class="string">"if(current_token&gt;0) then\n"</span> +</div><div class="line">            <span class="string">"  result = 1\n"</span> +</div><div class="line">            <span class="string">"  current_token = current_token-1\n"</span> +</div><div class="line">            <span class="string">"  last_time = current_time\n"</span> +</div><div class="line">            <span class="string">"end\n"</span> +</div><div class="line">            <span class="string">"redis.call('HMSET',KEYS[1],'last_time',last_time,'current_token',current_token)\n"</span> +</div><div class="line">            <span class="string">"return result"</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取令牌</div><div class="line">     * <span class="doctag">@param</span> key 请求id</div><div class="line">     * <span class="doctag">@param</span> max 最大能同时承受多少的并发（桶容量）</div><div class="line">     * <span class="doctag">@param</span> rate  每秒生成多少的令牌</div><div class="line">     * <span class="doctag">@return</span> 获取令牌返回true，没有获取返回false</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(String key, <span class="keyword">int</span> max,<span class="keyword">int</span> rate)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; keyList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span>);</div><div class="line">        keyList.add(key);</div><div class="line">        DefaultRedisScript&lt;Long&gt; script = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;();</div><div class="line">        script.setResultType(Long.class);</div><div class="line">        script.setScriptText(TEXT);</div><div class="line">        <span class="keyword">return</span> Long.valueOf(<span class="number">1</span>).equals(stringRedisTemplate.execute(script,keyList,Integer.toString(max), Integer.toString(rate),</div><div class="line">                Long.toString(System.currentTimeMillis())));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>采用拦截器+注解的方式实现，注解如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Description</span> 限流的注解，标注在类上或者方法上。在方法上的注解会覆盖类上的注解，同<span class="doctag">@Transactional</span></div><div class="line"> * <span class="doctag">@Author</span> CJB</div><div class="line"> * <span class="doctag">@Date</span> 2020/3/20 13:36</div><div class="line"> */</div><div class="line"><span class="meta">@Inherited</span></div><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RateLimit &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 令牌桶的容量，默认100</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> <span class="keyword">default</span> 100</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 每秒钟默认产生令牌数量，默认10个</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rate</span><span class="params">()</span> <span class="keyword">default</span> 10</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>拦截器如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Description</span> 限流的拦器</div><div class="line"> * <span class="doctag">@Author</span> CJB</div><div class="line"> * <span class="doctag">@Date</span> 2020/3/19 14:34</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiterIntercept</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> HandlerMethod)&#123;</div><div class="line">            HandlerMethod handlerMethod=(HandlerMethod)handler;</div><div class="line">            Method method = handlerMethod.getMethod();</div><div class="line">            <span class="comment">/**</span></div><div class="line">             * 首先获取方法上的注解</div><div class="line">             */</div><div class="line">            RateLimit rateLimit = AnnotationUtils.findAnnotation(method, RateLimit.class);</div><div class="line">            <span class="comment">//方法上没有标注该注解，尝试获取类上的注解</span></div><div class="line">            <span class="keyword">if</span> (Objects.isNull(rateLimit))&#123;</div><div class="line">                <span class="comment">//获取类上的注解</span></div><div class="line">                rateLimit = AnnotationUtils.findAnnotation(handlerMethod.getBean().getClass(), RateLimit.class);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//没有标注注解，放行</span></div><div class="line">            <span class="keyword">if</span> (Objects.isNull(rateLimit))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">            <span class="comment">//尝试获取令牌，如果没有令牌了</span></div><div class="line">            <span class="keyword">if</span> (!RedisLimiterUtils.tryAcquire(request.getRequestURI(),rateLimit.capacity(),rateLimit.rate()))&#123;</div><div class="line">                <span class="comment">//抛出请求超时的异常</span></div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span>  TimeOutException();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>SpringBoot配置拦截器的代码就不贴了，以上就是完整的代码，至此分布式限流就完成了。</li>
</ul>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;前几天和一个朋友讨论了他们公司的系统问题，传统的单体应用，集群部署，他说近期服务的并发量可能会出现瞬时增加的风险，虽然部署了集群
    
    </summary>
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合多数据源的巨坑</title>
    <link href="http://chenjiabing666.github.io/2020/03/18/SpringBoot%E6%95%B4%E5%90%88%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E5%B7%A8%E5%9D%91/"/>
    <id>http://chenjiabing666.github.io/2020/03/18/SpringBoot整合多数据源的巨坑/</id>
    <published>2020-03-18T08:51:57.000Z</published>
    <updated>2020-03-18T08:53:17.542Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>本篇文章接上篇<a href="https://chenjiabing666.github.io/2020/03/12/SpringBoot%E6%95%B4%E5%90%88%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%EF%BC%8C%E4%BD%A0%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/">SpringBoot整合多数据源，你会了吗？</a>，前面文章最后留了几个问题供大家思考，今天一一揭晓。</li>
</ul>
<h2 id="配置如何优化"><a href="#配置如何优化" class="headerlink" title="配置如何优化"></a>配置如何优化</h2><ul>
<li>上文整合的过程中的还顺带整合Mybatis和TransactionManager，为什么还要重新定义他们呢？SpringBoot不是给我们都配置好了吗？注意，此处优化就是这两个配置去掉，直接用SpringBoot的自动配置，顿时高级了，别人一看你的代码如此简单就实现了多数据源的切换，牛叉不？</li>
<li>如何去掉？SpringBoot万变不离自动配置类，且看MybatisAutoConfiguration，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@org</span>.springframework.context.annotation.Configuration</div><div class="line"><span class="meta">@ConditionalOnClass</span>(&#123; SqlSessionFactory.class, SqlSessionFactoryBean.class &#125;)</div><div class="line"><span class="meta">@ConditionalOnSingleCandidate</span>(DataSource.class)</div><div class="line"><span class="meta">@EnableConfigurationProperties</span>(MybatisProperties.class)</div><div class="line"><span class="meta">@AutoConfigureAfter</span>(DataSourceAutoConfiguration.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisAutoConfiguration</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</div></pre></td></tr></table></figure>
<ul>
<li>不多帖了，都是废话，看前几行就行了，醒目的一行啊，<code>@ConditionalOnSingleCandidate(DataSource.class)</code>，什么鬼？该注解的意思就是IOC容器中只有一个指定的候选对象才起作用，但是我们注入了几个DataSource，足足三个啊，这还起作用吗？那不废话嘛。</li>
<li>事务管理器也是一样，且看<code>DataSourceTransactionManagerAutoConfiguration</code>，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceTransactionManagerAutoConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Configuration</span></div><div class="line">	<span class="meta">@ConditionalOnSingleCandidate</span>(DataSource.class)</div><div class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceTransactionManagerConfiguration</span> </span>&#123;</div></pre></td></tr></table></figure>
<ul>
<li>又看到了什么，<code>@ConditionalOnSingleCandidate(DataSource.class)</code>同样的醒目，mmp，这不玩我呢吗。这怎么搞？</li>
<li>咦，不着急，此时就要看看<code>@ConditionalOnSingleCandidate</code>注解搞了什么，进去看看，有如下的介绍：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">The condition will also match <span class="keyword">if</span> multiple matching bean instances are already contained in the BeanFactory but a primary candidate has been defined; essentially, the condition match <span class="keyword">if</span> auto-wiring a bean with the defined type will succeed.</div></pre></td></tr></table></figure>
<ul>
<li>什么鬼，看不懂，英语太差了吧，不着急，陈某给大家推荐一个IDEA插件，文档翻译更加专注于程序员的专业术语，不像xx度翻译，如下：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/transac1.png" alt=""></p>
<ul>
<li>好了，翻译准确了就知道了，大致意思就是IOC容器中允许你有多个候选对象，但是你必须有一个主（primary）候选对象，顿时灵光一现，这不就是@Primary注解吗，艹，我这也太优秀了吧。</li>
<li>二话不说，直接开撸，轻轻松松一个注解搞定，此时的数据源配置变得简单多了，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Description</span> 数据源的配置</div><div class="line"> * <span class="doctag">@Author</span> CJB</div><div class="line"> * <span class="doctag">@Date</span> 2020/3/9 13:45</div><div class="line"> */</div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@MapperScan</span>(basePackages = &#123;<span class="string">"com.vivachek.service.dao"</span>,<span class="string">"com.vivachek.service.dao2"</span>&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatasourceConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 注入数据源1</div><div class="line">     */</div><div class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource1"</span>)</div><div class="line">    <span class="meta">@Bean</span>(value = <span class="string">"dataSource1"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource1</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 第二个数据源</div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span>(name = <span class="string">"dataSource2"</span>)</div><div class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource2"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 动态数据源</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="meta">@Primary</span></div><div class="line">    <span class="function"><span class="keyword">public</span> DynamicDataSource <span class="title">dynamicDataSource</span><span class="params">()</span> </span>&#123;</div><div class="line">        DynamicDataSource dataSource = <span class="keyword">new</span> DynamicDataSource();</div><div class="line">        <span class="comment">//默认数据源，在没有切换数据源的时候使用该数据源</span></div><div class="line">        dataSource.setDefaultTargetDataSource(dataSource2());</div><div class="line">        HashMap&lt;Object, Object&gt; map = Maps.newHashMap();</div><div class="line">        map.put(<span class="string">"dataSource1"</span>, dataSource1());</div><div class="line">        map.put(<span class="string">"dataSource2"</span>, dataSource2());</div><div class="line">        <span class="comment">//设置数据源Map，动态切换就是根据key从map中获取</span></div><div class="line">        dataSource.setTargetDataSources(map);</div><div class="line">        <span class="keyword">return</span> dataSource;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>直接在<code>DynamicDataSource</code>添加了一个@Primary就省去了SqlSessionFactory和TransactionManager的手动配置，是不是很easy并且显得自己很牛叉，太有成就感了…..</li>
<li>好了，牛也吹了，运行一下吧，满怀期待等待30秒…….，what？什么鬼？失败了，抛出了异常，如下：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/circleex.png" alt=""></p>
<ul>
<li>什么鬼，循环依赖异常，搞什么飞机，一万个草泥马在奔腾在横无际涯的草原上。。。。。。。。</li>
<li>别急，还有后续，关注我，将会定时更新后续文章。另外需要源码的联系我，微信联系方式在<a href="https://chenjiabing666.github.io/">个人独立博客</a>【关于我】中，加我注明来意，谢谢。</li>
<li>别忘了点赞哟，多来走动走动呗……….</li>
</ul>
<h2 id="动态路由数据源添加-Primary报循环依赖异常"><a href="#动态路由数据源添加-Primary报循环依赖异常" class="headerlink" title="动态路由数据源添加@Primary报循环依赖异常"></a>动态路由数据源添加@Primary报循环依赖异常</h2><ul>
<li>前面文章<a href="https://chenjiabing666.github.io/2019/07/17/Spring%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/">Spring解决循环依赖</a>有说过Spring对于循环依赖是完全能够解决的，没有读过的小伙伴建议看一下，里面详细的讲述了Spring是如何解决循环依赖的，此处就不再赘述了。</li>
<li>既然Spring能够解决循环依赖，为什么这里又会报循环依赖的异常呢？我们不妨跟着代码看看是怎样的循环依赖，如下：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/circleex.png" alt=""></p>
<ul>
<li>上面两个数据源都是自己定义的，先不用看，那么肯定是<code>DataSourceInitializerInvoker</code>造成的循环依赖了，果不其然，其中确实依赖了DataSource，源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">DataSourceInitializerInvoker(ObjectProvider&lt;DataSource&gt; dataSource, DataSourceProperties properties,</div><div class="line">			ApplicationContext applicationContext) &#123;</div><div class="line">		<span class="keyword">this</span>.dataSource = dataSource;</div><div class="line">		<span class="keyword">this</span>.properties = properties;</div><div class="line">		<span class="keyword">this</span>.applicationContext = applicationContext;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ul>
<li>what？即使依赖了又怎样？Spring不是可以解决循环依赖吗？别着急下面分析</li>
<li>ObjectProvider应该不陌生吧，其实内部就是从IOC容器中获取Bean而已，但是，转折来了……… ，这是什么，这是构造器，Spring能解决构造器的循环依赖吗？答案是不能，所以原因找到了，这里不再细说了，欲知原因请读<a href="https://chenjiabing666.github.io/2019/07/17/Spring%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/">Spring解循环依赖</a></li>
<li><p>问题找到了，如何解决？此时心中一万个草泥马奔腾，怎么解决呢？</p>
</li>
<li><p>哈哈，此时插播一条广告，本人的独立博客已经发布了很多文章，感兴趣的可以收藏一下，【关于我】中有我的微信联系方式，欢迎交流。</p>
</li>
<li>回到正题，如何解决？很简单，找到这个<code>DataSourceInitializerInvoker</code>是什么时候注入到IOC容器中的，因此我们找到了<code>DataSourceAutoConfiguration</code>，继而找到了<code>DataSourceInitializationConfiguration</code>这个配置类，源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ConditionalOnClass</span>(&#123; DataSource.class, EmbeddedDatabaseType.class &#125;)</div><div class="line"><span class="meta">@EnableConfigurationProperties</span>(DataSourceProperties.class)</div><div class="line"><span class="meta">@Import</span>(&#123; DataSourcePoolMetadataProvidersConfiguration.class, DataSourceInitializationConfiguration.class &#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceAutoConfiguration</span> </span>&#123;</div><div class="line">    <span class="meta">@Configuration</span></div><div class="line">	<span class="meta">@Conditional</span>(EmbeddedDatabaseCondition.class)</div><div class="line">	<span class="meta">@ConditionalOnMissingBean</span>(&#123; DataSource.class, XADataSource.class &#125;)</div><div class="line">	<span class="meta">@Import</span>(EmbeddedDataSourceConfiguration.class)</div><div class="line">	<span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedDatabaseConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Configuration</span></div><div class="line">	<span class="meta">@Conditional</span>(PooledDataSourceCondition.class)</div><div class="line">	<span class="meta">@ConditionalOnMissingBean</span>(&#123; DataSource.class, XADataSource.class &#125;)</div><div class="line">	<span class="meta">@Import</span>(&#123; DataSourceConfiguration.Hikari.class, DataSourceConfiguration.Tomcat.class,</div><div class="line">			DataSourceConfiguration.Dbcp2.class, DataSourceConfiguration.Generic.class,</div><div class="line">			DataSourceJmxConfiguration.class &#125;)</div><div class="line">	<span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledDataSourceConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line">	&#125;   </div><div class="line">&#125;</div><div class="line">    </div><div class="line">    </div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@Import</span>(&#123; DataSourceInitializerInvoker.class, DataSourceInitializationConfiguration.Registrar.class &#125;)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataSourceInitializationConfiguration</span> </span>&#123;</div></pre></td></tr></table></figure>
<ul>
<li>贴了那么多代码谁看的懂？草泥马又奔腾了，可以看到源码中出现了两次<code>@ConditionalOnMissingBean({ DataSource.class, XADataSource.class })</code>，这什么鬼，不多说了，相信读过SpringBoot源码的都知道，这个配置类根本不起作用啊，那还要它干嘛，直接搞掉不就完事了。好了，分析到这里终于知道解决的方案了，搞掉<code>DataSourceAutoConfiguration</code>，怎么搞呢？一个注解搞定。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//排除配置类</span></div><div class="line"><span class="meta">@SpringBootApplication</span>(exclude = &#123;DataSourceAutoConfiguration.class&#125;)</div></pre></td></tr></table></figure>
<ul>
<li>问题迎刃而解了，简单不，惊喜不，不好，又奔腾了。。。。</li>
</ul>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;本篇文章接上篇&lt;a href=&quot;https://chenjiabing666.github.io/2020/03/12/Spri
    
    </summary>
    
      <category term="SpringBoot" scheme="http://chenjiabing666.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://chenjiabing666.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合多数据源，你会了吗？</title>
    <link href="http://chenjiabing666.github.io/2020/03/12/SpringBoot%E6%95%B4%E5%90%88%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%EF%BC%8C%E4%BD%A0%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/"/>
    <id>http://chenjiabing666.github.io/2020/03/12/SpringBoot整合多数据源，你会了吗？/</id>
    <published>2020-03-12T14:41:57.000Z</published>
    <updated>2020-03-12T14:42:19.809Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>平常的工作中可能大家的接触的都是单数据源的操作，很少能够用到多数据源的操作，但是在和其他系统对接的或者系统数据迁移时候往往需要定时从其他系统拉数据，此时多数据源变得很有必要了。</li>
<li>多数据源的实现有两种方式，第一种是定义分别定义多个数据源，单个数据源分别和Mybatis整合，使用单独的事务机制；第二种是使用动态切换数据源的方式，笔者今天讲的就是动态数据源的切换。</li>
</ul>
<h2 id="AbstractRoutingDataSource"><a href="#AbstractRoutingDataSource" class="headerlink" title="AbstractRoutingDataSource"></a>AbstractRoutingDataSource</h2><ul>
<li>见名知意，动态路由数据源，实现的原理其实很简单，内部使用一个Map结构，将DataSource存放其中，key是beanName，value是实例对象。在getConnection的时候动态判断当前的数据源。</li>
<li>抽象类必须实现的方法是<code>protected Object determineCurrentLookupKey()</code>，返回值将作为key从Map中获取数据源。</li>
<li>重要一点就是每个请求要保持线程隔离，不能一个请求切换了数据源影响了另外一个请求，因此我们需要将每一个线程的数据源保存在ThreadLocal中做到线程隔离。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>针对业务逻辑的横向切面，切换数据源使用AOP的方式更加清晰一点。</li>
</ul>
<h3 id="线程隔离ThreadLocal"><a href="#线程隔离ThreadLocal" class="headerlink" title="线程隔离ThreadLocal"></a>线程隔离ThreadLocal</h3><ul>
<li>定一个工具类，存放单线程数据源，只是个人这么做而已，也可以和数据源实现类整合在一起。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Description</span> ThreadLocal保存数据源，保持线程隔离</div><div class="line"> * <span class="doctag">@Author</span> CJB</div><div class="line"> * <span class="doctag">@Date</span> 2020/3/12 14:29</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicThreadLocalHolder</span> </span>&#123;</div><div class="line">    <span class="comment">//本地线程保存数据源</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置线程数据源</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(String dataSource)</span></span>&#123;</div><div class="line">        threadLocal.set(dataSource);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取本地线程的数据源，这里只是数据源的key</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDataSource</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> threadLocal.get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 清除数据源</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearDataSource</span><span class="params">()</span></span>&#123;</div><div class="line">        threadLocal.remove();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="动态数据源实现"><a href="#动态数据源实现" class="headerlink" title="动态数据源实现"></a>动态数据源实现</h3><ul>
<li>实现AbstractRoutingDataSource，重写determineCurrentLookupKey方法即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Description</span> 动态数据源的实现</div><div class="line"> * <span class="doctag">@Author</span> CJB</div><div class="line"> * <span class="doctag">@Date</span> 2020/3/12 14:27</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractRoutingDataSource</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 决定使用哪个数据源</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//从ThreadLocal中获取数据源的beanName</span></div><div class="line">        <span class="keyword">return</span> DynamicThreadLocalHolder.getDataSource();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="多数据源配置"><a href="#多数据源配置" class="headerlink" title="多数据源配置"></a>多数据源配置</h3><ul>
<li>定义了两个数据源，笔者和Mybatis整合了，同时也整合了事务管理器<strong>（此处有待优化）</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Description</span> 数据源的配置</div><div class="line"> * <span class="doctag">@Author</span> CJB</div><div class="line"> * <span class="doctag">@Date</span> 2020/3/9 13:45</div><div class="line"> */</div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@MapperScan</span>(basePackages = &#123;<span class="string">"com.vivachek.service.dao"</span>,<span class="string">"com.vivachek.service.dao2"</span>&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatasourceConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 注入数据源1</div><div class="line">     */</div><div class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource1"</span>)</div><div class="line">    <span class="meta">@Bean</span>(value = <span class="string">"dataSource1"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource1</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 第二个数据源</div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span>(name = <span class="string">"dataSource2"</span>)</div><div class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource2"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 动态数据源</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> DynamicDataSource <span class="title">dynamicDataSource</span><span class="params">()</span> </span>&#123;</div><div class="line">        DynamicDataSource dataSource = <span class="keyword">new</span> DynamicDataSource();</div><div class="line">        <span class="comment">//默认数据源，在没有切换数据源的时候使用该数据源</span></div><div class="line">        dataSource.setDefaultTargetDataSource(dataSource2());</div><div class="line">        HashMap&lt;Object, Object&gt; map = Maps.newHashMap();</div><div class="line">        map.put(<span class="string">"dataSource1"</span>, dataSource1());</div><div class="line">        map.put(<span class="string">"dataSource2"</span>, dataSource2());</div><div class="line">        <span class="comment">//设置数据源Map，动态切换就是根据key从map中获取</span></div><div class="line">        dataSource.setTargetDataSources(map);</div><div class="line">        <span class="keyword">return</span> dataSource;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 和Mybatis整合必须设置SqlSessionFactory的数据源为动态数据源</div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        SqlSessionFactoryBean factoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</div><div class="line">        <span class="comment">//此处必须设置动态数据源</span></div><div class="line">        factoryBean.setDataSource(dynamicDataSource());</div><div class="line">        factoryBean.setVfs(SpringBootVFS.class);</div><div class="line">        org.apache.ibatis.session.Configuration configuration = <span class="keyword">new</span> org.apache.ibatis.session.Configuration();</div><div class="line">        configuration.setMapUnderscoreToCamelCase(<span class="keyword">true</span>);</div><div class="line">        factoryBean.setConfiguration(configuration);</div><div class="line">        factoryBean.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver().getResources(<span class="string">"classpath*:/mapper/**/*.xml"</span>));</div><div class="line">        <span class="keyword">return</span> factoryBean.getObject();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置事务管理器</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dynamicDataSource());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="AOP动态切换"><a href="#AOP动态切换" class="headerlink" title="AOP动态切换"></a>AOP动态切换</h3><ul>
<li>使用注解+AOP的方式动态切换数据源，在使用注解的方法上切换指定的数据源</li>
<li>注解如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.METHOD)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ChangeSource &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 数据源，动态数据源默认的是datasource1，这里默认的直接dataSource2</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "dataSource1"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>切面如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Description</span> 切面</div><div class="line"> * <span class="doctag">@Author</span> CJB</div><div class="line"> * <span class="doctag">@Date</span> 2020/3/12 16:18</div><div class="line"> */</div><div class="line"><span class="meta">@Aspect</span></div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="meta">@Slf</span>4j</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeSourceAspect</span> </span>&#123;</div><div class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.vivachek.core.aop.ChangeSource)"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 在方法执行之前往ThreadLocal中设置值</div><div class="line">     */</div><div class="line">    <span class="meta">@Before</span>(value = <span class="string">"pointcut()"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeOpt</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</div><div class="line">        Method method = ((MethodSignature) joinPoint.getSignature()).getMethod();</div><div class="line">        ChangeSource changeSource = method.getAnnotation(ChangeSource.class);</div><div class="line">        log.info(<span class="string">"[Switch DataSource]:"</span> + changeSource.value());</div><div class="line">        DynamicThreadLocalHolder.setDataSource(changeSource.value());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 结束之后清除</div><div class="line">     */</div><div class="line">    <span class="meta">@After</span>(value = <span class="string">"pointcut()"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterOpt</span><span class="params">()</span> </span>&#123;</div><div class="line">        DynamicThreadLocalHolder.clearDataSource();</div><div class="line">        log.info(<span class="string">"[change Default DataSource]"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>至此，整合完成，在需要切换数据源的方法上使用@ChangeSource注解即可。</li>
</ul>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul>
<li>此处有几个问题供读者思考，如下：<ul>
<li>在多数据源配置的地方其实可以更加简单，如何优化？</li>
<li>在声明DynamicDataSource的方式如果加上了@Primary注解为什么会出现循环依赖的异常？【巨坑】</li>
<li>AOP切面为什么在方法嵌套调用会失效，如何解决？</li>
<li>动态数据源的事务如何实现？</li>
</ul>
</li>
<li>以上问题小伙伴可以思考一下，后续会更新出来…….</li>
</ul>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><ul>
<li>源码已经上传，搜索微信公众号【码猿技术专栏】或者扫描下面的二维码关注后，关键词回复</li>
</ul>
<p>【数据源】即可。</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/myjszl.jpg" alt=""></p>
<h2 id="另外一种实现方式"><a href="#另外一种实现方式" class="headerlink" title="另外一种实现方式"></a>另外一种实现方式</h2><ul>
<li>关于另外一种实现方式，之前讲过SpringBoot整合JTA这篇文章中就是用两个数据源分别和Mybatis整合，关注公众号查看历史文章【SpringBoot整合JTA】</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;平常的工作中可能大家的接触的都是单数据源的操作，很少能够用到多数据源的操作，但是在和其他系统对接的或者系统数据迁移时候往往需要定
    
    </summary>
    
      <category term="SpringBoot" scheme="http://chenjiabing666.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://chenjiabing666.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合JTA</title>
    <link href="http://chenjiabing666.github.io/2020/03/11/SpringBoot%E6%95%B4%E5%90%88JTA/"/>
    <id>http://chenjiabing666.github.io/2020/03/11/SpringBoot整合JTA/</id>
    <published>2020-03-11T13:04:24.000Z</published>
    <updated>2020-03-12T14:40:46.527Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>JTA，即Java Transaction API，JTA允许应用程序执行分布式事务处理——在两个或多个网络计算机资源上访问并且更新数据。JDBC驱动程序的JTA支持极大地增强了数据访问能力。 </li>
<li>JTA是基于XA标准制定的，采用两阶段提交的方式来管理分布式事务。即是一个事务管理器和多个资源管理器协作完成，第一阶段各个资源管理器提交，第二个阶段事务管理器需要查看资源管理器是否全部提交成功再提交。</li>
<li>Java实现JTA强一致性的事务有很多种实现，笔者只是选择了atomikos的实现</li>
</ul>
<h2 id="SpringBoot整合"><a href="#SpringBoot整合" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h2><ul>
<li>添加依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jta-atomikos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>准备两个数据源，笔者是和Mybatis整合的，因此需要将数据源和Mybatis单独绑定，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Description</span> 数据源的配置</div><div class="line"> * <span class="doctag">@Author</span> CJB</div><div class="line"> * <span class="doctag">@Date</span> 2020/3/9 13:45</div><div class="line"> */</div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatasourceConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 第一个数据源的配置</div><div class="line">     */</div><div class="line">    <span class="meta">@Configuration</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfig1</span></span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 注入DruidXADataSource，Druid对JTA的支持，支持XA协议，采用两阶段事务的提交</div><div class="line">         * <span class="doctag">@return</span></div><div class="line">         */</div><div class="line">        <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource1"</span>)</div><div class="line">        <span class="meta">@Bean</span>(value = <span class="string">"druidXADataSource1"</span>)</div><div class="line">        <span class="function"><span class="keyword">public</span> DruidXADataSource <span class="title">druidXADataSource1</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DruidXADataSource();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Bean</span>(name = <span class="string">"dataSource1"</span>)</div><div class="line">        <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource1</span><span class="params">(@Qualifier(<span class="string">"druidXADataSource1"</span>)</span> DruidXADataSource dataSource)</span>&#123;</div><div class="line">            AtomikosDataSourceBean xaDataSource=<span class="keyword">new</span> AtomikosDataSourceBean();</div><div class="line">            xaDataSource.setXaDataSource(dataSource);</div><div class="line">            xaDataSource.setUniqueResourceName(<span class="string">"dataSource1"</span>);</div><div class="line">            <span class="keyword">return</span> xaDataSource;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Mybatis对多数据源的整合</div><div class="line">         * <span class="doctag">@param</span> dataSource</div><div class="line">         * <span class="doctag">@return</span></div><div class="line">         * <span class="doctag">@throws</span> Exception</div><div class="line">         */</div><div class="line">        <span class="meta">@Bean</span>(name = <span class="string">"sqlSessionFactory1"</span>)</div><div class="line">        <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory1</span><span class="params">(@Qualifier(value = <span class="string">"dataSource1"</span>)</span> DataSource dataSource) <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            SqlSessionFactoryBean factory = <span class="keyword">new</span> SqlSessionFactoryBean();</div><div class="line">            factory.setDataSource(dataSource);</div><div class="line">            factory.setVfs(SpringBootVFS.class);</div><div class="line">            org.apache.ibatis.session.Configuration configuration = <span class="keyword">new</span> org.apache.ibatis.session.Configuration();</div><div class="line">            configuration.setMapUnderscoreToCamelCase(<span class="keyword">true</span>);</div><div class="line">            factory.setConfiguration(configuration);</div><div class="line">            factory.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver().getResources(<span class="string">"classpath*:/mapper1/**/*.xml"</span>));</div><div class="line">            <span class="keyword">return</span> factory.getObject();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Bean</span>(name = <span class="string">"sqlSessionTemplate1"</span>)</div><div class="line">        <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">sqlSessionTemplate</span><span class="params">(@Qualifier(<span class="string">"sqlSessionFactory1"</span>)</span> SqlSessionFactory sqlSessionFactory) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 配置mapper文件的扫描，注入mapper，也可以使用<span class="doctag">@MapperScan</span>注解扫描，其中有一个属性指定sqlSessionFactory</div><div class="line">         */</div><div class="line">        <span class="meta">@Bean</span>(value = <span class="string">"mapperScannerConfigurer1"</span>)</div><div class="line">        <span class="function"><span class="keyword">public</span> MapperScannerConfigurer <span class="title">mapperScannerConfigurer</span><span class="params">()</span> </span>&#123;</div><div class="line">            MapperScannerConfigurer mapperScannerConfigurer = <span class="keyword">new</span> MapperScannerConfigurer();</div><div class="line">            <span class="comment">// 设置sqlSessionFactory名</span></div><div class="line">            mapperScannerConfigurer.setSqlSessionFactoryBeanName(<span class="string">"sqlSessionFactory1"</span>);</div><div class="line">            <span class="comment">// 设置接口映射器基础包名</span></div><div class="line">            mapperScannerConfigurer.setBasePackage(<span class="string">"com.vivachek.service.dao"</span>);</div><div class="line">            <span class="keyword">return</span> mapperScannerConfigurer;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 第二个数据源的配置</div><div class="line">     */</div><div class="line">    <span class="meta">@Configuration</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfig2</span></span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource2"</span>)</div><div class="line">        <span class="meta">@Bean</span>(value = <span class="string">"druidXADataSource2"</span>)</div><div class="line">        <span class="function"><span class="keyword">public</span> DruidXADataSource <span class="title">druidXADataSource2</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DruidXADataSource();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Bean</span>(name = <span class="string">"dataSource2"</span>)</div><div class="line">        <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource2</span><span class="params">(@Qualifier(<span class="string">"druidXADataSource2"</span>)</span> DruidXADataSource dataSource)</span>&#123;</div><div class="line">            AtomikosDataSourceBean xaDataSource=<span class="keyword">new</span> AtomikosDataSourceBean();</div><div class="line">            xaDataSource.setXaDataSource(dataSource);</div><div class="line">            xaDataSource.setUniqueResourceName(<span class="string">"dataSource2"</span>);</div><div class="line">            <span class="keyword">return</span> xaDataSource;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//配置Mybatis</span></div><div class="line">        <span class="meta">@Bean</span>(name = <span class="string">"sqlSessionFactory2"</span>)</div><div class="line">        <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory1</span><span class="params">(@Qualifier(value = <span class="string">"dataSource2"</span>)</span> DataSource dataSource) <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            SqlSessionFactoryBean factory = <span class="keyword">new</span> SqlSessionFactoryBean();</div><div class="line">            factory.setDataSource(dataSource);</div><div class="line">            factory.setVfs(SpringBootVFS.class);</div><div class="line">            org.apache.ibatis.session.Configuration configuration = <span class="keyword">new</span> org.apache.ibatis.session.Configuration();</div><div class="line">            configuration.setMapUnderscoreToCamelCase(<span class="keyword">true</span>);</div><div class="line">            factory.setConfiguration(configuration);</div><div class="line">            factory.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver().getResources(<span class="string">"classpath*:/mapper2/**/*.xml"</span>));</div><div class="line">            <span class="keyword">return</span> factory.getObject();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Bean</span>(name = <span class="string">"sqlSessionTemplate2"</span>)</div><div class="line">        <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">sqlSessionTemplate</span><span class="params">(@Qualifier(<span class="string">"sqlSessionFactory2"</span>)</span> SqlSessionFactory sqlSessionFactory) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//配置Mapper扫描器，整合mybatis的时候多数据源必须配置</span></div><div class="line">        <span class="meta">@Bean</span>(value = <span class="string">"mapperScannerConfigurer2"</span>)</div><div class="line">        <span class="function"><span class="keyword">public</span> MapperScannerConfigurer <span class="title">mapperScannerConfigurer</span><span class="params">()</span> </span>&#123;</div><div class="line">            MapperScannerConfigurer mapperScannerConfigurer = <span class="keyword">new</span> MapperScannerConfigurer();</div><div class="line">            <span class="comment">// 设置sqlSessionFactory名</span></div><div class="line">            mapperScannerConfigurer.setSqlSessionFactoryBeanName(<span class="string">"sqlSessionFactory2"</span>);</div><div class="line">            <span class="comment">// 设置接口映射器基础包名</span></div><div class="line">            mapperScannerConfigurer.setBasePackage(<span class="string">"com.vivachek.service.dao2"</span>);</div><div class="line">            <span class="keyword">return</span> mapperScannerConfigurer;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>关于数据源的配置和Druid的一模一样，只是需要配置两次而已，这里不再展示。</li>
<li>至此整合完成，开启事务直接使用<code>@Transactional</code>即可</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>使用<code>MapperScan</code>注解直接注入Mapper的时候需要使用<code>sqlSessionFactoryRef</code>属性指定对应的SqlSessionFactory。当然笔者采用的配置的方式。</li>
<li>关于实现的原理这里不再细说了，读者自己读读源码就能很清楚的知晓了，SpringBoot源码万变不离自动配置类，设计到的配置类如下：<ul>
<li><code>TransactionAutoConfiguration</code>：事务的自动配置类</li>
<li><code>DataSourceTransactionManagerAutoConfiguratio</code>：数据源事务管理器的自动配置类</li>
<li><code>AtomikosJtaConfiguratio</code>，<code>JndiJtaConfiguration</code>：JTA事务的自动配置类</li>
</ul>
</li>
<li>关于事务的执行原理可以看看笔者之前的文章，<a href="https://chenjiabing666.github.io/2019/07/07/Spring%E4%BA%8B%E5%8A%A1%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">Spring事务源码解析</a></li>
</ul>
<h2 id="装xx时刻"><a href="#装xx时刻" class="headerlink" title="装xx时刻"></a>装xx时刻</h2><ul>
<li>笔者最近新开了一个公众号，以后大部分文章会直接放在公众号上，后续会在公众号上分享精选资源供读者阅览，下面附上公众号链接或者直接搜索【码猿技术专栏】</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/myjszl.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;JTA，即Java Transaction API，JTA允许应用程序执行分布式事务处理——在两个或多个网络计算机资源上访问并且
    
    </summary>
    
      <category term="SpringBoot" scheme="http://chenjiabing666.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://chenjiabing666.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合分页插件</title>
    <link href="http://chenjiabing666.github.io/2020/03/11/SpringBoot%E6%95%B4%E5%90%88%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/"/>
    <id>http://chenjiabing666.github.io/2020/03/11/SpringBoot整合分页插件/</id>
    <published>2020-03-11T03:00:04.000Z</published>
    <updated>2020-03-13T06:12:05.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>很久以前的项目分页查询的话大概会用limit，如果要统计总数还需要使用count，总之大多数情况下都是很麻烦的一件事，特别是使用Mybatis。</li>
<li>分页插件确实解放了我们的双手，不用再写重复的sql，利用mybatis的插件的原理帮我们解决了系列问题。</li>
</ul>
<h2 id="SpringBoot整合"><a href="#SpringBoot整合" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h2><ul>
<li>SSM的整合这里就不再说了，相信现在大部分公司都在使用SpringBoot，当然万变不离其中，你会了SSM的整合，SpringBoot当然不在话下了。</li>
</ul>
<h3 id="整合之前"><a href="#整合之前" class="headerlink" title="整合之前"></a>整合之前</h3><ul>
<li>在整合之前需要准备环境，数据源，mybatis整合，这里就不再细说了，有不了解的可以会看我之前的文章<a href="https://chenjiabing666.github.io/2018/09/02/springBoot%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">https://chenjiabing666.github.io/2018/09/02/springBoot%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</a></li>
</ul>
<h3 id="开干"><a href="#开干" class="headerlink" title="开干"></a>开干</h3><ul>
<li>添加Maven依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--mybatis分页插件--&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>自定义一个配置类，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Description</span> 分页插件的参数</div><div class="line"> * <span class="doctag">@Author</span> CJB</div><div class="line"> * <span class="doctag">@Date</span> 2020/3/11 9:48</div><div class="line"> */</div><div class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"mybatis.page"</span>)</div><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageHelperProperties</span>  </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。 你可以配置helperDialect属性来指定分页插件使用哪种方言。配置时，可以使用下面的缩写值：</div><div class="line">     * oracle,mysql,mariadb,sqlite,hsqldb,postgresql,db2,sqlserver,informix,h2,sqlserver2012,derby</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> String helperDialect;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 是否进行count查询，默认是true，查询</div><div class="line">     * 如果设置为false，那么总数total将会为-1，不进行count查询</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Boolean countSql=<span class="keyword">true</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 分页合理化参数，默认值为false。当该参数设置为 true 时，pageNum&lt;=0 时会查询第一页， pageNum&gt;pages（超过总数时），会查询最后一页。默认false 时，直接根据参数进行查询。</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Boolean reasonable=<span class="keyword">false</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 默认值为 false，当该参数设置为 true 时，如果 pageSize=0 或者 RowBounds.limit = 0 就会查询出全部的结果（相当于没有执行分页查询，但是返回结果仍然是 Page 类型）。</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Boolean pageSizeZero=<span class="keyword">false</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>向Mybatis注入插件，查看<code>MybatisAutoConfiguration</code>的源码可以看出，直接向IOC注入Intercept即可，不需要重新注入SqlSessionFactory了，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableConfigurationProperties</span>(value = &#123;PageHelperProperties.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> PageHelperProperties pageHelperProperties;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MybatisConfig</span><span class="params">(ObjectProvider&lt;PageHelperProperties&gt; objectProvider)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.pageHelperProperties=objectProvider.getIfUnique();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 注入分页插件，springBoot会将注入的插件自动设置到sqlSessionFactory中</div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Interceptor <span class="title">interceptor</span><span class="params">()</span></span>&#123;</div><div class="line">        PageInterceptor pageInterceptor = <span class="keyword">new</span> PageInterceptor();</div><div class="line">        <span class="comment">//加载配置</span></div><div class="line">        Properties properties = <span class="keyword">new</span> Properties();</div><div class="line">        <span class="comment">//方言不设置可以自动选择</span></div><div class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(pageHelperProperties.getHelperDialect()))</div><div class="line">            properties.setProperty(<span class="string">"helperDialect"</span>,pageHelperProperties.getHelperDialect());</div><div class="line">        properties.setProperty(<span class="string">"countSql"</span>, String.valueOf(pageHelperProperties.getCountSql()));</div><div class="line">        properties.setProperty(<span class="string">"reasonable"</span>,pageHelperProperties.getHelperDialect());</div><div class="line">        properties.setProperty(<span class="string">"pageSizeZero"</span>,pageHelperProperties.getHelperDialect());</div><div class="line">        <span class="comment">//设置参数</span></div><div class="line">        pageInterceptor.setProperties(properties);</div><div class="line">        <span class="keyword">return</span> pageInterceptor;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果需要改变参数，直接在全局配置文件中直接修改即可，如下：</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="attr">mybatis:</span></div><div class="line"><span class="attr">  page:</span></div><div class="line"><span class="attr">    helperDialect:</span> <span class="string">mysql</span></div><div class="line"><span class="attr">    countSql:</span> <span class="literal">true</span></div><div class="line"><span class="attr">    reasonable:</span> <span class="literal">false</span></div><div class="line"><span class="attr">    pageSizeZero:</span> <span class="literal">false</span></div></pre></td></tr></table></figure>
<ul>
<li>自定义分页的工具类，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageUtils</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 此处pageNum和pageSize直接作为参数，这里就不封装了，自己可以根据条件封装一下</div><div class="line">     * <span class="doctag">@param</span> pageNum</div><div class="line">     * <span class="doctag">@param</span> pageSize</div><div class="line">     * <span class="doctag">@param</span> iSelect</div><div class="line">     * <span class="doctag">@param</span> &lt;T&gt;</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;<span class="function">PageData&lt;T&gt; <span class="title">getPageInfo</span><span class="params">(Integer pageNum,Integer pageSize,ISelect iSelect)</span></span>&#123;</div><div class="line">        PageInfo&lt;Object&gt; pageInfo = PageHelper.startPage(pageNum, pageSize).doSelectPageInfo(iSelect);</div><div class="line">        PageData&lt;T&gt; data = <span class="keyword">new</span> PageData&lt;&gt;();</div><div class="line">        BeanUtils.copyProperties(pageInfo,data);</div><div class="line">        <span class="keyword">return</span> data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>好了，整合结束，简单使用下，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PageUtils.getPageInfo(req.getPageNum(),req.getPageSize(),()-&gt;articleMapper.selectAll());</div></pre></td></tr></table></figure>
<h2 id="装xx开始"><a href="#装xx开始" class="headerlink" title="装xx开始"></a>装xx开始</h2><ul>
<li>如果想要深入学习Mybatis，不防看一下本人的独立博客<a href="https://chenjiabing666.github.io/2019/08/05/mybatis%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/">https://chenjiabing666.github.io/2019/08/05/mybatis%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/</a></li>
<li>另外，笔者新开了一个公众号，以后大部分文章会直接放在公众号上，后续会在公众号上分享精选资源供读者阅览，下面附上公众号链接或者直接搜索【码猿技术专栏】</li>
</ul>
<p><img src="https://raw.githubusercontent.com/chenjiabing666/BlogImage/master/myjszl.jpg" alt=""></p>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;很久以前的项目分页查询的话大概会用limit，如果要统计总数还需要使用count，总之大多数情况下都是很麻烦的一件事，特别是使用
    
    </summary>
    
      <category term="SpringBoot" scheme="http://chenjiabing666.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://chenjiabing666.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>一文搞懂Spring-AMQP</title>
    <link href="http://chenjiabing666.github.io/2020/03/09/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82Spring-AMQP/"/>
    <id>http://chenjiabing666.github.io/2020/03/09/一文搞懂Spring-AMQP/</id>
    <published>2020-03-09T01:11:16.000Z</published>
    <updated>2020-03-09T01:47:33.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitAdmin"><a href="#RabbitAdmin" class="headerlink" title="RabbitAdmin"></a>RabbitAdmin</h2><ul>
<li>队列，交换器的声明创建、删除、清空</li>
<li>创建：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line">   <span class="function"><span class="keyword">public</span> RabbitAdmin <span class="title">rabbitAdmin</span><span class="params">(ConnectionFactory connectionFactory )</span> </span>&#123;</div><div class="line">       RabbitAdmin rabbitAdmin = <span class="keyword">new</span> RabbitAdmin(connectionFactory);</div><div class="line">       rabbitAdmin.setAutoStartup(<span class="keyword">true</span>);</div><div class="line">       <span class="keyword">return</span> rabbitAdmin;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li>简单使用：创建一个direct交换器，绑定了一个队列</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">   <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</div><div class="line">       DirectExchange direct_1 = <span class="keyword">new</span> DirectExchange(<span class="string">"direct_1"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</div><div class="line">       rabbitAdmin.declareExchange(direct_1);</div><div class="line">       Queue direct_q_1 = <span class="keyword">new</span> Queue(<span class="string">"direct_q_1"</span>, <span class="keyword">true</span>);</div><div class="line">       rabbitAdmin.declareQueue(direct_q_1);</div><div class="line">       Binding binding = BindingBuilder.bind(direct_q_1).to(direct_1).with(<span class="string">"direct"</span>);</div><div class="line">       rabbitAdmin.declareBinding(binding);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h2 id="MessageConvert"><a href="#MessageConvert" class="headerlink" title="MessageConvert"></a>MessageConvert</h2><ul>
<li>消息转换器，在发送消息和接收消息的时候将消息内容转换成指定的格式。</li>
<li>默认的消息转换器是SimpleMessageConverter，此转换器的功能就是将发送的消息体转换成字节数组（Object，String，Serializable），rabbitTemplate中会用到消息转换器的方法如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(Object message)</span> <span class="keyword">throws</span> AmqpException</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(String routingKey, Object message)</span> <span class="keyword">throws</span> AmqpException</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(String exchange, String routingKey, Object message)</span></span></div><div class="line">    <span class="keyword">throws</span> AmqpException;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(Object message, MessagePostProcessor messagePostProcessor)</span></span></div><div class="line">    <span class="keyword">throws</span> AmqpException;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(String routingKey, Object message,</span></span></div><div class="line">    MessagePostProcessor messagePostProcessor) <span class="keyword">throws</span> AmqpException;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(String exchange, String routingKey, Object message,</span></span></div><div class="line">    MessagePostProcessor messagePostProcessor) <span class="keyword">throws</span> AmqpException;</div><div class="line"></div><div class="line"><span class="function">Object <span class="title">receiveAndConvert</span><span class="params">()</span> <span class="keyword">throws</span> AmqpException</span>;</div><div class="line"></div><div class="line"><span class="function">Object <span class="title">receiveAndConvert</span><span class="params">(String queueName)</span> <span class="keyword">throws</span> AmqpException</span>;</div></pre></td></tr></table></figure>
<ul>
<li><p>实现自己的消息转换器后调用rabbitTemplate的API（<code>public void setMessageConverter(MessageConverter messageConverter)</code>)设置即可。</p>
</li>
<li><p>在与SpringBoot整合时，可以注入自己的消息转换器，amqp提供了Jackson2JsonMessageConverter，使用JackSon将消息内容转换为json字符串，配置如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * 注入JackSon的MessageConverter，用于收发消息的格式化成json数据</div><div class="line">    * <span class="doctag">@param</span> ObjectMapper 这个是jackson自动注入的，详情请看JacksonAutoConfiguration</div><div class="line">    */</div><div class="line">   <span class="meta">@Bean</span></div><div class="line">   <span class="function"><span class="keyword">public</span> Jackson2JsonMessageConverter <span class="title">messageConverter</span><span class="params">(ObjectMapper )</span></span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Jackson2JsonMessageConverter(objectMapper);</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 重新注入RabbitTemplate，并且设置相关属性</div><div class="line">*/</div><div class="line"><span class="meta">@Bean</span></div><div class="line">   <span class="meta">@Primary</span></div><div class="line">   <span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">rabbitTemplate</span><span class="params">(ConnectionFactory connectionFactory, Jackson2JsonMessageConverter messageConverter, CustomConfirmCallBack confirmCallBack, CustomReturnCallBack returnCallBack)</span></span>&#123;</div><div class="line">       RabbitTemplate template = <span class="keyword">new</span> RabbitTemplate(connectionFactory);</div><div class="line">       template.setMandatory(<span class="keyword">true</span>);</div><div class="line">       <span class="comment">//设置消息转换器</span></div><div class="line">    	template.setMessageConverter(messageConverter);</div><div class="line">       template.setReturnCallback(returnCallBack);</div><div class="line">       template.setConfirmCallback(confirmCallBack);</div><div class="line">       <span class="keyword">return</span> template;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><h3 id="TTL-消息或者队列"><a href="#TTL-消息或者队列" class="headerlink" title="TTL(消息或者队列)"></a>TTL(消息或者队列)</h3><ul>
<li>TTL表示消息或者队列的生命周期，在消息发送或者队列创建的时候可以设置消息的存活时间，如果此条消息或者队列中的所有消息到达指定的时候还是没有被消费，那么消息将会被清空或者存入<strong>死信队列</strong>中。</li>
</ul>
<h4 id="消息TTL"><a href="#消息TTL" class="headerlink" title="消息TTL"></a>消息TTL</h4><ul>
<li>在发送消息的时候指定的TTL，（MessageProperties）API如下：<ul>
<li><code>public void setExpiration(String expiration)</code>：单位毫秒</li>
</ul>
</li>
</ul>
<h4 id="队列TTL"><a href="#队列TTL" class="headerlink" title="队列TTL"></a>队列TTL</h4><ul>
<li>在创建队列的时候指定过期时间，在创建Queue的时候需要指定过期时间（<code>x-message-ttl</code>），设置在<code>arguments</code>。</li>
</ul>
<h3 id="消息ack和nack"><a href="#消息ack和nack" class="headerlink" title="消息ack和nack"></a>消息ack和nack</h3><ul>
<li><p>消息确认机制，生产者发送消息可能因为网络、交换机不存在等其他问题导致消息投递失败，消息ack机制可以在消息投递之后针对失败或者成功做一些业务的处理。</p>
</li>
<li><p><strong>只要消息发送到exchange，ConfirmCallback回调的ack=true，而returncallback是能否发送到队列的回调函数</strong></p>
</li>
<li><p>监听步骤：</p>
<ul>
<li>设置connectionFacotry的发布确认模式为<code>ConfirmType.CORRELATED</code>，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置消息发送ack，默认none</span></div><div class="line">connectionFactory.setPublisherConfirmType(CachingConnectionFactory.ConfirmType.CORRELATED);</div></pre></td></tr></table></figure>
<ul>
<li>自定义<code>RabbitTemplate.ConfirmCallback</code>的实现类，重写其中的方法，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Description</span> 消息确认回调，在消息发出之后回调</div><div class="line"> * <span class="doctag">@Author</span> CJB</div><div class="line"> * <span class="doctag">@Date</span> 2020/2/21 15:36</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfirmCallback</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> correlationData  发送消息时携带的参数，在业务上能够唯一识别，比如主键id等</div><div class="line">     * <span class="doctag">@param</span> ack  消息是否发送成功的标志，true成功，false失败</div><div class="line">     * <span class="doctag">@param</span> cause 消息发送失败的原因</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</div><div class="line">        System.err.println(correlationData.getId()+<span class="string">"----&gt;"</span>+ack+<span class="string">"---&gt;"</span>+cause);</div><div class="line">        <span class="comment">//消息投递失败执行逻辑，比如消息入库，设置失败标记等操作</span></div><div class="line">        <span class="keyword">if</span> (!ack)&#123;</div><div class="line">            System.err.println(<span class="string">"消息投递失败"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在RabbitTemplate中设置</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">template.setConfirmCallback(myConfirmCallback);</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="消息Return"><a href="#消息Return" class="headerlink" title="消息Return"></a>消息Return</h3><ul>
<li><p>用于处理一些路由不可达的消息，比如发送消息时指定的路由投递不到相应的队列，此时Return Listener就会监听到这些消息进行处理</p>
</li>
<li><p>实现步骤：</p>
<ul>
<li>设置<code>ConnectionFactory</code>的<code>publisherReturns</code>为true</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置开启发布消息的Return监听</span></div><div class="line">      connectionFactory.setPublisherReturns(<span class="keyword">true</span>);</div></pre></td></tr></table></figure>
<ul>
<li>设置RabbitTemplate的<code>`mandatory</code>为true，或者<code>mandatory-expression</code>执行的结果为true</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">template.setMandatory(<span class="keyword">true</span>);</div></pre></td></tr></table></figure>
<ul>
<li>自定义实现<code>RabbitTemplate.ReturnCallback</code>的类，重写其中的方法，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Description</span> ReturnListener的监听，处理发送消息时路由不可达的消息</div><div class="line"> * <span class="doctag">@Author</span> CJB</div><div class="line"> * <span class="doctag">@Date</span> 2020/2/21 17:04</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReturnCallBack</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ReturnCallback</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 在消息路由不可达会回调此方法，用于处理这些消息，比如记录日志，消息补偿等等操作</div><div class="line">     * <span class="doctag">@param</span> message  投递的消息</div><div class="line">     * <span class="doctag">@param</span> replyCode  响应的状态吗</div><div class="line">     * <span class="doctag">@param</span> replyText  响应的文本</div><div class="line">     * <span class="doctag">@param</span> exchange  交换机</div><div class="line">     * <span class="doctag">@param</span> routingKey  路由键</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</div><div class="line">        System.err.println(<span class="string">"message："</span>+<span class="keyword">new</span> String(message.getBody()));</div><div class="line">        System.err.println(<span class="string">"replyCode："</span>+replyCode);</div><div class="line">        System.err.println(<span class="string">"replyText："</span>+replyText);</div><div class="line">        System.err.println(<span class="string">"exchange："</span>+exchange);</div><div class="line">        System.err.println(<span class="string">"routingKey："</span>+routingKey);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在RabbitTemplate中设置</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">template.setReturnCallback(myReturnCallBack);</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><h3 id="消息异步监听"><a href="#消息异步监听" class="headerlink" title="消息异步监听"></a>消息异步监听</h3><ul>
<li><p>异步监听消息需要设置一个监听器，一旦监听的队列中有消息发送，此监听器将会起作用。</p>
</li>
<li><p>步骤如下：</p>
<ul>
<li>注入<code>SimpleMessageListenerContainer</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line">   <span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">simpleMessageListenerContainer</span><span class="params">(ConnectionFactory connectionFactory)</span></span>&#123;</div><div class="line">       SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer(connectionFactory);</div><div class="line">       <span class="comment">//添加监听的队列</span></div><div class="line">       container.addQueueNames(<span class="string">"queue1"</span>);</div><div class="line">       <span class="comment">//设置消费者ack消息的模式，默认是自动，此处设置为手动</span></div><div class="line">       container.setAcknowledgeMode(AcknowledgeMode.MANUAL);</div><div class="line">       <span class="comment">//设置消费者的并发数量</span></div><div class="line">       container.setConcurrentConsumers(<span class="number">1</span>);</div><div class="line">       <span class="comment">//设置单个消费请求能够处理的消息条数，默认250</span></div><div class="line">       container.setPrefetchCount(<span class="number">250</span>);</div><div class="line">       <span class="comment">//设置最大的并发数量</span></div><div class="line">       container.setMaxConcurrentConsumers(<span class="number">10</span>);</div><div class="line">       <span class="comment">//设置消费者的tag的生成策略，队列的名字+"_"+UUID</span></div><div class="line">       container.setConsumerTagStrategy(queue -&gt; queue+<span class="string">"_"</span>+ UUID.randomUUID().toString());</div><div class="line">       <span class="comment">//设置消息监听器</span></div><div class="line">       container.setMessageListener(customMessageListener1());</div><div class="line">       <span class="keyword">return</span> container;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>自定义一个消息监听器MessageListener的实现类，此处有两个接口：</p>
<ul>
<li><code>MessageListener</code>：实现该接口，重写其中的方法，不过此种的实现没有channel对象</li>
<li><code>ChannelAwareMessageListener</code>： 其中重写的方法除了Message对象，还提供了Channel对象，用于手动ack等操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * 自定义Message监听器</div><div class="line">    * <span class="doctag">@return</span></div><div class="line">    */</div><div class="line">   <span class="meta">@Bean</span></div><div class="line">   <span class="function"><span class="keyword">public</span> MessageListener <span class="title">customMessageListener</span><span class="params">()</span></span>&#123;</div><div class="line">       <span class="keyword">return</span> msg-&gt; System.err.println(<span class="string">"消费者："</span>+<span class="keyword">new</span> String(msg.getBody()));</div><div class="line">   &#125;</div><div class="line">    </div><div class="line">   <span class="meta">@Bean</span></div><div class="line">   <span class="function"><span class="keyword">public</span> ChannelAwareMessageListener <span class="title">customMessageListener1</span><span class="params">()</span></span>&#123;</div><div class="line">       <span class="keyword">return</span> (msg,chanel)-&gt;&#123;</div><div class="line">           <span class="keyword">long</span> deliveryTag = msg.getMessageProperties().getDeliveryTag();</div><div class="line">           <span class="keyword">try</span>&#123;</div><div class="line">               System.err.println(<span class="string">"message:"</span>+<span class="keyword">new</span> String(msg.getBody()));</div><div class="line">               System.err.println(<span class="string">"properties:"</span>+ deliveryTag);</div><div class="line">               <span class="comment">//.....执行系列的逻辑</span></div><div class="line">    </div><div class="line">               <span class="comment">//逻辑顺利执行完成之后执行ack</span></div><div class="line">               chanel.basicAck(deliveryTag,<span class="keyword">false</span>);</div><div class="line">           &#125;<span class="keyword">catch</span> (Exception ex)&#123;</div><div class="line">               <span class="comment">//记录日志等操作</span></div><div class="line">    </div><div class="line">               <span class="comment">//消息执行出现异常，nack，设置不重回队列，如果设置了死信队列，那么将会到死信队列中</span></div><div class="line">               chanel.basicNack(deliveryTag,<span class="keyword">false</span>,<span class="keyword">false</span>);</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="消费端的并发"><a href="#消费端的并发" class="headerlink" title="消费端的并发"></a>消费端的并发</h3><ul>
<li>默认一个队列只有一个消费者监听，但是我们可以同时设置多个消费者监听这个消息，提高消息消费的效率。</li>
<li><code>SimpleMessageListenerContainer</code>中的两个属性可以完成设置，如下：<ul>
<li><code>concurrentConsumers</code>：消费者的数量，默认1</li>
<li><code>maxConcurrentConsumers</code>：最大消费者的数量</li>
</ul>
</li>
</ul>
<h3 id="消费端限流（流量削峰）"><a href="#消费端限流（流量削峰）" class="headerlink" title="消费端限流（流量削峰）"></a>消费端限流（流量削峰）</h3><ul>
<li>假设rabbitmq服务器有上万条信息没有处理，当开启一个消费端的话，那么就有可能出现服务器卡死的情况。</li>
<li>Rabbitmq提供了一种qos(服务质量保证)功能，即在非确认消息的前提下（手动确认消息），如果一定数目的消息（基于consumer或者channel的qos的设置）未被确认前（没有ack或者nack），不进行消费新的消息。</li>
<li>amqp实现如下：<ul>
<li>SimpleMessageListener中有一个属性<code>prefetchCount</code>，该属性用来限制消费端的同时处理的请求，默认是250，使用spring AMQP直接设置即可，与SpringBoot整合，配置如下：</li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  rabbitmq:</span></div><div class="line"><span class="attr">    listener:</span></div><div class="line"><span class="attr">      simple:</span></div><div class="line"><span class="attr">        prefetch:</span> <span class="number">1</span></div></pre></td></tr></table></figure>
<h3 id="消息ack"><a href="#消息ack" class="headerlink" title="消息ack"></a>消息ack</h3><ul>
<li><p>默认是自动ack的，即是在接收到这条消息之后无论有没有正确消费，这条消息都会从队列中删除。当然可以设置手动ack，即是在消费者接收消息，正确处理完成之后，手动确认ack，那么此条消息才会从队列中删除。</p>
</li>
<li><p>API（Channel类）：</p>
<ul>
<li><code>void basicAck(long deliveryTag, boolean multiple)</code>：ack消息<ul>
<li><code>deliveryTag</code>：Message中的属性</li>
<li><code>multiple</code>：是否批量ack消息</li>
</ul>
</li>
<li><code>void basicNack(long deliveryTag, boolean multiple, boolean requeue)</code>：nack消息<ul>
<li><code>requeue</code>：是否重回队列，如果设置了重回队列，那么这条消息会被重新进入队列中的最后一条消息，如果设置了false并且此队列设置了死信队列，那么将会被放入死信队列中。</li>
</ul>
</li>
</ul>
</li>
<li><p>实现步骤：</p>
<ul>
<li>设置消费者的确认模式为手动确认，使用的是<code>SimpleMessageListenerContainer</code>的API</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置消费者ack消息的模式，默认是自动，此处设置为手动</span></div><div class="line">      container.setAcknowledgeMode(AcknowledgeMode.MANUAL);</div></pre></td></tr></table></figure>
<ul>
<li>消息异步监听的实现类是<code>ChannelAwareMessageListener</code>，通过自己的业务逻辑判断何时需要ack何时需要nack</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line">   <span class="function"><span class="keyword">public</span> ChannelAwareMessageListener <span class="title">customMessageListener1</span><span class="params">()</span></span>&#123;</div><div class="line">       <span class="keyword">return</span> (msg,chanel)-&gt;&#123;</div><div class="line">           <span class="keyword">long</span> deliveryTag = msg.getMessageProperties().getDeliveryTag();</div><div class="line">           <span class="keyword">try</span>&#123;</div><div class="line">               System.err.println(<span class="string">"message:"</span>+<span class="keyword">new</span> String(msg.getBody()));</div><div class="line">               System.err.println(<span class="string">"properties:"</span>+ deliveryTag);</div><div class="line">               <span class="comment">//.....执行系列的逻辑</span></div><div class="line">  </div><div class="line">               <span class="comment">//逻辑顺利执行完成之后执行ack</span></div><div class="line">               chanel.basicAck(deliveryTag,<span class="keyword">false</span>);</div><div class="line">           &#125;<span class="keyword">catch</span> (Exception ex)&#123;</div><div class="line">               <span class="comment">//记录日志等操作</span></div><div class="line">  </div><div class="line">               <span class="comment">//消息执行出现异常，nack，设置不重回队列，如果设置了死信队列，那么将会到死信队列中</span></div><div class="line">               chanel.basicNack(deliveryTag,<span class="keyword">false</span>,<span class="keyword">false</span>);</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="消息重回队列"><a href="#消息重回队列" class="headerlink" title="消息重回队列"></a>消息重回队列</h3><ul>
<li><p>重回队列的机制即是消息在nack之后如果设置了重回队列，那么此条消息将会被重新放入到此队列中的最后一条，之后将会被重新投递到消费端消费。</p>
</li>
<li><p>重回队列的机制并不支持使用，如果是业务逻辑上的异常导致消息重回队列，那么重新消费也是没有多大意义。在实际的工作上可以采用补偿机制解决。</p>
</li>
<li><p>设置重回队列如下：</p>
<ul>
<li><code>SimpleMessageListenerContainer</code>中设置默认的行为如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置不重回队列，默认为true，即是消息被拒绝或者nack或者监听器抛出异常之后会重新返回队列</span></div><div class="line">       container.setDefaultRequeueRejected(<span class="keyword">false</span>);</div></pre></td></tr></table></figure>
<ul>
<li>在nack消息的时候有一个requeue的属性设置，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//消息执行出现异常，nack，requeue=false设置不重回队列，如果设置了死信队列，那么将会到死信队列中</span></div><div class="line">chanel.basicNack(deliveryTag,<span class="keyword">false</span>,<span class="keyword">false</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h3><ul>
<li>消息变成死信的情况如下（<strong>前提：消息所在队列设置了死信队列</strong>）：<ul>
<li>消息被拒绝（nack/reject）并且requeue=false（不设置重回队列）</li>
<li>消息的TTL过期</li>
<li>队列达到最大长度</li>
</ul>
</li>
<li>死信队列在rabbitmq中其实是一个exchange，只是普通的交换机和队列。</li>
<li>想要消息被拒绝或者过期之后能够回到死信队列中，需要在队列声明的时候添加一个<code>x-dead-letter-exchange</code>，指定死信的交换机</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">   String exchange=<span class="string">"a_exchange"</span>;</div><div class="line">      String queueName=<span class="string">"a_queue"</span>;</div><div class="line">      TopicExchange topicExchange = <span class="keyword">new</span> TopicExchange(exchange, <span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line">      Map&lt;String,Object&gt; arguments=<span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">      <span class="comment">//指定死信队列，dlx-exchange是死信交换机</span></div><div class="line">      arguments.put(<span class="string">"x-dead-letter-exchange"</span>, <span class="string">"dlx-exchange"</span>);</div><div class="line"><span class="comment">//设置死信队列的路由键，需要根据这个路由键找到对应的队列</span></div><div class="line">arguments.put(<span class="string">"x-dead-letter-routing-key"</span>, <span class="string">"dlx-key"</span>);</div><div class="line">      Queue queue = <span class="keyword">new</span> Queue(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, arguments);</div><div class="line">      Binding binding = BindingBuilder.bind(queue).to(topicExchange).with(<span class="string">"test.#"</span>);</div><div class="line">      rabbitAdmin.declareQueue(queue);</div><div class="line">      rabbitAdmin.declareExchange(topicExchange);</div><div class="line">      rabbitAdmin.declareBinding(binding);</div></pre></td></tr></table></figure>
<h2 id="事务【不推荐】"><a href="#事务【不推荐】" class="headerlink" title="事务【不推荐】"></a>事务【不推荐】</h2><ul>
<li><p>rabbitmq默认是没有开启事务的，提交和发送消息甚至业务逻辑中间涉及到数据库操作都不在同一个事务中。</p>
</li>
<li><p>amqp如何设置事务：</p>
<ul>
<li>关闭生产的消息确认（ack），当然默认是不开启的，投递消息的确认和事务是不能同时存在的</li>
<li>设置RabbitTemplate中的<code>setChannelTransacted</code>方法为true，表示使用事务。</li>
<li>定义事务管理器<code>RabbitTransactionManager</code>，实现了<code>PlatformTransactionManager</code>，这个事务管理器的事务只针对rabbitmq消息的发送和获取，对数据库的事务无效</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line">   <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">()</span></span>&#123;</div><div class="line">       RabbitTransactionManager manager = <span class="keyword">new</span> RabbitTransactionManager();</div><div class="line">       manager.setConnectionFactory(connectionFactory());</div><div class="line">       <span class="keyword">return</span> manager;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li>同步发送和消费消息的事务，使用@Transactional注解（<strong>无需声明RabbitTransactionManager，直接使用数据源的事务即可完成数据和mq消息的事务</strong>），如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Transactional</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(String msg)</span></span>&#123;</div><div class="line">       <span class="comment">//接收消息</span></div><div class="line">       Message message1 = rabbitTemplate.receive(<span class="string">"a_queue"</span>);</div><div class="line">       System.err.println(<span class="keyword">new</span> String(message1.getBody()));</div><div class="line">  </div><div class="line">       String queueName=<span class="string">"direc_q_1"</span>;</div><div class="line">       String exchangeName=<span class="string">"direct_1"</span>;</div><div class="line">       String  routingKey=<span class="string">"direct"</span>;</div><div class="line">       Message message = MessageBuilder.withBody(msg.getBytes()).andProperties(<span class="keyword">new</span> MessageProperties()).build();</div><div class="line">       rabbitTemplate.send(exchangeName,routingKey,message,<span class="keyword">new</span> CorrelationData(UUID.randomUUID().toString()));</div><div class="line">       <span class="comment">//此处出现异常，事务将会回滚</span></div><div class="line">       System.out.println(<span class="number">1</span>/<span class="number">0</span>);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>异步消费消息使用的是监听器，此时就需要在SimpleMessageListenerContainer中设置，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//开启事务</span></div><div class="line">      container.setChannelTransacted(<span class="keyword">true</span>);</div><div class="line">      <span class="comment">//设置事务管理器</span></div><div class="line">      container.setTransactionManager(transactionManager());</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><ul>
<li><a href="https://github.com/chenjiabing666/amqp-demo" target="_blank" rel="external">https://github.com/chenjiabing666/amqp-demo</a></li>
</ul>
<h2 id="更多文章请移步公众号"><a href="#更多文章请移步公众号" class="headerlink" title="更多文章请移步公众号"></a>更多文章请移步公众号</h2><ul>
<li><img src="https://raw.githubusercontent.com/chenjiabing666/BlogImage/master/myjszl.jpg" alt=""></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitAdmin&quot;&gt;&lt;a href=&quot;#RabbitAdmin&quot; class=&quot;headerlink&quot; title=&quot;RabbitAdmin&quot;&gt;&lt;/a&gt;RabbitAdmin&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;队列，交换器的声明创建、删除、清空&lt;/li&gt;
&lt;li&gt;创
    
    </summary>
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁-redis实现</title>
    <link href="http://chenjiabing666.github.io/2020/03/07/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-redis%E5%AE%9E%E7%8E%B0/"/>
    <id>http://chenjiabing666.github.io/2020/03/07/分布式锁-redis实现/</id>
    <published>2020-03-07T09:53:15.000Z</published>
    <updated>2020-03-13T06:20:54.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要分布式锁"><a href="#为什么要分布式锁" class="headerlink" title="为什么要分布式锁"></a>为什么要分布式锁</h2><ul>
<li>在单机的情况下，可以通过jvm提供的系列线程安全的操作来处理高并发的情况，但是在分布式的环境下，jvm提供的线程安全操作明显是不能满足要求的。在一些小型的互联网公司经常做的crud操作如果在高并发的情况下会出现很大的问题，比如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//伪代码：下订单</span></div><div class="line"><span class="number">1</span>、查库存：getStock()</div><div class="line"><span class="number">2</span>、判断库存：stock&gt;<span class="number">0</span>下单</div><div class="line"><span class="number">3</span>、下单：addOrder()</div><div class="line"><span class="number">4</span>、减库存</div></pre></td></tr></table></figure>
<ul>
<li>仅仅以上三步，如果在高并发的情况下，无论是单机或者集群，如果不加锁一定会出现超卖的情况。一瞬间成千上万个请求过来，如何能够确保查询到的库存是最新的数据？</li>
</ul>
<h2 id="Redis实现"><a href="#Redis实现" class="headerlink" title="Redis实现"></a>Redis实现</h2><ul>
<li>通过redis的setNx方法可以自己简单的实现以下分布式锁，但是在实现之前需要考虑清楚几个问题。</li>
</ul>
<h3 id="问题与解决思路"><a href="#问题与解决思路" class="headerlink" title="问题与解决思路"></a>问题与解决思路</h3><ul>
<li><strong>如何避免死锁？</strong>在高并发的情况下很可能由于服务重启，服务器宕机的等情况导致锁没有及时释放，导致其他线程不能获得锁。<ul>
<li>setNx的使用设置一个过期时间，当锁没有手动释放的时候能够超过一定时间自动释放</li>
<li>这个时间如何设置？如果业务没有执行完成但是过期时间到了，这个锁释放了，怎么处理？<ul>
<li>过期时间最好能够是业务执行完成的时间，为了防止时间到了业务没有执行完成，可以分开一个线程或者设置一个定时器，定时的延长这个过期时间，直到当前线程完成业务。</li>
</ul>
</li>
</ul>
</li>
<li><strong>如何避免锁的误删（设置过期时间没有设置定时器延长过期时间）？</strong>高并发的情况下瞬间几万个请求过来，很有可能A线程执行完成之后，但是B线程没有执行完成（<em>前提：B线程先获得锁先执行并且未执行完成之后过期时间到了删除了自己持有的锁，此时A线程获得锁并率先执行完成</em>），A线程执行<strong>deleteKey</strong>方法，删除了B的锁。<ul>
<li>在执行每一个业务逻辑之前先生成一个唯一id作为setNx的value值标识这个线程执行的任务，删除的时候先获取和当前线程的id比对一下，如果不一样，这个锁不是当前的线程持有的。</li>
</ul>
</li>
<li><strong>如何保证锁的可重入性？</strong><ul>
<li>在获取锁的时候先获取锁，比对一下当前的唯一标识，相同的话可重入。</li>
</ul>
</li>
<li><strong>如何确保获取锁和释放锁的原子性？</strong>在获取锁或者释放锁的过程中如果不是原子操作很有可能导致一系列问题<ul>
<li>使用Lua脚本获取锁和释放锁来保证原子性</li>
</ul>
</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li>根据上面的思路可以通过redis自己手写一个分布式锁的实现，当然这个例子并没有保证解锁和获得锁的原子性，不喜勿喷。</li>
<li>redis的工具类：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisUtils</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RedisTemplate redisTemplate=ApplicationContextUtils.applicationContext.getBean(<span class="string">"redisTemplate"</span>,RedisTemplate.class);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StringRedisTemplate stringRedisTemplate=ApplicationContextUtils.applicationContext.getBean(StringRedisTemplate.class);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * setNx</div><div class="line">     * <span class="doctag">@param</span> key</div><div class="line">     * <span class="doctag">@param</span> value</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">setNx</span><span class="params">(String key,String value)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> stringRedisTemplate.opsForValue().setIfAbsent(key,value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * setNx</div><div class="line">     * <span class="doctag">@param</span> key</div><div class="line">     * <span class="doctag">@param</span> value</div><div class="line">     * <span class="doctag">@param</span> seconds  过期时间，单位秒</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">setNx</span><span class="params">(String key, String value, Long seconds)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> stringRedisTemplate.opsForValue().setIfAbsent(key,value,seconds, TimeUnit.SECONDS);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 删除key</div><div class="line">     * <span class="doctag">@param</span> key</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">deleteKey</span><span class="params">(String key)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> redisTemplate.delete(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取NX设置的值</div><div class="line">     * <span class="doctag">@param</span> key</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getNX</span><span class="params">(String key)</span></span>&#123;</div><div class="line">       <span class="keyword">return</span> stringRedisTemplate.opsForValue().get(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置key的过期时间</div><div class="line">     * <span class="doctag">@param</span> key</div><div class="line">     * <span class="doctag">@param</span> seconds</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">expireKey</span><span class="params">(String key,Long seconds)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> stringRedisTemplate.expire(key,seconds,TimeUnit.SECONDS);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>分布式锁的实现：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLock</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 存储的KEY，每个业务应该不同</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> String key;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 过期时间，单位秒</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Long expireSeconds;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 异步任务，用于分开一个线程延长过期时间，也可以使用定时器</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> TaskAsync taskAsync;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisLock</span><span class="params">(String key,Long expireSeconds)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.key=key;</div><div class="line">        <span class="keyword">this</span>.expireSeconds=expireSeconds;</div><div class="line">        taskAsync= ApplicationContextUtils.applicationContext.getBean(TaskAsync.class);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 上锁</div><div class="line">     * <span class="doctag">@param</span>  uuid setNx的值，唯一标识当前线程</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(String uuid)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="comment">//获取value</span></div><div class="line">        String nx = RedisUtils.getNX(key);</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 如果此时的uuid和redis中的一致，那么就是可重入的</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (StringUtils.equals(nx,uuid))&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果不一致，需要设置，为了避免死锁，需要设置一个过期时间</span></div><div class="line">        Boolean b = RedisUtils.setNx(key, uuid,expireSeconds);</div><div class="line">        <span class="comment">//加锁失败，每隔两秒重试一次</span></div><div class="line">        <span class="keyword">while</span>(!b)&#123;</div><div class="line">            b = RedisUtils.setNx(key, uuid,expireSeconds);</div><div class="line">            Thread.sleep(<span class="number">2000</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//开启异步线程延长过期时间</span></div><div class="line">        taskAsync.delayExpireTime(uuid,key,expireSeconds);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 解锁</div><div class="line">     * <span class="doctag">@param</span>  uuid 为了避免误删，这里的uuid是唯一标识当前方法执行的，如果和当前方法的相同才能删除</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(String uuid)</span> </span>&#123;</div><div class="line">         String value= RedisUtils.getNX(key);</div><div class="line">         <span class="comment">//说明当前线程执行的方法所获得的锁已经被释放了</span></div><div class="line">         <span class="keyword">if</span> (!StringUtils.equals(value,uuid))&#123;</div><div class="line">             <span class="keyword">return</span>;</div><div class="line">         &#125;</div><div class="line">        Boolean b = RedisUtils.deleteKey(key);</div><div class="line">        <span class="keyword">while</span>(!b)&#123;</div><div class="line">            b=RedisUtils.deleteKey(key);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>异步线程延长锁的过期时间：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskAsync</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 异步开一个线程延长执行的任务，</div><div class="line">     * <span class="doctag">@param</span> uuid 当前线程持有锁的唯一标识</div><div class="line">     * <span class="doctag">@param</span>  key key</div><div class="line">     * <span class="doctag">@param</span>  expireSeconds 过期时间</div><div class="line">     */</div><div class="line">    <span class="meta">@Async</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delayExpireTime</span><span class="params">(String uuid,String key,Long expireSeconds)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="comment">//无限循环</span></div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">            String nx = RedisUtils.getNX(key);</div><div class="line">            <span class="comment">//key对应的值不存在，或者不等于当前方法的唯一id，直接跳出，不需要延长时间了</span></div><div class="line">            <span class="keyword">if</span> (nx==<span class="keyword">null</span>||!StringUtils.equals(uuid,nx))</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="comment">//延长时间</span></div><div class="line">            RedisUtils.expireKey(key,expireSeconds);</div><div class="line">            Thread.sleep(<span class="number">3000L</span>);</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h2><ul>
<li>Redisson和jedis一样同样是redis的客户端，但是其在解决分布式问题上有着很大的优势，对分布式锁的实现更是封装的更加简洁，能够通过简单的api完成。</li>
<li>Redisson封装了多种锁，包括重入锁，公平锁，红锁……，这里简单的演示一下重入锁的使用方式。</li>
</ul>
<h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><ul>
<li><code>RedissonClient</code>通过<code>getxxLock(name)</code>获取不同锁的对象，RLock对应的是可重入锁的接口。与SpringBoot整合之后，配置的方式创建RedissonClient，并且注入了一个处理订单业务的锁：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableConfigurationProperties</span>(value = &#123;RedissonProperties.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonConfig</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 注入RedissonClient对象</div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> RedissonClient <span class="title">redissonClient</span><span class="params">(RedissonProperties redissonProperties)</span></span>&#123;</div><div class="line">        Config config = <span class="keyword">new</span> Config();</div><div class="line">        config.useSingleServer().setAddress(redissonProperties.getAddress()).setPassword(redissonProperties.getPassword()).setDatabase(redissonProperties.getDatabase());</div><div class="line">        <span class="keyword">return</span> Redisson.create(config);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 注入可重入锁，用于订单业务</div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> RLock <span class="title">orderLock</span><span class="params">(@Qualifier(value = <span class="string">"redissonClient"</span>)</span> RedissonClient redissonClient,RedissonProperties redissonProperties)</span>&#123;</div><div class="line">        <span class="keyword">return</span> redissonClient.getLock(redissonProperties.getOrderLock());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>模拟订单的下单，如下：<ul>
<li><code>void lock(long leaseTime, TimeUnit unit)</code>：获得锁，leaseTime设置的过期时间，unit是时间单位，如果设置了-1，redisson会设置默认的时间30秒，这个时间可以在config配置中修改，具体看文档。锁的值是<code>UUID:线程Id</code>(作为唯一标识)</li>
<li><code>void unlock()</code>：解锁</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String goodsId)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//获取锁</span></div><div class="line">            rLock.lock(<span class="number">10</span>, TimeUnit.SECONDS);</div><div class="line">            <span class="comment">//检查库存，存储在redis中</span></div><div class="line">            Integer stock = Integer.valueOf(stringRedisTemplate.opsForValue().get(goodsId));</div><div class="line">            <span class="keyword">if</span> (stock&lt;<span class="number">0</span>)</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            <span class="comment">//减库存</span></div><div class="line">            Long increment = stringRedisTemplate.opsForValue().increment(goodsId, -<span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span> (increment&lt;<span class="number">0</span>)</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            <span class="comment">//减库存成功，下单</span></div><div class="line">            Order order = Order.builder().build();</div><div class="line">            orderMapper.add(order);</div><div class="line">        &#125;<span class="keyword">finally</span> &#123;</div><div class="line">            <span class="comment">//解锁</span></div><div class="line">            rLock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><ul>
<li>Redisson的文档很齐全，具体可看文档<a href="https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95" target="_blank" rel="external">https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95</a></li>
</ul>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么要分布式锁&quot;&gt;&lt;a href=&quot;#为什么要分布式锁&quot; class=&quot;headerlink&quot; title=&quot;为什么要分布式锁&quot;&gt;&lt;/a&gt;为什么要分布式锁&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在单机的情况下，可以通过jvm提供的系列线程安全的操作来处理高并发的情况，但是在
    
    </summary>
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://chenjiabing666.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Shiro</title>
    <link href="http://chenjiabing666.github.io/2019/08/17/Shiro/"/>
    <id>http://chenjiabing666.github.io/2019/08/17/Shiro/</id>
    <published>2019-08-17T11:22:05.000Z</published>
    <updated>2020-03-13T06:10:24.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h1><ul>
<li>添加Shiro的依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--Spring整合的shiro依赖--&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<h1 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h1><ul>
<li>Shiro的组件之一</li>
<li>其各个子类分别有不同职责</li>
</ul>
<h2 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h2><ul>
<li><code>CachingRealm</code>：提供了缓存的功能，其中配置了缓存管理器</li>
<li><code>AuthenticatingRealm</code>：负责认证的Realm，继承了CachingRealm，因此对认证的信息也是有缓存的功能，默认是关闭的，其中有一个重要的方法，如下：<ul>
<li><code>protected abstract AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token)</code>：用于子类实现认证的真正的逻辑</li>
</ul>
</li>
<li><code>AuthorizingRealm</code>：负责授权的Realm，不过继承了<code>AuthenticatingRealm</code>，因此具有认证和缓存的功能</li>
</ul>
<h2 id="自定义Realm"><a href="#自定义Realm" class="headerlink" title="自定义Realm"></a>自定义Realm</h2><ul>
<li>通常我们只需要完成认证授权，因此只需要继承AuthorizingRealm即可，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义的Realm，完成认证和授权</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> UserMapper userMapper;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> RoleMapper roleMapper;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> UserRoleMapper userRoleMapper;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> RolePermissionMapper rolePermissionMapper;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"userRealm"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 完成授权，主要的作用就是从数据库中查询出用户的角色和权限封装在AuthorizationInfo返回即可</div><div class="line">     * <span class="doctag">@param</span> principals 在认证的过程中返回的Principal，可以是一个User对象，也可以是userId等标志用户信息</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"授权。。。。"</span>);</div><div class="line">        SimpleAuthorizationInfo authorizationInfo = <span class="keyword">new</span> SimpleAuthorizationInfo();</div><div class="line">        <span class="keyword">final</span> HashSet&lt;String&gt; pers = Sets.newHashSet();</div><div class="line">        <span class="keyword">final</span> HashSet&lt;String&gt; roles = Sets.newHashSet();</div><div class="line">        <span class="comment">//获取用户信息</span></div><div class="line">        User user= (User) principals.getPrimaryPrincipal();</div><div class="line">        List&lt;UserRole&gt; userRole = userRoleMapper.selectByUserId(user.getId());</div><div class="line">        <span class="comment">//如果userRole存在</span></div><div class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(userRole))&#123;</div><div class="line">            <span class="comment">//获取权限</span></div><div class="line">            userRole.stream().forEach(o-&gt;&#123;</div><div class="line">                rolePermissionMapper.selectByRoleId(o.getRoleId()).stream().forEach(item-&gt;&#123;</div><div class="line">                    pers.add(item.getDesc());</div><div class="line">                &#125;);</div><div class="line">                <span class="comment">//获取角色</span></div><div class="line">                Role role = roleMapper.selectById(o.getRoleId());</div><div class="line">                roles.add(role.getRoleName());</div><div class="line">            &#125;);</div><div class="line">            authorizationInfo.setRoles(roles);</div><div class="line">            authorizationInfo.setStringPermissions(pers);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> authorizationInfo;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 认证</div><div class="line">     * <span class="doctag">@param</span> token</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     * <span class="doctag">@throws</span> AuthenticationException</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"认证。。。。"</span>);</div><div class="line">        UsernamePasswordToken upToken= (UsernamePasswordToken) token;</div><div class="line">        <span class="comment">//用户名</span></div><div class="line">        String userName = (String) upToken.getPrincipal();</div><div class="line">        User user = userMapper.selectByUserName(userName);</div><div class="line">        <span class="keyword">if</span> (Objects.isNull(user))&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationException(<span class="string">"用户不存在"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//该构造器还可以使用加密算法</span></div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(user,user.getPassword(),getName());</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 清除CacheManager中的缓存，可以在用户权限改变的时候调用，这样再次需要权限的时候就会重新查询数据库不走缓存了</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span> </span>&#123;</div><div class="line">        Subject subject = SecurityUtils.getSubject();</div><div class="line">        <span class="comment">//此处调用父类的方法，不仅会清除授权缓存，如果认证信息也缓存了，那么也会删除认证的缓存</span></div><div class="line">        <span class="keyword">super</span>.clearCache(subject.getPrincipals());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>将其配置到安全管理器中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * 配置UserRealm，完成认证和授权的两个流程</div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> UserRealm <span class="title">userRealm</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserRealm();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">     * 配置安全管理器</div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> SecurityManager <span class="title">securityManager</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//使用web下的安全管理器，构造参数传入Realm</span></div><div class="line">        DefaultWebSecurityManager securityManager = <span class="keyword">new</span> DefaultWebSecurityManager(userRealm());</div><div class="line">        <span class="comment">//设置缓存管理器</span></div><div class="line">        securityManager.setCacheManager(cacheManager());</div><div class="line">        <span class="comment">//设置会话管理器</span></div><div class="line">        securityManager.setSessionManager(sessionManager());</div><div class="line">        <span class="keyword">return</span> securityManager;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="认证信息的缓存"><a href="#认证信息的缓存" class="headerlink" title="认证信息的缓存"></a>认证信息的缓存</h2><ul>
<li>默认是关闭的，只需要开启即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">	<span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> UserRealm <span class="title">userRealm</span><span class="params">()</span></span>&#123;</div><div class="line">        UserRealm userRealm = <span class="keyword">new</span> UserRealm();</div><div class="line">        <span class="comment">//开启认证信息的缓存，默认关闭，key是UserNamePasswordToken，value就是principle</span></div><div class="line">        userRealm.setAuthenticationCachingEnabled(<span class="keyword">true</span>);</div><div class="line">        <span class="comment">//开启授权信息的缓存，默认开启</span></div><div class="line">        userRealm.setAuthorizationCachingEnabled(<span class="keyword">true</span>);</div><div class="line">        <span class="keyword">return</span> userRealm;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//SecurityManager中设置缓存管理器</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>认证信息缓存也需要在用户的个人信息改变的时候清除缓存</strong></li>
</ul>
<h2 id="密码加密认证"><a href="#密码加密认证" class="headerlink" title="密码加密认证"></a>密码加密认证</h2><ul>
<li><p>在正常的场景中都会涉及到对密码的加密，在Shiro中也提供了密码加密的认证，只需要配置一个凭证匹配器即可，步骤如下：</p>
<ul>
<li>在自定义的UserRealm中配置凭证匹配器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line">   <span class="function"><span class="keyword">public</span> UserRealm <span class="title">userRealm</span><span class="params">()</span></span>&#123;</div><div class="line">       UserRealm userRealm = <span class="keyword">new</span> UserRealm();</div><div class="line">       <span class="comment">//开启认证信息的缓存，默认关闭，key是UserNamePasswordToken，value就是principle</span></div><div class="line">       userRealm.setAuthenticationCachingEnabled(<span class="keyword">false</span>);</div><div class="line">       <span class="comment">//开启授权信息的缓存，默认开启</span></div><div class="line">       userRealm.setAuthorizationCachingEnabled(<span class="keyword">true</span>);</div><div class="line">       <span class="comment">//配置凭证匹配器，加密方式MD5</span></div><div class="line">       HashedCredentialsMatcher credentialsMatcher = <span class="keyword">new</span> HashedCredentialsMatcher(<span class="string">"MD5"</span>);</div><div class="line">       <span class="comment">//加密两次</span></div><div class="line">       credentialsMatcher.setHashIterations(<span class="number">2</span>);</div><div class="line">       <span class="comment">//设置凭证匹配器</span></div><div class="line">       userRealm.setCredentialsMatcher(credentialsMatcher);</div><div class="line">       <span class="keyword">return</span> userRealm;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li>在认证的方法中构建使用加密的<code>AuthenticationInfo</code>，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//第一个参数是principle，第二个参数是加密之后的密码，第三个参数是加密的盐，第四个参数是UserRealm的名称</span></div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(user,user.getPassword(),ByteSource.Util.bytes(user.getSalt()),getName());</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="缓存管理器（CacheManager）"><a href="#缓存管理器（CacheManager）" class="headerlink" title="缓存管理器（CacheManager）"></a>缓存管理器（CacheManager）</h1><ul>
<li><p>在每一次请求需要权限的时候总是会调用授权的方法查询数据库，这样的话性能很低，因此我们可以使用缓存管理器，来达到这种要求，在Shiro中有一个内存缓存管理器，内部就是使用Map实现的，但是这种缓存并不能实现跨JVM（分布式），因此我们可以使用Redis自定义一个缓存管理器，步骤如下：</p>
<ul>
<li>实现RedisCache，用于实现对授权信息的缓存，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Redis的Cache</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCache</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Cache</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 存储在redis中的hash中的key</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String COMMON_NAME=<span class="string">"shiro-demo"</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisCache</span><span class="params">(RedisTemplate redisTemplate, String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.redisTemplate = redisTemplate;</div><div class="line">        <span class="keyword">this</span>.name=COMMON_NAME+<span class="string">":"</span>+name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取指定的key的缓存</div><div class="line">     * <span class="doctag">@param</span> k</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     * <span class="doctag">@throws</span> CacheException</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span> <span class="keyword">throws</span> CacheException </span>&#123;</div><div class="line">        <span class="keyword">return</span> (V) redisTemplate.opsForHash().get(name,k);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 添加缓存</div><div class="line">     * <span class="doctag">@param</span> k</div><div class="line">     * <span class="doctag">@param</span> v</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     * <span class="doctag">@throws</span> CacheException</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K k, V v)</span> <span class="keyword">throws</span> CacheException </span>&#123;</div><div class="line">        redisTemplate.opsForHash().put(name, k, v);</div><div class="line">        <span class="comment">//设置过期时间</span></div><div class="line">        <span class="keyword">return</span> v;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 删除指定key的缓存</div><div class="line">     * <span class="doctag">@param</span> k 默认是principle对象，在AuthorizingRealm中设置</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K k)</span> <span class="keyword">throws</span> CacheException </span>&#123;</div><div class="line">        V v = <span class="keyword">this</span>.get(k);</div><div class="line">        redisTemplate.opsForHash().delete(name, k);</div><div class="line">        <span class="keyword">return</span> v;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 删除所有的缓存</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> <span class="keyword">throws</span> CacheException </span>&#123;</div><div class="line">        redisTemplate.delete(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取总数</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().size(name).intValue();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().keys(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().values(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>实现RedisManager，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Redis的CacheManager</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCacheManager</span> <span class="keyword">implements</span> <span class="title">CacheManager</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> &lt;K, V&gt; <span class="function">Cache&lt;K, V&gt; <span class="title">getCache</span><span class="params">(String s)</span> <span class="keyword">throws</span> CacheException </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedisCache&lt;K,V&gt;(redisTemplate, s);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在配置类中配置上缓存管理器，需要设置到Shiro的安全管理器中才能生效，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * 配置缓存管理器，使用自定义的Redis缓存管理器</div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedisCacheManager();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 配置安全管理器</div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> SecurityManager <span class="title">securityManager</span><span class="params">()</span></span>&#123;</div><div class="line">        DefaultWebSecurityManager securityManager = <span class="keyword">new</span> DefaultWebSecurityManager(userRealm());</div><div class="line">        <span class="comment">//设置缓存管理器</span></div><div class="line">        securityManager.setCacheManager(cacheManager());</div><div class="line">        <span class="keyword">return</span> securityManager;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a>清除缓存</h2><ul>
<li>在CachingRelam中有一个清除缓存的方法<code>org.apache.shiro.realm.CachingRealm#clearCache</code>，在我们自定义的Realm中覆盖该方法即可，这样就能在<strong>退出或者在业务逻辑中用户的权限改变</strong>的时候能够清除缓存的数据，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * 清除CacheManager中的缓存，可以在用户权限改变的时候调用，这样再次需要权限的时候就会重新查询数据库不走缓存了</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span> </span>&#123;</div><div class="line">       Subject subject = SecurityUtils.getSubject();</div><div class="line">       <span class="comment">//调用父类的清除缓存的方法</span></div><div class="line">       <span class="keyword">super</span>.clearCache(subject.getPrincipals());</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>除了重写或者覆盖CachingRelam中的方法，根据源码可以知道，真正起作用的方法是<code>AuthorizingRealm</code>中的方法<code>clearCachedAuthorizationInfo</code>，因此我们也可以重写或者覆盖这个方法，这里不再演示。</strong></li>
</ul>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><ul>
<li>在Shiro中一旦有地方调用<code>Subject.hasRole</code>等校验权限的地方，那么就会检测授权信息，在<code>org.apache.shiro.realm.AuthorizingRealm#getAuthorizationInfo</code>的方法中会先缓存中查询是否存在，否则调用授权的方法从数据库中查询，查询之后放入缓存中，源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">getAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (principals == <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       AuthorizationInfo info = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</div><div class="line">           log.trace(<span class="string">"Retrieving AuthorizationInfo for principals ["</span> + principals + <span class="string">"]"</span>);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">    	<span class="comment">//获取可用的缓存管理器</span></div><div class="line">       Cache&lt;Object, AuthorizationInfo&gt; cache = getAvailableAuthorizationCache();</div><div class="line">       <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</div><div class="line">               log.trace(<span class="string">"Attempting to retrieve the AuthorizationInfo from cache."</span>);</div><div class="line">           &#125;</div><div class="line">           <span class="comment">//获取缓存的key，这里获取的就是principal主体信息</span></div><div class="line">           Object key = getAuthorizationCacheKey(principals);</div><div class="line">           <span class="comment">//从缓存中获取数据</span></div><div class="line">           info = cache.get(key);</div><div class="line">           <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</div><div class="line">               <span class="keyword">if</span> (info == <span class="keyword">null</span>) &#123;</div><div class="line">                   log.trace(<span class="string">"No AuthorizationInfo found in cache for principals ["</span> + principals + <span class="string">"]"</span>);</div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   log.trace(<span class="string">"AuthorizationInfo found in cache for principals ["</span> + principals + <span class="string">"]"</span>);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">	<span class="comment">//如果缓存中没有查到</span></div><div class="line">       <span class="keyword">if</span> (info == <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="comment">//调用重写的授权方法，从数据库中查询</span></div><div class="line">           info = doGetAuthorizationInfo(principals);</div><div class="line">  		<span class="comment">//如果查询到了，添加到缓存中</span></div><div class="line">           <span class="keyword">if</span> (info != <span class="keyword">null</span> &amp;&amp; cache != <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</div><div class="line">                   log.trace(<span class="string">"Caching authorization info for principals: ["</span> + principals + <span class="string">"]."</span>);</div><div class="line">               &#125;</div><div class="line">               <span class="comment">//获取缓存的key</span></div><div class="line">               Object key = getAuthorizationCacheKey(principals);</div><div class="line">               <span class="comment">//放入缓存</span></div><div class="line">               cache.put(key, info);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">return</span> info;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h1 id="会话管理器（SessionManager）"><a href="#会话管理器（SessionManager）" class="headerlink" title="会话管理器（SessionManager）"></a>会话管理器（SessionManager）</h1><ul>
<li>Shiro在开启Web功能的时候默认的会话管理器是DefaultWebSessionManager，这种管理器是针对cookie进行存储的，将sessionId存储在cookie中，但是现在的主流方向是前后端分离，我们不能再依赖Cookie，因此我们必须自定义的会话管理器，实现跨JVM，前后端分离。</li>
</ul>
<h2 id="自定义SessionMananger"><a href="#自定义SessionMananger" class="headerlink" title="自定义SessionMananger"></a>自定义SessionMananger</h2><ul>
<li>在原有的DefaultWebSessionManager进行扩展，否则从头实现将会要写大量代码。默认的Web的会话管理器是从cookie中获取SessionId，我们只需要重写其中的方法即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义的会话管理器</div><div class="line"> */</div><div class="line"><span class="meta">@Slf</span>4j</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSessionManager</span> <span class="keyword">extends</span> <span class="title">DefaultWebSessionManager</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 前后端分离不存在cookie，因此需要重写getSessionId的逻辑，从请求参数中获取</div><div class="line">     * 此处的逻辑：在登录成功之后会将sessionId作为一个token返回，下次请求的时候直接带着token即可</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Serializable <span class="title">getSessionId</span><span class="params">(ServletRequest request, ServletResponse response)</span> </span>&#123;</div><div class="line">        <span class="comment">//获取上传的token,这里的token就是sessionId</span></div><div class="line">        <span class="keyword">return</span> request.getParameter(<span class="string">"token"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 重写该方法，在SessionManager中只要涉及到Session的操作都会获取Session，获取Session主要是从缓存中获取，父类的该方法执行逻辑如下：</div><div class="line">     *  1、先从RedisCache中获取，调用get方法</div><div class="line">     *  2、如果RedisCache中不存在，在从SessionDao中获取，调用get方法</div><div class="line">     *  优化：我们只需要从SessionDao中获取即可</div><div class="line">     * <span class="doctag">@param</span> sessionKey Session的Key</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Session <span class="title">retrieveSession</span><span class="params">(SessionKey sessionKey)</span> <span class="keyword">throws</span> UnknownSessionException </span>&#123;</div><div class="line">        <span class="comment">//获取SessionId</span></div><div class="line">        Serializable sessionId = getSessionId(sessionKey);</div><div class="line">        <span class="keyword">if</span> (sessionId == <span class="keyword">null</span>) &#123;</div><div class="line">            log.debug(<span class="string">"Unable to resolve session ID from SessionKey [&#123;&#125;].  Returning null to indicate a "</span> +</div><div class="line">                    <span class="string">"session could not be found."</span>, sessionKey);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//直接调用SessionDao中的get方法获取</span></div><div class="line">        Session session = ((RedisSessionDao) sessionDAO).doReadSession(sessionId);</div><div class="line">        <span class="keyword">if</span> (session == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//session ID was provided, meaning one is expected to be found, but we couldn't find one:</span></div><div class="line">            String msg = <span class="string">"Could not find session with ID ["</span> + sessionId + <span class="string">"]"</span>;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnknownSessionException(msg);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> session;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 该方法是作用是当访问指定的uri的时候会更新Session中的执行时间，用来动态的延长失效时间。</div><div class="line">     * 在父类的实现方法会直接调用SessionDao中的更新方法更新缓存中的Session</div><div class="line">     * 此处并没有其他的逻辑，后续可以补充</div><div class="line">     * <span class="doctag">@param</span> key</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">touch</span><span class="params">(SessionKey key)</span> <span class="keyword">throws</span> InvalidSessionException </span>&#123;</div><div class="line">        <span class="keyword">super</span>.touch(key);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="自定义SessionDao"><a href="#自定义SessionDao" class="headerlink" title="自定义SessionDao"></a>自定义SessionDao</h2><ul>
<li>SessionDao的作用是Session持久化的手段，默认的SessionDao是缓存在内存中的，此处使用Redis作为缓存的工具，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义RedisSessionDao，继承CachingSessionDAO</div><div class="line"> */</div><div class="line"><span class="meta">@Slf</span>4j</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSessionDao</span> <span class="keyword">extends</span> <span class="title">CachingSessionDAO</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 更新session</div><div class="line">     * <span class="doctag">@param</span> session</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doUpdate</span><span class="params">(Session session)</span> </span>&#123;</div><div class="line">        log.info(<span class="string">"执行redisdao的doUpdate方法"</span>);</div><div class="line">        redisTemplate.opsForValue().set(session.getId(), session);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 删除session</div><div class="line">     * <span class="doctag">@param</span> session</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDelete</span><span class="params">(Session session)</span> </span>&#123;</div><div class="line">        log.info(<span class="string">"执行redisdao的doDelete方法"</span>);</div><div class="line">        redisTemplate.delete(session.getId());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建一个Session，添加到缓存中</div><div class="line">     * <span class="doctag">@param</span> session Session信息</div><div class="line">     * <span class="doctag">@return</span> 创建的SessionId</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Serializable <span class="title">doCreate</span><span class="params">(Session session)</span> </span>&#123;</div><div class="line">        log.info(<span class="string">"执行redisdao的doCreate方法"</span>);</div><div class="line">        Serializable sessionId = generateSessionId(session);</div><div class="line">        assignSessionId(session, sessionId);</div><div class="line">        redisTemplate.opsForValue().set(session.getId(), session);</div><div class="line">        <span class="keyword">return</span> sessionId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Session <span class="title">doReadSession</span><span class="params">(Serializable sessionId)</span> </span>&#123;</div><div class="line">        log.info(<span class="string">"执行redisdao的doReadSession方法"</span>);</div><div class="line">       <span class="keyword">return</span> (Session) redisTemplate.opsForValue().get(sessionId);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="自定义SessionId生成策略"><a href="#自定义SessionId生成策略" class="headerlink" title="自定义SessionId生成策略"></a>自定义SessionId生成策略</h2><ul>
<li>默认的Shiro的生成策略是JavaUuidSessionIdGenerator，此处也可以自定义自己的生成策略，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义的SessionId的生成策略</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSessionIdGenerator</span> <span class="keyword">implements</span> <span class="title">SessionIdGenerator</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Serializable <span class="title">generateId</span><span class="params">(Session session)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> UUID.randomUUID().toString().replaceAll(<span class="string">"-"</span>, <span class="string">""</span>).toUpperCase();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="自定义Session监听器"><a href="#自定义Session监听器" class="headerlink" title="自定义Session监听器"></a>自定义Session监听器</h2><ul>
<li>Session监听器能够监听Session的生命周期，包括开始、过期、失效（停止），如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义Session监听器</div><div class="line"> */</div><div class="line"><span class="meta">@Slf</span>4j</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSessionListener</span> <span class="keyword">implements</span> <span class="title">SessionListener</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(Session session)</span> </span>&#123;</div><div class="line">        log.info(<span class="string">"开始"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Session无效【停止了，stopTime！=null】</div><div class="line">     * <span class="doctag">@param</span> session</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">(Session session)</span> </span>&#123;</div><div class="line">        log.info(<span class="string">"session失效"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onExpiration</span><span class="params">(Session session)</span> </span>&#123;</div><div class="line">        log.info(<span class="string">"超时"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="完成上述配置"><a href="#完成上述配置" class="headerlink" title="完成上述配置"></a>完成上述配置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * 配置SessionDao，使用自定义的Redis缓存</div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> SessionDAO <span class="title">sessionDAO</span><span class="params">()</span></span>&#123;</div><div class="line">        RedisSessionDao sessionDao = <span class="keyword">new</span> RedisSessionDao();</div><div class="line">        <span class="comment">//设置自定义的Id生成策略</span></div><div class="line">        sessionDao.setSessionIdGenerator(<span class="keyword">new</span> RedisSessionIdGenerator());</div><div class="line">        <span class="keyword">return</span> sessionDao;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 配置会话监听器</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> SessionListener <span class="title">sessionListener</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedisSessionListener();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 配置会话管理器</div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> SessionManager <span class="title">sessionManager</span><span class="params">()</span></span>&#123;</div><div class="line">        DefaultWebSessionManager sessionManager = <span class="keyword">new</span> RedisSessionManager();</div><div class="line">        <span class="comment">//设置session的过期时间</span></div><div class="line">        sessionManager.setGlobalSessionTimeout(<span class="number">60000</span>);</div><div class="line">        <span class="comment">//设置SessionDao</span></div><div class="line">        sessionManager.setSessionDAO(sessionDAO());</div><div class="line">        <span class="comment">//设置SessionListener</span></div><div class="line">        sessionManager.setSessionListeners(Lists.newArrayList(sessionListener()));</div><div class="line">        <span class="keyword">return</span> sessionManager;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 配置安全管理器</div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> SecurityManager <span class="title">securityManager</span><span class="params">()</span></span>&#123;</div><div class="line">        DefaultWebSecurityManager securityManager = <span class="keyword">new</span> DefaultWebSecurityManager(userRealm());</div><div class="line">        <span class="comment">//设置缓存管理器</span></div><div class="line">        securityManager.setCacheManager(cacheManager());</div><div class="line">        <span class="comment">//设置会话管理器</span></div><div class="line">        securityManager.setSessionManager(sessionManager());</div><div class="line">        <span class="keyword">return</span> securityManager;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ul>
<li>在源码中可以看到<code>AbstractSessionDAO</code>中的增删改查方法的执行逻辑使用的双层缓存的，还设计到查询CacheManager中的缓存，但是我们的SessionDao既然是实现了Redis的缓存，那么是没必要查询两次的，因此需要重写其中的方法，此时我们自己需要写一个抽象类覆盖其中的增删改查方法即可，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * RedisSessionDao的抽象类，重写其中的增删改查方法，原因如下：</div><div class="line"> *  1、AbstractSessionDAO中的默认方法是写查询CacheManager中的缓存，既然SessionDao实现了Redis的缓存</div><div class="line"> *      那么就不需要重复查询两次，因此重写了方法，直接使用RedisSessionDao查询即可。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRedisSessionDao</span> <span class="keyword">extends</span> <span class="title">AbstractSessionDAO</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 重写creat方法，直接执行sessionDao的方法，不再执行cacheManager</div><div class="line">     * <span class="doctag">@param</span> session</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Serializable <span class="title">create</span><span class="params">(Session session)</span> </span>&#123;</div><div class="line">        Serializable sessionId = doCreate(session);</div><div class="line">        <span class="keyword">if</span> (sessionId == <span class="keyword">null</span>) &#123;</div><div class="line">            String msg = <span class="string">"sessionId returned from doCreate implementation is null.  Please verify the implementation."</span>;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sessionId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 重写删除操作</div><div class="line">     * <span class="doctag">@param</span> session</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Session session)</span> </span>&#123;</div><div class="line">        doDelete(session);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 重写update方法</div><div class="line">     * <span class="doctag">@param</span> session</div><div class="line">     * <span class="doctag">@throws</span> UnknownSessionException</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Session session)</span> <span class="keyword">throws</span> UnknownSessionException </span>&#123;</div><div class="line">        doUpdate(session);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 重写查找方法</div><div class="line">     * <span class="doctag">@param</span> sessionId</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     * <span class="doctag">@throws</span> UnknownSessionException</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Session <span class="title">readSession</span><span class="params">(Serializable sessionId)</span> <span class="keyword">throws</span> UnknownSessionException </span>&#123;</div><div class="line">        Session s = doReadSession(sessionId);</div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnknownSessionException(<span class="string">"There is no session with id ["</span> + sessionId + <span class="string">"]"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> s;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doDelete</span><span class="params">(Session session)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doUpdate</span><span class="params">(Session session)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>此时的上面的RedisSessionDao直接继承我们自定义的抽象类即可，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义RedisSessionDao，继承AbstractRedisSessionDao，达到只查一层缓存</div><div class="line"> */</div><div class="line"><span class="meta">@Slf</span>4j</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSessionDao</span> <span class="keyword">extends</span> <span class="title">AbstractRedisSessionDao</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String HASH_NAME=<span class="string">"shiro_user"</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 更新session</div><div class="line">     * <span class="doctag">@param</span> session</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doUpdate</span><span class="params">(Session session)</span> </span>&#123;</div><div class="line">        log.info(<span class="string">"执行redisdao的doUpdate方法"</span>);</div><div class="line">        redisTemplate.opsForHash().put(HASH_NAME, session.getId(), session);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 删除session</div><div class="line">     * <span class="doctag">@param</span> session</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDelete</span><span class="params">(Session session)</span> </span>&#123;</div><div class="line">        log.info(<span class="string">"执行redisdao的doDelete方法"</span>);</div><div class="line">        redisTemplate.opsForHash().delete(HASH_NAME, session.getId());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建一个Session，添加到缓存中</div><div class="line">     * <span class="doctag">@param</span> session Session信息</div><div class="line">     * <span class="doctag">@return</span> 创建的SessionId</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Serializable <span class="title">doCreate</span><span class="params">(Session session)</span> </span>&#123;</div><div class="line">        log.info(<span class="string">"执行redisdao的doCreate方法"</span>);</div><div class="line">        Serializable sessionId = generateSessionId(session);</div><div class="line">        assignSessionId(session, sessionId);</div><div class="line">        redisTemplate.opsForHash().put(HASH_NAME, session.getId(),session);</div><div class="line">        <span class="keyword">return</span> sessionId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Session <span class="title">doReadSession</span><span class="params">(Serializable sessionId)</span> </span>&#123;</div><div class="line">        log.info(<span class="string">"执行redisdao的doReadSession方法"</span>);</div><div class="line">       <span class="keyword">return</span> (Session) redisTemplate.opsForHash().get(HASH_NAME,sessionId);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取所有的Session</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;Session&gt; <span class="title">getActiveSessions</span><span class="params">()</span> </span>&#123;</div><div class="line">        List values = redisTemplate.opsForHash().values(HASH_NAME);</div><div class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(values))&#123;</div><div class="line">            <span class="keyword">return</span> values;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> Collections.emptySet();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="会话验证"><a href="#会话验证" class="headerlink" title="会话验证"></a>会话验证</h2><ul>
<li>Shiro默认是在当前用户访问页面的时候检查Session是否停止或者过期，如果过期和停止了会调用的SessionDao中的相关方法删除缓存，但是如果这是在用户名操作的情况下，如果用户一直未操作，那么Session已经失效了，但是缓存中并没有删除，这样一来将会有大量无效的Session堆积，因此我们必须定时清理失效的Session。</li>
<li>清理会话，有如下两种方法：<ul>
<li>自己写一个定时器，每隔半小时或者几分钟清除清除缓存</li>
<li>自定义SessionValidationScheduler </li>
<li>使用已经实现的ExecutorServiceSessionValidationScheduler</li>
</ul>
</li>
<li>在Shiro中默认会开启ExecutorServiceSessionValidationScheduler，执行时间是一个小时，但是如果想要使用定时器定时清除的话，那么需要关闭默认的清除器，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//禁用Session清除器，使用定时器清除</span></div><div class="line">      sessionManager.setSessionValidationSchedulerEnabled(<span class="keyword">false</span>);</div></pre></td></tr></table></figure>
<h3 id="如何的Session是失效的"><a href="#如何的Session是失效的" class="headerlink" title="如何的Session是失效的"></a>如何的Session是失效的</h3><ul>
<li>Session是如何保活的？<ul>
<li>在<code>org.apache.shiro.web.servlet.AbstractShiroFilter#doFilterInternal</code>中的一个<code>updateSessionLastAccessTime(request, response);</code>方法用来更新Session的最后执行时间为当前时间，最终调用的就是<code>org.apache.shiro.session.mgt.SimpleSession#touch</code>。</li>
<li>在每次请求验证Session的时候实际调用的是<code>org.apache.shiro.session.mgt.AbstractValidatingSessionManager#doValidate</code>方法，在其中真正调用的是<code>org.apache.shiro.session.mgt.SimpleSession#validate</code>来验证是否过期或者停止<ul>
<li>核心逻辑就是验证当前的时间和最后执行时间的差值是否在设置的过期时间的范围内</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="何时是失效的"><a href="#何时是失效的" class="headerlink" title="何时是失效的"></a>何时是失效的</h3><ul>
<li>Session失效目前通过读源码总结出如下三点：<ul>
<li>isValid判断，这个会在访问请求的时候shiro会自动验证，并且设置进去</li>
<li>用户长期不请求，此时的isValid并不能验证出来，此时需要比较最后执行的时间和开始时间比较</li>
<li>没有登录就访问的也会在redis中生成一个Session，但是此时的Session中是没有两个属性的，以下的两个属性只有在认证成功之后才会设置查到Session中<ul>
<li>org.apache.shiro.subject.support.DefaultSubjectContext#PRINCIPALS_SESSION_KEY</li>
<li>org.apache.shiro.subject.support.DefaultSubjectContext#AUTHENTICATED_SESSION_KEY</li>
</ul>
</li>
</ul>
</li>
<li>通过上面的分析，此时就能写出从缓存中删除失效Session的代码，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * session过期有三种可能，如下：</div><div class="line">     *  1、isValid判断，这个会在访问请求的时候shiro会自动验证，并且设置进去</div><div class="line">     *  2、用户长期不请求，此时的isValid并不能验证出来，此时需要比较最后执行的时间和开始时间</div><div class="line">     *  3、没有登录就访问的也会在redis中生成一个Session，但是此时的Session中是没有两个属性的</div><div class="line">     *      1、org.apache.shiro.subject.support.DefaultSubjectContext#PRINCIPALS_SESSION_KEY</div><div class="line">     *      2、org.apache.shiro.subject.support.DefaultSubjectContext#AUTHENTICATED_SESSION_KEY</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearExpireSession</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//获取所有的Session</span></div><div class="line">        Collection&lt;Session&gt; sessions = redisSessionDao.getActiveSessions();</div><div class="line">        sessions.forEach(s-&gt;&#123;</div><div class="line">            SimpleSession session= (SimpleSession) s;</div><div class="line">            <span class="comment">//第一种可能</span></div><div class="line">            Boolean status1=!session.isValid();</div><div class="line">            <span class="comment">//第二种可能用开始时间和过期时间比较</span></div><div class="line">            Boolean status2=session.getLastAccessTime().getTime()+session.getTimeout()&lt;<span class="keyword">new</span> Date().getTime();</div><div class="line">            <span class="comment">//第三种可能</span></div><div class="line">            Boolean status3= Objects.isNull(session.getAttribute(DefaultSubjectContext.AUTHENTICATED_SESSION_KEY))&amp;&amp;Objects.isNull(session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY));</div><div class="line">            <span class="keyword">if</span> (status1||status2||status3)&#123;</div><div class="line">                <span class="comment">//清楚session</span></div><div class="line">                redisSessionDao.delete(session);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="SSM-Shiro整合"><a href="#SSM-Shiro整合" class="headerlink" title="SSM+Shiro整合"></a>SSM+Shiro整合</h1><ul>
<li>源码地址：<a href="https://github.com/chenjiabing666/ssm-shiro" target="_blank" rel="external">https://github.com/chenjiabing666/ssm-shiro</a></li>
</ul>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;项目搭建&quot;&gt;&lt;a href=&quot;#项目搭建&quot; class=&quot;headerlink&quot; title=&quot;项目搭建&quot;&gt;&lt;/a&gt;项目搭建&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;添加Shiro的依赖&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;tab
    
    </summary>
    
      <category term="分布式" scheme="http://chenjiabing666.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://chenjiabing666.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Shiro源码解析</title>
    <link href="http://chenjiabing666.github.io/2019/08/13/Shiro%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://chenjiabing666.github.io/2019/08/13/Shiro源码解析/</id>
    <published>2019-08-13T14:41:32.000Z</published>
    <updated>2020-03-13T06:10:31.333Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FilterChainManager"><a href="#FilterChainManager" class="headerlink" title="FilterChainManager"></a>FilterChainManager</h1><ul>
<li>过滤器管理器，在ShiroFilterFactoryBean创建的时候会创建管理器，将配置好的过滤器添加到其中</li>
<li>当发出请求的时候会其中找出和url匹配过滤器执行</li>
</ul>
<h1 id="ShiroFilterFactoryBean"><a href="#ShiroFilterFactoryBean" class="headerlink" title="ShiroFilterFactoryBean"></a>ShiroFilterFactoryBean</h1><ul>
<li><p>实现了FactoryBean接口，创建了一个<code>SpringShiroFilter</code>对象，在getObject方法中会创建，创建的步骤如下：</p>
<ul>
<li>创建FIlter管理器</li>
<li>创建11个默认的过滤器，并且其中的uri会被设置全局配置的uri，具体逻辑在<code>org.apache.shiro.spring.web.ShiroFilterFactoryBean#applyGlobalPropertiesIfNecessary</code>方法</li>
<li>将定义的Filter设置过滤器管理器中的filters属性中，并且调用<code>applyGlobalPropertiesIfNecessary</code>方法设置全局属性</li>
<li>构建过滤器链（chain），保存在<code>filterChains</code>的属性中</li>
</ul>
</li>
<li><p>实现了BeanPostProcessor接口，在<code>postProcessBeforeInitialization</code>方法中就是获取到ioc容器中的Filter类型的Bean将其设置到filters属性中</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Filter) &#123;</div><div class="line">            log.debug(<span class="string">"Found filter chain candidate filter '&#123;&#125;'"</span>, beanName);</div><div class="line">            Filter filter = (Filter) bean;</div><div class="line">            <span class="comment">//</span></div><div class="line">            applyGlobalPropertiesIfNecessary(filter);</div><div class="line">            <span class="comment">//放入到filters属性中</span></div><div class="line">            getFilters().put(beanName, filter);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            log.trace(<span class="string">"Ignoring non-Filter bean '&#123;&#125;'"</span>, beanName);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> bean;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="Shiro中的过滤器"><a href="#Shiro中的过滤器" class="headerlink" title="Shiro中的过滤器"></a>Shiro中的过滤器</h1><ul>
<li>Shiro中的过滤器设计的很巧妙，每一个抽象的Filter都有不同的职责</li>
<li>下面介绍的一些过滤器都是按照父类和子类从上向下介绍。</li>
</ul>
<h2 id="OncePerRequestFilter"><a href="#OncePerRequestFilter" class="headerlink" title="OncePerRequestFilter"></a>OncePerRequestFilter</h2><ul>
<li>该类是相对于有作用的过滤器的顶层，所有的过滤器都继承这个抽象类，该类保证了每一次请求只执行一次过滤器，其中的过滤器的doFilter方法就在其中定义，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain filterChain)</span></span></div><div class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line">        String alreadyFilteredAttributeName = getAlreadyFilteredAttributeName();</div><div class="line">        <span class="keyword">if</span> ( request.getAttribute(alreadyFilteredAttributeName) != <span class="keyword">null</span> ) &#123;</div><div class="line">            log.trace(<span class="string">"Filter '&#123;&#125;' already executed.  Proceeding without invoking this filter."</span>, getName());</div><div class="line">            filterChain.doFilter(request, response);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="comment">//noinspection deprecation</span></div><div class="line">            <span class="keyword">if</span> (<span class="comment">/* added in 1.2: */</span> !isEnabled(request, response) ||</div><div class="line">                <span class="comment">/* retain backwards compatibility: */</span> shouldNotFilter(request) ) &#123;</div><div class="line">            log.debug(<span class="string">"Filter '&#123;&#125;' is not enabled for the current request.  Proceeding without invoking this filter."</span>,</div><div class="line">                    getName());</div><div class="line">            filterChain.doFilter(request, response);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// Do invoke this filter...</span></div><div class="line">            log.trace(<span class="string">"Filter '&#123;&#125;' not yet executed.  Executing now."</span>, getName());</div><div class="line">            request.setAttribute(alreadyFilteredAttributeName, Boolean.TRUE);</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//过滤器真正执行的逻辑方法</span></div><div class="line">                doFilterInternal(request, response, filterChain);</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                <span class="comment">// Once the request has finished, we're done and we don't</span></div><div class="line">                <span class="comment">// need to mark as 'already filtered' any more.</span></div><div class="line">                request.removeAttribute(alreadyFilteredAttributeName);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>在doFilter中有一个方法<code>doFilterInternal(request, response, filterChain)</code>，这个方法是执行过滤器的真正逻辑，被子类<code>AdviceFilter</code>实现</li>
</ul>
<h2 id="AdviceFilter"><a href="#AdviceFilter" class="headerlink" title="AdviceFilter"></a>AdviceFilter</h2><ul>
<li>Advice很熟悉，这个抽象类能够实现像AOP一样的功能，其中定义了两个方法，分别是<code>preHandle</code>、<code>postHandle</code>，这两个方法能在过滤器执行前后做一些事情。</li>
<li>其中一个重要的方法，是执行过滤器的主要方法，在其中完成AOP相应的功能，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></div><div class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line"></div><div class="line">        Exception exception = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//在执行下一个过滤器前执行，如果返回的ttrue表示执行下一个过滤器，否则结束执行</span></div><div class="line">            <span class="keyword">boolean</span> continueChain = preHandle(request, response);</div><div class="line">            <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</div><div class="line">                log.trace(<span class="string">"Invoked preHandle method.  Continuing chain?: ["</span> + continueChain + <span class="string">"]"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (continueChain) &#123;</div><div class="line">                <span class="comment">//执行下一个过滤器</span></div><div class="line">                executeChain(request, response, chain);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//后置处理，过滤器执行完毕之后执行</span></div><div class="line">            postHandle(request, response);</div><div class="line">            <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</div><div class="line">                log.trace(<span class="string">"Successfully invoked postHandle method"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            exception = e;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="comment">//清除</span></div><div class="line">            cleanup(request, response, exception);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="PathMatchingFilter"><a href="#PathMatchingFilter" class="headerlink" title="PathMatchingFilter"></a>PathMatchingFilter</h2><ul>
<li>用于请求的url匹配，如果请求的url匹配了，那么需要执行<code>onPreHandle</code>判断是否继续执行后面的过滤器</li>
<li>url匹配的逻辑主要在preHandle方法中，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.appliedPaths == <span class="keyword">null</span> || <span class="keyword">this</span>.appliedPaths.isEmpty()) &#123;</div><div class="line">            <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</div><div class="line">                log.trace(<span class="string">"appliedPaths property is null or empty.  This Filter will passthrough immediately."</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (String path : <span class="keyword">this</span>.appliedPaths.keySet()) &#123;</div><div class="line">            <span class="comment">// If the path does match, then pass on to the subclass implementation for specific checks</span></div><div class="line">            <span class="comment">//(first match 'wins'):</span></div><div class="line">            <span class="keyword">if</span> (pathsMatch(path, request)) &#123;</div><div class="line">                log.trace(<span class="string">"Current requestURI matches pattern '&#123;&#125;'.  Determining filter chain execution..."</span>, path);</div><div class="line">                Object config = <span class="keyword">this</span>.appliedPaths.get(path);</div><div class="line">                <span class="keyword">return</span> isFilterChainContinued(request, response, path, config);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//no path matched, allow the request to go through:</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="AccessControlFilter"><a href="#AccessControlFilter" class="headerlink" title="AccessControlFilter"></a>AccessControlFilter</h2><ul>
<li><p>用于控制访问资源的权限，该类继承上面的三个类，其中有如下几个重要的方法：</p>
<ul>
<li><code>protected abstract boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue)</code>：判断当前的访问是否有权限，如果有权限，那么正常继续执行，如果返回false，那么将会执行<code>onAccessDenied</code>方法</li>
<li><code>protected abstract boolean onAccessDenied(ServletRequest request, ServletResponse response)</code>：isAccessAllowed返回false的时候将会执行，表示当前没有权限访问，需要执行相应的逻辑</li>
<li><code>public boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue)</code>：在过滤器继续执行之前执行的逻辑，其中默认就是调用了isAccessAllowed判断权限，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onPreHandle</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    	<span class="comment">//逻辑或，如果第一条件为false，将会执行第二个方法，反之不执行</span></div><div class="line">        <span class="keyword">return</span> isAccessAllowed(request, response, mappedValue) || onAccessDenied(request, response, mappedValue);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="AuthenticationFilter"><a href="#AuthenticationFilter" class="headerlink" title="AuthenticationFilter"></a>AuthenticationFilter</h2><ul>
<li>抽象类，实现了父类的isAccessAllowed方法，用于权限控制，只有当前的用户认证之后才返回true</li>
<li>其中的几个重要的方法如下：<ul>
<li><code>isAccessAllowed</code>：实现了父类的方法，只有用户认证之后才返回true</li>
<li><code>issueSuccessRedirect</code>：重定向方法，默认重定向到配置的successUrl</li>
</ul>
</li>
</ul>
<h2 id="实现的过滤器"><a href="#实现的过滤器" class="headerlink" title="实现的过滤器"></a>实现的过滤器</h2><ul>
<li>上面介绍的几个都是抽象类，在DefaultFilter中的11个过滤器都是实现了上面的抽象类</li>
</ul>
<h3 id="FormAuthenticationFilter"><a href="#FormAuthenticationFilter" class="headerlink" title="FormAuthenticationFilter"></a>FormAuthenticationFilter</h3><ul>
<li>shiro默认配置的过滤器，名称是authc</li>
<li>其中实现了登录的请求和认证的功能，我们可以不用重写登录的方法，而是配置一个url映射到该过滤器即可完成登录。</li>
<li>默认的登录的用户名和密码的映射字段如下：<ul>
<li>当然我们可以覆盖这个属性，只需要创建一个当前的过滤器，将其添加到IOC中即可，当然其中的beanName要是authc</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_USERNAME_PARAM = <span class="string">"username"</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PASSWORD_PARAM = <span class="string">"password"</span>;</div></pre></td></tr></table></figure>
<ul>
<li>其中实现的onAccessDenied方法有如下的两个功能：<ul>
<li>如果和配置的loginUrlng 相同，那么表示是登录的功能（也不全然是，也可以是一个没有认证的重定向的url，这个在前后端分离的时候常用）</li>
<li>重定向的功能，如果既不是登录的url也没有通过认证，那么将会重定向到配置的loginUrl</li>
</ul>
</li>
</ul>
<h2 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h2><ul>
<li>在现在的项目中大多使用的是前后端分离，现在我们使用自定义一个过滤器实现登录。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 继承AccessControlFilter抽象类，实现权限控制的访问</div><div class="line"> */</div><div class="line"><span class="meta">@Slf</span>4j</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFilter</span> <span class="keyword">extends</span> <span class="title">AccessControlFilter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span>  String USERNAME=<span class="string">"userName"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String PASSWORD=<span class="string">"password"</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 登录成功的url</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> String successUrl=<span class="string">"success"</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 登录失败的url</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> String failUrl=<span class="string">"fail"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoginFilter</span><span class="params">(String successUrl, String failUrl)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.successUrl = successUrl;</div><div class="line">        <span class="keyword">this</span>.failUrl = failUrl;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 判断是否认证成功</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isAccessAllowed</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Subject subject = SecurityUtils.getSubject();</div><div class="line">        <span class="keyword">return</span> subject.isAuthenticated();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建UserNamePasswordToken</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span>  UsernamePasswordToken <span class="title">createToken</span><span class="params">(ServletRequest request)</span></span>&#123;</div><div class="line">        String userName = WebUtils.getCleanParam(request, USERNAME);</div><div class="line">        String password = WebUtils.getCleanParam(request, PASSWORD);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UsernamePasswordToken(userName,password);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 没有认证成功执行的方法</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAccessDenied</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Subject subject=SecurityUtils.getSubject();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//执行登录</span></div><div class="line">            subject.login(createToken(request));</div><div class="line">            Map&lt;String,String&gt; params=<span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">            params.put(<span class="string">"token"</span>, subject.getSession().getId().toString());</div><div class="line">            <span class="comment">//此处需要将token传入重定向的url，因为重定向的url不是匿名访问的，配置的authc，并且还需要将token返回</span></div><div class="line">            <span class="comment">//如果走的是匿名的url的话，那么从Subject中获取的Session并不是认证成功的</span></div><div class="line">            WebUtils.issueRedirect(request, response, successUrl,params);</div><div class="line">        &#125;<span class="keyword">catch</span> (AuthenticationException ex)&#123;</div><div class="line">            log.info(<span class="string">"登录失败"</span>,ex);</div><div class="line">            <span class="comment">//登录失败，重定向到指定的url</span></div><div class="line">            WebUtils.issueRedirect(request, response, failUrl);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//不在执行下面的逻辑</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>配置过滤器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * 创建登录的过滤器</div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> LoginFilter <span class="title">loginFilter</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LoginFilter(<span class="string">"/user/success"</span>, <span class="string">"/user/unauthentic"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//配置登录的url</span></div><div class="line">filterChainDefinitionMap.put(<span class="string">"/login"</span>, <span class="string">"loginFilter"</span>);</div><div class="line"></div><div class="line"><span class="comment">//成功的重定向的请求</span></div><div class="line"> 	<span class="comment">/**</span></div><div class="line">     * LoginFilter登录成功重定向的请求</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"success"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> PageResponse <span class="title">success</span><span class="params">(String token)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PageResponse(<span class="string">"登录成功"</span>,<span class="string">"0"</span>,token);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//失败的重定向</span></div><div class="line"> <span class="comment">/**</span></div><div class="line">     * 没有登录跳转到的uri</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/unauthentic"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> PageResponse <span class="title">unauthentic</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PageResponse(<span class="string">"尚未登录"</span>,<span class="string">"401"</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>配置好之后，就能直接通过login访问了</li>
</ul>
<h1 id="过滤器创建"><a href="#过滤器创建" class="headerlink" title="过滤器创建"></a>过滤器创建</h1><ul>
<li><p>过滤器的来源：</p>
<ul>
<li>shiro容器中默认的11个过滤器，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">anon(AnonymousFilter.class),</div><div class="line">   authc(FormAuthenticationFilter.class),</div><div class="line">   authcBasic(BasicHttpAuthenticationFilter.class),</div><div class="line">   logout(LogoutFilter.class),</div><div class="line">   noSessionCreation(NoSessionCreationFilter.class),</div><div class="line">   perms(PermissionsAuthorizationFilter.class),</div><div class="line">   port(PortFilter.class),</div><div class="line">   rest(HttpMethodPermissionFilter.class),</div><div class="line">   roles(RolesAuthorizationFilter.class),</div><div class="line">   ssl(SslFilter.class),</div><div class="line">   user(UserFilter.class);</div></pre></td></tr></table></figure>
<ul>
<li>自定义的过滤器并且是注入IOC容器中的，这样在容器启动的时候会自动扫描到ShiroFilterFactoryBean中的filters中（后置处理器），如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Filter) &#123;</div><div class="line">            log.debug(<span class="string">"Found filter chain candidate filter '&#123;&#125;'"</span>, beanName);</div><div class="line">            Filter filter = (Filter) bean;</div><div class="line">            <span class="comment">//设置全局属性（如果自定义的过滤器中的三个url没有改变，那么将会启用全局配置的url，否则还是使用自定义设置的url）</span></div><div class="line">            applyGlobalPropertiesIfNecessary(filter);</div><div class="line">            getFilters().put(beanName, filter);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            log.trace(<span class="string">"Ignoring non-Filter bean '&#123;&#125;'"</span>, beanName);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> bean;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>什么是能够被Shiro执行的过滤器？</p>
<ul>
<li>在Shiro中并不是只要你配置了过滤器就能工作，必要的操作就是将其设置到ShiroFilterFactoryBean中的<code>filterChainDefinitionMap</code>的属性中</li>
</ul>
</li>
<li><p>同一个url能否配置多个过滤器？</p>
<ul>
<li>肯定是能的，只需要在配置filterChainDefinitionMap的时候指定多个即可，使用逗号分隔，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">filterChainDefinitionMap.put(<span class="string">"/user/login"</span>, <span class="string">"anon,customFilter"</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>假设对于请求的url能够匹配多个filterChainDefinitionMap，那么应该使用哪一个过滤器链？</p>
<ul>
<li>从源码中可以看到，在获取拦截器链的逻辑是只要第一个匹配了，那么就直接返回这个拦截器链，下面的就不执行了，因此是先在filterChainDefinitionMap中配置的先被使用，后面的会被忽略，源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getChain</span></div><div class="line"><span class="function"><span class="keyword">public</span> FilterChain <span class="title">getChain</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain originalChain)</span> </span>&#123;</div><div class="line">    	<span class="comment">//获取管理器</span></div><div class="line">        FilterChainManager filterChainManager = getFilterChainManager();</div><div class="line">        <span class="keyword">if</span> (!filterChainManager.hasChains()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">		<span class="comment">//获取请求的url</span></div><div class="line">        String requestURI = getPathWithinApplication(request);</div><div class="line"></div><div class="line">        <span class="comment">//循环遍历所有配置在filterChainDefinitionMap中的过滤器的名字</span></div><div class="line">        <span class="keyword">for</span> (String pathPattern : filterChainManager.getChainNames()) &#123;</div><div class="line"></div><div class="line">            <span class="comment">//url匹配</span></div><div class="line">            <span class="keyword">if</span> (pathMatches(pathPattern, requestURI)) &#123;</div><div class="line">                <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</div><div class="line">                    log.trace(<span class="string">"Matched path pattern ["</span> + pathPattern + <span class="string">"] for requestURI ["</span> + requestURI + <span class="string">"].  "</span> +</div><div class="line">                            <span class="string">"Utilizing corresponding filter chain..."</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//如果匹配了直接返回过滤器链的代理对象</span></div><div class="line">                <span class="keyword">return</span> filterChainManager.proxy(originalChain, pathPattern);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>创建过滤器的流程图如下：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/chenjiabing666/BlogImage/master/Shiro.png" alt=""></p>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;FilterChainManager&quot;&gt;&lt;a href=&quot;#FilterChainManager&quot; class=&quot;headerlink&quot; title=&quot;FilterChainManager&quot;&gt;&lt;/a&gt;FilterChainManager&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="分布式" scheme="http://chenjiabing666.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://chenjiabing666.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>mybatis源码解析</title>
    <link href="http://chenjiabing666.github.io/2019/08/05/mybatis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://chenjiabing666.github.io/2019/08/05/mybatis源码解析/</id>
    <published>2019-08-04T16:47:11.000Z</published>
    <updated>2020-03-13T06:04:08.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h1><ul>
<li>mybatis的全局配置类，其中封装了mybatis的全部配置，在mybaits加载全局配置文件和Mapper文件的时候，会将里面的xml中的各个元素解析出来，封装在其中。</li>
<li>主要的解析流程在<code>org.apache.ibatis.builder.xml.XMLConfigBuilder#parseConfiguration</code>有详细描述。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">//issue #117 read properties first</span></div><div class="line">      propertiesElement(root.evalNode(<span class="string">"properties"</span>));</div><div class="line">      Properties settings = settingsAsProperties(root.evalNode(<span class="string">"settings"</span>));</div><div class="line">      loadCustomVfs(settings);</div><div class="line">      loadCustomLogImpl(settings);</div><div class="line">      typeAliasesElement(root.evalNode(<span class="string">"typeAliases"</span>));</div><div class="line">      pluginElement(root.evalNode(<span class="string">"plugins"</span>));</div><div class="line">      objectFactoryElement(root.evalNode(<span class="string">"objectFactory"</span>));</div><div class="line">      objectWrapperFactoryElement(root.evalNode(<span class="string">"objectWrapperFactory"</span>));</div><div class="line">      reflectorFactoryElement(root.evalNode(<span class="string">"reflectorFactory"</span>));</div><div class="line">      settingsElement(settings);</div><div class="line">      <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></div><div class="line">      environmentsElement(root.evalNode(<span class="string">"environments"</span>));</div><div class="line">      databaseIdProviderElement(root.evalNode(<span class="string">"databaseIdProvider"</span>));</div><div class="line">      typeHandlerElement(root.evalNode(<span class="string">"typeHandlers"</span>));</div><div class="line">      mapperElement(root.evalNode(<span class="string">"mappers"</span>));</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing SQL Mapper Configuration. Cause: "</span> + e, e);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h1 id="MapperRegistry"><a href="#MapperRegistry" class="headerlink" title="MapperRegistry"></a>MapperRegistry</h1><ul>
<li>其中存放了所有的Mapper信息，相当于Mapper的注册中心</li>
<li>所有的Mapper信息都存放在<code>Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers</code>这个Map中，key是Mapper的全类名，value是MapperProxyFactory对象（用来创建代理对象）</li>
<li>在mybaits加载配置文件解析Mapper的时候，会调用<code>addMapper</code>方法，将其添加到Map中。在获取Mapper的时候会调用getMapper方法，利用MapperProxyFactory对象创建一个代理对象返回。</li>
</ul>
<h1 id="MappedStatement"><a href="#MappedStatement" class="headerlink" title="MappedStatement"></a>MappedStatement</h1><ul>
<li>封装了一个增删改查标签的全部属性，一个标签就是一个MappedStatement，保存在全局配置类中的<code>Map&lt;String, MappedStatement&gt; mappedStatements</code>中</li>
</ul>
<h1 id="MapperProxyFactory"><a href="#MapperProxyFactory" class="headerlink" title="MapperProxyFactory"></a>MapperProxyFactory</h1><ul>
<li>创建Mapper代理对象的工厂类，其中最重要的两个方法如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用MapperProxy创建一个代理对象</span></div><div class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</div><div class="line">      <span class="comment">//封装一个MapperProxy</span></div><div class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);</div><div class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h1 id="MapperProxy"><a href="#MapperProxy" class="headerlink" title="MapperProxy"></a>MapperProxy</h1><ul>
<li>Mapper的代理类，实现了<code>InvocationHandler</code>，当mapper调用方法的时候真正执行的方法是invoke</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</div><div class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.isDefault()) &#123;</div><div class="line">        <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</div><div class="line">    <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ul>
<li>其中的属性有<code>sqlSession</code>（其中的属性有全局配置类Configuration）、<code>mapperInterface</code>（mapper真正的接口）、<code>Map&lt;Method, MapperMethod&gt; methodCache</code></li>
</ul>
<h1 id="MapperMethod"><a href="#MapperMethod" class="headerlink" title="MapperMethod"></a>MapperMethod</h1><ul>
<li>封装了Mapper接口中的单个方法，其中有两个重要的属性，如下：<ul>
<li><code>SqlCommand</code>：封装方法的全类名和执行的增删改查的类型（SqlCommandType的枚举类型）</li>
<li><code>MethodSignature</code>：方法的签名，其中封装了该方法的一些信息，比如返回类型，返回值的类型等信息。</li>
</ul>
</li>
</ul>
<ul>
<li>其中有一个<code>public Object execute(SqlSession sqlSession, Object[] args)</code>方法，用来执行方法，如下：<ul>
<li>根据方法的不同类型，执行不同的逻辑</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</div><div class="line">    Object result;</div><div class="line">    <span class="keyword">switch</span> (command.getType()) &#123;</div><div class="line">      <span class="keyword">case</span> INSERT: &#123;</div><div class="line">        Object param = method.convertArgsToSqlCommandParam(args);</div><div class="line">        result = rowCountResult(sqlSession.insert(command.getName(), param));</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">case</span> UPDATE: &#123;</div><div class="line">        Object param = method.convertArgsToSqlCommandParam(args);</div><div class="line">        result = rowCountResult(sqlSession.update(command.getName(), param));</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">case</span> DELETE: &#123;</div><div class="line">        Object param = method.convertArgsToSqlCommandParam(args);</div><div class="line">        result = rowCountResult(sqlSession.delete(command.getName(), param));</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">case</span> SELECT:</div><div class="line">        <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</div><div class="line">          executeWithResultHandler(sqlSession, args);</div><div class="line">          result = <span class="keyword">null</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</div><div class="line">          result = executeForMany(sqlSession, args);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</div><div class="line">          result = executeForMap(sqlSession, args);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123;</div><div class="line">          result = executeForCursor(sqlSession, args);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          Object param = method.convertArgsToSqlCommandParam(args);</div><div class="line">          result = sqlSession.selectOne(command.getName(), param);</div><div class="line">          <span class="keyword">if</span> (method.returnsOptional()</div><div class="line">              &amp;&amp; (result == <span class="keyword">null</span> || !method.getReturnType().equals(result.getClass()))) &#123;</div><div class="line">            result = Optional.ofNullable(result);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> FLUSH:</div><div class="line">        result = sqlSession.flushStatements();</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Unknown execution method for: "</span> + command.getName());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Mapper method '"</span> + command.getName()</div><div class="line">          + <span class="string">" attempted to return null from a method with a primitive return type ("</span> + method.getReturnType() + <span class="string">")."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h1 id="BoundSql"><a href="#BoundSql" class="headerlink" title="BoundSql"></a>BoundSql</h1><ul>
<li>封装了SQL语句的信息，包括需要执行的sql语句，参数列表等信息，通过MappedStatement中getBoundSql()方法创建。</li>
</ul>
<h1 id="ResultHandler"><a href="#ResultHandler" class="headerlink" title="ResultHandler"></a>ResultHandler</h1><h1 id="TypeHandler"><a href="#TypeHandler" class="headerlink" title="TypeHandler"></a>TypeHandler</h1><h1 id="Mybatis四大关键类"><a href="#Mybatis四大关键类" class="headerlink" title="Mybatis四大关键类"></a>Mybatis四大关键类</h1><h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><ul>
<li>执行器：在mybaits中负责执行增删改查和事务的操作，mybatis会根据不同的executorType创建不同的执行器</li>
<li>Mybaits的执行器主要有如下的类型：<ul>
<li><code>ExecutorType.SIMPLE</code>：这个执行器类型不做特殊的事情。它为每个语句的执行创建一个新的预处理语句。</li>
<li><code>ExecutorType.REUSE</code>：这个执行器类型会复用预处理语句。</li>
<li><code>ExecutorType.BATCH</code>：这个执行器会批量执行所有更新语句，如果 SELECT 在它们中间执行，必要时请把它们区分开来以保证行为的易读性。</li>
</ul>
</li>
</ul>
<ul>
<li>我们通过SqlSessionFactory创建sqlSession的时候可以传入执行器的类型，如果不传入，默认使用Simple类型的，在源码中的创建的执行的逻辑如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//org.apache.ibatis.session.Configuration#newExecutor(org.apache.ibatis.transaction.Transaction, org.apache.ibatis.session.ExecutorType)</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</div><div class="line">    <span class="comment">//如果没有指定，使用默认的类型</span></div><div class="line">    executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</div><div class="line">    executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</div><div class="line">    Executor executor;</div><div class="line">    <span class="comment">//批量执行的执行器</span></div><div class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</div><div class="line">      executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</div><div class="line">      executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//缓存执行器，实现二级缓存</span></div><div class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</div><div class="line">      executor = <span class="keyword">new</span> CachingExecutor(executor);</div><div class="line">    &#125;</div><div class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</div><div class="line">    <span class="keyword">return</span> executor;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ul>
<li>实现类型如下：<ul>
<li>BatchExecutor：批量执行器</li>
<li>ReuseExecutor：复用执行器</li>
<li>SimpleExecutor：简单执行器，默认的</li>
<li>CachingExecutor：缓存执行器，mybaits中默认使用的执行器，用于二级缓存</li>
</ul>
</li>
</ul>
<h2 id="ParameterHandler"><a href="#ParameterHandler" class="headerlink" title="ParameterHandler"></a>ParameterHandler</h2><ul>
<li>主要作用就是设置为Statement设置参数</li>
</ul>
<h2 id="ResultSetHandler"><a href="#ResultSetHandler" class="headerlink" title="ResultSetHandler"></a>ResultSetHandler</h2><ul>
<li>主要作用就是对最后的结果进行处理</li>
</ul>
<h2 id="StatementHandler"><a href="#StatementHandler" class="headerlink" title="StatementHandler"></a>StatementHandler</h2><ul>
<li>顾名思义就是创建JDBC中的Statement，实现类如下：<ul>
<li><code>SimpleStatementHandler</code></li>
<li><code>PreparedStatementHandler</code></li>
<li><code>CallableStatementHandler</code></li>
</ul>
</li>
<li>主要的作用就是处理Statement，执行查询，对参数、查询结果进行处理。</li>
<li>主要的方法如下：<ul>
<li><code>Statement prepare(Connection connection, Integer transactionTimeout)</code>：创建Statement</li>
<li><code>void parameterize(Statement statement</code>：设置参数</li>
<li><code>void batch(Statement statement)</code>：批量处理</li>
<li><code>&lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler)</code>：执行查询</li>
</ul>
</li>
</ul>
<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><ul>
<li>分析源码执行流程，画出对应的流程图，方便理解和记忆</li>
</ul>
<h2 id="Mybatis创建MapperProxy"><a href="#Mybatis创建MapperProxy" class="headerlink" title="Mybatis创建MapperProxy"></a>Mybatis创建MapperProxy</h2><ul>
<li>包括了读取全局配置文件和Mapper文件生成全局配置类、创建Mapper代理对象的详细过程</li>
</ul>
<p><img src="https://raw.githubusercontent.com/chenjiabing666/BlogImage/master/mybatis%20crete%20mapper.png" alt=""></p>
<h2 id="Mybaits执行查询"><a href="#Mybaits执行查询" class="headerlink" title="Mybaits执行查询"></a>Mybaits执行查询</h2><ul>
<li>主要描述了mybaits通过代理对象如何执行查询语句到对查询结果的处理过程的详细描述</li>
</ul>
<p><img src="https://raw.githubusercontent.com/chenjiabing666/BlogImage/master/mybatis%20select%20all.png" alt=""></p>
<h2 id="Mybaits执行查询的简化版"><a href="#Mybaits执行查询的简化版" class="headerlink" title="Mybaits执行查询的简化版"></a>Mybaits执行查询的简化版</h2><ul>
<li>主要根据Mybatis中的重要的四大类，和SqlSession、TypeHandler进行简化描述，如下：<br><img src="https://raw.githubusercontent.com/chenjiabing666/BlogImage/master/mybatis%20select%20simple.png" alt=""></li>
</ul>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Configuration&quot;&gt;&lt;a href=&quot;#Configuration&quot; class=&quot;headerlink&quot; title=&quot;Configuration&quot;&gt;&lt;/a&gt;Configuration&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;mybatis的全局配置类，其中封装了m
    
    </summary>
    
      <category term="MyBatis" scheme="http://chenjiabing666.github.io/categories/MyBatis/"/>
    
    
      <category term="MyBatis" scheme="http://chenjiabing666.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis深入学习</title>
    <link href="http://chenjiabing666.github.io/2019/08/05/mybatis%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    <id>http://chenjiabing666.github.io/2019/08/05/mybatis深入学习/</id>
    <published>2019-08-04T16:46:56.000Z</published>
    <updated>2020-03-13T06:03:46.855Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><ul>
<li>按照官方文档搭建即可</li>
</ul>
<h1 id="typeAliases（别名）"><a href="#typeAliases（别名）" class="headerlink" title="typeAliases（别名）"></a>typeAliases（别名）</h1><ul>
<li><p>在使用mybatis标签的时候，需要指定类的全类名，比如<code>resultType=xx.xxx.xx</code>，但是我们可以为类指定别名，那么就可以直接使用别名，避免全类名冗余【不推荐使用】</p>
</li>
<li><p>别名的配置有两种方式，这里我们讲解简单的配置方式，步骤如下：</p>
<ul>
<li>在mybatis的全局配置文件下指定别名的包扫描如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"cn.tedu.domain"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>在domain这个包下的所有类默认的别名是类名首字母小写，但是我们也可以使用注解指定，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Alias</span>(<span class="string">"author"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Author</span> </span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="内建的别名【推荐使用】"><a href="#内建的别名【推荐使用】" class="headerlink" title="内建的别名【推荐使用】"></a>内建的别名【推荐使用】</h2><ul>
<li>mybatis对java中基本类型和基本的引用类型内嵌了别名，我们可以直接使用别名进行指定，这样利于开发，内建的别名如下：</li>
</ul>
<table>
<thead>
<tr>
<th>别名</th>
<th>映射的类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>_byte</td>
<td>byte</td>
</tr>
<tr>
<td>_long</td>
<td>long</td>
</tr>
<tr>
<td>_short</td>
<td>short</td>
</tr>
<tr>
<td>_int</td>
<td>int</td>
</tr>
<tr>
<td>_integer</td>
<td>int</td>
</tr>
<tr>
<td>_double</td>
<td>double</td>
</tr>
<tr>
<td>_float</td>
<td>float</td>
</tr>
<tr>
<td>_boolean</td>
<td>boolean</td>
</tr>
<tr>
<td>string</td>
<td>String</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>integer</td>
<td>Integer</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>date</td>
<td>Date</td>
</tr>
<tr>
<td>decimal</td>
<td>BigDecimal</td>
</tr>
<tr>
<td>bigdecimal</td>
<td>BigDecimal</td>
</tr>
<tr>
<td>object</td>
<td>Object</td>
</tr>
<tr>
<td>map</td>
<td>Map</td>
</tr>
<tr>
<td>hashmap</td>
<td>HashMap</td>
</tr>
<tr>
<td>list</td>
<td>List</td>
</tr>
<tr>
<td>arraylist</td>
<td>ArrayList</td>
</tr>
<tr>
<td>collection</td>
<td>Collection</td>
</tr>
<tr>
<td>iterator</td>
<td>Iterator</td>
</tr>
</tbody>
</table>
<h1 id="参数处理"><a href="#参数处理" class="headerlink" title="参数处理"></a>参数处理</h1><ul>
<li>mybatis内部会将我们传入的参数封装成一个Map，key就是以<code>param1、param2....</code></li>
</ul>
<h2 id="单个参数"><a href="#单个参数" class="headerlink" title="单个参数"></a>单个参数</h2><ul>
<li>单个参数在sql语句中可以任意指定，比如#{a}…，或者可以使用<code>#{param1}</code></li>
</ul>
<h1 id="多个参数"><a href="#多个参数" class="headerlink" title="多个参数"></a>多个参数</h1><ul>
<li>使用<code>@Param</code>指定key，那么就可以在sql语句中直接使用这个key即可，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Select</span>(<span class="string">"select * from patient_info where ipt_num=#&#123;iptNum&#125; and status=#&#123;status&#125;"</span>)</div><div class="line">   <span class="function">Patient <span class="title">selectByIptNumAndInhos</span><span class="params">(@Param(<span class="string">"iptNum"</span>)</span> String iptNum, @<span class="title">Param</span><span class="params">(<span class="string">"status"</span>)</span> String status)</span>;</div></pre></td></tr></table></figure>
<ul>
<li>也可以直接使用mybatis中默认的key，即是param1…..</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Select</span>(<span class="string">"select * from patient_info where ipt_num=#&#123;param1&#125; and status=#&#123;param2&#125;"</span>)</div><div class="line">  <span class="function">Patient <span class="title">selectByIptNumAndInhos</span><span class="params">(String iptNum,String status)</span></span>;</div></pre></td></tr></table></figure>
<h2 id="参数是Map类型"><a href="#参数是Map类型" class="headerlink" title="参数是Map类型"></a>参数是Map类型</h2><ul>
<li>mybatis默认的会将参数转换为map，那么我们直接传入一个map那是再好不过了，此时的key就可以直接使用，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Select</span>(<span class="string">"select * from patient_info where ipt_num=#&#123;iptNum&#125; and status=#&#123;status&#125;"</span>)</div><div class="line"> <span class="function">Patient <span class="title">selectByIptAndInhosNumMap</span><span class="params">(Map ipts)</span></span>;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        SqlSessionFactory sqlSessionFactory = XmlConfigInit.getSqlSessionFactory();</div><div class="line">        PatientMapper mapper = sqlSessionFactory.openSession().getMapper(PatientMapper.class);</div><div class="line">        Map&lt;String,String&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        map.put(<span class="string">"iptNum"</span>,<span class="string">"15627656"</span>);</div><div class="line">        map.put(<span class="string">"status"</span>,<span class="string">"1"</span>);</div><div class="line">        Patient patient = mapper.selectByIptAndInhosNumMap(map);</div><div class="line">        System.out.println(patient);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="POJO【推荐使用】"><a href="#POJO【推荐使用】" class="headerlink" title="POJO【推荐使用】"></a>POJO【推荐使用】</h2><ul>
<li>对于POJO可以直接使用成员属性的名称就可以取值，这个经常使用，不再演示</li>
</ul>
<h1 id="返回结果封装"><a href="#返回结果封装" class="headerlink" title="返回结果封装"></a>返回结果封装</h1><ul>
<li>mybatis对于返回结果如何封装有多种实现方式，可以返回List，POJO，Map等类型的数据</li>
</ul>
<h2 id="返回POJO"><a href="#返回POJO" class="headerlink" title="返回POJO"></a>返回POJO</h2><ul>
<li>对于从数据库中查询单条数据库的时候，返回一个POJO只需要sql查询的字段和POJO类中的属性相同即可自动映射，当然我们也可以开启<strong>驼峰配置</strong></li>
<li><code>resultType</code>指定返回的POJO的全类名即可，或者指定别名</li>
<li>此处不演示</li>
</ul>
<h2 id="返回List"><a href="#返回List" class="headerlink" title="返回List"></a>返回List</h2><ul>
<li>同POJO，此时的resultType指定的仍然是List泛型的全类名或者别名</li>
</ul>
<h2 id="返回Map"><a href="#返回Map" class="headerlink" title="返回Map"></a>返回Map</h2><ul>
<li>mybatis还可以返回Map类型的数据，比如我们查询患者的信息，使用Map接收数据，key是患者的id，value就是POJO，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * 使用<span class="doctag">@MapKey</span>注解指定返回Map中的key，这里设定的是Patient中的id属性作为key</div><div class="line">    * <span class="doctag">@return</span></div><div class="line">    */</div><div class="line">   <span class="meta">@MapKey</span>(<span class="string">"id"</span>)</div><div class="line">   <span class="meta">@Select</span>(<span class="string">"select * from patient_info"</span>)</div><div class="line">   <span class="function">Map&lt;Integer,Patient&gt; <span class="title">selectAllReturnMap</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li>在返回的Map的时候需要指定POJO类的哪个字段作为Map的key，使用<code>@MapKey</code>这个注解指定</li>
</ul>
<h2 id="ResultMap"><a href="#ResultMap" class="headerlink" title="ResultMap"></a>ResultMap</h2><ul>
<li>mybatis还支持使用ResultMap自定义结果映射，此时的select语句中需要指定resultMap为当前的定义的id</li>
<li>经常使用，不再演示</li>
</ul>
<h1 id="分步查询"><a href="#分步查询" class="headerlink" title="分步查询"></a>分步查询</h1><ul>
<li><p>在mybatis中<code>collection</code>和<code>association</code>中都是可以使用分步查询</p>
</li>
<li><p>我们需要查询一个科室下的所有患者，那么实体类定义如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="meta">@ToString</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dept</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Integer id;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> List&lt;Patient&gt; patients;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="meta">@ToString</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Patient</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String userId;</div><div class="line">    <span class="keyword">private</span> Integer id;</div><div class="line">    <span class="keyword">private</span> String status;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>不采用分布查询，此时我们的resultMap应该如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"baseResultMap"</span> <span class="attr">type</span>=<span class="string">"cn.tedu.domain.Dept"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"patients"</span> <span class="attr">ofType</span>=<span class="string">"cn.tedu.domain.Patient"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"pid"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"userId"</span> <span class="attr">property</span>=<span class="string">"userId"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"pstatus"</span> <span class="attr">property</span>=<span class="string">"status"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></div><div class="line"></div><div class="line">//sql</div><div class="line"></div><div class="line"> SELECT</div><div class="line">        d.id AS id,</div><div class="line">        d.NAME AS NAME,</div><div class="line">        p.id AS pid,</div><div class="line">        p.user_id AS userId,</div><div class="line">        p.STATUS AS pstatus</div><div class="line">    FROM</div><div class="line">        dept_info d</div><div class="line">        LEFT JOIN patient_info p ON p.dept_id = d.id</div><div class="line">    WHERE</div><div class="line">        d.id =#&#123;id,jdbcType=INTEGER&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>但是我们也可以采用分布查询的方式，先查询出科室的信息，再根据科室的id查询出对应患者的信息，实现步骤如下：</p>
<ul>
<li>定义一个方法查找科室，此时的resultMap指定的是分步查询的id</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;select id="selectById" resultMap="ByStepResultMap"&gt;</div><div class="line">           SELECT</div><div class="line">       *</div><div class="line">   FROM</div><div class="line">       dept_info</div><div class="line">   WHERE</div><div class="line">       id =#&#123;id,jdbcType=INTEGER&#125;</div><div class="line">   &lt;/select&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>定义一个方法根据科室id查询患者信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Select</span>(<span class="string">"SELECT * from patient_info where dept_id=#&#123;deptId&#125;"</span>)</div><div class="line">    <span class="function">List&lt;Patient&gt; <span class="title">selectByDeptId</span><span class="params">(Integer deptId)</span></span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>在resultMap中指定分步查询</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--分步查询科室信息和患者信息--&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"ByStepResultMap"</span> <span class="attr">type</span>=<span class="string">"cn.tedu.domain.Dept"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span> /&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></div><div class="line">  </div><div class="line">       <span class="comment">&lt;!--ofType：指定级联属性的类型--&gt;</span></div><div class="line">       <span class="comment">&lt;!--select：指定分步查询患者信息的方法，全类名+方法名--&gt;</span></div><div class="line">       <span class="comment">&lt;!--column：指定查询科室获取的结果的哪一个字段作为查询患者方法的参数，可以指定多个</span></div><div class="line">                   如果指定多个，那么需要将参数封装成map，比如column="&#123;key1=column1,key2=column2&#125;"</div><div class="line">       --&gt;</div><div class="line">        <span class="comment">&lt;!--fetchType：在开启全局延迟加载的时候设置是否延迟加载，默认是延迟加载，可以设置为eager表示不延迟加载--&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"patients"</span> <span class="attr">ofType</span>=<span class="string">"cn.tedu.domain.Patient"</span></span></div><div class="line">                   <span class="attr">select</span>=<span class="string">"cn.tedu.mapper.PatientMapper.selectByDeptId"</span></div><div class="line">                   <span class="attr">column</span>=<span class="string">"id"</span>&gt;</div><div class="line">       <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><ul>
<li>mybatis默认是不使用延迟加载的，因此当使用分步查询的时候即使没有用到分步查询的结果仍然会发出sql语句</li>
<li>我们可以在全局配置文件中设置开启延迟加载，如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!--延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态。--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></div><div class="line">        <span class="comment">&lt;!--当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个属性会按需加载（参考 lazyLoadTriggerMethods)。--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"aggressiveLazyLoading"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></div></pre></td></tr></table></figure>
<h1 id="内置参数"><a href="#内置参数" class="headerlink" title="内置参数"></a>内置参数</h1><ul>
<li>mybatis中内置了两个参数，在写sql的时候可以直接拿来使用，如下：<ul>
<li><code>_parameter</code>：代表整个参数，如果是一个参数就表示这个参数，如果是多个参数，此时的参数会被封装成一个Map，那么_parameter此时就代表整个Map</li>
<li><code>_databaseId</code>：如果配置了databaseIdProvider标签，就代表当前数据库的别名</li>
</ul>
</li>
</ul>
<ul>
<li>实例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Select</span>(<span class="string">"SELECT * from patient_info where dept_id=#&#123;_parameter&#125;"</span>)</div><div class="line">   <span class="function">List&lt;Patient&gt; <span class="title">selectByDeptId</span><span class="params">(Integer deptId)</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li>如果是一个参数，并且是POJO对象，我们还可以使用<code>_parameter</code>判断是否为空，如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"_parameter!=null"</span>&gt;</span></div><div class="line">	.....</div><div class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>如果是多个参数，那么就表示一个Map，此时可以直接使用<code>_parameter.key1....</code>直接获取值即可，当然如果没有指定@Param注解，此时还可以使用<code>_parameter.param1,_parameter.param2...</code>直接获取对应的值</li>
</ul>
<h1 id="批量处理"><a href="#批量处理" class="headerlink" title="批量处理"></a>批量处理</h1><ul>
<li>Mybatis针对批量操作有两种常用的方法，第一种就死通过动态sql在sql语句中使用for-each拼写，第二种就是使用Mybaits自带的批量执行器（BatchExecutor），这里主要介绍第二种的方式</li>
<li>如何配置？有如下两种方式<ul>
<li>在全局配置文件的settings中配置一个属性<code>defaultExecutorType =BATCH</code>即可，不过这种方式将会导致所有的sql操作都会使用批量操作。</li>
<li>我们可以在获取SqlSession的时候指定执行类型，如下：<ul>
<li><code>SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH);</code>，此时当前的SqlSession执行的就是批量操作。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Mybaits-Spring执行批量处理"><a href="#Mybaits-Spring执行批量处理" class="headerlink" title="Mybaits-Spring执行批量处理"></a>Mybaits-Spring执行批量处理</h2><ul>
<li>Spring执行批量处理很简单，只需要在ioc容器中注入一个<code>SqlSessionTemplate</code>，并且设置批量处理的属性即可，如下：<ul>
<li>这种改变是全局的，慎用</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * 注入SqlSessionTemplate，替代SqlSessionFactory直接创建SqlSession，并且能够使用Spring的事务管理</div><div class="line">     * 如果需要使用批量处理，在构造方法中指定ExecutorType.BATCH即可，那么全部的操作的都会使用</div><div class="line">     * 【可以不配置，需要的时候使用】</div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">sqlSessionTemplate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        SqlSessionTemplate sqlSessionTemplate = <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory().getObject(),ExecutorType.BATCH);</div><div class="line">        <span class="keyword">return</span> sqlSessionTemplate;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="类型处理器（TypeHandler）"><a href="#类型处理器（TypeHandler）" class="headerlink" title="类型处理器（TypeHandler）"></a>类型处理器（TypeHandler）</h1><ul>
<li>用于处理Java类型和JDBC类型之前的映射关系，mybaits中内置了许多的类型处理器，一般我们在使用<code>#{}</code>中的jdbcType属性的时候，mybaits框架会为我们设置相应的处理器，比如jdbcType=DATE，那么mybatis默认对应的处理器就是<code>DateOnlyTypeHandler</code>（只有年月日），如果我们设置了jdbcType=TIMESTAMP，那么mybatis对Date类型的类型处理器就是<code>DateTypeHandler</code>，关于类型处理器和jdbcType的对应关系，看<a href="http://www.mybatis.org/mybatis-3/zh/configuration.html#typeHandlers" target="_blank" rel="external">官方文档中typeHandler这一节</a></li>
<li>内置处理器执行的时间：<ul>
<li>在StatementHandler创建Statement之后，会调用ParameterHandler设置参数，其中执行了类型处理器的setParametes的方法，设置对应的参数</li>
<li>在DefaultResultsetHandler处理执行结果的时候，会调用的TypeHandler中的<code>getResult</code>方法获取结果集</li>
</ul>
</li>
<li>TypeHandler中的方法如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 为预编译语句设置参数的时候执行，实际就是调用setxxx方法设置参数</div><div class="line">   * <span class="doctag">@param</span> ps PreparedStatement 对象</div><div class="line">   * <span class="doctag">@param</span> i</div><div class="line">   * <span class="doctag">@param</span> parameter 参数</div><div class="line">   * <span class="doctag">@param</span> jdbcType #&#123;&#125;中自定义的jdbcType</div><div class="line">   * <span class="doctag">@throws</span> SQLException</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, T parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException</span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 根据列名获取指定的值</div><div class="line">   * <span class="doctag">@param</span> rs ResultSet结果集</div><div class="line">   * <span class="doctag">@param</span> columnName 列名</div><div class="line">   * <span class="doctag">@return</span></div><div class="line">   * <span class="doctag">@throws</span> SQLException</div><div class="line">   */</div><div class="line">  <span class="function">T <span class="title">getResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException</span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 根据下标获取指定列的值</div><div class="line">   * <span class="doctag">@param</span> rs ResultSet结果集</div><div class="line">   * <span class="doctag">@param</span> columnIndex  下标</div><div class="line">   * <span class="doctag">@return</span></div><div class="line">   * <span class="doctag">@throws</span> SQLException</div><div class="line">   */</div><div class="line">  <span class="function">T <span class="title">getResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 调用存储过程的获取返回值的时候</div><div class="line">   * <span class="doctag">@param</span> cs</div><div class="line">   * <span class="doctag">@param</span> columnIndex</div><div class="line">   * <span class="doctag">@return</span></div><div class="line">   * <span class="doctag">@throws</span> SQLException</div><div class="line">   */</div><div class="line">  <span class="function">T <span class="title">getResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>虽然mybatis中内置了许多的类型处理器，但是我们也可以自定义类型处理器，并且作用到指定需要处理的类型中，自定义的方式有两种，如下：<ul>
<li>实现<code>TypeHandler</code>接口</li>
<li>继承<code>BaseTypeHandler</code>【推荐】</li>
</ul>
</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul>
<li>实例：我们需要将一个<code>List&lt;Auth&gt;</code>对象存入数据库的时候是以json字符串的形式，获取的是以List集合的形式，此时我们可以自定义一个TypeHandler，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义类型转换器，将List&lt;Auth&gt;数据存入数据库的时候是以json字符串存入的，获取返回的结果的时候是List集合</div><div class="line"> * <span class="doctag">@MappedJdbcTypes</span>(value = &#123;JdbcType.VARCHAR&#125;)：指定了映射的jdbcType的类型是VARCHAR</div><div class="line"> * <span class="doctag">@MappedTypes</span>(value = &#123;Auth.class&#125;)：指定了映射的java类型是Auth</div><div class="line"> */</div><div class="line"><span class="meta">@MappedJdbcTypes</span>(value = &#123;JdbcType.VARCHAR&#125;)</div><div class="line"><span class="meta">@MappedTypes</span>(value = &#123;Auth.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthTypeHandler</span> <span class="keyword">extends</span> <span class="title">BaseTypeHandler</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 将参数转换为json数据存入数据库</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, Object parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        String json = <span class="keyword">new</span> Gson().toJson(parameter);</div><div class="line">        ps.setString(i,json);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        String string = rs.getString(columnName);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Gson().fromJson(string,<span class="keyword">new</span> TypeToken&lt;List&lt;Auth&gt;&gt;()&#123;&#125;.getType());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getNullableResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        String string = rs.getString(columnIndex);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Gson().fromJson(string,<span class="keyword">new</span> TypeToken&lt;List&lt;Auth&gt;&gt;()&#123;&#125;.getType());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getNullableResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>需要在全局配置文件中设置TypeHandler的包扫描，如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--设置自动扫描包下的typeHandler--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"cn.tedu.typehandler"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>此时的类型处理器还是不起作用的，需要在insert、update的#{}中设置一下typehandler属性，如下：<ul>
<li>#{}中有一个typeHandler属性，指定自定义的TypeHandler即可</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertAdmin"</span> <span class="attr">parameterType</span>=<span class="string">"cn.tedu.domain.Admin"</span>&gt;</span></div><div class="line">        insert into t_admin(name,birthday,account,password,point,status,auths)</div><div class="line">         values (#&#123;name,jdbcType=VARCHAR&#125;,#&#123;birthday,jdbcType=DATE&#125;,</div><div class="line">         #&#123;account,jdbcType=VARCHAR&#125;,#&#123;password,jdbcType=VARCHAR&#125;,</div><div class="line">         #&#123;point,jdbcType=DOUBLE&#125;,#&#123;status,jdbcType=VARCHAR&#125;,#&#123;auths,jdbcType=VARCHAR,typeHandler=cn.tedu.typehandler.AuthTypeHandler&#125;)</div><div class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>对select语句设置类型处理器，只能在resultMap中设置，如下：<ul>
<li>在result中需要设置javaType，jdbcType，typeHandler三个属性，这里的auths就是需要映射的<code>List&lt;AUth&gt;</code></li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"cn.tedu.domain.Admin"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span> /&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"auths"</span> <span class="attr">property</span>=<span class="string">"auths"</span> <span class="attr">javaType</span>=<span class="string">"cn.tedu.domain.Auth"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">typeHandler</span>=<span class="string">"cn.tedu.typehandler.AuthTypeHandler"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></div><div class="line"></div><div class="line">   <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="枚举类型处理器"><a href="#枚举类型处理器" class="headerlink" title="枚举类型处理器"></a>枚举类型处理器</h2><ul>
<li>枚举的类型处理器默认是<code>EnumTypeHandler</code>，存入和取出都是存储的枚举的名称，也有一个<code>EnumOrdinalTypeHandler</code>是按照枚举的索引存储和查询的。</li>
<li>我们也可以自定义类型处理器来处理枚举类型。</li>
</ul>
<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><ul>
<li>插件的设计其实就是一个拦截器，在目标方法执行之前进行拦截，当然这里只是针对Mybatis中的四大对象进行拦截，四大对象如下：<ul>
<li><strong>Executor</strong></li>
<li><strong>StatementHandler</strong></li>
<li><strong>ParameterHandler</strong></li>
<li><strong>ResultSetHandler</strong></li>
</ul>
</li>
<li>Interceptor能够做到对四大对象中的每一个方法进行拦截</li>
<li>实现一个插件很简单，只需要实现<code>org.apache.ibatis.plugin.Interceptor</code>接口即可</li>
<li>对应Interceptor这个接口的方法解释如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 拦截器真正执行的方法，其中的invocation.proceed()是用来执行目标方法的，只有执行了这个proceed方法，目标方法才会执行，否则不执行</div><div class="line">   * <span class="doctag">@param</span> invocation</div><div class="line">   * <span class="doctag">@return</span> 返回目标方法执行的结果，return invocation.proceed();</div><div class="line">   * <span class="doctag">@throws</span> Throwable</div><div class="line">   */</div><div class="line">  <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 四大对象生成代理对象的方法，在四大对象创建的时候，都会调用一个pluginAll方法返回一个代理对象</div><div class="line">   * 这个方法不需要做修改，默认就行了</div><div class="line">   * <span class="doctag">@param</span> target 目标对象</div><div class="line">   * <span class="doctag">@return</span> 返回的代理对象（层层包装，表示只有一层）</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">default</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 在全局配置文件中&lt;plugin&gt;标签中设置properties属性，会封装在此方法的properties中</div><div class="line">   * <span class="doctag">@param</span> properties</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</div><div class="line">    <span class="comment">// NOP</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="实现一个简单的插件"><a href="#实现一个简单的插件" class="headerlink" title="实现一个简单的插件"></a>实现一个简单的插件</h2><ul>
<li>自定义一个插件，修改指定查询语句的入参。如下：<ul>
<li>实现原理其实很简单，因为mybaits的增删改查标签所有的信息都封装在MappedStatement中，我们只需要获取这个对象，然后通过属性判断即可。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Intercepts</span>注解标记这是一个拦截器,其中可以指定多个<span class="doctag">@Signature</span></div><div class="line"> * <span class="doctag">@Signature</span>：指定该拦截器拦截的是四大对象中的哪个方法</div><div class="line"> *      type：拦截器的四大对象的类型</div><div class="line"> *      method：拦截器的方法，方法名</div><div class="line"> *      args：入参的类型</div><div class="line"> */</div><div class="line"><span class="meta">@Intercepts</span>(</div><div class="line">        &#123;</div><div class="line">                <span class="meta">@Signature</span>(type = ParameterHandler.class,method =<span class="string">"setParameters"</span>,args = &#123;PreparedStatement.class&#125;)</div><div class="line">        &#125;</div><div class="line">)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstPlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        System.out.println(<span class="string">"拦截器执行："</span>+invocation.getTarget());</div><div class="line">        <span class="comment">//目标对象</span></div><div class="line">        Object target = invocation.getTarget();</div><div class="line">        <span class="comment">//获取目标对象中所有属性的值，因为ParameterHandler使用的是DefaultParameterHandler，因此里面的所有的属性都封装在其中</span></div><div class="line">        MetaObject metaObject = SystemMetaObject.forObject(target);</div><div class="line">        <span class="comment">//使用xxx.xxx.xx的方式可以层层获取属性值，这里获取的是mappedStatement中的id值</span></div><div class="line">        String value = (String) metaObject.getValue(<span class="string">"mappedStatement.id"</span>);</div><div class="line">        <span class="comment">//如果是指定的查询方法</span></div><div class="line">        <span class="keyword">if</span> (<span class="string">"cn.tedu.mapper.AdminMapper.selectById"</span>.equals(value))&#123;</div><div class="line">            <span class="comment">//设置参数的值是2，即是设置id=2，因为这里只有一个参数，可以这么设置，如果有多个需要需要循环</span></div><div class="line">            metaObject.setValue(<span class="string">"parameterObject"</span>, <span class="number">2</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//执行目标方法</span></div><div class="line">        <span class="keyword">return</span> invocation.proceed();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//可以省略</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//可以省略</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</div><div class="line">        System.out.println(properties);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>全局文件中配置：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--配置插件，其中的property可以设置自己的属性，可以封装到setProperties中的properties中--&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"cn.tedu.plugin.FirstPlugin"</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"11"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="重要的方法"><a href="#重要的方法" class="headerlink" title="重要的方法"></a>重要的方法</h2><ul>
<li><code>SystemMetaObject.forObject(target)</code>：可以获取目标类中所有的属性的值</li>
<li><code>metaObject.getValue(&quot;mappedStatement.id&quot;)</code>：可以使用xxx.xxx层层的获取属性的值</li>
<li><code>metaObject.setValue(name, value)</code>：设置属性的值</li>
</ul>
<h2 id="多个插件的执行顺序"><a href="#多个插件的执行顺序" class="headerlink" title="多个插件的执行顺序"></a>多个插件的执行顺序</h2><ul>
<li><p><strong>全局配置文件中配置插件的顺序，决定插件的执行顺序，是相反的顺序。</strong></p>
</li>
<li><p>如果有多个插件作用在同一个对象的同一个方法上，那么插件的执行顺序是怎样的？我们知道四大对象在创建的时候会调用拦截器中的plugin方法创建代理对象，这种代理实层层包装的，那么在后面的插件创建的代理是包裹在最外层的，因此肯定是先执行最外层的拦截器方法。</p>
</li>
</ul>
<h1 id="Spring整合Mybatis"><a href="#Spring整合Mybatis" class="headerlink" title="Spring整合Mybatis"></a>Spring整合Mybatis</h1><ul>
<li><a href="http://www.mybatis.org/spring/zh/index.html" target="_blank" rel="external">官方文档</a></li>
<li>添加依赖：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>配置数据源、事务管理器、SqlSessionFactoryBean<ul>
<li>这里使用了<code>@MapperScan</code>注解自动扫描Mapper接口</li>
<li>在<code>SqlSessionFactoryBean</code>中的配置中设置xml文件的位置和全局配置文件中的位置</li>
<li><code>SqlSessionTemplate</code>的注入能够让我们很方便的获取一个SqlSession和Mapper，一旦注入之后，所有的获取Mapper的代理对象都会执行其中的getMapper方法获取，因此如果这里设置了批量处理，那么改变是全局的。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 配置类</div><div class="line"> * <span class="doctag">@MapperScan</span>：扫描所有的Mapper接口</div><div class="line"> */</div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"cn.tedu.ssm"</span>&#125;)</div><div class="line"><span class="meta">@MapperScan</span>(basePackages = &#123;<span class="string">"cn.tedu.ssm.mapper"</span>&#125;)</div><div class="line"><span class="meta">@EnableAspectJAutoProxy</span></div><div class="line"><span class="meta">@EnableAsync</span></div><div class="line"><span class="meta">@EnableTransactionManagement</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 注册数据源</div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> DruidDataSource <span class="title">dataSource</span><span class="params">()</span></span>&#123;</div><div class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</div><div class="line">        dataSource.setUrl(DataConfig.URL);</div><div class="line">        dataSource.setUsername(DataConfig.USER);</div><div class="line">        dataSource.setPassword(DataConfig.PWD);</div><div class="line">        dataSource.setDriverClassName(DataConfig.DRIVER_NAME);</div><div class="line">        <span class="keyword">return</span> dataSource;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 配置SqlSessionFactoryBean，实际就是SqlSessionFactory</div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactoryBean <span class="title">sqlSessionFactory</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</div><div class="line">        <span class="comment">//设置数据源</span></div><div class="line">        sqlSessionFactoryBean.setDataSource(dataSource());</div><div class="line">        <span class="comment">//配置扫描mapepr.xml文件</span></div><div class="line">        PathMatchingResourcePatternResolver classPathResource = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</div><div class="line">        sqlSessionFactoryBean.setMapperLocations(classPathResource.getResources(<span class="string">"classpath:mappers/*.xml"</span>));</div><div class="line">        <span class="comment">//设置全局配置文件的位置</span></div><div class="line">        sqlSessionFactoryBean.setConfigLocation(classPathResource.getResource(<span class="string">"classpath:mybatis-config.xml"</span>));</div><div class="line">        <span class="keyword">return</span> sqlSessionFactoryBean;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 注入SqlSessionTemplate，替代SqlSessionFactory直接创建SqlSession，并且能够使用Spring的事务管理</div><div class="line">     * 如果需要使用批量处理，在构造方法中指定ExecutorType.BATCH即可，那么全部的操作的都会使用</div><div class="line">     * 【可以不配置，需要的时候使用】</div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">sqlSessionTemplate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        SqlSessionTemplate sqlSessionTemplate = <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory().getObject());</div><div class="line">        <span class="keyword">return</span> sqlSessionTemplate;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建事务管理器</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>在和Spring整合的时候，原先全局配置中配置的数据源，事务管理器等都会被忽略，默认会加载Spring配置的事务管理器和数据源。</li>
<li>如果想要配置TypeHandler、Plugin、TypeAlias等设置，在SqlSessionFactoryBean中都是可以直接配置的，因此在和Spring整合之后，Mybaits的全局配置文件中需要配置的东西很少，几乎可以不用。</li>
</ul>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><ul>
<li>全注解版的SSM整合，包括下面分页插件的整合：<a href="https://github.com/chenjiabing666/ssm-demo" target="_blank" rel="external">https://github.com/chenjiabing666/ssm-demo</a></li>
</ul>
<h1 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h1><ul>
<li><a href="https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md" target="_blank" rel="external">官方文档https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md</a></li>
<li>使用环境：ssm环境下配置</li>
<li>添加依赖：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">      &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</div><div class="line">      &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;</div><div class="line">      &lt;version&gt;5.1.6&lt;/version&gt;</div><div class="line"> &lt;/dependency&gt;</div></pre></td></tr></table></figure>
<ul>
<li>配置拦截器，在和Spring整合下就只需要在SqlSessionFactoryBean中配置拦截器即可，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * 配置SqlSessionFactoryBean，实际就是SqlSessionFactory</div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactoryBean <span class="title">sqlSessionFactory</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</div><div class="line">        <span class="comment">//设置数据源</span></div><div class="line">        sqlSessionFactoryBean.setDataSource(dataSource());</div><div class="line">        <span class="comment">//配置扫描mapepr.xml文件</span></div><div class="line">        PathMatchingResourcePatternResolver classPathResource = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</div><div class="line">        sqlSessionFactoryBean.setMapperLocations(classPathResource.getResources(<span class="string">"classpath:mappers/*.xml"</span>));</div><div class="line">        <span class="comment">//设置全局配置文件的位置</span></div><div class="line">        sqlSessionFactoryBean.setConfigLocation(classPathResource.getResource(<span class="string">"classpath:mybatis-config.xml"</span>));</div><div class="line">        <span class="comment">//配置插件</span></div><div class="line">        PageInterceptor pageInterceptor = <span class="keyword">new</span> PageInterceptor();</div><div class="line">        <span class="comment">//可以配置PageHelper中的参数映射关系，这里使用默认的，不需配置</span></div><div class="line"><span class="comment">//        pageInterceptor.setProperties();</span></div><div class="line">        sqlSessionFactoryBean.setPlugins(pageInterceptor);</div><div class="line">        <span class="keyword">return</span> sqlSessionFactoryBean;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>官方文档中有多种使用方式，我们使用面向接口的方式，如下：<ul>
<li>只需要在doSelect中调用查询全部的sql即可</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</div><div class="line">       SqlSessionTemplate sqlSessionTemplate = applicationContext.getBean(SqlSessionTemplate.class);</div><div class="line">       <span class="keyword">final</span> PatientMapper mapper = sqlSessionTemplate.getMapper(PatientMapper.class);</div><div class="line">       PageInfo&lt;Object&gt; pageInfo = PageHelper.startPage(<span class="number">1</span>, <span class="number">10</span>).doSelectPageInfo(<span class="keyword">new</span> ISelect() &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSelect</span><span class="params">()</span> </span>&#123;</div><div class="line">               mapper.selectAllPatient();</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h2 id="自己整合工具类"><a href="#自己整合工具类" class="headerlink" title="自己整合工具类"></a>自己整合工具类</h2><ul>
<li>在实际使用过程中上述的方式有点繁琐，本人自己整合一个工具类，能够很轻松的完成分页。</li>
<li>定义一个ParamReq类，如果有需要的分页的请求都继承这个类，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonIgnore;</div><div class="line"><span class="keyword">import</span> lombok.Data;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 所有需要分页的请求要继承的类，其中提供了分页需要的参数</div><div class="line"> * 默认的映射关系是:pageNum=pageNum;pageSize=pageSize;count=countSql;reasonable=reasonable;pageSizeZero=pageSizeZero</div><div class="line"> * 也可在设置拦截器的时候指定映射关系，具体看官方文档</div><div class="line"> * https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md</div><div class="line"> */</div><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageParam</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 当前第几页</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Integer pageNum=<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 每页查询的数量</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Integer pageSize=<span class="number">10</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 是否进行count查询，默认是true，查询</div><div class="line">     * 如果设置为false，那么总数total将会为-1，不进行count查询</div><div class="line">     */</div><div class="line">    <span class="meta">@JsonIgnore</span></div><div class="line">    <span class="keyword">private</span> Boolean countSql=<span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 分页合理化参数，默认值为false。当该参数设置为 true 时，pageNum&lt;=0 时会查询第一页， pageNum&gt;pages（超过总数时），会查询最后一页。默认false 时，直接根据参数进行查询。</div><div class="line">     */</div><div class="line">    <span class="meta">@JsonIgnore</span></div><div class="line">    <span class="keyword">private</span> Boolean reasonable;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 默认值为 false，当该参数设置为 true 时，如果 pageSize=0 或者 RowBounds.limit = 0 就会查询出全部的结果（相当于没有执行分页查询，但是返回结果仍然是 Page 类型）。</div><div class="line">     */</div><div class="line">    <span class="meta">@JsonIgnore</span></div><div class="line">    <span class="keyword">private</span> Boolean pageSizeZero=<span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>自定义执行接口，其实就是覆盖上面的doSelect方法，实现自己的执行查询的方法，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 分页需要实现的接口，在doExecute中只需调用查询全部数据的mapper即可</div><div class="line"> */</div><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutePageHelper</span> <span class="keyword">extends</span> <span class="title">ISelect</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 实现类应该覆盖的方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doExecute</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">doSelect</span><span class="params">()</span> </span>&#123;</div><div class="line">        doExecute();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>分页工具类，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 执行分页插件的工具类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageHelperUtils</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行PageHelper分页的方法</div><div class="line">     * <span class="doctag">@param</span> req 请求对象，继承PageParam类</div><div class="line">     * <span class="doctag">@param</span> executePageHelper ExecutePageHelper的接口实现类</div><div class="line">     * <span class="doctag">@param</span> &lt;T&gt; 泛型，需要返回结果的类型</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;  <span class="function">PageInfo&lt;T&gt; <span class="title">execute</span><span class="params">(PageParam req,ExecutePageHelper executePageHelper)</span></span>&#123;</div><div class="line">        <span class="comment">//这里直接传入req，其实其中的值是有映射关系的，在PageParam中有讲到</span></div><div class="line">        <span class="keyword">return</span> PageHelper.startPage(req).doSelectPageInfo(executePageHelper);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>测试：<ul>
<li>使用lambda表示可以方便的执行分页查询</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</div><div class="line">       SqlSessionTemplate sqlSessionTemplate = applicationContext.getBean(SqlSessionTemplate.class);</div><div class="line">       PatientMapper mapper = sqlSessionTemplate.getMapper(PatientMapper.class);</div><div class="line">       <span class="comment">//分页的请求类，继承ParamReq</span></div><div class="line">       UserReq req=<span class="keyword">new</span> UserReq();</div><div class="line">       PageInfo&lt;Patient&gt; pageInfo = PageHelperUtils.execute(req, mapper::selectAllPatient);</div><div class="line">       System.out.println(pageInfo.getList());</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;按照官方文档搭建即可&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;typeAliases（别名）&quot;&gt;&lt;a href=&quot;
    
    </summary>
    
      <category term="MyBatis" scheme="http://chenjiabing666.github.io/categories/MyBatis/"/>
    
    
      <category term="MyBatis" scheme="http://chenjiabing666.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Springmvc源码解读</title>
    <link href="http://chenjiabing666.github.io/2019/07/31/Springmvc%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://chenjiabing666.github.io/2019/07/31/Springmvc源码解读/</id>
    <published>2019-07-31T06:45:44.000Z</published>
    <updated>2020-03-13T06:14:02.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实现Controller的方式"><a href="#实现Controller的方式" class="headerlink" title="实现Controller的方式"></a>实现Controller的方式</h1><ul>
<li>如何实现一个controller，在源码中其实将controller叫做handler，我们通常知道实现controller的方式就是在类上添加一个<code>@Controller</code>和<code>@RequestMapping</code>注解，但是还有其他的方式定义一个controller</li>
</ul>
<h2 id="实现Controller"><a href="#实现Controller" class="headerlink" title="实现Controller"></a>实现Controller</h2><ul>
<li>使用Bean中的id指定路径，必须是以<code>/</code>开头</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>(value = <span class="string">"/user/test.do"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"userController run....."</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="实现HttpRequestHandler"><a href="#实现HttpRequestHandler" class="headerlink" title="实现HttpRequestHandler"></a>实现HttpRequestHandler</h2><ul>
<li>要求同上</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>(value = <span class="string">"/prod/test.do"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductController</span> <span class="keyword">implements</span> <span class="title">HttpRequestHandler</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"prodController run ....."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h2><ul>
<li>经常使用，不再细说</li>
</ul>
<h1 id="EnableWebMvc"><a href="#EnableWebMvc" class="headerlink" title="@EnableWebMvc"></a>@EnableWebMvc</h1><ul>
<li>该注解使Spring MVC 开启高级功能的入口，主要的作用就是加载了一个配置类<code>DelegatingWebMvcConfiguration</code>，其中创建了MVC默认的一些组件，比如<code>viewControllerHandlerMapping</code>、<code>RequestMappingHandlerMapping</code>、<code>BeanNameUrlHandlerMapping</code>、<code>RequestMappingHandlerAdapter</code> 等等。</li>
</ul>
<h1 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h1><ul>
<li>一个用于分发请求的Servlet，一个请求进来之后，Servlet会根据HandlerMapping将请求转发给对应的Handler（controller）处理。</li>
<li>其中重要的方法如下：<ul>
<li><code>protected void doDispatch(HttpServletRequest request, HttpServletResponse response)</code>：执行分发的流程</li>
<li><code>protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)</code>：渲染视图</li>
</ul>
</li>
</ul>
<h1 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h1><ul>
<li>顾名思义，就是保存Handler和Mapping之间的对应的关系，当然这种关系是多种的，有<strong>uri to beanName</strong>，有<strong>uri to HandlerMethod</strong>，不同的对应关系有不同的实现类处理，因此就衍生了后续的三种实现类。</li>
</ul>
<h2 id="BeanNameUrlHandlerMapping"><a href="#BeanNameUrlHandlerMapping" class="headerlink" title="BeanNameUrlHandlerMapping"></a>BeanNameUrlHandlerMapping</h2><ul>
<li>见名思意，这种肯定是uri to beanName的实现，用于存储实现了<code>Controller</code>和<code>HttpRequestHandler</code>接口的Handler的映射关系</li>
</ul>
<h2 id="SimpleUrlHandlerMapping"><a href="#SimpleUrlHandlerMapping" class="headerlink" title="SimpleUrlHandlerMapping"></a>SimpleUrlHandlerMapping</h2><ul>
<li>这种也是uri to Handler的实现，不过这种用于存储<code>View-controller</code>、<code>ResourceHttpRequestHandler</code>的映射关系</li>
</ul>
<h2 id="RequestMappingHandlerMapping"><a href="#RequestMappingHandlerMapping" class="headerlink" title="RequestMappingHandlerMapping"></a>RequestMappingHandlerMapping</h2><ul>
<li>这种用于实现uri to HandlerMethod的关系，从名称可以看出，这种是用于使用<code>@RequestMapping</code>注解的</li>
</ul>
<h1 id="HandlerExecutionChain"><a href="#HandlerExecutionChain" class="headerlink" title="HandlerExecutionChain"></a>HandlerExecutionChain</h1><ul>
<li>处理器执行链，其中存储了Handler和拦截器</li>
</ul>
<h1 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h1><ul>
<li>简单的说就是执行的Handler的适配类，定义了三个方法，如下：<ul>
<li><code>boolean supports(Object handler);</code>：判断当前的HandlerAdapter是否支持这个Handler</li>
<li><code>ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;</code>：执行Handler的方法</li>
<li><code>long getLastModified(HttpServletRequest request, Object handler);</code>：获取请求都中的<code>LastModified</code></li>
</ul>
</li>
</ul>
<ul>
<li>该接口有多个实现类，如下：<ul>
<li><code>RequestMappingHandlerAdapter</code>：匹配HandlerMethod</li>
<li><code>HttpRequestHandlerAdapter</code>：匹配实现了<code>HttpRequestHandler</code>接口的Handler</li>
<li><code>SimpleControllerHandlerAdapter</code>：匹配实现了Controller接口的Handler</li>
</ul>
</li>
</ul>
<h1 id="执行流程分析"><a href="#执行流程分析" class="headerlink" title="执行流程分析"></a>执行流程分析</h1><p><img src="https://raw.githubusercontent.com/chenjiabing666/BlogImage/master/springMVC%20-proceed.png" alt=""></p>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;实现Controller的方式&quot;&gt;&lt;a href=&quot;#实现Controller的方式&quot; class=&quot;headerlink&quot; title=&quot;实现Controller的方式&quot;&gt;&lt;/a&gt;实现Controller的方式&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;如何实现一个contro
    
    </summary>
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Springmvc注解版开发</title>
    <link href="http://chenjiabing666.github.io/2019/07/31/Springmvc%E6%B3%A8%E8%A7%A3%E7%89%88%E5%BC%80%E5%8F%91/"/>
    <id>http://chenjiabing666.github.io/2019/07/31/Springmvc注解版开发/</id>
    <published>2019-07-31T06:45:22.000Z</published>
    <updated>2020-03-13T06:13:50.784Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h1><h2 id="搭建原理"><a href="#搭建原理" class="headerlink" title="搭建原理"></a>搭建原理</h2><p><img src="https://docs.spring.io/spring/docs/5.1.8.RELEASE/spring-framework-reference/images/mvc-context-hierarchy.png" alt=""></p>
<h2 id="springMVC版本"><a href="#springMVC版本" class="headerlink" title="springMVC版本"></a>springMVC版本</h2><ul>
<li>此次使用的版本是Spring 5.1.8</li>
</ul>
<h2 id="配置内嵌tomcat"><a href="#配置内嵌tomcat" class="headerlink" title="配置内嵌tomcat"></a>配置内嵌tomcat</h2><ul>
<li>为了简化开发，使用tomcat插件实现web项目的运行，只需要在pom.xml中配置一个插件即可，如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">uriEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">uriEncoding</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>之后在IDEA右侧的maven处可以看见tomcat7这个插件了，点击run即可运行</li>
</ul>
<h2 id="配置DispatcherServlet初始化器"><a href="#配置DispatcherServlet初始化器" class="headerlink" title="配置DispatcherServlet初始化器"></a>配置DispatcherServlet初始化器</h2><ul>
<li>配置的方式有多种，但是根据Spring文档推荐的方式如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cn.tedu.demo.config.AppConfig;</div><div class="line"><span class="keyword">import</span> cn.tedu.demo.config.WebMvcConfig;</div><div class="line"><span class="keyword">import</span> org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 配置DispatcherServlet初始化器，在容器启动的时候会加载初始化</div><div class="line"> * 入口就是/org/springframework/spring-web/5.1.8.RELEASE/spring-web-5.1.8.RELEASE.jar!/META-INF/services/javax.servlet.ServletContainerInitializer</div><div class="line"> * web容器在启动的时候会加载META-INF/service下的文件</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrartWebApplicationInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 配置主配置类，主配置类的作用就是配置业务所需要的各种Bean，比如dao，service</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class[]&#123;AppConfig.class&#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 配置MVC所需的配置类，该配置类的作用就是扫描controller，配置mvc的各种组件，比如视图解析器，拦截器等</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class[]&#123;WebMvcConfig.class&#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 配置servletMapping，相当于在DispatcherServlet中配置的url</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">"/"</span>&#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="主配置文件"><a href="#主配置文件" class="headerlink" title="主配置文件"></a>主配置文件</h2><ul>
<li>主配置文件主要的作用就是配置业务需求的Bean，比如dao，service层的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.FilterType;</div><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 业务逻辑的配置类，扫描所有的业务Bean，比如dao，service，排除所有的controller</div><div class="line"> */</div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"cn.tedu.demo"</span>&#125;,excludeFilters = &#123;<span class="meta">@ComponentScan</span>.Filter(type = FilterType.ANNOTATION,classes = &#123;Controller.class&#125;)&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="MVC配置类"><a href="#MVC配置类" class="headerlink" title="MVC配置类"></a>MVC配置类</h2><ul>
<li>MVC配置类主要的作用就是扫描Controller，配置各种组件，比如视图解析器，拦截器等等</li>
<li>重要的两点如下：<ul>
<li>使用<code>@EnableWebMvc</code>注解开启MVC功能，相当于xml文件中的<code>&lt;mvc:annotation-driven/&gt;</code></li>
<li>配置类需要实现<code>WebMvcConfigurer</code>，该接口下有各种方法，开发者可以实现其中的方法完成相关组件的生成</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cn.tedu.demo.interceptor.CustomInterceptor;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.FilterType;</div><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</div><div class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.*;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * MVC的配置类，扫描所有的controller，排除所有的业务类</div><div class="line"> * <span class="doctag">@EnableWebMvc</span> 注解开启mvc功能</div><div class="line"> * <span class="doctag">@ComponentScan</span> 注解中的属性useDefaultFilters（默认是true，扫描全部的Bean），这里我们定义了只扫描controller，因此要设置该属性为false，否则不起作用，排除Bean则不需要</div><div class="line"> */</div><div class="line"><span class="meta">@EnableWebMvc</span></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"cn.tedu.demo"</span>&#125;,includeFilters = &#123;<span class="meta">@ComponentScan</span>.Filter(type = FilterType.ANNOTATION,classes = &#123;Controller.class&#125;)&#125;,useDefaultFilters = <span class="keyword">false</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a>配置拦截器</h1><ul>
<li>自定义一个拦截器，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义一个拦截器，实现HandlerInterceptor</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 在拦截器方法之前执行</div><div class="line">     * <span class="doctag">@param</span> request request</div><div class="line">     * <span class="doctag">@param</span> response response</div><div class="line">     * <span class="doctag">@param</span> handler 拦截的handler</div><div class="line">     * <span class="doctag">@return</span> 如果返回false，后续的拦截器和拦截的handler不执行</div><div class="line">     * <span class="doctag">@throws</span> Exception</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"在之前执行"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在配置类设置自定义的拦截器，使得起作用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</div><div class="line">       <span class="comment">//创建</span></div><div class="line">       CustomInterceptor customInterceptor = <span class="keyword">new</span> CustomInterceptor();</div><div class="line">       <span class="comment">//添加自定义的拦截器</span></div><div class="line">       registry.addInterceptor(customInterceptor).addPathPatterns(<span class="string">"/**"</span>);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li>自定义的拦截器的真实实现类其实是<code>MappedInterceptor</code>，在源码中获取处理器执行链的时候会将其添加到执行链中。</li>
</ul>
<h1 id="配置过滤器"><a href="#配置过滤器" class="headerlink" title="配置过滤器"></a>配置过滤器</h1><ul>
<li>过滤器不属于SpringMVC，而是属于Servlet中的组件，因此配置过滤器使用的并不是MVC的配置，但是在Servlet3.0中也是提供了注解版的Servlet和Filter的生成方式，我们使用注解生成一个Filter，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义过滤器</div><div class="line"> */</div><div class="line"><span class="meta">@WebFilter</span>(filterName = <span class="string">"customFilter"</span>,urlPatterns = <span class="string">"/*"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"过滤器初始化"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"过滤器执行"</span>);</div><div class="line">        chain.doFilter(request,response);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"过滤器销毁"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="配置视图解析器"><a href="#配置视图解析器" class="headerlink" title="配置视图解析器"></a>配置视图解析器</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> </span>&#123;</div><div class="line">       registry.jsp(<span class="string">"/WEB_INF/"</span>,<span class="string">".jsp"</span>);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h1 id="配置ViewController"><a href="#配置ViewController" class="headerlink" title="配置ViewController"></a>配置ViewController</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</div><div class="line">        <span class="comment">//定义一个controller，访问路径是/index.do，跳转的视图是index.jsp</span></div><div class="line">        registry.addViewController(<span class="string">"/index.do"</span>).setViewName(<span class="string">"index"</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="配置MessageConverters"><a href="#配置MessageConverters" class="headerlink" title="配置MessageConverters"></a>配置MessageConverters</h1><ul>
<li>消息转换器用于对Request和Response的消息进行处理，比如将Response中的消息转换为指定JSON字符串的形式</li>
<li>默认的消息转换器对于日期的类型的转换是时间戳，即是返回的JSON字符串的日期类型是时间戳，接收的日期类型参数也只能是时间戳</li>
<li>如何配置消息转换器，只需要重写springmvc配置类中的方法即可。</li>
<li>我们使用的是<code>MappingJackson2HttpMessageConverter</code>这类转换器，但是其中依赖的是ObjectMapper，因此我们比如引入依赖，如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>在上述的MVC配置类中重写如下方法：<ul>
<li>设置日期的格式化格式是yyyy-MM-dd，此时返回和接收的格式就是<code>yyyy-MM-dd</code></li>
<li>在配置类中配置的消息转换器属于<strong>全局配置</strong>，所有的消息都会遵循这种配置。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</div><div class="line">       Jackson2ObjectMapperBuilder builder = <span class="keyword">new</span> Jackson2ObjectMapperBuilder()</div><div class="line">               .indentOutput(<span class="keyword">true</span>)</div><div class="line">               <span class="comment">//指定格式化的日期，这里只是举例，不建议在此处全局配置</span></div><div class="line">               .dateFormat(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>))</div><div class="line">               <span class="comment">//设置时区，默认是UTC，需要修改成北京时间</span></div><div class="line">               .timeZone(<span class="string">"GMT+8"</span>);</div><div class="line">       converters.add(<span class="keyword">new</span> MappingJackson2HttpMessageConverter(builder.build()));</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h2 id="注解版"><a href="#注解版" class="headerlink" title="注解版"></a>注解版</h2><ul>
<li>在实际的项目中这种方式太鸡肋，实际的需求有实际的变化，因此我们最好能够寻找一种灵活的处理方式，类似注解的方式。</li>
<li>在<code>jackson-databind</code>中提供了许多的注解，可以供我们使用，<strong>可以覆盖全局配置，和全局配置形成一种互补的作用</strong>。</li>
<li><code>@JsonFormat</code>：日期格式化注解，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//timeZone如果在全局配置过，可以不写	</span></div><div class="line"><span class="meta">@JsonFormat</span>(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>,timezone = <span class="string">"GMT+8"</span>)</div><div class="line">    <span class="keyword">private</span> Date birthDay;</div></pre></td></tr></table></figure>
<ul>
<li><code>@JsonIgnore</code>：在返回的JSON字符串中不显示</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@JsonIgnore</span></div><div class="line">   <span class="keyword">private</span> String name;</div></pre></td></tr></table></figure>
<ul>
<li>其他的注解请参考<a href="https://blog.51cto.com/7308310/2310930?source=dra" target="_blank" rel="external">https://blog.51cto.com/7308310/2310930?source=dra</a></li>
</ul>
<h1 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a>异常处理器</h1><ul>
<li>springMvc处理异常有三种方式，分别为：<ul>
<li><code>ExceptionHandlerExceptionResolver</code>：通过调用或 类中的<code>@ExceptionHandler</code>方法来解决异常，可以结合<code>@ControllerAdvice</code></li>
<li><code>DefaultHandlerExceptionResolver</code>：对一些特殊的异常进行处理</li>
<li><code>ResponseStatusExceptionResolver</code>：使用<code>@ResponseStatus</code>解析异常，并根据注解中的值将它们映射到HTTP状态代码 </li>
<li><code>SimpleMappingExceptionResolver</code>：异常和视图的映射，可以自定义指定的异常对应的视图</li>
</ul>
</li>
<li><strong>原理：主要的解析逻辑都是在<code>doResolveException</code>方法中完成的。</strong></li>
</ul>
<h2 id="异常处理器执行的顺序"><a href="#异常处理器执行的顺序" class="headerlink" title="异常处理器执行的顺序"></a>异常处理器执行的顺序</h2><ul>
<li>异常处理器的执行是有顺序的，优先级高的执行完之后，如果有对应的处理，那么后续的就不再执行。</li>
<li>异常处理器的执行顺序如下：<ul>
<li><code>ExceptionHandlerExceptionResolver</code></li>
<li><code>DefaultHandlerExceptionResolver</code></li>
<li><code>ResponseStatusExceptionResolver</code></li>
<li><code>SimpleMappingExceptionResolver</code></li>
</ul>
</li>
<li>四种异常处理器的顺序执行可以形成一种互补的配置。</li>
</ul>
<h2 id="SimpleMappingExceptionResolver"><a href="#SimpleMappingExceptionResolver" class="headerlink" title="SimpleMappingExceptionResolver"></a>SimpleMappingExceptionResolver</h2><ul>
<li>在配置中配置即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> SimpleMappingExceptionResolver <span class="title">simpleMappingExceptionResolver</span><span class="params">()</span></span>&#123;</div><div class="line">        SimpleMappingExceptionResolver resolver = <span class="keyword">new</span> SimpleMappingExceptionResolver();</div><div class="line">        <span class="comment">//设置默认的视图，如果有的异常没有指定处理，那么使用默认的视图</span></div><div class="line">        resolver.setDefaultErrorView(<span class="string">"index"</span>);</div><div class="line">        <span class="comment">//设置排除的异常</span></div><div class="line"><span class="comment">//        resolver.setExcludedExceptions();</span></div><div class="line">        <span class="comment">//指定异常视图映射</span></div><div class="line">        Properties properties=<span class="keyword">new</span> Properties();</div><div class="line">        properties.put(RuntimeException.class.getName(),<span class="string">"error"</span>);</div><div class="line">        resolver.setExceptionMappings(properties);</div><div class="line">        <span class="keyword">return</span> resolver;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="DefaultHandlerExceptionResolver"><a href="#DefaultHandlerExceptionResolver" class="headerlink" title="DefaultHandlerExceptionResolver"></a>DefaultHandlerExceptionResolver</h2><ul>
<li>此类异常解析器只能针对一些特殊的异常进行处理，如下：</li>
</ul>
<table>
<thead>
<tr>
<th>Exception</th>
<th>HTTP Status Code</th>
</tr>
</thead>
<tbody>
<tr>
<td>HttpRequestMethodNotSupportedException</td>
<td>405 (SC_METHOD_NOT_ALLOWED)</td>
</tr>
<tr>
<td>HttpMediaTypeNotSupportedException</td>
<td>415 (SC_UNSUPPORTED_MEDIA_TYPE)</td>
</tr>
<tr>
<td>HttpMediaTypeNotAcceptableException</td>
<td>406 (SC_NOT_ACCEPTABLE)</td>
</tr>
<tr>
<td>MissingPathVariableException</td>
<td>500 (SC_INTERNAL_SERVER_ERROR)</td>
</tr>
<tr>
<td>MissingServletRequestParameterException</td>
<td>400 (SC_BAD_REQUEST)</td>
</tr>
<tr>
<td>ServletRequestBindingException</td>
<td>400 (SC_BAD_REQUEST)</td>
</tr>
<tr>
<td>ConversionNotSupportedException</td>
<td>500 (SC_INTERNAL_SERVER_ERROR)</td>
</tr>
<tr>
<td>TypeMismatchException</td>
<td>400 (SC_BAD_REQUEST)</td>
</tr>
<tr>
<td>HttpMessageNotReadableException</td>
<td>400 (SC_BAD_REQUEST)</td>
</tr>
<tr>
<td>HttpMessageNotWritableException</td>
<td>500 (SC_INTERNAL_SERVER_ERROR)</td>
</tr>
<tr>
<td>MethodArgumentNotValidException</td>
<td>400 (SC_BAD_REQUEST)</td>
</tr>
<tr>
<td>MissingServletRequestPartException</td>
<td>400 (SC_BAD_REQUEST)</td>
</tr>
<tr>
<td>BindException</td>
<td>400 (SC_BAD_REQUEST)</td>
</tr>
<tr>
<td>NoHandlerFoundException</td>
<td>404 (SC_NOT_FOUND)</td>
</tr>
<tr>
<td>AsyncRequestTimeoutException</td>
<td>503 (SC_SERVICE_UNAVAILABLE)</td>
</tr>
</tbody>
</table>
<ul>
<li>不需要声明，默认存在</li>
</ul>
<h2 id="ResponseStatusExceptionResolver"><a href="#ResponseStatusExceptionResolver" class="headerlink" title="ResponseStatusExceptionResolver"></a>ResponseStatusExceptionResolver</h2><ul>
<li>在自定义的异常类上标注<code>@ResponseStatus</code>注解，当抛出此种异常的时候，将会响应定义的状态码和提示语</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ResponseStatus</span>(code = HttpStatus.FORBIDDEN,reason = <span class="string">"没有权限"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomException</span> <span class="keyword">extends</span>  <span class="title">RuntimeException</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ExceptionHandlerExceptionResolver"><a href="#ExceptionHandlerExceptionResolver" class="headerlink" title="ExceptionHandlerExceptionResolver"></a>ExceptionHandlerExceptionResolver</h2><ul>
<li>集合<code>@ControllerAdvice</code>和<code>@RestControllerAdvice</code>使用</li>
<li>方法中能够自动赋值的参数和返回值的类型都在Spring文档上有详细的记载，参考<code>https://docs.spring.io/spring/docs/5.1.8.RELEASE/spring-framework-reference/web.html#mvc-ann-exceptionhandler-args</code></li>
<li>详细的使用如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ControllerAdvice</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *</div><div class="line">     *处理FileNotFoundException，返回JSOn数据</div><div class="line">     */</div><div class="line">    <span class="meta">@ExceptionHandler</span>(value = ArrayIndexOutOfBoundsException.class)</div><div class="line">    <span class="meta">@ResponseBody</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handleFileNotFoundException</span><span class="params">(Exception ex, HttpServletRequest request, HandlerMethod method)</span></span>&#123;</div><div class="line">        System.out.println(request.getRequestURI());</div><div class="line">        System.out.println(method);</div><div class="line">        System.out.println(ex);</div><div class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@ExceptionHandler</span>(value = Exception.class)</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handleException</span><span class="params">(Exception ex, HttpServletRequest request, HandlerMethod method)</span></span>&#123;</div><div class="line">        System.out.println(request.getRequestURI());</div><div class="line">        System.out.println(method);</div><div class="line">        System.out.println(ex);</div><div class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="配置跨域请求"><a href="#配置跨域请求" class="headerlink" title="配置跨域请求"></a>配置跨域请求</h1><h2 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h2><ul>
<li>使用注解<code>@CrossOrigin</code>，可以标注在Controller上，也可以标注在方法上，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CrossOrigin</span></div><div class="line">   <span class="meta">@PostMapping</span>(<span class="string">"/getObj"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(@RequestBody AdminReq req)</span></span>&#123;</div><div class="line">       System.out.println(req);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Admin(<span class="string">"陈加兵"</span>,<span class="number">22</span>,<span class="keyword">new</span> Date(),<span class="keyword">new</span> Date());</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li>该注解中可以配置各种属性，这里不再细讲，在下面的全局配置中会涉及到。</li>
</ul>
<h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><ul>
<li>全局配置就是在MVC的配置文件中重写方法即可，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</div><div class="line">       registry.addMapping(<span class="string">"/api/**"</span>)</div><div class="line">               <span class="comment">//允许的源</span></div><div class="line">               .allowedOrigins(<span class="string">"https://domain2.com"</span>)</div><div class="line">               <span class="comment">//允许请求跨域的请求类型</span></div><div class="line">               .allowedMethods(<span class="string">"PUT"</span>, <span class="string">"DELETE"</span>)</div><div class="line">               <span class="comment">//允许的请求头</span></div><div class="line">               .allowedHeaders(<span class="string">"header1"</span>, <span class="string">"header2"</span>, <span class="string">"header3"</span>)</div><div class="line">               <span class="comment">//暴露的请求头</span></div><div class="line">               .exposedHeaders(<span class="string">"header1"</span>, <span class="string">"header2"</span>)</div><div class="line">               <span class="comment">//允许携带cookie等用户信息，这样才能实现登录</span></div><div class="line">               .allowCredentials(<span class="keyword">true</span>).maxAge(<span class="number">3600</span>);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h1 id="配置静态资源解析"><a href="#配置静态资源解析" class="headerlink" title="配置静态资源解析"></a>配置静态资源解析</h1><ul>
<li>springmvc中的DispatcherServlet如果设置了拦截的请求是<code>/</code>，那么也会拦截静态资源，但是我们可以在配置文件中配置，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</div><div class="line">       <span class="comment">//拦截的请求</span></div><div class="line">       registry.addResourceHandler(<span class="string">"/resources/**"</span>)</div><div class="line">               <span class="comment">//资源的位置</span></div><div class="line">               .addResourceLocations(<span class="string">"/public"</span>, <span class="string">"classpath:/static/"</span>)</div><div class="line">               <span class="comment">//缓存的时间，单位秒</span></div><div class="line">               .setCachePeriod(<span class="number">31556926</span>);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li>该配置会在ioc中注册一个<code>ResourceHttpRequestHandler</code>，封装在<strong>SimpleUrlHandlermapping</strong>中。</li>
</ul>
<h1 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h1><ul>
<li><code>@EnableMvc</code>注解其实就是注入了一个配置类<code>DelegatingWebMvcConfiguration</code>，那么我们可以将自定义的配置类实现该类即可完成MVC的高级功能，此时就不需要使用该注解了，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"cn.tedu.demo"</span>&#125;,includeFilters = &#123;<span class="meta">@ComponentScan</span>.Filter(type = FilterType.ANNOTATION,classes = &#123;Controller.class, Component.class&#125;)&#125;,useDefaultFilters = <span class="keyword">false</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvanceConfig</span> <span class="keyword">extends</span> <span class="title">DelegatingWebMvcConfiguration</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;项目搭建&quot;&gt;&lt;a href=&quot;#项目搭建&quot; class=&quot;headerlink&quot; title=&quot;项目搭建&quot;&gt;&lt;/a&gt;项目搭建&lt;/h1&gt;&lt;h2 id=&quot;搭建原理&quot;&gt;&lt;a href=&quot;#搭建原理&quot; class=&quot;headerlink&quot; title=&quot;搭建原理&quot;&gt;&lt;/a
    
    </summary>
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://chenjiabing666.github.io/tags/Spring/"/>
    
  </entry>
  
</feed>
