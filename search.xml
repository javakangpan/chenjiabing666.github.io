<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Mybatis之增删改查]]></title>
      <url>%2F2018%2F05%2F04%2FMybatis%E4%B9%8B%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%2F</url>
      <content type="text"><![CDATA[Mybatis的增删改查增加数据&lt;insert&gt; 在增加数据的时候，mybatis默认返回的是受影响的行数，因此不需要指定ResultType指定返回类型 在UserMapper.java接口中添加方法 1234/** @param user User对象*/Integer reg(User user); UserMapper.xml文件中添加&lt;insert&gt;节点 #{}中填写的是User对象的属性名称 ​ 1234567891011121314&lt;!-- 节点名称取决于需要执行的操作 --&gt; &lt;!-- 例如增加操作应该使用insert节点 --&gt; &lt;!-- id属性(*)的值是Java接口中的方法名称 --&gt; &lt;!-- parameterType属性的值是参数类型 --&gt; &lt;!-- 节点中间编写SQL语句 --&gt; &lt;insert id="reg" parameterType="cn.tedu.spring.entity.User"&gt; INSERT INTO user ( username, password ) VALUES ( #&#123;username&#125;, #&#123;password&#125; ) &lt;/insert&gt; 测试 1234567891011121314151617181920212223242526@Test public void testReg() &#123; //加载Spring的配置文件 AbstractApplicationContext ac = new ClassPathXmlApplicationContext( "spring-mvc.xml", "spring-dao.xml"); //获取UserMapper的bean，这个是spring通过扫描mapper.xml文件自动为mybatis自动创建的，首字母小写 UserMapper userMapper = ac.getBean( "userMapper", UserMapper.class); //新建User对象 User user = new User(); user.setUsername("Tom1"); user.setPassword("123456"); //调用reg(user)，进行添加，返回的是受影响的行数 Integer affectedRows = userMapper.reg(user); System.out.println( "affectedRows=" + affectedRows); ac.close(); &#125; 在Mybatis中增加数据时获取自增主键的id 首先mybatis在处理增加数据的功能时，只是返回受影响的行数，所以在持久层中并不会返回新增加的 如果需要获取自增主键Id，首先，在XML映射的&lt;insert&gt;节点中需要添加2个属性 useGeneratedKeys ：设置是否返回自增主键，如果为true则返回，默认为false keyProperty ： 配置自增主键在表中对应的字段 ，因为有时候在表中的自增主键的字段可能不是id，因此需要指定 123456789101112131415&lt;!-- 节点名称取决于需要执行的操作 --&gt;&lt;!-- 例如增加操作应该使用insert节点 --&gt;&lt;!-- id属性(*)的值是Java接口中的方法名称 --&gt;&lt;!-- parameterType属性的值是参数类型 useGeneratedKeys: 指定是否返回自增主键，默认为false keyProperty:配置自增主键在表中对应的字段 --&gt;&lt;insert id="reg" parameterType="cn.tedu.spring.entity.User" useGeneratedKeys="true" keyProperty="id"&gt; INSERT INTO user ( username, password ) VALUES ( #&#123;username&#125;, #&#123;password&#125; )&lt;/insert&gt; 此时的mybatis执行insert方法之后，即是调用reg(user)，返回的还是受影响的行数，并不是此时的自增主键id的值。而是在调用这个方法的时候将id封装到指定的方法参数中，即是封装到user中了，因此只有调用者才可以获取id，而持久层无法获取 12345678910111213141516171819202122232425262728@Testpublic void testReg() &#123; //加载Spring的配置文件 AbstractApplicationContext ac = new ClassPathXmlApplicationContext( "spring-mvc.xml", "spring-dao.xml"); //获取UserMapper的bean，这个是spring通过扫描mapper.xml文件自动为mybatis自动创建的，首字母小写 UserMapper userMapper = ac.getBean( "userMapper", UserMapper.class); //新建User对象，此时并没有设置id的值 User user = new User(); user.setUsername("Tom1"); user.setPassword("123456"); //调用reg(user)，进行添加，返回的是受影响的行数，但是此时已经将id封装到参数User对象中了 Integer affectedRows = userMapper.reg(user); System.out.println( "affectedRows=" + affectedRows); //直接获取Uesr对象中的id值，这个是自增主键返回的值 System.out.println("id = "+user.getId()); ac.close();&#125; 删除数据&lt;delete&gt; 在删除数据的时候，自动会返回受影响的行数，不需要在delete节点中定义返回类型，只有在查询数据的时候才会定义返回类型 在UserMapper.java中添加一个接口方法 12//根据id删除数据，返回受影响的行数，返回1，如果删除失败返回0Integer deleteUserById(int id); 在UserMapper.xml中配置&lt;delete&gt;节点 1234567&lt;!-- 删除用户数据根据id Integer deleteUserById(int id) parameterType: 指定参数类型，这里也可以不需要指定 --&gt;&lt;delete id="deleteUserById" parameterType="int"&gt; delete from user where id=#&#123;id&#125;&lt;/delete&gt; 删除数据是不可逆的，通常不会真正的删除数据，我们会使用备份，日志等手段来保存数据，在许多软件上看到的删除也许都是修改操作，通常在表中有一个字段is_deleted标记是否删除，如果执行删除，那么就会设置其值为true表示已经删除了，那么此时将不会显示在客户端，让客户以为已经被删除了 Mybaits参数规则 mybatis默认支持一个参数，即是定义的接口方法中只能有一个参数 如果需要支持多个参数，那么需要使用@Param()注解 如果接口方法中的参数类型是基本类型的可以不用parameterType指定类型，如果不是基本类型的，规范要求需要使用parameterType指定类型，但是可以不写 @Param() mybatis默认支持一个参数，即是定义的接口方法中只能有一个参数 在设计java接口方法时，如果需要指定多个参数，那么必须使用@Param() 如果想要支持多个参数，需要使用@Param()来指定参数，比如Integer ChangePassword(@Param(&quot;id&quot;)Integer id,@Param(&quot;newPassword&quot;)String newPassword); 其中@Param(&quot;key&quot;)中的value在配置增删改查的时候是使用#{key}表达式取出的 mybaits在处理过程中，本质上是使用了Map对参数进行了封装的。即是@Param(&quot;&quot;)注解中给出的参数值是Map中的key，调用方法时给出的参数值是Map中的value值，而最终在XML文件中使用#{}获取值，其实是使用Map中的get(key)方法获取的 修改数据&lt;update&gt; 在修改数据的时候，mybatis自动返回受影响的行数，因此我们不需要定义返回类型，默认的返回数据就是受影响的行数 在UserMapper.java接口中定义根据id修改数据的方法 使用@Param()注解来标记多个参数 ​ 1234567/** * 修改密码 * @param id id * @param newPassword 新密码 * @return 受影响的行数 */Integer ChangePassword(@Param("id")Integer id,@Param("newPassword")String newPassword); 在UserMapper.xml中添加&lt;update&gt;节点 其中#{}表达式中的字段为@Param(&quot;value&quot;)中的value ​ 123456&lt;!-- 修改密码 Integer ChangePassword(@Param("id")Integer id,@Param("newPassword")String newPassword); --&gt;&lt;update id="ChangePassword"&gt; update user set password=#&#123;newPassword&#125; where id=#&#123;id&#125;&lt;/update&gt; 测试方法 1234567891011121314151617@Testpublic void testChangePassword() &#123; //加载Spring的配置文件 AbstractApplicationContext ac = new ClassPathXmlApplicationContext( "spring-mvc.xml", "spring-dao.xml"); //获取UserMapper的bean，这个是spring通过扫描mapper.xml文件自动为mybatis自动创建的，首字母小写 UserMapper userMapper = ac.getBean( "userMapper", UserMapper.class); //调用删除的方法 int affectRow=userMapper.ChangePassword(3, "12345895"); System.out.println(affectRow); ac.close();&#125; 案例：修改用户密码用户提供数据 旧密码：oldPassword 新密码：newPassword 步骤 通过id查找用户信息 不可以使用select * from user where id=? and password=?,因为这个是不区分大小写的,我们应该先根据id获取用户信息，再比较password 在UserserviceImpl中完成验证逻辑，如果用户不存在，那么抛出用户不存在的异常，如果存在就验证原密码和是否匹配 用户信息存在，那么就要验证用户输入的oldPassword和用户信息中的原密码是否相同了，如果不相同，抛出密码不匹配的异常，如果相同，那么就可以修改密码 修改密码 实现 我们编写了一个UserService中编写逻辑 1234567891011121314public void ChangePasssword(Integer id, String oldPassword, String newPassword) throws UserNotFoundException, PasswordNotMatchException&#123; User user=this.findUserById(id); //获取用户信息 if (user==null) &#123; //如果用户信息不存在 throw new UserNotFoundException("操作失败，用户信息不存在"); &#125;else &#123; //用户存在，则判断原密码 if (user.getPassword().equals(oldPassword)) &#123;//如果密码匹配 userMapper.ChangePassword(id, newPassword); //修改密码 &#125;else &#123; //原密码不匹配 throw new PasswordNotMatchException("操作失败，原密码不正确"); &#125; &#125;&#125; 那么在Controller中如果要调用这个ChangePasssword将会通过处理异常来判断哪里是出错了，并给出友好的提示 查询数据&lt;select&gt;单条数据的查询 根据id的查询返回的查询结果就是单条数据，比如：select * from user where id=1 单条记录的查询在编写接口方法的时候，只需要返回一个实体类对象即可 123456/** * 根据id查询用户信息 * @param id 用户id * @return 返回User对象 */User findUserById(Integer id); 在UserMapper.xml中配置&lt;select&gt;节点 需要使用resultType指定返回的类型，因为参数是基本类型，因此不需要使用parameterType指定参数类型 123&lt;select id="findUserById" resultType="cn.tedu.spring.entity.User"&gt; select * from user where id=#&#123;id&#125;&lt;/select&gt; 多条记录的查找 有些查找语句返回的是多条记录，那么我们可以使用List&lt;&gt;集合来接收返回的结果，不能直接使用实体类对象来接收 在UserMapper.java中定义接口方法 123456/** * 根据密码查找用户 * @param password 用户密码 * @return 返回的是一个用户的集合 */List&lt;User&gt; findUserByPassword(String password); 在UserMapper.xml中添加&lt;select&gt;节点 这里的resultType虽然返回的是User集合，但是这里的类型还是需要写User类型 由于参数是基本类型，因此不需要使用parameterType 12345678&lt;!-- List&lt;User&gt; findUserByPassword(String password); resultType: 虽然返回的是User集合，但是这里的类型还是需要写User类型 --&gt; &lt;select id="findUserByPassword" resultType="cn.tedu.spring.entity.User"&gt; select * from user where password=#&#123;password&#125; &lt;/select&gt; 测试 1234567891011121314151617@Testpublic void testFindUserByPassword() &#123; //加载Spring的配置文件 AbstractApplicationContext ac = new ClassPathXmlApplicationContext( "spring-mvc.xml", "spring-dao.xml"); //获取UserMapper的bean，这个是spring通过扫描mapper.xml文件自动为mybatis自动创建的，首字母小写 UserMapper userMapper = ac.getBean( "userMapper", UserMapper.class); //获取User集合 List&lt;User&gt; users=userMapper.findUserByPassword("12345895"); System.out.println(users); ac.close();&#125; 总结 xxMapper.xml中配置的节点的id要和xxMapper.java中的方法名相同 mybatis默认支持一个参数，但是我们可以使用@Param(&quot;&quot;)指定多个参数，不过在使用#{}取值的时候要和@Param(&quot;&quot;)中的参数一致 获取自增主键并不是作为方法的返回值，而是在调用方法的时候将自增主键的值设置在方法参数的对象中，那么此时的调用者就可以获取到自增主键的值 增加，修改，删除，方法返回的永远是受影响的行数 在定义实体类属性的时候，尽量使用包装类，比如`Integer age` 只要是&lt;select&gt;节点，那么必须写返回类型resultType，无论是基本型还是其他类型]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[快速排序算法]]></title>
      <url>%2F2018%2F05%2F04%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[快速排序算法思想(从小到大排序) 快速排序是使用分治法来完成的 基本思想就是先从其中选取一个基准值，然后从数组的两端开始移动查找，在右边移动查找到比基准值小的数据停止移动，此时在左边查找到比基准值大的数据也停止查找，交换这两个查找到的数据，交换完成之后两端继续移动查找，如果左边找到比基准值大的，右边找到比基准值小的数据，再次交换。直到查找到同一个数据上(相遇)或者”擦肩而过”。那么将基准值与相遇的那个值交换，此时就能够保证在基准值左边的都是比基准值小的，在其右边的都是比其大的数，此时一轮查找结束。接下来这个基准值将一个数组分成了两半，左边的是小的，右边是大的，那么我们再分别对左边和右边的数据进行相同的操作，直至不可拆分成新的子序列为止。 快速排序的最坏运行时间是O(n2)，但期望的运行时间是O(nlgn)。 ##选取数组的第一个数为基准值 我们选取数组的第一个元素作为基准值 此时先从数组的最右边开始查找，如果找到比基准值小的停止查找，再从最左边开始查找，直至找到比基准值大的，那么两边就交换，交换完成之后，最右边再次开始查找，找到就等待左边找到数交换，直至双方相遇。那么把相遇的那个点的数据和基准值交换即可，那么现在在基准值左边的都是小的，在右边的都是大的，此时的基准值将数组分成了两个子序列，再对子序列进行重复的操作，直到不可拆分成子序列。 实现的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344public static void quickSort(int[] arr,int low,int high)&#123; //递归结束的条件，如果此时的子序列只有一个元素就是low=high，就不用排序了 if(low&gt;=high)&#123; return; &#125; int i=low; //i从最左边开始查找 int j=high; //i从最右边开始查找 int temp = arr[low]; //设置基准值为第一个元素，temp //如果此时的i和j没有相遇，一直进行下去 while (i&lt;j) &#123; //先从右边开始查找，如果没有找到比基准值小的并且没有相遇，那么继续向右查找 while (temp&lt;=arr[j]&amp;&amp;i&lt;j) &#123; j--; //向左移动 &#125; //再从左边开始查找，如果没有找到比基准值大的并且没有相遇，那么继续向左查找 while (temp&gt;=arr[i]&amp;&amp;i&lt;j) &#123; i++; // 向右移动 &#125; //代码能够运行到这里，那么表示已经找到了右面小于基准值的，左面大于基准值的，那么就可以交换数据了 //这里的i&lt;j用于控制在最后相遇的时候还要交换数据，不必交换了，可以省去一次的交换 if (i&lt;j) &#123; //交换数据 int t = arr[j]; arr[j] = arr[i]; arr[i] = t; &#125; &#125; //最后将基准为与i和j相等位置的数字交换 arr[low] = arr[i]; //第一个元素设置为i和j相遇的那个值 arr[i] = temp; //相遇的那个地方设置为基准值 //递归调用左半数组，以基准值为中心切割 quickSort(arr, low, j-1); //递归调用右半数组 quickSort(arr, j+1, high); &#125; 测试 123456int[] array=&#123; 9,7,4,67,45,2,24,33,22,45,88,12,1,0,25&#125;;quickSort(array, 0, array.length-1);for (int i = 0; i &lt; array.length; i++) &#123; System.out.print(array[i]+"\t");&#125; 另外一种方式123456789101112131415161718192021222324252627282930313233343536373839404142public static int partition(int[] array,int low,int high)&#123; int i=low; int j=high; int temp=array[low]; //选取第一个为基准数 //如果此时的还没有相遇，表示没有结束 while(i&lt;j)&#123; //因为基准数是最左面的，因此从最右面开始查找 //当当前的值比基准值大，并且i和j不相等，即是没有相遇 while(temp&lt;array[j]&amp;&amp;i&lt;j)&#123; j--; //向左移动，继续查找 &#125; //从左面开始查找，如果查找到的数据array[i]小于基准值并且i和j没有相遇，那么继续向右移动查找 while(array[i]&lt;temp&amp;&amp;i&lt;j)&#123; i++; //继续向右移动查找 &#125; //代码能够运行到这里，那么表示已经找到了右面小于基准值的，左面大于基准值的，那么就可以交换数据了 if (i&lt;j) &#123; int t = array[j]; array[j] = array[i]; array[i] = t; &#125; &#125; low=i; high=j; return j ; //返回当前的基准值在数组中的索引，用于分割子序列 &#125; public static void quickSort1(int[] arrary,int low,int high)&#123; //停止条件，如果low&gt;high表示相遇，那么停止递归 if(low&gt;high)&#123; return; &#125; int index=partition(arrary, low, high); //获取基准值的位置 quickSort1(arrary, low, index-1); //左边的 quickSort1(arrary,index+1,high); //右边的 &#125; 为什么从最右边开始查找 如果从最左边开始查找，那么有可能某一次查找到了比基准值大的数，停止查找，等待最右边查找到比基准值小的数，但是此时最右边一直在查找，直到和其相遇都没有查找到比基准值小的数据，那么此时的的基准值就需要和这个比它还大的值交换，那么出现的结果就是此时的数组的第一个数是比基准值大的，违背了左边都是比基准值小的，右边都是比基准值大的。 如果从最右边开始查找，即使当某一个时刻查找到了比基准值小的数据，停止查找，等待左边查找到比基准值大的数据。但是左边没有找到，直至相遇，那么此时相遇的这个数任然是比基准值小的，因此和基准值交换是没有问题的 参考文章https://blog.csdn.net/as02446418/article/details/47395867]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[冒泡排序算法]]></title>
      <url>%2F2018%2F05%2F04%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[冒泡排序算法原理 比较相邻的两个数，将值较大的元素放在最前面，由于较小的数字像泡泡一样浮上来，因此取名为冒泡 从后向前比较(小的数上浮) 第一趟：从数组的最后一个元素和倒数第二个元素比较，小的上浮(交换)，之后倒数第二个和倒数第三个数字比较，小的上浮(交换)，直至第二个数字和第一个数字比较，小的上浮,那么经过一趟排序之后，此时的第一个元素就是最小的 第二趟： 经过第一趟之后，第一个就是最小的数字，因此第二趟就不比较第一个和第二个数字了。从最后一个元素和倒数第二个元素比较，小的上浮，直至第三个元素和第二个元素比较，小的上浮，那么此时的第二个就是仅次于第一个的小的元素 第三趟：和前面一样的比较，不过就是不用比较第二个和第三个元素了，因为经过第一趟和第二趟之后，数组中的第一个和第二个元素已经是最小的两个了。经过第三趟比较，第三个元素是仅次于第一个和第二个元素小的元素 第四趟，第五趟……………………………… 从上面我们可以得出，假设数组中有n个元素，那么需要经过n-1趟排序才可以完成全部的比较，最后一趟可以比较出倒数第一个和倒数第二个元素的大小 实现123456789101112131415161718192021/** * 冒泡排序算法之从后向前比较排序 * @param a 需要排序的数组 */public static void bubbleSort(int[] a) &#123; // 外层循环控制排序的趟数，总共需要n-1趟排序 for (int i = 0; i &lt; a.length - 1; i++) &#123; //内层循环控制的是每一趟排序需要比较的次数，j=a.length-1 表示从最后一个元素开始比较，j&gt;i是用于控制每趟之后比较的次数 //比如，经过第一趟之后，那么第一个元素肯定是最小的，因此就不需要将第二个元素和其比较了，第二趟之后第二个元素第一个和第二个元素就是最小的，都需要比较了 for(int j=a.length-1;j&gt;i;j--)&#123; //比较大小，较小的就上浮 if(a[j]&lt;a[j-1])&#123; //交换位置 int temp=a[j]; a[j]=a[j-1]; a[j-1]=temp; &#125; &#125; &#125;&#125; 从前向后比较(大的数字下沉) 第一趟：从第一个元素和第二个元素进行比较，较大的下沉(交换)，然后第二个元素和第三个元素比较，较大的下沉，直至倒数第二个和最后一个比较，大的下沉，那么此时的最后一个数就是最大的 第二趟： 从第一个元素和第二个元素进行比较，较大的下沉，然后第二个和第三个比较，直至倒数第三个和倒数第二个比较，大的下沉，那么此时的倒数第二个数是仅次于最后一个数小的元素。因为经过第一趟之后，最后一个元素已经是最大的，因此不需要比较了 第三趟： 经过第二趟之后，倒数第二个仅次于最后一个元素小的元素了，因此在第三趟中只需要比较到倒数第四个和倒数第三个元素的大小即可，大的下沉，那么此时的倒数第三个元素又是前面所有元素中最大的，因此在第四趟排序就不需要和其比较了。 第四趟…………………………………………………… 从上面我们可以得出结论： 假设有n个元素，那么总共需要进行n-1趟排序 实现1234567891011121314151617181920/** * 冒泡排序算法之从前向后比较排序 * @param a 需要排序的数组 */ public static void bubbleSort(int[] a) &#123; // 外层循环控制排序的趟数，总共需要n-1趟排序 for (int i = 0; i &lt; a.length - 1; i++) &#123; //内层循环控制每趟循环比较的次数，j=0表示从第一个元素开始进行比较，j&lt;a.length-1-i用来控制每趟循环之后不用再比较的元素索引 //比如第一趟循环之后，最后一个元素就是最大的，那么在第二趟循环就不需要和其比较了 for (int j = 0; j &lt; a.length - 1 - i; j++) &#123; //相邻的元素进行比较，如果前面的大于后面的就交换位置 if (a[j] &gt; a[j + 1]) &#123; int temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; &#125; &#125; &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JSON]]></title>
      <url>%2F2018%2F05%2F04%2FJSON%2F</url>
      <content type="text"><![CDATA[JSON定义 数据组织的一种方式 格式 key-value形式的组织 JSON对象 对象保存在{}中，并且以key-value的形式存储 其中的key必须是加上双引号，不能是单引号 {&quot;key1&quot;,value1,&quot;key2&quot;,value2,..........} 其中的value可以是任意类型的，比如整数，字符串等 {&quot;name&quot;:&quot;Jack&quot;,&quot;age&quot;:22}，这个是简单的对象 对象之中还可以嵌套（对象之中嵌套对象） 12345678910&#123; "name":"Jack", "age":22 "data":&#123; "name":"admin", "age":33, "telephone":"1235488", "password":"12345686" &#125;&#125; JSON数组 使用[]保存数组 独立的数组：[&quot;admin&quot;,&quot;Tom&quot;,&quot;JACk&quot;] 数组中包含对象 12345[ &#123;"name":"Jack","age":22&#125;, &#123;"name":"Tom","age":33&#125;, "date":"2012-12-12"] 在对象中也是可以包含JSON数组 123456789&#123; "employees": [ &#123; "firstName":"John" , "lastName":"Doe" &#125;, &#123; "firstName":"Anna" , "lastName":"Smith" &#125;, &#123; "firstName":"Peter" , "lastName":"Jones" &#125; ], "name":"JACK", "age":22&#125; 访问JSON对象 定义一个JSON对象并且获取 12345678910111213141516var obj = &#123; "name":"Jack", "age":22 "data":&#123; "name":"admin", "age":33, "telephone":"1235488", "password":"12345686" &#125;&#125;;var name=obj.name;var age=obj.age;var dataName=obj.data.name;var dataAge=obj.data.age; 访问JSON数组 定义并且访问 我们定义一个对象，其中包含一个JSON数组employees 123456789101112131415161718function testJSON()&#123; //定义一个对象，其中包含JSON数组employees var obj = &#123; "employees": [ &#123; "firstName":"John" , "lastName":"Doe" &#125;, &#123; "firstName":"Anna" , "lastName":"Smith" &#125;, &#123; "firstName":"Peter" , "lastName":"Jones" &#125; ], "name":"JACK", "age":22 &#125;; //遍历其中的JSON数组employees for(var i=0;i&lt;obj.employees.length;i++)&#123; console.log(obj.employees[i].firstName+"-----"+obj.employees[i].lastName); &#125; &#125; JSON.parse(str) 将字符串形式的JSON对象转换成为JSON对象，即是去掉引号 12345678var p='&#123;"name":"陈加兵","age":22&#125;'; //这个是json字符串//这样取值肯定不行，因为此时的p并不是JSON对象，而是一个字符串形式的JSON对象alert(p.name+"---&gt;"+p.age); var obj = JSON.parse(p); //将字符串形式的json对象转换成真正的JSON对象alert(obj.name + "---&gt;" + obj.age); //此时就可以取出其中的值了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript实现Ajax]]></title>
      <url>%2F2018%2F05%2F04%2Fjavascript%E5%AE%9E%E7%8E%B0Ajax%2F</url>
      <content type="text"><![CDATA[javascript实现Ajax定义 异步的javascript和XML，实现异步提交功能的技术(XMLHttpRequest) 不响应页面的前提下，服务器可以响应其中的一小部分数据到页面上 实现的步骤创建XMLHttpRequest 解决浏览器兼容问题 12345678910111213function getXHR()&#123; var xmlhttp; //判断当前浏览器是否识别XMLHttpRequest if (window.XMLHttpRequest) &#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); &#125; else &#123;// code for IE6, IE5 xmlhttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125; return xmlhttp; &#125; 打开1234//第一个参数：请求的方式//第二： 请求的url//第三个：是否为异步，true表示异步，false表示同步xhr.open("GET","Url",true); 发送请求1xhr.send(); 接收服务器响应数据 xhr.onreadystatechange : 表示从发送请求到响应请求的状态变化，根据状态的变化，处理数据5种状态 xhr.readyState ： 获取状态值 0 : 表示xhr对象创建，但是还未初始化 1 ：初始化完成，发送请求 2 ： 接收服务器的响应 3：解析服务器断响应的数据 4： 响应数据 xhr.status : 获取响应状态码 200 ：表示ok if(xhr.status==200) xhr.responseText : 获取文本数据 123456789//用于监听 xhr.onreadystatechange=function()&#123; //如果数据响应成功，并且状态码为200 if (xhr.readyState==4&amp;&amp;xhr.status==200) &#123; //处理数据 var text=xhr.responseText; //获取文本数据 &#125; &#125; 实例 请求本地的file.text文件 123456789101112131415161718192021222324252627function LoadText()&#123; var xhr; //判断当前浏览器是否识别XMLHttpRequest if (window.XMLHttpRequest) &#123;// code for IE7+, Firefox, Chrome, Opera, Safari xhr=new XMLHttpRequest(); &#125; else &#123;// code for IE6, IE5 xhr=new ActiveXObject("Microsoft.XMLHTTP"); &#125; //用于监听 xhr.onreadystatechange=function()&#123; //如果数据响应成功，并且状态码为200 if (xhr.readyState==4&amp;&amp;xhr.status==200) &#123; //处理数据 var text=xhr.responseText; //获取文本数据 alert(text); &#125; &#125; //异步请求 xhr.open("GET","file.text",true); xhr.send(); //发送请求&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mybatis配置事务管理器]]></title>
      <url>%2F2018%2F05%2F04%2FMybatis%E9%85%8D%E7%BD%AE%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%2F</url>
      <content type="text"><![CDATA[Mybatis配置事务管理器 数据库中的事务可以保证在连续执行的多条写操作(增删改)时，这多条操作要么成功，要么全部失败，以保证数据和逻辑的完整及严谨 在使用mybatis时，无需考虑事务如何创建，如何提交等，只需要配置好事务管理器 配置事务管理器(DataSourceTransactionManager) 在spring的配置文件中配置即可 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!-- 加载db.properties --&gt; &lt;util:properties id="dbConfig" location="classpath:db.properties" /&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;property name="url" value="#&#123;dbConfig.url&#125;" /&gt; &lt;property name="driverClassName" value="#&#123;dbConfig.driver&#125;" /&gt; &lt;property name="username" value="#&#123;dbConfig.user&#125;" /&gt; &lt;property name="password" value="#&#123;dbConfig.password&#125;" /&gt; &lt;property name="initialSize" value="#&#123;dbConfig.initSize&#125;" /&gt; &lt;property name="maxActive" value="#&#123;dbConfig.maxSize&#125;" /&gt; &lt;/bean&gt; &lt;!-- 配置MapperScannerConfigurer,自动扫描整个包，并且spring会自动创建UserMapper接口对象--&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 配置接口文件所在的包 --&gt; &lt;property name="basePackage" value="cn.tedu.spring.mapper" /&gt; &lt;/bean&gt; &lt;!-- 配置SqlSessionFactoryBean --&gt; &lt;bean class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 配置数据源：如何连接数据库等 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 配置XML文件的位置 --&gt; &lt;property name="mapperLocations" value="classpath:mappers/UserMapper.xml" /&gt; &lt;/bean&gt; &lt;!--配置事务管理器，需要用到前面配置的数据源datasource--&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; 开启事务注解 直接在spring配置文件中配置即可 12&lt;!-- 开启事务注解 ,transaction-manager指定的是上面配置的事务管理器的id--&gt;&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; 在需要使用事务的方法上添加@Transactional注解(或者是Service类上) 如果添加在类上，那么类中的全部方法都会被事务管理器管理 如果添加在方法上，那么只有这个方法会被管理 事务只发生在service的 在方法上添加注解 12345678910111213141516@Transactionalpublic void ChangePasssword(Integer id, String oldPassword, String newPassword) throws UserNotFoundException, PasswordNotMatchException&#123; User user=this.findUserById(id); //获取用户信息 if (user==null) &#123; //如果用户信息不存在 throw new UserNotFoundException("操作失败，用户信息不存在"); &#125;else &#123; //用户存在，则判断原密码 if (user.getPassword().equals(oldPassword)) &#123;//如果密码匹配 User user1=new User(); user1.setPassword(newPassword); userMapper.update(user1); &#125;else &#123; //原密码不匹配 throw new PasswordNotMatchException("操作失败，原密码不正确"); &#125; &#125;&#125; 在service类上添加@Transactional注解，那么类中的整个方法都会被管理 1234567@Service @Transactional //配置事务管理public class UserServiceImpl implements IUserService &#123; @Resource private UserMapper userMapper;&#125; 开启组件扫描 在spring-service.xml中开启组件扫描service即可 12&lt;!-- 组件扫描 --&gt;&lt;context:component-scan base-package="cn.tedu.spring.service" /&gt; 事务如何处理 在spring处理事务时，如果遇到RuntimeException就会自动回滚 完整的spring配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!-- 加载db.properties --&gt; &lt;util:properties id="dbConfig" location="classpath:db.properties" /&gt; &lt;!-- 数据源 --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;property name="url" value="#&#123;dbConfig.url&#125;" /&gt; &lt;property name="driverClassName" value="#&#123;dbConfig.driver&#125;" /&gt; &lt;property name="username" value="#&#123;dbConfig.user&#125;" /&gt; &lt;property name="password" value="#&#123;dbConfig.password&#125;" /&gt; &lt;property name="initialSize" value="#&#123;dbConfig.initSize&#125;" /&gt; &lt;property name="maxActive" value="#&#123;dbConfig.maxSize&#125;" /&gt; &lt;/bean&gt; &lt;!-- 配置MapperScannerConfigurer,自动扫描整个包，并且spring会自动创建UserMapper接口对象--&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 配置接口文件所在的包 --&gt; &lt;property name="basePackage" value="cn.tedu.spring.mapper" /&gt; &lt;/bean&gt; &lt;!-- 配置SqlSessionFactoryBean --&gt; &lt;bean class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 配置数据源：如何连接数据库等 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 配置XML文件的位置,其中的值是一个数组 --&gt; &lt;property name="mapperLocations"&gt; &lt;array&gt; &lt;value&gt;classpath:mappers/UserMapper.xml&lt;/value&gt; &lt;value&gt;classpath:mappers/DormitoryMapper.xml&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 配置数据源 --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 开启事务注解 ,transaction-manager指定的是上面配置的事务管理器的id--&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mybatis之多表查询]]></title>
      <url>%2F2018%2F05%2F04%2FMybatis%E4%B9%8B%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%2F</url>
      <content type="text"><![CDATA[Mybatis之多表查询一对一的查询(&lt;assocation&gt;)创建Java类 创建User类(用户类) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108public class User implements Serializable &#123; private static final long serialVersionUID = 6716332190979093860L; private Integer id; private String username; private String password; private Integer age; private Department department; //Department对象 public Department getDepartment() &#123; return department; &#125; public void setDepartment(Department department) &#123; this.department = department; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + ((age == null) ? 0 : age.hashCode()); result = prime * result + ((department == null) ? 0 : department.hashCode()); result = prime * result + ((id == null) ? 0 : id.hashCode()); result = prime * result + ((password == null) ? 0 : password.hashCode()); result = prime * result + ((username == null) ? 0 : username.hashCode()); return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; User other = (User) obj; if (age == null) &#123; if (other.age != null) return false; &#125; else if (!age.equals(other.age)) return false; if (department == null) &#123; if (other.department != null) return false; &#125; else if (!department.equals(other.department)) return false; if (id == null) &#123; if (other.id != null) return false; &#125; else if (!id.equals(other.id)) return false; if (password == null) &#123; if (other.password != null) return false; &#125; else if (!password.equals(other.password)) return false; if (username == null) &#123; if (other.username != null) return false; &#125; else if (!username.equals(other.username)) return false; return true; &#125; @Override public String toString() &#123; return "User [id=" + id + ", username=" + username + ", password=" + password + ", age=" + age + ", department=" + department + "]"; &#125;&#125; 创建Department类(部门类) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Department &#123; private Integer id; private String name; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + ((id == null) ? 0 : id.hashCode()); result = prime * result + ((name == null) ? 0 : name.hashCode()); return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Department other = (Department) obj; if (id == null) &#123; if (other.id != null) return false; &#125; else if (!id.equals(other.id)) return false; if (name == null) &#123; if (other.name != null) return false; &#125; else if (!name.equals(other.name)) return false; return true; &#125; @Override public String toString() &#123; return "Department [id=" + id + ", name=" + name + "]"; &#125;&#125; 分析 我们知道一个用户只能属于一个部门，因此这里在User类中只是使用了Department对象，而不是个集合 那么我们想要查询所有的用户信息和其所在的部门信息，此时的sql语句为:select * from user u left join department d on u.department_id=d.id;。但是我们在mybaits中如果使用这条语句查询，那么返回的结果类型是什么呢？如果是User类型的，那么查询结果返回的还有Department类型的数据，那么肯定会对应不上的。 我们可以使用resultMap解决对应问题 实现 使用resultMap解决查询结果的对应问题 这里一定要在resultMap将每一个字段和查询结果返回的字段对应上，否则此时的结果就为null 12345678910111213141516171819202122232425262728293031&lt;!-- 定义resultMap --&gt;&lt;resultMap type="cn.tedu.spring.entity.User" id="UserDepartment"&gt; &lt;!-- 配置id的对应 --&gt; &lt;id column="id" property="id"/&gt; &lt;!-- 配置其他字段的对应关系 column: 查询结果中的列名字，如果没有起别名，那么就是表中的字段名 property: java类中的属性名称 --&gt; &lt;result column="password" property="password"/&gt; &lt;result column="age" property="age"/&gt; &lt;result column="username" property="username"/&gt; &lt;!-- 配置对1的数据类型，即User类中的Department对象是单一的具体类型 property: 这个是在User类中的字段名称 javaType: 这个是java类的全名，是Department类的全名 --&gt; &lt;association property="department" javaType="cn.tedu.spring.entity.Department"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;/association&gt; &lt;/resultMap&gt;&lt;!-- User findUserAndDepartment(); resultMap: 指定上面resultMap的id的值 --&gt; &lt;select id="findUserAndDepartment" resultMap="UserDepartment"&gt; select * from user u left join department d on u.department_id=d.id &lt;/select&gt; 测试方法 123456789101112131415161718@Test public void testFindUserAndDepartment() &#123; //加载Spring的配置文件 AbstractApplicationContext ac = new ClassPathXmlApplicationContext( "spring-mvc.xml", "spring-dao.xml"); //获取UserMapper的bean，这个是spring通过扫描mapper.xml文件自动为mybatis自动创建的，首字母小写 UserMapper userMapper = ac.getBean( "userMapper", UserMapper.class); List&lt;User&gt; users=userMapper.findUserAndDepartment(); for (User user : users) &#123; System.out.println(user); &#125; ac.close(); &#125; 一对多的查询(&lt;collection&gt;) 一个宿舍可以住多个学生，那么我们通过宿舍查询学生，那么就是一对多查询 创建Java 创建Student类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class Student implements Serializable &#123; private static final long serialVersionUID = 8673238196042278929L; private Integer id; private String name; private Integer age; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + ((age == null) ? 0 : age.hashCode()); result = prime * result + ((id == null) ? 0 : id.hashCode()); result = prime * result + ((name == null) ? 0 : name.hashCode()); return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Student other = (Student) obj; if (age == null) &#123; if (other.age != null) return false; &#125; else if (!age.equals(other.age)) return false; if (id == null) &#123; if (other.id != null) return false; &#125; else if (!id.equals(other.id)) return false; if (name == null) &#123; if (other.name != null) return false; &#125; else if (!name.equals(other.name)) return false; return true; &#125; @Override public String toString() &#123; return "Student [id=" + id + ", name=" + name + ", age=" + age + "]"; &#125; &#125; 创建Dormitory类 其中有一个Set&lt;Student&gt;集合用来存储学生对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class Dormitory implements Serializable&#123; private static final long serialVersionUID = 1359749532219773083L; private Integer id; private String number; //编号 private Set&lt;Student&gt; students; //学生集合，一个宿舍可以住多个学生 public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getNumber() &#123; return number; &#125; public void setNumber(String number) &#123; this.number = number; &#125; public Set&lt;Student&gt; getStudents() &#123; return students; &#125; public void setStudents(Set&lt;Student&gt; students) &#123; this.students = students; &#125; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + ((id == null) ? 0 : id.hashCode()); result = prime * result + ((number == null) ? 0 : number.hashCode()); result = prime * result + ((students == null) ? 0 : students.hashCode()); return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Dormitory other = (Dormitory) obj; if (id == null) &#123; if (other.id != null) return false; &#125; else if (!id.equals(other.id)) return false; if (number == null) &#123; if (other.number != null) return false; &#125; else if (!number.equals(other.number)) return false; if (students == null) &#123; if (other.students != null) return false; &#125; else if (!students.equals(other.students)) return false; return true; &#125; @Override public String toString() &#123; return "Dormitory [id=" + id + ", number=" + number + ", students=" + students + "]"; &#125;&#125; 创建表 student 1create table student(id int primary key auto_increment,name varchar(10) not null unique,age int,dormitory_id int); dormitory 1create table dormitory(id int primary key auto_increment,number varchar(20) not null unique); 创建DormitoryMapper.java(接口)123456public interface DormitoryMapper &#123; //查询所有的宿舍信息 List&lt;Dormitory&gt; findDormitories(); //根据id查询宿舍信息 Dormitory findDormitory(Integer id);&#125; 创建DormitoryMapper.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//ibatis.apache.org//DTD Mapper 3.0//EN" "http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd"&gt;&lt;!-- MyBatis的接口映射文件，根节点是mapper --&gt;&lt;!-- 接口映射文件是与Java接口文件(interface)相对应的 --&gt;&lt;!-- 根节点的namespace属性用于指定Java接口文件 --&gt;&lt;mapper namespace="cn.tedu.spring.mapper.DormitoryMapper"&gt; &lt;!-- 定义resultMap --&gt; &lt;resultMap type="cn.tedu.spring.entity.Dormitory" id="DormitoryStudentRs"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="number" property="number"/&gt; &lt;!-- 因为Dormitoy中的Student使用set集合存储的，因此这里使用collection标签 property ： Java类中的集合对象 ofType： 集合对象的泛型类型 --&gt; &lt;collection property="students" ofType="cn.tedu.spring.entity.Student"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;result column="age" property="age"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- List&lt;Dormitory&gt; findDormitories(); 查询所有的宿舍信息 resultMap： 指定前面定义的resultMap --&gt; &lt;select id="findDormitories" resultMap="DormitoryStudentRs"&gt; select * from student s left join dormitory d on s.dormitory_id=d.id &lt;/select&gt; &lt;!-- Dormitory findDormitory(Integer id); --&gt; &lt;select id="findDormitory" resultType="cn.tedu.spring.entity.Dormitory"&gt; select * from dormitory where id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 在spring配置文件中添加DormitoryMapper.xml文件12345678910111213&lt;!-- 配置SqlSessionFactoryBean --&gt;&lt;bean class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 配置数据源：如何连接数据库等 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 配置XML文件的位置,其中的值是一个数组 --&gt; &lt;property name="mapperLocations"&gt; &lt;array&gt; &lt;value&gt;classpath:mappers/UserMapper.xml&lt;/value&gt; &lt;value&gt;classpath:mappers/DormitoryMapper.xml&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 测试123456789101112131415161718@Testpublic void testFindDormitory() &#123; //加载Spring的配置文件 AbstractApplicationContext ac = new ClassPathXmlApplicationContext( "spring-mvc.xml", "spring-dao.xml"); //获取DormitoryMapper对象 DormitoryMapper dormitoryMapper=ac.getBean("dormitoryMapper",DormitoryMapper.class); //执行查询方法 List&lt;Dormitory&gt; dormitories=dormitoryMapper.findDormitories(); for (Dormitory dormitory : dormitories) &#123; System.out.println(dormitory); &#125; ac.close();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mybatis之ResultMap]]></title>
      <url>%2F2018%2F05%2F04%2FMybatis%E4%B9%8BResultMap%2F</url>
      <content type="text"><![CDATA[Mybatis之ResultMap实体类 通常实体类中的属性要和数据库表中的字段一致，包括类型，字段名称 因此我们在单表查询的时候不需要使用&lt;resultMap&gt;指定实体类和表中的字段对应关系，但是如果我们在查询的时候使用了别名，或者属性字段和表的字段不一致，那么我们就需要用&lt;resultMap&gt;指定对应关系了 准备 创建一个User类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class User implements Serializable &#123; private static final long serialVersionUID = 6716332190979093860L; private Integer id; private String username; private String password; private Integer age; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return "User [id=" + id + ", username=" + username + ", password=" + password + ", age=" + age + "]"; &#125; &#125; 创建user表 表中的字段和User实体类一致 1create table user(id int primary key auto_increment,username varchar(20),age int ,password varchar(20)); 根据id查询用户信息(使用resultType指定结果类型) 直接在UserMapper.xml中配置&lt;select&gt;即可 使用resultType指定返回的结果类型 1234567&lt;!-- User findUserById(Integer id); resultType: 指定返回的结果类型 --&gt; &lt;select id="findUserById" resultType="cn.tedu.spring.entity.User"&gt; select username,password,age,id from user where id=#&#123;id&#125; &lt;/select&gt; 上面的查询返回的结果字段和User实体类中的属性字段一致，因此只需要指定resultType即可对应。但是如果我们查询的语句如下： 1234567&lt;!-- User findUserById(Integer id); resultType: 指定返回的结果类型 --&gt; &lt;select id="findUserById" resultType="cn.tedu.spring.entity.User"&gt; select username name,password pw,age,id from user where id=#&#123;id&#125; &lt;/select&gt; 那么此时返回的结果中，User类中的username，password值为null，因为没有对应上，这里使用了别名 使用resultMap解决别名或者字段不对应的问题 如果实体类中的字段和表中的字段一致，但是查询结果中使用了别名，那么需要使用&lt;resultMap&gt;来设置对应关系 如果实体类中的字段和表中的字段不一致，那么返回的查询结果即使不使用别名也会不对应，因此此时还是需要使用&lt;resultMap&gt;来设置对应关系 1234567891011121314151617181920212223&lt;!-- 指定resultMap type: 指定java类的全名 id： 唯一标识 --&gt; &lt;resultMap type="cn.tedu.spring.entity.User" id="UserMap"&gt; &lt;!-- id指定主键的对应关系，这里主键没有使用别名，因此不需要指定对应关系，可以自动对应上 &lt;id column="id" property="id"/&gt; --&gt; &lt;!-- result ： 指定主键之外的属性 column: 查询结果中的字段 property：java类中的对应属性 --&gt; &lt;result column="name" property="username"/&gt; &lt;result column="pw" property="password"/&gt; &lt;/resultMap&gt; &lt;!-- User findUserById(Integer id); resultMap: 指定返回的结果类型为前面定义的resultMap --&gt; &lt;select id="findUserById" resultMap="UserMap"&gt; select username name,password pw,age,id from user where id=#&#123;id&#125; &lt;/select&gt; 测试方法 123456789101112131415161718@Testpublic void testFinduserById() &#123; //加载Spring的配置文件 AbstractApplicationContext ac = new ClassPathXmlApplicationContext( "spring-mvc.xml", "spring-dao.xml"); //获取UserMapper的bean，这个是spring通过扫描mapper.xml文件自动为mybatis自动创建的，首字母小写 UserMapper userMapper = ac.getBean( "userMapper", UserMapper.class); User user=userMapper.findUserById(3); System.out.println(user); ac.close();&#125; 使用&lt;resultMap&gt;来解决多表之间的查询 后面的多表关联查询会讲到 总结 实体类中的属性是和表中的属性一致的，普通的java类或许不相同 如果查询返回的结果字段和java类中的属性字段一致，那么就不需要使用resultMap,而是能够自动的对应上 如果返回查询结果字段和java类中的属性字段不一致，那么就需要使用resultMap来设置对应关系了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MyBatis之动态sql]]></title>
      <url>%2F2018%2F05%2F04%2F%E5%8A%A8%E6%80%81sql%2F</url>
      <content type="text"><![CDATA[动态sqlif子句格式 &lt;if test=&quot;&quot;&gt; test中填写的是判断条件 实例更新密码或者年龄 首先在UserMapper.java中添加抽象方法 因为要一个方法兼具更新密码或者更新年龄的功能，那么我们直接使用一个实体类对象作为方法参数即可 123456/** * 更新数据，比如密码或者年龄 * @param user User对象，其中封装了用户密码或者用户的年龄 * @return 受影响的行数，成功返回1，否则返回0 */Integer update(User user); 在UserMapper.xml中配置&lt;update&gt;节点 只能修改密码或者年龄，不能同时修改，因为如果同时修改拼接而成的sql语句将会少了一个逗号, 1234567891011&lt;update id="update" parameterType="cn.tedu.spring.entity.User"&gt; update user set &lt;if test="password!=null"&gt; password=#&#123;password&#125; &lt;/if&gt; &lt;if test="age!=null"&gt; age=#&#123;age&#125; &lt;/if&gt; where id=#&#123;id&#125;&lt;/update&gt; 测试 修改年龄age，因此只需要在新建的User对象中添加age的值即可，那么此时password的值不能设置 同时要设置id的值 1234567891011121314151617181920@Testpublic void testUpdate() &#123; //加载Spring的配置文件 AbstractApplicationContext ac = new ClassPathXmlApplicationContext( "spring-mvc.xml", "spring-dao.xml"); //获取UserMapper的bean，这个是spring通过扫描mapper.xml文件自动为mybatis自动创建的，首字母小写 UserMapper userMapper = ac.getBean( "userMapper", UserMapper.class); //新建一个User对象 User user=new User(); user.setId(3); //设置id user.setAge(33); //设置年龄 int affectRows=userMapper.update(user); System.out.println(affectRows); ac.close();&#125; 根据用户名或者用户id查询信息 在UserMpper.java中添加接口方法 123456/** * 查找用户信息，根据用户名或者用户id查询 * @param user User对象，其中封装了用户名或者用户id * @return 用户对象 */User findUser(User user); 在UserMapper.xml中配置 12345678910111213141516&lt;!-- User findUser(User user); 不能同时查询，缺少连接符号 and or --&gt; &lt;select id="findUser" parameterType="cn.tedu.spring.entity.User" resultType="cn.tedu.spring.entity.User"&gt; select * from user where &lt;if test="id!=null"&gt; id=#&#123;id&#125; &lt;/if&gt; &lt;if test="username!=null"&gt; username=#&#123;username&#125; &lt;/if&gt; &lt;/select&gt; 测试方法 12345678910111213141516171819@Test public void testFind() &#123; //加载Spring的配置文件 AbstractApplicationContext ac = new ClassPathXmlApplicationContext( "spring-mvc.xml", "spring-dao.xml"); //获取UserMapper的bean，这个是spring通过扫描mapper.xml文件自动为mybatis自动创建的，首字母小写 UserMapper userMapper = ac.getBean( "userMapper", UserMapper.class); //新建一个User对象 User user=new User(); user.setId(3); //设置id //根据id查找 System.out.println(userMapper.findUser(user)); ac.close(); &#125; choose【了解】 相当于java中的switch，通常与when搭配使用 123456789101112&lt;select&gt; select * from user where &lt;choose&gt; &lt;when test="password!=null"&gt; password=#&#123;password&#125; &lt;/when&gt; &lt;otherwise&gt; id=#&#123;id&#125; &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; where元素问题 我们使用动态sql语句构建的语句如下 123456789101112&lt;select id="findUser" parameterType="cn.tedu.spring.entity.User" resultType="cn.tedu.spring.entity.User" &gt; select * from user where &lt;if test="password!=null"&gt; password=#&#123;password&#125; &lt;/if&gt; &lt;if test="username!=null"&gt; and username=#&#123;username&#125; &lt;/if&gt; &lt;/select&gt; 如果传入的参数User对象中只是设置了username的值，那么此时的sql语句将会变成select * from user where and username=#{username},很明显多了一个and 作用 &lt;where&gt;标签主要是用于简化where子句的编写，&lt;where&gt;可以替代sql语句中的where，而且还可以将后面多余的and或者or去掉 格式1234select 字段 from 表名 &lt;where&gt; ..... &lt;/where&gt; 解决问题 我们使用&lt;where&gt;标签解决上面的问题 12345678910111213&lt;select id="findUser" parameterType="cn.tedu.spring.entity.User" resultType="cn.tedu.spring.entity.User" &gt; select * from user &lt;where&gt; &lt;if test="password!=null"&gt; and password=#&#123;password&#125; &lt;/if&gt; &lt;if test="username!=null"&gt; and username=#&#123;username&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 如果此时在User对象中只是设置了一个username的值，那么会去掉前面的and关键字，并且此时的sql语句会变成：select * from user where username=#{username} set元素问题 我们使用动态sql构建一个更新语句，如下： 1234567891011121314151617&lt;update id="update" parameterType="cn.tedu.spring.entity.User"&gt; update user set &lt;if test="password!=null"&gt; password=#&#123;password&#125;, &lt;/if&gt; &lt;if test="age!=null"&gt; age=#&#123;age&#125;, &lt;/if&gt; &lt;if test="username!=null"&gt; username=#&#123;username&#125; &lt;/if&gt; where id=#&#123;id&#125; &lt;/update&gt; 从上面的&lt;update&gt;中可以看出，如果我们在User对象中没有设置password,age,username的值，那么构建出来的sql语句变成了update user set where id=#{id}，很明显是一个错误的语句。 如果在User对象中值设置了password的值，那么这里的sql语句变成了update user set password=#{password}, where id=#{id},很明显，这个sql多了一个逗号 解决 我们可以使用&lt;set&gt;,可以在&lt;set&gt;元素所在位置输出一个set关键字，而且可以去除内容结尾中无关的逗号，有了&lt;set&gt;元素，那么我们可以动态的修改字段 格式1234update table_name &lt;set&gt; ...... &lt;/set&gt; 实例 解决上面的问题 1234567891011121314151617&lt;update id="update" parameterType="cn.tedu.spring.entity.User"&gt; update user &lt;set&gt; &lt;if test="password!=null"&gt; password=#&#123;password&#125;, &lt;/if&gt; &lt;if test="age!=null"&gt; age=#&#123;age&#125;, &lt;/if&gt; &lt;if test="username!=null"&gt; username=#&#123;username&#125; &lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125; &lt;/update&gt; where 元素作用 使用动态sql可以解决SQL语句中代码复用问题，即2处或者多处高度相似的代码，在使用动态SQL之后，1个方法和1个映射就可以解决 总结 虽然在动态sql中，有很多标签可以实现对SQL语句的编程，但是，使用动态SQL的原则应该是希望代码复用，而不是编程，更不要用动态sql解决业务方法的问题]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MyBatis入门程序]]></title>
      <url>%2F2018%2F05%2F04%2FMyBatis%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[MyBatis入门程序设计案例实现向tedu_ums数据库的t_users数据表中插入数据。 开发步骤1 创建项目DAY07-MyBatis-Sample，生成web.xml，在web.xml中配置（2项），添加spring-webmvc依赖，复制Spring配置文件，添加Tomcat运行环境； 2 添加新的依赖：mybatis、mybatis-spring、spring-jdbc： 123456789101112131415161718&lt;!-- Spring-JDBC --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;3.2.8.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 以上依赖中，spring-jdbc的版本需与spring-webmvc保持一致！（同一个项目中，以spring-作为前缀的依赖都应该使用相同版本） 3 创建实现类cn.tedu.spring.entity.User，在该类中声明Integer id、String username、String password属性，及相关方法； 4 设计持久层接口：创建cn.tedu.spring.mapper.UserMapper接口，并在接口中添加抽象方法： 1Integer reg(User user); 注意：增删改操作固定返回受影响的行数，在设计方法时，可以将返回值声明为Integer类型，或使用void表示无返回值也可以。 5 从FTP下载mybatis.zip文件，将解压得到的EmpMapper.xml重命名为UserMapper.xml（推荐这样命名），然后在项目的src\main\resource新建文件夹mappers，将UserMapper.xml复制到mappers文件夹中； 6 编辑UserMapper.xml文件： ​ 123456789101112131415161718192021&lt;!-- MyBatis的接口映射文件，根节点是mapper --&gt;&lt;!-- 接口映射文件是与Java接口文件(interface)相对应的 --&gt;&lt;!-- 根节点的namespace属性用于指定Java接口文件 --&gt;&lt;mapper namespace="cn.tedu.spring.mapper.UserMapper"&gt; &lt;!-- 节点名称取决于需要执行的操作 --&gt; &lt;!-- 例如增加操作应该使用insert节点 --&gt; &lt;!-- id属性(*)的值是Java接口中的方法名称 --&gt; &lt;!-- parameterType属性的值是参数类型 --&gt; &lt;!-- 节点中间编写SQL语句 --&gt; &lt;insert id="reg" parameterType="cn.tedu.spring.entity.User"&gt; INSERT INTO t_users ( username, password ) VALUES ( #&#123;username&#125;, #&#123;password&#125; ) &lt;/insert&gt; &lt;/mapper&gt; 7 添加依赖：mysql-connector-xxxx、dbcp、junit； 8 在src\main\resources下配置db.properties； 9 从此前的项目中复制spring-dao.xml，在该配置文件中，至少配置了：加载db.properties、BasicDataSource 10 在spring-dao.xml中，配置： 12345678910111213141516&lt;!-- 配置MapperScannerConfigurer ，扫描mapper的配置在哪里--&gt;&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 配置接口文件所在的包 --&gt; &lt;property name="basePackage" value="cn.tedu.spring.mapper" /&gt;&lt;/bean&gt;&lt;!-- 配置SqlSessionFactoryBean --&gt;&lt;bean class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 配置数据源：如何连接数据库等 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 配置XML文件的位置 --&gt; &lt;property name="mapperLocations" value="classpath:mappers/UserMapper.xml" /&gt;&lt;/bean&gt; 11 编写测试类，添加测试方法： 123456789101112131415161718192021@Testpublic void testReg() &#123; AbstractApplicationContext ac = new ClassPathXmlApplicationContext( "spring-mvc.xml", "spring-dao.xml"); UserMapper userMapper = ac.getBean( "userMapper", UserMapper.class); User user = new User(); user.setUsername("Tom1"); user.setPassword("123456"); Integer affectedRows = userMapper.reg(user); System.out.println( "affectedRows=" + affectedRows); ac.close();&#125; 总结 在spring中配置mybatis的步骤： 配置扫描xxmapper.xml的MapperScannerConfigurer 配置SqlSessionFactoryBean，需要用到数据库连接池的数据源datasource 完整的依赖文件pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;dependencies&gt; &lt;!-- SpringMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;3.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring-JDBC,要和spring-webmvc的版本一致 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;3.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MyBatis-Spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.28&lt;/version&gt; &lt;/dependency&gt; &lt;!-- DBCP --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 完整的db.properties文件 123456url=jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=utf8driver=com.mysql.jdbc.Driveruser=rootpassword=rootinitSize=5maxSize=10 完整的spring-dao.xml文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:jdbc="http://www.springframework.org/schema/jdbc" xmlns:jee="http://www.springframework.org/schema/jee" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:util="http://www.springframework.org/schema/util" xmlns:jpa="http://www.springframework.org/schema/data/jpa" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-3.2.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa-1.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.2.xsd"&gt; &lt;!-- 加载db.properties --&gt; &lt;util:properties id="dbConfig" location="classpath:db.properties" /&gt; &lt;!-- 数据源 --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;property name="url" value="#&#123;dbConfig.url&#125;" /&gt; &lt;property name="driverClassName" value="#&#123;dbConfig.driver&#125;" /&gt; &lt;property name="username" value="#&#123;dbConfig.user&#125;" /&gt; &lt;property name="password" value="#&#123;dbConfig.password&#125;" /&gt; &lt;property name="initialSize" value="#&#123;dbConfig.initSize&#125;" /&gt; &lt;property name="maxActive" value="#&#123;dbConfig.maxSize&#125;" /&gt; &lt;/bean&gt; &lt;!-- 配置MapperScannerConfigurer,自动扫描整个包，并且spring会自动创建UserMapper接口对象--&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 配置接口文件所在的包 --&gt; &lt;property name="basePackage" value="cn.tedu.spring.mapper" /&gt; &lt;/bean&gt; &lt;!-- 配置SqlSessionFactoryBean --&gt; &lt;bean class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 配置数据源：如何连接数据库等 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 配置XML文件的位置 --&gt; &lt;property name="mapperLocations" value="classpath:mappers/UserMapper.xml" /&gt; &lt;/bean&gt;&lt;/beans&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Springmvc响应Ajax请求(@ResponseBody)]]></title>
      <url>%2F2018%2F05%2F04%2FSpringmvc%E5%93%8D%E5%BA%94Ajax%E8%AF%B7%E6%B1%82-ResponseBody%2F</url>
      <content type="text"><![CDATA[Springmvc响应Ajax请求(@ResponseBody)创建工程 创建maven project 选择war包 自动生成web.xml Target Runtime 选择 Tomcat 添加依赖pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;dependencies&gt; &lt;!-- SpringMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;3.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring-JDBC,要和spring-webmvc的版本一致 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;3.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MyBatis-Spring 整合jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.28&lt;/version&gt; &lt;/dependency&gt; &lt;!-- DBCP --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 配置前端控制器和解决中乱码的过滤器(web.xml) 12345678910111213141516171819202122232425262728293031&lt;!--配置中文乱码的过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;!--配置前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!--加载spring配置文件--&gt; &lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 配置spring-mvc.xml 要想使用@ResponseBody这个注解来接收Ajax发送过来的请求，必须加上注解驱动&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; 123456789101112&lt;!-- 组件扫描 --&gt;&lt;context:component-scan base-package="cn.tedu.spring.controller" /&gt;&lt;!-- 配置ViewResolver --&gt;&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/web/" /&gt; &lt;property name="suffix" value=".jsp" /&gt;&lt;/bean&gt;&lt;!-- 配置注解扫描，用于ajax的注解扫描 --&gt;&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; 编写前端表单 其实并不是使用表单提交的，可以不使用表单 12345&lt;form action="" method="post"&gt; 姓名： &lt;input type="text" name="name" id="name" onblur="checkName()"&gt;&lt;span id="nameSpan"&gt;&lt;/span&gt;&lt;br&gt; 密码:&lt;input type="password" name="pwd" id="pwd"&gt;&lt;span id="pwSpan"&gt;&lt;/span&gt;&lt;br&gt; &lt;input type="submit" value="注册"&gt;&lt;/form&gt; 效果和实现(@RequestBody)用户名文本框失去焦点，异步检测用户 用户名文本框失去焦点发生请求处理方法，检测用户名 请求方式POST 返回的值不再是视图的名称，而是处理请求的结果，即使返回给Ajax请求的数据 12345678@RequestMapping("/checkName.do")@ResponseBody //使用@ResponseBody，表示这个是处理ajax的请求public String checkName(@RequestParam("name")String name)&#123; if ("admin".equals(name)) &#123; return "0"; //表示admin这个用户名不能使用，已经存在 &#125; return "1"; //表示此时的用户名不存在，可以使用&#125; 前端编写Ajax请求（JQUERY） 使用JQuery中的Ajax请求 12345678910111213141516171819202122232425262728&lt;!-- 添加jquery文件 --&gt;&lt;script type="text/javascript" src="&lt;%=request.getContextPath() %&gt;/web/jquery-3.2.1.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; function checkName()&#123; var name=$("#name").val(); //获取用户名 if(name=="")&#123; alert("用户名不能为空"); return; &#125; var url="&lt;%=request.getContextPath()%&gt;/user/checkName.do"; // 请求的url $.post(url,&#123;'name':name&#125;,function(responseData,status,xhr)&#123; //如果状态码正确 if(status=="success")&#123; if(responseData=="0")&#123; //为节点添加提示内容 $("#nameSpan").text("用户名已经存在，请重新输入"); $("#nameSpan").css("color","red"); //设置颜色为红色 &#125;else&#123; $("#nameSpan").text("用户名不存在，可以使用"); $("#nameSpan").css("color","green"); &#125; &#125; &#125;) &#125;`&lt;/script&gt; 使用javascript发出Ajax请求 GET请求 ：xhr.open(&quot;GET&quot;,&quot;&lt;%=request.getContextPath()%&gt;/user/checkName.do?name=&quot;+name,true); POST请求需要将数据封装到xhr.send(data)中 12345678910111213141516171819202122232425262728//使用POST请求function checkNameFun()&#123; var xhr=getXHR(); //获取XHR //监听状态改变 xhr.onreadystatechange=function()&#123; if(xhr.readyState==4&amp;&amp;xhr.status==200)&#123; var text=xhr.responseText; //获取返回的数据 if(Text=="0")&#123; alert("用户名已经存在，请重新输入"); &#125;else&#123; alert("用户名不存在，可以使用"); &#125; &#125; &#125; var name=$("#name").val(); //获取name文本框中的值 if(name=="")&#123; alert("用户名不能为空"); return; &#125; //编写请求 xhr.open("POST","&lt;%=request.getContextPath()%&gt;/user/checkName.do",true); //在open之后，send之前添加请求头信息 xhr.setRequestHeader("content-type","application/x-www-form-urlencoded"); //在send之中添加请求信息 xhr.send("name="+name); //发送请求&#125; @ResponseBody 配置注解驱动支持该注解的使用，直接在spring-mvc.xml中配置即可&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; 添加jackson的依赖，处理json数据 我们需要三个jar包，我们只需要添加jackson-databind即可，就会自动的导入其他的两个 ​ 123456&lt;!-- 添加jackson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.4&lt;/version&gt; &lt;/dependency&gt; 用于响应Ajax请求 使用@ResponseBody标记的Controller方法的返回值，不再是返回的视图名称,而是返回的给Ajax的请求结果，可以是String，List,Map,单个对象等 返回单个值 返回的单个值，比如String，int，boolean 直接使用上面的例子即可 12345678@RequestMapping("/checkName.do")@ResponseBody //使用@ResponseBody，表示这个是处理ajax的请求public String checkName(@RequestParam("name")String name)&#123; if ("admin".equals(name)) &#123; return "0"; //表示admin这个用户名不能使用，已经存在 &#125; return "1"; //表示此时的用户名不存在，可以使用&#125; 返回Map 这里我们返回的是一个Map&lt;String,Object&gt; 使用了JackSon，spring会将Map自动转换成JSON对象，那么我们在JSP中就可以用JSON来获取数据即可 编写Controller方法，使用@ResponseBody注解 12345678910111213141516171819@RequestMapping("/testMap.do")@ResponseBody //使用注解public Map&lt;String,Object&gt; testMap(@RequestParam("name")String name,@RequestParam("age")Integer age)&#123; System.out.println(name+"---"+age); //接收请求参数 Map&lt;String, Object&gt; map=new HashMap&lt;String, Object&gt;(); //新建一个Map //新建User对象 User user1=new User(); user1.setName("JACK"); user1.setAge(22); User user2=new User(); user2.setAge(33); user2.setName("Tom"); //将上面的User对象添加到map中 map.put("u1",user1); map.put("u2",user2); return map;&#125; 在jsp页面中添加一个方法，用于发出Ajax请求 使用返回的数据(JSON对象)，直接使用data.key的形式即可取出Map中的值 12345678910111213//Ajax请求testMap.dofunction testMap()&#123; var url="&lt;%=request.getContextPath()%&gt;/user/testMap.do"; // 请求的url var d=&#123;'name':'陈加兵','age':22&#125;; //需要发出请求的参数 $.post(url,d,function(responseData,status,xhr)&#123; //如果状态码正确 if(status=="success")&#123; var user1=responseData.u1; //取出key为u1的值，是一个user对象 var user2=responseData.u2; //取出key为u2的值，是一个user对象 alert("u1 = "+user1.name+"---"+user1.age); //打印出u1中的name，age的值 &#125; &#125;)&#125; 返回List 这里的返回值是List&lt;Object&gt; JackSon会自动将List转换成JSON数组，在JSP页面就可以使用JSON的方式来获取数据 比如：[{&quot;name&quot;:&quot;JACK&quot;,&quot;age&quot;:22},{&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:33},10]，这个是一个JSON数组的形式，因此我们在js中需要遍历这个数组 Controller中方法如下： 12345678910111213141516171819@RequestMapping("/testList.do")@ResponseBodypublic List&lt;User&gt; testList(@RequestParam("name") String name, @RequestParam("age") Integer age) &#123; System.out.println(name + "---" + age); // 接收请求参数 List&lt;User&gt; list = new ArrayList&lt;User&gt;(); // 新建User对象 User user1 = new User(); user1.setName("JACK"); user1.setAge(22); User user2 = new User(); user2.setAge(33); user2.setName("Tom"); //将数据添加到其中 list.add(user1); list.add(user2); return list;&#125; jsp中使用发出Ajax请求 此时返回的是数组，因此需要循环遍历 123456789101112131415//Ajax请求testList.dofunction testList()&#123; var url="&lt;%=request.getContextPath()%&gt;/user/testList.do"; // 请求的url var d=&#123;'name':'陈加兵','age':22&#125;; //需要发出请求的参数 $.post(url,d,function(responseData,status,xhr)&#123; //如果状态码正确 if(status=="success")&#123; //此时返回的是一个数组，因此我们需要循环遍历这个数组，但是其中的元素是一个User对象，因此可以使用key-value的形式取出其中的值 for(var i=0;i&lt;responseData.length;i++)&#123; //将数据输出到控制台 console.log(responseData[i].name+"-----&gt;" + responseData[i].age); &#125; &#125; &#125;)&#125; 返回单个对象 返回的是一个对象，比如一个User对象，JackSon会将其转换成为JSON对象返回给浏览器 返回的是对象，那么我们在js中可以直接使用key-value的形式取出其中的值 Controller中的方法 12345678910@RequestMapping("/testObject.do")@ResponseBodypublic User testObject(@RequestParam("name") String name, @RequestParam("age") Integer age) &#123; System.out.println(name + "---" + age); // 接收请求参数 User user=new User(); user.setName("JACK"); user.setAge(22); return user;&#125; 发出Ajax请求，并且接收数据 直接使用取值即可 1234567891011//Ajax请求testObject.dofunction testObject()&#123; var url="&lt;%=request.getContextPath()%&gt;/user/testObject.do"; // 请求的url var d=&#123;'name':'陈加兵','age':22&#125;; //需要发出请求的参数 $.post(url,d,function(responseData,status,xhr)&#123; //如果状态码正确 if(status=="success")&#123; console.log(responseData.name+"----"+responseData.age); &#125; &#125;)&#125; 练习省市二级菜单联动 前端使用下拉菜单&lt;select&gt;实现 加载页面完成之后，发送一个异步请求，请求所有的省份,在省的下拉菜单中显示出来 当用户选择了某个省之后，那么发送一个异步请求，获取当前省的所有市的信息，并且显示在市的下拉菜单中 在省的下拉菜单中需要使用onchange监听选项的改变，只要选项改变了就要发出异步请求，返回对应城市的信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869省：&lt;select name="province" id="province" onchange="getCity()"&gt; &lt;option value="-1"&gt;请选择省&lt;/option&gt;&lt;/select&gt;市：&lt;select name="city" id="city"&gt; &lt;option value="-1"&gt;请选择市&lt;/option&gt;&lt;/select&gt;&lt;!--加载jquery--&gt;&lt;script type="text/javascript" src="&lt;%=request.getContextPath() %&gt;/web/jquery-3.2.1.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; //只要页面加载完成之后就会执行其中的逻辑 $(function()&#123; getProvince(); //页面加载完成就调用这个方法发出异步请求 &#125;); //获取省份的方法 function getProvince()&#123; var url="&lt;%=request.getContextPath()%&gt;/menu/getProvince.do"; //异步请求的url var d=&#123;&#125;; //没有数据提交 $.post(url,d,function(data,status,xhr)&#123; if(status=="success")&#123; //循环遍历返回的JSON数组 for(var i=0;i&lt;data.length;i++)&#123; //创建option，用于插入节点 var option="&lt;option value=" + data[i].code + "&gt;"+data[i].name+"&lt;/option&gt;"; //将option插入到下拉列表中 $("#province").append(option); &#125; &#125; &#125;); &#125; //根据选择的省份获取市 function getCity()&#123; var province=$("#province").val(); //获取下拉菜单的值，这里返回的是省份的编号 var url="&lt;%=request.getContextPath()%&gt;/menu/getCity.do"; //异步请求的url var d=&#123;"province":province&#125;; //将省份的编号传入 //每次都要清空之前的城市 $("#city").html("&lt;option value='-1'&gt;请选择市&lt;/option&gt;"); //如果用户点击了请选择省，那么返回的值就是-1，此时不需要发出异步请求 if(province==-1)&#123; return; &#125; //发出异步请求 $.post(url,d,function(data,status,xhr)&#123; if(status=="success")&#123; //如果返回的是一个空的，直接返回即可，不需要后续的操作 if(data.lengt==0)&#123; return; &#125; //循环遍历返回的JSON数组 for(var i=0;i&lt;data.length;i++)&#123; //创建option，用于插入节点 var option="&lt;option value=" + data[i].code + "&gt;"+data[i].name+"&lt;/option&gt;"; //将option插入到下拉列表中 $("#city").append(option); &#125; &#125; &#125;); &#125;&lt;/script&gt; 在Controller编写方法 展示页面的方法(showMenu.do) 返回省份信息的方法 返回城市信息方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//显示页面@RequestMapping("/showMenu.do")public String showMenu() &#123; return "menu";&#125;//异步请求返回省份的信息@RequestMapping("/getProvince.do")@ResponseBodypublic List&lt;Province&gt; getProvince()&#123; Province p1=new Province(); p1.setName("江苏"); p1.setCode(1001); Province p2=new Province(); p2.setName("山东"); p2.setCode(1002); List&lt;Province&gt; provinces=new ArrayList&lt;Province&gt;(); provinces.add(p1); provinces.add(p2); return provinces;&#125;//异步获取城市信息的方法，这里没有操作数据库，仅仅是模拟，因此只要返回数据即可@RequestMapping("/getCity.do")@ResponseBodypublic List&lt;City&gt; getCity(@RequestParam("province") Integer code)&#123; System.out.println(code); List&lt;City&gt; cities=new ArrayList&lt;City&gt;(); /** * 如果这里涉及到数据库操作 * 1. 调用service的方法查询，service调用dao的方法查询 * 2. dao中的查询： 根据code查询出对应的城市即可，当然是联表查询 * 3. select c.name,c.code from city c join province p on c.provice_id=p.id; * 4. mybatis调用第三步的查询语句，直接返回的就是List&lt;City&gt;集合 */ //这里省略if的判断，主要是看效果 City c1=new City(); c1.setName("南京"); c1.setCode(123); City c2=new City(); c2.setName("淮安"); c2.setCode(1223); cities.add(c1); cities.add(c2); return cities; //返回集合&#125; 总结 springmvc会通过jackson将返回给ajax请求的对象自动封装成JSON对象，那么在JSP页面我们就可以使用JSON的读取方式获取返回的数据即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring配置DBCP连接池]]></title>
      <url>%2F2018%2F05%2F04%2FSpring%E9%85%8D%E7%BD%AEDBCP%E8%BF%9E%E6%8E%A5%E6%B1%A0%2F</url>
      <content type="text"><![CDATA[Spring配置DBCP连接池建立数据库配置文件jdbc.properties 在resource文件下新建一个jdbc.properties文件，内容如下 在每一个键值对的后面不可以有空格，将光标移动到后面，如果紧贴着即可 ​ 123456url=jdbc:mysql://localhost:3306/tedu_ums?useUnicode=true&amp;characterEncoding=utf8driver=com.mysql.jdbc.Driveruser=rootpassword=rootinitSize=5 maxSize=10 在spring配置文件中配置DBCP数据源 直接使用spring的表达式获取文件中的值即可 ​ 12345678910111213141516171819202122&lt;!-- 加载db.properties --&gt; &lt;util:properties id="dbConfig" location="classpath:jdbc.properties" /&gt; &lt;!-- 数据源 --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;property name="url" value="#&#123;dbConfig.url&#125;" /&gt; &lt;property name="driverClassName" value="#&#123;dbConfig.driver&#125;" /&gt; &lt;property name="username" value="#&#123;dbConfig.user&#125;" /&gt; &lt;property name="password" value="#&#123;dbConfig.password&#125;" /&gt; &lt;!--初始化链接数量--&gt; &lt;property name="initialSize" value="#&#123;dbConfig.initSize&#125;" /&gt; &lt;!--最大链接数量--&gt; &lt;property name="maxActive" value="#&#123;dbConfig.maxSize&#125;" /&gt; &lt;/bean&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Springmvc处理异常]]></title>
      <url>%2F2018%2F05%2F04%2FSpringmvc%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%2F</url>
      <content type="text"><![CDATA[Spring MVC处理异常关于异常 异常的体系结构： 12345678910111213Throwable Error OutOfMemoryError（OOM） Exception RuntimeException NullPointerException：某个为null的对象调用了属性或方法 ClassCastException：强制转换为不匹配的数据类型 ClassNotFoundException：尝试加载的类不存在 IndexOutOfBoundsException：使用List集合时使用了越界的索引 ArrayIndexOutOfBoundsException：使用Array时使用了越界的索引 SQLException：数据库相关异常 IOException：输入输出（读写）异常 FileNotFoundException：文件找不到 在Spring MVC中处理异常 在Spring MVC中，提供了一种统一处理某种异常的机制，例如通过配置，可以对整个项目中的NullPointerException进行处理，那么，无论是项目的哪个环节出现该异常，都会自动按照配置的方式进行处理，而不用每个方法中逐一编写相关代码。 准备演示案例 创建项目DAY07-SpringMVC-Exception，设计请求路径： http://SERVER:PORT/PROJECT/ex1.do http://SERVER:PORT/PROJECT/ex2.do 以上3个请求将分别由ex1.jsp、ex2.jsp页面显示。 使用SimpleMappingExceptionResolver 在Spring MVC中，有SimpleMappingExceptionResolver类，用于配置异常与View组件的映射关系，如果确定某种异常出现后都会显示某个View组件，则在Spring的配置文件中： 12345678910&lt;bean class="xx.xx.SimpleMappingExceptionResolver"&gt; &lt;property name="exceptionMappings"&gt; &lt;props&gt; &lt;prop key="异常类的全名"&gt;View组件名&lt;/prop&gt; &lt;prop key="异常类的全名"&gt;View组件名&lt;/prop&gt; &lt;prop key="异常类的全名"&gt;View组件名&lt;/prop&gt; &lt;props&gt; &lt;/property&gt;&lt;/bean&gt; 经过以上配置后，整个项目运行到任何位置，一旦出现以上配置过的异常，都会转发到匹配的View组件，在项目的各个方法中，不必再处理已经配置过的异常！ 这种做法的不足在于：只要是同一种异常，都是转发到同一个View组件，无法根据实际运行状态进行更加细化的处理，例如无法提示是哪个值错误或者某些原因导致的异常。 使用@ExceptionHandler注意：使用SimpleMappingExceptionResolver处理异常时，不可以使用@ExceptionHandler！ 当需要统一处理异常时，可以在控制器类中自定义方法（方法名称自定义），并在方法上方添加@ExceptionHandler，与处理请求的方法类似，可以按需添加方法的参数，需要注意的，必须有Exception参数： 1234567891011121314@ExceptionHandlerpublic String handleException( HttpServletRequest request, Exception ex) &#123; System.out.println(ex.getClass()); if (ex instanceof NullPointerException) &#123; return "error1"; &#125; else if (ex instanceof ArrayIndexOutOfBoundsException) &#123; return "error2"; &#125; else &#123; return "error3"; &#125;&#125; 这种做法，是作用于当前控制器类内部的所有请求的处理！对其它控制器类中的异常是没有影响的！ Spring MVC小结 解决MVC中V与C的关系的，即如何接收请求并响应； 在Spring的配置文件中，最主要的配置是组件扫描和ViewResolver； 重点掌握@RequestMapping注解，还有@RequestParam注解； 掌握在处理请求时，如何获取请求参数（2种）和封装转发数据（ModelMap）； 理解转发和重定向； 学会使用Interceptor； 学会处理异常。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MVC处理异常]]></title>
      <url>%2F2018%2F05%2F04%2FMVC%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[Springmvc之向JSP页面提供数据(request，session)]]></title>
      <url>%2F2018%2F04%2F26%2FSpringmvc%E4%B9%8B%E5%90%91JSP%E9%A1%B5%E9%9D%A2%E6%8F%90%E4%BE%9B%E6%95%B0%E6%8D%AE-request%EF%BC%8Csession%2F</url>
      <content type="text"><![CDATA[Springmvc之向JSP页面提供数据(request，session)准备 Springmvc默认就是转发,因此可以在request域中共享数据 表单提交，注册 123456&lt;form action="&lt;%=request.getContextPath()%&gt;/user/login.do" method="post"&gt; username:&lt;input type="text" name="username"&gt; &lt;br&gt; password:&lt;input type="text" name="password"&gt; &lt;br&gt; age:&lt;input type="text" name="age"&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; User类 12345678910111213141516171819202122232425262728public class User &#123; private String username; private String password; int age; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return "User [username=" + username + ", password=" + password + "]"; &#125;&#125; 使用HttpServletRequest转发 直接使用HttpServletRequest中的setAttribute(key,value)即可添加属性值request域中，那么在JSP页面即可使用EL表达式获取 12345678910/** * @param user 接收请求参数 * @param request 添加属性值request域中 */@RequestMapping(value = "/login.do")public String login(User user,HttpServletRequest request,HttpServletResponse response) &#123; System.out.println(user); request.setAttribute("user", user); return "error";&#125; 【不常用】使用ModelAndView转发 ModelAndView中本身就是用来存储数据和视图的，因此我们可以使用ModelAndView来传值 ModelAndView会利用HttpServletRequest中的setAttribute(key,value)将数据存储在requst域中 Model表示的就是转发的数据，可以通过ModelAndView(String viewName,Map&lt;String,?&gt; map)构造方法封装Model，其中Model的类型就是Map&lt;String,?&gt; 12345678910@RequestMapping(value = "/login.do")public ModelAndView login(User user) &#123; System.out.println(user); //创建一个Map，存储数据 Map&lt;String, User&gt; map=new HashMap&lt;String, User&gt;(); //将获取的user对象存储进去 map.put("user", user); //返回一个ModelAndView对象，第一个参数是视图，第二个是Map存储数据 return new ModelAndView("error", map);&#125; 【推荐使用】使用ModelMap转发 利用HttpServletRequest中的setAtttibute()添加数据到request域中 直接在处理请求的方法中，添加ModelMap类型的参数，当需要转发数据时，调用它的addAttribute方法封装数据，如果需要封装多条，多次调用即可 1234567@RequestMapping(value = "/login.do")public String login(User user,ModelMap map) &#123; System.out.println(user); //将数据存储在ModelMap中 map.addAttribute("user", user); return "error";&#125; 拓展 从源代码可以看出，ModelMap实际上是实现了Map接口，因此我们也可以直接使用Map传值 直接在方法的参数中声明即可，spring会自动注入 1234567@RequestMapping(value = "/login.do")public String login(User user,Map&lt;String, Object&gt; map) &#123; System.out.println(user); //将数据存储在ModelMap中 map.put("user", user); return "error";&#125; Session 浏览器关闭或者在session的指定时间内没有操作，那么session会自动关闭 通常会把访问的用户的唯一标识（用户的ID或用户名，邮箱等）和使用频率使用较高的数据（用户名，昵称，头像）存储在Session中。 使用HttpSession123456@RequestMapping(value = "/login.do")public String login(User user,HttpSession session) &#123; //将id存储在session中 session.setAttribute("uid", "9527"); return "error";&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Springmvc之接受请求参数]]></title>
      <url>%2F2018%2F04%2F26%2FSpringmvc%E4%B9%8B%E6%8E%A5%E5%8F%97%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%2F</url>
      <content type="text"><![CDATA[Springmvc之接受请求参数准备工作 新建一个表单提交 请求地址： http://localhost:8080/ProjectName/user/login.do 123456&lt;form action="&lt;%=request.getContextPath()%&gt;/user/login.do" method="post"&gt; username:&lt;input type="text" name="username"&gt; &lt;br&gt; password:&lt;input type="text" name="password"&gt; &lt;br&gt; age:&lt;input type="text" name="age"&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; 【不推荐】HttpServletRequest 直接使用HttpServeletRequest作为方法参数，spring会自动为其注入 需要手动转换参数的类型 12345678@RequestMapping(value="/login.do")public String login(HttpServletRequest request,HttpServletResponse response)&#123; String username=request.getParameter("username"); String password=request.getParameter("password"); int age=Integer.parseInt(request.getParameter("age")); //转换类型 System.out.println(username+"---&gt;"+password); return "success";&#125; 直接在方法中声明对应的参数(name的属性必须和方法参数一致) 表单中的name属性要和方法中的参数一致 涉及到类型转换，直接在方法中申明不同类型的参数即可 优点： 方便，并且可以使Springmvc自动处理数据类型 12345@RequestMapping(value = "/login.do")public String login(String username,String password,Integer age) &#123; System.out.println(username + "---&gt;" + password+"-----&gt;"+age); return "success";&#125; 【推荐】@RequestParam 使用该注解可以获取请求参数，方法中的参数可以与表单中的name属性不一致 使用@RequestParam这个获取的值必须包含在请求参数中，否则报错，除非设置required属性为false 1234567891011/** * 使用@RequestParam获取请求参数 * @RequestParam()中的value属性为form表单中对应的name属性 * 自动转换数据类型，只需要定义方法参数为所需的数据类型即可，spring会为我们自动转换 */@RequestMapping(value = "/login.do")public String login(@RequestParam(value = "username") String name, @RequestParam("password") String pwd,@RequestParam("age") Integer age) &#123; System.out.println(name + "---&gt;" + pwd+"-----&gt;"+age); return "success";&#125; 属性 value 指定请求中对应的属性名称，这个就像表单中定义的name属性 required指定是否这个参数必须包含在请求地址中，默认是true，即是如果不包含这个参数那么就会报错。 defaultValue 指定默认的值，如果设置了required=false，并且没有设置这个值，那么默认的是null，但是也是可以使用这个属性来设置参数默认的值。当然对于设置了int类型的参数，那么并没有指定其值，那么将会报错，因为int类型没有null，只有Integer类型的才有，因此需要设置成Integer 123456789101112/* * 这里的获取请求参数中的username，age的值 * 其中username的这个注解默认的是required=true，因此这个是不可以没有的 * age的这个注解设置了required=false，表示可以没有这个参数，但是如果没有这个参数，那么默认的是null，但是int类型的没有null，因此也会是报错的，有两种解决方式： * 1) 通过defalutValue设置其默认的值 * 2) 如果我们就想要设其为null，可以使用封装类Integer类型即可 */@RequestMapping(value = "/testRequestParams")public String testRequestParams(@RequestParam(value="username") String username,@RequestParam(value="age",required=false) int age) &#123; System.out.println("username,age "+ username+" , "+age); return SUCCESS;&#125; 【推荐】使用自定义数据类型(JavaBean) 如果传过来的请求参数很多，那么我们使用上面的方法获取请求参数，需要申明很多的方法参数。但是我们可以将传递过来的请求参数封装成一个JavaBean，那么我们直接传入一个JavaBean对象即可接收全部的请求参数。 声明一个User类，其中必须为每一个属性添加 set方法，并且其中的变量名要和表单中的name属性一致 12345678910111213141516171819202122232425262728public class User &#123; private String username; private String password; private int age; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return "User [username=" + username + ", password=" + password + "]"; &#125;&#125; 那么我们此时的UserController中的login方法如下： 12345@RequestMapping(value = "/login.do") public String login(User user) &#123; System.out.println(user); return "success"; &#125; 总结 以上的所有方法并不冲突，可以混合使用 12345678/** * 混合使用案例*/@RequestMapping(value = "/login.do")public String login(User user,@RequestParam("gender")String gender) &#123; System.out.println(user); return "success";&#125; 不建议使用HttpServletRequest方法获取，另外的方法都是非常好用的方法，根据实际情况进行选取即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Springmvc之RequestMapping]]></title>
      <url>%2F2018%2F04%2F26%2FSpringmvc%E4%B9%8BRequestMapping%2F</url>
      <content type="text"><![CDATA[Springmvc之RequestMappingRequestMapping 标记客户的请求与哪一个类和方法对应 使用@RequestMapping同时对类和方法进行注解，相当于最终将这两处的注解路径拼接起来，比如类上使用@RequestMapping(&quot;/user&quot;),在方法上使用@RequestMapping(&quot;/login.do&quot;),那么拼接时访问的路径为http://localhost:8080/ProjectName/user/login.do 属性 value ： 默认的属性，表示映射的地址，如果只有这一个属性，那么默认可以不写value，比如@RequestMapping(&quot;/login.do&quot;)和@RequestMapping(value=&quot;/login.do&quot;)是一样的效果 method：指定是请求的方式，我们知道请求的方式有post,get,put,delete。一般常用的是post,get，一旦我们在其中定义这个method属性，那么如果请求的方式不是这个method指定的属性值，那么就不会访问到这个方法。 其实只要不指定这个method属性，无论是post还是get方式的都会执行这个方法，只有当其设置了method属性才会做限定 比如我们使用了 @RequestMapping(value=&quot;login.do&quot;,method=RequestMethod.GET)，但是我们使用表单提交的是&lt;form action=&quot;&lt;%=request.getContextPath%&gt;/project/user/login.do&quot; method=&quot;post&quot;&gt;&lt;/form&gt;,那么这个表单的请求就不会对应上面的注解的方法，因为表单的提交方式是post，但是RequestMapping定义的是method是get方式,会响应405错误 params ： params是用来指定请求中包含的参数，其中的值是一个字符串数组的形式，并且这个还支持简答的表达式 param: 表示请求参数中必须包含param这个参数至于为其赋予的值可以随便，但是必须包含这个字段 param!=value： 表示请求参数中必须包含param这个参数，但是为其赋予的值不能等于value这个值，其他的什么值都是可以的 !param ：表示请求参数中一定不能包含这个param字段，如果包含这个字段，那么将不能映射到这个地址 {“param1”，“param2”} ： 指定请求参数中必须包含着两个请求参数，至于为其赋什么值随便 12345678/* * 请求的参数中必须不能包含name属性，age必须不能等于12，必须包含sex，address必须等于xuzhou */@RequestMapping(value="/testParams",params=&#123;"!name","age!=12","sex","address=xuzhou"&#125;) public String testParams()&#123; System.out.println("testParams"); return SUCCESS; &#125; headers : headers和params同样是支持简单的表达式，同样是一个字符串数组，这里一样的是适用于上面的表达式 123456789/* * 请求的参数中必须不能包含name属性，age必须不能等于12，必须包含sex，address必须等于xuzhou * 请求头中的Accept-Language不能等于zh-CN,zh;q=0.8 */@RequestMapping(value="/testParams",params=&#123;"!name","age!=12","sex","address=xuzhou"&#125;,headers=&#123;"Accept-Language!=zh-CN,zh;q=0.8"&#125;)public String testParams()&#123; System.out.println("testParams"); return SUCCESS;&#125; RequestMapping支持Ant风格的通配符 在学习struts2中的时候也是支持通配符调用的，比如_等。现在springmvc中也是支持通配符风格的，但是只支持Ant风格的，如下： ？： 表示一个任意的字符 springmvc/testAnt?可以使用springmvc/testAnta`这个地址来访问，其中最后一个a可以替换成任意的字符 * : 表示支持多个任意的字符 /spingmvc/testAnt/* 可以使用springmvc/testAnt/aaaaa这个地址来访问，其中最后一层的路径可以使用任意的字符串替换 ** : 匹配多层路径 /springmvc/testAnt/** 可以使用/springmvc/testAnt/user/test这个来访问，当然也可以是多层的路径 123456789/* * 这里的* 表示支持任意多个字符，因此这里可以使用:springmvc/testAnt/user这个地址来访问，其中最后一层use可以写成任意的字符串即可 * */ @RequestMapping(value="/testAnt/*",method=RequestMethod.GET) public String testAnt()&#123; System.out.println("testAnt"); return SUCCESS; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Springmvc入门]]></title>
      <url>%2F2018%2F04%2F24%2FSpringmvc%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[Springmvc入门作用 解决V(View)和C(Controller)的交互问题,即解决了Controller如果接收了用户的请求，并将结果响应给用户的问题 springmvc约定了一套处理用户请求的流程 Springmvc的核心组件 DispatcherServlet ：前端控制器，请求入口 HandlerMapping ： 控制器，其中存放着处理请求的组件，请求派发 Controller ：控制器，处理请求 ModelAndView ：模型，封装业务处理结果和视图 ViewResolver : 视图解析器，显示视图 springmvc处理流程 用户发出请求，请求交给前端控制器(DispatcherServlet)处理 DispatcherServlet通过HandlerMapping找到Controller中相对应的组件处理请求 执行Controller组件约定方法处理请求，在约定方法调用模型组件(Service,Dao)完成业务逻辑,约定方法返回一个ModelAndView对象，封装了处理结果和视图名称信息 控制器接收了ModelAndView之后，调用视图解析器(ViewResolver)组件，定位到指定的View(JSP)并且传递处理结果，生成响应界面结果 创建一个Springmvc项目 创建maven项目 导入web.xml 配置tomact项目运行环境(项目右击 --&gt; properties - &gt; Target Runtimes) 配置pom.xml依赖 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 添加springmvc的配置文件在resource目录下(applicationContext.xml) 开启组件扫描 配置视图解析器，用来定义跳转的视图，在视图解析中，最后的jsp文件在 perfix + controller中返回的字符串 + suffix 123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:jdbc="http://www.springframework.org/schema/jdbc" xmlns:jee="http://www.springframework.org/schema/jee" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:util="http://www.springframework.org/schema/util" xmlns:jpa="http://www.springframework.org/schema/data/jpa" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-3.2.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa-1.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.2.xsd"&gt; &lt;!-- 开启组件扫描 --&gt; &lt;context:component-scan base-package="cn.tedu.springmvc"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置视图解析器: prefix:表示前缀 suffix：表示后缀 如果controller中返回的是success这个字符串，那么对应的视图是/WEB-INF/JSP/success.jsp这个视图 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/JSP/" /&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt;&lt;/beans&gt; 配置前端控制器(DispatcherServlet),在web.xml中配置 12345678910111213141516171819202122&lt;!-- 配置前端控制器DispatcherServlet --&gt;&lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置springMVC配置文件的路径，这里如果想要使用默认的可以不用配置 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- classpath表示根路径，这里找的项目根路径下的applicationContext.xml --&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 当tomcat启动的时候就加载，设置启动的优先级 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;!-- 配置分发规则，这个是用来控制所有的请求,只要是请求后缀为.do的都会拦截分发--&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 在cn.tedu.springmvc.controller包中创建一个UserController类 12345678910@Controller@RequestMapping("/user")public class UserController &#123; @RequestMapping("/hello.do") public String testHello()&#123; System.out.println("Hello World"); return "success"; //返回视图，这里通过视图解析器之后对应的是 /WEB-INF/JSP/success.jsp &#125;&#125; 在 WEB-INF/JSP/中创建一个success.jsp页面，添加一个&lt;h1&gt;Hello World&lt;/h1&gt; 此时启动项目，打开浏览器输入http://localhost:8080/Springmvc_01/user/hello.do，那么就会看见成功跳转到success.jsp页面，显示文字]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring注解的使用和组件扫描]]></title>
      <url>%2F2018%2F04%2F24%2FSpring%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E7%BB%84%E4%BB%B6%E6%89%AB%E6%8F%8F%2F</url>
      <content type="text"><![CDATA[Spring注解的使用和组件扫描【非常重要】 组件扫描(Component-Scan) 通过配置组件扫描，可以使得spring自动扫描package，而不必在spring的配置文件中逐一声明各个&lt;bean&gt; 在配置组件扫描时，指定的包是“根包”，即例如指定了cn.tedu.spring,spring不只会扫描这个包，还会扫描它的各个层级子包，例如：cn.tedu.spring.dao 直接在spring的配置文件中开启组件扫描即可 &lt;context:component-scan base-package=&quot;cn.tedu.spring&quot;&gt;&lt;/context:component-scan&gt; 注意： 仅仅开启组件扫描spring是不会自动管理bean的，而是自动的扫描package，要想自动管理bean，那么还需要配置注解 注解 在类的声明上方添加@Component注解，可以是的spring知道这个类是一个组件，需要进行管理，所以如过某个类需要被Spring管理，应该将这个类放在被扫描的包中，并且添加注解 由Spring扫描到的组件(由@Component注解标记的类)，会由Spring自动设置Bean Id，值为将类名首字母小写的名称，例如组件类的名称是UserDao，则配置的Bean的id是userDao，如果需要自定义Bean，那么可以直接在注解中设置，比如@Component(&quot;id&quot;) 前提 一定要是在开启组件扫描的包下使用注解，否则将不会扫描到配置的注解 常用注解 可以混用，暂时这几个注解没有差异，完全功能相同，但是我们还是要根据规则使用 @Component ： 通用注解 @Service ： 用于对业务逻辑类的注解(Service层) @Controller ： 用于对控制器类的注解 @Repository ：用于对持久层处理类的注解(Dao层) @Named ：通用注解(不用) 以上5个注解从实现目标和效果是等效的，但是基于方便理解代码的目的，应该按需使用，了；例如对名为UserService类的，应该使用@Service 其他注解@Scope 在类的声明语句上方添加这个注解，用于设置bean的作用域,比如@Scope(&quot;prototype&quot;)表示非单例，默认是单例 @Lazy 在单例模式下设置是否懒加载，例如@Lazy(&quot;true&quot;)用于设置成懒加载 在类的声明语句上方添加 前面之前已经说过，在创建Bean的时候默认使用的是单例模式下的饿汉式的创建，即是在spring配置文件加载的时候创建 @PostConstruct 将方法设置为生命周期的初始化方法 设置初始化方法，直接在初始化方法的声明语句中添加即可 1234567/** * 初始化方法： 应该是public的，无返回参数，无参数的 */@PostConstruct //定义初始化方法，在构造方法之后执行public void init()&#123; System.out.println("初始化方法");&#125; @PreDestroy(单例模式下才会销毁) 在方法的声明语句上方使用，可以将这个方法设置为生命周期的销毁方法 1234@PreDestroy //定义销毁方法 public void destroy()&#123; System.out.println("销毁方法"); &#125; 注入值@Autowired （不推荐使用） 在类中，在声明属性的上方添加@Autowired，用于标记该属性是自动装配值 这种自动装配默认按照类型(byType)实现自动装配 如果需要按照名称(byName)来自动装配,还需要使用@Qualifier(&quot;userDao&quot;)来组合使用，注解中配置的名称是需要注入的值的Bean-Id UserDao 123456@Repository(&quot;userDao&quot;)public class UserDaoImpl implements UserDao&#123; public void reg() &#123; System.out.println(&quot;reg&quot;); &#125;&#125; UserService 123456789@Servicepublic class UserService &#123; @Autowired @Qualifier("userDao") private UserDao userDao; public void reg()&#123; userDao.reg(); &#125;&#125; @Resource (推荐使用) 在需要注入的属性的上方添加该注解 默认先按照名称来自动装配的(byName),如果名称对应不上，那么按照类型(byType)进行匹配 12@Resource //这里会先自动匹配和属性名一样的Bean Id，如果没有匹配到，那么就按照类型进行匹配private UserDao userDao; 如果使用@Resource(name=&quot;userDaoImpl&quot;)，name属性指定的是Bean Id,添加了name属性，那么只是按照名称来装配，如果这个名称对应的Bean不存在，那么就注入失败 12@Resource(name="userDaoImpl") //这里只会匹配Bean Id为userDaoImpl的，如果匹配不上，那么报异常private UserDao userDao; @Value 使用@Value注解添加在属性的声明的上方，可以对属性注入值 直接注入值 12@Value("陈加兵")private String name; 在使用@Value(&quot;#{beanId.属性名}&quot;)的注解时还可以使用Spring表达式 12@Value(#&#123;jdbc.url&#125;)private String url;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring表达式和自动装配]]></title>
      <url>%2F2018%2F04%2F24%2FSpring%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%2F</url>
      <content type="text"><![CDATA[Spring表达式和自动装配【重要】spring表达式作用 通过spring表达式可以在配置Y节点时，如果Y的某些属性需要注入值，可以是已经配置的好的X类的节点中的值 直接使用#{id.属性名} 前提 必须为每个属性都要设置set方法 实现 新建两个类 Message 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Message &#123; private String name; private List&lt;String&gt; cities; //城市 。List集合 private Set&lt;String&gt; friend; //Set集合 private Map&lt;Integer,String&gt; bookes; //Map集合 private Properties properties; //Properties集合 private String[] names; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String[] getNames() &#123; return names; &#125; public void setNames(String[] names) &#123; this.names = names; &#125; public List&lt;String&gt; getCities() &#123; return cities; &#125; public void setCities(List&lt;String&gt; cities) &#123; this.cities = cities; &#125; public Set&lt;String&gt; getFriend() &#123; return friend; &#125; public void setFriend(Set&lt;String&gt; friend) &#123; this.friend = friend; &#125; public Map&lt;Integer, String&gt; getBookes() &#123; return bookes; &#125; public void setBookes(Map&lt;Integer, String&gt; bookes) &#123; this.bookes = bookes; &#125; public Properties getProperties() &#123; return properties; &#125; public void setProperties(Properties properties) &#123; this.properties = properties; &#125;&#125; ValueBean的类 123456789101112public class ValueBean &#123; private String username; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125;&#125; 获取不是集合类型的值 在sprig的配置文件中配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;util:list id="cities"&gt; &lt;value&gt;徐州&lt;/value&gt; &lt;value&gt;无锡&lt;/value&gt; &lt;value&gt;常州&lt;/value&gt;&lt;/util:list&gt;&lt;util:set id="friends"&gt; &lt;value&gt;Jack&lt;/value&gt; &lt;value&gt;Tom&lt;/value&gt; &lt;value&gt;陈加兵&lt;/value&gt;&lt;/util:set&gt;&lt;util:map id="bookes"&gt; &lt;entry key="1001" value="java编程基础"&gt;&lt;/entry&gt; &lt;entry key="1002" value="java编程思想"&gt;&lt;/entry&gt;&lt;/util:map&gt;&lt;!-- 引入外部的Properties文件，location指定的就是位置 --&gt;&lt;util:properties id="properties" location="classpath:jdbc.properties"&gt;&lt;/util:properties&gt;&lt;bean id="message" class="cn.tedu.spring.beans.Message"&gt; &lt;property name="name" value="陈加兵"&gt;&lt;/property&gt; &lt;!-- List集合的注入 ref指定的上面定义的List的id --&gt; &lt;property name="cities" ref="cities"&gt;&lt;/property&gt; &lt;!-- Set集合的注入 --&gt; &lt;property name="friend" ref="friends"&gt;&lt;/property&gt; &lt;!-- Map集合的注入 --&gt; &lt;property name="bookes" ref="bookes"&gt;&lt;/property&gt; &lt;!-- properties的集合的注入 --&gt; &lt;property name="properties" ref="properties"&gt;&lt;/property&gt; &lt;!-- 为数组赋值 --&gt; &lt;property name="names"&gt; &lt;array&gt; &lt;value&gt;Alex&lt;/value&gt; &lt;value&gt;Billy&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置ValueBean --&gt;&lt;bean id="valueBean" class="cn.tedu.spring.beans.ValueBean"&gt; &lt;!-- value的值是使用spring表达式获取的，形式为：#&#123;前面定义好的id.属性名&#125; --&gt; &lt;property name="username" value="#&#123;message.name&#125;"&gt;&lt;/property&gt;&lt;/bean&gt; 引用数组集合或者List的值 直接使用 #{bean的id.数组名[index]} 12345&lt;!-- 配置ValueBean --&gt;&lt;bean id="valueBean" class="cn.tedu.spring.beans.ValueBean"&gt; &lt;!-- value的值是使用spring表达式获取的，形式为：#&#123;前面定义好的id.属性名&#125; --&gt; &lt;property name="username" value="#&#123;message.names[0]&#125;"&gt;&lt;/property&gt;&lt;/bean&gt; ValueBean的name属性设置为Person中的Address对象的city值 #{person.address.city} Person类中有一个成员变量是Address类的对象 这里不再写这三个类了，直接在spring中配置 123456789101112131415161718&lt;!-- 创建一个Address的实例 --&gt; &lt;bean id="address" class="cn.tedu.spring.beans.Address"&gt; &lt;property name="city" value="无锡"&gt;&lt;/property&gt; &lt;property name="pro" value="江苏"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="person" class="cn.tedu.spring.beans.Person"&gt; &lt;property name="name" value="陈加兵"&gt;&lt;/property&gt; &lt;property name="age" value="22"&gt;&lt;/property&gt; &lt;!-- 引用上面address --&gt; &lt;property name="address" ref="address"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置ValueBean --&gt; &lt;bean id="valueBean" class="cn.tedu.spring.beans.ValueBean"&gt; &lt;!-- value的值是使用spring表达式获取的，形式为：#&#123;前面定义好的id.属性名&#125; --&gt; &lt;property name="username" value="#&#123;person.address.city&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; 引用Map集合中的某个value #{id.Map名称.key名称} #{id.Map名称[&#39;key名称&#39;]} 【了解】spring表达式支持方法的调用【了解】 自动装装配(autowire) &lt;bean id=&quot;&quot; class=&quot;&quot; autowire=&quot;&quot;&gt; 自动装配表现为不需要配置&lt;property&gt;节点来注入，spring会自动的为属性注入值 在bean节点中添加autowire属性以配置自动装配，当值为byName，表示根据名称自动装配，即spring会检查这个bean的所有属性名称，然后在搜平日那个管理的所有Bean中查找bean-id一致的Bean对象，如果找到，则自动赋值 当取值为byType时，表示根据类型自动装配，及自动化赋值的标准是找数据类型匹配的Bean对象，需要注意的是：如果根据类型装配，必须保证可以匹配上的，由spring自动管理的Bean只有一个，如果有2个或者更多，会导致异常 实例 UserDao 12345public class UserDao()&#123; public void reg()&#123;&#125;&#125; UserService 123456public class UserService&#123; private UserDao userDao; private void reg()&#123; userDao.reg();&#125;&#125; spring 的配置文件 1234&lt;bean id="userDao" class="cn.tedu.spring.UserDao"/&gt;&lt;!--这里不需要配置property节点来ref上面定义的bean，只需要使用自动装配即可--&gt;&lt;bean id="userService" class="cn.tedu.spring.UserService" autowire="byName"&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring依赖注入]]></title>
      <url>%2F2018%2F04%2F24%2FSpring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%2F</url>
      <content type="text"><![CDATA[Spring依赖注入【了解】Spring管理对象的生命周期(只有在单例的模式有意义，这个是默认的) 由spring管理的对象可以有生命周期方法，这些生命周期方法是开发人员自定义的，方法名自定义，无参数 由spring管理的对象的类可以有初始化和销毁这两种生命周期方法，按需设计即可。 因为是spring自己调用的，因此要设置为无参数，无返回值的方法。 为单个bean指定生命周期方法 实例： 1234567891011public class Person &#123; private String name; private int age; //person类的初始化方法 public void init()&#123; System.out.println("初始化方法"); &#125; public void destory()&#123; System.out.println("销毁方法"); &#125;&#125; 在spring配置文件中配置 12345&lt;!-- init-method ： 定义初始化方法，直接写上方法名称即可 destroy-method： 定义销毁方法，直接写上方法名即可 --&gt;&lt;bean id="" class="cn.tedu.spring.beans.Person" init-method="init" destroy-method="destory"&gt;&lt;/bean&gt; 为容器中所有的bean指定生命周期方法 可以在顶级节点中添加default-init-method指定初始化方法和添加default-destroy-method指定销毁方法 123&lt;beans default-init-method="init" default-destroy-method="destroy"&gt; &lt;bean id="person" class="cn.tedu.spring.bean.Person"&gt;&lt;/bean&gt;&lt;/bean&gt; 【重要】注入属性值实现目标 由spring管理的对象，其属性值可以为其中的某些属性注入值，是的最终获取对象时，属性就已经有值了 Setter注入前提 必须为每一个属性添加set方法 基本数据类型变量的注入实现 新建一个Person的实体类如下： 12345678910111213141516public class Person &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 在配置文件中配置bean 123456789&lt;bean id="person" class="cn.tedu.spring.beans.Person"&gt; &lt;!-- 直接使用property配置参数 name：指定属性的字段，这个是set方法后面的单词首字母小写的值，比如SetUsername()，那么此时的name值为username value： 指定属性的值 ref : 指定前面定义的bean的id，用于设置引用类型的参数值 --&gt; &lt;property name="name" value="陈加兵"&gt;&lt;/property&gt; &lt;property name="age" value="22"&gt;&lt;/property&gt;&lt;/bean&gt; 注意： 在配置XML文件时，节点中的name属性的值其实是Java代码中Set方法名称中除去set单词并且将首字母小写后的名称，例如Set方法的名称为setAge，那么其中的name属性的值就是age。所以这个name属性的值并不是java代码中的属性名称，只不过通常在java代码中，基于代码规范，这里的name属性值也是java代码中的属性名称。 引用类型的属性注入 引用类型即是在一个类中包含另外一个类的对象，即是一个类的成员变量是另外一个类的对象 实现 新建一个Address类 12345678910111213141516public class Address &#123; private String city; //城市 private String pro ; //省份 public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125; public String getPro() &#123; return pro; &#125; public void setPro(String pro) &#123; this.pro = pro; &#125;&#125; 新建一个Person类，其中包含了Address这个类的对象 1234567891011121314151617181920212223242526272829public class Person &#123; private String name; private int age; private Address address; // Address的对象作为成员变量 public Address getAddress() &#123; return address; &#125; public void setAddress(Address address) &#123; this.address = address; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 在配置文件中配置实例 12345678910111213&lt;!-- 创建一个Address的实例 --&gt;&lt;bean id="address" class="cn.tedu.spring.beans.Address"&gt; &lt;property name="city" value="无锡"&gt;&lt;/property&gt; &lt;property name="pro" value="江苏"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id="person" class="cn.tedu.spring.beans.Person"&gt; &lt;property name="name" value="陈加兵"&gt;&lt;/property&gt; &lt;property name="age" value="22"&gt;&lt;/property&gt; &lt;!-- 这里的ref引用的是上面配置的Address的实例中的id值 --&gt; &lt;property name="address" ref="address"&gt;&lt;/property&gt;&lt;/bean&gt; 【了解】构造器注入(无参，有参) 在前面已经讲过了无参构造注入，直接使用&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;即可 前提 有一个构造有参构造方法 实现 创建一个Person类 12345678910111213141516171819202122232425public class Person &#123; private String name; private int age; //构造方法 public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 配置spring的配置文件 12345678910&lt;bean id="person" class="cn.tedu.spring.beans.Person"&gt; &lt;!-- name: 这个相当于index，也是指定参数列表的属性，不过这里是直接使用参数列表中的变量名 value: 为参数设置的值 index: 构造方法的参数列表的索引，从0开始 ref:引用类型的值，这里的值应该是上面已经定义好的bean的id值 --&gt; &lt;constructor-arg index="0" value="陈加兵"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" value="22"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 注入基本型 在spring注入值时，如果值的类型是String或者java中的基本数据类型，都称之为基本型，而其他的都是”非基本型“的数据 注入非基本型(ref) 前面所说的引用类型的注入就是基本型的注入，这里不再详细的讲述 注入集合 集合类型有List，Set，Map，Properties 实现 创建一个Message类，其中定义了各种集合类型的成员属性，并且添加了set方法 123456789101112131415161718192021222324252627282930public class Message &#123; private List&lt;String&gt; cities; //城市 。List集合 private Set&lt;String&gt; friend; //Set集合 private Map&lt;Integer,String&gt; bookes; //Map集合 private Properties properties; //Properties集合 public List&lt;String&gt; getCities() &#123; return cities; &#125; public void setCities(List&lt;String&gt; cities) &#123; this.cities = cities; &#125; public Set&lt;String&gt; getFriend() &#123; return friend; &#125; public void setFriend(Set&lt;String&gt; friend) &#123; this.friend = friend; &#125; public Map&lt;Integer, String&gt; getBookes() &#123; return bookes; &#125; public void setBookes(Map&lt;Integer, String&gt; bookes) &#123; this.bookes = bookes; &#125; public Properties getProperties() &#123; return properties; &#125; public void setProperties(Properties properties) &#123; this.properties = properties; &#125;&#125; 在spring的配置文件中配置注入 1234567891011121314151617181920212223242526272829303132333435&lt;bean id="message" class="cn.tedu.spring.beans.Message"&gt; &lt;!-- List集合的注入 --&gt; &lt;property name="cities"&gt; &lt;list&gt; &lt;value&gt;徐州&lt;/value&gt; &lt;value&gt;无锡&lt;/value&gt; &lt;value&gt;常州&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- Set集合的注入 --&gt; &lt;property name="friend"&gt; &lt;set&gt; &lt;value&gt;Jack&lt;/value&gt; &lt;value&gt;Tom&lt;/value&gt; &lt;value&gt;陈加兵&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- Map集合的注入 --&gt; &lt;property name="bookes"&gt; &lt;map&gt; &lt;entry key="1001" value="java编程基础"&gt;&lt;/entry&gt; &lt;entry key="1002" value="java编程思想"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- properties的集合的注入 --&gt; &lt;property name="properties"&gt; &lt;props&gt; &lt;prop key="username"&gt;root&lt;/prop&gt; &lt;prop key="password"&gt;root&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 测试方法 123456789101112131415161718@Test public void test2() &#123; // spring的配置文件 String conf = "applicationContext.xml"; // 获取spring容器 AbstractApplicationContext context = new ClassPathXmlApplicationContext( conf); Message message=(Message) context.getBean("message"); List&lt;String&gt; cities=message.getCities(); Set&lt;String&gt; friends=message.getFriend(); Map&lt;Integer, String&gt; bookes=message.getBookes(); Properties properties=message.getProperties(); System.out.println(cities); System.out.println(friends); System.out.println(bookes); System.out.println(properties); context.close(); &#125; 【重点了解Properties的注入】引用方式注入集合(&lt;util:&gt;) 其中的ref指定的是配置集合的id 使用的还是上面的Message类 在resource中需要新建一个jdbc.properties，我们便可以在spring的配置文件中使用&lt;util:properties id=&quot;&quot; location=&quot;classpath:jdbc.properties&quot;&gt;自动的读取其中的值 1234root=rootpassword=rooturl=jdbc:mysql://localhost:3306/hirbernate?useUnicode=true&amp;characterEncoding=UTF-8driver=com.mysql.jdbc.Driver spring的配置文件中配置bean 123456789101112131415161718192021222324252627282930313233&lt;util:list id="cities"&gt; &lt;value&gt;徐州&lt;/value&gt; &lt;value&gt;无锡&lt;/value&gt; &lt;value&gt;常州&lt;/value&gt;&lt;/util:list&gt;&lt;util:set id="friends"&gt; &lt;value&gt;Jack&lt;/value&gt; &lt;value&gt;Tom&lt;/value&gt; &lt;value&gt;陈加兵&lt;/value&gt;&lt;/util:set&gt;&lt;util:map id="bookes"&gt; &lt;entry key="1001" value="java编程基础"&gt;&lt;/entry&gt; &lt;entry key="1002" value="java编程思想"&gt;&lt;/entry&gt;&lt;/util:map&gt;&lt;!-- 引入外部的Properties文件，location指定的就是位置 --&gt;&lt;util:properties id="properties" location="classpath:jdbc.properties"&gt;&lt;/util:properties&gt;&lt;bean id="message" class="cn.tedu.spring.beans.Message"&gt; &lt;!-- List集合的注入 ref指定的上面定义的List的id --&gt; &lt;property name="cities" ref="cities"&gt;&lt;/property&gt; &lt;!-- Set集合的注入 --&gt; &lt;property name="friend" ref="friends"&gt;&lt;/property&gt; &lt;!-- Map集合的注入 --&gt; &lt;property name="bookes" ref="bookes"&gt;&lt;/property&gt; &lt;!-- properties的集合的注入 --&gt; &lt;property name="properties" ref="properties"&gt;&lt;/property&gt;&lt;/bean&gt; 【了解】其他类型的注入为数组注入值 新添加一个数组的属性 12345678private String[] names; public String[] getNames() &#123; return names; &#125; public void setNames(String[] names) &#123; this.names = names; &#125; spring配置文件 1234567&lt;!-- 为数组赋值 --&gt;&lt;property name="names"&gt; &lt;array&gt; &lt;value&gt;Alex&lt;/value&gt; &lt;value&gt;Billy&lt;/value&gt; &lt;/array&gt;&lt;/property&gt; 甚至在配置XML时，&lt;List&gt;和&lt;array&gt;可以随意挑选使用，即为List类型的数据注入值时，既可以使用&lt;List&gt;节点，也可以使用&lt;array&gt;节点，反之为数组类型的数据值也是一样 注入空字符串 设置的value直接为&quot;&quot; 为引用类型的数据注入null值123&lt;property name="xxx"&gt; &lt;null/&gt;&lt;/property&gt; 显示的确定数据类型123&lt;property name="xxx"&gt; &lt;value type="数据类型"&gt;值&lt;/value&gt;&lt;/property&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring入门]]></title>
      <url>%2F2018%2F04%2F24%2FSpring%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[spring_day01SSM框架 Spring + springMVC + mybatis 作用 管理对象： 当开发人员需要某一个类的对象时，不需要自行new对象，而是通过spring直接获取即可 使用【掌握】通过spring获取存在无参构造方法类的对象 创建Maven Project 当项目创建好之后，生成web.xml，解决默认提示错误 选择tomcat, 项目右击 - &gt; properties -&gt; Target Runtimes 打开 http://mvnrepository.com，搜索springwebmvc，在结果中找到的Group是org.springframework,选择版本，并且复制xml代码 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置spring的配置文件(applicationContext.xml) 1234&lt;!-- id： 自定义名称 class : 需要spring管理的类的路径 --&gt; &lt;bean id="date" class="java.util.Date"&gt;&lt;/bean&gt; 测试 12345678910111213141516import java.util.Date;import org.springframework.context.support.AbstractApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestDemo1 &#123; public static void main(String[] args) &#123; //spring的配置文件 String conf="applicationContext.xml"; //获取spring容器 AbstractApplicationContext context=new ClassPathXmlApplicationContext(conf); //获取配置文件中指定的bean，参数是自定义的id Date date=(Date) context.getBean("date"); //打印出日期，对象创建成功 System.out.println(date); context.close(); &#125;&#125; 内存泄露或者内存溢出 当需要释放某个对象所占用的内存空间时，如果对象没有正确关闭，将导致无法释放，由于这个对象可能已经没有了引用，这个对象再也无法使用，却一直被误认为被使用，就会变成长期存在于内存中的垃圾数据，就是内存泄露 其实少量的内存泄露是灭有危害的。但是如果存在大量的内存泄露，就可导致可用内存明显变少，计算机的运行性能就会下降，当内存泄露到极点的时候，就会溢出。尽管少量的内存泄露是没有危害的，但是应该严谨的编程，尽量不要出现内存泄露 【了解】通过spring获取类中不存在无参构造方法，但是存在静态工厂方法类的对象 我们使用spring获取java.util.Calendar的对象 factory-method ： 这个属性指定的静态工厂方法 在spring的配置文件中配置这个对象 123456&lt;!-- 通过静态工厂方法创建对象 id ： 自定义的名称 class： 类的全路径 factory-method ： 静态工厂方法 --&gt;&lt;bean id="calendar" class="java.util.Calendar" factory-method="getInstance"&gt;&lt;/bean&gt; 测试 12345678910111213@Test public void testStatice() &#123; // spring的配置文件 String conf = "applicationContext.xml"; // 获取spring容器 AbstractApplicationContext context = new ClassPathXmlApplicationContext( conf); // 获取配置文件中指定的bean，参数是自定义的id Calendar calendar=(Calendar) context.getBean("calendar"); // 打印出日期，对象创建成功 System.out.println(calendar.getTime()); context.close(); &#125; 【了解】类中不存在无参构造方法，也没有静态工厂方法，但是存在实例工厂方法实例工厂方法 实例工厂方法： 指另一个类中有工厂方法，可以获取目标类型的对象，即X类中有工厂方法(非静态的)可以获取Y类的对象 实例 假设存在PhoneFactory类中，该类中有非静态方法getPhone()可以获取Phon类型的对象，并且Phone没有无参构造方法 Phone 123456public class Phone &#123; public String name; public Phone(String name) &#123; this.name=name; &#125;&#125; PhoneFactory 12345public class PhoneFactory &#123; public Phone getPhone() &#123; return new Phone("小米6"); &#125;&#125; spring配置文件 factory-bean ： 是工厂类的id factory-method ： 工厂类获取Phone对象的非静态的方法 12345678&lt;!-- 配置工厂类 --&gt; &lt;bean id="phoneFactory" class="cn.tedu.spring.beans.PhoneFactory"&gt;&lt;/bean&gt; &lt;!-- 配置Phone类的对象 factory-bean ： 是工厂类的id factory-method ： 工厂类获取Phone对象的非静态的方法 --&gt; &lt;bean id="phone" class="cn.tedu.spring.beans.Phone" factory-bean="phoneFactory" factory-method="getPhone"&gt;&lt;/bean&gt; Bean的作用域(Scope) 默认情况下，由spring配置的对象是单例的 在配置时，在&lt;bean&gt;节点添加scope属性即可调整，当该属性为singleton时是单例的，当属性为prototype为非单例的 1234&lt;!-- id： 自定义名称 class : 需要spring管理的类的路径 --&gt;&lt;bean id="date" class="java.util.Date" scope="prototype"&gt;&lt;/bean&gt; 单例(Singleton)懒加载 在默认情况下，spring创建对象的是使用饿汉式，即是在spring配置文件开始加载的时候就创建对象，但是我们可以使用lazy-init取值我true的时候，就会使用懒加载(懒汉式) 1&lt;bean id="date" class="java.util.Date" scope="singleton" lazy-init="true"&gt;&lt;/bean&gt; prototype 一个Bean定义对应多个对象实例 request 在一次Http请求中，一个Bean只创建一个实例，仅限于web环境 session 在一个HttpSession中，一个Bean定义对应一个实例 globalSession 在一个全局的HttpSession中，一个bean定义对应一个实例 Bean的延迟初始化 在spring创建Bean的实例的时候默认是使用单例，并且是饿汉式加载，即是在spring的配置文件在开始加载的时候就创建bean的实例对象 但是我们可以使用lazy-init来延迟初始化，使用懒加载即可，当lazy-init为true的时候便是延迟加载 1&lt;bean id="date" class="java.util.Date" lazy-init="true"&gt;&lt;/bean&gt; 我们还可以在&lt;beans&gt;根节点中添加一个default-lazy-init，可以为容器中的所有bean设置为懒加载 1&lt;beans default-lazy-init="true"&gt;&lt;/beans&gt; spring配置文件的全部约束12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:jdbc="http://www.springframework.org/schema/jdbc" xmlns:jee="http://www.springframework.org/schema/jee" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:util="http://www.springframework.org/schema/util" xmlns:jpa="http://www.springframework.org/schema/data/jpa" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-3.2.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa-1.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.2.xsd"&gt;&lt;/beans&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Servlet和JSP总结]]></title>
      <url>%2F2018%2F04%2F24%2FServlet%E5%92%8CJSP%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[Servlet和JSP总结B/S和C/S BS: Browser Server 浏览器和服务器 特点： 跨平台，功能升级比较方便，加载数据慢，用户体验稍差 CS： Client Server 客户端和服务器 特点： 功能升级 需要下载新版本客户端，用户交互界面炫酷，体验度高，需要开发多个平台的版本，开发成本高 总结： 两种架构各有优缺点，以后工作都有可能涉及到 什么是服务器 服务器实际上就是一台高配置的电脑，通常配置内存8g以上，cpu8核以上，硬盘T级别 web服务器： 电脑上安装了web服务器软件，提供复杂的数据及文件共享功能 邮件服务器： 电脑上安装了邮件服务器，提供了收发邮件的功能 数据库服务器： 电脑上安装了数据库软件(mysql oracle) 提供了数据的增删改查 ftp服务器：电脑上安装了ftp服务软件，提供了文件上传下载功能 什么是web服务器 电脑中得到任何资源（数据或者文件）被远程计算机访问，都必须有一个与之对应的网络通信程序，当有用户来访问时，此程序负责建立网络连接，读取相关资源，并把资源发送给用户，此程序负责底层的网络通讯处理http协议，使用此类型程序，程序猿只需要把精力放在具体的业务逻辑上即可 通过scoket实现web服务器 练习： 请求http://localhost:8080 返回一个网页 火狐浏览器执行，chrome不支持，windows下不执行可能原因是防火墙 1234567891011121314151617181920212223242526272829303132import java.io.FileInputStream;import java.io.IOException;import java.io.OutputStream;import java.net.ServerSocket;public class Socket &#123; public static void main(String[] args) throws IOException &#123; //创建服务器socket，并指定端口号 ServerSocket serverSocket=new ServerSocket(8888); System.out.println("服务器已经启动"); //循环接收新的socket while(true)&#123; //得到链接进来的socket对象 java.net.Socket socket=serverSocket.accept(); //构建数据发送通道 OutputStream outputStream=socket.getOutputStream(); //得到文件的输入流 FileInputStream inputStream=new FileInputStream("/home/chenjiabing/文档/a.html"); //把文件数据读取到，然后写出 int len=0; while((len=inputStream.read())!=-1)&#123; outputStream.write(len); &#125; //关闭流 outputStream.close(); inputStream.close(); &#125; &#125;&#125; 市面上常见的web服务器 webSphere : 是IBM公司产品，闭源收费 应用场景：IBM的操作系统+DB2+WebSphere Tomcat： apache的产品，属于开源免费应用在中小型网站中 web学习阶段使用的服务器 weblogic : BEA公司的产品 闭源收费 静态资源和动态资源 静态资源：任何用户 任何时间访问 内容都一样 动态资源： 不同的用户访问显示的内容可能会不一样，通过计算生成的网页 Servlet 介绍 因为web服务器本身只提供了静态资源访问，而具体的业务需求存在着动态资源，servlet就是用来扩展web服务器功能，tomcat属于web容器，而servlet属于存在于容器中的组件，Servlet本身是一个组件规范。 如何创建Servlet 创建一个Class，继承HttpServlet 编译 打包并发布（把servlet添加到tomcat中的webapps目录下） WEB-INF 这个文件夹里面的资源不能直接访问 classess (.class文件) lib (存放第三方的jar包) web.xml （部署描述文件） 运行tomact服务器 创建Servlet第一个程序 创建maven项目 把默认的jar改成war 把package Explorer改成 project Explorer 在工程根目录的第一个文件上右键点击最长的那一个选项(默认工程中没有web.xml文件，这个操作会自动创建web.xml) 创建一个类，继承HttpServlet 可能你会发现没有这个HttpServlet类，因为这里我们还需要一个jar包，我们在项目上右击选择properties，然后选择Targeted Runtime选择你自己的Tomcat，ok 1234567891011121314151617181920212223import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class HelloServlet extends HttpServlet &#123; //这个方法可以处理任何的请求，get.post delete put 并且可以在适当的时候调用处理请求类型的各种方法 @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //设置响应的数据类型 response.setContentType("text/html"); //设置响应编码格式为UTF-8，否则将会出现中文乱码 response.setCharacterEncoding("UTF-8"); //得到输出对象 PrintWriter writer=response.getWriter(); //返回数据，这里是向浏览器中写入数据 writer.write("&lt;h1&gt;Hello World--你好世界&lt;/h1&gt;"); //关闭输出流 writer.close(); &#125;&#125; 接下来在web.xml中配置Servlet的映射地址，在web-app的目录下写上如下内容 12345678910111213&lt;servlet&gt; &lt;!-- 自己定义的名字，任意 --&gt; &lt;servlet-name&gt;HelloWorld&lt;/servlet-name&gt; &lt;!-- 指定Servlet的全类名 --&gt; &lt;servlet-class&gt;cn.tedu.HelloServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!-- 指定Servlet的映射关系 --&gt;&lt;servlet-mapping&gt; &lt;!-- 这个是上面定义的Servlet的名字 --&gt; &lt;servlet-name&gt;HelloWorld&lt;/servlet-name&gt; &lt;!-- 指定映射的地址： 这里只需要在浏览器中输入http://localhost:8080/helloWorld即可调用这个Servlet --&gt; &lt;url-pattern&gt;/helloWorld&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 在浏览器中输入http://localhost:8080/helloWorld 错误码 404 找不到访问资源 解决： 检查请求地址，检查项目是否部署成功 500 服务器处理出错 - 代码执行中有异常，仔细查看异常提示，看看能否找到解决办法 Servlet响应的过程 浏览器发出请求，会先由浏览器的通讯模块对请求进行打包，打包后把数据传递给tomcat服务器 tomcat由通讯模块接收请求包并且对请求包进行解析，把请求数据封装到Request对象中，并且创建Response对象用于给浏览器返回数据 tomcat通讯模块通过查找web.xml文件和本次请求相对应的Sevlet，通过反射技术创建对象并且调用对象的Service方法并把Request和Response传递到方法中 在service方法中书写各种业务代码，把需要返回的数据交给Respose对象，由Response对象传递给通讯模块，在通讯模块中打包成响应包 把响应包数据发送给浏览器通讯模块 浏览器通讯模块解析数据并且展示返回的数据 ##响应数据乱码-为什么出现乱码,因为输出响应数据默认使用的是iso8859-1 需要把此编码改成utf-8 ##发出请求时传递参数把请求的参数写在请求地址的后面http://localhost:8080/1712ServletDay02_01Hello/hello?name=xiaoming通过request获取请求参数 ##案例:计算 体质率BMI页面中 有两个文本输入框 一个用来获取身高,一个用来获取体重 和一个提交按钮bmi计算公式 bmi = 体重(kg)/身高(m)/身高(m)根据bmi值判断体重是否正常 bmi=19&amp;&amp; bmi&lt;=25 体重正常 bmi&gt;25 该减肥了步骤:1. 创建页面bmi.html 页面中添加两个文本输入框和一个提交按钮 2. 创建BMIServlet在Service方法中写业务逻辑 3. 在web.xml中配置bmiservlet 地址栏中出现中文 乱码解决方案因为浏览器默认会对中进行utf-8编码,但是在Servlet里面8.0以前默认是iso8859-1,8.0以后默认是utf-8,如果使用8.0以前版本解决乱码方案有两种: new String(gender.getBytes(&quot;iso8859-1&quot;),&quot;utf-8&quot;); 在server.xml的配置文件中修改 在server.xml的第65行左右 的&lt;Connector标签中添加以下属性&lt;Connector URIEncoding=&quot;utf-8&quot; HTTP协议(了解)什么是HTTP协议属于一种网络应用层的协议,规定了浏览器与web服务器之间如何通讯,以及数据包的结构 -tcp/ip协议:属于连接协议,规定了两台设备如何建立连接 -http:应用层协议基于tcp/ip协议 http协议,规定了数据包的内容和结构,规定了请求方式等内容 浏览器-&gt;打请求包-&gt;服务器-&gt;服务器解请求包 服务器-&gt;打响应包-&gt;浏览器-&gt;浏览器解响应包 http://locaohost:8888/1712ServletDay02_01Hello/hello?name=abc http请求包数据: GET /1712ServletDay02_01Hello/hello?name=abc HTTP/1.1 Host: localhost:8080 主机地址 Connection: keep-alive 连接状态 Upgrade-Insecure-Requests: 1 //浏览器信息User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,/;q=0.8Accept-Encoding: gzip, deflate, sdchAccept-Language: zh-CN,zh;q=0.8 响应数据包 HTTP/1.1(协议版本号) 200(状态码) OK(状态信息) Server: Apache-Coyote/1.1(服务器信息) Content-Type: text/html;charset=utf-8(响应数据类型及字符集) Content-Length: 21(数据长度) Date: Tue, 03 Apr 2018 07:44:01 GMT(当前时间) http请求包中包含:请求头和请求体 http响应包中包含:响应头和响应体 请求方式:GET和POST GET: 请求参数放在请求地址的后面 提交的数据量比较小(大小在2k左右的数据) 不能提交敏感信息因为在地址栏中可能会显示出来,或者某些路由器会保存请求地址中的信息 浏览器什么时候会发出get请求: 在地址栏中发出的请求就是get请求 form表单默认的请求方式就是get 点击超链接所发出的请求也是get POST: 会将请求参数放在请求体里面,没有大小限制 敏感信息相对安全 浏览器什么时候会发出post请求 只有当表单的提交方式修改为post的时候 Servlet中service 和doGet/doPost的关系当Servlet组件被tomcat容器调用执行的时候会先执行service方法,在Service方法中判断请求方式是get就访问doGet 如果是post就访问doPost 获取请求头里面的数据 String uri = request.getRequestURI(); StringBuffer url = request.getRequestURL(); String httpVersion = request.getProtocol(); 设置响应头数据1234//设置响应数据类型和字符集response.setContentType("text/html;charset=utf-8");//设置刷新时间response.setHeader("refresh", "3;info.html"); 乱码响应数据有中文 response.setContentType(&quot;text/html;charset=utf-8&quot;);请求参数有中文 get请求: new String(gender.getBytes(&quot;iso8859-1&quot;),&quot;utf-8&quot;); 修改server配置文件 65左右 &lt;Connector URIEncoding=”utf-8” post: 为什么出现乱码:在post表单提交数据的时候使用当前页面的解码格式进行编码,因为Request对象默认使用iso8859-1解码 所以需要使用以下方式解决乱码问题 解决方案:在获取参数之前添加以下代码request.setCharacterEncoding(&quot;utf-8&quot;); 以后写Servlet代码 需要添加以下两行代码12request.setCharacterEncoding("utf-8");response.setContentType("text/html;charset=utf-8"); 定时刷新及定时跳转 response.setHeader(&quot;refresh&quot;,&quot;2&quot;); response.setHeader(&quot;refresh&quot;,&quot;2;home.html&quot;); 如何隐藏关闭的工程 在左侧边栏右上角的小三角点击 点击 customView -&gt; filters-&gt;closed Project 如何分组显示项目 在左侧边栏右上角的小三角点击 点击Top level Element 选择Working set 然后重新点击小三角 选择select working set 在里面点击new -&gt;Java 给分组起名然后分配工程到此分组里面,也可以不分配之后以拖拽的方式分配项目 重定向 什么是重定向:让浏览器往另外一个地址重新发出请求 实现原理: 重定向命令会给浏览器返回一个302的状态码 和一个location的参数 ,浏览器接收到302状态码后会向location参数的地址发出请求 重定向案例: response.sendRedirect(request.getContextPath()+&quot;/FindAllServlet&quot;); 得到当前工程根路径的方式: request.getContextPath() 路径的匹配两种匹配方式: 精确匹配:web.xml中的url parttern要和请求地址一致 模糊匹配: 通过添加* 的方式让多个请求地址对应一个Servlet /*: *代表一个或多个未知,此地址会对应所有的动态资源地址(servlet地址) /abc /bcd /aaa /a/b/c /x/yhttp://localhost:8080/appname/(内容任意) /user/*:此匹配地址必须要求请求地址中必须是http://localhost:8080/appname/user/(内容任意) 后缀匹配 *.do(*.action)http://localhost:8080/appname/xxxx.do 浏览器输入一个地址查找资源的过程是怎样的?1. 在当前应用的web.xml中查找是否有与之匹配的动态资源路径(Servlet) 2. 如果匹配到则执行相对应的Servlet 3. 如果没有匹配到会使用默认的Servlet查找是否有同名的静态资源 4. 如果有则返回资源文件 5. 如果没有则页面会显示404(找不到资源) 总结:先找动态 然后找静态 都找不到就404 复制工程时注意事项 如果复制工程,需要在工程上右键properties-&gt;web settings修改里面的名称,此时的名称为复制之前工程的名称,修改成新工程的名字 Servlet的生命周期 什么是生命周期: 什么时候实例化 什么时候初始化 什么时候调用方法 什么时候销毁 实例化: 两种情况: 默认什么时候请求 什么时候实例化 web容器启动的时候实例化 需要在Web.xml中进行配置 &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;数值越小 优先级越高 初始化: 当请求地址在web.xml中匹配到相应的Servlet的时候 web容器会通过反射实例化Servlet对象 并且调用有参数的init方法 在有参数的方法中调用了无参的init()如果需要写初始化代码 重写无参的init(); 方法调用: service doget dopost web容器先实例化Servlet然后初始化Servlet 然后web容器调用service方法在Service方法中判断请求方式然后调用doget或doPost方法 销毁: 当工程从web容器(Tomcat)中卸载的时候执行 执行步骤: 实例化-&gt;初始化-&gt;方法调用-&gt;销毁 JSP 什么是JSP: Java Server Page java服务器页面是sun公司提供的一套动态页面规范 虽然直接使用Servlet也可以生成动态页面,但是操作过于繁琐(out.pringtln()),也不利于页面的维护,所以sun公司才提出了jsp规范 jsp实际上就是一个以.jsp结尾的文件,可以在此文件中写html(css/javaScript)也可以写Java代码片段,容器会将此文件转换成Servlet来执行总结:jsp文件的本质就是Servlet 如何创建jsp文件 创建一个file 名称为first.jsp 在jsp文件中可以写以下内容Html(包括css,JavaScript)直接写即可和操作html文件一样Java代码 两种写法: &lt;% java代码 %&gt; 转换成servlet时会直接照搬过去 &lt;%=java表达式 %&gt; 只能输出一行 等效out.println(java表达式)隐含对象 什么是隐含对象 在jsp中不用创建可以直接使用的对象称为隐含对象(比如:out,request,response,servletConfig…) 为什么可以直接用隐含对象 因为把jsp转成servlet的时候会自动生成创建这些对象的代码指令 什么是指令:告诉容器,将jsp转成servlet的时候所做的一些额外操作 比如 import contentType pageEncoding等 pageEncoding指令有些容器在读取磁盘中的jsp文件时默认的解码是iso-8859-1(tomcat默认是utf-8),但是通常jsp文本保存时选择的编码字符集是utf-8,为了保证编码和解码字符集一致所以在页面中通过pageEncoding属性设置解码字符集weblogic bea 收费 默认是iso-8859-1 jsp是如何执行的 容器会将jsp文件转成一个servlet html(css,js)—&gt;在_jspService中 通过out.write &lt;% %&gt; —-&gt; 直接原样照搬到_jspService中 &lt;%= %&gt;—-&gt; 在_jspService中 使用 out.print() 容器和调用其它servlet一样调用此Servlet 练习: 自己写一个jsp 显示当前时间 格式为 2018年10月20日 11点23分44秒 练习: 显示用户表中的所有用户信息 ###cellpadding 内容距td边框的距离 ###cellspacing td边框距table边框的距离 Servlet(显示 业务逻辑)Dao数据访问 JSP(显示 业务逻辑)Dao数据访问 ##三层架构JSP(显示)Servlet(业务逻辑)Dao数据访问案例:查询所有用户 Servlet: 执行查询数据的代码放在Servlet里面 JSP:控制显示的代码##转发一个web组件将未完成的工作交给另外一个web组件 web组件(Servlet和jsp)通常情况下是在Servlet里面获取数据,然后把数据交给Jsp显示浏览器发请求-&gt;Servlet -&gt; Jsp以前请求发送到Servlet或jsp 现在分层之后 先把请求发送到Servlet,在Servlet里面获取数据 然后把数据转发给Jsp显示浏览器发请求-&gt;Servlet浏览器发请求-&gt;Jsp##如何实现转发 把数据绑定到request对象上 可以绑定多个数据 request.setAttribute(“users”, users); 得到转发器 并调用forward方法 RequestDispatcher dispatcher =request.getRequestDispatcher(&quot;userlist3.jsp&quot;); dispatcher.forward(request, response); 注意:转发实际上就是web容器找到相对应的组件并且执行了组件的_jspService方法##转发的特点 转发的目的地有限制只能是应用内部的资源 转发后浏览器的地址栏不变###转发和重定向的区别: 浏览器地址栏有没有变化? -转发没有 -重定向有变化 能否共享Request和Response对象 -转发:可以共享,因为转发只有一次请求web容器只创建了一对Request和Response对象两个组件使用的是相同的 -重定向:不可以共享:因为两次请求,web容器创建了两对Request和Response 每个组件使用的是自己的Request和Response 访问地址有何区别 -转发:只能访问工程内部的资源 -重定向:可以访问任意地址 include 指令 引入一个jsp页面，实现页面复用 &lt;jsp:include page=&quot;file.jsp&quot;&gt; 路径相关问题 转发，重定向，表单提交，超链接 request.getDispatcher(&quot;&quot;) response.sendRedirect(&quot;&quot;) &lt;form action=&quot;&quot;&gt; &lt;a href=&quot;&quot;&gt;&lt;/a&gt; 相对路径 不以/开头的路径就是相对路径，此路径相对于当前组件的位置 如果想要找到上一级的资源需要加上 ../ 访问上上级的a.jsp : ../../a.jsp 绝对路径 假设工程名为web1 获取工程名 : request.getContextPath() 以/开头的路径是绝对路径 转发从工程名之后写 request.getDispatcher(&quot;/jsp/a.jsp&quot;) 直接省略前面的工程名 其他(重定向，超链接，表单提交)从工程名开始写 &lt;a href=&quot;&lt;%=request.getContextPath() %&gt;/jsp/a.jsp&quot;&gt; &lt;form action=&quot;&lt;%=request.getContextPath() %&gt;/jsp/helloServlet&quot;&gt; response.sendRedirect(&quot;&lt;%=request.getContextPath() %&gt;/jsp/a.jsp&quot;) 总结 以后工作中更多的使用的是绝对路径，可维护性和扩展性更好，相对路径可能会出现一个地方更改多个地方出现错误的情况 状态管理（数据管理）什么是状态管理 将浏览器和服务器之间的多次交互建立关系，此时需要数据建立关系，数据保存和修改称为状态管理。状态即是数据 Cookie 把少量数据保存在浏览器(客户端)的一种技术 cookie默认是保存在内存中，浏览器关闭则清除，如果设置了时间为0则立即清除，如果设置时间为正整数，则保存在磁盘中，时间到后自动删除 工作原理： 浏览器访问服务器时，服务器会将一些数据以setCookie的形式把数据存放到响应的消息头中，然后浏览器再次访问服务器时，会将Cookie数据放在请求的消息头中，这样服务器就能够得到之前请求时保存的一些数据，这样多次请求就能建立联系 服务器如何添加cookie： 123456//创建一个cookie对象Cookie cookie= new Cookie("name", "xiaoming");//设置cookie的过期时间，如果设置为0表示立即清除，如果没有设置那么浏览器关闭之后就会清除cookie.setMaxAge(100);//添加到响应头中，并且返回给浏览器response.addCookie(cookie); 此时在浏览器中就可以查看到这个cookie的值了(name属性对应的值) cookie时间： 如果Cookie没有设置时间，时间为负整数，cookie保存在内存中，如果浏览器关闭，则数据清除 如果cookie时间设置为0，是立即清除cookie的意思 如果设置成为大于0 的整数，此时的cookie会保存到磁盘中，当时间到了之后会自动删除 cookie.setMaxAge(100); 单位是秒 获取cookie的值 12345678910// 获取Cookie，返回的是一个数组 Cookie[] cookies = request.getCookies(); //如果Cookies存在，读取 if (cookies != null) &#123; for(Cookie cookie : cookies)&#123; System.out.println(cookie.getName()+" : " + cookie.getValue()); &#125; &#125;else &#123; System.out.println("其中没有cookie"); &#125; cookie的路径 如果不设置路径，默认会以当前组件的路径为准，只有当访问地址为当前组件地址或者组件地址的子地址时才会带上cookie 假设我们添加cookie的servlet为 http://localhost:8080/web1/cookie/setCookieServlet,那么我们的获取添加的cookie的servlet地址只有是http://localhost:8080/web1/cookie这个地址的子地址(后代),比如http://localhost:8080/web1/cookie/user/getCookieServlet 为cookie设置路径 cookie.setPath(“/“); 举例： 如果设置path为 /a /a/servlet1 : yes /b/servlet2 : no cookie的编码问题 cookie只能保存英文，不能保存中文，如果需要保存中文，那么需要编码 中文编码 1234567891011String name="小明";//对中文进行url编码name=URLEncoder.encode(name,"utf-8");//创建一个cookie对象Cookie cookie= new Cookie("name", name);//设置cookie的过期时间，如果设置为0表示立即清除，如果没有设置那么浏览器关闭之后就会清除cookie.setMaxAge(100);System.out.println(cookie.getPath());//添加到响应头中，并且返回给浏览器response.addCookie(cookie); 将获取的中文cookie解码输出 12345678910111213// 获取Cookie，返回的是一个数组Cookie[] cookies = request.getCookies();//如果Cookies存在，读取if (cookies != null) &#123; for(Cookie cookie : cookies)&#123; String value=cookie.getValue(); //把cookie的值取出，然后url解码 value=URLDecoder.decode(value,"utf-8"); System.out.println(cookie.getName()+" : " + value); &#125;&#125;else &#123; System.out.println("其中没有cookie");&#125; cookie的限制 cookie可以被用户禁止 cookie不安全 ，对于敏感信息一定要加密 cookie的数据大小有限制，大约4k左右 cookie总数也有限制，大约200个左右 使用cookie记录客户端访问次数1234567891011121314151617181920212223242526272829@Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Cookie[] cookies = request.getCookies(); Map&lt;String, String&gt; map = getValues(cookies); //获取map String stringCount = map.get("count"); // 获取指定的value if (stringCount == null) &#123;// 第一次请求 stringCount = "1"; // 设置访问次数为1 &#125; else &#123;// 不是第一次请求 // 请求次数+1 stringCount = "" + (Integer.parseInt(stringCount) + 1); &#125; Cookie cookie = new Cookie("count", stringCount); // 把运行次数放置到cookie中 response.addCookie(cookie); // 添加cookie,如果前面已经存在了，那么相当于更新cookie的值 System.out.println(stringCount); &#125; /** * 将cookie数组中的键值对存放到Map中,这样就能判断出这个cookie中是否含有指定的key */ public Map&lt;String, String&gt; getValues(Cookie[] cookies) &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); if (cookies != null) &#123; for (Cookie cookie : cookies) &#123; map.put(cookie.getName(), cookie.getValue()); &#125; &#125; return map; &#125; 使用cookie保存登录的用户名和信息 需求： 当用户选择了记住用户名和密码的选项，那么当用户登录成功的时候，接下来每次请求登录页面的时候浏览器会自动显示之前成功登录的用户名和密码 实现： 一个单选按钮，选择是否记录登录信息，jsp页面 在表单提交给servlet之后，验证用户是否登录成功，如果登录成功了并且还选择了记住用户名和密码，那么就将此时的用户名和密码信息添加到cookie中 在每次跳转到登录页面的时候都需要经过一个Servlet，这个Servlet的作用是获取cookie的值，并且存放在request域中，这样在login.jsp页面中就可以使用这个值 login.jsp 123456789101112131415161718192021222324252627&lt;form action="/Servlet01/RememberLoginServlet" method="post"&gt; &lt;table cellpadding="0" cellspacing="0" border="0" class="form_table"&gt; &lt;tr&gt; &lt;td valign="middle" align="right"&gt;username:&lt;/td&gt; &lt;td valign="middle" align="left"&gt;&lt;input type="text" class="inputgri" name="username" value="&lt;%=request.getAttribute("username") %&gt;" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign="middle" align="right"&gt;password:&lt;/td&gt; &lt;td valign="middle" align="left"&gt;&lt;input type="password" class="inputgri" name="password" value="&lt;%=request.getAttribute("password") %&gt;" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td valign="middle" align="left"&gt; &lt;input type="checkbox" name="isRemember"&gt;记住用户名和密码一周 &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;p&gt; &lt;input type="submit" class="button" value="Submit &amp;raquo;" /&gt; &lt;/p&gt; &lt;/form&gt; 验证用户，保存信息到cookie中的servlet 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Overrideprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding("UTF-8"); // 设置中文格式 //设置响应字符集必须写在获取输出对象的前面 response.setContentType("text/html;charset=utf-8"); PrintWriter writer=response.getWriter(); // 获取用户名和密码 String username = request.getParameter("username"); String password = request.getParameter("password"); String isRemeber = request.getParameter("isRemember"); // 登录流程 Connection connection = null; PreparedStatement statement = null; ResultSet resultSet = null; try &#123; connection = DBUtils.getConn(); // 获取连接 String sql = "select count(*) c from user where username=? and password=?"; statement = connection.prepareStatement(sql); //创建预编译对象 //设置占位符的值 statement.setString(1, username); statement.setString(2, password); resultSet = statement.executeQuery(); // 执行查询语句 //遍历查询结果集，如果count&gt;0 表示登录成功，如果=0表示用户名或密码错误 while (resultSet.next()) &#123; int count = resultSet.getInt("c"); // 获取总数 if (count &gt; 0) &#123; System.out.println("登录成功"); // 判断是否记住密码 //如果设置了记住密码，那么就将此时的用户名和密码保存在cookie中 if (isRemeber != null) &#123; //将username和password添加到cookie中 Cookie cookie=new Cookie("loginInfo", username+","+password); cookie.setMaxAge(7*24*3600); //设置时间为一周，单位为秒 response.addCookie(cookie); &#125; //跳转到首页 request.getRequestDispatcher("home.jsp").forward(request, response); &#125; else &#123; System.out.println("登录失败，用户名或密码错误"); response.sendRedirect("/Servlet01/ShowLoginCookieServlet"); //重定向到登录界面 &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); writer.write("服务器出错....."); &#125; finally &#123; DBUtils.close(connection, statement, resultSet); // 关闭资源 &#125;&#125; 获取cookie值，存放到request域中，便于在login.jsp页面中访问到信息 1234567891011121314151617181920212223242526272829@Overrideprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Cookie[] cookies = request.getCookies(); Map&lt;String, String&gt; map = getValues(cookies); String loginInfo = map.get("loginInfo"); // 获取cookie的值 String username = ""; String password = ""; if (loginInfo != null) &#123; username = loginInfo.split(",")[0]; // 分割字符串，获取信息 password = loginInfo.split(",")[1]; &#125; request.setAttribute("username", username); request.setAttribute("password", password); request.getRequestDispatcher("login.jsp").forward(request, response);&#125;/** * 将cookie数组中的键值对存放到Map中,这样就能判断出这个cookie中是否含有指定的key */public Map&lt;String, String&gt; getValues(Cookie[] cookies) &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); if (cookies != null) &#123; for (Cookie cookie : cookies) &#123; map.put(cookie.getName(), cookie.getValue()); &#125; &#125; return map;&#125; Session 服务端为了保存状态（数据）创建的一个特殊的对象，session数据会保存在服务器 工作原理 当浏览器第一次向服务器请求，服务器创建一个session对象，然后把session对象的唯一标识sessionid以cookie的形式返回给浏览器，服务器通过sessionid找到上次保存的session对象，这样的话多次请求只需要把数据保存在session对象中， 如何创建Session对象 HttpSession session=request.getSession(boolean flag) 参数为false，如果不存在这个session，那么就返回一个null 参数为true，会通过cookie中的sessionid获取之前保存的session对象，如果有则返回，如果没有则创建一个新的session，这个是默认的形式（缺省值为true） 添加删除数据 setAttribute(key,value) getAtttribute(key,value) removeAttribute(key) session超时 session默认时间是在服务器保存30分钟 如何修改session存活时间 修改配置文件 在servers中的web.xml中查找如下123&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt; 通过代码设置时间 session.setMaxInactiveInterval(int mils); 单位为秒 删除session session.invalidate() 删除session中的数据 session.removeAttribute(key) 实现自动登录（Session) 这个在学到过滤器的时候再讲 Base64加密 什么是Base64： 将任意二进制数据转换成字符串（由64个基础字符组成a-z A-Z 0-9 + /),可以将需要加密的字符串转换成二进制数据后再转换成Base64的字符串，也可以把任意文件的二进制数据转换成可见的字符串 123456789String pw="admin";BASE64Encoder encoder=new BASE64Encoder();String newPW=encoder.encode(pw.getBytes("utf-8"));System.out.println(newPW);//解密BASE64Decoder decoder=new BASE64Decoder();String oldPw=new String(decoder.decodeBuffer(newPW),"utf-8");System.out.println(oldPw); 比较cookie和Session cookie： 优点不占用服务器资源，缺点：大小有限制4k 数量限制200左右 内容有限制只能存放字符串，cookie不够安全而且有些浏览器可以模拟cookie数据 Session： 优点:安全（因为数据保存在服务器）大小无限制，保存数据类型丰富，缺点： 占用资源，浏览器关闭后Session则失效,因为session的是状态是存储在cookie中的seessionid决定的。 自动登录加强版 需要自己创建一个cookie 过滤器什么是过滤器 Servlet规范中定义的是一种特殊组件，用来拦截web容器调用Servlet/jsp组件的过程 好处： 可以在不改动Servlet的情况下增加业务功能，可以起到代码复用的作用，因为一个过滤器可以对应拦截多个Servlet 如何创建一个过滤器 new - &gt; Filter 这样就创建一个过滤器，其中的类实现了Filter这个接口 12345678910111213141516171819public class MyFilter implements Filter &#123; public MyFilter() &#123; &#125; public void destroy() &#123; System.out.println("过滤器被销毁"); &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println("过滤器执行"); chain.doFilter(request, response); &#125; public void init(FilterConfig fConfig) throws ServletException &#123; System.out.println("过滤器初始化"); &#125;&#125; 这个类中同样有init和destroy方法，但是实现代码逻辑实在doFilter()这个方法中 在web.xml中配置这个过滤器1234567891011&lt;!-- 配置Filter 的name和class --&gt; &lt;filter&gt; &lt;filter-name&gt;MyFilter&lt;/filter-name&gt; &lt;filter-class&gt;cn.filter.MyFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;!-- 配置Filter的过滤的url，其中的name是前面定义好的 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;MyFilter&lt;/filter-name&gt; &lt;!-- /* 拦截所有的Servlet,但是也拦截器了这个路径下的jsp ，如果设置成/MyServlet,那么只拦截这一个Servlet--&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 过滤器的生命周期 创建： 无参构造方法，当web容器启动时，会自动创建过滤器 初始化： init()方法 当过滤器创建后会自动调用 销毁: destroy()方法 当应用程序从web容器中卸载时 doFilter(): 当调用被拦截器的Servlet或者jsp的时候执行，在此方法中执行doFilter方法相当于执行Servlet里面的Service方法，因为过滤器里面的Request和Response对象和Servlet中的是同一对象，所以在Servlet里面做的任何事都可以在过滤器中实现 案例： 实现评论功能 如果出现了敏感字符禁止访问 步骤 准备一个Comment.jsp页面，页面中有一个文本框和一个提交按钮 如果出现敏感信息禁止提交，并跳转到原页面重新填写评论 123456public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest req=(HttpServletRequest)request; //继续执行下面的Filter和Servlet，没有这个方法，那么将不会执行 chain.doFilter(request, response); &#125; 如果配置多个过滤器拦截器同一个请求地址 此时多个过滤器都会响应，哪个先执行，取决于在web.xml中哪个过滤器先配置，先配置的先执行 &lt;init-param&gt;设置初始化值 配置Filter 的初始化值，在web.xml中定义 其中的 12345678&lt;filter&gt; &lt;filter-name&gt;CommentFiletr&lt;/filter-name&gt; &lt;filter-class&gt;cn.filter.CommentFiletr&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;word&lt;/param-name&gt; &lt;param-value&gt;美女,我操&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt; 获取其中的值 在init中初始化FilterConfig对象 在doFilter中使用FilterConfig对象获取初始化值即可123456789101112131415161718192021public class CommentFiletr implements Filter &#123; private FilterConfig config; //定义成员变量FilterConfig对象 public CommentFiletr() &#123; &#125; public void destroy() &#123; &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; String word=this.config.getInitParameter("word"); //获取初始化值 chain.doFilter(request, response); &#125; //初始化方法 public void init(FilterConfig fConfig) throws ServletException &#123; this.config=fConfig; &#125;&#125; ServletContext（上下文） 定义： web服务器启动的时候会为每一个应用创建一个符合ServletContext接口的对象 特点： 唯一性： 整个工程中只有一个 持久性： 只要容器不关闭，整个ServletContext对象就会存在于内存中 应用场景： 负责传递数据（共享数据），任何一个组件往ServletContext对象中保存数据都可以给整个工程的所有Servlet访问 可以在web.xml中获取全局的初始化数据 如何配置参数 在web.xml中配置即可 如果想要配置多个，那么可以定义多个&lt;context-param&gt;即可 1234&lt;context-param&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;陈加兵&lt;/param-value&gt;&lt;/context-param&gt; 在组件中获取ServletContext(在任何组件中都可以获取) 在Servlet中获取 1234protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; ServletContext context=this.getServletContext(); //获取对象 String name=context.getInitParameter("name"); //获取name属性的值&#125; 在Filter中获取 12345//初始化方法public void init(FilterConfig fConfig) throws ServletException &#123; ServletContext context=fConfig.getServletContext(); String name=context.getInitParameter("name");&#125; 添加和获取数据 getAttribute(key) setAttribute(key,value) Request,Session,ServletContex，PageContext作用范围 ServletContext &gt; Session &gt; Request &gt; PageContext 如何选择传递数据的域：符合需求的域中，选择范围最小的 监听器 Listener什么是监听器 Servelt规范中定义的一个特殊组件，用来监听容器内部各组件的事件 组件会有两大类事件 生命周期相关事件(比如session的创建的和销毁) 绑定数据相关事件 如何创建监听器Listener new --- &gt; Listener ---&gt; 类名 ---&gt; next -- &gt; 选择对应的Listener 具体的选项如下图 选项中有三大域的监听器，ServletContext，Session，Request 其中Liftcycle 是 生名周期金监听器 其中可以监听三大域的创建和销毁-Change to Attributes 是三大域绑定删除数据监听器 创建成功之后会在web.xml中自动为我们填上监听器的配置 123&lt;listener&gt; &lt;listener-class&gt;cn.listener.MyListener&lt;/listener-class&gt;&lt;/listener&gt; 统计在线人数 当开始一个会话将会就表示在线人数+1，因此需要监听Session的生命周期 因为我们是统计在线人数，因此我们需要在jsp页面中显示出人数，我们需要将在线人数这个变量存放在ServletContext才能实现共享，这样只有当web容器关闭才会清空其中的在线人数 如果存放在session中，那么当浏览器关闭就会清空session中的数据，或者到了指定的时间也会清空，因此我们不能存放在Session 创建一个监听Session的监听器 1234567891011121314151617181920212223242526272829public class MyListener implements HttpSessionListener &#123; //Session创建时调用的方法 public void sessionCreated(HttpSessionEvent sessionEvent) &#123; System.out.println("会话开始"); // 取出当前在线人数 ServletContext context = sessionEvent.getSession().getServletContext(); // 得到ServletContext Integer count=(Integer) context.getAttribute("count"); //获取当前的在线人数 // 如果count是第一次，那么此时的count就是null，因为这里还没有设置这个上下文参数 if (count == null) &#123; count = 1; &#125; else &#123; count++; &#125; // 将在线人数保存回去 context.setAttribute("count",count); &#125; //Session销毁时调用的方法 public void sessionDestroyed(HttpSessionEvent event) &#123; System.out.println("会话结束"); ServletContext context = event.getSession().getServletContext(); Integer count=(Integer) context.getAttribute("count"); //获取当前的在线人数 count--; // 直接人数-1 // 将此时的人数保存回去 context.setAttribute("count",count); &#125;&#125; 缓存数据练习 创建一ServletContext生命周期监听器，在ServletContext创建的的方法中读取数据库中的数据并将数据保存在ServletContext中，因为ServletContext在容器创建的时候就会创建，因此在web容器开启的时候就会读取数据库中的信息 我们在Servlet中直接读取ServletContext中的数据即可，不同在请求Servlet的时候从数据库中读取，提高Servlet的响应效率 好处 在我们使用同一种数据的时候，并且数据常用，我们可以在web容器启动的时候就加载出来，不用每次用到该数据就请求一次读取数据库一次，提高了效率 代码123456789101112131415public class CacheListener implements ServletContextListener &#123; //ServletContext销毁的时候调用 public void contextDestroyed(ServletContextEvent event) &#123; System.out.println("销毁"); &#125; //ServletContext初始化的时候调用 public void contextInitialized(ServletContextEvent event) &#123; ServletContext context=event.getServletContext(); //获取ServletContext对象 EmpDao empDao=new EmpDao(); //创建Dao对象，用于读取数据库中的信息 List&lt;Emp&gt; emps=empDao.findAll(); //获取所有的数据 context.setAttribute("emps", emps); //添加到ServletContext中 &#125;&#125; 各组件执行顺序 MyServlet、MyListener(监听ServletContext),MyFilter web容器启动 – &gt; MyListener(监听) — &gt; MyFilter实例化 – &gt; 请求 —&gt; MyFilter(doFilter) —&gt; 执行MyServlet Servlet线程安全问题为什么 为什么会有线程安全问题：因为每一个请求 服务器都会开启一条新的线程来执行，这样的话如果请求量比较大出现高并发访问就会出现多条线程同时执行，如果多一条线程执行的过程中，有需要去修改同一份数据，则有可能出现线程安全问题，即一条数据没有处理完，另外一条数据把数据取走 解决方案 通过同步代码块，将可能会出现线程安全的代码包裹起来，这样就可以解决线程安全问题 实例 假设我们的线程不安全的Servlet如下 12345678910111213141516171819public class ThreadSafeServlet extends HttpServlet &#123; private int count = 0; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(Thread.currentThread().getName() + "：开始执行" + count); try &#123; Thread.sleep(5000); //线程睡眠5s &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; count++; System.out.println(Thread.currentThread().getName() + "：执行完毕" + count); &#125;&#125; 我们在浏览器多次请求这个servlet，那么我们可以看到输出的每一个开始执行的count的值都是0，但是我们后面都count++了，从此可以看出线程不安全，那么我们添加一个同步代码块来确保线程安全 123456789101112131415161718192021public class ThreadSafeServlet extends HttpServlet &#123; private int count = 0; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //同步代码块 synchronized (this) &#123; System.out.println(Thread.currentThread().getName() + "：开始执行" + count); try &#123; Thread.sleep(5000); //线程睡眠5s &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; count++; System.out.println(Thread.currentThread().getName() + "：执行完毕" + count); &#125; &#125;&#125; JSP扩展什么是JSP java Server page java服务器页面 jsp文件部署到web容器时会自动转成Servlet组件，添加到容器中 如何写jsp java代码的写法 &lt;% %&gt; 写java代码，任意java代码都行，转化成Servlet的时候直接是写在service方法体中 &lt;%! %&gt; 声明变量或者方法，转换成Servlet的时候直接作为其成员变量或者成员方法 &lt;%= %&gt; java表达式，返回的是一个值 指令 高速容器，将jsp转成Servlet的时候所做的一些额外操作 &lt;%@ page&gt; ： import导包 contentType pageEncoding session的默认值为true，如果值为false，则在java代码中不能使用session隐式对象 errorPage :指定jsp里面出现异常时显示的页面 isErrorPage : 设置当前页面为错误异常页面，默认为false，设置为true之后页面中才可以使用exception获取异常信息 tablib ： 引入标签库 JSP中隐式对象什么是隐式对象 在JSP中可以不用创建，可以直接使用的对象 为什么可以直接使用 因为将JSP转成Servlet类的时候会自动创建的对象 有哪些 （九大隐式对象) 面试中常考 application ： 类型为ServletContext，该实例表示jsp所属的web应用本身，可以用于多个组件间共享或传递数据，常用方法有setAttribute(),getAttribute(),removeAttribute()和getInitParameter() session : 类型为HttpSession，用于在同一个会话中共享数据，常用方法有setAttribute(),getAttribute(),removeAttribute() request ：类型HttpServeltRequest，用于在同一个请求中共享数据，常用方法有setAttribute(),getAttribute(),removeAttribute() pageContext : 用于在同一个jsp中共享数据，常用方法有setAttribute(),getAttribute(),removeAttribute() 12345&lt;%pageContext.setAttribute("name", "陈加兵");%&gt;&lt;h1&gt;&lt;%=pageContext.getAttribute("name") %&gt;&lt;/h1&gt; response : 类型HttpServletResponse,用于处理响应数据和重定向，因为有out，更多使用的是out out ： 类型为JSPWriter，用于输出数据 page ： page就是jsp本身，因为jsp最终会转成Servlet，page相当于this exception : 异常对象，用于获取异常信息，只有当page指令里面添加了isErrorPage=true的时候才能使用 config ： 类型为ServletConfig，用于获取配置文件中初始化参数 JSP的注释 &lt;!--注释内容--&gt; ： 代码会被注释但是代码会被执行 &lt;%-- 注释内容 --%&gt; ： 代码会被注释，不会执行 JSP如何执行的 将JSP转成Servlet 调用Servlet JSP标签和EL表达式什么是jsp标签 是sun公司提供的一套类似于html标签的内容，用于替换jsp中出现的java代码 因为在jsp中写java代码不利于维护，代码的可读性也很差，以后工作时显示相关的内容很可能交给前端工程师或者美工，所以在jsp中尽量不要出现java代码，所以才产生了jsp标签 什么是EL表达式 一套简单的运算规则，用于从域对象中取值，然后给jsp中标签的属性赋值 EL表达式的使用(${}) 访问Bean对象中的属性(属性必须有get方法) ${对象名.属性名},假设一个对象user，访问其中的name属性，我们可以使用 ${user.name}，这个相当于调用了user.getName()方法 EL表达式执行过程 ${user.name} 会先从pageContext域中查找如果有则用，如果没有会到request域中查找，如果没有再到session域中查找，如果没有再到ServletContext中查找 如果找不到直接输出空字符串&quot;&quot;,如果没有获取到对象调用对象的方法不会报空指针异常，仍然输出空字符串 指定域获取 ${requestScope.user.name} 相当于 request.getAttribute(&quot;user&quot;).getName() pageScope requestScope sessionScope applicationScope ${user[&#39;name&#39;]} 个人不推荐使用 使用EL表达式获取请求参数(使用不多，一般都是在Servlet获取) 直接使用${param.请求参数名} 获取指定的请求参数 ${param.name} 相当于request.getParameter(&quot;name&quot;) ${paramValues.参数名[index]} 获取多个同名参数 相当于request.getParameterValues(&quot;参数名&quot;)[index] EL表达式的简单运算 运算结果可以直接给标签的属性赋值 算术运算符 可以直接使用加减乘除 ${1+2},${5/2},${5*3} 注意： +只能做求和运算，不能字符串拼接 逻辑运算符 ${true and false}=false,${true and true}=true,${true or false}=true 关系运算符 使用 ==, != , &gt;=,&lt;, &gt; , &lt;= , &amp;&amp; , || 如： ${age&lt;30} 可以直接在EL表达式比较大小，返回的也是false和true，可以用来判断，如下：${1&lt;2}=false ,${(10*10)&gt;200}=true,${age&gt;11&amp;&amp;age&lt;20} empty 判断是否为空(空字符串或者值为null) 判断字符串为null或者为空字符串 判断数组，值为null和不为null但是数组里面没有数据都会返回true 判断对象为null ${empty str} 判断字符串是否为空 ${empty user} 判断对象user是否为空 jstl java standard tab lib （java标准标签库） jstl是Apache开发的一套jsp标签 如何使用 导入jstljar包,使用maven，在pom.xml中添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt; 通过tablib指定引入标签库 &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; ， uri：是标签库的命名空间，代表标签库的唯一标识，prefix ：别名或前缀 几个核心标签 if标签， &lt;c:if test=&quot;&quot;&gt; test中填写的是判断条件，使用EL表达式 var ： test中的判断结果，如果test中的判断为真，那么此时var的变量值为true scope ： 将var中的变量存放到指定的域中，便于直接访问12345678910&lt;% request.setAttribute("age", 22);%&gt;&lt;c:if test="$&#123;requestScope.age&gt;20 &#125;"&gt; &lt;h1&gt;&lt;c:out value="年龄大于20"&gt;&lt;/c:out&gt;&lt;/h1&gt;&lt;/c:if&gt;&lt;c:if test="$&#123;requestScope.age&gt;10 &#125;" var="result" scope="session"&gt; &lt;h2&gt;此时的判断结果为 : $&#123;sessionScope.result &#125;&lt;/h2&gt;&lt;/c:if&gt; choose标签 （相当于switch case） 需要和 when，otherwise结合使用1234567891011121314151617&lt;%User user=new User();user.setUsername("libai");user.setPassword("admin");request.setAttribute("user", user);%&gt;&lt;c:choose&gt; &lt;c:when test="$&#123;user.username=='libai' &amp;&amp; user.password=='admin' &#125;"&gt; &lt;h1&gt;登录成功&lt;/h1&gt; &lt;/c:when&gt; &lt;!-- 其他的任何类型的判断，只要不是when中的，都在这里执行，相当于else --&gt; &lt;c:otherwise&gt; &lt;h1&gt;登录失败&lt;/h1&gt; &lt;/c:otherwise&gt;&lt;/c:choose&gt; forEach标签 相当于java中的forEach，由于遍历集合或者数组 items : 需要遍历的集合或者数组 var ：遍历的对象的变量名称，遍历时会把当前遍历的对象绑定在PageContext域中，需要获取遍历对象的内容时直接使用EL表达式从域中获取出来 begin ： 开始的索引 end ： 结束的索引 step ： 指定步长，默认的步长为1 varStatus : 遍历的状态，如果需要得到遍历对象的下标调用index，如果想要得到遍历对象是集合中的第几个调用count 1234567891011121314151617181920212223&lt;table width="500" border="1"&gt; &lt;tr&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;th&gt;密码&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;级别&lt;/th&gt; &lt;th&gt;下标&lt;/th&gt; &lt;th&gt;第几个&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach var="user" items="$&#123;requestScope.users &#125;" begin="0" end="19" step="1" varStatus="s"&gt; &lt;c:if test="$&#123;s.index%2==0 &#125;"&gt; &lt;tr id="row1"&gt; &lt;/c:if&gt; &lt;c:if test="$&#123;s.index%2!=0 &#125;"&gt; &lt;tr id="row2"&gt; &lt;/c:if&gt; &lt;td&gt;$&#123;user.username &#125;&lt;/td&gt; &lt;td&gt;$&#123;user.password &#125;&lt;/td&gt; &lt;td&gt;$&#123;user.gender &#125;&lt;/td&gt; &lt;td&gt;$&#123;user.level &#125;&lt;/td&gt; &lt;!-- 下标 --&gt; &lt;td&gt;$&#123;s.index &#125;&lt;/td&gt; &lt;!-- 第几个 --&gt; &lt;td&gt;$&#123;s.count &#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt; 自定义标签 简单标签技术 复杂标签技术：支持标签内部写java代码 简单标签技术(继承SimpleTagSupport) 创建自定义标签的类(继承SimpleTagSupport) get，set方法必须1234567891011121314151617181920212223242526272829303132import java.io.IOException;import java.io.PrintWriter;import javax.servlet.jsp.JspException;import javax.servlet.jsp.JspWriter;import javax.servlet.jsp.PageContext;import javax.servlet.jsp.tagext.SimpleTagSupport;public class HelloTag extends SimpleTagSupport &#123; private int count; //标签的属性count private String msg; //属性msg @Override public void doTag() throws JspException, IOException &#123; PageContext context=(PageContext) this.getJspContext(); //获取PageContext隐式对象 JspWriter out=context.getOut(); //获取JSPWriter对象，用于在JSp页面中输出内容 for(int i=0;i&lt;count;i++)&#123; out.println(msg+"&lt;br/&gt;"); &#125; &#125; public int getCount() &#123; return count; &#125; public void setCount(int count) &#123; this.count = count; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125;&#125; 定义hello.tld文件(WEB-INF下) 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!-- 约束不用改写，直接copy --&gt;&lt;taglib xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd" version="2.1"&gt; &lt;!-- 标签库的版本号 --&gt; &lt;tlib-version&gt;1.1&lt;/tlib-version&gt; &lt;!-- 推荐别名 --&gt; &lt;short-name&gt;d&lt;/short-name&gt; &lt;!-- 随便起，只要保证唯一性即可，这个是唯一标识 --&gt; &lt;uri&gt;http://www.tedu.cn/hello&lt;/uri&gt; &lt;tag&gt; &lt;!-- 标签名 --&gt; &lt;name&gt;hello&lt;/name&gt; &lt;!-- 标签的类，自定义的类 --&gt; &lt;tag-class&gt;cn.servlet.HelloTag&lt;/tag-class&gt; &lt;!-- 设置成没有标签体 --&gt; &lt;body-content&gt;empty&lt;/body-content&gt; &lt;!-- 定义标签的属性 --&gt; &lt;attribute&gt; &lt;!-- 属性的名字 --&gt; &lt;name&gt;msg&lt;/name&gt; &lt;!-- 是否设置成必须的 --&gt; &lt;required&gt;true&lt;/required&gt; &lt;!-- 是否运行EL表达式赋值 --&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;attribute&gt; &lt;name&gt;count&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;/tag&gt;&lt;/taglib&gt; 在jsp中引入这个标签库 1234&lt;!-- 引入自定义的标签库 --&gt;&lt;%@ taglib prefix="d" uri="http://www.tedu.cn/hello"%&gt;&lt;d:hello count="20" msg="陈加兵"/&gt; &lt;body-content&gt; 其中可以写以下三种内容 JSP ： 有标签体而且标签体内可以写java代码(只有复杂标签技术才支持) empty ：没有标签体 scriptless ： 有标签体，但是标签体内不能写java代码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hibernate关联查询]]></title>
      <url>%2F2018%2F04%2F24%2FHibernate%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%2F</url>
      <content type="text"><![CDATA[Hibernate关联查询关联查询之延迟加载(lazy)什么是延迟加载 前面单独讲过延迟加载就是在根据id查询获取的对象中只是有一个id的属性值，只有当使用其他属性的时候才会发出sql语句查询数据库，session.load(Class&lt;T&gt; cls,id)就是这个原理 什么是关联查询的延迟加载 简单的说就是在关联关系中，根据id查询对象的时候仅仅发出sql语句查询的是当前的实体类的表，并没有查询另外一张表的数据，只有当需要使用另外一张表的对象中的属性时才会发出sql语句查询另外一张表 一对一 在一对一的关系中默认使用的不是延迟加载，而是饿汉式的加载方式(EAGER),即是查询一个对象，并且也会随之查询另外一个对象的数据，发出的sql语句是左外连接查询 使用懒加载可以减轻数据库服务器的压力，只有当用到数据的时候才会发出select语句查询 我们可以使用@OneToOne(fetch=FetchType.LAZY)其中的fetch有两个值，一个是FetchType.LAZY(懒加载)，一个是FetchType.EAGER(饿汉式) 测试 使用前面讲过的Student和Teacher类 测试默认的情况(饿汉式的加载) 由于是默认的就是饿汉式的查询方式，因此不需要改变实体类 测试方法 我们根据id查询husband的数据，这里发出的sql语句是左外连接语句，相当于：select * from husband h left join wife w on h.wifeid=w.id where h.id=? 123456789101112131415161718192021222324252627@Test public void Test1() &#123; Session session = null; Transaction transaction = null; try &#123; // 创建session session = HibernateUntil.getSession(); // 开始事务 transaction = session.beginTransaction(); //查询id=1的husband数据，这里将会使用左外连接查询数据，直接联表查询 Husband husband=session.get(Husband.class, 1); //获取Husband中的Wife对象属性 Wife wife=husband.getWife(); //输出wife的属性age的值，由于前面已经查询过了，因此这里不再发出sql语句 System.out.println(wife.getAge()); // 提交事务 transaction.commit(); &#125; catch (Exception exception) &#123; transaction.rollback(); // 事务回滚 &#125; finally &#123; if (session!=null) &#123; session.close(); &#125; &#125; 测试懒加载 需要在@OneToOne注解中添加fetch属性，我们测试单向外键关联的懒加载(通过Husband类访问Wife的信息) Husband类，使用懒加载 12345678910111213141516171819202122232425262728293031323334353637383940414243@Entity //指定实体类@Table(name="husband") //指定对应数据库的表名为husbandpublic class Husband &#123; private int id; private String name; private int age; private Wife wife; //Wife对象 @Id @GeneratedValue //主键生成策略，自增长 public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; @OneToOne(fetch=FetchType.LAZY) //设置wife的主键为Husband的外键，默认的对应表中的字段为wife_id @JoinColumn(name="wifeid") // 默认外键的名字为wife_id.我们使用这个注解改变外键的名字为wifeid public Wife getWife() &#123; return this.wife; &#125; public void setWife(Wife wife) &#123; this.wife = wife; &#125; @Column(length=20) //设置长度为20 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Husband [id=" + id + ", name=" + name + ", age=" + age + ", Wife=" + this.wife + "]"; &#125;&#125; 测试方法 12345678910111213141516171819202122232425262728@Test public void Test1() &#123; Session session = null; Transaction transaction = null; try &#123; // 创建session session = HibernateUntil.getSession(); // 开始事务 transaction = session.beginTransaction(); //查询id=1的husband数据，这里使用懒加载，只会查找husband的表，并不会联表查询 Husband husband=session.get(Husband.class, 1); //获取Husband中的Wife对象属性，此处依然没有查询wife表 Wife wife=husband.getWife(); //输出wife的属性age的值，此处发出sql语句查询wife表，验证了只有当用到的wife属性的时候才会发出查询语句 System.out.println(wife.getAge()); // 提交事务 transaction.commit(); &#125; catch (Exception exception) &#123; transaction.rollback(); // 事务回滚 &#125; finally &#123; if (session!=null) &#123; session.close(); &#125; &#125; &#125; 总结 默认使用的饿汉式的查询方式，因此在访问数据量过大的时候，我们可以设置懒加载的方式 如果是双向外键关联的关系，我们可以在两个@OneToOne都设置fetch属性的值为懒加载 一对多或者多对一 如果是@ManyToOne的方式，那么默认的就是EAGER方式进行查找。当我们使用get语句查找Many的对象的时候，那么我们会看到发出的select语句其实也在查找作为其属性的One的那一方的信息，但是如果我们设置LAZY,那么使用get语句查找Many的时候将不会直接查找One的一方，而是在用到One的信息的时候才会发出select语句查找One的一方。可以提高性能，使用如下：@ManyToOne(fetch=FetchType.LAZY) 使用@OneToMany默认的fetch是LAZY，即是当查询One的一方的时候只是发出了查找One的一方的select语句。只有当调用其中的Many一方的对象的属性的时候才会发出select语句查询。 多对多 多对多的关联查询默认使用的懒加载(LAZY) 如果想要设置饿汉式加载，可以使用@ManyToMany(fetch=FetchType.EAGER)，这里就不在演示了 如果在双向外键关联中都要饿汉式加载，那么可以在两个@ManyToMany注解中设置属性]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hibernate关联关系]]></title>
      <url>%2F2018%2F04%2F24%2FHibernate%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%2F</url>
      <content type="text"><![CDATA[Hibernate关联关系一对一背景 在中国一个丈夫只能有一个妻子，那么丈夫和妻子的关系就是一对一的关系 准备 创建丈夫和妻子的实体类 丈夫的实体类 1234567891011121314151617181920212223242526272829303132@Entity@Table(name="husband")public class Husband &#123; private int id; private String name; private int age; @Id @GeneratedValue //主键生成策略，自增长 public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; @Column(length=20) //设置长度为20 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Husband [id=" + id + ", name=" + name + ", age=" + age + "]"; &#125;&#125; 妻子的实体类 123456789101112131415161718192021222324252627282930313233@Entity@Table(name="wife")public class Wife &#123; private int id; private String name; private int age; @Id @GeneratedValue //主键生成策略，自增长 public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; @Column(length=20) //设置长度为20 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Husband [id=" + id + ", name=" + name + ", age=" + age + "]"; &#125;&#125;个 单向外键关联 单向外键关联简单的说就是只能通过一张表访问到另外一张表的数据，不能也从另外一张表访问到这张表的数据。 比如：我们可以通过丈夫的信息访问到妻子的信息，那么在丈夫的表中就必须有妻子的外键。同样的，我们也可以通过妻子的信息访问到丈夫的信息，那么在妻子的表中必须有丈夫的外键。 简单的说就是只能单向访问，要么是通过妻子访问丈夫，要么是通过丈夫访问妻子 通过丈夫访问妻子 根据上面的需求，那么此时的妻子的主键将作为丈夫的外键，这样才可以通过丈夫访问到妻子的信息，其实的sql语句是这样的，如下：select * from husband h join wife w on h.wife_id=w.id; 妻子的主键作为丈夫的外键，那么这个是表中的关系，在实体类中的关系就是妻子的对象作为丈夫的实体类的属性，这样丈夫才可以访问到妻子的信息。 完整的Husband实体类的代码 如果使用自动生成表的话，那么默认生成的外键名称为 类名小写_id，但是我们可以使用@JoinColumn(name=&quot;&quot;)改变外键的名称 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.persistence.JoinColumn;import javax.persistence.OneToOne;import javax.persistence.Table;@Entity //指定实体类@Table(name="husband") //指定对应数据库的表名为husbandpublic class Husband &#123; private int id; private String name; private int age; private Wife Wife; @Id @GeneratedValue //主键生成策略，自增长 public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; @OneToOne //设置wife的主键为Husband的外键，默认的对应表中的字段为wife_id @JoinColumn(name="wifeid") // 默认外键的名字为wife_id.我们使用这个注解改变外键的名字为wifeid public Wife getWife() &#123; return Wife; &#125; public void setWife(Wife wife) &#123; Wife = wife; &#125; @Column(length=20) //设置长度为20 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Husband [id=" + id + ", name=" + name + ", age=" + age + "]"; &#125;&#125; 实体类Wife的代码不用改变 在核心配置文件hibernate.cfg.xml添加实体类的映射即可 12&lt;mapping class="cn.tedu.bean.Husband"&gt;&lt;/mapping&gt;&lt;mapping class="cn.tedu.bean.Wife"&gt;&lt;/mapping&gt; 启动服务器我们将会看到Hibernate已经为我们创建了两张表husband和wife，其中wife的主键设置为husband的外键了(wifeid) 测试方法 我们知道妻子是作为丈夫的外键，因此这里需要先添加指定的wife数据，才可以添加对应的husband数据，所以下面的测试方法先保存了wife对象。但是在后面讲到级联操作，那么就可以直接保存husband对象便可以一起保存了wife对象数据到数据库中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154import org.hibernate.Session;import org.hibernate.Transaction;import org.junit.Test;import cn.tedu.bean.Husband;import cn.tedu.bean.Teacher;import cn.tedu.bean.Wife;import cn.tedu.utils.HibernateUntil;public class TestOneToOne &#123; /** * 添加数据到husband中 */ @Test public void TestAdd() &#123; Session session = null; Transaction transaction = null; try &#123; // 创建session session = HibernateUntil.getSession(); // 开始事务 transaction = session.beginTransaction(); //创建wife对象，并且设置属性值，由于主键是自增长的，因此这里不需要自己设置 Wife wife=new Wife(); wife.setAge(22); wife.setName("Marry"); //新建husband对象 Husband husband=new Husband(); husband.setAge(22); husband.setName("陈加兵"); //将Wife的对象添加到Husband中，如果这里设置了级联操作，那么只需要保存husband对象即可完成wife的数据保存 husband.setWife(wife); //由于没有设置级联操作，因此这里需要先保存wife对象，否则将不能在数据库中添加成功 session.save(wife); //保存丈夫的信息 session.save(husband); // 提交事务 transaction.commit(); &#125; catch (Exception exception) &#123; transaction.rollback(); // 事务回滚 &#125; finally &#123; if (session!=null) &#123; session.close(); &#125; &#125; &#125; /** * 查询丈夫和对应妻子的信息 * 根据id查询，只要查询到丈夫的对象，那么妻子的信息就会保存在Husband的属性Wife对象中，因此可以通过访问其中的wife属性来获取对应妻子的信息 * 原理：使用session.get(class&lt;T&gt; cls,id)，其实发出的sql语句是外连接语句： * select * from husband h left join wife w on h.wifeid=w.id where h.id=? * 如果能够查找到对应的妻子信息就将其添加到Husband中的wife属性中，如果没有查找到那么设置wife属性为null即可，这个就是外连接 */ @Test public void TestGet() &#123; Session session = null; Transaction transaction = null; try &#123; // 创建session session = HibernateUntil.getSession(); // 开始事务 transaction = session.beginTransaction(); //查询id=1的husband信息 Husband husband=session.get(Husband.class, 1); //获取对应的妻子对象 Wife wife=husband.getWife(); //输出 System.out.println(husband); System.out.println(wife); // 提交事务 transaction.commit(); &#125; catch (Exception exception) &#123; transaction.rollback(); // 事务回滚 &#125; finally &#123; if (session!=null) &#123; session.close(); &#125; &#125; &#125; /** * 测试修改操作： 这里我们修改id=1的Husband对应的妻子的信息为id=2,当然前提是id=2的wife信息要存在，否则将不会成功 * 想要修改妻子的数据，直接修改Husband中的wife属性即可 */ @Test public void TestUpdate() &#123; Session session = null; Transaction transaction = null; try &#123; // 创建session session = HibernateUntil.getSession(); // 开始事务 transaction = session.beginTransaction(); //查询id=1的husband信息 Husband husband=session.get(Husband.class, 1); //查询wife的id=2的对象 Wife wife=session.get(Wife.class, 2); //如果这个对象查询到 if (wife!=null) &#123; husband.setWife(wife); //修改Husband对象中的wife属性值即可 &#125; session.update(husband); //执行更新操作 //获取对应的妻子对象 // 提交事务 transaction.commit(); &#125; catch (Exception exception) &#123; transaction.rollback(); // 事务回滚 &#125; finally &#123; if (session!=null) &#123; session.close(); &#125; &#125; &#125; /** * 测试删除wife表中的数据 * 原理： 如果设置了外键关联，那么我们想要删除wife的数据，必须先要删除其中与之外键关联的丈夫的信息，或者设置Husband表中的外键为其他的wife数据 * 两种解决办法： * 1. 先删除对应的丈夫的数据 * 2. 直接将丈夫对应的表的wifeId设置为其他或者为空即可 * * 下面我们使用的是设置丈夫对应的wifeId为空，那么就可以删除其对应的妻子的数据 */ @Test public void TestDelete() &#123; Session session = null; Transaction transaction = null; try &#123; // 创建session session = HibernateUntil.getSession(); // 开始事务 transaction = session.beginTransaction(); //查询到id=2的wife数据 Wife wife=session.get(Wife.class,2); //查询其对应的丈夫，这里还没有讲到其他的查询条件，所以我们默认id=2就是wife的id=2的对应的丈夫 Husband husband=session.get(Husband.class, 2); //将wife设置null，表示将wifeId外键设置空，因此就断了外键关联 husband.setWife(null); //删除wife session.delete(wife); // 提交事务 transaction.commit(); &#125; catch (Exception exception) &#123; transaction.rollback(); // 事务回滚 &#125; finally &#123; if (session!=null) &#123; session.close(); &#125; &#125; &#125;&#125; 通过妻子访问丈夫 那么根据需求，此时就是丈夫的主键作为妻子的外键，那么只需要在WIfe的类中添加一个Husband对象属性即可 Wife类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.persistence.JoinColumn;import javax.persistence.OneToOne;import javax.persistence.Table;@Entity@Table(name="wife")public class Wife &#123; private int id; private String name; private int age; private Husband husband; @Id @GeneratedValue //主键生成策略，自增长 public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; @OneToOne //设置丈夫的主键为妻子外键 @JoinColumn(name="husbandId") // 外键名称为husbandId public Husband getHusband() &#123; return husband; &#125; public void setHusband(Husband husband) &#123; this.husband = husband; &#125; @Column(length=20) //设置长度为20 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Husband [id=" + id + ", name=" + name + ", age=" + age + "]"; &#125;&#125; Husband的类不用改变，还是如第一个的样子 总结 单向连接就是只能通过一个对象访问另一个对象的属性，只需要在一个实体类中添加另外一个类的对象为成员变量即可，并且在该对象的get方法上添加OneToOne注解即可，就表示这个对象的主键会作为该实体类的外键 双向外键关联(@OneToOne(mappedBy=””) 所谓的双向的外键关联，就是两个实体类可以互相访问对方的属性，那么此时就需要在两个实体类中都要添加对方的对象为成员变量 问题 在两个实体类中都添加对方的对象作为自己的成员变量，那么我们此时就需要在两个实体类中都要使用OneToOne注解，但是我们使用了OneToOne就会在两张表中都会将对方的主键作为自己的外键，显然是没有必要的，冗余。 解决办法 我们在不想作为外键的属性的get方法上添加mappedBy,或者在想要成为对方的外键的类中的对方的对象的get方法中添加即可。 但是我们需要注意的是： mappedBy=”“，其中的值一定要和该类对象对方类中属性的字段相同 实现 我们让Wife作为Husband的外键，所以mappedBy添加到Wife类中的Husband对象的get方法头上即可 Husband实体类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.persistence.JoinColumn;import javax.persistence.OneToOne;import javax.persistence.Table;@Entity //指定实体类@Table(name="husband") //指定对应数据库的表名为husbandpublic class Husband &#123; private int id; private String name; private int age; private Wife Wife; //Wife对象 @Id @GeneratedValue //主键生成策略，自增长 public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; @OneToOne //设置wife的主键为Husband的外键，默认的对应表中的字段为wife_id @JoinColumn(name="wifeid") // 默认外键的名字为wife_id.我们使用这个注解改变外键的名字为wifeid public Wife getWife() &#123; return Wife; &#125; public void setWife(Wife wife) &#123; Wife = wife; &#125; @Column(length=20) //设置长度为20 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Husband [id=" + id + ", name=" + name + ", age=" + age + ", Wife=" + Wife + "]"; &#125;&#125; Wife类(添加@oneToOne(mappedBy=”wife”)) 将维护权交给了wife，表示wife作为husband的外键 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.persistence.JoinColumn;import javax.persistence.OneToOne;import javax.persistence.Table;@Entity@Table(name="wife")public class Wife &#123; private int id; private String name; private int age; private Husband husband; //Husband对象 @Id @GeneratedValue //主键生成策略，自增长 public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; /** * mappedBy="对方类中的该类的属性名字"，注意这里的名字和一定要和对方类中的成员变量的字段一样 * 表示将维护权交给对方类中的当前类的对象，就是表示当前类的主键将会作为外键 */ @OneToOne(mappedBy="wife") //设置关联，并且将维护权交给了对方类中的属性wife，因此这里的外键就是wifeId public Husband getHusband() &#123; return husband; &#125; public void setHusband(Husband husband) &#123; this.husband = husband; &#125; @Column(length=20) //设置长度为20 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Wife [id=" + id + ", name=" + name + ", age=" + age + ", husband=" + husband + "]"; &#125;&#125;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.persistence.JoinColumn;import javax.persistence.OneToOne;import javax.persistence.Table;@Entity@Table(name="wife")public class Wife &#123; private int id; private String name; private int age; private Husband husband; //Husband对象 @Id @GeneratedValue //主键生成策略，自增长 public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; /** * mappedBy="对方类中的该类的属性名字"，注意这里的名字和一定要和对方类中的成员变量的字段一样 * 表示将维护权交给对方类中的当前类的对象，就是表示当前类的主键将会作为外键 */ @OneToOne(mappedBy="wife") //设置关联，并且将维护权交给了对方类中的属性wife，因此这里的外键就是wifeId public Husband getHusband() &#123; return husband; &#125; public void setHusband(Husband husband) &#123; this.husband = husband; &#125; @Column(length=20) //设置长度为20 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Wife [id=" + id + ", name=" + name + ", age=" + age + ", husband=" + husband + "]"; &#125;&#125; 测试 我们只要查询到Husband对象就可以访问到其中的Wife对象的数据，同样的只要查询到Wife对象就可以访问到其中的Husband对象的数据 这里就不再测试了 一对多 一个宿舍可以被多个学生住，这个就是一对多的关系,其中宿舍是One的一方，学生是Many的一方 准备 Student实体类 12345678910111213141516171819202122232425262728293031323334import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.Table;@Entity@Table(name="student")public class Student &#123; private int id; //主键 private String name; private int age; @Id @GeneratedValue public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; @Column(length=10) public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 宿舍的实体类 1234567891011121314151617181920212223/** * 一个宿舍可以被多个学生住 * 一个学生只能住在一个宿舍 * 学生是One * 宿舍是Many */public class Dormitory &#123; private int id; //主键 private Long number; //宿舍编号 public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public Long getNumber() &#123; return number; &#125; public void setNumber(Long number) &#123; this.number = number; &#125;&#125; 前提须知 我们知道无论是一对多还是多对一的关系，在创建表的关联关系的时候，外键总是在多的一方，即是一的一方的主键作为多的一方的外键 单向外键关联 前面已经说过，单向外键关联是只能单向访问，只能一张表访问另外一张表，比如通过One的一方可以访问到Many的一方，也可以通过Many的一方访问到One的一方 从One的一方访问Many的一方(@OneToMany) 即是通过学生查询到其所住的宿舍 想要通过学生查询到所住的宿舍，那么必须在Student的实体类中必须有Dormitory的对象作为其成员变量 Dormitory类(One的一方，使用@OneToMany) 1234567891011121314151617181920212223242526272829303132333435@Entity@Table(name = "dormitory")public class Dormitory &#123; private int id; // 主键 private Long number; // 宿舍编号 private Set&lt;Student&gt; students; @Id @GeneratedValue public int getId() &#123; return id; &#125; @OneToMany //Dormitory是One的一方，Student是Many的一方，因此这里使用OneToMany @JoinColumn(name="dormitory_id") //必须指定外键的名称，否则将会自动创建第三张表来管理关联关系 public Set&lt;Student&gt; getStudents() &#123; return students; &#125; public void setStudents(Set&lt;Student&gt; students) &#123; this.students = students; &#125; public void setId(int id) &#123; this.id = id; &#125; public Long getNumber() &#123; return number; &#125; public void setNumber(Long number) &#123; this.number = number; &#125;&#125; Student类(Many的一方，不变) 测试 添加： 在为Many的一方(Student)添加宿舍信息的时候，这个宿舍的信息一定是在数据库中的，因为添加外键相当于必须这个外键存在才能添加 删除： 在删除的One的一方的时候，一定要确保Many的一方没有与其外键关联，否则将会删除失败，除非设置了级联删除，那么会连同外键关联的数据一起删除（以后再讲） 123456789101112131415161718192021222324252627282930313233@Testpublic void TestGet() &#123; Session session = null; Transaction transaction = null; try &#123; // 创建session session = HibernateUntil.getSession(); // 开始事务 transaction = session.beginTransaction(); Dormitory dormitory=new Dormitory(); dormitory.setNumber(10011L); //创建一个Set集合存储Student对象 Set&lt;Student&gt; students=new HashSet&lt;Student&gt;(); for(int i=0;i&lt;5;i++)&#123; Student student=new Student(); student.setAge(10*i); student.setName("name_"+i); session.save(student); students.add(student); // 添加到集合中 &#125; dormitory.setStudents(students); //将学生信息添加到宿舍对象中 session.save(dormitory); //保存宿舍信息 // 提交事务 transaction.commit(); &#125; catch (Exception exception) &#123; transaction.rollback(); // 事务回滚 &#125; finally &#123; if (session != null) &#123; session.close(); &#125; &#125;&#125; 从Many的一方查询One的一方(@ManyToOne) 即是通过学生对象查询到宿舍信息，因此需要在学生的实体类中添加宿舍的实体类对象 Student实体类（使用＠ManyToOne) 12345678910111213141516171819202122232425262728293031323334353637@Entity@Table(name="student")public class Student &#123; private int id; //主键 private String name; private int age; private Dormitory dormitory; //添加Dormitory对象，因为是One的一方，因此不用Set集合存储 @Id @GeneratedValue public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; @ManyToOne //使用@ManyToOne，因为Student是Many的一方 @JoinColumn(name="dormitory_id") //设置外键的字段值 public Dormitory getDormitory() &#123; return dormitory; &#125; public void setDormitory(Dormitory dormitory) &#123; this.dormitory = dormitory; &#125; @Column(length=10) public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; Dormitory实体类，不用改变，还是和前面的最初的实体类一样 双向外键关联 即是通过One的一方可以访问到Many的一方，也可以通过Many的一方访问到One的一方。简单的说就是可以互相访问对方的数据。 要想实现双向外键关联，必须是两个实体类对象互为对方的成员属性 问题并解决 因为是双向关联，因此这里的要设置双向关联的主导对象（mappedBy），否则将会出现两张表的外键都是对方的主键，这显然是冗余的，因此我们需要设置一个主导的。我们这里应该选择多的一方为主导位置的，因此需要在一的这一方使用mppedBy指定主导对象。因此我们只需要在@OneToMany上加上mappedBy属性即可。 由于无论是一对多还是多对一的关系，外加都是One一方的主键，因此要将维护权交给One的一方，因此只需要在@OneToMany这个注解中添加mappedBy这个属性即可 由于外键是在One的一方添加的，即是外键在student的表中，因此只有在Student的实体类中可以使用@JoinColumn()设置外键的字段名 实现 Student实体类(Many的一方，因此使用@ManyToOne) 12345678910111213141516171819202122232425262728293031323334353637@Entity@Table(name="student")public class Student &#123; private int id; //主键 private String name; private int age; private Dormitory dormitory; //添加Dormitory对象，因为是One的一方，因此不用Set集合存储 @Id @GeneratedValue public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; @ManyToOne //使用@ManyToOne，因为Student是Many的一方 @JoinColumn(name="dormitory_id") //设置外键的字段值,因为外键是在student表中添加的，因此只能在这个地方设置外键的字段名 public Dormitory getDormitory() &#123; return dormitory; &#125; public void setDormitory(Dormitory dormitory) &#123; this.dormitory = dormitory; &#125; @Column(length=10) public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; Dormitory实体类（One的一方，使用@OneToMany) 1234567891011121314151617181920212223242526272829@Entity@Table(name = "dormitory")public class Dormitory &#123; private int id; // 主键 private Long number; // 宿舍编号 private Set&lt;Student&gt; students; @Id @GeneratedValue public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; //仍然需要注意的是mappedBy的值必须是对方类中该类对象的一样的字段 @OneToMany(mappedBy="dormitory") //添加注解，由于是双向外键关联，必须添加mappedBy,由于外键就是One的一方的主键，因此这里的只需要在OneToMany中添加即可 public Set&lt;Student&gt; getStudents() &#123; return students; &#125; public void setStudents(Set&lt;Student&gt; students) &#123; this.students = students; &#125; public Long getNumber() &#123; return number; &#125; public void setNumber(Long number) &#123; this.number = number; &#125;&#125; 总结 无论是一对多还是多对一的关系，在建立表的时候总是在Many的一方添加One的一方的外键 在单向外键关联中，如果通过One的一方获取Many的一方数据，那么需要在One的实体类中添加Many的实体类的对象为其成员变量，同时在这个成员变量的get方法上方使用@OneToMany这个注解。如果想要通过Many的一方获取One的数据，那么需要在Many的实体类中添加One的实体类的对象为其成员变量，同时在这个成员变量的get方法上使用@ManyToOne这个注解 在双向外键关联，那么我们在使用@JoinColumn改变外键的字段名，那么必须在One的实体类中使用，因为外键是设置在One的一方的表中 双向外键关联必须使用@OneToMany(mappedBy=)设置主导地位的表，如果不设置这个mappedBy，那么就会出现双向外键，出现了冗余 多对一 一对多和多对一是相对的，因此这里的使用和一对多是一样的，不再反复的讲述了 多对多背景 一个老师可以教多个学生，一个学生可以被多个老师教，那么老师和学生的关系就是多对多的关系 准备 老师的实体类(Teacher) 12345678910111213141516171819202122232425262728293031323334import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.Table;@Entity@Table(name="teacher")public class Teacher &#123; private int id; //主键 private String name; private int age; @Id @GeneratedValue public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; @Column(length=10) public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 学生的实体类(Student) 12345678910111213141516171819202122232425262728293031323334import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.Table;@Entity@Table(name="student")public class Student &#123; private int id; //主键 private String name; private int age; @Id @GeneratedValue public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; @Column(length=10) public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 前提须知 我们在处理多对多的关系，在建立表的时候使用的是第三张表来维护外键，如下： 单向外键关联(@ManyToMany)通过学生访问老师的信息 根据需求我们必须在Student的类中将Teacher类的对象声明为成员变量，多对多的关系，因此使用的是Set集合来存储 Student的实体类 123456789101112131415161718192021222324252627282930313233343536373839@Entity@Table(name="student")public class Student &#123; private int id; //主键 private String name; private int age; private Set&lt;Teacher&gt; teachers; @Id @GeneratedValue public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; @ManyToMany //指定第三张表的名称，如果默认的是student_teacher,joinColumns指定的是当前的实体类的外键名称，inverseJoinColumns指定的是另外一个实体类的外键名称 //如果不指定外键的名称，那么默认的是student_id,和teacher_id @JoinTable(name="stu_tea",joinColumns=@JoinColumn(name="st_id"),inverseJoinColumns=@JoinColumn(name="t_id")) public Set&lt;Teacher&gt; getTeachers() &#123; return teachers; &#125; public void setTeachers(Set&lt;Teacher&gt; teachers) &#123; this.teachers = teachers; &#125; @Column(length=10) public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; @JoinTable 在多对多的关系中，默认创建第三张表的名称为 ： 表名_表名，但是我们可以使用@JoinTable这个注解来修改第三张表的名称 其中的name属性可以修改 @ManyToMany 在多对多的关系中使用，在实体类对象的get方法上面使用 joinColumns指定的是当前的实体类对应的外键名称，其中的值使用的@JoinColumn注解 inverseJoinColumns指定的是另外一个实体类的外键名称，其中的值使用的是@JoinColumn注解 通过老师访问学生的信息 那么需要在Teacher类中添加一个成员变量的类型为Student对象，并且在该成员变量的get方法上使用@ManyToMany 这个就不在演示了，和上面很相似 双向外键关联(@ManyToMany(mappedBy=””)) 如果老师想要知道自己教的学生的信息，学生也想知道老师的信息，那么就需要使用多对多双向关联，在两个实体类中都要定义对方的实体类的对象，因此这样就可以访问到对方的信息了。 这个和前面说的一样，当使用双向外键联系的时候，一定要设置主导的实体类(mappedBy)否则的话就会出现冗余，因此一定要指定主导关系。 下面我们的范例是指定学生的主导位置，因此要在老师的实体类中设置mappedBy属性 Student类 由于指定Student为主导位置，因此设置外键的名称和第三张表名字只能在Student的类中设置 123456789101112131415161718192021222324252627282930313233343536373839@Entity@Table(name="student")public class Student &#123; private int id; //主键 private String name; private int age; private Set&lt;Teacher&gt; teachers; @Id @GeneratedValue public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; @ManyToMany //指定第三张表的名称，如果默认的是student_teacher,joinColumns指定的是当前的实体类的外键名称，inverseJoinColumns指定的是另外一个实体类的外键名称 //如果不指定外键的名称，那么默认的是student_id,和teacher_id @JoinTable(name="stu_tea",joinColumns=@JoinColumn(name="st_id"),inverseJoinColumns=@JoinColumn(name="t_id")) public Set&lt;Teacher&gt; getTeachers() &#123; return teachers; &#125; public void setTeachers(Set&lt;Teacher&gt; teachers) &#123; this.teachers = teachers; &#125; @Column(length=10) public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; Teacher类（指定学生的主导位置，因此这里不能设置外键的名称和外键的字段名） 123456789101112131415161718192021222324252627282930313233343536@Entity@Table(name="teacher")public class Teacher &#123; private int id; //主键 private String name; private int age; private Set&lt;Student&gt; students; @Id @GeneratedValue public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; @ManyToMany(mappedBy="teachers") //将维护权交给teacher表，这里的teachers是Student类中的字段名，一定要一模一样的 public Set&lt;Student&gt; getStudents() &#123; return students; &#125; public void setStudents(Set&lt;Student&gt; students) &#123; this.students = students; &#125; @Column(length=10) public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 完整核心配置文件1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 必须要配置的5大参数，4大参数，一个方言 其中的四大参数是连接JDBC必须的参数 这里的方言也是必须的 --&gt; &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="hibernate.connection.url"&gt;jdbc:mysql://localhost:3306/hirbernate&lt;/property&gt; &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt; &lt;property name="hibernate.connection.password"&gt;root&lt;/property&gt; &lt;!-- mysql的方言 --&gt; &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 可选的配置文件 --&gt; &lt;!-- 输出所有的sql语句到控制台 --&gt; &lt;property name="hibernate.show_sql"&gt;true&lt;/property&gt; &lt;!-- 在控制台上打印出漂亮的sql语句 --&gt; &lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt; &lt;!-- 配置如果这个表还没有创建，那么就会自动创建，如果已经创建了，那么会自动更新 --&gt; &lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt; &lt;!-- 配置不生成Hibernate_sequence --&gt; &lt;property name="hibernate.id.new_generator_mappings"&gt;false&lt;/property&gt; &lt;!-- 直接指定这个Teacher实体类的全类名即可，即是完成了映射 --&gt; &lt;mapping class="cn.tedu.bean.Student"&gt;&lt;/mapping&gt; &lt;mapping class="cn.tedu.bean.Teacher"&gt;&lt;/mapping&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 总结 在双向外键关联的关系中，一定要使用mappedBy指定外键的维护权，否则将会出现数据冗余 在一对以和一对多，多对一的关系中，我们可以使用@JoinColumn这个注解来设置外键的字段名，但是在多对多的关系中，因为需要第三张表来维护，因此要使用@JoinTable这个注解来设置外键和第三张表的一些属性]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hibernate之一级缓存]]></title>
      <url>%2F2018%2F04%2F22%2FHibernate%E4%B9%8B%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%2F</url>
      <content type="text"><![CDATA[Hibernate之一级缓存什么是一级缓存 Hibernate创建每个Session对象时，都会给Session分配一块独立的缓存区，用于存放Session查询出来的对象，这个分配给Session的缓存区称之为一级缓存，也叫Session级缓存 为什么使用一级缓存 Session读取数据时，会优先向缓存区取数据，如果存在数据直接返回，不存在才会区数据库查询，从而降低了数据库的访问次数。提升了代码的运行效率 如何使用一级缓存 一级缓存默认是开启的，在使用Hibernate的API进行查询时会自动使用 验证 从控制台可以看到只发出一条sql的查询语句 1234567891011121314151617181920212223@Test public void Test() &#123; Session session = null; Transaction transaction = null; try &#123; // 创建session session = HibernateUntil.getSession(); // 开始事务 transaction = session.beginTransaction(); //查询id=2 的数据，这个是session的第一次查询，那么会发出sql语句 Student student1=session.get(Student.class, 2); //再次使用同一个Session查询id=2的对象，由于前面已经查询过一次，因此这里不需要发出sql语句 Student student2=session.get(Student.class,2); transaction.commit(); &#125; catch (Exception exception) &#123; transaction.rollback(); // 事务回滚 &#125; finally &#123; if (session!=null) &#123; session.close(); &#125; &#125; &#125; 一级缓存的规则 一级缓存是Session独享的，每个Session不能访问其他的Session的缓存区 12345678910111213141516171819202122232425@Test public void test1()&#123; Session session1 = null; Session session2 = null; Transaction transaction = null; try &#123; // 创建session session1=HibernateUntil.getSession(); //获取session1 session2=HibernateUntil.getSession(); // 开始事务 transaction = session1.beginTransaction(); transaction = session2.beginTransaction(); //使用session1查询id=2的对象，这个对象会在session1的缓存区缓存 Student s1=session1.get(Student.class, 2); //使用Session2查询id=2的对象，可以看到这还是会发出sql语句，因为在session2的缓存区没有这个对象 Student s2=session2.get(Student.class, 2); transaction.commit(); &#125; catch (Exception exception) &#123; transaction.rollback(); // 事务回滚 &#125; finally &#123; if (session1!=null) &#123; session1.close(); &#125; &#125; &#125; Session的save，update，delete操作会出发缓存更新 此时的缓存区将会将之前的查询到的对象全部清除 一级缓存管理 session.evit(obj) 将obj对象从一级缓存中清除 12345678910111213141516171819202122232425public void Test2() &#123; Session session = null; Transaction transaction = null; try &#123; // 创建session session = HibernateUntil.getSession(); // 开始事务 transaction = session.beginTransaction(); //查询id=2 的数据，这个是session的第一次查询，那么会发出sql语句 Student student1=session.get(Student.class, 2); //清楚一级缓存中的student1对象 session.evict(student1); //再次使用同一个Session查询id=2的对象，由于前面已经清除了这个对象，因此这里还是会发出sql语句 Student student2=session.get(Student.class,2); transaction.commit(); &#125; catch (Exception exception) &#123; transaction.rollback(); // 事务回滚 &#125; finally &#123; if (session!=null) &#123; session.close(); &#125; &#125; &#125; session.clear() 清除一级缓存中的所有对象 session.close() 关闭session，释放缓存空间 总结 一级缓存是默认开启的 一级缓存的使用可以减少服务器和数据库之间的交互，减轻服务器的压力 提高查询的效率，不必查询发出重复的sql语句]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hibernate中的三种状态]]></title>
      <url>%2F2018%2F04%2F22%2FHibernate%E4%B8%AD%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81%2F</url>
      <content type="text"><![CDATA[Hibernate中的三种状态 在Hibernate中可以将实体对象看成3种状态，分别是临时态，持久态，游离态 临时态(瞬时态)特征 临时态的对象可以被垃圾回收 临时态的对象未经过持久化，没有和session关联(没有经过session存储和查找) 转换 新new出来的对象就是临时态 在Hibernate中,可通过 session的save()或saveOrUpdate()方法将临时对象与数据库相关联,并将数据对应的插入数据库中,此时该临时对象转变成持久化对象. 12Student st=new Student(); //此时的对象是临时态st.setName("陈加兵"); 持久态 处于该状态的对象在数据库中具有对应的记录,并拥有一个持久化标识.通过session的get()、load()等方法获得的对象都是持久对象。 持久态的对象与session关联 在数据库中有与之关联的数据 12//使用get方法获取id=2的对象，此时的Student是持久态Student student=session.get(Student.class, 2); 特点 session.save()方法将一个临时态的对象转换成持久态 123456//新建的Student对象，这个是临时态对象，并没有数据库关联Student student = new Student();student.setAge(22);student.setName("陈加兵");// 保存数据到数据库，此时的student就是一个持久态的对象，与session有了关联，并且数据库中也有了这条数据session.save(student); Session的update()方法 将一个游离对象转变为持久对象 不能调用save()方法，因为游离态对象在数据库中是对应着一条数据的(数据库中有id的值与其对应)，如果此时调用save()方法，那么就会向其中插入一条数据(此时的主键是自增长的)。因此要想一个游离态的对象变成持久态的对象，必须使用update()方法 12345678910111213141516171819202122232425@Test public void Test() &#123; Session session = null; Transaction transaction = null; try &#123; // 创建session session = HibernateUntil.getSession(); // 开始事务 transaction = session.beginTransaction(); //此时的student为临时态 Student student=new Student(); //设置了id的值，并且这个id=2在数据库中有这么一条数据，因此是游离态 student.setId(2); //调用了update()方法，此时变成持久态的对象 session.update(student); transaction.commit(); &#125; catch (Exception exception) &#123; transaction.rollback(); // 事务回滚 &#125; finally &#123; if (session!=null) &#123; session.close(); &#125; &#125; &#125; 只要是这个持久态的对象的数据和数据库中的数据不相同了，不需要主动的调用update()方法，在执行的时候会自动的更新到数据库中。如果比较之后发现对象中的属性是相同的，那么即使调用了update()方法，也不会发出sql的更新语句。 1234567891011121314151617181920212223242526 @Test public void TestPersit() &#123; Session session = null; Transaction transaction = null; try &#123; // 创建session session = HibernateUntil.getSession(); // 开始事务 transaction = session.beginTransaction(); //使用get方法获取id=2的对象，此时的Student是持久态 Student student=session.get(Student.class, 2); //修改了持久态的对象，这里只要session提交了就会自动更新到数据库中，不需要使用update()方法 student.setName("陈加兵"); //更新Student对象到数据库中，但是student是持久态，因此这里的语句是多余// session.update(student); // 提交事务 transaction.commit(); &#125; catch (Exception exception) &#123; transaction.rollback(); // 事务回滚 &#125; finally &#123; if (session!=null) &#123; session.close(); &#125; &#125; &#125; Session的lock()方法: 调用lock()方法将对象同Session相关联而不强制更新。 Session的merge()方法: 拷贝指定对象的状态到具有相同对象标识符的持久对象。 Session的saveOrUpdate()方法: saveOrUpdate() 方法对于临时对象，执行save()方法，对于游离对象，执行update()方法。 Session的load()和get()方法: load()方法和get()方法都可以根据对象的标识符加载对象，这两个方法加载的对象都位于Session的缓存中，属于持久对象。 Session的 delete()方法: delete()方法用于从数据库中删除与持久化对象对应的记录。如果传入的是一个持久化对象，Session就执行一条 delete语句。如果传入的参数是游离对象，先使分离对象与Session关联，使它变为持久化对象，然后才计划执行一个delete语句。 Session 的evict()方法: evict()方法从Session的缓存中删除一个持久对象。 游离态(脱管态) 当与某持久对象关联的session被关闭后,该持久对象转变为游离对象.当游离对象被重新关联到session上 时,又再次转变成持久对象（在Detached其间的改动将被持久化到数据库中）。 游离对象拥有数据库的识别值,但已不在持久化管理范围之内。 对象中有id的值(这个id的值对应数据库中的数据)，但是和session没有关联 123Student student2=new Student();student.setId(2); //设置了id的值，这个id的值在数据库中对应一条记录student.setName("陈加兵"); 参考文章 https://blog.csdn.net/leefengboy/article/details/52723849]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hibernate之延迟加载]]></title>
      <url>%2F2018%2F04%2F22%2FHibernate%E4%B9%8B%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%2F</url>
      <content type="text"><![CDATA[hibernate之延迟加载什么是延迟加载 在使用某些Hibernate方法查询数据的时候，Hibernate返回的只是一个空对象(除了id外属性都为null)，并没有真正的查询数据库。而是在使用这个对象的时候才会出发查询数据，并将查询到的数据注入到这个空对象中，这种查询时机推迟到对象访问时的机制称之为延迟加载。 简单的说，使用延迟加载获取的对象，只有在获取其中的除了id之外的属性才会发出sql语句。 好处 可以提升内存资源的使用率 可以降低对数据库的访问次数 如何使用延迟加载 session.load() query.iterate() 1234567891011121314151617181920212223242526@Test public void Testload() &#123; Session session = null; Transaction transaction = null; try &#123; // 创建session session = HibernateUntil.getSession(); // 开始事务 transaction = session.beginTransaction(); //使用延迟加载load()方法获取对象，这里并没有发出sql查询语句，其中除了一个id属性之外没有其他的属性 Student student=session.load(Student.class,2); //查询其中的id属性，这里也没有发出查询语句 System.out.println(student.getId()); //查询对象中的name属性，这里将会发出查询的sql语句 System.out.println(student.getName()); // 提交事务 transaction.commit(); &#125; catch (Exception exception) &#123; transaction.rollback(); // 事务回滚 &#125; finally &#123; if (session!=null) &#123; session.close(); &#125; &#125; &#125; 使用延迟加载需要注意的问题 采用延迟加载机制的操作，需要避免session的提前关闭。避免在使用对象之前关闭session 因为在使用延迟加载的时候并没有发出sql查询语句，只有当使用其中的除了id属性之外的属性才会发出查询语句，因此这里的session不能提前关闭]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hibernate注解之基本注解的注解使用]]></title>
      <url>%2F2018%2F04%2F22%2FHibernate%E6%B3%A8%E8%A7%A3%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[Hibernate注解之基本注解的注解使用使用注解须知 我们在使用注解自动创建表的时候，系统会默认为我们创建一张表Hibernate_sequence，我们可以在Hibernate.cfg.xml文件中添加如下语句解决问题12&lt;!-- 配置不生成Hibernate_sequence --&gt;&lt;property name="hibernate.id.new_generator_mappings"&gt;false&lt;/property&gt; 类级别注解 @Entity : 映射实体类，其中有一个name属性指定当前实体类映射的表的名称 name: 可选属性 ，指定对应表的名称，如果没有指定name属性，那么创建表的名称和类名一样 @Table : 在实体类的上方使用，和Entity配合使用，指定实体类对应的数据库中的表的信息 name ：可选，指定表的名称，默认的是和类名一样，只有在不一致的情况下才会指定表名 catalog ： 可选，表示Catalog名称，默认为 Catalog(“”) schema ： 可选 , 表示 Schema 名称 , 默认为Schema(“”) 属性级别的注解 属性级别的注解在getXXX()方法上使用 @Id 映射生成主键 @Version 定义乐观锁 @Column 映射表的列 @Transient 定义暂态属性 主键相关的注解 @id： 指定该属性为主键 @GeneratedValue(strategy=,generator=&quot;&quot;) : 主键生成策略 Strategy的值 GenerationType.AUTO - 根据底层数据库自动选择（默认），若数据库支持自动增长类型，则为自动增长。 GenerationType.INDENTITY - 根据数据库的Identity字段生成，支持DB2、MySQL、 MS、SQL Server、SyBase与HyperanoicSQL数据库的Identity 类型主键。 GenerationType.SEQUENCE - 使用Sequence来决定主键的取值，适合Oracle、DB2等 支持Sequence的数据库，一般结合@SequenceGenerator使用。 GenerationType.TABLE - 使用指定表来决定主键取值，结合@TableGenerator使用。 与非主键相关的注解 @Version - 可以在实体bean中使用@Version注解,通过这种方式可添加对乐观锁定的支持 @Basic - 用于声明属性的存取策略： @Basic(fetch=FetchType.EAGER) 即时获取（默认的存取策略） @Basic(fetch=FetchType.LAZY) 延迟获取 @Temporal 这个使用来设置数据库表中显示的日期的精度，因为java中的Date属性可以对应着数据库中的三种类型(DATE,TIME, TIMESTAMP)即是单纯的表示日期，时间，两者兼备的，默认的是两者兼备的，输出的是:2012-01-22 17:55:55 因此可以使用@Temporal来设置显示的时间的精度，这三种的表示形式如下： TemporalType.TIME 输出到数据库中的仅仅是小时格式的，比如:12:22:12 TemporalType.DATE 输出到数据库中的是日期的格式：2012-12-01 TemporalType.TIMESTAMP 两者兼备，这个是默认的 @Column - 可将属性映射到列，使用该注解来覆盖默认值，@Column描述了数据库表中 该字段的详细定义，这对于根据 JPA 注解生成数据库表结构的工具非常有作用。 name - 可选，表示数据库表中该字段的名称，默认情形属性名称一致 nullable -可选，表示该字段是否允许为 null，默认为true unique - 可选，表示该字段是否是唯一标识，默认为 false length - 可选，表示该字段的大小，仅对 String 类型的字段有效，默认值255. insertable -可选，表示在ORM框架执行插入操作时，该字段是否应出现INSETRT 语句中，默认为 true updateable -可选，表示在ORM 框架执行更新操作时，该字段是否应该出现在 UPDATE语句中，默认为 true. 对于一经创建就不可以更改的字段，该 属性非常有用，如对于 birthday字段。 columnDefinition - 可选，表示该字段在数据库中的实际类型。通常ORM框架可以根 据属性类型自动判断数据库中字段的类型，但是对于Date类型仍无法确定数据 库中字段类型究竟是 DATE,TIME还是 TIMESTAMP. 此外 ,String 的默认映射类型为VARCHAR, 如果要将 String 类型映射到特定数据库的 BLOB或 TEXT字段类型，该属性非常有用。 @Transient - 可选，表示该属性并非一个到数据库表的字段的映射，ORM框架将忽略该属性，如果一个属性并非数据库表的字段映射，就务必将其标示为@Transient。 如果使用这个注解，那么表中不会出现这个字段 实例 我们现在创建一个实体类Teacher，映射到数据库teacher表中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.util.Date;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.Table;import javax.persistence.Temporal;import javax.persistence.TemporalType;import javax.persistence.Transient;@Entity@Table(name="teacher")public class Teacher &#123; private int id; //主键 private String name; private int age; private double sal; private Date joinDate; private String wife; //妻子的名字 @Transient //设置该属性不在表中 public String getWife() &#123; return wife; &#125; public void setWife(String wife) &#123; this.wife = wife; &#125; @Id @GeneratedValue(strategy=GenerationType.AUTO) //设置主键自增长 public int getId() &#123; return id; &#125; @Temporal(TemporalType.DATE) //设置时间精确到天数，2012-01-12 @Column(name="JoinTime") //改变表中字段的名字 public Date getJoinDate() &#123; return joinDate; &#125; public void setId(int id) &#123; this.id = id; &#125; @Column(nullable=false) //设置名字不为空 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public double getSal() &#123; return sal; &#125; public void setSal(double sal) &#123; this.sal = sal; &#125; public void setJoinDate(Date joinDate) &#123; this.joinDate = joinDate; &#125;&#125; 在核心配置文件(hibernate.cfg.xml)中配置这个映射12&lt;!-- 直接指定这个Teacher实体类的全类名即可，即是完成了映射 --&gt;&lt;mapping class="cn.tedu.bean.Teacher"&gt;&lt;/mapping&gt; @JoinColumn 我们知道外键的生成的字段的名称是默认的，但是我们也可以使用这个注解改变这个名称 这个注解是用来设置自动生成的外键的属性，比如外键的名称，非空…… name指定外键的名称 nullable指定外键是否为空，默认的是true unique生成唯一的约束，就是这个字段的值唯一，默认的false @JoinTabl 当涉及到多对多的映射关系的时候，用来定义第三表的表名，和字段的名称。 name设置第三张表的名称 joinColumns设置的是当前实体类对应的表在第三张表的外键的字段名称 inverseJoinColumns设置的是另外一个实体类对应的表在第三张表的外键的字段名称 参考文档 http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e1148 http://www.cnblogs.com/qjjazry/p/6306744.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hibernate使用日志(log4j)]]></title>
      <url>%2F2018%2F04%2F22%2FHibernate%E4%BD%BF%E7%94%A8%E6%97%A5%E5%BF%97-log4j%2F</url>
      <content type="text"><![CDATA[Hibernate使用日志(log4j)添加依赖 在pom.xml中添加如下的依赖123456789101112131415161718&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 在resource目录下创建log4j.properties文件123456789101112131415161718192021222324# Direct log messages to a log filelog4j.appender.file=org.apache.log4j.RollingFileAppender# define the log to filelog4j.appender.file.File=jsnu-log4j.loglog4j.appender.file.MaxFileSize=1MBlog4j.appender.file.MaxBackupIndex=1log4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n# Direct log messages to stdoutlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.outlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n# Root logger optionlog4j.rootLogger=INFO, file, stdout# Log everything. Good for troubleshootinglog4j.logger.org.hibernate=INFO# Log all JDBC parameterslog4j.logger.org.hibernate.type=ALL]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hibernate常用API]]></title>
      <url>%2F2018%2F04%2F22%2FHibernate%E5%B8%B8%E7%94%A8API%2F</url>
      <content type="text"><![CDATA[Hibernate常用API Configuration ：负责加载核心配置文件 加载的默认名字为hibernate.cfg.xml，如果不是这个名字，那么需要指定 SessionFactory configuration.buildSessionFactory() 创建SessionFactory SessionFactory ： 用来创建Session(会话) Session openSession() 获取Session Session : 数据库连接会话，用来实现增删改查 save(Object) 增加数据 get(Class&lt;T&gt; cls,arg) 根据id查询 update(Object object) 更新，一般先要根据条件获取到其中的记录，然后在其对象中修改 delete(Object object) 删除 Transaction ：负责事务控制 session.beginTransaction() 开始事务 rollback() 回滚 commit() 提交事务 Query ：执行特殊的查询 增删改查的是实例(Session)创建一个工具类 用于获取Session，相当于JDBC获取Connection12345678910111213141516171819public class HibernateUntil &#123; private static Configuration configuration; private static SessionFactory sessionFactory; /* * 静态语句块中的内容只是在类加载的时候只创建一次，因此这里的大大减少了资源的消耗 */ static &#123; // 加载核心配置文件hibernate.cfg.xml configuration = new Configuration(); configuration.configure(); // 创建SessionFactotry对象 sessionFactory = configuration.buildSessionFactory(); &#125; //创建session对象，在测试类中可以使用这个静态方法获取session public static Session getSession() &#123; return sessionFactory.openSession(); &#125;&#125; 增删改查 使用的是Session中的相关方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134package cn.tedu.test;import org.hibernate.Session;import org.hibernate.Transaction;import org.junit.Test;import cn.tedu.bean.Student;import cn.tedu.utils.HibernateUntil;public class Demo1 &#123; /** * 添加数据到数据库中 * save(Object object) * 直接传入的是一个实体类的对象，我们在实体类中设置值，那么设置的值就会根据映射关系文件将其添加到指定的表的字段的值 */ @Test public void TestAdd() &#123; Session session = null; Transaction transaction = null; try &#123; // 创建session session = HibernateUntil.getSession(); // 开始事务 transaction = session.beginTransaction(); Student student = new Student(); student.setAge(22); student.setName("陈加兵"); // 保存数据到数据库 session.save(student); // 提交事务 transaction.commit(); &#125; catch (Exception exception) &#123; transaction.rollback(); // 事务回滚 &#125; finally &#123; if (session!=null) &#123; session.close(); &#125; &#125; &#125; /** * 删除数据 * 1. 根据id查询出想要删除的对象 * 2. 使用delete(Object obj) 删除 */ @Test public void testDelete()&#123; Session session = null; Transaction transaction = null; try &#123; // 创建session session = HibernateUntil.getSession(); // 开始事务 transaction = session.beginTransaction(); Student student=session.get(Student.class, 1); //根据id查询想要删除的对象 session.delete(student); //删除查询到的对象 // 提交事务 transaction.commit(); &#125; catch (Exception exception) &#123; transaction.rollback(); // 事务回滚 &#125; finally &#123; if (session!=null) &#123; session.close(); &#125; &#125; &#125; /** * 根据id查询数据，返回的是一个实体类对象 * get(Class&lt;T&gt; cls,id) */ @Test public void testGet()&#123; Session session = null; Transaction transaction = null; try &#123; // 创建session session = HibernateUntil.getSession(); // 开始事务 transaction = session.beginTransaction(); //查询id=1的数据，并且返回对象 Student student=session.get(Student.class, 1); System.out.println(student); // 提交事务 transaction.commit(); &#125; catch (Exception exception) &#123; transaction.rollback(); // 事务回滚 &#125; finally &#123; if (session!=null) &#123; session.close(); &#125; &#125; &#125; /** * 测试更新数据 * 1. 先根据id获取指定的对象 get(Class&lt;T&gt; class,id) * 2. 使用set方法修改对象中的属性值 * 3. update(Object object) 直接将对象更新即可 */ @Test public void TestUpdate() &#123; Session session = null; Transaction transaction = null; try &#123; // 创建session session = HibernateUntil.getSession(); // 开始事务 transaction = session.beginTransaction(); //查询id=1的数据，并且返回对象 Student student=session.get(Student.class, 1); student.setName("Jack"); student.setAge(33); session.update(student); // 提交事务 transaction.commit(); &#125; catch (Exception exception) &#123; transaction.rollback(); // 事务回滚 &#125; finally &#123; if (session!=null) &#123; session.close(); &#125; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hibernate的基本配置]]></title>
      <url>%2F2018%2F04%2F22%2FHibernate%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[Hibernate的基本配置核心配置文件(hibernate.cfg.xml) 名字为hibernate.cfg.xml 放在根目录下(resource) 必须的配置(配置数据库信息) hibernate.connection.driver_class加载驱动，其中的mysql的为：com.mysql.jdbc.Driver hibernate.connection.url数据库的连接，其中mysql是jdbc:mysql://localhost:3306/hirbernate hibernate.connection.username数据库的用户名 hibernate.connection.password数据库的密码 hibernate.dialect数据库的方言，其中mysql：org.hibernate.dialect.MySQLDialect 可选的配置 hibernate.show_sql输出sql执行的语句到控制台，false，true hibernate.format_sql格式化sql语句，true，false hibernate.hbm2ddl.auto配置自动生成表，其中有四个值，分别是create（表示hibernate自动创建表，但是每次执行完成之后都会删除上一个表重新创建一个），update（如果还没有表，那么就生成一个，如果已经存在这个表，那么就会更新这个表），validate（不会自动创建表，字段不一致时会出现异常），create-drop（每次加载的时候都会创建表，但是SessionFactory关闭后就会自动删除这个表）。我们使用最多的是update &lt;mapping resource=&quot;com/bean/Student.hbm.xml&quot; /&gt;设置映射文件的路径 实例12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 必须要配置的5大参数，4大参数，一个方言 其中的四大参数是连接JDBC必须的参数 这里的方言也是必须的 --&gt; &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="hibernate.connection.url"&gt;jdbc:mysql://localhost:3306/hirbernate&lt;/property&gt; &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt; &lt;property name="hibernate.connection.password"&gt;root&lt;/property&gt; &lt;!-- mysql的方言 --&gt; &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 可选的配置文件 --&gt; &lt;!-- 输出所有的sql语句到控制台 --&gt; &lt;property name="hibernate.show_sql"&gt;true&lt;/property&gt; &lt;!-- 在控制台上打印出漂亮的sql语句 --&gt; &lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt; &lt;!-- 配置如果这个表还没有创建，那么就会自动创建，如果已经创建了，那么会自动更新 --&gt; &lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt; &lt;!-- 映射配置文件，这里是引用Student类的配置文件，注意这里的配置文件可以有多个 --&gt; &lt;mapping resource="cn/tedu/bean/Student.hbm.xml" /&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 映射关系文件作用 指定实体类的各个字段与表的关系 缺点 太麻烦了，一个项目中有很多个实体类，那么我们也需要配置多个映射关系文件 后面会使用注解的方式替代这个映射关系文件 创建 每一个实体类对应一个映射配置文件 映射关系文件的名字最好是实体类名.hbm.xml(不强制规定) 最好和实体类放在同一个包中 属性 class name : 对应的实体类的全类名(包名+类名) table : 在数据库中对应的表的名称 id 指定主键的对应关系，这个mybatis很相似 property : 实体类中的主键的字段 column ： 表中的主键字段 property 指定表中其他字段的对应关系 实例 实体类Student 1234567891011121314151617181920212223public class Student &#123; private String name; private Integer id; //主键 private Integer age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 映射关系文件 (Student.hbm.xml) 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;!-- 根节点 --&gt;&lt;hibernate-mapping&gt; &lt;!-- name：指定实体类的路径 table：指定该实体类对应的表的名称 --&gt; &lt;class name="cn.tedu.bean.Student" table="student"&gt; &lt;!-- &lt;id&gt;配置主键，name指定JavaBean中的属性，column指定的是表中的属性 --&gt; &lt;id name="id" column="id"&gt; &lt;!-- 配置主键的生成策略 --&gt; &lt;generator class="native"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;!-- property是定义非主键的类型 name：指定实体类中的属性名称 column：指定实体类中的属性对应在表中的元素的名称 如果这里的name和column相同，那么可以省略这里的colum，不过建议写全，更加清晰 --&gt; &lt;property name="name" column="name"&gt;&lt;/property&gt; &lt;property name="age" column="age"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 注意 如果实体类中的属性和表中的属性字段相同，那么其中的column可以省略，但是建议写全 SQL方言 告诉Hibernate你使用的是哪一个数据库，Hibernate便可以根据设定的方言来对应数据库 常用的方言(Mysql,Oracle) mysql : org.hibernate.dialect.MySQLDialect Oracle : org.hibernate.dialect.OracleDialect 主键生成方式 我们在学习mysql的时候，一般都会设置主键为自增长，这个自增长就是主键生成方式 如何使用 主键生成策略是在映射关系文件中定义的，使用的是&lt;generator&gt;定义的 分类常见的分类 sequence： 采用序列方式生成主键，适用于Oracle数据库 123&lt;generator class="sequence"&gt; &lt;param name="sequence"&gt;序列名&lt;/param&gt;&lt;/generator&gt; identity 是采用数据库自增长机制生成主键，适用于Oracle之外的其他的数据库 配置语法 ： &lt;generator class=&quot;identity&quot;&gt;&lt;/generator&gt; native 是根据当前配置的数据库方言，自动选择sequence或者identity 在mysql的环境下是自增长的方式 配置语法如下：&lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; uuid用一个128-bit的UUID算法生成字符串类型的标识符， 这在一个网络中是唯一的（使用了IP地址）。UUID被编码为一个32位16进制数字的字符串。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hibernate第一个程序]]></title>
      <url>%2F2018%2F04%2F22%2FHibernate%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[Hibernate第一个程序创建一个Maven项目 在pom.xml中配置Hibernate的jar包1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;dependencies&gt; &lt;!-- hibernate核心jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;5.1.0.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysqljar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.21&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建一个实体类(JavaBean)12345678910111213141516171819202122232425package cn.tedu.bean;public class Student &#123; private String name; private Integer id; //主键 private Integer age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 创建这个实体类Student的映射文件 这个实体类的映射文件的名字最好要和是：实体类名.hbm.xml 映射文件最好和实体类放在同一个包中1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;!-- 根节点 --&gt;&lt;hibernate-mapping&gt; &lt;!-- name：指定实体类的路径 table：指定该实体类对应的表的名称 --&gt; &lt;class name="cn.tedu.bean.Student" table="student"&gt; &lt;!-- &lt;id&gt;配置主键，name指定JavaBean中的属性，column指定的是表中的属性 --&gt; &lt;id name="id" column="id"&gt; &lt;!-- 配置主键的生成策略 自增长--&gt; &lt;generator class="native"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;!-- property是定义非主键的类型 name：指定实体类中的属性名称 column：指定实体类中的属性对应在表中的元素的名称 如果这里的name和column相同，那么可以省略这里的colum，不过建议写全，更加清晰 --&gt; &lt;property name="name" column="name"&gt;&lt;/property&gt; &lt;property name="age" column="age"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 核心配置文件(hibernate.cfg.xml) 核心配置文件的名字是hibernate.cfg.xml 放在根目录中，resource下12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 必须要配置的5大参数，4大参数，一个方言 其中的四大参数是连接JDBC必须的参数 这里的方言也是必须的 --&gt; &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="hibernate.connection.url"&gt;jdbc:mysql://localhost:3306/hirbernate&lt;/property&gt; &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt; &lt;property name="hibernate.connection.password"&gt;root&lt;/property&gt; &lt;!-- mysql的方言 --&gt; &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 可选的配置文件 --&gt; &lt;!-- 输出所有的sql语句到控制台 --&gt; &lt;property name="hibernate.show_sql"&gt;true&lt;/property&gt; &lt;!-- 在控制台上打印出漂亮的sql语句 --&gt; &lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt; &lt;!-- 配置如果这个表还没有创建，那么就会自动创建，如果已经创建了，那么会自动更新 --&gt; &lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt; &lt;!-- 映射配置文件，这里是引用Student类的配置文件，注意这里的配置文件可以有多个 --&gt; &lt;mapping resource="cn/tedu/bean/Student.hbm.xml" /&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 工具类(HibernateUtil) 用于读取配置文件 获取Session12345678910111213141516171819202122import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;public class HibernateUntil &#123; private static Configuration configuration; private static SessionFactory sessionFactory; /* * 静态语句块中的内容只是在类加载的时候只创建一次，因此这里的大大减少了资源的消耗 */ static &#123; // 加载核心配置文件hibernate.cfg.xml configuration = new Configuration(); configuration.configure(); // 创建SessionFactotry对象 sessionFactory = configuration.buildSessionFactory(); &#125; //创建session对象，在测试类中可以使用这个静态方法获取session public static Session getSession() &#123; return sessionFactory.openSession(); &#125;&#125; 测试类 添加一条记录到数据库中123456789101112131415161718192021222324252627282930313233import org.hibernate.Session;import org.hibernate.Transaction;import org.junit.Test;import cn.tedu.bean.Student;import cn.tedu.utils.HibernateUntil;public class Demo1 &#123; @Test public void TestAdd() &#123; Session session = null; Transaction transaction = null; try &#123; // 创建session session = HibernateUntil.getSession(); // 开始事务 transaction = session.beginTransaction(); Student student = new Student(); student.setAge(22); student.setName("陈加兵"); // 保存数据到数据库 session.save(student); // 提交事务 transaction.commit(); &#125; catch (Exception exception) &#123; transaction.rollback(); // 事务回滚 &#125; finally &#123; if (session!=null) &#123; session.close(); &#125; &#125; &#125; 总结 核心配置文件名字一定要是: hibernate.cfg.xml 实体类的配置文件要和实体类最好放在同一个包中 运行测试类，我student表将会自动创建，在控制台还会输出sql语句]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hibernate简介]]></title>
      <url>%2F2018%2F04%2F22%2FHibernate%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[hibernate简介什么是hibernate hibernate是数据访问层的框架，对JDBC进行了封装，是针对数据库访问提出的面向对象的解决方案 Hibernate的作用 使用Hibrenate可以直接访问对象，从hierbnate自动将此访问转换成SQL执行，从而达到间接访问数据库的目的，简化了数据访问层的代码开发 hibernate与JDBC对比使用JDBC具有以下缺点 需要编写大量SQL语句 需要给大量的占位符?赋值 需要将ResultSet结果集转换成实体对象 SQL中包含特有函数，无法移植 使用Hibernante的优点 自动生成SQL语句 自动给？参数赋值 自动将ResultSet结果集转换成实体对象 采用一致的方法对数据库操作，移植性好 总结 简单的来说，hibernate对JDBC进行了封装，比如JDBCTemplate可以简便的操作数据库，底层还是使用了JDBC Hibernate与Mybatis的对比共性 对JDBC进行了封装 采用ORM思想解决了Entity和数据库的映射问题 MyBaits Mybatis采用SQL与Entity映射，对JDBC封装成都较轻 Mybatis需要程序猿自己写sql语句，更具灵活性 Hibernate Hibernate采用数据库和Entity映射。对JDBC封装程度较重Hibernate自动生成SQL，对于基本的操作，开发效率高 总结 Hibernate对JDBC的封装较重，程序猿不需要写SQL语句，比如写好映射关系就可以自动创建表，使用JDBCTemplate直接操作数据库 Hibernate框架设计原理设计原理 Hibernate采用了ORM思想对JDBC进行了封装 Hibernate框架是ORM思想的一种体现，解决了对象和数据库映射问题 Hibernate提供了一系列的API，允许我们直接访问实体对象，然后其根据ORM映射关系，转换成SQL并且去执行，从而达到访问数据库的目的 ORM思想 ORM： Object Relation Mapping，即是对象关系映射，指的是java独享和关系数据库之间的映射 ORM思想： 就是将对象与数据库进行相互转换的思想，不同的框架技术实现ORM的手段不同，但更多的是采用配置+反射的方式ORM hibernate文档 http://docs.jboss.org/hibernate/orm/3.5/reference/zh-CN/html/session-configuration.html#configuration-sessionfactory]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自己写springmvc框架]]></title>
      <url>%2F2018%2F04%2F22%2F%E8%87%AA%E5%B7%B1%E5%86%99springmvc%E6%A1%86%E6%9E%B6%2F</url>
      <content type="text"><![CDATA[简易的springmvc框架三层架构 表示层(视图层，显示层) jsp servlet 业务逻辑层 service 数据访问层(持久层) dao 什么是mvc Model View Controller 是一种架构思想，其核心思想将项目划分成三种不同模块，分别是模型，视图，控制器 模型： 负责封装业务逻辑和数据访问 控制器： 负责调度 视图： 负责显示 View : JSP 负责显示 Controller :控制器 起到调度分发请求 Model ： 模型层 代表除了Servlet，Controller之外的java代码，包括service，dao 好处 项目的可维护性，可扩展性更高，抽取service 实现思想 首先需要一个RequestMapping注解 创建前端控制器DispatcherServlet用来转发请求 创建视图解析器来对应不同的页面 创建注解RequestMapping 使用@Target可以设置这个注解在方法体上还是在类上使用，这里我们只是在方法体上使用，这个和Springmvc有点出入1234567891011import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.METHOD) //设置这个注解是给方法使用的@Retention(RetentionPolicy.RUNTIME) //设置注解的存在时间为运行时public @interface RequestMapping &#123; //设置传入的参数 public String value(); //设置一个参数 ，必须传入参数 如果添加 default "" ,那么默认的参数就是空字符串 //public String method() default "get"; //设置method参数，默认的是get方法&#125; 创建Handler类 用来保存反射调用的方法和对象123456789101112131415161718192021222324252627282930313233import java.lang.reflect.Method;public class Handler &#123; private Method method; // 方法 private Object object; // Object对象，用于反射调用方法method public Handler(Method method, Object object) &#123; super(); this.method = method; this.object = object; &#125; public Method getMethod() &#123; return method; &#125; public void setMethod(Method method) &#123; this.method = method; &#125; public Object getObject() &#123; return object; &#125; public void setObject(Object object) &#123; this.object = object; &#125; @Override public String toString() &#123; return "Handler [method=" + method + ", object=" + object + "]"; &#125;&#125; config.xml(resource目录下) 用来存放bean，不同的controller类都需要在这个配置文件重视配置12345&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans&gt; &lt;bean class="cn.controller.UserController"&gt;&lt;/bean&gt; &lt;bean class="cn.controller.DeptController"&gt;&lt;/bean&gt;&lt;/beans&gt; XMLUtils 解析config.xml的文件，使用的是Dom4j 在pom.xml中导入依赖 123456&lt;!-- 读取xml文件的jar包 --&gt;&lt;dependency&gt; &lt;groupId&gt;dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt;&lt;/dependency&gt; 解析xml文件的工具类 123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.InputStream;import java.util.ArrayList;import java.util.List;import org.dom4j.Document;import org.dom4j.Element;import org.dom4j.io.SAXReader;import cn.reflect.ReflectDemo;/** * 读取XML文件的工具类 * @author chenjiabing * */public class XMLUtils &#123; /** * 读取xml文件中的内容,使用的jar包是dom4j * @return xml配置文件中的所有bean的对象 */ public static List&lt;Object&gt; getBeans() throws Exception&#123; SAXReader reader=new SAXReader(); InputStream inputStream=ReflectDemo.class.getClassLoader().getResourceAsStream("config.xml"); //获取输入流 Document document=reader.read(inputStream); //得到根节点 Element beansEle=document.getRootElement(); //得到根节点下面的所有子节点 List&lt;Element&gt; elements=beansEle.elements(); List&lt;Object&gt; beans=new ArrayList&lt;Object&gt;(); //保存bean中的class属性创建的对象 //遍历子节点 for (Element element : elements) &#123; //得到class属性的值 String className=element.attributeValue("class"); //直接使用遍历的className创建对象并且保存在集合中 Class cls=Class.forName(className); Object bean=cls.newInstance(); beans.add(bean); //将创建的对象添加到集合中 &#125; return beans; &#125;&#125; HandlerMapping 读取config.xml中的bean，并且利用反射获取注解上的value值(请求路径)、方法、创建类。存储在Map中1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package cn.reflect;import java.io.InputStream;import java.lang.reflect.Method;import java.util.HashMap;import java.util.List;import java.util.Map;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader;import cn.annoation.RequestMapping;public class HandlerMapping &#123; private Map&lt;String, Handler&gt; map = new HashMap&lt;String, Handler&gt;(); // 创建一个Map存储path和Handler /** * 初始化方法，将指定类的带有注解的方法放入Map中 * @param beans 对象集合 */ public void init(List&lt;Object&gt; beans) &#123; for (Object bean : beans) &#123; Class cls=bean.getClass(); //获取所有方法 Method[] methods=cls.getDeclaredMethods(); for (Method method : methods) &#123; RequestMapping requestMapping=method.getAnnotation(RequestMapping.class); //如果方法上面存在RequestMapping注解 if (requestMapping!=null) &#123; String path=requestMapping.value(); //获取注解上的地址 Handler handler=new Handler(method, bean); //创建handler对象 map.put(path, handler); //存放键值对 &#125; &#125; &#125; &#125; /** * 根据给定的path返回一个Handler对象 * * @param path * 指定的路径，map中的key * @return Handler 对象 */ public Handler getHandler(String path) &#123; return map.get(path); &#125;&#125; 视图解析器 根据controller方法中的返回值转发或者重定向到指定的视图 默认是转发的 重定向需要使用: redirect:add.do 12345678910111213141516171819202122232425262728import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class ViewResolver &#123; /** * 视图解析器 * @param returnValue controller方法的返回值 */ public void process(Object returnValue, HttpServletRequest request, HttpServletResponse response) &#123; String path=(String)returnValue; try &#123; //判断是转发还是重定向 if (path.startsWith("redirect:")) &#123; //重定向 response.sendRedirect(request.getContextPath()+"/"+path.split(":")[1]); &#125;else &#123; //转发 request.getRequestDispatcher("/WEB-INF/"+path+".jsp").forward(request, response); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; DispatcherServlet 前端控制器，其实是一个Servlet，不过用来拦截.do的请求，因此需要在web.xml中配置`.do` 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.io.IOException;import java.lang.reflect.Method;import java.util.List;import java.util.Scanner;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import cn.reflect.Handler;import cn.reflect.HandlerMapping;import cn.reflect.ViewResolver;import cn.utils.XMLUtils;/** * Servlet implementation class DispatcherServlet */public class DispatcherServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; List&lt;Object&gt; beans; try &#123; beans = XMLUtils.getBeans();// 获取xml配置文件中所有bean的对象 HandlerMapping handlerMapping = new HandlerMapping(); String uri = request.getRequestURI(); // 请求地址 String appName = request.getContextPath(); // 工程名 String path = uri.replace(appName, ""); // 获取注解的path handlerMapping.init(beans); // 初始化 Handler handler = handlerMapping.getHandler(path); // 获取指定的Handler Method method = handler.getMethod(); Object object = handler.getObject(); Class[] paramTypes = method.getParameterTypes(); // 获取方法中的参数类型 Object returnValue=null; //申明目标方法的返回值 // 如果调用的方法有参数 if (paramTypes.length &gt; 0) &#123; Object[] args = new Object[paramTypes.length]; //创建参数列表 for (int i = 0; i &lt; args.length; i++) &#123; Class cls = paramTypes[i]; // 判断类型是request或者response if (cls == HttpServletRequest.class) &#123; args[i] = request; &#125; else if (cls == HttpServletResponse.class) &#123; args[i] = response; &#125; &#125; returnValue=method.invoke(object, args); &#125; else &#123; returnValue=method.invoke(handler.getObject()); // 调用方法执行 &#125; //有返回值，要么转发，要么重定向 if (returnValue!=null) &#123; //通过视图解析器对象，处理转发或者重定向 ViewResolver viewResolver=new ViewResolver(); viewResolver.process(returnValue,request,response); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之适配器模式]]></title>
      <url>%2F2018%2F04%2F16%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[结构型模式之适配器模式定义 适配器模式用于将一个接口转化成客户想要的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。 Target（目标抽象类）：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。 Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。 Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。 根据对象适配器模式结构图，在对象适配器中，客户端需要调用request()方法，而适配者类Adaptee没有该方法，但是它所提供的specificRequest()方法却是客户端所需要的。为了使客户端能够使用适配者类，需要提供一个包装类Adapter，即适配器类。这个包装类包装了一个适配者的实例，从而将客户端与适配者衔接起来，在适配器的request()方法中调用适配者的specificRequest()方法。因为适配器类与适配者类是关联关系（也可称之为委派关系），所以这种适配器模式称为对象适配器模式 类适配器 类适配器是继承适配者类实现的，其中对象适配器是使用组合的方式实现的，就是适配者类作为适配器类的成员变量而实现的 一般目标抽象类是一个接口，适配者类一般是一个具体的实现类，有时候甚至不知道其中的源代码，因此需要适配器类将适配者类转换成适合用户的目标类 实例 我们知道笔记本充电的电压是5v，但是我们的高压电是220v，那么我们此时就需要一个适配器将这个220v电压转换成为5v的电压给笔记本充电 这里的220v电压就是适配者类，即是需要转换的类 5v电压是目标抽象类，由适配器将220v转换而来 这里的适配器类的主要功能就是将220v电压转换成5v电压 目标接口(5v电压) 1234567/* * 接口为5v电压的接口 ， 这个目标抽象类 */public interface Power5 &#123; void getPower5();&#125; 220v电压的类（这里是一个具体的类，适配者类） 12345public class Power220 &#123; public void getPower220()&#123; System.out.println("正在输出220v电压....."); &#125;&#125; 适配器类（将220v电压转换成5v） 1234567891011121314151617181920212223242526/* * 适配器类，主要的目的就是将220v电压转换为5v的电压供笔记本充电 * 其中Power5是目标抽象接口，是最终需要的接口，Power220是一个适配者类，是已经存在的，只需要适配器转换即可 */public class AdapterPower5 extends Power220 implements Power5 &#123; /** * 重载Power5中的方法，获取需要的5v电压 * 过程： 先获取220v电压，然后进行转换即可 * */ @Override public void getPower5() &#123; super.getPower220(); //首先获取220v电压 this.transform(); //将220v电压转换成5v的电压 System.out.println("获取5v电压......."); &#125; /* * 将220v电压转换成5v电压的方法 */ public void transform() &#123; System.out.println("现在将220v电压转换成5v电压......."); &#125;&#125; 笔记本充电的类 12345678910111213/* * 笔记本类 */public class NoteBook &#123; /** * 笔记本充电的方法 * @param power5 电压为5v的对象 */ public void PowerOn(Power5 power5)&#123; power5.getPower5(); //获取5v电压 System.out.println("笔记本获取了5v的电压，正在开始充电......"); &#125;&#125; 测试类 123456public class Client &#123; public static void main(String[] args) &#123; NoteBook noteBook=new NoteBook(); //创建笔记本的类 noteBook.PowerOn(new AdapterPower5()); //调用笔记本充电的类 &#125;&#125; 对象适配器 对象适配器是将适配者类作为适配器类的成员变量并不是继承，这个是一种组合方式 这种方式使用的更加普遍 实例 这里的实例还是前面的例子 这里唯一不同的就是适配器类，不是继承适配者类，而是使用组合的方式 1234567891011121314151617181920212223242526/* * 适配器类，这个是对象适配器，适配者类是作为成员变量存在，是组合关系 */public class Adapter implements Power5 &#123; private Power220 power; //220v电压类的对象，作为成员变量 /* * 构造方法，主要是为类初始化Power220v的对象 */ public Adapter(Power220 power)&#123; this.power=power; &#125; @Override public void getPower5() &#123; power.getPower220(); //获取220v电压 transform(); //转换电压 System.out.println("正在输出5v电压......."); &#125; public void transform()&#123; System.out.println("将220v电压转换成5v的电压......"); &#125;&#125; 总结 类适配器是使用类继承的方式，适配器类继承适配者类(不提倡使用) 对象适配器使用的是一种组合的方式，将适配者类作为其中的成员变量，那么也是可以实现（提倡使用） 麻烦支持下博主的广告事业，点击下即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之桥接模式]]></title>
      <url>%2F2018%2F04%2F16%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[结构型模式之桥接模式 桥接模式是一种很实用的结构型设计模式，如果软件系统中某个类存在两个独立变化的维度，通过该模式可以将这两个维度分离出来，使两者可以独立扩展，让系统更加符合“单一职责原则”。与多层继承方案不同，它将两个独立变化的维度设计为两个独立的继承等级结构，并且在抽象层建立一个抽象关联，该关联关系类似一条连接两个独立继承结构的桥，故名桥接模式。 桥接模式用一种巧妙的方式处理多层继承存在的问题，用抽象关联取代了传统的多层继承，将类之间的静态继承关系转换为动态的对象组合关系，使得系统更加灵活，并易于扩展，同时有效控制了系统中类的个数。桥接定义如下： 桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。 在桥接模式结构图中包含如下几个角色： Abstraction（抽象类）：用于定义抽象类的接口，它一般是抽象类而不是接口，其中定义了一个Implementor（实现类接口）类型的对象并可以维护该对象，它与Implementor之间具有关联关系，它既可以包含抽象业务方法，也可以包含具体业务方法。 RefinedAbstraction（扩充抽象类）：扩充由Abstraction定义的接口，通常情况下它不再是抽象类而是具体类，它实现了在Abstraction中声明的抽象业务方法，在RefinedAbstraction中可以调用在Implementor中定义的业务方法。 Implementor（实现类接口）：定义实现类的接口，这个接口不一定要与Abstraction的接口完全一致，事实上这两个接口可以完全不同，一般而言，Implementor接口仅提供基本操作，而Abstraction定义的接口可能会做更多更复杂的操作。Implementor接口对这些基本操作进行了声明，而具体实现交给其子类。通过关联关系，在Abstraction中不仅拥有自己的方法，还可以调用到Implementor中定义的方法，使用关联关系来替代继承关系。 ConcreteImplementor（具体实现类）：具体实现Implementor接口，在不同的ConcreteImplementor中提供基本操作的不同实现，在程序运行时，ConcreteImplementor对象将替换其父类对象，提供给抽象类具体的业务操作方法。 实例 从上面的这个实例我们可以看出，如果使用多层继承的话，那么我们可以定义是三个抽象类（台式机，笔记本，平板电脑），在这个三个抽象类的下面每个都有三个不同品牌的具体实现类，那么总共要有3x3=9个具体的实现类。不仅仅是类的数量多，在扩展性能上也是成倍的增加，如果想要添加一个品牌，那么需要添加三个类，这个是极其浪费的。 针对上面的缺点，我们可以使用桥接模式，将电脑分类，品牌分类分成两个维度，如下图： 其中Computer是一个抽象类，不是接口，其中Brand（品牌）是其中的成员变量，我们就完成了一个电脑具有不同品牌，那么如果我们想添加一个品牌，就只是添加一个具体的实现类即可，就不需要添加三个了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之原型模式]]></title>
      <url>%2F2018%2F04%2F16%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[创建型模式之原型模式定义 原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要 在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。 原型模式可以分为浅克隆和深度克隆 角色 java语言中实现克隆的两种方式 直接创建一个对象，然后设置成员变量的值 123Obj obj=new Obj(); //创建一个新的对象obj.setName(this.name); //设置其中变量的值obj.setAge(this.age); 实现cloneable接口 浅克隆 如果克隆的对象的成员变量是值类型的，比如int，double那么使用浅克隆就可以实现克隆完整的原型对象，但是如果其中的成员变量有引用类型的，那么这个引用类型的克隆过去的其实是地址，克隆对象的这个引用类型变量改变了，那么原来变量的值也是会改变的。 简单的说，浅克隆只能复制值类型的，对于引用类型的数据只能复制地址 实例 一个公司出版周报，那么这个周报的格式一般是相同的，只是将其中的内容稍作修改即可。但是一开始没有这个原型，员工每周都需要重新手写这个周报，现在有了这个周报的原型，只需要在这个clone这个原型，然后在其基础上修改即可。 其中的Cloneable就是抽象原型类 附件类（这个是一个引用类型的对象，验证浅克隆只是复制其中的地址，如果两个对象中的任何一个改变了这个变量的值，那么另外一个也会随之改变） 12345678910111213141516171819/* * 附件类，这个是周报的附件 */public class Attachment &#123; private String name; // 名称 public Attachment(String name) &#123; super(); this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 周报的类（其中实现了Cloneable接口） 其中的clone()方法返回的就是一个克隆的对象，因此我们调用这个方法克隆一个新的对象 1234567891011121314151617181920212223242526272829303132333435/* * 这个是周报类，这个类是实现接口Prototype这个接口的 */public class WeeklyLog implements Cloneable &#123; private String name; // 姓名 private String date; // 日期 private String content; // 内容 private Attachment attachment; //附件，是一个引用对象，这个只能实现浅克隆 public WeeklyLog() &#123; super(); &#125; /** * 构造方法 */ public WeeklyLog(String name, String date, String content) &#123; super(); this.name = name; this.date = date; this.content = content; &#125; /** * 提供一个clone方法，返回的是一个clone对象 */ public WeeklyLog clone() &#123; Object object = null; // 创建一个Object对象 try &#123; object = super.clone(); // 直接调用clone方法，复制对象 return (WeeklyLog) object; // 返回即可 &#125; catch (CloneNotSupportedException e) &#123; System.out.println("这个对象不能复制....."); return null; &#125; &#125;&#125; 测试类 测试浅克隆的值类型是是否完成复制了 测试引用类型的值能否完成克隆，还是只是复制了一个引用地址 从结果来看，对象是完成复制了，因为判断两个对象的地址是不一样的，但是其中的引用类型的成员变量没有完成复制，只是复制了一个地址 12345678910111213141516public class Client &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; WeeklyLog p1 = new WeeklyLog("陈加兵", "第一周", "获得劳动模范的称号..."); // 创建一个对象 Attachment attachment = new Attachment("消息"); p1.setAttachment(attachment); // 添加附件 WeeklyLog p2 = p1.clone(); System.out.println(p1 == p2); // 判断是否正确 p2.setName("Jack"); // 修改P2对象的内容 p2.setDate("第二周"); p2.setContent("工作认真....."); System.out.println(p2.getName()); // 返回true，可以知道这两个附件的地址是一样的 System.out.println(p1.getAttachment() == p2.getAttachment()); &#125;&#125; 总结 浅克隆对于值类型的数据可以复制成功，但是对于引用卡类型的数据只能复制一个地址，如果一个对象中的引用类型的变量的值改变了，那么另外一个也会随之改变 深度克隆 浅克隆只能完成复制值类型，深度克隆可以完成复制引用类型和值类型 条件 引用类型的变量类实现序列化(实现Serializabl接口） 需要克隆的类实现序列化(实现Serializable接口) 为什么实现序列化 因为深度克隆的实现的原理是使用输入和输出流，如果想要将一个对象使用输入和输出流克隆，必须序列化。 实现 附件类(引用类型的成员变量，实现序列化) 1234567891011121314151617/* * 附件类，这个是周报的附件 */public class Attachment implements Serializable&#123; private static final long serialVersionUID = -799959163401886355L; private String name; // 名称 public Attachment(String name) &#123; super(); this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 周报类（需要克隆的类，因为其中有引用类型的成员变量，因此需要实现序列化) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* * 这个是周报类，这个类是实现接口Prototype这个接口的 */public class WeeklyLog implements Serializable &#123; private static final long serialVersionUID = -8782492113927035907L; private String name; // 姓名 private String date; // 日期 private String content; // 内容 private Attachment attachment; // 附件，是一个引用对象，这个只能实现浅克隆 public WeeklyLog() &#123; super(); &#125; /** * 构造方法 */ public WeeklyLog(String name, String date, String content) &#123; super(); this.name = name; this.date = date; this.content = content; &#125; /** * 提供一个clone方法，返回的是一个clone对象 */ public WeeklyLog clone() &#123; // 将对象写入到对象流中 ByteArrayOutputStream arrayOutputStream = new ByteArrayOutputStream(); try &#123; ObjectOutputStream objectOutputStream = new ObjectOutputStream( arrayOutputStream); // 创建对象输出流 objectOutputStream.writeObject(this); // 将这个类的对象写入到输出流中 &#125; catch (IOException e) &#123; e.printStackTrace(); return null; &#125; // 将对象从流中读出 ByteArrayInputStream arrayInputStream = new ByteArrayInputStream( arrayOutputStream.toByteArray()); WeeklyLog weeklyLog; try &#123; ObjectInputStream objectInputStream = new ObjectInputStream( arrayInputStream);// 新建对象输入流 weeklyLog = (WeeklyLog) objectInputStream.readObject(); // 读取对象从流中 return weeklyLog; &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; 测试类 从中可以看出其中的附件地址是不同的，如果一个对象的附件变量改变了，那么另外一个将保持不变，因此实现了深度克隆，是两个完全不同的对象 12345678910111213141516public class Client &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; WeeklyLog p1 = new WeeklyLog("陈加兵", "第一周", "获得劳动模范的称号..."); // 创建一个对象 Attachment attachment = new Attachment("消息"); p1.setAttachment(attachment); // 添加附件 WeeklyLog p2 = p1.clone(); System.out.println(p1 == p2); // 判断是否正确 p2.setName("Jack"); // 修改P2对象的内容 p2.setDate("第二周"); p2.setContent("工作认真....."); System.out.println(p2.getName()); //返回false，可以看出这个是不同的地址，因此完成了深克隆 System.out.println(p1.getAttachment() == p2.getAttachment()); &#125;&#125; 总结 因为深度克隆使用的是将对象写入输入和输出流中的，因此需要实现序列化，否则将不能完成 总结 浅克隆只能克隆对象中的值类型，不能克隆有引用类型成员变量的对象 使用深度克隆： 引用类型的成员变量的类必须实现序列化 需要克隆的类必须实现序列化]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之建造模式]]></title>
      <url>%2F2018%2F04%2F16%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[创建型模式之建造者模式定义 建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。 简单说，建造者的功能就是先构造复杂对象的每一个部件，指挥者的功能就是将这些部件以一定的步骤组装起来，形成一个具有一定功能的产品或者对象。当然这个步骤是透明的对于客户端。 建造者模式一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式结构如图8-2所示： 实例 下面是一个组装汽车的例子，其中汽车由发动机和轮胎组成，那么我们只需要组装轮胎，发动机即可组装完成一个汽车。 汽车包括轮胎，引擎，我们通常在组装汽车的时候一般都是一步一步的组装，比如先装引擎，后装轮胎。使用建造者模式就是将建造汽车的这个过程抽离成几个不同的过程，比如建造引擎和建造轮胎就是两个过程。 轮胎的JavaBean 12345678910111213141516171819/* * 轮胎 */class Tyre &#123; private String name; public Tyre(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 引擎的JavaBean 1234567891011121314151617181920/* * 引擎 */class Engine &#123; private String name; public Engine(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 汽车的JavaBean(汽车包含轮胎和引擎，因此使用聚合的关系) 123456789101112131415161718192021222324/* * 汽车的类 */public class Car &#123; private Tyre tyre; // 轮胎 private Engine engine; // 引擎 public Tyre getTyre() &#123; return tyre; &#125; public void setTyre(Tyre tyre) &#123; this.tyre = tyre; &#125; public Engine getEngine() &#123; return engine; &#125; public void setEngine(Engine engine) &#123; this.engine = engine; &#125;&#125; 抽象建造者(实际上是一个接口，其中定义了建造轮胎和引擎的方法) 1234567891011public interface Builder &#123; /** * 构造引擎的方法 */ Engine buliderEngine(); /** * 构造轮胎的方法 */ Tyre builderTyre();&#125; 具体的建造者(实现了抽象建造者，实现建造轮胎和引擎的详细过程) 12345678910111213141516/* * 具体的建造者，主要是构造汽车的部件 */public class BuilderCar implements Builder &#123; @Override public Engine buliderEngine() &#123; System.out.println("构造汽车发动机"); return new Engine("傻逼牌发动机"); &#125; @Override public Tyre builderTyre() &#123; System.out.println("构造汽车轮胎"); return new Tyre("傻逼牌轮胎"); &#125;&#125; 抽象指挥者(定义了一个构造汽车的方法)，指挥者的作用就是按照一定步骤将构造者建造的部件组装起来 123456/* * 指挥者的接口，用来按照顺序组装汽车 */public interface Director &#123; Car CreateCar();&#125; 具体的指挥者(实现了指挥者接口) 1234567891011121314151617181920212223242526/* * 指挥者的实现类 */public class DirectorCar implements Director &#123; private Builder builder; // 建造者的对象 /** * 构造方法，主要用来初始化建造者对象 * * @param builder Builder的对象 */ public DirectorCar(Builder builder) &#123; this.builder = builder; &#125; @Override public Car CreateCar() &#123; Car car = new Car(); // 创建汽车对象 Engine engine = builder.buliderEngine(); // 构建发动机 Tyre tyre = builder.builderTyre(); // 构造轮胎 car.setEngine(engine); // 设置属性 car.setTyre(tyre); // 设置属性 return car; // 返回构造好的汽车 &#125;&#125; 测试类 12345678public class Client &#123; public static void main(String[] args) &#123; Director director = new DirectorCar(new BuilderCar()); // 创建指挥者的对象 Car car = director.CreateCar(); // 获取组装完成的 System.out.println(car.getEngine().getName()); // 输出引擎的名字 System.out.println(car.getTyre().getName()); // 输出轮胎的名字 &#125;&#125; 适用场景 基本部件不变，但是其中的组合经常变化的情况 比如你去肯德基点餐，汉堡，可乐，鸡翅这些食物是不变的，但是套餐的组合是经常变化的，建造者模式的指挥者就是将这些部件按照一定步骤将其组合起来的。 java中StringBuilder 需要生成的对象具有复杂的内部结构 复杂的内部结构，我们可以使用建造者模式将其分离，先将其中的各个小的部件组装成功，然后由指挥者按照一定的步骤将其组装成一个复杂的对象 需要生成的对象内部属性本身相互依赖。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之代理模式]]></title>
      <url>%2F2018%2F04%2F16%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[结构型模式之代理模式(静态代理) 由于某些原因，客户端不想或不能直接访问一个对象，此时可以通过一个称之为“代理”的第三者来实现间接访问，该方案对应的设计模式被称为代理模式。 代理其实是实现简介访问的媒介，当然在代理类中还可以在执行代理操作之前，之后，之中，环绕等执行相关动作。Spring 中面向切面编程就是这个原理 代理模式是一种应用很广泛的结构型设计模式，而且变化形式非常多，常见的代理形式包括远程代理、保护代理、虚拟代理、缓冲代理、智能引用代理等，后面将学习这些不同的代理形式 当使用代理类的时候， 真实类中的信息对用户来说是透明的(不可见的) 主要就是用于对象的间接访问提供了一个方案，可以对对象的访问进行控制 定义 Subject（抽象主题角色）：它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。 Proxy（代理主题角色）：它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中，客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作。 RealSubject（真实主题角色）：它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。 实例第一个例子 需求： 我们知道mac笔记本是在美国生产的，那么如果中国供销商想要卖mac笔记本，那么必须从美国供销商那里先进货，然后中国的顾客才可以在中国供销商买mac。这里的中国供销商就相当于代理，美国供销商就相当于真实主题角色 Mac笔记本抽象接口(相当于其中的抽象主题) 123456/* * 苹果笔记本的接口，其中有一个方法实现了买笔记本的动作 */public interface MacBook &#123; public void buy(); //购买笔记本的行为&#125; 美国供销商(相当于这里RealSubject) 1234567891011/* * 美国的笔记本，实现了MacBook接口，表示在美国买笔记本 */public class USAMac implements MacBook &#123; @Override public void buy() &#123; System.out.println("在美国买笔记本"); &#125;&#125; 中国供销商(相当于这里的代理角色) 我们可以看到我们在使用代理模式的时候可以在之前和之后进行操作12345678910111213141516171819202122232425262728293031/* * 中国的笔记本，实现了MacBook 表示在中国买笔记本 * 但是中国想要买到苹果笔记本，那么还是需要先从美国进货，因此中国只是一个中间的代理作用而已 * 当然代理的最大作用就是在代理之前、之后、之中执行相关的操作，这就是面向切面编程的原理 */public class ChinaMac implements MacBook &#123; private MacBook mcBook=new USAMac(); //创建USAMac的对象 /** * 在购买之前执行的操作 */ public void preBuy()&#123; System.out.println("购买之前执行的操作"); &#125; /** * 在购买之后执行的操作 */ public void afterBuy()&#123; System.out.println("购买之后执行的操作"); &#125; @Override public void buy() &#123; this.preBuy(); //之前执行的操作 mcBook.buy(); //在美国买笔记本 System.out.println("在中国买笔记本"); this.afterBuy(); //之后执行的操作 &#125;&#125; 测试类 我们在使用的时候直接使用代理类即可，我们根本不知道在真实类的使用，完全是代理类为我们提供了 1234567public class Client &#123; public static void main(String[] args) &#123; MacBook macBook=new ChinaMac(); //创建ChinaMac对象，在中国买笔记本 macBook.buy(); //直接在中国买笔记本 &#125;&#125; 第二个例子 我们登录一个网站的服务器端的验证步骤： 读取用户名和密码 验证用户名和密码 记录到日志中 这里的验证密码和记录到日志中可以在代理类中实现，在用户执行操作之前需要读取用户名和密码，并且验证，在操作之后需要将用户的一些操作记录到日志中。其实这里的真实用户需要做的只是执行自己的操作，而验证和记录都是交给代理类实现的。 实现 用户接口(User) 1234567/* * 用户的抽象类 */public interface User &#123; public void DoAction(); //执行动作&#125; 真实的用户类（实现了用户接口） 主要的做的就是执行自己的操作 12345678910111213141516public class RealUser implements User &#123; public String name; public String password; public RealUser(String name, String password) &#123; this.name = name; this.password = password; &#125; public RealUser() &#123;&#125; /* * 执行一些操作 */ @Override public void DoAction() &#123; System.out.println("开始执行操作......"); &#125;&#125; 代理类(实现了User接口) 在执行操作之前验证密码和用户名是否正确 在执行操作之后记录到日志中 实际上这里就是面向切面编程 12345678910111213141516171819202122232425262728293031323334353637383940public class ProxUser implements User &#123; private RealUser user; // 真实用户的对象 /** * 创建对象 * @param name 姓名 * @param password 密码 */ public ProxUser(String name, String password) &#123; user = new RealUser(name, password); &#125; @Override public void DoAction() &#123; //验证用户名和密码 if (Validate()) &#123; user.DoAction(); //调用真实用户的DoAction方法执行相关操作 logger(); //调用日志记录信息 &#125; else &#123; System.out.println("请重新登录......."); &#125; &#125; /* * 验证用户的用户名和密码 */ public Boolean Validate() &#123; if ("陈加兵".equals(user.name) &amp;&amp; "123456".equals(user.password)) &#123; return true; &#125; return false; &#125; /** * 添加日志记录信息 */ public void logger() &#123; System.out.println(user.name + "登录成功......"); &#125;&#125; 测试类 实际上执行了验证用户名和密码，记录日志的操作，但是对于客户端来说只能看到自己执行的操作 123456public class Client &#123; public static void main(String[] args) &#123; ProxUser proxUser=new ProxUser("陈加兵", "123456"); //创建代理对象 proxUser.DoAction(); //执行操作，实际执行了验证信息，doaction(),日志记录这个三个动作 &#125;&#125; 缺点 如果增加一个接口就需要增加一个代理类，如果是要增加很多，那么就要增加很多代理类，代码将会重复 解决方法 下面我们将会讲解到动态代理，仅仅需要一个代理类即可 结构型模式之动态代理模式 前面我们说的代理模式其实是属于静态代理模式，就是说在程序执行之前已经写好了代理类，但是缺点也是说过，必须为每个接口都实现一个代理类，如果有多个接口需要代理，那么代码肯定是要重复的，因此就需要动态代理了。 动态代理可以实现多个接口共用一个代理类，只需要改变初始化的参数即可，可以省去很多的重复的代码。 JDK的动态代理需要一个类一个接口，分别为Proxy和InvocationHandler 主要原理就是利用了反射的原理 InvocationHandler 这个是代理类必须实现的接口，其中有一个方法public Object invoke(Object proxy,Method method,Object[] args) Object proxy：指被代理的对象。 Method method：要调用的方法 Object[] args：方法调用时所需要的参数 Proxy Proxy类是专门完成代理的操作类，可以通过此类为一个或多个接口动态地生成实现类，此类提供了如下的操作方法：public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) ClassLoader loader：类加载器 Class&lt;?&gt;[] interfaces：得到全部的接口 InvocationHandler h：得到InvocationHandler接口的子类实例 实例 肯德基的接口 123456/* * 肯德基的接口，其中一个eat方法 */public interface IKFC &#123; public void eat();&#125; 肯德基的实现类(RealSubject) 1234567891011/* * IKFC的实现类 */public class KFC implements IKFC &#123; @Override public void eat() &#123; System.out.println("我在肯德基吃了饭......"); &#125;&#125; 苹果笔记本的接口 123456/* * 苹果笔记本的接口 */public interface MacBook &#123; public void buy();&#125; 美国供销商的类(RealSubject) 12345678910/* * 美国笔记本的类，实现了MacBook接口 */public class USAMacBook implements MacBook &#123; @Override public void buy() &#123; System.out.println("在美国买了一个苹果电脑......"); &#125;&#125; 动态代理的类（实现了InvocationHandler接口） 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;/** * 这个是代理类，实现了InvocationHandler接口 * */public class ProxyHandler implements InvocationHandler &#123; private Object Realobject; //被代理的对象 //构造方法，用来初始化被代理的对象 public ProxyHandler(Object obj)&#123; this.Realobject=obj; //初始化真实类的对象 &#125; /** * @param proxy 表示被代理的对象的，就是真实类的对象 * @param method 表示要调用真实类的方法 * @param args 表示方法调用的时候所需要的参数 * @return 方法调用之后的返回值 */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; prefunction(); //执行之前调用的方法 Object res=method.invoke(Realobject, args); //Method类中的执行方法的函数，在反射中常用 afterFunction(); //执行之后调用的方法 return res; &#125; /** * 执行方法之前调用的方法 */ public void prefunction()&#123; System.out.println("执行方法之前......"); &#125; /** * 执行方法之后调用的方法 */ public void afterFunction()&#123; System.out.println("执行方法之后......"); &#125;&#125; 测试类 1234567891011121314151617181920212223import java.lang.reflect.Proxy;import com.sun.org.apache.bcel.internal.generic.NEW;import com.sun.org.apache.bcel.internal.util.Class2HTML;public class Client &#123; public static void main(String[] args) &#123; Class[] cls1=&#123;IKFC.class&#125;; //第一个代理的所有接口数组，直接用接口的反射即可 Class[] cls2=USAMacBook.class.getInterfaces(); //直接具体的实现类的反射调用getInterfaces即可返回所有的接口数组 // 返回KFC的代理对象 IKFC kfc = (IKFC) Proxy.newProxyInstance(Client.class.getClassLoader(), cls1, new ProxyHandler(new KFC())); kfc.eat(); //执行方法 MacBook macBook = (MacBook) Proxy.newProxyInstance(Client.class.getClassLoader(), cls2, new ProxyHandler( new USAMacBook())); macBook.buy(); //执行方法 &#125;&#125; 总结 动态代理的好处 即使有多个接口，也仅仅只有一个动态代理类]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之工厂模式]]></title>
      <url>%2F2018%2F04%2F12%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[创建型模式之工厂模式什么是工厂模式 工厂模式是java中最常见的创建型模式，客户端在不知道创建逻辑的情况下，只需要在工厂中直接创建即可 简单工厂模式 简单工厂在创建对象的时候不需要知道具体的创建逻辑，客户端只需要知道该产品的一个标志即可，比如产品的名字 必备的两个元素： 产品的抽象类 生产产品的工厂类 实现 假设现在我们需要根据客户端的要求创建不同的图形，比如矩形，圆形…..，此时我们可以将图形抽象成接口，具体的产品只需要实现这个图形接口即可 shape接口（图形的接口，其中提供了一个创建图形的方法） 123456/* * 这个是抽象的产品类，后续的所有的产品都必须实现这个抽象类 */public interface Shape &#123; public void draw(); //提供一个实现方法，作为画画的动作&#125; 矩形产品类（实现shape接口） 123456789101112131415/* * 矩形的产品类，其中实现了Shape这个类 */public class Rectangle implements Shape &#123; /** * 实现了Shape中的方法 */ @Override public void draw() &#123; System.out.println("我们画了一个矩形"); &#125;&#125; 圆形产品类（实现Shape接口） 1234567891011/* * 圆形的产品类，实现了Shape这个类 */public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println("我们画了一个圆"); &#125;&#125; 工厂方法（创建产品的类） 根据传入的标志创建对应的产品123456789101112131415161718/* * 简单工厂的实例 * 其中提供一个getShape(String name) 可以根据提供的名字来返回一个对象，其实工厂生产的产品 */public class SimpleFactoryDemo &#123; public Shape getShape(String name) &#123; switch (name) &#123; case "矩形": return new Rectangle(); // 返回矩形的对象 case "圆形": return new Circle(); // 返回圆形对象 default: System.out.println("我们不能创建一个额外的对象"); return null; // 没有指定对象就返回null &#125; &#125;&#125; 测试 12345678public class ClientMain &#123; public static void main(String[] args) &#123; String name = "圆形"; // 填入名字 SimpleFactoryDemo simpleFactoryDemo = new SimpleFactoryDemo(); // 创建简单工厂实例 Shape shape = simpleFactoryDemo.getShape(name); // 根据名字获取对象 shape.draw(); // 调用方法 &#125;&#125; 优缺点 优点： 每次增加一个产品类只需要增加一个实现类即可（实现产品接口） 缺点： 如果添加一个产品类，那么我们就需要在工厂类中添加对应的代码（违反开闭原则） 开闭原则： 简单的说就是在对功能进行扩展的时候对原先的代码不做任何修改 工厂方法模式 简单工厂模式是一个抽象产品类派生出多个具体的产品类，但是一个工厂就生产了全部的产品 工厂方法模式是有一个抽象工厂派生出多个具体的工厂，每个工厂生产一件具体的产品 条件 抽象产品类 抽象工厂类 每个具体的产品类都有一个具体的工厂类生产 实现 我们对上面的实例进行改写，只需要定义一个抽象工厂类即可，其中派生出两个具体的工厂类用来生产圆形和矩形 这里的抽象产品接口和具体的产品类和上面相同，不需要写了 抽象工厂（使用的接口，其中有一个生产方法） 1234567/* * 抽象的工厂类 * 其中定义一个方法 getShape() 返回的是Shape类型的产品类 */public interface FactoryInterface &#123; public Shape getShape();&#125; 生产圆形的工厂类（实现抽象工厂） 1234567891011/* * 生产圆形的产品类 其中实现了抽象的工厂类 */public class FactoryCircle implements FactoryInterface &#123; @Override public Shape getShape() &#123; return new Circle(); &#125;&#125; 生产矩形的工厂类（实现抽象工厂接口） 123456789/** * 生产矩形的工厂类，其中实现了抽象工厂类 */public class FactoryRectangle implements FactoryInterface &#123; @Override public Shape getShape() &#123; return new Rectangle(); &#125;&#125; 测试类 123456789101112public class ClientMain &#123; public static void main(String[] args) &#123; //使用多态创建工厂类 FactoryInterface factoryInterface=new FactoryCircle(); //创建圆形的工厂类 factoryInterface.getShape().draw(); //生成Circle对象并且调用方法 FactoryInterface factoryInterface2=new FactoryRectangle(); //创建矩形的工厂类 factoryInterface2.getShape().draw(); //生成Rectangle的对象并且调用方法 &#125;&#125; 优缺点 优点： 易于扩展，如果需要添加一个产品类，只需要添加一个具体的产品类和对应的工厂类即可，不需要对原工厂的方法进行任何的修改 在工厂方法模式中，用户只需要知道所需要产品的具体工厂类即可，不需要知道具体的创建过程，甚至不需要知道具体产品类的类名。 缺点： 每次新增一个产品时，都需要增加一个具体的产品类和具体的工厂类，明显的成倍增加代码。 抽象工厂模式 多个抽象产品类，派生出多个具体产品类；一个抽象工厂类，派生出多个具体工厂类；每个具体工厂类可创建读个具体产品类实例。 即是提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们的具体的类。“一对多的关系” 这里的抽象产品类就像是一类产品的族，其中具体实现类就是不同的表现形式而已。 这里的每一个具体的工厂类可以生产不同种类的产品，并不是一个具体的工厂类只能生产一个具体的产品罢了 下面我们举一个麦当劳和肯德基的例子，他们两家中都买薯条和鸡翅，那么薯条和鸡翅就是两类产品，麦当劳和肯德基就是具体的工厂类用来生产薯条和鸡翅，那么我们需要一个抽象的工厂类来生产这两类产品，肯德基和麦当劳只需要实现即可。 总结定义 简单的说： 抽象工厂模式一个一个工厂生产一个产品类族 其中的工厂并不是生产一种产品，而是生产多种产品（一类的产品） 条件 多个抽象产品类派生出多个具体的产品类，比如鸡翅(麦当劳，肯德基)，薯片（麦当劳，肯德基） 一个抽象工厂，派生出多个具体的工厂类，比如肯德基和麦当劳就相当于两个工厂，这两个工厂都生产各自品牌的鸡翅，薯片，汉堡等 实现 抽象产品类 这里我们有两种产品，一个是鸡翅，一个薯片，因此需要创建两个抽象产品接口 鸡翅的抽象接口 1234567/* * 鸡翅的接口，这是一类产品的接口，在其中可以实现具体的产品类，比如麦当劳的麦乐鸡，肯德基的奥尔良烤翅*/public interface IChicken &#123;public void eat();&#125; 薯片的抽象接口 123456/* * 薯条的接口，这也是一个抽象的产品类，其中可以有多个具体的产品类，比如麦当劳的薯条，肯德基的薯条 */public interface IChips &#123; public void eat();&#125; 抽象工厂类 抽象工厂类只有一个，但是具体的工厂类一个是麦当劳，一个肯德基，工厂中生产各自品牌的产品 抽象工厂 12345678910/* * 抽象工厂类，用来生产鸡翅和薯条的工厂类，下面可以衍生出多个具体的工厂类来生产指定商家的鸡翅和薯条 */public interface IStore &#123; public IChicken createChicken(); // 生产鸡翅 public IChips createChips(); // 生产薯条&#125; 具体的产品类 肯德基的薯条 123456789101112/** * 肯德基的薯条，是IChips具体实现类，也是一个具体的产品类 */public class KfcChips implements IChips &#123; @Override public void eat() &#123; System.out.println("你吃了肯德基的薯条......"); &#125; &#125; 肯德基的鸡翅 1234567891011/* * 肯德基的奥尔良烤翅类，是IChicken的具体实现类，是一个具体的产品 */public class KfcChicken implements IChicken &#123; @Override public void eat() &#123; System.out.println("你吃了肯德基的奥尔良烤翅......"); &#125;&#125; 麦当劳的薯条 1234567891011/** * 麦当劳的薯条，是IChips具体实现类，也是一个具体的产品类 */public class McChips implements IChips &#123; @Override public void eat() &#123; System.out.println("你吃了麦当劳的薯条......"); &#125;&#125; 麦当劳的鸡翅 1234567891011/* * 麦当劳的鸡翅，这是IChicken的具体的实现产品类 */public class McChicken implements IChicken &#123; @Override public void eat() &#123; System.out.println("你吃了的麦当劳的鸡翅......"); &#125; &#125; 具体的工厂类 麦当劳的工厂类 12345678910111213141516/* * 麦当劳的工厂，实现了抽象工厂，这个工厂可以生产麦当劳的鸡翅和薯条 */public class McFactory implements IStore &#123; @Override public IChicken createChicken() &#123; return new McChicken(); // 生产麦当劳的鸡翅 &#125; @Override public IChips createChips() &#123; return new McChips(); // 生产麦当劳的薯条 &#125;&#125; 肯德基的工厂类 12345678910111213141516/* * 肯德基的工厂，实现了抽象工厂，这个工厂可以生产肯德基的鸡翅和薯条 */public class KFCFactory implements IStore &#123; @Override public IChicken createChicken() &#123; return new KfcChicken(); // 生产肯德基的鸡翅 &#125; @Override public IChips createChips() &#123; return new KfcChips(); // 生产肯德基的薯条 &#125;&#125; 测试类 1234567891011121314public class ClientMain &#123; public static void main(String[] args) &#123; IStore iStore1=new KFCFactory(); //创建肯德基的具体工厂类 iStore1.createChicken().eat(); //吃了肯德基的鸡翅 iStore1.createChips().eat(); //吃了肯德基的薯条 IStore iStore2=new McFactory(); //创建麦当劳的具体工厂类 iStore2.createChicken().eat(); //吃了麦当劳的鸡翅 iStore2.createChips().eat(); //吃了麦当劳的薯条 &#125;&#125; 优缺点 优点 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。 缺点 产品族比较难扩展，比如你要添加一个鞋子这个产品族，那么需要自己定义一个鞋子的抽象产品类，还要添加这个不同品牌的具体的产品实现类，另外还需要在抽象工厂里添加一个生产鞋子的方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之单例模式]]></title>
      <url>%2F2018%2F04%2F12%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[创建型模式之单例模式(Singleton)什么是单例模式 该类只有一个实例 构造方法是私有的 有一个获取该类对象的静态方法getInstance() 应用场景 一个国家只有一个主席 如果此时的限定必须是抽象出来的类只能是一个对象，这个时候就需要使用单例模式 懒汉式什么是懒汉式 懒汉式是当用到这个对象的时候才会创建，即是在getInstance()方法创建这个单例对象 优缺点 只有用到的时候才会创建这个对象，因此节省资源 线程不安全 我们知道一旦我们使用了懒汉式就是在getInstance()方法中创建这个单例对象，那么不可避免的就是线程安全问题 实现12345678910111213141516171819202122/** * 懒汉式的单例模式： 不是线程安全的 * 优点： 在使用的时候才会初始化，可以节省资源 */public class SignalLazy &#123; // 将默认的构造器设置为private类型的 private SignalLazy() &#123; &#125; // 静态的单例对象 private static SignalLazy instance; //静态的获取单例的对象，其中有一个判断，如果没有初始化，那么就创建 public static SignalLazy getInstance() &#123; // 如果instance没有被初始化，那么就创建即可，这个是保证了单例，但是并不是线程安全的 if (instance == null) &#123; System.out.println("this is SignalLazy"); instance = new SignalLazy(); // 创建一 个对象 &#125; return instance; // 返回这个对象 &#125;&#125; 从上面的代码中我们可以知道一旦使用多线程创建对象，那么就会出现线程不安全，最后创建出来的就不是单例了 测试代码如下 12345678910111213141516171819public class MainTest &#123; public static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; //创建实例，并且输出其中的地址，如果地址相同， 那么就是同一个实例 System.out.println("this is"+ SignalLazy.getInstance()); &#125; &#125;).start(); //主线程也是创建输出其中的地址，运行可以看出这两个地址是不一样的 System.out.println("this is"+SignalLazy.getInstance()); &#125;&#125; 解决线程不安全 线程同步锁(synchronized) 我们知道每一个类都有一个把锁，我们可以使用线程同步锁来实现线程同步方法 但是使用线程同步锁浪费资源，因为每次创建实例都需要请求同步锁，浪费资源 12345678public synchronized static SignalLazy getInstance() &#123; // 如果instance没有被初始化，那么就创建即可，这个是保证了单例，但是并不是线程安全的 if (instance == null) &#123; System.out.println("this is SignalLazy"); instance = new SignalLazy(); // 创建一个对象 &#125; return instance; // 返回这个对象 &#125; 双重校验 双重校验： 两次判断单例对象是否为 null，这样的话，当当线程经过这个判断的时候就会先判断，而不是等待，一旦判断不成立，那么就会继续执行，不需要等待 相对于前面的同步方法更加节省资源 123456789101112131415161718192021222324public class SignalTonDoubleCheck &#123; private volatile static SignalTonDoubleCheck instance = null; private SignalTonDoubleCheck() &#123; &#125;; // 将默认的构造方法设置私有 public static SignalTonDoubleCheck getInstance() &#123; if (instance == null) &#123; synchronized (SignalTonDoubleCheck.class) &#123; if (instance == null) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 这个new 并不是原子操作，因此当多线程进行到这里需要及时刷新这个值，因此要设置为voliate instance = new SignalTonDoubleCheck(); &#125; &#125; &#125; return instance; &#125;&#125; 匿名内部类 （推荐使用） 我们知道静态变量、静态代码块、静态方法都是在类加载的时候只加载一次 12345678910111213141516public class SignalTonInnerHolder &#123; //私有构造函数 private SignalTonInnerHolder() &#123; &#125; /* * 匿名内部类，其中利用了静态成员变量在类加载的时候初始化，并且只加载一次，因此保证了单例 */ private static class InnerHolder &#123; private static SignalTonInnerHolder instance = new SignalTonInnerHolder(); &#125; public static SignalTonInnerHolder getInstance() &#123; return InnerHolder.instance; //加载类 &#125;&#125; 一旦加载SignalTonInnerHolder类的时候就会加载其中的静态类，随之加载的就是其中的创建对象语句，因此在类加载的时候就完成了创建，这个和我们后面说的饿汉式有点相同 饿汉式什么是饿汉式 在类加载的时候就创建单例对象，而不是在getInstance()方法创建 所谓的饿汉式就是利用静态成员变量或者静态语句块在类加载的时候初始化，并且只初始化一次，因此这个是线程安全的，但是在没有用到的时候就初始化，那么是浪费资源 优缺点 还没用到就创建，浪费资源 类加载的时候就创建，线程安全 实现12345678910111213141516/* * 饿汉式：线程安全 * */public class SignalHungry &#123; private SignalHungry() &#123; &#125; // 静态变量只有在类加载的时候初始化一次，因此这个是线程安全的 private static SignalHungry instance = new SignalHungry(); public static SignalHungry getInstance() &#123; return instance; &#125;&#125; 测试12345678910111213141516171819public class MainTest &#123; public static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; //创建实例，并且输出其中的地址，如果地址相同， 那么就是同一个实例 System.out.println("this is"+ SignalHungry.getInstance()); &#125; &#125;).start(); //主线程也是创建输出其中的地址，运行可以看出这两个地址是不一样的 System.out.println("this is"+SignalHungry.getInstance()); &#125;&#125; 总结 饿汉式在类加载的时候就会创建单例对象，因此浪费资源 懒汉式在用到的时候才创建，节省资源，但是线程不安全，但是我们可以使用匿名内部类的方式使其线程安全 一般在使用的时候会使用懒汉式的匿名内部类的实现和饿汉式的创建方式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之常见关系]]></title>
      <url>%2F2018%2F04%2F12%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B8%B8%E8%A7%81%E5%85%B3%E7%B3%BB%2F</url>
      <content type="text"><![CDATA[继承和泛化 泛华关系是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。 使用三角箭头的实线表示继承，其中箭头指向的是父类 接口与实现 在java中一个类只能继承一个父类，但是可以实现多个接口 使用的是带三角的虚线表示，其中箭头指向的是接口 依赖 是一种使用关系，即一个类的实现需要另外一个类的协助，所以尽量不使用双向的依赖关系。 最典型的就是import 比如：一个类要定义String类型的变量，那么这个类就是依赖String这个类 关联 是一种拥有的关系，它使一个类知道另外一个类的属性和方法，比如数据库中的关系，通过学生可以查找到自己课程的成绩，只需要在学生中定义一个课程的对象即可。 代码体现： 成员变量 带普通箭头的实心线，指向被拥有者 聚合 是整体和部分的关系，且部分可以离开整体而单独的存在。车和轮胎是整体和部分的关系，但是轮胎离开车还是可以单独存在的 代码体现： 成员变量 带空心菱形的实心线，菱形指向整体 组合 是整体和部分的关系，但是部分不能离开整体而单独存在 代码体现：成员变量 带实心菱形的实线，菱形指向整体]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Struts2之类型转换器]]></title>
      <url>%2F2018%2F04%2F12%2FStruts2%E4%B9%8B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%99%A8%2F</url>
      <content type="text"><![CDATA[Struts2之类型转换器 在我们接收表单的请求参数的时候其实默认的都是String类型，但是有时候我们需要其他的数据类型，比如int,double,float,Date。 其实前面表单的传值都是字符串形式的，但是为什么我们在JavaBean中定义了不同的类型的数据，Struts还是会正确接收表单传递过来的值呢，因为使用了Struts中的内建的类型转换器 传统的类型转换器 在Servlet中我们可以自己获取请求参数自己转换类型，通常使用request.getParamerter(String name) 获取请求的参数 如下: 123String username= requst.getParameter("username");//获取年龄然后转换成了整数int age=Integer.parseInt(requst.getParameter("age")); 内建的类型转换器 其实内建的类型转换器已经可以完成大部分的功能了，比如表单传值，其实传递的是字符串，但是我们在JavaBean中定义的却是不同类型的数据，内部原理就是用了内置的类型转换器 内建类型转换器可以完成基本类型之前的转换 自定义类型转换器 前面说的内建的类型转换器只是在普通的类型之间的转换，都是一些基本的类型可以实现自动转换，并不用自己定义类型转换器。但是我们现在需要将输出的字符串转换为复合对象，比如一个User（username，password）类，那么现在就不能使用内建的类型转换器自动转换了，现在需要自己定义类型转换器了。 实现类型转换器也是基于OGNL实现的，在OGNL中有一个TypeConverter接口，但是这个接口太复杂了，因此OGNL还提供了一个类DefaultTypeConverter，通过继承这个类就可以实现类型转换器了。 假设我们在登录界面需要在一个text中输入用户名和密码用逗号隔开，现在我们可以使用自定义的转换器。现在登录的JSP如下: 12345&lt;form action="http://localhost:8080/web3/login" method="post"&gt; &lt;label&gt;请输入用户名和密码(逗号隔开)：&lt;/label&gt; &lt;input type="text" name="user"&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt; 定义的User类如下 12345678910111213141516public class User &#123; private String username; //用户名 private String password; //密码 public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; Action类 12345678910111213141516import com.opensymphony.xwork2.Action;import com.user.User;public class LoginAction implements Action &#123; private User user; // User对象 public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public String execute() throws Exception &#123; return SUCCESS; &#125;&#125; UserConverter（转换器类） 123456789101112131415161718192021222324252627282930313233import java.util.Map;import com.user.User;import ognl.DefaultTypeConverter;public class UserConverter extends DefaultTypeConverter &#123; /* * context：类型转换的上下文环境 * value: value是需要转换的参数，随着转换的方向不同，value的参数值也是不一样的，因此需要强制转化 * toType： 表示转换后的目标类型 */ public Object convertValue(Map context, Object value, Class toType) &#123; System.err.println("调用了"); // 有字符串转http://download.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html#sum换为User类 // toType表示转向的类型 if (toType == User.class) &#123; String[] params = (String[]) value; // 将字符串转换为数组 User user = new User(); // 创建User对象 // 利用逗号将数组中的第一个字符串分割为两个字符串，设置成username，password user.setUsername(params[0].split(",")[0]); user.setPassword(params[0].split(",")[1]); return user; // 最后一定要返回User对象 &#125; // 如果是从复合类转换为字符串 else if (toType == String.class) &#123; User user = (User) value; // 将value转换为User对象 // 最后返回一个字符串表现的形式 return user.getUsername() + "," + user.getPassword(); &#125; else &#123; return null; // 没有相互转换的条件返回null &#125; &#125;&#125; 从上面的代码可以看出有两类的转换:一是从字符串转换为User类，二是从User类转换为字符串，这个都是使用toType来控制的。 ConverterValue方法参数和返回值的含义 context： 是类型转换环境的上下文 value ：是需要转换的类型参数。随着转换方向的不同，value参数的值也是不一样的，当把字符串类型转换为User类型时，value就是原始字符串。当需要把User类型向字符串类型转换时，value是User的实例。当然无论向哪一个方向转换，value都是需要强制转换的。 toType: 是转换后的目标类型。 为什么自己当向User类转换的时候，value要转换为一个字符数组呢？ 因为这里对应的是一个文本，如果我们对应的是一个多选框，那么此时就是一个数组了，因此这里强制转换为数组是一个通用的写法 局部转换器 转换器分为局部转换器和全局转换器，局部转换器是针对指定的Action类，但是全局转换器是针对的是该项目中所有需要转换的Action类。 前面已经实现了Action类，现在我们只需要定义一个ActionName-conversion.properties文件和Action放在一个目录下即可，其中的ActionName是Action的类名，比如上面的Action类是LoginAction，那么这里的文件就是LoginAction-conversion,.properties。其中的内容如下： user是Action中定义User对象，com.converter.UserConverter是对应的转换的类，一定要定义到包名。 1user=com.converter.UserConverter 全局转换器 全局转换器是作用于全部需要转换的Action的，只需要定义一个xwork-conversion. Properties。这个的名字就不需要改变了，放在src目录下即可，这样才可以作用到全局中。内容如下: 12com.user.User=com.converter.UserConvertercom.date.Date=com.converter.Date 其中的内容是一键值对存在的，com.user.User对应的是定义的JavaBean类，这里不再是action类中的定义的User对象了，是需要转换对象的类，com.converter.UserConverter这个是定义转换器的类。 从上面我们可以看出来定义两个转换器，最后一个是将字符串转换为日期类型的转换器。其实其中可以定多个类型转换器，并且只要是一键值对的形式写出即可。 基于Struts2的类型转换器 上面的类型转换器都是基于OGNL的DefaultTypeConverter类实现的，基于该类实现转换时都要实现ConverterValue()方法，无论是从字符串转换为复合类型还是从复合类型转换为字符串都是在这个方法中实现。 为了简化类型转换器的实现，Struts2提供了一个StrutsTypeConverter抽象类，这个抽象类是DefaultTypeConverter的子类。其中重要的方法如下: public Object convertFromString(Map context, String[] values, Class toClass)将字符串转换为复合类型个方法。 context是上下文环境，value是字符串数组，toClass是要转换的类型 public String convertToString(Map context, Object values) 将复合类型转换为字符串 values是复合类对象，context是上下文环境 public Object convertValue(Map context, Object values, Class toClass)实现DefaultTypeConverter方法，其中的变量还是上面的意思 下面实现上面的登录转换，如下: 12345678910111213141516171819202122232425import java.util.Map;import org.apache.struts2.util.StrutsTypeConverter;import com.user.User;public class UserConverterStruts extends StrutsTypeConverter &#123; protected Object performFallbackConversion(Map context, Object o, Class toClass) &#123; return super.performFallbackConversion(context, o, toClass); &#125; // 将字符串转换为复合类型的方法 public Object convertFromString(Map context, String[] values, Class toClass) &#123; User user = new User(); //创建User对象 String[] userValues = values[0].split(","); // 将字符串数组中的第一个字符串分隔开 user.setUsername(userValues[0]); user.setPassword(userValues[1]); return user; &#125; // 将复合类型转换为字符串 public String convertToString(Map context, Object values) &#123; User user = (User) values; //强制转换成User类型的 String username = user.getUsername(); //获取username和password String password = user.getPassword(); return "&lt;" + username + "," + password + "&gt;"; &#125;&#125; 有了上面的转换器，那么局部转换器和全局转换器的配置还是和上面的一样，这里就不在赘述了。 数组属性的类型转换器 数组类型的转换器是用于提交的参数为数组的类型的，也就是同时Action中有一个属性为数组。 现在我们要同时输入两个用户的信息，jsp如下: 123456&lt;form action="http://localhost:8080/web3/login" method="post"&gt;&lt;label&gt;请输入用户名和密码(逗号隔开)：&lt;/label&gt;&lt;input type="text" name="users"&gt;&lt;input type="text" name="users"&gt;&lt;input type="submit" value="提交"&gt;&lt;/form&gt; 从上面的代码我们可以看出这里text中有两个name属性相同的表单，这个同时提交上去就是一个数组。 Action类：(定义一个User数组): 12345678910111213141516171819import com.opensymphony.xwork2.Action;import com.user.User;public class LoginSAction implements Action &#123; private User[] users; //定义数组类型User public User[] getUsers() &#123; return users; &#125; public void setUsers(User[] users) &#123; this.users = users; &#125; public String execute() throws Exception &#123; System.out.println(getUsers()[0].getUsername()); return SUCCESS; &#125;&#125; 数组转换器: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.Map;import org.apache.struts2.util.StrutsTypeConverter;import com.user.User;public class UsersConverterStruts extends StrutsTypeConverter &#123; // 将字符串转换复合类型 public Object convertFromString(Map context, String[] values, Class toClass) &#123; if (values.length &gt; 1) &#123; User[] results= new User[values.length]; // 创建对象，这里是创建和字符串数组一样的长度 // 遍历所有的字符串数组，然后将其填入每一个User对象中 for (int i = 0; i &lt; values.length; i++) &#123; User user=new User(); //创建user对象 String[] uservalues = values[i].split(","); user.setUsername(uservalues[0]); // 将其设置为User的属性 user.setPassword(uservalues[1]); results[i]=user; //将实例化的user对象，填入数组 &#125; return results; &#125; else &#123; // 这里表示数组中只有一个字符串 User user = new User(); // 创建对象 String[] uservalues = values[0].split(","); user.setUsername(uservalues[0]); user.setPassword(uservalues[1]); return user; &#125; &#125; // 将复合类型转换为字符串 public String convertToString(Map context, Object values) &#123; // 只是一个单个的User类型的 if (values instanceof User) &#123; User user = (User) values; String username = user.getUsername(); String password = user.getPassword(); return "&lt;" + username + "," + password + "&gt;"; &#125; // User数组 else if (values instanceof User[]) &#123; User[] users = (User[]) values; //转换为User数组 String results = "["; for (User user : users) &#123; String username = user.getUsername(); String password = user.getPassword(); results += "&lt;" + username + "," + password + "&gt;"; &#125; return results + "]"; //返回全部的字符串 &#125; else &#123; return ""; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Struts之标签库]]></title>
      <url>%2F2018%2F04%2F12%2FStruts%E4%B9%8B%E6%A0%87%E7%AD%BE%E5%BA%93%2F</url>
      <content type="text"><![CDATA[Struts标签库 如果想要在jsp页面使用struts2的标签，需要引入标签库 &lt;%@ taglib uri=&quot;/struts-tags&quot; prefix=&quot;s&quot;%&gt; 数据标签 作用: 用于数据的存储和处理 action action标签是用来在JSP页面中调用Action某个Action类的，该标签有如下的几个属性； Id该属性用来指定Action的引用id name该属性是用来指定Action类的映射地址 namespace该属性用来指定Action类所在namespace executeResult该属性用来指定是否将Action类的处理结果也跳转的那个视图内容包含到本页面中，默认值为false，不包含 ignoreContextParams该属性用来指定是够将请求的参数传入到Action中，默认为false，即是传入 1234567891011&lt;h1&gt;调用第一个action&lt;/h1&gt;&lt;!-- 调用登录的Action类，name指定&lt;action&gt;标签的name属性值，executeResult为true指示包含Action响应的内容 namespace指定Action类所在包指定的namespace--&gt;&lt;s:action name="login" executeResult="true" namespace="/"&gt;&lt;/s:action&gt;&lt;hr&gt;&lt;h1&gt;调用第二个action&lt;/h1&gt;&lt;!-- 调用第二个Action，表示注册页面，ignoreContextParams为true表示不传入参数，那么其中的password和username就不能接收参数了，因此输出为NULL --&gt;&lt;s:action name="regist" executeResult="true" namespace="/" ignoreContextParams="true"&gt;&lt;/s:action&gt; bean bean标签用来创建一个JavaBean实例，和action标签差不多，就是在jsp页面中调用JavaBean对象，创建一个对象,不过这个对象是存在Stack Context中的，不是值栈中的。 id用来表示创建的JavaBean类的实例，这个是用来在Stack Context中查看状态的,使用标签 name用来指定JavaBean，指定JavaBean类所在的路径 var这个是id一样的功能，其实可以代替id 12345678&lt;s:bean name="com.user.User" id="myBean" &gt; &lt;!-- 使用param标签为其赋值 --&gt; &lt;s:param name="username" value="'陈加兵'"&gt;&lt;/s:param&gt; &lt;s:param name="age" value="22"&gt;&lt;/s:param&gt; 姓名: &lt;s:property value="username"/&gt;&lt;br&gt; 年龄:&lt;s:property value="age"/&gt;&lt;/s:bean&gt; date date标签用于格式化一个日期，除了格式化输出当前的日期，也可以计算指定的日期和当前日期时刻之间的时差 format可选属性，用于指定格式化的格式，如yyyy/MM/dd-HH:mm:ss name必填的值，该属性指定格式化日期的值，比如Date对象 nice可选属性，如果为true那么将会输出指定日期和当前日期的时差，默认为false timezone可选属性，指定格式化所用的时区 var可选属性，如果指定了该属性，该时间对象将放入值栈中，可以使用id代替，但是推荐使用var 如果同时指定了nice=true，和format那么format将会失效 1234&lt;!-- 创建一个日期对象now，表示当前的时间 --&gt; &lt;s:set var="now" value="new java.util.Date()"&gt;&lt;/s:set&gt; &lt;!-- 格式化当前的日期--&gt; &lt;s:date name="#now" format="dd/MM/yyyy HH:mm:ss"/&gt;&lt;br&gt; debug 该标签是辅助标签，用来生成一个超链接，便于查看值栈，和Stack Context中的信息。 i18n 主要用于在视图上加载国际资源，使用该标签时需要指定一个name属性，该name属性为需要加载的国际化资源文件的basename include 将指定的jsp文件或者Servlet文件包含在当前的jsp页面，这个相当于标签。 value指定被包含的jsp或者Servlet文件路径 1&lt;s:include value="success.jsp"&gt;&lt;/s:include&gt; param param标签主要是为其他的标签提供参数的 注意value的值是使用的OGNL表达式，一定要注意，如果指定字符串要加单引号或者双引号 name指定要赋值的变量名 value指定变量的值 12345&lt;s:bean name="com.user.User" id="myBean" &gt; &lt;!-- 使用param标签为其赋值 --&gt; &lt;s:param name="username" value="'陈加兵'"&gt;&lt;/s:param&gt; &lt;s:param name="age" value="22"&gt;&lt;/s:param&gt;&lt;/s:bean&gt; push push标签用于将某个值放到ValueStack(值栈)中，从而更简单的访问该值，其实不将其防放置在值栈中也是可以访问，使用#即可。只有一个属性value就是需要放在栈顶的值 1234567891011121314&lt;s:bean name="com.user.User" id="myBean"&gt; &lt;s:param name="username" value="'陈加兵'"&gt;&lt;/s:param&gt; &lt;s:param name="age" value="22"&gt;&lt;/s:param&gt;&lt;/s:bean&gt;&lt;%-- 只有在push标签内是，被放到值栈中的对象才存在，一旦出了push标签那么就不存在了 --%&gt; &lt;s:push value="#myBean"&gt; &lt;s:property value="username"/&gt; &lt;s:property value="age"/&gt; &lt;!-- 这个可以看出值栈中有值 --&gt; &lt;s:debug&gt;&lt;/s:debug&gt; &lt;/s:push&gt; &lt;!-- 这个没有myBean对象 --&gt; &lt;s:debug&gt;&lt;/s:debug&gt; set set标签是用来将某一个值放入指定的范围，当然也是相当于创建一个新的变量 id该属性用来指定该元素的引用ID（废弃） var该属性用来指定创建的新变量的名称 value用来指定变量的值，这个是使用的OGNL表达式 scope该属性用来指定新变量的放置范围，可选值有page,request,session,application和action，如果没有指定该属性，则默认放在Stack Context中 12&lt;s:set var="x" value="'陈加兵'"&gt;&lt;/s:set&gt;&lt;s:property value="#x"/&gt; 获取指定范围的值,其实相当于在指定的范围内绑定属性值，可以实现数据共享： 12&lt;s:set var="x" value="'陈加兵'" scope="session"&gt;&lt;/s:set&gt;&lt;s:property value="#session.x"/&gt; 其实set的真正的作用是变量放置在指定的范围内，如果一个属性的访问的太繁琐了，比如访问user.name,但是这个值需要频繁的使用，这时就创建一变量存放这个值，并且设定范围: 12&lt;s:set var="x" value="user.name"&gt;&lt;/s:set&gt;&lt;s:property value="#x"/&gt; url url标签用于在页面生成一个url地址，该标签的属性如下: id指定该元素的引用id，如果指定了该属性，那么在Stack Context中就会有这个id，那么就可以使用#来获取它的值 value该属性用来指定生成URL地址，如果不指定该属性，那么action属性指定的Action作为URL地址 action该属性用来指定生成URL地址值的action，如果不指定该属性，那么使用value属性值作为URL地址值 method该属性用来指定使用action的方法 encode该属性用来指定是否需要encode请求参数，默认值为true includeParams该属性用来指定是否包含请求参数，可选值为：none,get,和all默认的为none includeContext该属性指定是否需要当前上下文包含在url地址中 anchor该属性指定URL的锚点 Scheme该属性用来指定URL使用的协议(HTTP或者HTTPS) namespace该属性用来指定命名空间，使用action的时候指定 1234567891011121314&lt;s:url value="success.jsp" includeParams="get" id="myUrl"&gt; &lt;s:param name="username" value="'陈加兵'"&gt;&lt;/s:param&gt;&lt;/s:url&gt;&lt;hr&gt;&lt;s:url action="login"&gt;&lt;/s:url&gt;&lt;hr&gt;&lt;s:url action="login" namespace="/user" includeParams="get"&gt; &lt;s:param name="username" value="'陈加兵'"&gt;&lt;/s:param&gt;&lt;/s:url&gt;&lt;hr&gt;&lt;!-- 获取值 --&gt;&lt;s:property value="#myUrl"/&gt; property property标签是用来在页面中输出指定值，该标签有如下属性: id指定该元素的标识（废弃） value指定需要输出的特定的值，注意这里使用的OGNL表达式，如果没有指定value属性，那么将会输出值栈中的栈顶的值 escape指定是否转义输出内容中HTML，其默认值为true default指定一个默认的输出值，如果value中的值为空，那么就会默认输出这个值 123456&lt;!-- 转义标签h1，输出内容 --&gt;&lt;s:property value="'&lt;h1&gt;陈加兵&lt;/h1&gt;'" escape="false"/&gt;&lt;!-- 输出Stack Context中的内容，并且指定了默认值 --&gt;&lt;s:property value="#username" default="输出一个默认值"/&gt;&lt;!-- 输出栈顶的值 --&gt;&lt;s:property/&gt; 总结 数据标签最重要的就是set,property,debug,i18n这些标签，其他的了解写即可 控制标签 控制标签主要用于条件和循环等流程控制 if/elseif/else 其中elseif允许出现多次 12345678910&lt;s:set var="age" value="22"&gt;&lt;/s:set&gt;&lt;s:if test="#age&gt;10"&gt; &lt;s:property value="#age+'大于10'" /&gt;&lt;/s:if&gt;&lt;s:elseif test="#age&gt;20"&gt; &lt;s:property value="#age+'大于20'" /&gt;&lt;/s:elseif&gt;&lt;s:else&gt; &lt;s:property value="#age+'在10与20之间'" /&gt;&lt;/s:else&gt; 并且和或的关系(&amp;&amp;,||) 123456789&lt;%-- 新建一个集合list --%&gt;&lt;s:set var="list" value="&#123;'陈加兵','郑元梅',22,33&#125;"&gt;&lt;/s:set&gt;&lt;%-- 指定begin,end获取前3个元素--%&gt;&lt;s:iterator value="#list" var="item" status="iter"&gt; &lt;s:if test="#iter.isOdd()&amp;&amp;#iter.getIndex()&gt;0"&gt; &lt;s:property value="#item+'---'+#iter.getIndex()"/&gt; &lt;br&gt; &lt;/s:if&gt;&lt;/s:iterator&gt; iterator iterator标签主要用于对集合进行迭代，这里的集合包含list，Set和数组，也可以对Map集合进行迭代输出。 value可选属性，该属性指定迭代的集合，如果没有指定value属性，那么就会迭代ValuStack栈顶的集合。 var可选属性，该属性指定的是迭代的集合中的每一个元素，放在Stack Context中· status可选属性，该属性指定迭代对象的IteratorStatus实例存放在Stack Context中，通过这个属性可以判断当前迭代元素的属性。例如是否为最后一个，以及当前元素的索引 begin可选属性，指定从迭代对象第几个元素开始迭代 end可选属性，指定迭代到对象的第几个元素结束 step可选属性，指定步长 如果迭代元素指定了status，那么就可以调用如下的属性查看迭代元素的当前的属性，可以调用如下的几个方法查看： int getCount() 返回当前迭代了几个元素 int getIndex() 返回当前迭代元素的索引 boolean isEven() 当前迭代元素的索引是否为偶数 boolean isFirst() 当前迭代元素是否为第一个元素 boolean isLast() 当前迭代元素是否为最后一个元素 boolean isOdd() 判断当前的迭代元素的索引是否为奇数 此标签每次进行迭代的时候就会把元素放在值栈的顶部，那么我们都知道如果不指定value属性，那么默认的就是从栈顶取元素： 1234567&lt;%-- 新建一个集合list --%&gt; &lt;s:set var="list" value="&#123;'陈加兵','郑元梅',22,33&#125;"&gt;&lt;/s:set&gt; &lt;%--指定了value属性，但是其他属性都没有，那么直接可以从栈顶取数据 --%&gt; &lt;s:iterator value="#"&gt; &lt;s:property/&gt; &lt;/s:iterator&gt; 指定var属性来获取迭代对象的值: 1234567&lt;%-- 新建一个集合list --%&gt; &lt;s:set var="list" value="&#123;'陈加兵','郑元梅',22,33&#125;"&gt;&lt;/s:set&gt;&lt;%-- 指定var表示当前迭代对象的每一个元素--%&gt; &lt;s:iterator value="#list" var="item"&gt; &lt;%-- 因为var元素是放在Stack Context中，因此可以使用#取值 --%&gt; &lt;s:property value="#item" /&gt; &lt;/s:iterator&gt; 指定begin，end来获取指定范围的值。 12345678&lt;%-- 新建一个集合list --%&gt; &lt;s:set var="list" value="&#123;'陈加兵','郑元梅',22,33&#125;"&gt;&lt;/s:set&gt; &lt;%-- 指定begin,end获取前3个元素--%&gt; &lt;s:iterator value="#list" var="item" begin="0" end="2"&gt; &lt;%-- 因为var元素是放在Stack Context中，因此可以使用#取值 --%&gt; &lt;s:property value="#item" /&gt; &lt;/s:iterator&gt; 指定status获取每一个迭代元素的当前状态: 12345678910&lt;%-- 新建一个集合list --%&gt; &lt;s:set var="list" value="&#123;'陈加兵','郑元梅',22,33&#125;"&gt;&lt;/s:set&gt; &lt;%-- 指定begin,end获取前3个元素--%&gt; &lt;s:iterator value="#list" var="item" status="iter"&gt; &lt;s:if test="#iter.isOdd()&amp;&amp;#iter.getIndex()&gt;0"&gt; &lt;s:property value="#item+'---'+#iter.getIndex()"/&gt; &lt;br&gt; &lt;/s:if&gt; &lt;/s:iterator&gt; 迭代Map 12345&lt;s:set var="map" value="#&#123;'age':22,'username':'陈加兵' &#125;"&gt;&lt;/s:set&gt;&lt;s:iterator value="#map" var="item"&gt; 获取集合中的key:&lt;s:property value="#item.key"/&gt; 获取集合中的值：&lt;s:property value="#item.value"/&gt;&lt;/s:iterator&gt; append append标签用于将多个集合拼接起来形成一个新的集合。 var拼接之后形成的新的集合，放在Stack Context中 id这个和var是一样的，两个可以互换使用的，不过推荐使用var 12345678910111213&lt;%-- 新建一个集合list --%&gt;&lt;s:set var="list1" value="&#123;'陈加兵','郑元梅',22,33&#125;"&gt;&lt;/s:set&gt;&lt;s:set var="list2" value="&#123;44,55,6,99&#125;"&gt;&lt;/s:set&gt;&lt;s:append var="list3"&gt; &lt;%-- 使用param标签指定要拼接的集合 --%&gt; &lt;s:param value="#list1"&gt;&lt;/s:param&gt; &lt;s:param value="#list2"&gt;&lt;/s:param&gt;&lt;/s:append&gt;&lt;s:iterator value="#list3" var="item"&gt; &lt;s:property value="#item"/&gt;&lt;/s:iterator&gt; generator 使用这个标签可以将字符串按照指定的分隔符分割成多个子串，临时生成的子串可以使用标签迭代输出。可以这样理解：这个标签使用指定的的分隔符将字符串分割，然后这些字符串组成一个集合。 val必选属性，该属性指定被解析的字符串 var可选属性，如果指定了该属性，那么生成的Iterator对象将会以这个名称放在Stack Context中，就可以访问这个集合了。 count可选属性，该属性指定生成集合中元素的个数 separator必选属性，这个属性指定分隔符 converter可选属性，该属性指定一个转换器，该转换器负责将集合中的每一个字符串转换成对象，通过该转换器可以将一个字符串解析成对象集合。该属性值必须是org.apache.struts2.util.IteratorGenerator.Convertere 123456&lt;%--分隔符为',',并且选取其中的前两个元素 --%&gt; &lt;s:generator separator="," val="'陈加兵,郑元梅,chenjiabing'" var="x" count="2"&gt;&lt;/s:generator&gt; &lt;s:iterator value="#x" var="item"&gt; &lt;s:property value="#item" /&gt; &lt;/s:iterator&gt; merge merge这个标签和append的功能是一样的，都是将两个集合拼接在一起，但是append是将一个集合拼接在另外一个集合的末尾，但是merge是将后面一个集合的对应索引的元素添加到前面一个集合的索引所在的位置，也就是后面集合的第一个元素变成了新集合的第二个元素了。 123456789101112&lt;s:set var="list1" value="&#123;'陈加兵','郑元梅'&#125;"&gt;&lt;/s:set&gt; &lt;s:set var="list2" value="&#123;1,2&#125;"&gt;&lt;/s:set&gt; &lt;s:merge var="list3"&gt; &lt;s:param value="#list1"&gt;&lt;/s:param&gt; &lt;s:param value="#list2"&gt;&lt;/s:param&gt; &lt;/s:merge&gt; &lt;s:iterator var="item" value="#list3"&gt; &lt;s:property value="#item"/&gt; &lt;/s:iterator&gt; subset subset标签用于取得集合的子集，形成新的集合。 count可选属性，指定选取集合的子集的个数，如果不指定该属性，那么默认的就是截取全部的元素 source可选属性，该属性指定源集合，如果没有指定，那么默认是从栈顶取集合 start可选属性，该属性指定子集从源集合的第几个元素开始截取，默认从第一个开始(即start=0) decider可选属性，该属性有开发真决定是否选中该元素 var可选属性，如果指定了该属性，那么生成Iterator对象设置成为Page范围内的属性，可以使用#attr.name获取其值，也可以替换成id，但是推荐使用var 12345678910&lt;!-- 创建一个集合 --&gt; &lt;s:set var="list1" value="&#123;'陈加兵','郑元梅',1,2,3&#125;"&gt;&lt;/s:set&gt; &lt;!-- 指定变量为x，存储在page中，源集合为list1，截取其中的两个元素，从第二个元素开始截取 --&gt; &lt;s:subset var="x" source="#list1" count="2" start="1"&gt;&lt;/s:subset&gt; &lt;!-- 由于x存储在Page中，因此使用#attr.x来获取 --&gt; &lt;s:iterator value="#attr.x" var="item"&gt; &lt;s:property value="#item" /&gt; &lt;/s:iterator&gt; sort 主要用于对集合进行排序 comparator必填属性，该属性指定进行排序的实例，必须实现java.util.Comparator接口 source可选属性，这是一个源集合，如果没有指定，那么就拿栈顶的集合进行排序 var可选属性，如果指定了属性，那么生成的Iterator对象设置成Page范围的属性，该属性也可替换成id 12345678910&lt;s:set var="list" value="&#123;'陈加兵','123459999+','4442555'&#125;"&gt;&lt;/s:set&gt; &lt;!-- 创建一个实例 --&gt; &lt;s:bean name="com.compare.Compare" id="compare"&gt;&lt;/s:bean&gt; &lt;!-- 排序 --&gt; &lt;s:sort comparator="#compare" source="#list" var="x"&gt;&lt;/s:sort&gt; &lt;!-- 迭代输出 --&gt; &lt;s:iterator var="item" value="#attr.x"&gt; &lt;s:property value="#item" /&gt; &lt;/s:iterator&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Struts之OGNL使用]]></title>
      <url>%2F2018%2F04%2F02%2FStruts%E4%B9%8BOGNL%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[OGNL的使用OGNL简介 OGNI是一种对象图导航语言(object graphics navigation language) ,这也是一种表达式语言，这个和EL表达式一样，但是EL表达式只能在JSTL标签库中使用，这个OGNL只能在struts标签库中使用。 值栈（valueStack) 值栈就是存储Action的信息，包括其中定义的成员变量和其他的一些自己的属性，比如error,fieldError,如果想要让action中属性在值栈中显示或者获取，一定要为这些属性设置get,set方法 值栈是存储的action的栈，同时可以存储多个action，先执行的先进栈 值栈中的元素是根元素，访问值栈中的元素不需要使用#(#是访问非根元素的值，比如#session.username) 在jsp页面可以使用struts标签库&lt;s:debug/&gt;,查看值栈中的内容 实验 我们新建一个Action类，用表单传递数据请求action，最后action跳转到success.jsp页面，我们在success.jsp使用&lt;s:debug&gt;查看此时值栈中的数据 其中的属性必须要有get，set方法 LoginAction 123456789101112131415161718192021222324//实现ModelDriven接口&lt;&gt;指定的泛型为JavaBean类public class LoginAction extends ActionSupport &#123; private User user; private String tips; public String getTips()&#123; return tips; &#125; public void setTips(String tips)&#123; this.tips=tips; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; @Override public String execute() &#123; System.out.println("执行execute方法"); System.out.println(this.getUser().getName()+"------"+this.getUser().getPassword()); return SUCCESS; &#125; success.jsp页面 其中要引用struts2的标签库 12345678910111213&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib prefix="s" uri="/struts-tags" %&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:debug&gt;&lt;/s:debug&gt;&lt;/body&gt;&lt;/html&gt; 此时我们可以看到在值栈中有个user属性，并且有LoginAction 常量 我们现在先接触一下&lt;s:property value=&quot;&quot;&gt;标签，struts2中的标签在后面再详细讲解，这个标签的意思是输出属性的值 这个标签中的value属性填写的是OGNL表达式，如果我们要输出一个常量，那么我们必须使用单引号 引用struts2中的标签库&lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&gt; 字符常量 如果我们仍然使用上面的实例，但是我们要在success.jsp页面中使用OGNL使用显示表单传递过来的值，其中我们还输出自己的一个常量字符串 success.jsp 123456789101112131415161718&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib prefix="s" uri="/struts-tags" %&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;&lt;s:property value="user.name" default="如果为null，输出这个字段"/&gt;&lt;/h1&gt; &lt;h1&gt;&lt;s:property value="user.password" default="如果为null，输出这个字段" /&gt;&lt;/h1&gt; &lt;h1&gt;输出一个字符串常量: &lt;s:property value="'jack'"/&gt;&lt;/h1&gt; &lt;s:debug&gt;&lt;/s:debug&gt;&lt;/body&gt;&lt;/html&gt; 数值常量 int 1,2,3 double 1.24d或者1.24 float 1.23f long 122l 最后一个是字母l BigDecimal 123b BigInteger 123h 在其中直接输出即可:&lt;s:property value=&quot;1&quot;/&gt; 布尔常量 直接输出即可 &lt;s:property value=&quot;true&quot;/&gt; 总结 当需要输出一个字符串常量的时候，一定要使用单引号，否则就会默认的将其作为OGNL表达式，输出的就为空 集合list OGNL中的list相当于数组，其中存放的可以是任意类型的数据 读取的时候直接使用数组的形式读取即可，使用索引读取即可 我们的创建形式是使用&lt;s:set&gt;标签，因此这个变量不是值栈中的，需要使用# 1234&lt;!-- 创建list --&gt;&lt;s:set var="list" value="&#123;1,2,3,'jack',true&#125;"&gt;&lt;/s:set&gt;&lt;s:property value="#list[0]"/&gt;&lt;br&gt;&lt;s:property value="#list[4]"/&gt; Map 使用#{}的形式创建，其中存放的是键值对(key-value)的形式 读取的方式有两种 map[‘key’] map.key 123&lt;s:set var="map" value="#&#123;'name':'jack','age':22&#125;"&gt;&lt;/s:set&gt;&lt;s:property value="#map['name']"/&gt;&lt;s:property value="#map.age"/&gt; 访问action中的属性值 action都是存放在值栈中，我们可以使用OGNL读取值栈中的数据 使用上面的LoginAction类，我们通过表单提交到这个LoginAction中，跳转到success.jsp页面中，那么我们就可以在success.jsp页面中访问LoginAction属性的值(前提是属性必须有get，set方法) LoginAction中的属性是一个User对象，那么我们既可以获取这个User对象，之后在获取User对象中的数据了，这个相当于链式操作，前提还是有get，set方法 123&lt;!-- 这里的user一定要和LoginAction中的成员变量User的对象字段相同 --&gt;User对象中的name属性：&lt;s:property value="user.name"/&gt;User对象中的age属性：&lt;s:property value="user.age"/&gt; 操作符# 值栈中的的属性称为是根属性，#访问的是非根属性，就不是值栈中的值，比如#session.username 相当于调用ActionContext.getContext.getSession.getAttribute(&quot;username&quot;) 创建Map 过滤和投影 $符号 在国际化文件中使用OGNL表达式，例如年龄必须在${min}到${max}之间 在Struts配置文件中使用OGNL表达式，例如两个Action之间进行跳转，并且附带参数 % 符号 当标签的属性为字符串类型时，计算OGNL表达式的值。 123&lt;s:url value="#map.name"/&gt;&lt;br&gt;&lt;s:url value="%&#123;#map.name&#125;"/&gt; 大括号 {} 用来创建一个Map，其中存放的是键值对 创建一个list集合 12&lt;s:set var="map" value="#&#123;'name':'jack','age':22&#125;"&gt;&lt;/s:set&gt;&lt;s:property value="#map['name']"/&gt; in ,not in 判断某一个值是否存在一个集合中，返回的是布尔值 不过经过自己测试，只有数字类型的可以判断出来，字符串不能判断出来，如果哪位能够测出来，和我说说原因 123456&lt;!-- 创建一个集合list --&gt; &lt;s:set var="list" value="&#123;1,2,3,'jack','Tom'&#125;"&gt;&lt;/s:set&gt; &lt;s:property value="1 in #list"/&gt;&lt;br&gt; &lt;s:property value="1 not in #list"/&gt;&lt;br&gt; &lt;!-- 没有结果 --&gt; &lt;s:property value=" 'jack' in #list"/&gt;&lt;br&gt; + 这个和java是一样的，如果两个整数相加就执行整数相加，如果字符串相加就拼接 12&lt;s:property value=&quot;2+3&quot;/&gt;&lt;s:property value=&quot;&apos;ce&apos;+22&quot;/&gt; 集合的伪属性 集合的伪属性是用来代替java集合API的方法的属性，比如迭代器的使用 List list.iterator list.size Set set.iterator set.isEmpty Map map.keys （map.keySet） map.values (map.values) Iterator Iterator.next Iterator.hasNext Enumeration enum.next enum.hasNext 123456789101112131415161718192021&lt;%--创建列表 --%&gt;&lt;s:set var="list" value="&#123;1,'陈加兵'&#125;"&gt;&lt;/s:set&gt;&lt;%-- 创建Map --%&gt;&lt;s:set var="map" value="#&#123;'one':'陈加兵','tow':'郑元梅'&#125;"&gt;&lt;/s:set&gt;&lt;%-- 创建数组 --%&gt;&lt;s:set var="number" value="new String[]&#123;'aaa','bbb','ccc']"&gt;&lt;/s:set&gt;&lt;%-- 获取list的迭代器对象 --%&gt;&lt;s:set var="iter" value="#list.iterator"&gt;&lt;/s:set&gt;list的大小:&lt;s:property value="#list.size"/&gt;&lt;s:if test="#iter.hasNext"&gt; list中的第一个元素的值:&lt;s:property value="#iter.next"/&gt;&lt;/s:if&gt;&lt;hr&gt;&lt;%-- #map.keys返回的是set类型，然后使用迭代器输出即可 --%&gt;&lt;s:property value="#map.keys.iterator.next" default="NULL"/&gt;&lt;s:property value="#map.values"/&gt; 投影 在OGNL中，投影是对一个集合中对每一个元素调用相同的方法，或者抽取相同的属性，并将一个结果保存为一个新的集合。 下面的例子是将集合list中的元素转换成字符串 1234&lt;%--创建列表 --%&gt;&lt;s:set var="list" value="&#123;1,'陈加兵'&#125;"&gt;&lt;/s:set&gt;&lt;%-- 这个&#123;#&#125;首先会取list中的每一个元素然后赋值给tihs，接着调用toString方法转换为字符串 --%&gt;&lt;s:property value="#list.&#123;#this.toString()&#125;"/&gt; 选择 在OGNL中使用表达式从集合中选择某一些元素，并将这些元素保存到新的集合中 12345&lt;%--创建列表 --%&gt;&lt;s:set var="list" value="&#123;1,2,3&#125;"&gt;&lt;/s:set&gt;&lt;%-- 选取大于2的元素组成一个新的集合 --%&gt;&lt;s:property value="#list.&#123;?#this&gt;2&#125;"/&gt; [N]语法 我们知道一次请求值栈中可以存放两个或者多个action(只需要设置result跳转类型为chain即可完成在action之间的跳转)，那么我们一般取值栈中的值默认是获取栈顶的action，但是如果有多个action呢，此时我们需要获取其他action中的数据，这下就要用到[N]语法了 [N].propertyName可以用来指定从值栈中的从上向下数位置N的action的属性值，N从事0开始的。 实现 假设我们有两个Action，一个是SimpleAction，一个是LoginAction(上面的，有一个属性为user)，我们在在配置的时候，发出请求给SimpleAction，之后跳转到LoginAction(result的type类型为chain即可），之后跳转到success.jsp，那么此时的值栈中的action就有两个了，栈顶的是SimpleAction，第二个是LoginAction。 我们想要获取LoginAction属性user的值，在值栈中的位置是第二个，那么此时使用[1].propertName 12User对象中的name:&lt;s:property value="[1].user.name"/&gt;User对象中的age：&lt;s:property value="[1].user.age"/&gt; top 语法 我们知道[N]语法中，如果想要访问栈顶的action属性使用[0].propertyName，我们也可以使用top，直接top.propertyName即可 Struts2的命名对象 这些对象都不是值栈中的数据，因此需要使用#来获取 parameters用来访问请求参数，比如#parameters.name, # parameters [‘name’]相当与request.getParameters(“name”) request用来访问request的属性，比如#request.name或者# request [‘name’] 相当于request,getAttrubute(“name”) session用来访问session属性，例如 #session.name或者#session[‘name’]相当于 session.getAttribute(“name”) application用来访问application属性，比如:#application.name相当于application.getAttribute(“name”) attr用来访问PageContext，如果PageContext不可用，则一次搜索request,session,application对象 123456789101112&lt;% //设置属性 request.setAttribute("login","true"); session.setAttribute("regist", "false"); application.setAttribute("auto", "true");%&gt;获取的请求参数中的name的值:&lt;s:property value="#parameters.name"/&gt;&lt;br&gt;获取request中的login属性:&lt;s:property value="#request.login"/&gt;&lt;br&gt;获取session中的regist属性:&lt;s:property value="#session.regist"/&gt;&lt;br&gt;获取application中的auto属性:&lt;s:property value="#application.auto"/&gt;&lt;s:debug&gt;&lt;/s:debug&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Struts之配置拦截器]]></title>
      <url>%2F2018%2F04%2F02%2FStruts%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
      <content type="text"><![CDATA[struts2之配置拦截器什么是拦截器 java里的拦截器是动态拦截Action调用的对象。它提供了一种机制可以使开发者可以定义在一个action执行的前后执行的代码，也可以在一个action执行前阻止其执行，同时也提供了一种可以提取action中可重用部分的方式。在AOP（Aspect-Oriented Programming）中拦截器用于在某个方法或字段被访问之前，进行拦截然后在之前或之后加入某些操作。 拦截器是可插拔式的，一旦出现了问题，可以不用改变软件的很多代码就可以实现修复，给维护工作带来方便，其实过滤器也是这样的。 Struts2其实就实现了很多的拦截器，可以在struts-default.xml中看到定义很多的拦截器，其中向类型转换，文件上传都是通过拦截器实现的。 Struts2拦截器实现原理与Servlet过滤器实现原理类似，它以链式执行，对真正要执行的方法（execute（））进行拦截。首先执行Action配置的拦截器，在Action和Result执行之后，拦截器会再次执行（与先前调用的顺序相反），在此链式执行的过程中，每一个拦截器都可以直接返回，从而终止余下的拦截器、Action及Result的执行。 拦截器的作用 拦截器适合封一些通用处理，便于重复利用，比如日志的记录，访问权限的检查，事务处理等，拦截器通过配置方式调用，因此使用方法比较灵活，便于维护和扩展 拦截器的配置元素 &lt;interceptors&gt;用来定义拦截器，所有的拦截器和拦截器栈都是在此元素中定义的，可以包含子元素, &lt;Interceptor&gt;用来定义拦截器，需要指定两个属性，name属性指定了拦截器的名字，class指定了拦截器的实现的类。这个是在下定义的 &lt;interceptor-stack&gt;用来定义拦截器栈，其中的name属性指定了拦截器栈的名称。另外在此元素下可以指定引入其他的拦截器或者拦截器栈 &lt;interceptor-ref&gt;用来引用其他的拦截器或者拦截器栈，name属性指定了拦截器或者拦截栈的名称 &lt;param&gt;用来为拦截器指定参数，可以作为或者的子元素。并且可以定义多个。其中的name属性指定了参数的名称 &lt;default-interceptor-ref&gt;将某一个拦截器定义为默认拦截器 内建的拦截器 struts2中提供了许多内建的拦截器，在struts-core.jar中，我们只需要在struts.xml中引用这个内建的拦截器即可 比如我们在实现文件上传的时候，使用的就是内建的拦截器 内建的拦截器使用的很少，通常我们都是使用自定义的拦截器，比如验证访问权限的拦截器 自定义拦截器 实现自定义的拦截器有两种方法，一种是实现接口，一种是继承 需求 我们需要将表单传递过来的数据转换成大写的，再传递给action 实现接口(com.opensymphony.xwork2.interceptor.Interceptor)接口中的方法 void init()初始化拦截器执行的方法 String intercept(ActionInvocation invocation) throws Exception实现拦截器逻辑的主要方法。 ActionInvocation包含了Action的引用，因此使用这个对象可以对Action进行相应的操作，比如可以获取和设置Action类的成员变量 ActionInvocation包含了Action的引用，可以调用其中的invoke()方法继续调用下一个拦截器，如果后面没有拦截器了，那么就会执行Action中对应的映射方法，如果有，那么就会继续执行下一个拦截器，直到执行完全部的拦截器才会执行对应的映射方法 invoke()方法将拦截器的作用分成了两个部分，在调用invoke()之前的实在Action方法执行之前的逻辑，在之后的代码是在Action执行result，跳转到指定视图之后执行的逻辑 这个方法返回的是一个字符串，对应的也是结果视图，如果在其中没有调用invoke()方法，那么返回的字符串就作为Action跳转的视图，因此在一定要定义这个对应的视图。如果调用了invoke()方法，那么返回的字符串就会失效，就会以Action中方法返回的字符串为主 void destroy() 销毁拦截器开启的资源 实现 拦截器类 这里并没有在init和destroy方法中写什么逻辑，可以根据实际情况来定义其中的逻辑 12345678910111213141516171819202122232425262728293031323334import com.jsnu.struts2.controller.SimpleAction;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.Interceptor;public class TestInterceptor implements Interceptor&#123; @Override public void destroy() &#123; // TODO Auto-generated method stub &#125; @Override public void init() &#123; // TODO Auto-generated method stub &#125; @Override public String intercept(ActionInvocation invocation) throws Exception &#123; Object object=invocation.getAction(); //获取当前调用拦截器的Action类的对象 //如果不为null，就可以获取其中的属性，否则空指针 if (object!=null) &#123; SimpleAction simpleAction=(SimpleAction)object; //将User属性全部转换成大写字母 simpleAction.getUser().setName(simpleAction.getUser().getName().toUpperCase()); simpleAction.getUser().setPassword(simpleAction.getUser().getPassword().toUpperCase()); String result=invocation.invoke(); //调用下一个拦截器 System.out.println("成功跳转视图后执行的逻辑"); return result; &#125; return null; &#125;&#125; 继承AbstractInterceptor（推荐） 继承AbstractInterceptor抽象类，里面只有一个抽象方法String intercept(ActionInvocation invocation)，只需要实现这个方法即可，如果你需要初始化和销毁，那么也可以覆盖其中的init()和destroy()方法 继承抽象类的方式比实现接口对一个类的更加简洁，对这个类的污染更加小 其中的方法逻辑还是和上面的一样 还是完成上面的需求，把传递的请求参数转换成大写字母 1234567891011121314151617181920212223import com.jsnu.struts2.controller.SimpleAction;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.AbstractInterceptor;//继承类AbstractInterceptorpublic class AbstractInterceptorTest extends AbstractInterceptor &#123; @Override public String intercept(ActionInvocation invocation) throws Exception &#123; Object object = invocation.getAction(); // 获取当前调用拦截器的Action类的对象 // 如果不为null，就可以获取其中的属性，否则空指针 if (object != null) &#123; SimpleAction simpleAction = (SimpleAction) object; // 将User属性全部转换成大写字母 simpleAction.getUser().setName( simpleAction.getUser().getName().toUpperCase()); simpleAction.getUser().setPassword( simpleAction.getUser().getPassword().toUpperCase()); String result = invocation.invoke(); // 调用下一个拦截器 System.out.println("成功跳转视图后执行的逻辑"); return result; &#125; return null; &#125;&#125; 配置拦截器 因为struts2的很多功能都要依赖内建的拦截器，比如表单传值。这一系列的拦截器都定义在一个拦截器栈中，如果在一个中引用了拦截器，那么这拦截器就会被覆盖，因此一定要在自定义的拦截器之前定义默认的拦截器栈&lt;interceptor-ref name=&quot;defaultStack&quot;&gt;&lt;/interceptor-ref&gt; 配置拦截器只需要在下定义拦截器即可，如果哪个action想要引用拦截器，使用&lt;interceptor-ref &gt;引用已经定义好的拦截器即可 一个action中可以引用多个拦截器，在上面配置的拦截器先执行，因此默认的拦截器栈一定要在最上面 在struts.xml中配置上面我们自定义的拦截器 1234567891011121314151617181920212223&lt;package name="test" extends="struts-default" namespace="/"&gt; &lt;!-- 定义拦截器 --&gt; &lt;interceptors&gt; &lt;!-- 实现接口的拦截器 --&gt; &lt;interceptor name="testInterceptor" class="com.jsnu.struts2.Interceptor.TestInterceptor"&gt;&lt;/interceptor&gt; &lt;!-- 继承类的 --&gt; &lt;interceptor name="abstractInterceptorTest" class="com.jsnu.struts2.Interceptor.AbstractInterceptorTest"&gt;&lt;/interceptor&gt; &lt;/interceptors&gt; &lt;action name="simple" class="com.jsnu.struts2.controller.SimpleAction"&gt; &lt;result name="success"&gt;/jsp/success.jsp&lt;/result&gt; &lt;result name="input"&gt;/jsp/input.jsp&lt;/result&gt; &lt;!-- 在使用了自定的拦截器之后，那么系统默认的拦截器栈将会失去作用，因此这里需要重新指定拦截器栈--&gt; &lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt; &lt;!-- 引用自定义的拦截器，在上面要定义 --&gt; &lt;interceptor-ref name="abstractInterceptorTest"&gt;&lt;/interceptor-ref&gt; &lt;interceptor-ref name="testInterceptor"&gt;&lt;/interceptor-ref&gt; &lt;/action&gt; &lt;/package&gt; 配置拦截器栈 如果一个action中的需要用到的拦截器很多，或者同时引用几个相同的拦截器的action很多，那么我们此时在action一个一个的引用拦截器效率太低，此时我们就需要将这些拦截器定义在一个拦截器栈中，直接在action中引用了拦截器栈即可。 直接使用标签中使用定义即可 拦截器栈中的拦截器一定要在上面定义过的，否则将会引用出错 拦截器栈中的拦截器引用是有顺序的，在上面的拦截器最先执行 我们把上面自定义的两个拦截器放在拦截器栈中,并在action中引用拦截器栈，注意此时的默认的default-stack还是要放在最上面 123456789101112131415161718192021222324252627&lt;package name="test" extends="struts-default" namespace="/"&gt; &lt;!-- 定义拦截器 --&gt; &lt;interceptors&gt; &lt;!-- 实现接口的拦截器 --&gt; &lt;interceptor name="testInterceptor" class="com.jsnu.struts2.Interceptor.TestInterceptor"&gt;&lt;/interceptor&gt; &lt;!-- 继承类的 --&gt; &lt;interceptor name="abstractInterceptorTest" class="com.jsnu.struts2.Interceptor.AbstractInterceptorTest"&gt;&lt;/interceptor&gt; &lt;!-- 自定拦截器栈，其中引用了上面的两个拦截器 --&gt; &lt;interceptor-stack name="myStack"&gt; &lt;!-- 引用自定义的拦截器，在上面要定义 --&gt; &lt;interceptor-ref name="abstractInterceptorTest"&gt;&lt;/interceptor-ref&gt; &lt;interceptor-ref name="testInterceptor"&gt;&lt;/interceptor-ref&gt; &lt;/interceptor-stack&gt; &lt;/interceptors&gt; &lt;action name="simple" class="com.jsnu.struts2.controller.SimpleAction"&gt; &lt;result name="success"&gt;/jsp/success.jsp&lt;/result&gt; &lt;result name="input"&gt;/jsp/input.jsp&lt;/result&gt; &lt;!-- 在使用了自定的拦截器之后，那么系统默认的拦截器栈将会失去作用，因此这里需要重新指定拦截器栈--&gt; &lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt; &lt;interceptor-ref name="myStack"&gt;&lt;/interceptor-ref&gt; &lt;/action&gt;&lt;/package&gt; 拓展 拦截器中还可以包含其他的拦截器栈，那么此时我们就可以将struts2中内建的拦截器放在自己的拦截器栈顶，那么就不用在每个action中引用了，直接引用这个拦截器栈即可 123456789101112131415161718192021222324252627&lt;package name="test" extends="struts-default" namespace="/"&gt; &lt;!-- 定义拦截器 --&gt; &lt;interceptors&gt; &lt;!-- 实现接口的拦截器 --&gt; &lt;interceptor name="testInterceptor" class="com.jsnu.struts2.Interceptor.TestInterceptor"&gt;&lt;/interceptor&gt; &lt;!-- 继承类的 --&gt; &lt;interceptor name="abstractInterceptorTest" class="com.jsnu.struts2.Interceptor.AbstractInterceptorTest"&gt;&lt;/interceptor&gt; &lt;!-- 自定拦截器栈，其中引用了上面的两个拦截器 --&gt; &lt;interceptor-stack name="myStack"&gt; &lt;!-- 在使用了自定的拦截器之后，那么系统默认的拦截器栈将会失去作用，因此这里需要重新指定拦截器栈--&gt; &lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt; &lt;!-- 引用自定义的拦截器，在上面要定义 --&gt; &lt;interceptor-ref name="abstractInterceptorTest"&gt;&lt;/interceptor-ref&gt; &lt;interceptor-ref name="testInterceptor"&gt;&lt;/interceptor-ref&gt; &lt;/interceptor-stack&gt; &lt;/interceptors&gt; &lt;action name="simple" class="com.jsnu.struts2.controller.SimpleAction"&gt; &lt;result name="success"&gt;/jsp/success.jsp&lt;/result&gt; &lt;result name="input"&gt;/jsp/input.jsp&lt;/result&gt; &lt;interceptor-ref name="myStack"&gt;&lt;/interceptor-ref&gt; &lt;/action&gt;&lt;/package&gt; 自定义默认的拦截器栈 在一个包中定义一个默认的拦截器栈后(使用定义)，那么当下没有显式的配置拦截器的时候，那么此时就会默认使用自定义的默认的拦截器或者默认的拦截器栈。 一个包中只能定义一个默认的拦截器，如果想要定义多个拦截器可以使用拦截器栈，定义一个默认的拦截器栈即可解决。 在定义了默认的拦截器之后一定要在每一个action都定义系统默认的拦截器栈defaultStack,前面已经说过如果action定义了拦截器(这里虽然不是显式的定义，但是实际上是定义了),那么就会失去defaultStack的作用，其实我们需要很多defaultStack的功能，因此还是要定义的。 比如登录检查的拦截器，这个是每一个action都需要用到的，那么我们可以设置一个默认的拦截器栈，栈顶引用的是struts2内建的默认的拦截器栈 使用 即可定义 1234567891011121314151617181920212223242526272829&lt;struts&gt; &lt;package name="test" extends="struts-default" namespace="/"&gt; &lt;!-- 定义拦截器 --&gt; &lt;interceptors&gt; &lt;!-- 实现接口的拦截器 --&gt; &lt;interceptor name="testInterceptor" class="com.jsnu.struts2.Interceptor.TestInterceptor"&gt;&lt;/interceptor&gt; &lt;!-- 继承类的 --&gt; &lt;interceptor name="abstractInterceptorTest" class="com.jsnu.struts2.Interceptor.AbstractInterceptorTest"&gt;&lt;/interceptor&gt; &lt;!-- 自定拦截器栈，其中引用了上面的两个拦截器 --&gt; &lt;interceptor-stack name="myStack"&gt; &lt;!-- 在使用了自定的拦截器之后，那么系统默认的拦截器栈将会失去作用，因此这里需要重新指定拦截器栈--&gt; &lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt; &lt;!-- 引用自定义的拦截器，在上面要定义 --&gt; &lt;interceptor-ref name="abstractInterceptorTest"&gt;&lt;/interceptor-ref&gt; &lt;interceptor-ref name="testInterceptor"&gt;&lt;/interceptor-ref&gt; &lt;/interceptor-stack&gt; &lt;/interceptors&gt; &lt;!-- 定义默认的拦截器栈，其中引用了上面定义的拦截器栈 --&gt; &lt;default-interceptor-ref name="myStack"&gt;&lt;/default-interceptor-ref&gt; &lt;action name="simple" class="com.jsnu.struts2.controller.SimpleAction"&gt; &lt;result name="success"&gt;/jsp/success.jsp&lt;/result&gt; &lt;result name="input"&gt;/jsp/input.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 配置拦截方法的拦截器 一般我们的Action类中有很多的方法，但是我们在使用动态调用的时候会调用其中不同的方法，如果不想Action类中的某个方法不被拦截，此时就需要使用拦截方法的拦截器 其中可以设置拦截的方法，也可以设置不拦截的方法 自定义拦截器类 继承MethodFilterInterceptor 其中的方法doIntercept是在执行其中指定方法之前执行，和前面的逻辑一样，也有invoke方法 123456789101112import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.MethodFilterInterceptor;public class SimpleActionInteceptor extends MethodFilterInterceptor&#123; @Override protected String doIntercept(ActionInvocation invocation) throws Exception &#123; System.out.println("拦截方法的拦截器起了作用"); String result=invocation.invoke(); System.out.println("执行之后"); return result; &#125;&#125; struts中配置 &lt;param name=&quot;excludeMethods&quot;&gt;login&lt;/param&gt; 用来定义不拦截的方法 &lt;param name=&quot;includeMethods&quot;&gt;regist&lt;/param&gt; 用来定义拦截的方法，如果有多个使用逗号隔开 这里使用的是动态调用的method的，但是我们也可以使用 action!方法名 假设我们的项目名称为web1，并且把method=“”去掉，那么我们开启action!方法名进行调用，具体方法前面有介绍，开启之后，我们在地址栏输入 http://localhost:8080/web1/simple.regist,将会成功被拦截器拦截器，但是我们输入http://localhost:8080/web1/simple.login，拦截器不起作用 1234567891011121314151617181920&lt;package name="test" extends="struts-default" namespace="/"&gt; &lt;!-- 定义拦截器 --&gt; &lt;interceptors&gt; &lt;!-- 配置拦截方法的拦截器 --&gt; &lt;interceptor name="simpleMethod" class="com.jsnu.struts2.Interceptor.SimpleActionInteceptor"&gt;&lt;/interceptor&gt; &lt;/interceptors&gt; &lt;action name="simple" class="com.jsnu.struts2.controller.SimpleAction" method="regist"&gt; &lt;result name="success"&gt;/jsp/success.jsp&lt;/result&gt; &lt;result name="input"&gt;/jsp/input.jsp&lt;/result&gt; &lt;!-- 在使用了自定的拦截器之后，那么系统默认的拦截器栈将会失去作用，因此这里需要重新指定拦截器栈--&gt; &lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt; &lt;interceptor-ref name="simpleMethod"&gt; &lt;!-- 定义不拦截login方法 --&gt; &lt;param name="excludeMethods"&gt;login&lt;/param&gt; &lt;!-- 定义需要拦截器的方法 --&gt; &lt;param name="includeMethods"&gt;regist&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;/action&gt; &lt;/package&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JDBC干货三]]></title>
      <url>%2F2018%2F04%2F02%2FJDBC%E5%B9%B2%E8%B4%A7%E4%B8%89%2F</url>
      <content type="text"><![CDATA[JDBC干货三生成get,set方法的快捷键 alt+shift+s r alt+a a松手 alt不松手 按o 最后回车 eclipse中生成toString方法的快捷键 alt+shift+o 回车 数据库操作和对象的关系 因为数据库中查询的数据比较零散，需要通过对象的形式把数据封装起来 这种封装数据的对象通常称为javaBean 以后项目开发，基本上有什么表在代码中就会创建相应的对象，表中有什么字段，对象中就有什么属性 JavaBean 俗称简单的java对象 -具备如下的三个特点 - 私有属性 - 无参构造 - 为属性提供get，set方法 Statement和PreparedStatement应用场景 通常DDL使用Statement 通常DML 和DQL使用PreparedStatement 只有需要传入参数的就要使用PreparedStatent 实例 我们将数据库中的表和JavaBean相对应实现了crud操作 使用了PreparedStatement对象操作数据库 JavaBean对象12345678910111213141516171819202122232425262728293031323334353637public class Item &#123; private int id; private String title; private int price; private int num; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public int getPrice() &#123; return price; &#125; public void setPrice(int price) &#123; this.price = price; &#125; public int getNum() &#123; return num; &#125; public void setNum(int num) &#123; this.num = num; &#125; @Override public String toString() &#123; return "Item [id=" + id + ", title=" + title + ", price=" + price + ", num=" + num + "]"; &#125;&#125; crud操作 传入的参数全部都是JavaBean对象 其中的sql语句不能有中的占位符部分不能有空格，否则可能会出现错误 这里使用的是前一篇讲的数据库工具类终结版（使用了DBCP连接池),详情请看前一篇的文章 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// 插入数据，传入JavaBean对象作为参数 public void insert(Item item) &#123; Connection connection = null; PreparedStatement statement = null; // 创建预处理对象 ResultSet resultSet = null; try &#123; connection = DBUtils.getConnection(); // 获取连接 String sql = "insert into t_item(id,title,price,num) values(?,?,?,?)"; statement = connection.prepareStatement(sql); statement.setInt(1, item.getId()); statement.setString(2, item.getTitle()); // 为预处理对象中的占位符赋值 statement.setInt(3, item.getPrice()); statement.setInt(4, item.getNum()); int row = statement.executeUpdate(); System.out.println(row); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; DBUtils.close(connection, statement, resultSet); // 关闭资源 &#125; &#125; // 查询数据，封装在JavaBean中 public List&lt;Item&gt; findAll() &#123; ArrayList&lt;Item&gt; items = new ArrayList&lt;Item&gt;(); Connection connection = null; PreparedStatement statement = null; // 创建预处理对象 ResultSet resultSet = null; try &#123; connection = DBUtils.getConnection(); // 获取连接 String sql = "select * from t_item where price&gt;100"; statement = connection.prepareStatement(sql); resultSet = statement.executeQuery(); while (resultSet.next()) &#123; String title = resultSet.getString("title"); int price = resultSet.getInt("price"); int num = resultSet.getInt("num"); Item item = new Item(); item.setNum(num); item.setPrice(price); item.setTitle(title); items.add(item); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; DBUtils.close(connection, statement, resultSet); // 关闭资源 &#125; return items; &#125; //更新操作，传入JavaBean对象，只需要将要更新的条件封装进去即可 public void update(Item item) &#123; Connection connection = null; PreparedStatement statement = null; // 创建预处理对象 ResultSet resultSet = null; try &#123; connection = DBUtils.getConnection(); // 获取连接 String sql = "update t_item set title=?,num=?,price=? where id=?"; statement = connection.prepareStatement(sql); //设置其中的占位符的值 statement.setString(1, item.getTitle()); statement.setInt(2, item.getNum()); statement.setInt(3, item.getPrice()); statement.setInt(4, item.getId()); int row = statement.executeUpdate(); System.out.println(row); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; DBUtils.close(connection, statement, resultSet); // 关闭资源 &#125; &#125; // 删除的数据，其中参数传入的还是JavaBean对象 public void delete(Item item) &#123; Connection connection = null; PreparedStatement statement = null; // 创建预处理对象 ResultSet resultSet = null; try &#123; connection = DBUtils.getConnection(); // 获取连接 String sql = "delete from t_item where id=?"; statement = connection.prepareStatement(sql); statement.setInt(1, item.getId()); int row = statement.executeUpdate(); System.out.println(row); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; DBUtils.close(connection, statement, resultSet); // 关闭资源 &#125; &#125; 批量操作 因为类似的sql语句执行，每一个次都需要和数据库服务器进行数据交互，多次交互会浪费资源，并且耗时，可以使用批量 Statement执行批量操作 需要写多个重复的sql语句，只是其中的想用批量的内容不同，比较繁琐-最后将这些sql语句中添加到批量操作中 statement.addBatch(sql); 添加到批量操作之后，就开始执行批量方法了 statement.executeBatch(); 123456789101112131415161718192021222324@Testpublic void testStatement() &#123; Connection connection = null; Statement statement = null; ResultSet resultSet = null; try &#123; connection = DBUtils.getConnection(); // 获取连接 statement = connection.createStatement(); // 创建Statement语句对象 String sql1 = "insert into t_item(id,title) values(100,'asaa')"; String sql2 = "insert into t_item(id,title) values(101,'asaa')"; String sql3 = "insert into t_item(id,title) values(102,'asaa')"; // 添加批量操作 statement.addBatch(sql1); statement.addBatch(sql2); statement.addBatch(sql3); // 执行批量操作 statement.executeBatch(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; DBUtils.close(connection, statement, resultSet); // 关闭资源 &#125;&#125; PreparedStatement 只需要写一个条sql语句，其中要批量的内容使用占位符即可 设置占位符的内容，将其添加到批量中，再重新设置，这样的好处就是减少了重复的sql语句了 statement.addBatch() 最后直接执行批量操作即可 statement.executeBatch(); 12345678910111213141516171819202122232425262728293031@Testpublic void testPreparedStatement() &#123; Connection connection = null; PreparedStatement statement = null; ResultSet resultSet = null; try &#123; connection = DBUtils.getConnection(); // 获取连接 String sql = "insert into t_item(id,title) values(?,?)"; statement = connection.prepareStatement(sql); statement.setInt(1, 200); statement.setString(2, "联想电脑"); statement.addBatch(); // 添加上面的数据到Batch中 statement.setInt(1, 201); statement.setString(2, "华硕笔记本"); statement.addBatch(); // 添加上面的数据到Batch中 statement.setInt(1, 202); statement.setString(2, "海尔洗衣机"); statement.addBatch(); // 添加上面的数据到Batch中 statement.executeBatch(); // 执行批量操作 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; DBUtils.close(connection, statement, resultSet); // 关闭资源 &#125;&#125; 批量插入数据 注意：addBatch()其中的数量是有限的，如果存放的批量操作太多，那么会造成内存溢出，因此我们应该当其中批量操作的数量达到一定值的时候先执行一次，然后清除执行完的操作即可(clearBatch()) 批量操作的时候如果批量操作的数量太多的话，肯定会造成内存溢出，这个时候最好的办法就是当数量达到一定数量时候就执行，然后将其中的已经执行完成的清除即可 下面是向表中插入有100条数据，我们每20条插入一次，这样就可以避免内存的溢出 1234567891011121314151617181920212223242526@Testpublic void test1()&#123; Connection connection = null; PreparedStatement statement = null; ResultSet resultSet = null; try &#123; connection = DBUtils.getConnection(); // 获取连接 String sql = "insert into t_v(name) values(?)"; statement=connection.prepareStatement(sql); for(int i=0;i&lt;100;i++)&#123; statement.setString(1, "name"+(i+1)); statement.addBatch(); //为了避免内存溢出，当批量操作数量达到一定值时先执行一次，在向其中添加 //每二十次添加一次 if (i%20==0) &#123; statement.executeBatch(); //执行批量操作 statement.clearBatch(); //清除已经执行过的 &#125; statement.executeBatch(); //为了避免有剩余的，把剩下的执行掉 &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; DBUtils.close(connection, statement, resultSet); // 关闭资源 &#125;&#125; 分页查询 要求： 在控制台输入页数(n)，和每页显示的数量(m) 分析： 我们知道sql语句中的limit ?,?，第一个参数表示的是跳过的条数，第二个参数是每页显示的条数，那么此时我们限定显示第n页，每页显示m条，那么此时的跳过的条数就是(n-1)*m,因此此时的查询语句就是: select * from table_name limit (n-1)*m,m; 代码如下： 12345678910111213141516171819202122232425262728293031323334@Testpublic void testLimit()&#123; Connection connection = null; PreparedStatement statement = null; ResultSet resultSet = null; Scanner scanner=new Scanner(System.in); //控制台输入 try &#123; connection = DBUtils.getConnection(); // 获取连接 String sql = "select * from t_v limit ?,?"; statement=connection.prepareStatement(sql); // n页，每页m条 limit (n-1)*m m System.out.println("第几页："); int n=Integer.parseInt(scanner.nextLine()); //页数,控制台读取的是字符串，因此这里需要转换 System.out.println("每页的条数"); int m=Integer.parseInt(scanner.nextLine()); //每页显示的条数 //设置占位符 statement.setInt(1, (n-1)*m); statement.setInt(2, m); //查询，获取结构集 resultSet=statement.executeQuery(); //遍历结果集 while(resultSet.next())&#123; int id=resultSet.getInt("id"); //获取id String name=resultSet.getString("name"); //获取name System.out.println(id+"-----"+name+"\t"); //制表符输出值 &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; DBUtils.close(connection, statement, resultSet); // 关闭资源 &#125;&#125; 事务ACID 原子性 一致性 隔离性 持久性 jdbc操作事务 connection.setAutoCommit(false) 关闭自动提交 如果不关闭自动提交，那么会每执行一行都会提交一次 connection.commit() 提交 connection.rollback() 回滚 转账的实现过程 创建表：create table user(id int,name,varchar(10),money int); 插入数据：insert into user values(1,&#39;超人&#39;,200),(2,&#39;蝙蝠侠&#39;,10000); 关闭自动提交 connection.setAutoCommit(false) 修改超人的钱(money+3000) 修改蝙蝠侠的钱(money-3000) 查询蝙蝠侠的钱是否大于0，如果小于0，则抛出运行时异常，大于0 提交(commit) 在catch异常的地方把SQLException改成Exception，并且在catch里面回滚 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Testpublic void testTransaction() &#123; Connection connection = null; PreparedStatement statement = null; ResultSet resultSet = null; try &#123; connection = DBUtils.getConnection(); // 获取连接 connection.setAutoCommit(false); // 关闭自动提交 String sql = "update user set money=money+? where id=?"; // 修改蝙蝠侠和超人钱的sql语句 String sql_select = "select money from user where id=?"; // 查询钱 // 创建更新的预编译对象 statement = connection.prepareStatement(sql); // 超人+3000 statement.setInt(1, 3000); statement.setInt(2, 1); int row1 = statement.executeUpdate(); // 执行更新语句 // 蝙蝠侠-3000 statement.setInt(1, -3000); statement.setInt(2, 2); int row2 = statement.executeUpdate(); // 执行更新语句 // 预编译查询sql语句 statement = connection.prepareStatement(sql_select); statement.setInt(1, 2); resultSet = statement.executeQuery(); // 执行查询语句 while (resultSet.next()) &#123; int money = resultSet.getInt("money"); // 获取蝙蝠侠的此时的钱 // 如果&lt;0 抛出运行异常 if (money &lt; 0) &#123; throw new RuntimeException(); // 手动抛出异常 &#125; else &#123; // 如果 &gt;0 可以成功提交 connection.commit(); // 提交 &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; connection.rollback(); // 回滚，如果运行出错，那么就回滚到起始点，数据库中就不会生效 &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125; finally &#123; DBUtils.close(connection, statement, resultSet); // 关闭资源 &#125;&#125; 获取自增主键的值 为什么获取： 因为某些插入的数据，插入完之后，需要用到数据的主键作为下一条数据外键 准备sql create table t_d(id int primary key auto_increment,name varchar(10)); 1234567891011121314151617181920212223@Testpublic void testAuto() &#123; Connection connection = null; Statement statement = null; ResultSet resultSet = null; try &#123; connection = DBUtils.getConnection(); // 获取连接 String sql="insert into t_d values(null,'神仙')"; statement=connection.createStatement(); //执行sql，并且标记此时执行需要获取生成的key值 statement.executeUpdate(sql,Statement.RETURN_GENERATED_KEYS); //得到生成的key值 resultSet=statement.getGeneratedKeys(); while(resultSet.next())&#123; int id=resultSet.getInt(1); //获取第一个值，不能写getInt("id") 因为这里不是查询得到的数据，字段名并不是id System.out.println("自增主键的值为:"+id); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; DBUtils.close(connection, statement, resultSet); // 关闭资源 &#125;&#125; 获取元数据 数据库元数据： 数据库厂商信息（mysql,oracle) 数据库连接信息，都称为数据库的元数据 表元数据 12345678910111213141516171819202122232425262728293031323334@Testpublic void testMetaData() &#123; Connection connection = null; Statement statement = null; ResultSet resultSet = null; try &#123; connection = DBUtils.getConnection(); // 获取连接 statement=connection.createStatement(); //得到数据库元数据 DatabaseMetaData data=connection.getMetaData(); System.out.println(data.getDriverName()); //数据库驱动名字 System.out.println(data.getDriverVersion()); //驱动版本 System.out.println(data.getUserName()); //用户名 System.out.println(data.getURL()); //连接地址 System.out.println(data.getDatabaseProductName()); //数据库厂商的名称 String sql="select * from t_d"; resultSet=statement.executeQuery(sql); //从结果集中获取表的元数据 ResultSetMetaData sqldata=resultSet.getMetaData(); int columcount=sqldata.getColumnCount(); //获取表字段的数量 //获取表中每个字段的名称 for(int i=0;i&lt;columcount;i++)&#123; String name=sqldata.getColumnName(i+1); System.out.println("字段名："+name+"\t"); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; DBUtils.close(connection, statement, resultSet); // 关闭资源 &#125;&#125; 乱码问题 在JDBC连接数据的url后面添加如下参数： jdbc:mysql://localhost:3306/test?UseUnicode=true&amp;characterEncoding=UTF-8]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Struts之获取请求参数]]></title>
      <url>%2F2018%2F03%2F31%2FStruts%E4%B9%8B%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%2F</url>
      <content type="text"><![CDATA[获取请求参数 在Servlet中可以调用HttpServletRequest的getParameter()的方法接收传递过来的请求参数，但是在struts2中对这种方式进行了三种封装 我们一般发出请求都是通过表单传递的，但是在服务端如果获取表单传递过来的值，其中有三种不同的方式 属性驱动 属性驱动就是将一个Action类作为一个POJO类，在类中定义表单的请求参数的name属性，但是还要为这些成员变量设置get，set方法。因为在获取请求参数的时候自动调用的是set方法，获取参数的时候调用的是get方法。 当表单提交的时候，实际上是提交了表单元素的值，之后会给ACtion类中的属性设置值(set)，因此这里的属性需要添加set方法 当表单请求成功的时候，实际上是先经过Action类，然后跳转到指定的视图，这个过程都是转发(ddispatcher)，因此会保留request域中的键值对，此时在success.jsp页面中使用EL表达式取值即可(get方法),取值使用的是属性的get方法，因此需要添加get方法 实现 SimpleAction类，其中定义了属性 为每一个属性都需要添加get，set方法 表单提交之后会自动调用属性的set方法为其赋值 跳转到指定视图之后，使用EL表达式取值时会调用属性的get方法 1234567891011121314151617181920212223242526public class SimpleAction implements Action &#123; private String name; //姓名 private String password; //密码 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String execute() &#123; System.out.println(name+"----"+password); return SUCCESS; &#125;&#125; struts.xml 配置Action 1234&lt;action name="simple" class="com.jsnu.struts2.controller.SimpleAction"&gt; &lt;result name="success"&gt;/jsp/success.jsp&lt;/result&gt; &lt;result name="input"&gt;/jsp/input.jsp&lt;/result&gt;&lt;/action&gt; index.jsp 提价表单 input中的属性name对应的是SimpleAction的属性名 123456789101112&lt;body&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";%&gt;&lt;form action="&lt;%=basePath %&gt;simple" method="post"&gt; name:&lt;input type="text" name="name"&gt; password:&lt;input type="text" name="password"&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt;&lt;/body&gt; success.jsp 表单提交成功之后跳转的视图 12345&lt;body&gt; &lt;h1&gt;success&lt;/h1&gt; &lt;h1&gt;$&#123;name &#125;&lt;/h1&gt; &lt;h1&gt;$&#123;password &#125;&lt;/h1&gt;&lt;/body&gt; 域驱动 域驱动是将表单中name属性抽象出一个JavaBean类成为一个modle，并不是Action类成为modle了，只需要在Action类引用JavaBean的对象即可(作为成员变量，get，set，方法都有) 既然Action类中的成员变量已经是JavaBean的对象了，那么表单的中name属性的设置就要使用OGNL形式的取该对象中的属性了，而不是像属性驱动一样直接设置的属性 实现 JavaBean实体类 必须为每一个属性设置get，set方法 必须有无参构造 12345678910111213141516171819202122232425/** * POJO类，model 其中必须为每一个属性设置get，set方法 */public class User &#123; private String name; // 姓名 private String password; // 密码 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; Action类 JavaBean对象作为其成员变量，必须为这个成员变量设置get,set方法 必须有一个无参构造 1234567891011121314151617public class SimpleAction implements Action &#123; private User user; // POJO类对象，必须有set，get方法，和无参构造方法 public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; @Override public String execute() &#123; System.out.println(user.getName() + "---&gt;" + user.getPassword()); return SUCCESS; &#125;&#125; struts.xml配置同上 index.jsp 表单提交 input中的name属性使用OGNL表达式来设置其值 123456789&lt;%String path = request.getContextPath();String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";%&gt;&lt;form action="&lt;%=basePath %&gt;simple" method="post"&gt; name:&lt;input type="text" name="user.name"&gt; password:&lt;input type="text" name="user.password"&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; success.jsp页面 此时使用EL表达式取值，也是使用OGNL形式的取值方式 12345&lt;body&gt; &lt;h1&gt;success&lt;/h1&gt; &lt;h1&gt;$&#123;requestScope.user.name &#125;&lt;/h1&gt; &lt;h1&gt;$&#123;requestScope.user.password &#125;&lt;/h1&gt;&lt;/body&gt; 模型驱动 模型驱动和域驱动比较相似，都是用一个JavaBean类作为model，但是模型驱动必须实现ModelDriven&lt;&gt;这个接口,这个可以指定一个泛型，其中泛型类为JavaBean的类，必须实现的方法是getmodel()方法 Type getModel(){} 返回一个Type对象，这个对象是在实现接口的时候定义泛型类(JavaBean类) 使用模型驱动，那么表单中的name属性值就不需要使用OGNL表达式了，而是直接使用属性字段即可，这个和属性驱动一样的 JavaBean类，这个和上面的一样 Action类，实现了ModelDriver 接口 12345678910111213141516171819202122232425262728//实现ModelDriven接口&lt;&gt;指定的泛型为JavaBean类public class SimpleAction implements Action,ModelDriven&lt;User&gt; &#123; private User user; // POJO类对象，必须有set，get方法，和无参构造方法 public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; @Override public String execute() &#123; System.out.println(user.getName() + "---&gt;" + user.getPassword()); return SUCCESS; &#125; @Override public User getModel() &#123; System.out.println("调用了getModel方法"); // 如果对象为空，就创建一个对象，然后返回 if (user == null) &#123; this.user = new User(); &#125; return user; &#125;&#125; struts.xml 同上 index.jsp 表单提交 这里name属性值直接使用JavaBean属性即可，必须字段一样 12345&lt;form action="&lt;%=basePath %&gt;simple" method="post"&gt; name:&lt;input type="text" name="name"&gt; password:&lt;input type="text" name="password"&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; success.jsp 取值仍然使用的是OGNL形式的取值方式 123&lt;h1&gt;success&lt;/h1&gt;&lt;h1&gt;$&#123;requestScope.user.name &#125;&lt;/h1&gt;&lt;h1&gt;$&#123;requestScope.user.password &#125;&lt;/h1&gt; 总结 根据我的经验，在框架整合的基础上，我们必须使得单独的实体类对应一张表，那么此时就需要使得Action类和JavaBean分离，因此我推荐使用第二种方式，第三种方式还需要实现接口，对类的污染比较严重]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Struts之Action类访问Servlet_API]]></title>
      <url>%2F2018%2F03%2F31%2FStruts%E4%B9%8BAction%E7%B1%BB%E8%AE%BF%E9%97%AEServlet-API%2F</url>
      <content type="text"><![CDATA[Action类访问Servlet API Struts2并未直接和Servlet API耦合，这是Struts2的一个改良之处。但是对于web应用控制器而言，不访问Servlet API是不可能，因此下面我们介绍三种方式访问Servlet API ActionContext 使用这个可以获取Servlet中HttpServletRequest,HttpSession,ServletContext 其中的方法 static ActionContext getContext()返回一个实例化ActionContext对象，用于调用下面的方法 Object get(key) 返回ActionContext中存放的键值对的值 其实这里获取的是Servlet中HttpServletRequest对象的属性 Object put(key,value) 向ActionContext中存放键值对,同样该方法用于存放HttpServletRequest的属性 Map getSession()返回一个Map对象，不过这个模拟了HttpSession的用法，只不过现在向其中存放键值对使用put,获取属性用get Map getApplication()返回一个Map对象，不过这个模拟了Servlet中的ServletContext对象的方法。只不过存放和获取属性的方法用的分别是put和get Map getParameters()获取所有的请求参数，类似调用HttpServletRequest对象的getParameterMap()方法 Map setSession(Map session)直接传入一个Map实例，将其中的kay-value转换成session的属性名和属性值 Map setApplication(Map application)直接传入一个Map实例，将Map实例中的key-value转换成属性名，属性值 使用 如果想要使用这个类，当然需要实例化的对象，其中提供了一个获取对象的静态方法，就是上面方法中的第一个 我们在Action方法中使用这个设置request域，session域中的属性 12345678910111213141516171819public class SimpleAction implements Action &#123; @Override public String execute()&#123; ActionContext actionContext=ActionContext.getContext(); //获取实例化对象 //向request域中存放键值对 actionContext.put("name", "jack"); //获取request域中的name值 System.out.println(actionContext.get("name")); //向session中存放键值对 actionContext.getSession().put("password", "123456"); //向application中存放键值对 actionContext.getApplication().put("a", "b"); return SUCCESS; &#125;&#125; success.jsp 使用EL表达式获取 1234&lt;h1&gt;success&lt;/h1&gt;&lt;h1&gt;request域中的name:$&#123;requestScope.name&#125;&lt;/h1&gt;&lt;h1&gt;session域中的password: $&#123;sessionScope.password &#125;&lt;/h1&gt;&lt;h1&gt;application域中的a: $&#123;a &#125;&lt;/h1&gt; 总结 虽说现在可以向各种域中添加属性获取属性，但是我们不可以移除属性，所以说这种方法不如直接使用Servlet API功能更加强大 实现接口访问Servlet API 实现接口访问对一个Action类的污染实在太严重了，这个是不推荐使用的，可以了解一下 可以实现的接口 ServletContextAware实现该接口的Action可以直接访问用户请求的ServletContext实例 ServletRequestAware实现该接口的Action可以直接访问用户请求的HttpServletRequest实例 ServletResponseAware实现该接口的Action可以直接访问请求的HttpServletResponse实例 ServletActionContext（推荐） 使用这个类可以直接获取HttpServletRequest，HttpServletResponse等对象，其功能比第一种更加强大，因此推荐使用这种方式获取Servlet API 方法 PageContext getPageContext()取得web应用的PageContext对象 HttpServletRequest getRequest()获取HttpServletRequest对象 HttpServletResponse getResponse()获取HttpServletResponse对象 ServletContext getServletContext()获取ServletContext对象 使用 我们在Action类中使用 123456789101112131415161718public class SimpleAction implements Action &#123; @Override public String execute()&#123; //获取Request域的对象 HttpServletRequest request=ServletActionContext.getRequest(); request.setAttribute("name", "jack"); //获取Session域的对象 HttpSession session=request.getSession(); session.setAttribute("password", "123456"); //获取Response的对象 HttpServletResponse response=ServletActionContext.getResponse(); return SUCCESS; &#125;&#125; 总结 直接获取Servlet API中的对象，可以使用的功能更加强大，因此推荐使用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Struts2之动态调用]]></title>
      <url>%2F2018%2F03%2F31%2FStruts2%E4%B9%8B%E5%8A%A8%E6%80%81%E8%B0%83%E7%94%A8%2F</url>
      <content type="text"><![CDATA[动态调用什么是动态调用 动态调用就是一个Action类对应着多个请求，比如一个Action类中包含许多的方法，实现动态调用就是让这些方法都配上不同的URL请求映射，这个就是动态调用 好处 我们知道如果一个Action类只是对应着一个URL请求，那么我们要写很多Action类，但是如果我们使用了动态调用，那么就可以减少很多的重复工作 method实现动态调用-在struts核心配置文件详解(action)中已经详细讲解了method的用法，使用这个方式可以指定Action类中的不同的方法映射请求，那么就完成了动态调用 action名!方法名 这种方式不推荐使用，要想使用的话还要开启开关，如下 &lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value=&quot;true&quot; /&gt;将这个常量设置true才能使用 实现 创建SimpleAction的类 这个Action类中有一个login方法，我们的动态调用这个login方法，使用action名!方法名 1234567891011public class SimpleAction implements Action &#123; @Override public String execute()&#123; return SUCCESS; &#125; //实现登录的action public String login()&#123; System.out.println("这个是login方法......"); return INPUT; &#125;&#125; struts.xml中的配置(在src目录下) 开启开关 配置SimpleAction这Action类 123456789101112131415&lt;struts&gt; &lt;!-- 开启开关，否则不能使用!的方式 --&gt; &lt;constant name="struts.enable.DynamicMethodInvocation" value="true"&gt;&lt;/constant&gt; &lt;package name="test" extends="struts-default" namespace="/"&gt; &lt;!-- 定义这个包下的默认处理类 --&gt; &lt;default-class-ref class="com.jsnu.struts2.controller.SimpleAction"&gt;&lt;/default-class-ref&gt; &lt;!-- 这个是SimpleAction的类 --&gt; &lt;action name="simple"&gt; &lt;result name="success"&gt;/jsp/success.jsp&lt;/result&gt; &lt;result name="input"&gt;/jsp/input.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 输入地址 假设项目的名称为web1，那么在地址栏中输入的url为：http://localhost:8080/web1/simple!login,注意这个感叹号一定是英文的 输入成功之后我们看到可以正确跳转，那么就成功了 通配符的方式 使用这种方式首先需要关闭上面开启的开关，当然如果你没有开启，那么就不用配置，因为其中默认就是关闭的 &lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value=&quot;false&quot; /&gt; 这种方式是官网推荐使用 在Servelt设置url的时候也使用过通配符，一般都是使用*来替代的。现在使用通配符也是一样的道理，也是可以使用动态调用的。 这种方式是和method方式配合使用的，在我看来就是method方式，只不过通过通配符传参而已 实现 我们还是使用上面的SimpleAction类，仍然是调用其中的login方法，不过struts.xml此时的配置文件改变了 struts.xml 关闭开关(默认是关闭的) 定义SimpleAction类的action 12345678910111213&lt;struts&gt; &lt;!-- 设置为false，关闭开关，默认是关闭的，因此可以不设置 --&gt; &lt;constant name="struts.enable.DynamicMethodInvocation" value="false" /&gt; &lt;package name="test" extends="struts-default" namespace="/"&gt; &lt;!-- 定义action，其中name属性使用一个*的通配符，method=&#123;1&#125;，这个1就是用来接收第一个通配符*的内容 假设此时输入的Simple_regist ,那么此时&#123;1&#125;=regist --&gt; &lt;action name="simple_*" class="com.jsnu.struts2.controller.SimpleAction" method="&#123;1&#125;"&gt; &lt;result name="success"&gt;/jsp/success.jsp&lt;/result&gt; &lt;result name="input"&gt;/jsp/input.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 此时如果我们的项目名称为让web1，那么输入的url为http://localhost:8080/Struts2/simple_login.action,那么就会调用SimpleAction中的login方法执行 总结 推荐使用method和通配符的方式实现动态调用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[struts核心配置文件详解(result配置)]]></title>
      <url>%2F2018%2F03%2F31%2Fstruts%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3-result%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[struts核心配置文件详解(result配置)配置处理结果(result) 我们在包中定义的&lt;result name=&quot;&quot; type=&quot;&quot;&gt;value&lt;/result&gt;,这个是用来根据action方法返回的字符串，跳转到指定的视图或者其他的action。 name指定的是action方法返回的结果。 type 指定的是跳转的类型，默认的是dispatcher，相当于Servlet中的RequestDispatcher,地址栏中的url不会改变 如果一个action方法中可能返回的值是多个，比如如果测试成功返回success，测试失败返回input，出现异常返回error，那么此时就需要用到多个&lt;result&gt;标签来定义这些返回值跳转的视图 1234&lt;action name="login" class="com.controller.LoginAction"&gt; &lt;result name="success"&gt;/JSP/success.jsp&lt;/result&gt; &lt;result name="login"&gt;/JSP/login.jsp&lt;/result&gt;&lt;/action&gt; 类型 dispatcher 表示采用的跳转方式为转发，这个和Servlet中的RequestDispathcher是一个原理，地址栏的url是不会改变的 dispatcher 结果类型是在Action与JSP页面之中的一种默认的跳转发方式，相当于之间的Servlet中的转发(RequestDispatcher) redirect 用于跳转到其他的页面，但是这个地址栏的url是改变的 这个结果类型主要用于重定向到指定的视图资源，这个和dispatcher比较相似，但是这个地址改变了。相当于Servlet中的sendirect()这个方法。 chain Action链式处理结果类型 很多时候，当一个Action处理完之后并不想转发到视图资源，而是想要跳转到指定的Action继续未完成的处理，这时就需要使用chain，使得两个Action成为链式处理。 范例如下： 其中中的value要写成指定的标签中的name值，如果不是一个包中的，还要引入另外一个包中的action，看上面的内容 1234567891011&lt;package name="Login" extends="struts-default" namespace="/"&gt; &lt;action name="regist" class="com.action.regist"&gt; &lt;result name="success" type="chain"&gt;login&lt;/result&gt; &lt;/action&gt; &lt;action name="login" class="com.action.LoginAction"&gt; &lt;result name="success"&gt;/JSP/success.jsp&lt;/result&gt; &lt;result name="login"&gt;/JSP/login.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; freemaker 用于与FreeMaker整合的结果类型 httpheader 用于控制特殊的HTTP行为的结果类型 redirectAction 用于直接跳转到其他Action的结果类型 上面说个redirect是用于重定向到指定的视图资源的，那么这个是用于重定向到指定的Action类的，这个和chain类型非常相似，不过一个是重定向，一个是转发，当然其中的request中的内容会丢失。 stream 用于浏览器返回一个InputStream的结果类型（一般用于下载） velocity 用于与Velocity整合的结果类型 xslt 用于与XML/XSTL整合的结果类型 plainText 用于显示某个页面的原始代码的结果类型 局部结果 配置局部结果就是在作为的子标签配置，就是上面的配置方式，但是这种局部配置只针对自己的父标签的action起作用。如下： 1234567&lt;!-- name指定了包的名称，extends指定继承的类，namespace指定url路径，这里使用/表示在根路径下就可以直接访问 --&gt;&lt;package name="Login" extends="struts-default" namespace="/"&gt;&lt;action name="login" class="com.controller.LoginAction"&gt; &lt;result name="success"&gt;/JSP/success.jsp&lt;/result&gt; &lt;result name="login"&gt;/JSP/login.jsp&lt;/result&gt;&lt;/action&gt;&lt;/package&gt; 配置全局结果 当我们需要一个视图可能这个package中action都需要，如果一个action中定义一个这样的result难免有些多余，现在我们使用只需要在元素内定义一次即可，一旦有返回值满足即可调用这个视图。比如我们定义一个错误处理的界面，因为这个处理视图是一样的，只需要配置全局result即可。 123456789&lt;package name=”Login” extends=”struts-default” namespace=”/user”&gt;&lt;global-results &gt; &lt;!—只要执行action的类返回error就会跳转到error.jsp--!&gt; &lt;result name=”error”&gt;error.jsp&lt;/result&gt;&lt;/global-results&gt;&lt;action name=”login”class=”com.action.LoginAction”&gt; &lt;result name=”success”&gt;success.jsp&lt;/result&gt;&lt;/action&gt;&lt;/package&gt; 根据上面的配置，如果此时login这个action返回的字符串为error，那么此时的全局配置结果就起作用了，就会跳转到error.jsp页面 但是我们一个action处理错误的页面和特殊，虽然返回的是error，但是我就想跳转到其他的页面，那么可以在这个action的标签下重新定义一个结果，此时的局部结果就会覆盖全局结果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[struts核心配置文件详解(action配置)]]></title>
      <url>%2F2018%2F03%2F31%2Fstruts%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3-action%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[struts核心配置文件详解(action配置)配置action 前面我们已经说过Action类的三个实现方式，现在我们该说说Action类在struts.xml中的配置问题了 指定特定的方法执行(method) 我们知道ActionSupport类实际上相当与一个POJO类，这个和springmvc不同，struts2中的控制层Action类没有和实体类分离，其中可以有很多的方法，我们知道struts2默认调用的execute方法，但是如果我们想要指定其他的方法来处理请求呢，这时我们就需要使用method这个属性了 method: 是&lt;action name=&quot;&quot; class=&quot;&quot; method=&quot;&quot;&gt;标签中的属性,指定的是Action类中的方法名，如果不使用这属性，那么默认的值是execute 12345&lt;!-- 使用method指定 SimpleAction中的login方法执行这个login.action这个URL --&gt;&lt;action name="login" class="com.jsnu.struts2.controller.SimpleAction" method="login"&gt; &lt;result name="success"&gt;/jsp/success.jsp&lt;/result&gt; &lt;result name="input"&gt;/jsp/input.jsp&lt;/result&gt;&lt;/action&gt; 配置默认的处理类 上面我们讲解了method的使用方式，但是现在有一个问题，如果一个Action类中有多个处理方法，那么每次定义action都需要在其中指定相同的class属性，如果我们把这个class抽离出来，不用每一个action都写class属性。 只需要在标签内部加上&lt;default-class-ref class=&quot;&quot;&gt;即可，那么这个包下的所有的action没有设置class的是属性的都是使用的这个默认的处理类。 但是如果&lt;action&gt;标签中指定了class属性，那么会覆盖这个默认的处理类 12345678910111213141516171819202122&lt;package name="test" extends="struts-default" namespace="/"&gt; &lt;!-- 定义这个包下的默认处理类 --&gt; &lt;default-class-ref class="com.jsnu.struts2.controller.SimpleAction"&gt;&lt;/default-class-ref&gt; &lt;!-- 这个action使用的是另外一个处理类，此时的默认处理类对这个action没有作用，被覆盖掉--&gt; &lt;action name="testaction" class="com.jsnu.struts2.controller.TestAction" &gt; &lt;result name="success"&gt;/jsp/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;!-- 这个action没有指定class属性，那么就会使用默认处理类的exit方法 --&gt; &lt;action name="simpleAction" method="exit"&gt; &lt;result name="success"&gt;/jsp/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;!-- 使用method指定 SimpleAction中的login方法执行这个login.action这个URL，同样的没有指定class，使用默认处理类中的login方法 --&gt; &lt;action name="login" method="login"&gt; &lt;result name="success"&gt;/jsp/success.jsp&lt;/result&gt; &lt;result name="input"&gt;/jsp/input.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 配置默认的处理action-如果用户输入的的URL地址在这个&lt;package&gt;下，即是namespace符合，但是在其中没有相应的action的做出响应，可能是地址输错了，此时的我们需要使其跳转到error.jsp页面，给用户一个提示。那么我们这个时候就需要使用默认的action。 默认的action的作用就是在用户输入地址没有响应，但是符合&lt;package&gt;下的一个namespace，那么可能是用户输错了，那么我们为了提高友好性，此时需要跳转到error.jsp页面，此时就需要一个默认的action类映射了 -直接在&lt;package&gt; 定义即可，其中的name属性指定的package下的已经存在的action的名称 1234567891011121314151617&lt;package name="test" extends="struts-default" namespace="/"&gt; &lt;!-- 指定默认的action，如果在namespace路径下的找不到指定的action来映射请求，那么就会使用package下的默认的action来做出响应 name： 指定这个package下的action的名字，相当于已经定义好的action --&gt; &lt;default-action-ref name="login"&gt;&lt;/default-action-ref&gt; &lt;!-- 定义这个包下的默认处理类 --&gt; &lt;default-class-ref class="com.jsnu.struts2.controller.SimpleAction"&gt;&lt;/default-class-ref&gt; &lt;!-- 使用method指定 SimpleAction中的login方法执行这个login.action这个URL，同样的没有指定class，使用默认处理类中的login方法 --&gt; &lt;action name="login" method="login"&gt; &lt;result name="success"&gt;/jsp/success.jsp&lt;/result&gt; &lt;result name="input"&gt;/jsp/input.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Struts2Action类实现]]></title>
      <url>%2F2018%2F03%2F30%2FStruts2Action%E7%B1%BB%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[Action类的实现方式Action类的实现方式 如果想要浏览器可以映射到其中的方法，那么必须返回一个String，使用这个值指示需要跳转的视图或者Action Struts中的Action类实际上可以是一个POJO类，其中也是可以定义许多的方法，但是如果在struts.xml的配置文件中特指调用哪个方法的话，那么就会默认会调用名为execute的方法。后续将会讲如何调用类中其他的方法 普通的pojo类 不需要实现或者继承任何类，只是一个普通的类 这个普通的类中有一个名为execute的方法，返回的一个字符串 123456public class SimpleAction &#123; public String execute()&#123; System.out.println("这是一个普通的pojo类"); return "success"; &#125;&#125; struts.xml 配置跳转的视图 1234&lt;!-- 配置跳转到添加学生页面的action --&gt; &lt;action name="simpleAction" class="com.jsnu.struts2.controller.SimpleAction" &gt; &lt;result name="success"&gt;/jsp/success.jsp&lt;/result&gt; &lt;/action&gt; 继承ActionSupport 在其中封装了execute方法，我们只需要覆盖即可 在这个类中还默认的封装了一些静态变量，比如： public static final String EOORO=”error” public static final String INPUT=”input” public static final String LOGIN=”login” public static final String NONE=’none’ public static final String SUCCESS=”success” 实现 1234567public class ActionSupportAction extends ActionSupport &#123; @Override public String execute() throws Exception &#123; System.out.println("继承了ActionSupport"); return SUCCESS; &#125;&#125; struts中配置 同上 实现Action类 实现这个类，同样是还要实现其中的execute方法 其中也是和ActionSupport一样，封装了许多的字符串静态变量，我们自己调用即可。同上 实现 123456789101112/** * action类： 这里实现的Action接口 * @author chenjiabing */public class TestAction implements Action &#123; @Override public String execute() throws Exception &#123; System.out.println("cchjemko"); return SUCCESS; &#125;&#125; struts.xml配置 同上 只需要改变中的name 和 class即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Struts2核心配置文件(package)]]></title>
      <url>%2F2018%2F03%2F30%2FStruts2%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[struts核心配置文件详解包(package) 在核心配置文件中需要配置&lt;package&gt; 元素可以把逻辑上相关的一组Action、Result、Intercepter等元素封装起来，形成一个独立的模块，package可以继承其他的package，也可以作为父包被其他的package继承 属性 name 这是一个必填的属性，指定包的名字，便于其他的包引用，因为其他的包可以继承这个包 extends ： 该属性是一个选择属性，表示继承其他的包，但是我们一般都会继承struts-default 如果我们学到了处理json数据的时候，我们将会继承处理json的包 namespace ：该属性是一个可选属性，指定该包的命名空间，默认的是“/”,以为一个配置文件中可能有相同名字的action，如果配置不同的namespace，那么就可以配置相同的action的名字 namespace配置的是包的命名空间，同一个命名空间里面不能有同名的Action，当然不同的命名空间里面是可以有同名的Action的。类似于Java的包的功能，namespace可以有效的防止action重名的冲突，因为配置了namespace后，在访问action的时候就需要添加namespace来作为action的前缀。如果不配置namespace，表示是默认的namespace，那么访问的时候不需要添加namespace前缀。 比如有一个项目为Web1，在struts.xml的&lt;package namespace = &quot;/student&quot;&gt;,这个包的下面有一个&lt;action name =&quot;add&quot;&gt;,那么我们要访问这个action使用的url为：http://localhost:8080/Web1/student/add.action abstract：这是一个可选属性，表示这个包是否是抽象的，抽象包不能包含action定义 范例12&lt;!—指定了继承自strtus-default这个类，namespace指定了命名空间，那么当其中的action访问的时候要必须使用如下:http://localhost:8080/web1/user/*--!&gt;&lt;package name="Login" extends="struts-default" namespace="/user"&gt;&lt;/package&gt; 引入另一个包中的action 需求： 前面我们都是跳转到指定的视图，但是我们也是可以跳转到指定的action，但是这个要跳转的action和当前的action不是一个包中的。 此时我们就需要在当前包中引入另外一个包中的action，那么我们可以如下设置 &lt;param name=&quot;namespace&quot;&gt;中的值为另外一个包的namespace &lt;param name=&quot;actionName&quot;&gt;中的值为需要跳转到的action名字 1234567891011121314151617&lt;package name="Login" extends="struts-default" namespace="/"&gt; &lt;action name="login" class="com.action.LoginAction"&gt; &lt;result name="success" type="chain"&gt; &lt;!-- namespace指定另外一个包中的namespace，actionName指定action的名字 --&gt; &lt;param name="namespace"&gt;/user&lt;/param&gt; &lt;param name="actionName"&gt;regist&lt;/param&gt; &lt;/result&gt; &lt;/action&gt;&lt;/package&gt;&lt;package name="Regist" extends="struts-default" namespace="/user"&gt; &lt;action name="regist" class="com.action.RegistAction"&gt; &lt;result name="success"&gt;JSP/success.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 包含另外一个包（include) 一个项目中的配置文件中可能需要定义很多个package和action，那么都写在一个xml文件中，不免有些混乱，因此需要使用include包含其他的配置文件，相当于jsp文件中的&lt;jsp:include&gt;,要注意的是配置文件都要放在项目的src目录下 &lt;include file=”user.xml”&gt;&lt;/include&gt; 配置处理结果(result) 我们在包中定义的&lt;result name=&quot;&quot; type=&quot;&quot;&gt;value&lt;/result&gt;,这个是用来根据action方法返回的字符串，跳转到指定的视图或者其他的action。 name指定的是action方法返回的结果。 type 指定的是跳转的类型，默认的是dispatcher，相当于Servlet中的RequestDispatcher,地址栏中的url不会改变 如果一个action方法中可能返回的值是多个，比如如果测试成功返回success，测试失败返回input，出现异常返回error，那么此时就需要用到多个&lt;result&gt;标签来定义这些返回值跳转的视图 1234&lt;action name="login" class="com.controller.LoginAction"&gt; &lt;result name="success"&gt;/JSP/success.jsp&lt;/result&gt; &lt;result name="login"&gt;/JSP/login.jsp&lt;/result&gt;&lt;/action&gt; 类型 dispatcher 表示采用的跳转方式为转发，这个和Servlet中的RequestDispathcher是一个原理，地址栏的url是不会改变的 dispatcher 结果类型是在Action与JSP页面之中的一种默认的跳转发方式，相当于之间的Servlet中的转发(RequestDispatcher) redirect 用于跳转到其他的页面，但是这个地址栏的url是改变的 这个结果类型主要用于重定向到指定的视图资源，这个和dispatcher比较相似，但是这个地址改变了。相当于Servlet中的sendirect()这个方法。 chain Action链式处理结果类型 很多时候，当一个Action处理完之后并不想转发到视图资源，而是想要跳转到指定的Action继续未完成的处理，这时就需要使用chain，使得两个Action成为链式处理。 范例如下： 其中中的value要写成指定的标签中的name值，如果不是一个包中的，还要引入另外一个包中的action，看上面的内容 1234567891011&lt;package name="Login" extends="struts-default" namespace="/"&gt; &lt;action name="regist" class="com.action.regist"&gt; &lt;result name="success" type="chain"&gt;login&lt;/result&gt; &lt;/action&gt; &lt;action name="login" class="com.action.LoginAction"&gt; &lt;result name="success"&gt;/JSP/success.jsp&lt;/result&gt; &lt;result name="login"&gt;/JSP/login.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; freemaker 用于与FreeMaker整合的结果类型 httpheader 用于控制特殊的HTTP行为的结果类型 redirectAction 用于直接跳转到其他Action的结果类型 上面说个redirect是用于重定向到指定的视图资源的，那么这个是用于重定向到指定的Action类的，这个和chain类型非常相似，不过一个是重定向，一个是转发，当然其中的request中的内容会丢失。 stream 用于浏览器返回一个InputStream的结果类型（一般用于下载） velocity 用于与Velocity整合的结果类型 xslt 用于与XML/XSTL整合的结果类型 plainText 用于显示某个页面的原始代码的结果类型 局部结果 配置局部结果就是在作为的子标签配置，就是上面的配置方式，但是这种局部配置只针对自己的父标签的action起作用。如下： 1234567&lt;!-- name指定了包的名称，extends指定继承的类，namespace指定url路径，这里使用/表示在根路径下就可以直接访问 --&gt;&lt;package name="Login" extends="struts-default" namespace="/"&gt;&lt;action name="login" class="com.controller.LoginAction"&gt; &lt;result name="success"&gt;/JSP/success.jsp&lt;/result&gt; &lt;result name="login"&gt;/JSP/login.jsp&lt;/result&gt;&lt;/action&gt;&lt;/package&gt; 配置全局结果 当我们需要一个视图可能这个package中action都需要，如果一个action中定义一个这样的result难免有些多余，现在我们使用只需要在元素内定义一次即可，一旦有返回值满足即可调用这个视图。比如我们定义一个错误处理的界面，因为这个处理视图是一样的，只需要配置全局result即可。 123456789&lt;package name=”Login” extends=”struts-default” namespace=”/user”&gt;&lt;global-results &gt; &lt;!—只要执行action的类返回error就会跳转到error.jsp--!&gt; &lt;result name=”error”&gt;error.jsp&lt;/result&gt;&lt;/global-results&gt;&lt;action name=”login”class=”com.action.LoginAction”&gt; &lt;result name=”success”&gt;success.jsp&lt;/result&gt;&lt;/action&gt;&lt;/package&gt; 根据上面的配置，如果此时login这个action返回的字符串为error，那么此时的全局配置结果就起作用了，就会跳转到error.jsp页面 但是我们一个action处理错误的页面和特殊，虽然返回的是error，但是我就想跳转到其他的页面，那么可以在这个action的标签下重新定义一个结果，此时的局部结果就会覆盖全局结果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Struts2入门]]></title>
      <url>%2F2018%2F03%2F30%2FStruts2%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[入门操作##导入jar 包 到官网下载相应的jar包 导入前阶段必须的jar包 创建项目 在eclipse中创建一个web项目 在webContent下WEB-INF/lib下导入需要的jar包即可 配置核心过滤器 StrutsPrepareAndExecuteFilter （web.xml) 核心过滤器相当于springmvc中的前端控制器的功能，都是用来分发请求的 这里的核心过滤器默认分发的请求是以.action结尾的请求，因此我们可以使用这个默认的，但是我们也可以自己配置自己的，下面我配置的是所有的请求都分发 在web.xml中配置 1234567891011&lt;!-- 配置struts2的核心过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;!-- struts2中默认的访问路径是以.action结尾的路径才会分发， 因此我们这里需要设置即使不是.action结尾的也能分发请求给对应的action --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 创建action类 定义action类有两种方法，一种是实现Action接口，一种是继承ActionSupport,这个在第二章会详细讲解 12345678910111213import com.opensymphony.xwork2.Action;/** * action类： 这里实现的Action接口 * @author chenjiabing */public class TestAction implements Action &#123; @Override public String execute() throws Exception &#123; System.out.println("cchjemko"); return SUCCESS; &#125;&#125; 创建核心配置文件 文件名为： struts.xml 存放的路径： 在src目录下，或者自己创建的源文件夹的根目录下 struts.xml 内容 123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.1//EN" "http://struts.apache.org/dtds/struts-2.1.dtd"&gt;&lt;struts&gt; &lt;!--定义package ，name是这个package的名字，唯一标识 extends: 该属性是一个选择属性，表示继承其他的包，但是我们一般都会继承struts-default namespace：该属性是一个可选属性，指定该包的命名空间，默认的是“/”,以为一个配置文件中可能有相同名字的action，如果配置不同的namespace，那么就可以配置相同的action的名字，这个和调用执行请求的url息息相关 --&gt; &lt;package name="test" extends="struts-default" namespace="/"&gt; &lt;!-- 配置测试的action类，其中name是调用的别名，class是Action类的全路径 类名+包名--&gt; &lt;action name="testaction" class="com.jsnu.struts2.controller.TestAction" &gt; &lt;!--name是Action类中返回的值，/jsp/success.jsp是对应的跳转视图，这里如果返回success，那么跳转到/jsp/success.jsp这个视图--&gt; &lt;result name="success"&gt;/jsp/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 创建视图 前面的核心配置文件中定义了跳转的视图为 /jsp/success.jsp 在webContent下创建一个jsp文件夹，在其中创建一个success.jsp文件 执行 开启tomcat，在浏览器张输入：http://localhost:8080/Struts2/testaction.action 执行成功之后，我们将会看到调用上面的链接，页面就会跳转到success.jsp页面 但是我们看到地址依然没有改变，因为struts默认的跳转是以转发的方式，不是重定向，后面我们会讲到怎样设置跳转方式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JDBC干货二]]></title>
      <url>%2F2018%2F03%2F30%2FJDBC%E5%B9%B2%E8%B4%A7%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[Day02Properties属性配置对象什么是properties 程序猿可以把工程中出现的某些数据以配置文件的形式保存起来，就是处理 *.properties文件的对象，在properties文件中是以键值对形式保存的数据 把数据库中的信息存放到该文件中 其中存放的是driver ,url , username,password 为什么要保存到该配置文件中 因为以后的工作中有更换数据库的需求，此时如果写在java类中修改比较麻烦，所以需要把这些数据保存到配置文件中 存放数据 在src的目录下创建一个jdbc.properties配置文件 将数据库的信息保存到其中(键值对的形式) 1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/jdbcusername=rootpassword=root 存放数据注意事项 数据是以键值的形式存放的（key-value） value的值不能带有引号，并且后面不能有空格 读取Properties配置文件中的信息 既然我们将数据库中的配置信息存放到配置文件中，我们当然需要将其读取到java代码中使用 前提：这个配置文件在src目录下 12345678910111213@Testpublic void testPro()&#123; Properties properties=new Properties(); //创建Properties对象 //使用类加载器生成输入流（读取） 前提是该配置文件必须在src目录下 InputStream ips=TestProperties.class.getClassLoader().getResourceAsStream("jdbc.properties"); try &#123; properties.load(ips); String s1=properties.getProperty("url"); //直接读取，以键值 System.out.println(s1); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 定义此时的工具类 我们引用了配置文件，那么我们的工具类就需要改变了，在工具类需要读取配置文件中数据库信息 我们知道数据库的配置信息是不变的，因此我们不需要每次连接都加载一次，所以我们可以将读取数据库配置信息的代码放在静态语句块中，那么只有当类加载的时候才会加载一次 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.Properties;/** * 数据库封装类 * @author chenjiabing */public class DBUtils &#123; private static String driver; //驱动 private static String url; //url private static String username; //用户名 private static String password; //密码 //静态语句块,只在使用类加载的时候加载一次，因为其中的数据不用每次都加载，所以只需要加载一次 static&#123; Properties properties=new Properties(); //创建对象 //使用类加载器读取文件输入流 InputStream ips=DBUtils.class.getClassLoader().getResourceAsStream("jdbc.properties"); try &#123; properties.load(ips); //读取属性值 driver=properties.getProperty("driver"); url=properties.getProperty("url"); username=properties.getProperty("username"); password=properties.getProperty("password"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接对象 * @param user 数据库用户名 * @param password 密码 * @param database : 数据库名称 */ public static Connection getConnection() throws Exception &#123; Class.forName("com.mysql.jdbc.Driver"); // 注册驱动 // 链接数据库 Connection connection = DriverManager.getConnection( url, username, password); return connection; &#125; /** * 关闭数据库资源 * @param connection 连接对象 * @param statement Statement对象 * @param resultSet 结果集 */ public static void close(Connection connection, Statement statement, ResultSet resultSet) &#123; try &#123; if (resultSet != null) &#123; resultSet.close(); &#125; if (statement != null) &#123; statement.close(); &#125; if (connection != null) &#123; connection.close(); &#125; &#125; catch (Exception exception) &#123; exception.printStackTrace(); &#125; &#125;&#125; 数据库连接池什么是数据库连接池(DBCP DatabaseConnection Pool) 一套管理数据库连接的api 为什么用 如果没有数据库连接池的话，每次和数据库进行交互都需要建立连接和关闭连接，如果有1万次交互就有一万次建立和关闭连接，频繁开关连接非常消耗资源。使用数据库连接池，可以设置一个初始连接数量，如果有连接需求会和连接池要，连接池中有空闲连接则用空闲的，如果没有此时会检测是否是最大数量，如果是则等待，如果不是则创建新的连接，每个连接使用完之后会归还到连接池中。等待连接池的，如果有归还的连接会直接得到此连接进行操作 原理 使用数据库连接池，可以设置一个初始连接数量，如果有连接需求会和连接池要，连接池中有空闲连接则用空闲的，如果没有此时会检测是否是最大数量，如果是则等待，如果不是则创建新的连接，每个连接使用完之后会归还到连接池中。等待连接池的，如果有归还的连接会直接得到此 如何使用数据库连接池 下载jar包 去maven私服中，找到dbcp-1.4版本的 添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; 初次使用（连接数据库） 1234567891011121314151617//创建数据源对象 BasicDataSource dataSource=new BasicDataSource(); //设置连接信息 driver url username password dataSource.setDriverClassName("com.mysql.jdbc.Driver"); dataSource.setUrl("jdbc:mysql://localhost:3306/jdbc"); dataSource.setUsername("root"); dataSource.setPassword("root"); //设置连接池策略信息 dataSource.setInitialSize(3); //设置初始连接数量 dataSource.setMaxActive(5); //设置最大连接数量 //获取连接 Connection connection=dataSource.getConnection(); System.out.println(connection); JDBC工具类终极版 使用数据库连接池 使用了properties配置文件的形式存储数据库配置信息 jdbc.properties(key-value 键值对形式存储) value最后不能有空格 value的值不能用引号 因为使用的是类加载器加载的，因此这个文件的位置应该在src目录下 123456driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/jdbcusername=rootpassword=rootinitSize=3maxSize=5 实现 数据库的配置信息不是经常改变的，因此不用每次使用都重新加载，只需要加载一次(静态语句块) 数据源和数据库连接池的配置信息(初始连接数量，最大连接数量) 只需要加载一次（静态语句块) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.Properties;import org.apache.commons.dbcp.BasicDataSource;/** * 数据库封装类 ： 终极版 * @author chenjiabing */public class DBUtils &#123; private static String driver; //驱动 private static String url; //url private static String username; //用户名 private static String password; //密码 private static String maxSize; //最大连接数量 private static String initSize; //初始化连接数量 private static BasicDataSource dataSource; //数据源 //静态语句块,只在使用类加载的时候加载一次，因为其中的数据是不会经常改变的，所以只需要加载一次 static&#123; Properties properties=new Properties(); //创建对象 //使用类加载器读取文件输入流 InputStream ips=DBUtils.class.getClassLoader().getResourceAsStream("jdbc.properties"); try &#123; properties.load(ips); //读取属性值 driver=properties.getProperty("driver"); url=properties.getProperty("url"); username=properties.getProperty("username"); password=properties.getProperty("password"); initSize=properties.getProperty("initSize"); maxSize=properties.getProperty("maxSize"); dataSource=new BasicDataSource(); //获取数据源 //设置数据源的属性-----数据库的配置信息 dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); dataSource.setInitialSize(Integer.parseInt(initSize)); dataSource.setMaxActive(Integer.parseInt(maxSize)); &#125; catch (IOException e) &#123; System.out.println("配置文件jdbc.properties读取失败！！！"); e.printStackTrace(); &#125; &#125; /** * 获取数据库连接 * @return * @throws Exception */ public static Connection getConnection() throws Exception &#123; Connection connection=dataSource.getConnection(); return connection; &#125; /** * 关闭数据库资源 * @param connection 连接对象 * @param statement Statement对象 * @param resultSet 结果集 */ public static void close(Connection connection, Statement statement, ResultSet resultSet) &#123; try &#123; if (resultSet != null) &#123; resultSet.close(); &#125; if (statement != null) &#123; statement.close(); &#125; if (connection != null) &#123; connection.close(); &#125; &#125; catch (Exception exception) &#123; exception.printStackTrace(); &#125; &#125;&#125; 测试连接123456789101112131415161718192021222324252627282930313233343536import java.sql.Connection;import java.sql.ResultSet;import java.sql.Statement;import org.junit.Test;import com.jsnu.db.DBUtils;public class TestDBUtils &#123; @Test public void test() &#123; Connection connection = null; Statement statement = null; ResultSet resultSet = null; try &#123; connection = DBUtils.getConnection(); //获取连接 statement = connection.createStatement(); //创建Statement语句对象 String select_sql = "select * from t"; resultSet = statement.executeQuery(select_sql); //执行查询方法 while (resultSet.next()) &#123; int id = resultSet.getInt("id"); //获取属性 String name = resultSet.getString("name"); int age = resultSet.getInt("age"); System.out.println(id + "---" + age + " ----" + name); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; DBUtils.close(connection, statement, resultSet); //关闭资源 &#125; &#125;&#125; 测试等待 我们知道连接池有最大的连接限制，只要连接的数量需求超过最大值，那么我们就需要等待，直到连接池中有空闲的连接。 上面我们设置的最大连接数量为5，此时我们利用多线程来测试等待的过程 connection.close 就是归还连接，因为连接关闭了 线程类： 123456789101112131415public class TestDButils2 extends Thread &#123; @Override public void run() &#123; try &#123; Connection connection=DBUtils.getConnection(); System.out.println(connection); //获取连接 System.out.println(this.getName()+ "： 正在运行"); Thread.sleep(5000); //睡眠5s connection.close(); //关闭连接，相当于释放连接，归还到连接池中 System.out.println(this.getName()+":连接已经归还"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; main方法中测试 在main方法中创建了六个线程，那么最大的连接数量是5，此时肯定有一个线程在等待获取连接，直到前面的线程归还连接才会执行 1234567public static void main(String[] args) &#123; for(int i=0;i&lt;=6;i++)&#123; TestDButils2 testDButils2=new TestDButils2(); testDButils2.start(); //线程启动 &#125; &#125; PrepareStatement好处 代码结构更加清晰，比拼接字符串出错概率要低 执行效率要比Statement高（效果不是太明显）因为使Statement每次执行sql都需要把sql编译成执行计划，而PrepareStatement只需要创建时转化一次，之后只需要修改里面的值即可，所以效率会高 有预编译可避免sql注入，预编译的时候把sql语句的逻辑已经定死，不能再向其中添加新的逻辑 sql注入 创建用户表 drop table user if exists; //有则先删除 create table user(id int primary key auto_increment,username varchar(10),password varchar(20)); insert into user(username,password) values(‘libai’,’admin’),(‘zhaosi’,’123456’); 用户登录 根据用户名和密码查询人数，如果 &gt;0 表示有这个人，如果 &lt;0 登录失败 select count(*) from user where username=”libai” and password=”admin”; 我们只需要使用select count(*) from user where username=&#39;xds&#39; and password=&#39;&#39; or &#39;1&#39;=&#39;1&#39; 那么会直接登录成功，无论用户名和密码是多少。这种是使用Statement才会生效，因为其中的sql是拼接的。我们只需要输入密码为 &#39; or &#39;1&#39;=1即可sql注入]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JDBC干货一]]></title>
      <url>%2F2018%2F03%2F30%2FJDBC%E5%B9%B2%E8%B4%A7%E4%B8%80%2F</url>
      <content type="text"><![CDATA[JDBC什么是JDBC Java Database Connectivity JDBC是java中一套和数据库进行交互的API(应用程序编程接口) 为什么使用JDBC 因为java程序猿需要连接各种数据库（oracle，mysql，db2等）为了避免java程序猿每一种数据库都需要学习一遍，sun公司提出一个JDBC接口，各个数据库厂商去针对此接口写实现类（数据库驱动），这样的话java程序猿连接数据库只需要掌握JDBC接口的调用就可以操作各种数据库 eclipse配置maven 本机安装maven 修改远程仓库地址 maven的配置文件settings中修改 123456789101112131415161718192021222324252627282930 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd"&gt; &lt;pluginGroups&gt; &lt;/pluginGroups&gt; &lt;proxies&gt; &lt;/proxies&gt; &lt;servers&gt; &lt;/servers&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;Tedu Maven&lt;/name&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;!--&lt;url&gt;http://maven.tedu.cn/nexus/content/groups/public&lt;/url&gt;--&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;profiles&gt; &lt;/profiles&gt; &lt;activeProfiles&gt; &lt;/activeProfiles&gt;&lt;/settings&gt; 在eclispe中配置 window —- &gt; perferences —- &gt; Maven — &gt; User Settings —- &gt; 在Global Settings中选择你的maven配置文件settings即可 OK 新建项目 New — &gt; Maven Project — &gt; Create Simple Project 第一次创建可能需要很长的时间 在pom.xml中写上依赖 123456789101112131415161718192021222324252627 &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.tedu&lt;/groupId&gt; &lt;artifactId&gt;JDBCMaven&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.44&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 如何使用JDBC 创建maven工程 下载mysql相关jar包 登录阿里私服： maven.aliyun.cn 执行方法(Statement) execute(sql) 执行DDL create alter executeUpdate(sql) 执行DML insert update delete executeQuery(sql) 执行select语句 12345678910111213141516171819202122232425 Class.forName("com.mysql.jdbc.Driver"); //注册驱动//链接数据库Connection connection=DriverManager.getConnection("jdbc:mysql://localhost:3306/jdbc", "root", "root");//创建Statement，执行sql语句的对象Statement statement =connection.createStatement();String sql_create="create table if not exists t(id int primary key auto_increment,age int ,name varchar(10))";String sql_insert="insert into t(age,name) values(22,'jack'),(33,'tom')";String sql_sselect="select * from t";//执行create 语句Boolean flag=statement.execute(sql_create);System.out.println(flag);//执行insert语句int row=statement.executeUpdate(sql_insert);System.out.println(row);//执行selectResultSet resultSet=statement.executeQuery(sql_sselect);while(resultSet.next())&#123; int id=resultSet.getInt("id"); int age=resultSet.getInt("age"); String name = resultSet.getString("name"); System.out.println(id+"----"+age+"----"+name);&#125; ResultSet(查询得到结果集) 代表查询语句得到的结果集(executeQuery) 见到resultSet 就用while next() 移动游标 有下一条返回true，没有返回false 1234567891011121314 Class.forName("com.mysql.jdbc.Driver"); //加载驱动 // 链接数据库Connection connection=DriverManager.getConnection("jdbc:mysql://localhost:3306/jdbc", "root", "root");Statement statement =connection.createStatement(); //获取执行sql语句对象 String sql_sselect="select * from t"; //创建sql语句 ResultSet resultSet=statement.executeQuery(sql_sselect); //获取结果集while(resultSet.next())&#123; int id=resultSet.getInt("id"); int age=resultSet.getInt("age"); String name = resultSet.getString("name"); System.out.println(id+"----"+age+"----"+name);&#125; 关闭资源(close) 关闭Connection 如果sql执行完，继续持有连接没有意义，会造成服务器压力过大，所以需要关闭 关闭Statement 会占用内存的资源，所以用完就关闭 关闭ResultSet 因为ResultSet对象中包含查询结果的数据，会占用内存空间 关闭顺序 ResultSet , Statement , Connection 异常处理123456789101112131415161718192021222324252627282930313233343536@Test public void testException() &#123; Connection connection = null; //申明Connection为null Statement statement = null; // 申明 Statement为null try &#123; Class.forName("com.mysql.jdbc.Driver"); // 注册驱动 // 链接数据库 connection = DriverManager.getConnection( "jdbc:mysql://localhost:3306/jdbc", "root", "root"); // 创建Statement，执行sql语句的对象 statement = connection.createStatement(); String sql_insert = "insert into t(age,name) values(22,'marry'),(33,'Alice')"; int row=statement.executeUpdate(sql_insert); System.out.println(row); &#125; catch (Exception e) &#123; System.out.println("出异常"); e.printStackTrace(); &#125; finally &#123; if (statement != null) &#123; try &#123; statement.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (connection != null) &#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; JDBC封装 目的：把频繁出现的代码封装起来，起到代码复用的作用，从而提高开发效率 创建DBUtils类(数据库工具类) 封装建立数据连接 封装关闭资源 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;/** * 数据库封装类 * @author chenjiabing */public class DBUtils &#123; /** * 获取连接对象 * @param user 数据库用户名 * @param password 密码 * @param database : 数据库名称 */ public static Connection getConnection(String user, String password, String database) throws Exception &#123; Class.forName("com.mysql.jdbc.Driver"); // 注册驱动 // 链接数据库 Connection connection = DriverManager.getConnection( "jdbc:mysql://localhost:3306/" + database, user, password); return connection; &#125; /** * 关闭数据库资源 * @param connection 连接对象 * @param statement Statement对象 * @param resultSet 结果集 */ public static void close(Connection connection, Statement statement, ResultSet resultSet) &#123; try &#123; if (resultSet != null) &#123; resultSet.close(); &#125; if (statement != null) &#123; statement.close(); &#125; if (connection != null) &#123; connection.close(); &#125; &#125; catch (Exception exception) &#123; exception.printStackTrace(); &#125; &#125;&#125; 测试 1234567891011121314151617 @Testpublic void testUntils()&#123; Connection connection=null; Statement statement=null; ResultSet resultSet=null; try &#123; connection=DBUtils.getConnection("root", "root", "jdbc"); //获取连接 statement=connection.createStatement(); //插入数据 int row = statement.executeUpdate("insert into t(age,name) values(22,'陈加兵'),(33,'Jackson')"); System.out.println(row); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; DBUtils.close(connection, statement, resultSet); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL操作六]]></title>
      <url>%2F2018%2F03%2F28%2FSQL%E6%93%8D%E4%BD%9C%E5%85%AD%2F</url>
      <content type="text"><![CDATA[Day06视图视图概述 什么是视图： 在数据库中存在多种对象，表和视图都是数据库中的对象，创建视图时视图名称不能和表名相同，实际上，视图就代表一个sql查询语句，也可以理解成视图是一张虚拟的表，但是虚拟表中的数据会随着原表数据的改变而改变 为什么使用视图： 因为有些数据的查询需要书写大量的sql语句，每次书写比较麻烦，使用视图可起到重用sql语句的作用 可以通过视图隐藏敏感信息，比如隐藏员工工资的字段，那么我们可以创建一个视图，其中不包含工资这个字段 创建视图的格式： create view 视图名 as 子查询 create view view_emp_10 as(select * from emp where deptno=10); 创建一个视图view_emp_10 （简单视图） create view view_dep_20 as(select * from EMP where deptno=20 and sal&lt;3000 ); 创建emp表部门是20，工资小于3000的视图 create view view_emp_sum_max(select max(sal),sum(sal),min(sal) from EMP); 复杂视图，只能查看，不能删除修改插入 如何查看视图： 查询的方式和表的查询方式一样(select) 视图分类 简单视图 ： 创建视图的子查询中 不包含去重，函数，聚合，关联查询的视图成为简单视图 简单视图可以实现增删改查 复杂视图 ： 和简单视图相反 复杂视图是能查询 视图数据污染 什么是数据污染： 在视图中插入一条数据，在视图中不显示，但是在原表中显示的数据，称为数据污染 在视图中只要进行insert操作时才会造成数据污染，因为update和delete只能操作视图中存在的数据 如果一旦执行插入语句，但是插入的数据不符合创建视图时的子查询条件，那么就会插入视图中失败，但是会插入到原表中，这个是我们不需要的，这个就叫做视图数据污染。 往视图中插入数据，删除数据，修改数据 简单视图： 删除数据： 如果将视图中的数据删除了，那么原表中的数据也会删除掉 插入数据： 如果插入的数据符合创建视图的子查询的条件，那么就会将数据插入进视图和原表中，如果不符合创建视图时的子查询的条件，那么数据只会插入到原表中，不会插入进视图。 比如上面创建的view_emp_10视图，子查询条件为deptno=10,如果插入视图的数据的的deptno字段为10，那么就会显示在视图和表中，如果不为10，那么只会显示在表中。 更新数据： 如果更新后的数据不符合创建视图时子查询的条件的话，那么这些数据就会移除视图，但是原表中还会显示，只是不在视图中显示。 如果满足子查询的条件，那么就会成功更新在视图中，原表和视图的数据都会更新并且都会显示 比如上面创建的view_emp_10的视图，如果我们将视图中的一条数据的deptno改为11，那么这条数据将不会显示在视图中，只会显示在原表中。 总结： 更新和删除都是对视图中已经存在的数据进行操作，如果存在就会直接删除和更新，并且原表中的数据也会同时被删除和更新，但是如果执行更新操作，更新后的条件不符合创建视图时子查询的条件，那么这些数据将不会显示在视图中，但是在表中还是存在的 插入数据有可能会造成数据污染 避免视图数据污染(with check option) 我们在创建的视图的时候加上with check option 即可 create view v_emp_30 as(select * from EMP where deptno=30) with check option; 现在我们在往v_emp_30的视图中插入数据，其中字段deptno不等于30，那么就会报错，因为不符合创建视图时的子查询条件 但是如果我们没有使用with check option，那么我们就会插入成功，虽然不会在视图中显示，但是插入到原表中了，造成了视图数据污染 修改视图 我们创建一个视图 create view view_emp_10 as(select * from emp where deptno=10); 现在我们需要为子查询加上一个条件 工资大于3000的，即是 创建一张视图，里面数据是部门号为10，工资大于3000的全部员工信息，那么我们就需要在原有的view_emp_10的基础上修改 create or replace view view_emp_10 as(select * from EMP where deptno=10 and sal&gt;3000);直接在create后面加上or replace即可，有就替换 删除视图 格式 ：drop view 视图名称 drop view_emp_10; 删除视图view_emp_10，如果存在就删除，不存在就报错 加上关键字 if exists 如果存在就删除，不存在也不报错 drop view if exists view_emp_10; 如果创建视图的时候对视图中的字段使用了别名，那么以后对视图的操作只能使用别名来操作 create view view_1 as(select ename name from emp where deptno=10); 这里面的子查询将字段ename起了别名，那么我们在以后操作的时候只能使用别名对这个字段操作 案例 创建视图显示每个部门对应的员工的名字 `create view view_emp_dept as(select d.dname,e.ename from EMP e join Dept d on d.deptno=e.deptno); 修改上面的视图在上面题的前提下只显示工资在3000以内的 create or replace view view_emp_dept as(select d.dname,e.ename from EMP e join Dept d on d.deptno=e.deptno where e.sal&lt;3000); 删除上面的视图 drop view if exists v_emp_dept; 索引原理索引概述 什么是索引： 索引是用来提高查询速度的技术，类似于一个目录，查询数据时会从索引中对数据进行定位，然后直接找到数据所在的位置 为什么使用索引 ： 因为不使用索引的话，查询数据会按照磁盘块一块一块的去查，如果数据量很大，效率很低 索引分为聚集索引和非聚集索引 在mysql中数据库会为主键自动创建聚集索引，聚集索引中数据是有序保存 索引内部实现原理 ： B+tree 数据库中创建索引的过程是数据库内部自己控制，然后使用索引的过程也是数据库自己操作的，不需要程序猿干涉 创建索引 格式： create index 索引名 on 表名(字段名([长度])); 创建索引之前先查询title=’100’的数据，看看查询时间 select * from item2 where title=’100’; 创建title索引 create index index_title on item2(title); 再次查询，查看时间 select * from item2 where title=’100’; 查看索引 格式: show index from 表名 其中包含主键的索引，这个是自动创建的 删除索引 格式：drop index 索引名 on 表名 drop index index_title on item2; 索引是越多越好吗？有索引就一定好吗？ 因为索引会占用磁盘空间，所以创建索引需谨慎，只创建查询需求的索引 索引要建立在大量的数据的表中，如果数据量不够大，可能会降低查询效率 复合索引 创建索引的时候指定多个字段，此时如果查询数据正好过滤条件为这多个字段的话，可以降低磁盘块的访问，从而提高查询效率 创建复合索引: create index index_title_price on item2(title,price); 执行查询语句 select * from item2 where title=&#39;100&#39; and price &lt;100000; 可以看出查询效率很高 创建表的时候直接创建索引 create table t_index(id int,age int ,index index index_age(age)); 直接在字段后面写入 index 名字(字段) 总结 索引会占磁盘空间，不是越多越好 数据量小的表不要创建索引 对于经常出现在where ，order by，distinct 后面的字段创建索引 ，效果更好 不要在频繁修改的表中创建索引 约束 什么是约束： 约束就是对表字段的数据进行限制的规则 唯一约束 unique 添加唯一约束的字段，这个字段的值不能重复,否则报错 crate table t(id int ,age int unique); 主键约束 (primary key) 创建表时添加主键约束 create table t(id int primary key auto_increment,age int); 创建表之后添加主键 (primary key(字段名) ) alter table t add primary key(id); 删除主键约束 格式： alter table 表名 drop primary key alter table t drop primary key; 自增约束(auto_increment) 当字段赋的值为null时，字段会自动增长 如果删除了某条数据，自增数值不会减少 自增的基础是根据字段的最大值来自增的 create table t(id int primary key auto_increment,age int); 如果使用delete清空表(delete from t) ,那么自增的值不会从头开始 如果使用truncate table t 的方式清空表，那么自增的值会从头开始，则从1开始 外键约束（foreign key） 外键约束是保证一个表或者两个表之间数据一致性和完整性的约束 工作中除非特殊情况，一般不使用外键约束，通过代码逻辑进行限制，避免测试时不必要的麻烦 外键的值通常是另外一张表的主键 外键可以重复，可以为null，但不能是另外一张表中不存在的数据- 使用外键约束的条件： 必须保证两张表使用相同的引擎(engine) 引擎必须是innodb,myisam不支持外键约束 外键和关联字段必须是相同的数据类型，比如一张表的主键id的外键，那么这个外键一定要是int类型 外键所对应的关联字段如果不是主键，会自动为该字段创建索引 创建外键约束 格式 ： create table t(id int primary key auto_increment,deptid int,constraint 约束名 foregin key(deptid) references 关联的表名(关联表的字段名)) 创建两张表 t_emp 和 t_dept 先创建部门表 create table t_dept(id int primary key auto_increment,name varchar(10)); 创建t_emp create table t_emp(id int primary key auto_increment,name varchar(10),deptid int,constraint fk_dept foreign key(deptid) references t_dept(id)); 测试： 如果插入数据到t_emp中的时候，其中的deptid的值在t_dept中的id不存在的话，那么插入失败，因为两个是外键关联的 如果想要删除t_dept的数据，但是在t_emp中的还有关联的数据(即是deptid)，那么删除失败，只有将t_emp中关联的数据字段deptid设置为null，此时在删除才会成功 外键总结 保证一个表或两个表之间的数据一致性和完整性，工作不怎用，外键的值是关联表的主键，值可以是null可以重复，不能是不存在的数据，使用外键必须两张表使用innodb引擎，数据类型要一致，会自动添加索引 非空约束(not null) 该字段的值不能为null，否则报错 默认约束(default) 给字段设置默认值 create table t(id int primary key auto_increment,age int not null default 0); 设置字段age设置默认值为0 ，如果插入数据的时候没有插入age的值，那么默认赋值为0 check 约束 在mysql中不生效，但是语法不报错 create table t_check(id int,age int,check(age&gt;10)); 什么是事务 事务是数据库执行sql语句的工作单元或者最小单元，写在事务里面的sql要么同时成功，要么同时失败 事务的ACID性质(重要，面试常考) Automicity ： 原子性 ： 最小，不能拆分 Consistency： 一致性 ： 要么同时成功，要么同时失败 Isolation： 隔离性 ： 事务和事务之间互不影响 Durablity ： 持久性 ： 事务执行完之后数据持久保存到数据库中 MySQL事务 show variables lile “%autocommit%” set autocommit=0/1 开启 begin commit rollback savepoint s1 rollback to s1 事务案例 转账]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL操作五]]></title>
      <url>%2F2018%2F03%2F28%2FSQL%E6%93%8D%E4%BD%9C%E4%BA%94%2F</url>
      <content type="text"><![CDATA[Day05关联关系自关联 当前表的数据和当前表里面的数据有关联关系 一对一一对多多对多 学生和老师的关系就是多对多的关系一个学生可以被多个老师教，一个老师可以教多个学生 创建表 创建教师表 teacher(id,name)创建学生表 stu(id,name)创建第三张关系表t_s(sid,t_id) 查询 查询学生小明的所有老师 通过小明查询出小明的id 得到小明的id 在关系表中查询出对应的老师的id 通过关系表中的老师的id再和教师表关联查询查出所有的老师 select name from teacher where id in ( select t_s.tid from stu join t_s on stu.id=t_s.sid where stu.name=&#39;小明&#39;); 子查询方式，但是子查询中使用了内连接，也可以使用等值连接 select t_s.tid from stu join t_s on stu.id=t_s.sid join teacher t on t.id=tid where stu.name=&#39;小明&#39;; 使用内连接的方式查询，多个join连接，where条件语句应该放在最后一个join的on的后面 查询所有老师对应的所有学生0 select t.name t_name,stu.name s_name from stu join t_s on stu.id=t_s.sid join teacher t on t.id=tid; 查询唐僧的所有学生 select t.name t_name,stu.name s_name from stu join t_s on stu.id=t_s.sid join teacher t on t.id=tid where t.name=&#39;唐僧&#39;; 如何让两张表建立关系 自关联 自关联是在一张表中，这张表中要有一个字段记录上级的主键 一对一： 需要在从表中有个字段表示主表的主键值 （外键） 一对多 部门和员工为例，需要在多的一端通过字段记录另外一张的表的主键 （外键） 多对多 需要准备一张关系表，表中保存两张表的主键值（第三张表） （外键） 连接方式和关联关系的区别 连接方式： 包括内连接，等值连接，左/右外连接 是指查询两张表时使用的查询方式 关联关系： 一对一，一对多，多对多 是指两张表之间存在的逻辑关系 数据库设计值权限管理什么是权限管理 不同用户登录网站后可能会有不同的权限，实现此功能的过程称为权限管理 权限管理表的实现 总共需要5张表 用户表 角色表 权限表 用户和角色关系表 角色和权限的关系表]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL操作四]]></title>
      <url>%2F2018%2F03%2F26%2FSQL%E6%93%8D%E4%BD%9C%E5%9B%9B%2F</url>
      <content type="text"><![CDATA[Day 04创建数据库和表商城建表语句123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110DROP TABLE IF EXISTS `t_item`;CREATE TABLE `t_item` ( `id` varchar(200) NOT NULL COMMENT '商品id', `category_id` bigint(20) DEFAULT NULL COMMENT '分类id', `item_type` varchar(100) DEFAULT NULL COMMENT '商品系列', `title` varchar(100) DEFAULT NULL COMMENT '商品标题', `sell_point` varchar(150) DEFAULT NULL COMMENT '商品卖点', `price` bigint(20) DEFAULT NULL COMMENT '商品单价', `num` int(10) DEFAULT NULL COMMENT '库存数量', `barcode` varchar(30) DEFAULT NULL COMMENT '条形码', `image` varchar(500) DEFAULT NULL COMMENT '图片路径', `status` int(1) DEFAULT '1' COMMENT '商品状态 1：上架 2：下架 3：删除', `priority` int(10) DEFAULT NULL COMMENT '显示优先级', `created_time` datetime DEFAULT NULL COMMENT '创建时间', `modified_time` datetime DEFAULT NULL COMMENT '最后修改时间', `created_user` varchar(50) DEFAULT NULL COMMENT '创建人', `modified_user` varchar(50) DEFAULT NULL COMMENT '最后修改人', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;INSERT INTO `t_item` VALUES ('10000000',238,'牛皮纸记事本','广博(GuangBo)10本装40张A5牛皮纸记事本子日记本办公软抄本GBR0731','经典回顾！超值特惠！',23,99999,NULL,'/images/portal/00GuangBo1040A5GBR0731/collect.png',1,53,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000001',238,'牛皮纸记事本','广博(GuangBo)10本装40张A5牛皮纸记事本子日记本办公软抄本GBR0731','经典回顾！超值特惠！',23,99999,NULL,'/images/portal/00GuangBo1040A5GBR0731/collect.png',1,62,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000002',238,'皮面日程本','广博(GuangBo)皮面日程本子 计划记事本效率手册米色FB60322','经典回顾！超值特惠！',46,99999,NULL,'/images/portal/001GuangBo)FB60322/collect.png',1,49,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('100000021',238,'皮面日程本','广博(GuangBo)皮面日程本子 计划记事本效率手册蓝色FB60321','经典回顾！超值特惠！',22,99999,NULL,'/images/portal/001GuangBo)FB60322/collect.png',1,73,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000003',238,'记事本日记本笔记本','广博(GuangBo)16K115页线圈记事本子日记本文具笔记本图案随机','经典回顾！超值特惠！',13,99999,NULL,'/images/portal/01GuangBo16K115FB60506/collect.png',1,58,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000004',241,'计算器','得力（deli）1548A商务办公桌面计算器 太阳能双电源','经典回顾！超值特惠！',58,99999,NULL,'/images/portal/002calculator1548A/collect.png',1,42,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000005',241,'圆珠笔','施耐德（Schneider） K15 经典款圆珠笔 (5支混色装)','经典回顾！超值特惠！',29,99999,NULL,'/images/portal/03SchneiderK15/collect.png',1,36,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000006',236,'票据网格拉链袋','三木(SUNWOOD) C4523 票据网格拉链袋/文件袋 12个装 颜色随机','经典回顾！超值特惠！',28,99999,NULL,'/images/portal/04_SUNWOODC452312/collect.png',1,53,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000007',163,'燃 7000经典版','戴尔Dell 燃700金色','下单赠12000毫安移动电源',32999,99999,NULL,'/images/portal/11DELLran7000gold/collect.png',1,59,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000008',163,'燃 7000经典版','戴尔Dell 燃700R1605银色','仅上海，广州，沈阳仓有货！预购从速！',4549,99999,NULL,'/images/portal/11DELLran7000R1605Ssilvery/collect.png',1,32,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000009',163,'燃 7000学习版','戴尔Dell 燃700金色','下单赠12000毫安移动电源',39929,99999,NULL,'/images/portal/11DELLran7000gold/collect.png',1,84,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000010',163,'燃 7000学习版','戴尔Dell 燃700R1605银色','仅上海，广州，沈阳仓有货！预购从速！',5559,99999,NULL,'/images/portal/11DELLran7000R1605Ssilvery/collect.png',1,21,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000011',163,'燃 7000高配版','戴尔Dell 燃700金色','下单赠12000毫安移动电源',3994,99999,NULL,'/images/portal/11DELLran7000gold/collect.png',1,56,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000012',163,'燃 7000高配版','戴尔Dell 燃700R1605银色','仅上海，广州，沈阳仓有货！预购从速！',6559,99999,NULL,'/images/portal/11DELLran7000R1605Ssilvery/collect.png',1,16,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000013',238,'A5优品商务笔记本','齐心（COMIX）C5902 A5优品商务笔记本子记事本日记本122张','下单即送10400毫安移动电源！再赠手机魔法盒！',41,99999,NULL,'/images/portal/02COMIXC5902A5122blue/collect.png',1,10,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000014',163,'XPS13-9360','戴尔(DELL)XPS13-9360-R1609 13.3','仅上海，广州，沈阳仓有货！预购从速！',4600,99999,NULL,'/images/portal/12(DELL)XPS13gold/collect.png',1,1,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000015',163,'XPS13-9360','戴尔(DELL)XPS13-9360-R1609 13.3','仅上海，广州，沈阳仓有货！预购从速！',4601,99999,NULL,'/images/portal/12DELLXPS13-silvery/collect.png',1,73,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000016',163,'XPS13-9360','戴尔(DELL)XPS13-9360-R1609 13.3','仅上海，广州，沈阳仓有货！预购从速！',4602,99999,NULL,'/images/portal/12(DELL)XPS13gold/collect.png',1,64,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000017',163,'XPS13-9360','戴尔(DELL)XPS13-9360-R1609 13.3','仅上海，广州，沈阳仓有货！预购从速！',4604,99999,NULL,'/images/portal/12DELLXPS13-silvery/collect.png',1,100,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000018',163,'XPS13-9360','戴尔(DELL)XPS13-9360-R1609 13.3','仅上海，广州，沈阳仓有货！预购从速！',4605,99999,NULL,'/images/portal/12(DELL)XPS13gold/collect.png',1,7,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000019',163,'XPS13-9360','戴尔(DELL)XPS13-9360-R1609 13.3','仅上海，广州，沈阳仓有货！预购从速！',4899,99999,NULL,'/images/portal/12DELLXPS13-silvery/collect.png',1,34,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000020',163,'IdeaPad310低配版','联想（Lenovo）IdeaPad310低配版','清仓！仅北京，武汉仓有货！',5119,99999,NULL,'/images/portal/13LenovoIdeaPad310_black/collect.png',1,50,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000021',163,'IdeaPad310低配版','联想（Lenovo）IdeaPad310低配版','清仓！仅北京，武汉仓有货！',5129,99999,NULL,'/images/portal/13LenovoIdeaPad310_silvery/collect.png',1,48,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000022',163,'IdeaPad310经典版','联想（Lenovo）IdeaPad310经典版','清仓！仅北京，武汉仓有货！',5119,99999,NULL,'/images/portal/13LenovoIdeaPad310_black/collect.png',1,90,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000023',163,'IdeaPad310经典版','联想（Lenovo）IdeaPad310经典版','清仓！仅北京，武汉仓有货！',5129,99999,NULL,'/images/portal/13LenovoIdeaPad310_silvery/collect.png',1,6,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000024',163,'IdeaPad310高配版','联想（Lenovo）IdeaPad310高配版','清仓！仅北京，武汉仓有货！',5119,99999,NULL,'/images/portal/13LenovoIdeaPad310_black/collect.png',1,60,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000025',163,'IdeaPad310高配版','联想（Lenovo）IdeaPad310高配版','清仓！仅北京，武汉仓有货！',5129,99999,NULL,'/images/portal/13LenovoIdeaPad310_silvery/collect.png',1,80,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000026',163,'YOGA710','联想（Lenovo）YOGA710 14英寸触控笔记本（i7-7500U 8G 256GSSD 2G独显 全高清IPS 360°翻转 正版office）金','【0元献礼】好评过万，销量传奇！经典蓝光电视，独有自然光技术专利，过大年带最好的回家！【0元白条试用，1001个拜年计划】',59999,99999,NULL,'/images/portal/14LenovoYOGA710 _gold/collect.png',1,19,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000027',163,'YOGA710','联想（Lenovo）YOGA710 14英寸触控笔记本（i7-7500U 8G 256GSSD 2G独显 全高清IPS 360°翻转 正版office）银','【0元献礼】好评过万，销量传奇！经典蓝光电视，独有自然光技术专利，过大年带最好的回家！【0元白条试用，1001个拜年计划】',59999,99999,NULL,'/images/portal/14LenovoYOGA710 _silvery/collect.png',1,55,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000028',163,'310低配版','联想（Lenovo）小新310低配版','清仓！仅北京，武汉仓有货！',4939,99999,NULL,'/images/portal/15Lenovo_xiaoxin_310_black/collect.png',1,19,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000029',163,'310低配版','联想（Lenovo）小新310低配版','清仓！仅北京，武汉仓有货！',4839,99999,NULL,'/images/portal/15Lenovo_xiaoxin_310_silvery/collect.png',1,27,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000030',163,'310经典版','联想（Lenovo）小新310经典版','清仓！仅北京，武汉仓有货！',4739,99999,NULL,'/images/portal/15Lenovo_xiaoxin_310_black/collect.png',1,78,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000031',163,'310经典版','联想（Lenovo）小新310经典版','清仓！仅北京，武汉仓有货！',4639,99999,NULL,'/images/portal/15Lenovo_xiaoxin_310_silvery/collect.png',1,9,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000032',163,'310高配版','联想（Lenovo）小新310高配版','清仓！仅北京，武汉仓有货！',4539,99999,NULL,'/images/portal/15Lenovo_xiaoxin_310_black/collect.png',1,9,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000033',163,'310高配版','联想（Lenovo）小新310高配版','清仓！仅北京，武汉仓有货！',4439,99999,NULL,'/images/portal/15Lenovo_xiaoxin_310_silvery/collect.png',1,18,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000034',163,'YOGA900','联想（Lenovo）YOGA900绿色','青春的活力 清新漂亮高端大气上档次',5200,99999,NULL,'/images/portal/16LenovoYOGA900green/collect.png',1,63,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000035',163,'YOGA900','联想（Lenovo）YOGA900粉色','青春的活力 清新漂亮高端大气上档次',5200,99999,NULL,'/images/portal/16LenovoYOGA900pink/collect.png',1,62,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000036',163,'YOGA900','联想（Lenovo）YOGA900红色','青春的活力 清新漂亮高端大气上档次',5200,99999,NULL,'/images/portal/16LenovoYOGA900red/collect.png',1,21,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000037',163,'小新13旗舰版','联想(Lenovo)小新Air13 Pro 13.3英寸14.8mm超轻薄笔记本电脑','青春的活力 青年专属',6439,99999,NULL,'/images/portal/17Lenovo)xiaoxinAir13Pro_gold/collect.png',1,16,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000038',163,'小新13旗舰版','联想(Lenovo)小新Air13 Pro 13.3英寸14.8mm超轻薄笔记本电脑','青春的活力 青年专属',6439,99999,NULL,'/images/portal/17Lenovo)xiaoxinAir13Pro_silvery/collect.png',1,17,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000039',163,'XPS15','戴尔(DELL) XPS15 银色','限时特价！好评过万条优秀产品！',3333,99999,NULL,'/images/portal/18(DELL)XPS15_silvery/collect.png',1,37,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('100000391',163,'XPS15','戴尔(DELL) XPS15 金色','限时特价！好评过万条优秀产品！',3333,99999,NULL,'/images/portal/18(DELL)XPS15_silvery/collect.png',1,81,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000040',163,'DELL 15MF Pro','戴尔(DELL)魔方15MF Pro-R2505TSS灵越','15.6英寸二合一翻转笔记本电脑 (i5-7200U 8GB 1TB IPS Win10)触控银',4443,99999,NULL,'/images/portal/19DELL15MF Pro/collect.png',1,35,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('100000401',163,'DELL 15MF Pro','戴尔(DELL)魔方15MF Pro-R2505TSS灵越','15.6英寸二合一翻转笔记本电脑 (i5-7200U 8GB 1TB IPS Win10)触控白',4443,99999,NULL,'/images/portal/19DELL15MF Pro/collect.png',1,86,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('100000402',163,'DELL 15MF Pro','戴尔(DELL)魔方15MF Pro-R2505TSS灵越','15.6英寸二合一翻转笔记本电脑 (i7-7200U 8GB 512GB IPS Win10)触控银',6443,99999,NULL,'/images/portal/19DELL15MF Pro/collect.png',1,84,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('100000403',163,'DELL 15MF Pro','戴尔(DELL)魔方15MF Pro-R2505TSS灵越','15.6英寸二合一翻转笔记本电脑 (i7-7200U 8GB 512GB IPS Win10)触控白',6443,99999,NULL,'/images/portal/19DELL15MF Pro/collect.png',1,63,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000041',163,'DELL XPS15-9550','戴尔(DELL) XPS15升级版 ','15.6英寸二合一翻转笔记本电脑 (i5-7200U 8GB 1TGB IPS Win10)触控',8443,99999,NULL,'/images/portal/20DellXPS15-9550/collect.png',1,61,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('100000411',163,'DELL XPS15-9550','戴尔(DELL) XPS15升级版 ','15.6英寸二合一翻转笔记本电脑 (i5-7200U 8GB 256GB IPS Win10)触控',8443,99999,NULL,'/images/portal/20DellXPS15-9550/collect.png',1,60,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('100000412',163,'DELL XPS15-9550','戴尔(DELL) XPS15升级版 ','15.6英寸二合一翻转笔记本电脑 (i7-7200U 8GB 1TB IPS Win10)触控',8443,99999,NULL,'/images/portal/20DellXPS15-9550/collect.png',1,13,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('100000413',163,'DELL XPS15-9550','戴尔(DELL) XPS15升级版 ','15.6英寸二合一翻转笔记本电脑 (i7-7200U 8GB 256GB IPS Win10)触控',8443,99999,NULL,'/images/portal/20DellXPS15-9550/collect.png',1,83,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000042',163,'ThinkPad New s1','联想ThinkPad New S2（01CD） i5 6代 红色','经典回顾！超值特惠！',4399,99999,NULL,'/images/portal/21ThinkPad_New_S1/collect.png',1,99,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('100000421',163,'ThinkPad New s1','联想ThinkPad New S2（01CD） i7 6700 红','经典回顾！超值特惠！',6399,99999,NULL,'/images/portal/21ThinkPad_New_S1/collect.png',1,74,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('100000422',163,'ThinkPad New s1','联想ThinkPad New S2（01CD） i5 6代 黄','经典回顾！超值特惠！',4399,99999,NULL,'/images/portal/21ThinkPad_New_S1/collect.png',1,23,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('100000424',163,'ThinkPad New s1','联想ThinkPad New S2（01CD） i5 6代 蓝','经典回顾！超值特惠！',4399,99999,NULL,'/images/portal/21ThinkPad_New_S1/collect.png',1,87,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('100000425',163,'ThinkPad New s1','联想ThinkPad New S2（01CD） i7 6700 蓝','经典回顾！超值特惠！',6399,99999,NULL,'/images/portal/21ThinkPad_New_S1/collect.png',1,59,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000043',917,'书包 bag','乐尚书包 电脑包 bag黑色','给你满载而归的喜悦！',89,99999,NULL,'/images/portal/22_LEXON_LNE6025B06T/collect.png',1,12,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin'),('10000044',917,'书包 bag','乐尚书包 电脑包 bag粉色','给你满载而归的喜悦！',89,99999,NULL,'/images/portal/22_LEXON_LNE6025B06T/collect.png',1,62,'2017-10-25 15:08:55','2017-10-25 15:08:55','admin','admin');DROP TABLE IF EXISTS `t_item_category`;CREATE TABLE `t_item_category` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键', `parent_id` bigint(20) DEFAULT NULL COMMENT '父分类id', `name` varchar(150) DEFAULT NULL COMMENT '名称', `status` int(1) DEFAULT '1' COMMENT '状态 1：正常 2：删除', `sort_order` int(4) DEFAULT NULL COMMENT '排序号', `is_parent` tinyint(1) DEFAULT NULL COMMENT '是否是父分类 1：是 0：否', `created_time` datetime DEFAULT NULL COMMENT '创建时间', `modified_time` datetime DEFAULT NULL COMMENT '最后修改时间', `created_user` varchar(50) DEFAULT NULL COMMENT '创建人', `modified_user` varchar(50) DEFAULT NULL COMMENT '最后修改人', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1183 DEFAULT CHARSET=utf8;INSERT INTO `t_item_category` VALUES (163,162,'笔记本',1,1,0,'2017-10-25 15:00:55','2017-10-25 15:00:55','admin','admin'),(236,229,'文件管理',1,7,0,'2017-10-25 15:00:55','2017-10-25 15:00:55','admin','admin'),(238,229,'本册/便签',1,9,0,'2017-10-25 15:00:55','2017-10-25 15:00:55','admin','admin'),(241,229,'笔类',1,12,0,'2017-10-25 15:00:55','2017-10-25 15:00:55','admin','admin'),(917,913,'双肩包',1,4,0,'2017-10-25 15:00:55','2017-10-25 15:00:55','admin','admin'); 员工建表语句12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152create table EMP(EMPNO int(4) primary key,ENAME varchar(10) not null,JOB varchar(9),MGR int(4),HIREdate date,SAL double(7,2),COMM double(7,2),DEPTNO int(4));create table Dept(DEPTNO int(4) primary key,DNAME varchar(14) not null unique,LOC varchar(13)); insert into Dept VALUES (10,'ACCOUNTING','NEW YORK');insert into Dept VALUES (20,'RESEARCH','DALLAS');insert into Dept VALUES (30,'SALES','CHICAGO');insert into Dept VALUES (40,'OPERATIONS','BOSTON');SELECT * FROM DEPT;insert into EMP VALUES(7369,'SMITH','CLERK',7902,str_to_date('17-12-1980','%d-%m-%Y'),800,null,20);insert into EMP VALUES(7499,'ALLEN','SALESMAN',7698,str_to_date('20-2-1981','%d-%m-%Y'),1600,300,30);insert into EMP VALUES(7521,'WARD','SALESMAN',7698,str_to_date('22-2-1981','%d-%m-%Y'),1250,500,30);insert into EMP VALUES(7566,'JONES','MANAGER',7839,str_to_date('2-4-1981','%d-%m-%Y'),2975,NULL,20);insert into EMP VALUES(7654,'MARTIN','SALESMAN',7698,str_to_date('28-9-1981','%d-%m-%Y'),1250,1400,30);insert into EMP VALUES(7698,'BLAKE','MANAGER',7839,str_to_date('1-5-1981','%d-%m-%Y'),2850,NULL,30);insert into EMP VALUES(7782,'CLARK','MANAGER',7839,str_to_date('9-6-1981','%d-%m-%Y'),2450,NULL,10);insert into EMP VALUES(7839,'KING','PRESIDENT',NULL,str_to_date('17-11-1981','%d-%m-%Y'),5000,NULL,10);insert into EMP VALUES(7844,'TURNER','SALESMAN',7698,str_to_date('8-9-1981','%d-%m-%Y'),1500,0,30);insert into EMP VALUES(7900,'JAMES','CLERK',7698,str_to_date('3-12-1981','%d-%m-%Y'),950,NULL,30);insert into EMP VALUES(7902,'FORD','ANALYST',7566,str_to_date('3-12-1981','%d-%m-%Y'),3000,NULL,20);insert into EMP VALUES(7934,'MILLER','CLERK',7782,str_to_date('23-1-1982','%d-%m-%Y'),1300,NULL,10);commit; group by 分组查询 通常和聚合函数结合使用通常查询每个部门(性别/分类) 就以部门(性别/分类)为分组条件group by语句的位置可以对多个字段进行分组格式:select 字段 from 表名 where 条件 group by 分组字段 having 聚合函数条件 order by 字段 limit n,m 分页 查询emp表中每个部门的编号(deptno)，人数，工资总和 最后根据人数进行升序排序，如果人数一致，根据工资总和降序排列 select deptno,count(*) c,sum(sal) s from emp group by deptno order by c asc,s desc; 查询工资平均在1000-3000之间的员工信息，每个部门的编号，平均工资，最低工资，最高工资，根据平均工资进行升序排列 select deptno,avg(sal) a,min(sal),max(sal) from emp where sal between 1000 and 3000 group by deptno order by a; 查询含有上级领导的员工，每个职业的人数，工资的总和，平均工资，最低工资，最后根据人数进行降序排列，如果人数一致，根据平均工资进行升序排列 select count(*) c,sum(sal),avg(sal) a,min(sal) from emp where mgr is not null group by job order by c desc,a asc; 每个部门中，每个主管的手下人数（两个分组，使用逗号即可） select deptno,mgr ,count(*)from emp where mgr is not null group by deptno,mgr; 每种工作的平均工资 select job,avg(sal) from emp group by job; 每年的入职人数 其中hiredate的格式是2015-01-02(%Y-%m-%d),因此这里需要用到日期截取的函数extract()，具体使用参看SQL操作三 select extract(year from hiredate) year,count(*) from emp group by y; having子句 聚合函数不可以对where结合使用 select deptno,avg(sal) a from emp where a&gt;2000 group by deptno; 这句话是错误的，因为avg(sal)是聚合函数，不能和where结合使用 having中也是可以使用普通字段的过滤，不一定是聚合函数，但是聚合函数的过滤只能使用having，但是建议写在where条件语句中 对聚合函数的结构进行条件过滤要使用having having语句要写在group by 后面 select from where group by having order by limit 查询每个部门中平均工资，只显示平均工资大于2000的 select deptno,avg(sal) a from emp group by deptno having a&gt;2000; 查询所有分类商品所对应的库存总量中，高于1000的总量 这个就是查询每一种商品的库存(group by ) ，库存高于1000(having) select category_id, sum(num) sum from t_item group by category_id having sum&gt;1000; 查询所有分类商品所对应的平均单价中，低于1000的均价 select category_id, avg(price) avg from t_item group by category_id having avg&lt;100; 查询编号238和编号917分类商品的平均单价 这里没有查询编号就是category_id的值，没有涉及到聚合函数，因此可以使用where条件进行过滤 &gt; select category_id, avg(price) avg from t_item where category_id in(238,917) group by category_id ; 虽然没有涉及到聚合函数，但是我们也是可以使用having子句进行过滤（不建议） select category_id, avg(price) avg from t_item group by category_id having category_id in(238,917); 查询emp中，每个部门的平均工资高于2000的部门的编号，部门的人数，平均人数，平均工资，最后根据平均工资进行升序排列 select avg(sal) avg,deptno,count(*) from emp group by deptno having avg&gt;2000 order by avg; 查询emp表中名字中不是以k开头的信息，每个部门的最低工资高于1000的部门的编号，工资总和，平均工资以及最低工资，最后根据平均工资进行升序排列 select deptno,sum(sal) sum,avg(sal) avg,min(sal) min from emp where ename not like &#39;k%&#39; group by deptno having min&gt;1000 order by avg; 查询emp表中部门编号是10,30号部门的员工，每个职业的最高工资低于5000的职业的名称，人数，平均工资，最高工资，最后根据人数进行升序排列，如果人数一致，根据最高工资进行降序排列 select max(sal) max,job,avg(sal) avg,count(*) c from emp where deptno in(10,30) group by job having avg&lt;5000 order by c asc,max desc; 查询emp表中，每个部门的编号，人数，工资总和，最高工资以及最低工资，过滤掉最高工资是5000的部门，根据部门的人数进行升序排列，如果人数一致，则根据最高工资进行降序排列。 select deptno,count(*) c,sum(sal) sum,max(sal) max,min(sal) min from emp group by deptno having max !=5000 order by c asc,max desc; 查询emp表中工资在1000~3000之间的员工信息，每个部门的编号，工资总和，平均工资，过滤掉平均工资低于2000的部门，按照平均工资进行升序排列 select deptno,sum(sal) sum,avg(sal) avg from emp where sal between 1000 and 3000 group by deptno having avg &gt;=2000 order by avg; 查询emp表中名字不是以‘S’开头，每个职位的名字，人数，工资总和，最高工资，过滤掉工资是3000的职位，根据人数进行升序排列，如果人数一致，根据工资总和进行降序排列。 select job,count(*) c,sum(sal) sum,max(sal) max from emp where ename not like &#39;s%&#39;and sal !=3000 group by job order by c asc,sum desc; 查询emp表的信息，每个职位的名称，人数，平均工资，最低工资，过滤掉平均工资是3000的职位信息，根据人数进行降序排列，如果人数一致，根据平均工资进行升序排列 select job,count(*) c,avg(sal) avg,min(sal) min from emp group by job having avg !=3000 order by c desc,avg asc; 子查询Mysql子查询 子查询 ： 嵌套到sql语句里面的查询sql语句称为”子查询” 子查询中返回的字段一定要和查询的判断条件字段类型一致，否则没有意义，比如 ： 这里的最高员工工资，那么子查询返回的一定是一个字段并且这个字段是最高的工资。当然子查询中也是可以返回多个值，那么此时需要使用in关键字判断 如果子查询中返回的是一个值，比如最大工资，那么我们可以使用 = &gt; &lt; !=如果子查询中返回的是一组值，那么我们就不能使用 = 或者 != 我们可以使用in关键字 查询工资最高的员工的所有信息 子查询中返回的是最高工资 select * from emp where sal=(select max(sal) from emp); 工资多于平均工资的员工信息 子查询中返回的是平均工资 select * from emp where sal &gt; (select avg(sal) from emp); 最后入职的员工信息 子查询中返回的是最后入职的日期 select * from emp where hiredate=(select max(hiredate) from emp); 查询出有商品的分类信息 子查询中返回的是t_item中不重复的category_id的值，这个就是在t_item_category中的id，因此我们只需要将t_item_category中的id值在t_item中的信息查询出来即可、 由于子查询中可能返回的不是一个值，而是一组值，因此使用in select * from t_item_category where id in(select category_id from t_item where category_id is not null); 查询工资高于20号部门最高工资的员工的所有信息 select * from emp where sal&gt;(select max(sal) from emp where deptno=20); 查询emp表中姓名是‘KING’所属的部门的编号，名称 emp表中存放的是员工信息，dept表中存放的是部门信息，emp表中的deptno对应的dept表中的deptno(相当于外键) 子查询是返回的emp表中ename为king的部门编号 select deptno,dname from dept where deptno = (select distinct deptno from emp where ename=&#39;king&#39;); 查询部门名称是SALES的部门下所有员工的编号，姓名，职位，以及所属部门的编号 emp和dept表是以deptno关联的 select empno,ename,job,deptno from emp where deptno=(select deptno from dept where dname=&quot;sales&quot;); 查询部门地址是DALLAS的部门下所有员工的所有信息 仍然是emp和dept的查询 select * from emp where deptno in (select deptno from dept where loc=&#39;dallas&#39;); 查询跟JONES同样工作的员工的所有信息（包含JONES） select * from emp where job=(select job from emp where ename=&#39;jones&#39;); 查询跟JONES同样工作的员工的所有信息（不包含JONES） where句中可以包含子查询，也可以包含其他的条件，使用and或者or select * from emp where job=(select job from emp where ename=&#39;jones&#39;) and ename!=&#39;jones&#39;; 查询部门平均工资最高的部门详情 复杂写法： (select * from t) new 这个可以当做一个新表进行查询，也是一种嵌套查询123456select * from dept where deptno in (select deptno from (select max(a),deptno from (select avg(sal) a,deptno from emp group by deptno)new)n);``` - 简单写法 - 查询每个部门的deptno，然后对平均工资进行降序排序，之后取其中的第一条数据，那么就是平均工资最大的。```sql select * from dept where deptno=(select deptno from emp group by deptno order by avg(sal) desc limit 0,1); 查询所有分类产品商品库存总量最大的分类详情 简单写法1select * from t_item_category where id =(select category_id from t_item group by category_id order by sum(num) desc limit 0,1); 总结 子查询可以写在where后面作为查询条件 可以写在from后面作为一张新表，作为新表时必须起别名 select * from (select * from t_item where title like &#39;%广博%&#39; limit 0,10) newtable; 上面的select子句中返回的字段就是新表newtable的字段 可以把子查询写在创建表的时候、 select table t_item_new as (select title,price from t_item from t_item where price&gt;1000) 子查询可以嵌套n层 关联查询 同时查询多张表信息中的字段同时查询多张表的字段的时候，一定要指定关联关系，否则就会出现笛卡尔积的错误，比如外键关联，emp和dept表中的deptno是对应字段的关系（相当于外键） 查看每个员工的名字以及所在部门的名字 select ename,dname from emp,dept where emp.deptno=dept.deptno; 查询在new york 工作的员工 select ename from emp,dept where dept.loc=&#39;new york&#39; and emp.deptno=dept.deptno; 查看工资高于3000的员工，名字，工资，部门名，所在地 这里的关联关系依然是两张表中都有deptno字段 select ename,sal,dname,loc from emp,dept where emp.deptno=dept.deptno and sal&gt;3000; 笛卡尔积 笛卡尔积通常是一种错误的查询结果笛卡尔积是在不谢关联关系的情况下，查询出来的两张表的乘积 查看每个员工的名字以及所在部门的名字 select ename,dname from emp,dept where emp.deptno=dept.deptno; 上面的sql语句如果没写where中的子句，那么就会出现笛卡尔积的错误，因为没有设置关联关系 等值连接/内连接等值连接 select * from A,B where A.x=B.x and age&gt;18; 内连接 select * from A [inner] join B on A.x=B.x where age&gt;18; 查询在new york 工作的员工 select * from emp e join dept d on e.deptno=d.deptno where d.loc=&#39;new york&#39;; 查看工资高于3000的员工，名字，工资，部门名，所在地 select ename ,sal,dname,loc from emp e join dept d on e.deptno=d.deptno where sal&gt;3000; 总结 等值连接和内连接只能查询有关联关系的数据，如果其中的数据没有关联关系，那么没有关联关系的数据查询不出来 左外连接 两张表中其中有数据没有关联关系，那么使用等值连接和内连接就查询不出来，因此需要使用左外连接查询结构以左边的表为主，内容全部显示，左边的只是显示有关系的 select * from emp e left join dept d on e.deptno=d.deptno; 右外连接 两张表中其中有数据没有关联关系，那么使用等值连接和内连接就查询不出来，因此需要使用左外连接查询结构以右边的表为主，内容全部显示，左边的只是显示有关系的 select * from emp e right join dept d on e.deptno=d.deptno; 案例 查询出所有可以匹配的商品分类及商品数据 select c.name , t.* from t_item t,t_item_category c where t.category_id=c.id; 等值连接 select t.* ,c.name from t_item t join t_item_category c on t.category_id = c.id; 内连接 查询出所有的分类,以及与之匹配的商品 这里侧重于查询分类，如果某一个分类中没有商品，那么使用等值连接和内连接就会导致查询不到所有的分类，因此这里可以使用左外连接或者右外连接，以分类所在的表(t_item_category)为主 select c.name,t.* from t_item_category c left join t_item t on t.category_id=c.id; 左外连接 select c.name,t.* from t_item t right join t_item_category c on t.category_id=c.id; 右外连接 查询出所有的商品,以及与之匹配的分类 这里侧重于所有的商品，如果其中某一件商品与分类没有关联关系，即是没有指定分类，那么我们使用等值连接或者内连接就会查询不到这件商品，我们可以使用左外连接或者右外连接 商品类(t_item) 分类（t_item_category） select t.title,c.name from t_item t left join t_item_category c on c.id=t.category_id; 左外连接 select t.title,c.name from t_item_category c right join t_item t on c.id=t.category_id; 右外连接 每个部门的人数,根据人数排序 select deptno count(*) c from emp group by deptno order by c; 每个部门中，每个主管的手下人数 select deptno,mgr,count(*) from emp group by deptno,mgr; 每种工作的平均工资 select job,avg(sal) avg from emp group by job; 每年的入职人数 select extract(year from hiredate) year, count(*) from emp group by year; 少于等于3个人的部门 select deptno, count(*) c from emp group by deptno having c&lt;=3; 拿最低工资的员工信息 select * from emp having sal=min(sal); (不推荐) select * from emp having sal=(select min(sal) from emp); 只有一个下属的主管信息 select e.* from emp e join (select count(*) c ,mgr from emp group by mgr having c=1)newtable on newtable.mgr=e.empno; 平均工资最高的部门编号 select deptno from emp group by deptno order by avg(sal) desc limit 0,1 下属人数最多的人，查询其个人信息 先分组查询出所有的主管的信息，然后根据人数降序排列，最后取出第一条就是数据就是下属人数最多的主管 select * from emp group by mgr order by count(*) desc limit 0,1; 拿最低工资的人的信息 select * from emp where sal=(select min(sal) from emp); 最后入职的员工信息 select * from emp where hiredate=(select max(hiredate) from emp); 工资多于平均工资的员工信息 select * from emp where sal&gt;(select avg(sal) from emp); 查询员工信息，部门名称 select e.*,d.dname from emp e join dept d on e.deptno=d.deptno; 员工信息，部门名称，所在城市 select e.*,d.dname,d.loc from emp e join dept d on e.deptno=d.deptno; DALLAS 市所有的员工信息 select e.* from emp e join dept d on e.deptno=d.deptno where d.loc=&#39;DALLAS&#39;; 按城市分组，计算每个城市的员工数量 select loc ,count(*) from (select e.*,d.dname,d.loc from emp e join dept d on e.deptno=d.deptno) newtable group by newtable.loc; select d.loc,count(*) from emp e join dept d on e.deptno=d.deptno group by loc; 查询员工信息和他的主管姓名 员工信息和主管姓名在同一张表中，我们可以抽离出主管编号mgr和ename组成一张新表，那么我们就可以使用关联查询了 select e.*,n.ename &#39;主管名字&#39; from emp e join (select mgr,ename from emp) n on e.empno=n.mgr; 或者我们可以不抽离字段，而是直接整个当做一张新表 select e.*,n.ename mgrname from emp e join emp n on e.empno=n.mgr; 员工信息，员工主管名字，部门名 直接join（可以连接多张表）,直接在后面join即可 select e.*,n.ename mgrname,dname from emp e join emp n on e.empno=n.mgr join dept d on e.deptno=d.deptno; 把上面的查询结果当成一张新表，和dept内连接即可 select new.*,d.dname from (select e.*,n.ename mgrname from emp e join emp n on e.empno=n.mgr) new join dept d on new.deptno=d.deptno; 总结 如果涉及到两张表，甚至多张表，想要查询某张表的所有信息，此时就需要使用左/右外连接，因为如果某条数据没有关联关系，那么使用等值连接或者内连接将会缺失没有关联关系的数据。 如果涉及到多张表的时候，使用内连接可以连接多张表，直接在后面添加join即可，比如 select e.*,n.ename mgrname,dname from emp e join emp n on e.empno=n.mgr join dept d on e.deptno=d.deptno; 分组(group by)是对前面查询到的结果进行分组，因此在where条件语句后，也是在内连接之后，因为必须查询到完整的一张表才能进行分组 推荐使用内连接，不使用等值连接 使用内连接的时候，where条件语句一定要放在 on的后面，即使是多个内连接(多个join)，也必须放在最后一个join的on的后面，不影响结果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL操作三]]></title>
      <url>%2F2018%2F03%2F24%2FSQL%E6%93%8D%E4%BD%9C%E4%B8%89%2F</url>
      <content type="text"><![CDATA[Day03查询null 查询列值为null (is null) select * from emp where mgr is null; 查询上级领导为空的员工 查询列值不为null (is not null) select * from emp where mgr is not null and comm&gt;0; 别名 如果表中的字段名称太长或者不是很容易直接看懂，那么我们可以使用别名，使用的方式有三种： select ename &quot;姓名&quot; from emp; select ename as &quot;姓名&quot; from emp; select ename 姓名 from emp; 去除重复的值(distinct) select distinct job from emp; where 条件语句支持的运算符： &gt; &lt; = != &gt;= &lt;= !=(&lt;&gt;) and 和 or and 并且 多个条件属于与的关系or 或者 select * from user where id=1 or id=2; 查询id=1的数据或者id=2的数据 ,如果这两个都存在，那么将会全部返回 like _ 代表单个未知字符 第二个字母为a : _a% 倒数第三个字母为a ：%a__ % 代表多个未知字符 以a开头的 : a% 以a结尾的 ：%a 包含a :%a% select * from user where name like &#39;_加%&#39;; select * from user where name like &#39;_加_&#39;; 此时匹配的名字是三个字符，比如 陈加兵 not like (不包含) select * from user where name not like &#39;_加%&#39;; between … and (在..之间) 在两个数之间select * from t_item where price between 10 and 100; 查询价格在10 到 100之间的数据 in (查询的值为多个) 查询某个字段的值为多个值的时候使用inselect * from t_item where price in(100,200,233); order by 升序（默认 asc） -select price from t_item order by price order by 写在后面，如果有where条件，那么要写在where条件的后面 select price from t_item where price&lt;100 order by price; 降序（desc） select price from t_item order by price desc 如果需要多个字段进行排序，则在by的后面写多个字段 select category_id,price from t_item order by category_id,price desc; 按照分类id升序，价格降序 查询带燃字的商品，按照价格降序排列 select title,price from t_item where title like &quot;%燃%&quot; order by price; 分页 limit 子句 limit n,m ： n表示跳过的条数，m表示每页显示的条数 写在排序（order by 字句）的后面，如果没有排序写在where后面 limit 0,5 查询第一页，每页显示5条 limit 10,5 查询第三页，每页显示5条 limit 12,3 查询第五页 每页3条 select price from t_item order by price limit 10,10; 按照价格升序排列，显示第二页，每页10条 select price from t_item where price &lt;100 limit 0,10; 查询价格小于100的记录，显示第一页，每页10条 concat() 函数 concat()函数可以实现多个字符串的拼接 在终端直接输入 select concat(&#39;a&#39;,&#39;b&#39;); select concat(price,&quot;元&quot;) from t_item limit 0,3; 查询商品，并且将查询到的价格和元这个单位拼接。相当于显示的是价格只是每个价格后面添加了单位 比如： 23元 将标题和单价拼到一起进行展现 select concat(price,&quot;元&quot;,title) from t_item limit 0,5; 数值运算 支持加减乘除，取余(%)等效mod(n,m) 查询商品并在结果中显示商品的总价值 select price,num ,price*num &#39;总价&#39; from t_item; 直接做运算即可，可以使用别名解释字段的含义 日期相关函数 获取当前时间+时间 now() 在终端输入select now(); 获取当前日期 curdate() 获取当前时间 curtime() 测试 select now(),curdate(),curtime(); 从日期和时间中获取日期 date(now()) 从日期和时间中获取时间 time(now()) extract() 提取年月日时分秒的函数 select extract(year from now()); select extract(month from now()); select extract(day from now()); select extract(hour from now()); select extract(minute from now()); select extract(second from now()); DATE_FORMATE() 函数 日期格式化 format %Y 4位年 2018 %y 2位 18 %m 月 05 %c 月 5 %d 日 %H 24小时制 %i 分 %s 秒 测试 select date_format(now(),&#39;%Y年%m月%d日 %h时%i分%s秒&#39;); 输出 2018年03月23日 03时44分51秒 查询商品 并显示商品上传日期 select title,date_format(created_time,&#39;%Y年%m月%d日 %h时%i分%s秒&#39;) from t_item; str_to_date 把字符串转成日期格式 将’2018年10月22日’ 转换成日期 select str_to_date(&quot;2018年10月23日&quot;,&#39;%Y年%m月%d日&#39;); 第一个参数是即将要转换的字符串日期，第二个参数是这个字符串日期的格式，用来解析这个字符串。 输出： 2018-10-23 IFNULL() 函数 age=ifnull(a,b) 如果a是null，age=b，如果不是null，age=a; 把奖金是null 设置成0 update emp set comm=ifnull(comm,0); 如果奖金comm是null，那么comm=0，如果不是空 comm=comm，还是原来的值 聚合函数 对多行数据进行合并统计 sum() 求和 select sum(num) from t_item where price&lt;100; avg() ： 求平均值 select avg(price) from t_item; count() 计算数量 select count(*) from t_item where price&lt;100; max() 最大值 select max(price) from t_item; min() 最小值 select min(price) from t_item; 测试 查询DELL的平均单价 select avg(price) &quot;平均单价&quot; from t_item where title like &quot;%DELL%&quot;; 字符串的函数 char_length(str) instr(str,substr) locate(substr,str) insert(str,start,end,newStr) lower(str) upper(str) left(str,count) right(str,count) trim(str) substring(str,index) substring(str,index,length); repeat(str,count) replace(str,old,new) reverse() 数学相关函数 floor(num) round(num) round(num,m) truncate(num,m)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL操作二]]></title>
      <url>%2F2018%2F03%2F22%2FSQL%E6%93%8D%E4%BD%9C%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[Day02乱码问题 1.数据库字符集 要设置成utf8 表的字符集 设置为utf8 windows系统的命令行里，有些版本是gbk的编码格式，可以通过set names gbk；的方式把mysql接收到数据是的解码格式设置为gbk，这个位置的gbk和数据库还有表的utf8没有关系 在windows系统中修改mysql默认的数据库编码，找到安装文件中的my.ini的配置文件 在里面添加时如下代码：character-set-server=utf8 eclipse 下写sql配置 下载mysql驱动jar包 window -&gt; show view -&gt; other -&gt; Data Management -&gt; Data source(open) / SQL Results(open) 找到控制台的Data source explor中，然后点击DataBaseConnetctions -&gt; new 选择Mysql 点击下拉箭头右面的加号 选择5.1 点击jarList clearAll 点击add jar 在弹出窗口中找到下载的jar文件 然后ok8.修改URL 只需要修改最后面的database即可，这个是选择需要操作的数据库 输入密码，save password 点击test connection 如果显示ping Successd则点击finish 在 Database Connections下的New MySQL 右键 选择 type中选择mysql5.1 Name中选Neq Mysql Database中选择database 在最右侧如果显示connected，那么可以开始写sql语句 自定义代码块 点击windows -&gt; 搜索 templates -&gt; 选择SQL下editor下的templates -&gt; New（新建） 约束主键(primary key) 主键特点 ： 非空 唯一CREATE TABLE user(id int PRIMARY KEY,age int); 自增(auto_increment) 一般和主键一起使用create table t5(id int primary key auto_increment,name varchar(10));如果设置了自增长，那么在插入数据的时候主键可以不设置值。也可以赋值为null，数据库会自动为这个主键赋值(在原来的基础上自增+1) 非空(not null) create table user(id int primary key,age int not null); 注释 直接使用comment来添加字段注释即可create table t6(id int comment &#39;用户的id&#39;,age int comment &#39;用户的年龄&#39;); 事务 数据库中sql语句执行的最小单元 不能分割执行事务内的sql语句，只能是同时执行成功，或者同时执行失败，否则可能出现安全性问题 一个事务中的代码块包含多条sql语句，只有一起执行成功才能成功，只要有一条出现错误都会失败,因为开启事务的话，每操作的一条语句产生的结果都是存储在内存中的，没有及时更新到数据库中，只有提交之后才能更新到数据库中 关闭自动提交 mysql的自动提交属性自动是开启的，就是每执行一次sql语句就会自动提交，如果需要使用事务功能，那么需要将其关闭，因为一旦提交了，数据就会发生改变，但是事务的功能就是当所有的sql语句都执行完才提交，因此要将其关闭。 显示自动提交的状态 show variables like &#39;%autocommit%&#39;; 显示为on表示开启的 关闭自动提交 set autocommit=0; 此时再次查询状态就会显示OFF 再次开启自动提交 set autocommit=1 开启自动提交，此时查看就实现为on 验证 创建表，插入数据 123CREATE TABLE USR(id int primary key auto_increment,name varchar(10),money int);INSERT INTO user values(NULL,'超人',200),(NULL,'蝙蝠侠',205); 关闭自动提交 让超人的钱+100 update user set money=300 where id=1 打开另外一个窗口登录mysql，可以查看此时的超人看看钱是不是300，我们可以看到此时的数据并没有改变，因为我们关闭了自动提交，如果我们此时在原来窗口输入 commit;,那么在看看另外的登录窗口就会发现数据改变了。 回滚(rollback) 当你之前的操作没有提交的话，那么你使用rollback这个命令，那么就会回滚到初始状态 回滚点(savepoint) 前提是没有设置了自动提交，才能回滚到保存点savepint s1(标识); ： 设置保存点回滚到保存点，那么保存点之前的操作都是存在的，一旦提交之后就会执行保存点之前的操作。 rollback to s1; 总结 当将自动提交设置为关闭状态，当改变数据库的内容时，只要手动提交输入 commit;，才能更新到数据库中，否则就只是在内存中改变了。 begin 起始点 savepoint s(标识) 设置回滚点 commit 提交 rollback 回滚 rollback to … 回滚到指定的回滚点 SQL分类数据库定义语言 DDL Data Definition Language 数据库定义语言 常见命令： create drop alter truncate 这些命令不支持事务，就是没有提交也会生效 数据操纵语言 DML Data Manipulation Language :数据操作语言 常见命令： insert update delete select 支持事务，可以回滚，不提交将不会生效 数据查询语言 DQL Data Query Language : 数据查询语言 常见命令： select（也属于DML） TCL Transaction Control Language ： 事务控制语言 常见命令： begin commit rollback savepoint DCL Data Control Language : 数据控制语言 给用户分配权限相关的sql语言 数据类型 整数 int 4字节 bigint 8字节 浮点数 double(m,d): m代表数据的总长度，d表示小数点后面的位数 decimal(m,d): m代表数据的总长度，d表示小数点后面的位数 double精度比float高，decimal精度比double高 字符串类型 char(n) : 固定长度，即是存了abc也是占满了n长度 执行效率高 总长255 varchar(n) : 可变长度 存abc 占3个长度 节省空间 最大长度65535，但是超过255建议使用text text(n) : 可变长度 最大65535 日期类型 date : 只能存储年月日 time ： 只能存储时分秒 datetime ： 年月日时分秒 默认值为null 最大值9999-12-31 timestamp ： 年月日时分秒 默认值是当前时间 最大值2038-01-19 创建表插入数据：123create table p(d1 date, d2 time,d3 datetime,d4 timestamp); insert into p values('2018-03-08',null,null.null); insert into p values('2018-03-08','12:06:03',null,null);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL操作一]]></title>
      <url>%2F2018%2F03%2F21%2FSQL%E6%93%8D%E4%BD%9C%E4%B8%80%2F</url>
      <content type="text"><![CDATA[Day01-基本的语句数据库简介 因为传统的文本形式存储数据存在很多的弊端： 执行效率低 占用内存 什么是DB Database ： 数据库数据库本质是文件集（多个文件）会按照特定存储规范进行数据增删改查 什么是DBMS DateBaseManagementSystem : 数据库管理系统，本质就是管理数据库文件的软件 Oracle Mysql DB2 Sqlite SqlServer 数据库分类 关系型数据库 是经过数学理论验证过，可以保存现实生活中任何关系的数据库（其中的高级映射，比如一对多，多对一，一对一都是关系） 关系数据库是以表为单位进行存储的 Oracle mysql DB2 sqlite sqlserver都是关系型数据库 非关系型数据库 Redis数据库是非关系型数据库 以key-value形式进行存储 主流关系型数据库介绍 Mysql ： 开源 卖服务赚钱 被sun公司收购 sun被oracle收购 5.5版本因为oracle技术大牛对其进行升级，性能大幅提升，Mysql 从6.0开始收费，导致原来的mysql工程师跳槽创建了MariaDB,MariaDB内部实际上就是mysql，创建者的女儿叫Maria Oracle 闭源 卖产品 支持windows，Linux DB2 闭源 大型数据库 通常是国字头的企业在用 sqlite 轻量级数据库，大小几十k，应用于移动或者嵌入式设备 SQLServer 微软公司 闭源 主要.net开发的网站中 mysql安装 端口号3306编码格式 utf8 数据库相关SQL什么是SQL Strctured Query Language ： 结构化查询语言通过sql语言和DBMS（数据库管理软件）进行交互 连接数据库 终端中输入： mysql -u root -p输入密码即可,没有密码直接回车即可 数据库操作 create database d_name ; 创建数据库d_namedrop database d_name; 删除数据库d_nameshow databases; 显示所有的数据库show create database d_name; 查看单个数据库use d_name; 使用当前的数据库d_namecreate database db_name character set utf8;创建数据库指定字符集 表相关SQL什么是表 表是数据库中存放数据的单元，任何数据都是存放到表中类似java中的Class，表中的字段对应class的属性 数据库表的引擎 innoDB : 支持数据库的高级操作，包括事务 主键 外键等myisam : 只具备基本的数据库储功能 创建表时指定引擎和字符集 格式 ：create table t_name(字段名 字段类型,....) engine=myisam charset=utf8; 创建表 格式: create table 表名(字段名 类型,字段名 类型,......);例子： create table name(id int,name char(10),age int);执行原理： 当在中断输入建表语句 终端会把写好的sql发送给DBMS，然后解析到create table时，识别出要创建一个表。 查询所有表 show tables ; 查询单个表 show create table tale_name;使用上面的语句会出现创建表的语句和字符编码 查看表的字段属性 desc table_name ; 修改表修改表的名称 格式 : rename table 原名 to 新名rename table user to t_user; 修改表的属性（引擎和字符集） 格式 ：alter table 表名 engine-innoDB charset=utf8;alter table t engine=InnoDB charset=GBK; 添加表字段 在最后添加 格式 ： alter table 表名 add 字段名 字段类型;alter table t add age int; 在最前添加 格式： alter table 表名 add 字段名 字段类型 first;alter table t add newage int first; 在某个字段后面添加 格式： alter table 表名 add 字段名 字段类型 after 字段名;alter table t add birthday varchar(10) after id; 修改字段名和类型 alter table 表名 change 原字段名 新字段名 新的字段类型 ;alter table t change birthday bth Date; 修改字段类型和位置 alter table 表名 modify 字段名 类型 位置（first/after 字段名）;alter table t modify name int after age; 将name移到age的后面，并且修改了name字段的类型为int alter table t modify name varchar(10) first; 将字段name移到最前面 删除字段 alter table 表名 drop 字段名;alter table t drop bth; 将t表中的bth字段删除 删除表 格式 ： drop table 表名 ; 数据相关的SQL(CRUD)插入语句 全表插入 格式 insert into 表名 values(value1,value2,…)格式要求: values里面的值的数量和顺序必须要和表的字段一致insert into user values(1,&#39;jack&#39;,22); 指定字段插入 格式： insert into 表名(字段1,字段2,..) values(value1，value2,….)insert into user(id,name,age) values(1,&#39;jack&#39;,22);格式要求： values中的值必须和前面格式的字段一致。 插入多组数据 格式： insert into values(第一组数据),(第二组数据)….insert into user values(1,&quot;孙悟空&quot;,22),(2,&quot;唐僧&quot;,44); 指定字段插入多组数据 insert into user(age) values(22),(33); 查询语句 查询所有字段 格式：select * from 表名select * from user; 查询指定字段 格式：select 字段1,字段2 from 表名select name.age from user; 更新语句 更新表中所有的字段 格式： update 表名 set 字段名 = 新的值;update user set age=22; 改变指定条件的字段 格式： update 表名 set 字段名 = 新的值 where 条件;update user set age=22 where id=1; 修改id=1的那一行数据的age 删除语句 指定条件删除 格式： delete from 表名 where 条件 ;delet from user where id=2; 删除id=2的那一行数据 不指定条件删除，那么将会删除整张表数据 delete from user; TRUNCATE语句 trucate table 表名; 先删除表，然后再创建一样的空表（表的名字相同，字段不变，主要的功能就是清空表中的数据）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Excel表格的写入读取]]></title>
      <url>%2F2017%2F09%2F27%2FExcel%E8%A1%A8%E6%A0%BC%E7%9A%84%E5%86%99%E5%85%A5%E8%AF%BB%E5%8F%96%2F</url>
      <content type="text"><![CDATA[Excel的读取和写入准备 首先需要导入jar包，请点击这里下载 简介 我们知道Excel表格在2007之后就不一样了，后缀名变为xlsx，之前的后缀名为xls,因此读取和写入的操作就对应着不同的方式，但是只是读取和写入的类不同了，思想还是一样的。 我们要知道一个Excel文件(工作簿)包含三部分，分别是工作表(sheet),行(row),列(cell) 工作簿 工作簿对应的类是 XSSFWorkbook(2007之后),在2007之前对应的类是HSSFWorkbook 构造方法 new XSSFWorkbook() 创建一个工作簿用于写入文件 new XSSFWorkbook(java.io.InputStream inputstream) 创建一个工作簿，用于读取文件 常用的方法 XSSFFont createFont() 返回一个XSSFont类的对象，主要用于设置字体用的 XSSFSheet createSheet() 创建一个工作表 XSSFSheet createSheet(String name) 创建一个工作表并且指定姓名 XSSFCellStyle createCellStyle() 创建一个单元格风格类的一个对象，便于设置单元格的属性 write(OutputStream out) 用于将文件写入到文件中 close() setSheetName(int sheetIx,String name) 为指定索引的工作表设置名称 XSSFSheet getSheetAt(int index) 获取指定索引的工作表对象，这个是用来读取文件的时候用的 例子读取文件的例子12345 File file = new File("F:\\demo1.xlsx");//创建输入流FileInputStream inputStream = new FileInputStream(file);//创建工作簿读取XSSFWorkbook workbook = new XSSFWorkbook(inputStream); 写入文件的例子12345678910XSSFWorkbook book=new XSSFWorkbook(); //创建工作簿.....省略写入的内容FileOutputStream out=new FileOutputStream("D:\\demo1.xlsx"); //创建输出流book.write(out); //写入到指定的文件book.close(); // 关闭out.close(); 工作表(sheet) 工作表对应的类为XSSFSheet,2007之前对应的是HSSFSheet一般工作表都是在工作簿基础上创建的，因此构造函数也用不到，所以这里就不多说了 常用方法 int addMergedRegion(CellRangeAddress region) 合并单元格 XSSFRow createRow(int rownum) 创建一个行 rownum表示创建第几行，这是一个行的索引(0开始) 便于写入 XSSFRow getRow(int index) 获取指定索引的那一行，便于读取 int getLastRowNum() 获取文件中最后一行的索引，这个通常在读取的时候用到 int getFirsetRowNum() 获取文件第一行的索引 例子合并单元格1234567// 创建工作簿对象 XSSFWorkbook workbook = new HSSFWorkbook(); XSSFSheet sheet = workbook.createSheet("第一张表"); //创建工作表对象 //合并单元格 CellRangeAddress cell=new CellRangeAddress(int firstRow, int lastRow, int firstCol, int lastCol) //这里表示合并第一行的1-10列 sheet.addMergedRegion(new CellRangeAddress(0, 0, 0, 10)); 创建一行123XSSFWorkbook workbook = new HSSFWorkbook();XSSFSheet sheet = workbook.createSheet("第一张表"); //创建工作表对象XSSFRow row=sheet.createRow(0); //创建第一行 行 行对应的类为XSFFRow,2007之前对应的是HSSFRow 常用的方法 XSSFCell createCell(int columnIndex) 创建一列 columnIndex表示列的索引(0开始) short getFirstCellNum() 返回文件中第一个列的索引，便于以后读取 short getLastCellNum() 返回全部的列数(不是索引)，这个和Sheet中getRowNum()方法不同，便于以后读取文件 XSSFCell getCell(int cellnum) 获取指定索引的那一列，便于以后的读取 XSSCellStyle getCellStyle() 获取单元格风格的对象 void setCellStyle(XSSFCellStyle style) 将设置的风格样式添加到单元格中，否则将不会起作用 列 列对应的类为XSSFCell,2007之前对应的是HSSFCell 常用的单元格类型 常用的单元格的类型有字符串，数字，布尔值，空值，可以使用XSSFCell的int getCellType() 方法获取类型 CELL_TYPE_BLANK 空值 CELL_TYPE_STRING 字符串 CELL_TYPE_NUMERIC 数字(浮点值，整型) CELL_TYPE_BOOLEAN 布尔值(True,FALSE) 常用的方法 int getCellType()获取单元格类型 可以和常用的单元格类型进行比较，然后使用不同的读取方法读取 XSSFCellStyle getCellStyle() 获取单元格风格对象，便于后面设置单元格的风格 setCellValue(Object value) 设置单元格的内容，可以是任意类型的 java.util.Date getDateCellValue() 读取单元格的日期内容 String getStringCellValue() 读取单元格中的字符串内容 double getNumericCellValue() 读取单元格中的数字类型的内容 boolean getBooleanCellValue() 获取单元格中的布尔类型的内容 设置单元格样式 对应的类为XSSFCellStyle 常用的方法 void setAlignment(HorizontalAlignment align) 设置水平对齐方式 void setVerticalAlignment(VerticalAlignment align) 设置垂直的对齐方式 void setTopBorderColor(XSSFColor color) 设置上边框的颜色(还有Left,right..) void setFont(Font font) 设置字体 这里的Font是org.apache.poi.ss.usermodel.Font void setBorderTop(BorderStyle border) 设置上边框的样式，在BorderStyle类中有很多的样式 void setRotation(short rotation) 设置文字的旋转度数 单元格字体的设置 对应的类为XSSFFont 常用的方法: void setBold(boolean bold) 是否设置加粗 void setItalic(boolean italic) 设置是否倾斜 void setUnderline(FontUnderline underline) 设置下划线 void setStrikeout(boolean strikeout) 设置是否带有删除线 void setColor(XSSFColor color) 设置字体的颜色,只需要调用XSSFColor静态颜色变量即可 void setFontHeight(double height) 设置字体高度 void setFontHeightInPoints(short height) 设置字号 void setFontName(java.lang.String name) 设置字体样式(黑体，楷体…) 写入文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import java.awt.Color;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import org.apache.poi.hssf.util.HSSFColor;import org.apache.poi.ss.usermodel.FontUnderline;import org.apache.poi.ss.usermodel.HorizontalAlignment;import org.apache.poi.ss.usermodel.VerticalAlignment;import org.apache.poi.ss.util.CellRangeAddress;import org.apache.poi.xssf.usermodel.XSSFCell;import org.apache.poi.xssf.usermodel.XSSFCellStyle;import org.apache.poi.xssf.usermodel.XSSFColor;import org.apache.poi.xssf.usermodel.XSSFFont;import org.apache.poi.xssf.usermodel.XSSFRow;import org.apache.poi.xssf.usermodel.XSSFSheet;import org.apache.poi.xssf.usermodel.XSSFWorkbook;public class TestDemo &#123; public static void main(String[] args) throws IOException &#123; XSSFWorkbook workbook = new XSSFWorkbook(); // 创建工作簿 XSSFSheet sheet = workbook.createSheet("第一个工作表"); // 创建一个工作表 XSSFCellStyle style = workbook.createCellStyle(); // 创建单元格风格对象 sheet.addMergedRegion(new CellRangeAddress(0, 0, 0, 10)); // 合并第一行的单元格 style.setAlignment(HorizontalAlignment.CENTER); // 设置水平居中 style.setVerticalAlignment(VerticalAlignment.CENTER); // 设置垂直居中 XSSFFont font = workbook.createFont(); // 创建字体的对象 font.setFontName("黑体"); // 设置字体的样式为黑体 font.setFontHeightInPoints((short) 20); // 设置字体的大小 font.setBold(true); // 设置粗体 font.setItalic(true); // 设置倾斜 font.setColor(HSSFColor.RED.index); // 设置字体的颜色 font.setUnderline(FontUnderline.SINGLE); // 设置下划线 font.setStrikeout(false); // 设置不带下划线 style.setFont(font); // 将设置的字体添加到单元格样式中，显示出来 XSSFRow row1 = sheet.createRow(0); // 创建第一个行 XSSFCell cell1 = row1.createCell(0); // 创建第一行的第一列 cell1.setCellStyle(style); // 将上面定义的风格设置到这个单元格中，这个是必须有的，否则根本不起作用 cell1.setCellValue("员工信息表"); // 设置单元格的内容 // 设置第二行的前三列的值 XSSFRow row2 = sheet.createRow(1); row2.createCell(0).setCellValue("姓名"); row2.createCell(1).setCellValue("性别"); row2.createCell(2).setCellValue("年龄"); // 设置第三行的前三列 XSSFRow row3 = sheet.createRow(2); row3.createCell(0).setCellValue("陈加兵"); row3.createCell(1).setCellValue("男"); row3.createCell(2).setCellValue(22); // 设置数字 // 设置第四行的前三列 XSSFRow row4 = sheet.createRow(3); row4.createCell(0).setCellValue("郑元梅"); row4.createCell(1).setCellValue("女"); row4.createCell(2).setCellValue(22); // 设置数字 // 创建输出流对象 FileOutputStream stream = new FileOutputStream(new File( "F:\\demo2.xlsx")); workbook.write(stream); // 写入文件 workbook.close(); // 关闭 stream.close(); &#125;&#125; 写入文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import org.apache.poi.xssf.usermodel.XSSFCell;import org.apache.poi.xssf.usermodel.XSSFRow;import org.apache.poi.xssf.usermodel.XSSFSheet;import org.apache.poi.xssf.usermodel.XSSFWorkbook;public class TestDemo1 &#123; public static void main(String[] args) throws IOException &#123; File file = new File("F:\\demo2.xlsx"); FileInputStream inputStream = new FileInputStream(file); // 创建输入流 XSSFWorkbook workbook = new XSSFWorkbook(inputStream); // 创建读取工作簿的对象 XSSFSheet sheet = workbook.getSheetAt(0); // 获取第一个工作表的对象 // 第一次循环取得所有的行的对象 getLastRowNum()是得到最后一行的索引 for (int i = 0; i &lt;= sheet.getLastRowNum(); i++) &#123; XSSFRow row = sheet.getRow(i); // 获取每一行的对象 for (int j = 0; j &lt; row.getLastCellNum(); j++) &#123; XSSFCell cell = row.getCell(j); // 获取每一行的每一列 int type = cell.getCellType(); // 获取每一个单元格对应的类型 switch (type) &#123; case XSSFCell.CELL_TYPE_BOOLEAN: //如果是布尔类型 boolean b=cell.getBooleanCellValue(); System.out.print(b + " "); break; case XSSFCell.CELL_TYPE_NUMERIC: //如果是数字类型 double d=cell.getNumericCellValue(); //获取值 System.out.print( d+ " "); break; case XSSFCell.CELL_TYPE_STRING: //如果是字符串类型的 String s=cell.getStringCellValue(); System.out.print( s+ " "); case XSSFCell.CELL_TYPE_BLANK: //如果是空值 System.out.print(" "); default: break; &#125; &#125; System.out.println(); &#125; workbook.close(); //关闭 inputStream.close(); &#125;&#125; 参考文章 POI文档 http://lsieun.blog.51cto.com/9210464/1836601]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JSP总结四(EL表达式)]]></title>
      <url>%2F2017%2F09%2F26%2FJSP%E6%80%BB%E7%BB%93%E5%9B%9B-EL%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[JSP总结四(EL表达式)简介 JSP页面尽量不要使用scriptlet编写java代码，因此我们可以使用EL表达式可以替代Java语句的使用 隐含对象与属性相关的隐含对象 属性的隐含对象有PageScope,requestScope,sessionScope,applicationScope分别对应的是JSP中的PageContext,request,session,application，因此可以取得JSP对象使用setAttribute()设置的属性，如果没有使用EL隐含对象获取属性的值，那么默认是从PageScope开始寻找 1234567891011&lt;% request.setAttribute("login",'true'); //绑定request对象的属性 session.setAttribute("login",'true'); //绑定session对象的属性 application.setAttribute("login","true"); //设置application对象的属性%&gt;&lt;%--获取request绑定的属性值 相当于request.getAttribute("login");--%&gt;&lt;h1&gt;$&#123;requestScope.login&#125;&lt;h1&gt;&lt;%--获取session绑定的属性值--%&gt;&lt;h1&gt;$&#123;sessionScope.login&#125;&lt;h1&gt; 与请求参数相关的隐含对象(param,paramValues) 与请求参数相关的EL隐含对象有param,paramValues。我们可以使用EL表达式可以获取表单提交的请求参数。 下面我们使用表单提交，测试一下 JSP代码(表单提交) 12345678910&lt;form action="demo1.jsp" method="get"&gt; 姓名:&lt;input type="text" name="username"&gt; 密码:&lt;input type="password" name="password"&gt; &lt;input type="submit" value="提交"&gt; 爱好: 打棒球：&lt;input type="checkbox" name="hobbies"&gt; 打羽毛球：&lt;input type="checkbox" name="hobbies"&gt; &lt;/form&gt; demo1.jsp 文件（接收请求参数） 1234567891011121314&lt;%--获取提交的请求参数username，password 相当于使用如下代码: request.getParameter("username"); request.getParameter("password");--%&gt;&lt;h1&gt;$&#123;param.username&#125;&lt;/h1&gt;&lt;h1&gt;$&#123;param.password&#125;&lt;/h1&gt;&lt;%--获取多选框的值 相当于使用下面的代码: request.getParameterValues("hobbies")[0]--%&gt;&lt;h1&gt;$&#123;paramValues.hobbies[0]&#125;&lt;/h1&gt;&lt;h1&gt;$&#123;paramValues.hobbies[1]&#125;&lt;/h1&gt; 与标头(Header)相关的隐含对象 如果想要取得用户请求的表头数据，那么使用header或者headerValues隐含对象。例如使用${header[&quot;User-Agent&quot;]} 这个相当于使用&lt;%=request.getHeader(&quot;User-Agent&quot;)%&gt;。 HeaderValues对象相当于使用request.getHeaders() cookie隐含对象 cookie的隐含对象可以取得用户设置的Cookie设置的值。如果在Cookie中设置了username属性，那么可以使用${cookie.username} 初始参数隐含对象 隐含对象initParam可以用来取得web.xml中设置的ServletContext初始参数，也就是在&lt;context-param&gt;中设置的初始参数。例如${initParam.initcount}的作用，相当于&lt;%=ServletContext.getInitParameter(&quot;initCount&quot;)%&gt; EL运算符 使用EL运算符直接实现一些算术运算符，逻辑运算符，就如同一般常见的程序语言中的运算 算术运算符 可以直接使用加减乘除 ${1+2},${5/2},${5*3} 逻辑运算符 ${true and false}=false,${true and true}=true,${true or false}=true 关系运算符 可以直接在EL表达式比较大小，返回的也是false和true，可以用来判断，如下：${1&lt;2}=false ,${(10*10)&gt;200}=true 1234&lt;c:if text="$&#123;6&gt;5&#125;"&gt; &lt;c:out value="可以直接使用EL表达式进行比较"&gt;&lt;/c:out&gt;&lt;/c:if&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JSP总结三(JSTL核心标签库的使用)]]></title>
      <url>%2F2017%2F09%2F22%2FJSP%E6%80%BB%E7%BB%93%E4%B8%89-JSTL%E6%A0%B8%E5%BF%83%E6%A0%87%E7%AD%BE%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[JSP总结三(JSTL核心标签库的使用)简介 其实在我们编写JSP网页的时候是不希望在JSP页面中出现Java代码的，这里我们就要使用JSTL的核心标签库来实现。 想要使用JSTL，一定要填上这句话：&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; 属性处理与输出标签属性处理标签 在定义变量的时候，我们难免会用到Java代码，但是这里我们介绍&lt;c:set&gt;标签，这个能够实现变量的定义 &lt;c:set&gt;标签中的属性有 var(定义的变量)、value(变量的值)、target(为JavaBean对象赋值的时候使用)、scope(设置变量的存活范围，有request,session,application,page)、property(JavaBean的变量) 使用set标签相当于调用存活范围内的setAttribute()方法来绑定属性 定义一个普通的变量: 123&lt;%--x的值为10，这句话相当于String x="10" --%&gt;&lt;c:set var="x" value="10"&gt;&lt;/c:set&gt; 定义session范围的变量(当然还可以定义其他存活范围的变量，这里就不一一讲了) 123456789&lt;%--seesion范围的变量代表整个会话期间都是可以共享这个变量的，相当于下面这句话： session.setAttribute("x",100); 在另外一个JSP文件中可以使用下面的语句得到其中的值： session.getAttribute("x"); &lt;c:out value="$&#123;sessionScope.x&#125;"&gt;&lt;/c:out&gt;--%&gt;&lt;c:set var="x" value="100" scope="session"&gt;&lt;/c:set&gt; 设置JavaBean对象的值： 12345678&lt;%--获取JavaBean的对象person,如果没有那么就是直接创建一个对象，范围为session,下面可以用到 --%&gt;&lt;jsp:useBean id="person" class="com.Person" scope="session"&gt;&lt;/jsp:useBean&gt;&lt;%-- target是对象的person，这里使用EL表达式，得到session范围内的Person对象 --%&gt;&lt;c:set target="$&#123;sessionScope.person &#125;" property="username" value="陈加兵"&gt;&lt;/c:set&gt;&lt;%-- 输出变量的username的值，这里使用的EL表达式 相当于 session.getAttribute("person").getUsername() --%&gt;&lt;c:out value="$&#123;sessionScope.person.username &#125;"&gt;&lt;/c:out&gt; 如果设置的值太冗长了，那么可以在标签体的中间设置 1&lt;c:set scope="request"&gt;陈加兵&lt;/c:set&gt; 移除变量 使用的是&lt;c:remove&gt;(一定要指定存活范围) 1234&lt;%--移除session范围内的变量x 相当于 session.removeAttribute("x") 这里一定要指定范围--%&gt;&lt;c:remove var="x" scope="session"/&gt; 输出标签 &lt;c:out&gt;相当于out.println()方法，是一个用来向网页中输出内容的 其中的属性有value (输出的内容，其中可以是JEL的${}或者一个字符串) ，escapeXml(这个使用来控制是否将输出的内容中有html标签的是否用替代字符替换，默认为true表示用替代字符替换),default(如果输出的内容为null或者为空的时候那么就直接不显示任何内容，但是我们可以定义default的值来默认显示的值) 使用EL表达式输出 123&lt;%--输出request范围内的属性x 相当于 out.println(request.getAttribute("x"))--%&gt;&lt;c:out value="$&#123;requestScope.x&#125;"&gt;&lt;/c:out&gt; 直接使用字符串输出一个值 12&lt;c:out value="我是陈加兵"&gt;&lt;/c:out&gt; 输出html语句 123&lt;%--设置escapeXml为false--%&gt;&lt;c:out value="&lt;h1&gt;我是陈加兵&lt;/h1&gt;" escapeXml="false"&gt;&lt;/c:out&gt; 指定输出的默认的内容 123&lt;%--如果$&#123;param.username&#125;为空，那么就输出0--%&gt;&lt;c:out value="$&#123;param.username&#125;" default="0"&gt;&lt;/c:out&gt; 流程处理标签 流程处理就是判断，循环语句 if判断语句 &lt;c:if&gt;可以判断语句是否正确，如果正确即可执行，但是这个标签没有else语句，只能处理判断为正确的结果其中的属性有test，这个是设置判断条件的，如果为true即可执行，反之不执行，var是保留判断结果的test中的判断条件既可以是EL表达式也可以是&lt;%=%&gt; 1234567 &lt;c:set var="salary" value="$&#123;3000 &#125;"&gt;&lt;/c:set&gt;&lt;%-- test中写的是判断条件，如果为true那么才执行，这里写的是EL表达式，当然也是可以用&lt;%=%&gt; --%&gt; &lt;c:if test="$&#123;salary&gt;2000 &#125;"&gt; &lt;c:out value="这个员工的工资大于2000"&gt;&lt;/c:out&gt;&lt;/c:if&gt; 高级判断 前面的说过的&lt;c:if&gt;仅仅当判断为真时才执行，但是我们想要当不为真时也执行语句，这时我们要使用&lt;c:choose&gt;,&lt;c:when&gt;,&lt;c:otherwise&gt; 123456789101112131415161718 &lt;%-- 判断题必须在choose中 --%&gt;&lt;c:choose&gt; &lt;%-- 如果提交的username和password都对的话，那么就登录成功 相当于if --%&gt; &lt;c:when test='$&#123;param.username=="陈加兵" &amp;&amp; param.password=="123456"&#125;'&gt; &lt;h1&gt; &lt;c:out value="$&#123;param.username &#125;"&gt;&lt;/c:out&gt; 登录成功 &lt;/h1&gt; &lt;/c:when&gt; &lt;%-- 相当于else --%&gt; &lt;c:otherwise&gt; &lt;h1&gt; &lt;c:out value="$&#123;param.username &#125;"&gt;&lt;/c:out&gt; 登录失败 &lt;/h1&gt; &lt;/c:otherwise&gt;&lt;/c:choose&gt; 网页导入和重定向标签网页导入标签 之前学过JSP中的网页导入，一个是静态导入，一个是动态导入，详情请看上篇文章。 在JSTL中也有一个标签(&lt;c:import&gt;)，用于动态导入网页,并且还可以使用&lt;c:param&gt;设置传入的参数 12345 &lt;%-- url就是要导入的网页，name是设置初始值的变量，value是设置的值。在demo1.jsp中可以使用 request.getParameter(String name)取得参数 --%&gt;&lt;c:import url="demo1.jsp"&gt; &lt;c:param name="username" value="陈加兵"&gt;&lt;/c:param&gt; &lt;c:param name="password" value="123456"&gt;&lt;/c:param&gt;&lt;/c:import&gt; 除了导入web应用程序中的网页，我们还可以导入非目前web应用程序中的网页 12&lt;%--导入百度的首页，并且设置字符集为utf-8，注意这里一定要设置网页的字符集格式和当前的jsp格式一样，否则会出现乱码--%&gt;&lt;c:import url="http://www.baidu.com"&gt;&lt;/c:import charEncoding="utf-8"&gt; 重定向标签 之前的重定向必须使用HttpServletResponse的sendRedirect()方法 现在我们可以使用JSTL标签&lt;c:redirect url&gt; 1&lt;c:redirect url="demo1.jsp"&gt;&lt;/c:rediect&gt; 当然我们也是可以传入参数的，使用&lt;c:param name=&quot;&quot; value=&quot;&quot;&gt; 123&lt;c:redirect url="demo1.jsp"&gt; &lt;c:param name="username" value="陈加兵"/&gt;&lt;/c:rediect&gt; 错误处理标签 在之前的JSP文件中，必须定义errorPage属性才能跳转到指定的页面或者处理错误 现在我们使用JSTL标签&lt;c:catch&gt;,可以捕捉异常，如果有异常就会将异常对象保存下来 1234567891011 &lt;%--捕捉异常，如果有了异常，那么保存在error变量中 --%&gt;&lt;c:catch var="error"&gt; $&#123;10/0 &#125;&lt;/c:catch&gt;&lt;%-- 如果捕捉到了异常，那么error就不是null --%&gt;&lt;c:if test="$&#123;error!=null &#125;"&gt; &lt;h1&gt; &lt;c:out value="$&#123;error.message &#125;"&gt;&lt;/c:out&gt; &lt;/h1&gt;&lt;/c:if&gt; 迭代标签 迭代标签用于数组，集合，列表的输出。 forEach forEach既可以循环也可以迭代 属性 var 变量，用于输出 items 将要迭代的对象 valueStatus 迭代的状态 begin 如果指定了bengin，就在items下标为begin的位置进行迭代 end 如果指定了end，那么就在items下表为end的位置结束迭代 step 指定迭代的步长，默认的是1 实例12345678910111213141516171819202122232425262728 &lt;!-- 循环输出[0,8]之中的所有的整数 --&gt; &lt;c:forEach var="item" begin="0" end="8"&gt; &lt;c:out value="$&#123;item&#125;"&gt;&lt;/c:out&gt; &lt;/c:forEach&gt; &lt;br&gt; &lt;!-- 循环输出[0,8]之中的所有的整数 ,指定步长为2--&gt; &lt;c:forEach var="item" begin="0" end="8" step="2"&gt; &lt;c:out value="$&#123;item&#125;"&gt;&lt;/c:out&gt; &lt;/c:forEach&gt;&lt;% List list=new ArrayList(); for(int i=0;i&lt;3;i++)&#123; list.add(i); &#125; request.setAttribute("items", list);%&gt;&lt;!-- item是创建的变量用来存储迭代中的值，items是迭代的对象，其中的值使用EL表达式给出 --&gt;&lt;c:forEach var="item" items="$&#123;requestScope.items &#125;"&gt; &lt;c:out value="$&#123;item &#125;"&gt;&lt;/c:out&gt;&lt;/c:forEach&gt; forTokens 用于将一个字符串按照定义的符号分隔出来。 属性 var 变量，用于输出 items 将要迭代的string对象 delims 指定分隔字符串的分隔符，可以定义多个分隔符 varStatus 迭代的状态 begin end step 实例12345678&lt;% String str="c,v,d,s,a|v,d"; request.setAttribute("str",str);%&gt;&lt;c:forTokens var="item" items="$&#123;requestScope.str &#125;" delims=",|"&gt; &lt;c:out value="$&#123;item &#125;"&gt;&lt;/c:out&gt;&lt;/c:forTokens&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JSP总结二(动作元素)]]></title>
      <url>%2F2017%2F09%2F20%2FJSP%E6%80%BB%E7%BB%93%E4%BA%8C-%E5%8A%A8%E4%BD%9C%E5%85%83%E7%B4%A0%2F</url>
      <content type="text"><![CDATA[JSP总结二(动作元素)&lt;jsp:include&gt; 前面介绍了一种指令元素include，那是一种静态包含JSP文件，这个标签是动态包含一个JSP页面，也就是被包含的JSP页面和原JSP将合并在一起，转译为一个Servlet类。这是有一定的局限性的，如变量的定义不能重复。 动态的包含JSP文件即是被包含的JSP和原JSP分别转译为一个Servlet类，这就保证了其中的变量可以重复定义了，因为并不是在一个类中了 &lt;jsp:include page=&quot;相对的文件路径&quot;&gt;&lt;/jsp:include&gt;这种标签转译为Servlet和指令元素include是一样的 123456&lt;%--动态导入在编译的时候是两个jsp文件各自编译成一个Servlet文件，因此其中的变量是不可以共享的，在当前页面中还是可以定义导入页面定义的变量 --%&gt;&lt;jsp:include page="form.jsp"&gt; //定义的param可以在form.jsp中使用request.getParameter(String name)取得其中的值 &lt;jsp:param value="陈加兵" name="username"/&gt; &lt;jsp:param value="123456" name="password"/&gt;&lt;/jsp:include&gt; &lt;jsp:forward&gt; 这是将请求转发给另外一个JSP或者Servlet文件处理，这个和RequestDispatcher是一样的原理，就是Servlet中转发123456//绑定属性，在login.jsp中可以获取request.setAttribute("username","陈加兵");//当前页面的请求将会交给login.jsp文件处理&lt;jsp:forward page='login.jsp'&gt;&lt;/jsp:forward&gt; &lt;jsp:useBean&gt; 这个动作元素是用来搭配JavaBean组件的标准标签。JavaBean必须满足下面的条件： 必须实现Java.io.Serializable接口 没有公开的(public)类变量 具有无参构造函数（默认的都有） 具有公开的设置方法（setter）与取值方法（getter） 下面就是一个JavaBean组件 12345678910111213141516171819202122232425262728293031323334353637383940package com;import java.io.Serializable;public class Person implements Serializable &#123; //这里的变量的值一定要和表单的中的name属性的值一样，否则不能获取 private String username; private String password; private int age; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Boolean Checkout()&#123; return "陈加兵".equals(username)&amp;&amp;"123456".equals(password); &#125;&#125; 使用JavaBean的目的是减少Scriptlet的使用。其中搭配&lt;jsp:useBean&gt;来使用这个JavaBean,并且使用&lt;jsp:setProperty&gt;与&lt;jsp:getProperty&gt;对javaBean进行设值与取值 注意javaBean一定要搭配表单使用，因为设值的值其实是隐式的调用request.getParameter(String name)来获取表单的值 下面是一个登录的表单(注意这里的input中的name属性的值一定要和JavaBean组件类的成员变量的名字一样) 123456789101112131415161718192021&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--提交给Demo1.jsp处理，下面就实现Demo1.jsp--&gt;&lt;form action="Demo1.jsp"&gt; &lt;label&gt;姓名：&lt;/label&gt; &lt;input type="text" name="username"&gt; &lt;label&gt;密码：&lt;/label&gt; &lt;input type="password" name="password"&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 下面我们写一个JSP文件设置JavaBean 12345678910111213141516171819202122232425262728293031323334353637383940&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%--使用JavaBean person是Person创建的对象，相当于 Person person=new Person() 其中class是JavaBean的类所在的路径(在com包下的Person文件中) id就是相当于创建的对象 --%&gt; &lt;jsp:useBean id="person" class="com.Person"&gt;&lt;/jsp:useBean&gt; &lt;%--为username和password设置值,相当于下面的语句 person.setUsername(request.getParameter("username")); person.setPassword(request.getParameter("password")); JavaBean中的变量一定要和表单中的值一样，否则就不能对应，出现错误 其中name就是指定上面的id，即是使用的对象，property就是指定变量 --%&gt; &lt;jsp:setProperty property="uesrname" name="person"/&gt; &lt;jsp:setProperty property="password" name="person"/&gt; &lt;%--age是另外的变量，并没有对应着表单的name属性，因此我们可以单独的为其设置值，使用value实行即可设置，这里不必考虑类型，因为在内部会自动转换成JavaBean中的类型 --%&gt; &lt;jsp:setProperty property="age" name="person" value="20"/&gt; &lt;%--获取设置的值，相当于下面的语句： person.getUsername(); person.getPassword(); person.getAge(); --%&gt; &lt;h1&gt;&lt;jsp:getProperty property="username" name="person" /&gt;&lt;/h1&gt; &lt;h1&gt;&lt;jsp:getProperty property="password" name="person" /&gt;&lt;/h1&gt; &lt;h1&gt;&lt;jsp:getProperty property="age" name="person" /&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 其实我们还可以不但可以将表单中的值赋值给变量，还可以使用value和param自己设置 1234567&lt;%-- 将请求的url中的password的值赋值给username，注意这里的使用的get的请求的话，提交的时候url会有请求值的 http://localhost:8080/web2/JSP/Demo1.jsp?username=%E9%99%88%E5%8A%A0%E5%85%B5&amp;password=123456 --%&gt; &lt;jsp:setProperty property="username" name="person" param="password"/&gt; &lt;%--age是另外的变量，并没有对应着表单的name属性，因此我们可以单独的为其设置值，使用value实行即可设置，这里不必考虑类型，因为在内部会自动转换成JavaBean中的类型 --%&gt; &lt;jsp:setProperty property="age" name="person" value="20"/&gt; JavaBean的存活范围 Scope属性决定了javabean对象的存在的范围。可选值有: page(默认值) request session application 1&lt;jsp:useBean id="person" class="com.anllin.bean.Person" scope="page"&gt;&lt;/jsp:useBean&gt; 在page范围 客户每次请求访问jsp页面时，都会创建一个javabean对象。JavaBean对象的有效范围就是当前的jsp文件中，如果不在当前Jsp中，那么就不可以使用该JavaBean对象中设置的值 比如使用forward转发给另外一个JSP文件，那么此时就会再创建一个JavaBean对象，原来页面的JavaBean对象并没有传过来，也就不能使用其中的值，这个和变量的共享是一个道理的，这个JavaBean对象只能在当前的Jsp文件中调用，不能实现共享 在request范围 客户每次请求访问jsp页面时，都会创建新的javabean对象。有效范围为： 客户请求访问的当前jsp网页。 和当前网页共享一个客户请求的网页，即当前jsp网页中&lt;%@include %&gt;指令以及&lt;forward&gt;标记包含的其他jsp文件,也就是转发和包含的Jsp文件也是可以共享这个JavaBean对象的，这个和Servlet中的request是一样的，一旦转发了，就可以通过setAttribute()设置属性，那么在转发的页面中就可以访问这个属性 当所有共享同一个客户请求的jsp页面执行完毕并向客户端发加响应时，javabean对象结束生命周期。 javabean对象作为属性保存在httpServletRequest对象中，属性名javabean的id,属性值为javabean对象，因此可以通过HttpRequest.getAttribute()方法取得javabean对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 //Demo1.jsp文件 表单请求提交的JSp文件 &lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt; &lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%--设置scope属性为request，这个是必须的，这里的JavaBean对象为person--%&gt; &lt;jsp:useBean id="person" class="com.Person" scope="request"&gt;&lt;/jsp:useBean&gt; &lt;jsp:setProperty property="uesrname" name="person"/&gt; &lt;jsp:setProperty property="password" name="person"/&gt; &lt;jsp:setProperty property="age" name="person" value="20"/&gt;&gt; e &lt;%--转发请求到Demo2.jsp文件中，那么就可以在Demo.jsp中共享person对象了--%&gt; &lt;jsp:forward page="Demo2.jsp"&gt;&lt;/jsp:forward&gt;&lt;/body&gt;&lt;/html&gt;//Demo2.jsp &lt;%@page import="com.Person"%&gt; &lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt; &lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%-- 使用JavaBean,这里的scope是必须的，一定要和Demo1.jsp一样，id也要一样 --%&gt; &lt;jsp:useBean id="person" class="com.Person" scope="request"&gt;&lt;/jsp:useBean&gt; &lt;%--获取username的值 --%&gt; &lt;jsp:getProperty property="username" name="person"/&gt; &lt;% //使用HttpServletRequest获取对象person Person p=(Person)request.getAttribute("person"); out.println(p.getUsername()); //获取username的值 %&gt; &lt;/body&gt; &lt;/html&gt; 在session范围内 我们知道HttpSession是可以在会话期间实现数据共享的，只要是同一个项目中的Jsp文件都是可以共享这个JavaBean对象，但是并不是永久的，因为会话也是有时间限制的， javabean对象作为属性保存在HttpSession对象中，属性名为javabean的id,属性值为javabean对象。除了可以通过javabean的id直接引用javabean对象外，也可以通过HttpSession.getAttribute（）方法取得javabean对象 一定要注意在每一个&lt;jsp:useBean&gt;中都要写上scope=&quot;session&quot; 在application范围内 我们知道ServletContext存在于整个web应用的生命周期，这个不像session，一旦设置的会话时间结束，那么就不存在了，这个是永远存在的，只要web程序在继续 javabean对象作为属性保存在application对象中，属性名为javabean的id，属性值为javabean对象，除了可以通过javabean的id直接引用对象外，也可以通过javabean的application.getAttribute()方法取得javabean对象 重要的属性 其实不仅仅可以对于表单中请求可以转换为对象的值，上面我们说过了存活范围，其实只要在这个请求范围内，并且将对象绑定到响应的属性上面，那么就可以在jsp文件中使用改标签接收其值。 其实一般在表单提交之后，我们会使用Sevlet文件验证是否密码和用户名正确，那么就不是直接提交给jsp文件，此时就像上面说过的，不影响标签的使用，只要将JavaBean对象绑定到响应范围的属性上，便是可以实现对象的共享，代码如下： ServletDemo文件 123456789101112131415161718192021222324252627282930313233343536package com;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class ServletDemo extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //创建对象，并且设置值 Person person=new Person(); person.setUsername("陈加兵"); person.setPassword("123456"); //将JavaBean对象绑定到request上，相当于存活范围为request //注意这里的键值一定要是和对象的名称一样，否则不行 request.setAttribute("person", person); //转发请求到jsp文件，下面我们就将在jsp文件中使用JavaBean标签接收 RequestDispatcher dispatcher=request.getRequestDispatcher("JSP/demo1.jsp"); dispatcher.forward(request, response); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; &#125; demo1.jsp:上面文件转发过来的，接收JavaBean对象 123456789101112131415161718&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%-- 使用标签接收转发过来的JavaBean对象，scope一定要设置为request,id就是传过来的对象，一定要和前面的名称一样，下面的语句相当于： Person person=(Person)request.getAttribute("person"); --%&gt;&lt;jsp:useBean id="person" class="com.Person" scope="request"&gt;&lt;/jsp:useBean&gt;&lt;h1&gt;&lt;jsp:getProperty property="username" name="person"/&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 参考文章http://www.cnblogs.com/zfc2201/archive/2011/08/17/2143615.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JSP总结一(标签）]]></title>
      <url>%2F2017%2F09%2F20%2FJSP%E6%80%BB%E7%BB%93%E4%B8%80-%E6%A0%87%E7%AD%BE%EF%BC%89%2F</url>
      <content type="text"><![CDATA[JSP总结一(标签)生命周期 JSP文件在部署到web服务器上的时候还是会编译成Servlet文件，因此JSP的生命周期和Servlet是一样的，都是有_JSPInit()，_JSPService(),_JSPDestroy()方法的 指示元素 在jsp中有三个指示类型，分别为：page,include,tablig。 page page指示类型告知容器如何转译目前的JSP网页。 1&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" import="java.util.*"%&gt; language指定解析语言，contentType表明为html文件，pageEncoding告诉容器转译及编译的时候如何处理这个这个JSP网页中的额中文编码，import是导入包的作用，如果有多个包导入，那么可以使用逗号隔开。 errorPage用于设置当JSP运行错误而产生异常的时候，该转发哪一个页面处理这个异常，可以自己定义一个异常的JSP或者html文件显示这个异常，但是这个必须和isErrorPage配合使用，必须在处理异常的page指令中协商isErrorPage=&quot;true&quot; 还有一些其他的属性，自己可以看看菜鸟教程上的内容 include include是用于静态的包含其他页面中的内容。这个还是很重要的，如果在网页中每一张页面都需要使用一样的导航栏，导入一样的css，js文件，那么可以将这些内容单独做一个jsp文件或者html文件，要使用的时候就直接包含即可。 12 //file指定文件的相对路径 &lt;%@include file="daoru.jsp" %&gt; 其实上面的语句在Servlet语句相当于下面这句话： 12RequestDispatcher dis=request.getRequestDispatcher();dis.include(request,response); 注意这句话写在页面的哪里，那么就将其中的内容导入到哪里，比如要导入css，js文件，那么直接在head标签中直接导入 静态导入的方式在部署到服务器会自动和当前的JSP文件编译为一个Servlet文件，也就是在一个Servlet类中。因此在包含的JSP文件中如果定义了变量或者方法，那么在当前的JSP页面中就不能重复定义，否则将会出现变量重复的错误，代码如下： 1234567891011121314151617181920212223242526272829303132//Demo1.jsp&lt;%@ page language="java" contentType="text/html; charset=UTF-8"pageEncoding="UTF-8"%&gt;&lt;% String name="陈加兵"; int age=22;%&gt;//Demo2.jsp&lt;%@ page language="java" contentType="text/html; charset=UTF-8"pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;//包含Demo1.jsp文件&lt;%@ include file="Demo1.jsp" %&gt;&lt;% //String name="chenji"; //这里不能重复定义，否则将会报错%&gt;//直接输出name的值 &lt;h1&gt;&lt;%=name%&gt;&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 注意这里的Demo1.jsp文件中一定不能重复的出现&lt;html&gt;标签，因为包含的时候是全部内容都是包含到当前页面中，如果出现重复的html标签代码就会混乱。 声明元素 &lt;%! &gt; 这就是声明元素，主要是用来定义类成员和方法声明的。其中不可以出现循环语句等，只能出现定义语句，当然在定义方法的时候函数体中可以出现其他的语句。 声明元素中的内容在编译的都将变成Servlet中的类的成员变量和方法 1234567891011 &lt;%! //变量 String name="陈加兵"; private int age=20; //方法 public void display()&#123; System.out.println(name+":"+age);&#125; %&gt; Scriptlet &lt;% %&gt;这个是写正常的java语句的，其中将会转译成_jspService()方法中的内容 12345&lt;% String name="陈加兵"; request.setAttribute("name",name);%&gt; 表达式元素 &lt;%= %&gt; 其中可以直接写一个表达式 123&lt;h1&gt;&lt;%= new Date() %&gt; &lt;/h1&gt;&lt;h1&gt;&lt;%= 2+3 %&gt; &lt;/h1&gt;&lt;h1&gt;&lt;%= request.getAttribute("name") %&gt; &lt;/h1&gt; 注释元素 &lt;%----%&gt;这是JSP的注释，在浏览器中查看源代码的时候是看不到的 &lt;!-- --&gt; 这是html中的注释，在网页源代码中是可以看到的 隐含对象 request 转译后对应的是HttpServletRequest resposne 译后对应的是HttpServletResponse out 译后对应的是JspWriter对象，其内部关系一个PrintWriter对象 Config 译后对应的是ServletConfig session 译后对应的是HttpSession application 译后对应的是ServletContext pageContext 译后对应的是PageContext对象 exception 译后对应的是Throwable对象 page 译后对应的是this]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Servlet总结五(监听器)]]></title>
      <url>%2F2017%2F09%2F19%2FServlet%E6%80%BB%E7%BB%93%E4%BA%94-%E7%9B%91%E5%90%AC%E5%99%A8%2F</url>
      <content type="text"><![CDATA[Servlet总结五(监听器)分类 监听器按其功能可以分为三种，分别是生命周期监听器(ServletContextListener,ServletRequestListener,HttpSessionListener)，属性监听器(ServletRequestAttributeListener,HttpSessionAttributeListener,ServletContextAttributeListener)，会话属性监听器(HttpSessionBindingListener,HttpSessionActivationListener)。下面我们将会详细的介绍这三种监听器。 生命周期监听器生命周期就是从创建到销毁，因此顾名思义，就是在对象创建的时候会触发，销毁的时候也会触发 ServletContextListener 前面我们说过ServletContext是上下文的，是应用程序共享的，当应用程序启动就会生成的。在应用程序初始化或者结束前，会分别调用contextInitialized()和contextDestroyed()方法，通过传入的ServletContextEvent取得ServletContext对象。 实例 下面读取设置的初始化参数，并且在监听器中将其绑定为属性实现全文共享 web.xml的文件，主要是设置初始化属性值，前面已经讲过 1234567891011121314151617&lt;!-- 设置ServletContext初始参数 --&gt; &lt;context-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;param-value&gt;陈加兵&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;123456&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 设置ServletContext初始参数 --&gt; &lt;!-- 设置监听器，ServletContextListener --&gt; &lt;listener&gt; &lt;listener-class&gt;com.ServletContextListenerDemo&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 设置监听器，ServletContextListener --&gt; 下面是实现监听器的功能 123456789101112131415161718192021222324252627282930313233343536373839package com;import java.util.Enumeration;import javax.servlet.ServletContext;import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;public class ServletContextListenerDemo implements ServletContextListener &#123; // ServletContext销毁的时候触发 public void contextDestroyed(ServletContextEvent arg0) &#123; //当销毁的时候就移除其中绑定的属性 ServletContext context = arg0.getServletContext(); // 获取所有属性的名称 Enumeration enumeration = context.getAttributeNames(); while (enumeration.hasMoreElements()) &#123; String name = (String) enumeration.nextElement(); // 移除绑定的属性 context.removeAttribute(name); &#125; &#125; // ServletContext生成的时候触发，一般当web程序应用的时候就会初始化ServletContext参数 public void contextInitialized(ServletContextEvent arg0) &#123; //获取ServletContext对象 ServletContext context = arg0.getServletContext(); // 读取参数 String name = context.getInitParameter("username"); String password = context.getInitParameter("password"); // 绑定属性，用于全文共享 context.setAttribute("username", name); context.setAttribute("password", password); &#125;&#125; ServletRequestListener 这是在对象ServletRequest对象生成或结束时，会触发的监听器。当生成的时候会触发requestInitialized(),结束时会触发requestDestroyed()方法。ServletRequest对象生成一般在浏览器发出请求，或者转发重定向。注意这个触发是在Servlet的doGet()或者doPost()之前。 实例 ServletRequestListener文件:在ServletRequest对象生成时绑定属性 1234567891011121314151617181920212223242526package com;import javax.servlet.ServletRequestEvent;import javax.servlet.ServletRequestListener;import javax.servlet.http.HttpServletRequest;public class ServletRequestListenerDemo implements ServletRequestListener &#123; //在ServletRequest对象结束时触发 public void requestDestroyed(ServletRequestEvent arg0) &#123; HttpServletRequest request=(HttpServletRequest)arg0.getServletRequest(); &#125; //在ServletRequest对象生成时触发(比如浏览器请求) public void requestInitialized(ServletRequestEvent arg0) &#123; //强制转换成其子类 HttpServletRequest request=(HttpServletRequest) arg0.getServletRequest(); //绑定属性，这里的request和触发其的Servlet中的是一样的，因此可以实现共享 //就好像forward,include一样 request.setAttribute("login", "atuo"); //绑定属性 &#125;&#125; Servlet文件：取得绑定的值 123456public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; PrintWriter pWriter=response.getWriter(); pWriter.println(request.getAttribute("login")); //取得上面监听器绑定的值 &#125; web.xml文件 12345&lt;!-- 设置监听器，ServletRequestListener --&gt; &lt;listener&gt; &lt;listener-class&gt;com.ServletRequestListenerDemo&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 设置监听器，ServletRequestListener --&gt; HttpSessionListener 在HttpSession对象初始化后或者结束时，会分别调用sessionCreated()和sessionDestroyed()方法，你可以通过传入的HttpSessionEvent来取得HttpSession，以针对会话对象做出响应的创建或者结束处理操作 实例 Servlet文件：用来验证登录是否正确，如果正确就创建HttpSession对象，并且绑定属性用来实现自动登录 12345678910111213141516171819202122232425262728293031323334353637package com;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import javax.xml.registry.infomodel.User;public class ServletDemo3 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String name=request.getParameter("username"); String password=request.getParameter("password"); if ("chenjiabing".equals(name)&amp;&amp;"123456".equals(password)) &#123; //用户名和密码正确创建对象 HttpSession session=request.getSession(); session.setAttribute("login", "auto"); &#125; &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; public void init() throws ServletException &#123; &#125;&#125; HttpSessionListenerDemo文件：用来记录登录的人数 123456789101112131415161718192021222324package com;import javax.servlet.http.HttpSession;import javax.servlet.http.HttpSessionEvent;import javax.servlet.http.HttpSessionListener;import org.omg.CORBA.Request;public class ServletHttpSessionListenerDemo implements HttpSessionListener &#123; private static int count=0; //HttpSession创建时触发 public void sessionCreated(HttpSessionEvent arg0) &#123; count++; //人数++ &#125; //HttpSession销毁时触发 public void sessionDestroyed(HttpSessionEvent arg0) &#123; // TODO Auto-generated method stub count--; //人数-- &#125;&#125; 属性操作监听器 顾名思义，属性操作监听器就是当绑定属性或者移除绑定属性的时候会触发，共有三个监听器，分别为：ServletContextAttributeListener,ServletRequestAttributeListener,HttpSessionAtrributeListener。相同的是它们都有共同需要实现的方法，分别为：attributeAdded(绑定属性的时候触发),attributeRemoved(属性移除的时候触发),attributeReplace(属性被替换的时候触发) 由于这三个监听器实现的方法都是一样的，下面就演示一个即可，其他的都是相同的 HttpSessionAttributeListener 这是监听HttpSession对象属性的，主要有（添加，移除，替换）,当然这个也是要在web.xml设置的 12345678910111213141516171819202122232425262728293031323334package com;import javax.servlet.http.HttpSession;import javax.servlet.http.HttpSessionBindingEvent;public class HttpSessionAttributeListener implements javax.servlet.http.HttpSessionAttributeListener &#123; /*HttpSessionBindingEvent方法 * String getName() 返回最近改变的属性的名称 * Object getValue() 返回已添加、移除或替换的属性的值。如果添加（或绑定）了属性，则这是该属性的值。如果移除（或取消绑定）了属性，则这是被移除属性的值。如果替换了属性，则这是属性原来的值。 * getSession() 获取HttpSession对象 */ //添加新的属性时触发，每绑定一个属性就触发一次 public void attributeAdded(HttpSessionBindingEvent arg0) &#123; //获取HttpSession对象 HttpSession session=arg0.getSession(); String name=arg0.getName(); //获取添加的属性名称 String attribute=(String) arg0.getValue(); //获取添加的属性的值 &#125; //移除属性的时候触发 ，每移除一次就会触发一次 public void attributeRemoved(HttpSessionBindingEvent arg0) &#123; String value=(String) arg0.getValue(); System.out.println("被移除的属性的值为："+value); &#125; //属性值被替换的时候触发，直接重新设置属性值就是替换 public void attributeReplaced(HttpSessionBindingEvent arg0) &#123; System.out.println("被替换的属性的值："+arg0.getValue()); &#125;&#125; 会话属性监听器 先前介绍的几个监听器都是要在web.xml中使用&lt;listener&gt;定义的，这个会话属性监听器是不要在web.xml设置的 这里介绍的监听器分别为：HttpSessionBindingListener,HttpSessionActivationListener HttpSessionBindingListener 当实现HttpSessionBindingListener接口的类的对象被移除或者绑定到HttpSession成为属性的时候就会触发 下面是实现HttpSessionBindingListener接口的类 1234567891011121314151617181920212223242526272829303132package com;import javax.servlet.http.HttpSession;import javax.servlet.http.HttpSessionBindingEvent;public class HttpSessionBindingListenerDemo implements javax.servlet.http.HttpSessionBindingListener &#123; public String name; private int age; public HttpSessionBindingListenerDemo() &#123; super(); this.name="陈加兵"; this.age=22; &#125; //当这个类的对象绑定成为HttpSession的属性的时候将会触发 public void valueBound(HttpSessionBindingEvent arg0) &#123; //获取绑定的属性的对象 HttpSessionBindingListenerDemo listenerDemo=(HttpSessionBindingListenerDemo)arg0.getValue(); //获取对象的值 System.out.println(listenerDemo.name); &#125; //当这个类的对象被移除的时候就会触发 //getValue() getName() public void valueUnbound(HttpSessionBindingEvent arg0) &#123; &#125;&#125; 下面是Servlet文件： 123456789101112131415161718192021222324252627282930313233343536373839package com;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;public class ServletDemo1 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取对象 HttpSession session=request.getSession(); //对象 HttpSessionBindingListenerDemo listener=new HttpSessionBindingListenerDemo(); //绑定对象 session.setAttribute("listener", listener); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; public void init() throws ServletException &#123; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Servlet总结四(过滤器)]]></title>
      <url>%2F2017%2F09%2F17%2FServlet%E6%80%BB%E7%BB%93%E5%9B%9B-%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
      <content type="text"><![CDATA[Servlet总结四(过滤器的使用)简介 在容器调用Servlet的service()的方法钱，Servlet其实并不会知道有请求的到来，而在service()方法执行后，容器真正对浏览器进行HTTP响应之前，浏览器也不知道Servlet真正响应是什么。过滤器(Filter)正如其名称所示，它介于Servlet之前，可拦截浏览器对Servlet的请求，也可以改变Servlet对浏览器的响应。 其实说白了，过滤器就是应用程序的一个额外的组件，为了方便使用并且不改变Servlet源代码，比如用户验证，字符替换，压缩这类的需求，你可能只是暂时的需要这类需求，但是过一段时间又不需要了，如果直接在Servlet中改动源码，那么就太麻烦了。因此此时就需要设置一个独立的组件，在使用的时候直接引用，不需要的时候直接删除即可，这就是过滤器的必要。 过滤器的实现 想要实现过滤器，那么需要实现Filter接口，这个接口中有三个必须实现的方法，分别为init(),doFilter(),destroy()。 init(FilterConfig config) 这是一个初始化方法，其中的参数可以获取定义的初始值，这个在后面会详细说 destroy() 这个是销毁方法 doFilter(HttpServletRequest request,HttpServletResponse response,FilterChain chain) 这是主要的方法，用来执行过滤的作用。当请求来到了web容器中，容器发现了调用Servlet的service()方法之前可以应用某过滤器的时候就会调用该过滤器的doFilter()方法。就是在doFilter()方法中进行了service()方法的前置处理，而后根据是否调用FilterChain中的doFilter()决定是否执行下一个过滤器，如果没有那么就执行第一个过滤器。 如果执行了FilterChain的doFilter()方法，那么就会执行下一个过滤器，如果没有就调用指定的Servlet的service()方法。 重点 Servlet的响应分为前置处理和后置处理。前置处理就是在调用service()方法之前进行的处理，就是Servlet还没有接受到请求的时候，后置处理就是在Servlet执行过service()方法之后，就是Servlet已经处理完请求之后。因此FilterChain的doFilter()方法就将过滤器处理分为了前置处理和后置处理，在调用FilterChain的doFilter()方法之前的都是对Servlet的前置处理，也就是说这时候Servlet并不知道此时有请求过来，而在其之后的都是对Servlet的后置处理。 123456doFilter(HttpServletRequest request,HttpServletResponse response,FilterChain chain)&#123; //service()的前置处理 chain.doFilter(request,response); //service()的后置处理&#125; 在FilterChain执行后会一堆栈顺序返回，就是说如果有多个Filter，那么就先按照顺序执行chain.doFilter(request,response)之前的代码，即是先前置处理，然后入栈，这样一直到执行到最后一个Filter，之后就从栈顶开始执行chain.doFilter()的方法之后的代码，即是后置处理。总的来说就是先执行前置处理，然后入栈，待全部执行完毕之后再从栈顶开始后置处理的代码。 在Filter的doFilter的方法中的request，response和Servlet的doGet()和doPost()方法中的是一样的，即是可以设置属性，可以得到表单提交的值，总之是一样的。 简单的例子 下面实现一个过滤器用来验证提交请求的用户名和密码是否正确 1234567891011121314151617181920212223242526272829303132333435363738package com;import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequestWrapper;import javax.servlet.http.HttpServletResponse;public class FilterDemo1 implements Filter &#123; public void destroy() &#123; &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; // 根据request获取表单的用户名和密码 String username = request.getParameter("username"); String password = request.getParameter("password"); // 如果用户名和密码正确 if ("陈加兵".equals(username) &amp;&amp; "123456".equals("password")) &#123; System.out.println("用户名或者密码错误，请重新输入"); &#125; //继续执行下一个过滤器，如果有就执行 chain.doFilter(request, response); //当所有过滤器的前置处理都执行完毕才执行这个语句 System.out.println("Servlet已经执行完毕"); &#125; public void init(FilterConfig config) throws ServletException &#123; &#125;&#125; 过滤器的设置 在web.xml中设置过滤器，设置的方式如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;display-name&gt;web2&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 定义FilterDemo1的过滤器 --&gt;&lt;filter&gt; &lt;!--设置过滤器文件的名字--&gt; &lt;filter-name&gt;FilterDemo1&lt;/filter-name&gt; &lt;!--设置过滤器类所在的路径，具体到包名--&gt; &lt;filter-class&gt;com.FilterDemo1&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;FilterDemo3&lt;/filter-name&gt; &lt;!--设置作用的url，即是Demo9这个Servlet应用这个过滤器--&gt; &lt;url-pattern&gt;/Demo9&lt;/url-pattern&gt; &lt;!-- &lt;servlet-name&gt;Demo9&lt;/servlet-name&gt; 这个标签和上面的&lt;url-pattern&gt;是一个效果，直接指明应用的Servlet的名称 --&gt; &lt;!--Demo1也应用这个过滤器--&gt; &lt;servlet-name&gt;Demo1&lt;/servlet-name&gt; &lt;/filter-mapping&gt;&lt;!-- 定义FilterDemo1的过滤器 --&gt; &lt;!-- 定义FilterDemo2的过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;FilterDemo2&lt;/filter-name&gt; &lt;filter-class&gt;com.FilterDemo2&lt;/filter-class&gt; &lt;/filte&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;FilterDemo2&lt;/filter-name&gt;&lt;!-- Demo1这个Servlet文件也应用FilterDemo2这个过滤器，那么当请求Demo的时候要按照定义的先后顺序先执行FilterDemo1这个过滤器 --&gt; &lt;url-pattern&gt;/Demo1&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 定义FilterDemo2的过滤器 --&gt; &lt;/web-app&gt; 注意 可以在同一个&lt;filter-mapping&gt;中定义多个Servlet文件，表示多个Servlet都应用于这个过滤器 一个Servlet文件可以同时应用多个过滤器，但是执行的顺序要按照定义的先后顺序执行 初始参数的设置和获取设置初始值 这个和ServletConfig一样的都存在初始参数，当然定义的方式也是不尽相同，都是在web.xml中定义的，如下： 123456789101112131415&lt;filter&gt; &lt;filter-name&gt;FilterDemo3&lt;/filter-name&gt; &lt;filter-class&gt;com.FilterDemo3&lt;/filter-class&gt; &lt;!--直接在filter下可以设置初始参数，当然我们可以在过滤器中获取参数--&gt; &lt;init-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;param-value&gt;陈加兵&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;123456&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; 获取初始参数的值 直接利用其中的init(FilteConfig config) 获取初始化参数 12345678910111213141516171819202122232425262728293031323334package com;import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequestWrapper;import javax.servlet.http.HttpServletResponse;public class FilterDemo1 implements Filter &#123; public String username; public String password; public void destroy() &#123; &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; &#125; //直接在init方法中利用FilterConfig的方法获取参数的值 public void init(FilterConfig config) throws ServletException &#123; //获取初始值 username=config.getInitParameter("username"); password=config.getInitParameter("password"); &#125;&#125; 设置触发的时机 当我们直接请求Servlet文件的url或者表单提交的时候使用的都是浏览器默认发出的请求，这个是可以触发过滤器的。但是如果是那些重定向(sendirect)或者转发包含(forward,include)就不会默认触发，因此我们需要在web.xml设置触发的时机，定义如下: 12345678&lt;filter-mapping&gt; &lt;filter-name&gt;FilterDemo1&lt;/filter-name&gt; &lt;url-pattern&gt;/Demo1&lt;/url-pattern&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;!--默认的--&gt; &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt; &lt;!--forward--&gt; &lt;dispatcher&gt;INCLUDE&lt;/dispatcher&gt; &lt;!--include--&gt; &lt;dispatcher&gt;ERROR&lt;/dispatcher&gt; &lt;!--error --&gt;&lt;/filter-mapping&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Servlet总结三(HttpSession会话管理)]]></title>
      <url>%2F2017%2F09%2F16%2FServlet%E6%80%BB%E7%BB%93%E4%B8%89-HttpSession%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[Servlet总结三(HttpSession会话管理)简介 HttpSession是提供一种方式，跨多个页面请求或对 Web 站点的多次访问标识用户并存储有关该用户的信息。简单的来说就是能够实现全局的共享数据，可以跨多个页面请求，当然在Servlet中可以在同一个项目中的不同的Servlet中共享数据 常用方法 void setAttribute(String name, Object value) 绑定对象到此会话上 public void removeAttribute(String name) 移除绑定的对象 Object getAttribute(String name) 根据指定的属性名称获取指定的值(需要强转) Enumeration getAttributeNames() 返回一个所有属性的枚举对象,可以通过Enumeration得到其中的值 public int getMaxInactiveInterval() 返回 servlet 容器在客户端访问之间将使此会话保持打开状态的最大时间间隔，以秒为单位（根据测试，这个默认的值为1800秒，如果在这个默认的时间之内没有响应，那么会话将会中断） public void setMaxInactiveInterval(int interval) 指定在 servlet 容器使此会话失效之前客户端请求之间的时间间隔，以秒为单位。负数时间指示会话永远不会超时。 使用 我们可以通过HttpServletRequest的方法getSession() 获取对象，下面我们来使用其中的函数 1234567891011121314151617 //Demo1中的doGet方法 public void doGet(HttpServletRequest request,HttpServletResponse response)&#123; request.setCharacterEncoding("UTF-8"); response.setContentType("text/html;charset=UTF-8"); //获取对象 HttpSession session=request.getSession(); //设置属性login的值为auto session.setAttribute("login", "auto"); &#125; //Demo2中的doGet方法 public void doGet(HttpServletRequest request,HttpServletResponse response)&#123; //获取对象 HttpSession session=request.getSession(); //获取其中的login的值 String login=session.getAttribute("login");&#125; 简单的例子 下面是一个简单的例子实现自动登录,在填入用户名和密码正确之后，并且勾选其中的自动登录选项，那么登录过一次后在一天之内，如果直接登录首页将会直接跳转到用户界面，实现自动登录的功能 index.jsp文件中实现的是简单的表单登录，并没有加上一些css，js,仅仅是一个例子 123456789101112131415161718192021222324252627282930313233&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort() + path + "/";%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt;&lt;head&gt;&lt;base href="&lt;%=basePath%&gt;"&gt;&lt;title&gt;My JSP 'index.jsp' starting page&lt;/title&gt;&lt;meta http-equiv="pragma" content="no-cache"&gt;&lt;meta http-equiv="cache-control" content="no-cache"&gt;&lt;meta http-equiv="expires" content="0"&gt;&lt;meta http-equiv="keywords" content="keyword1,keyword2,keyword3"&gt;&lt;meta http-equiv="description" content="This is my page"&gt;&lt;!-- &lt;link rel="stylesheet" type="text/css" href="styles.css"&gt; --&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="Demo3" method="get"&gt; &lt;label&gt;username:&lt;/label&gt;&lt;input type="text" name="username"&gt;&lt;/br&gt; &lt;label&gt;password:&lt;/label&gt;&lt;input type="password" name="password"&gt;&lt;/br&gt; &lt;label&gt;自动登录：&lt;/label&gt;&lt;input type="checkbox" name="login" value="auto"&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; Demo3.java是用户的首页，实现检测自动登录，没有加一些页面在上面，但是其实是用户的首页 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com;import java.io.BufferedReader;import java.io.File;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.PrintWriter;import java.io.Reader;import javax.servlet.RequestDispatcher;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;public class Demo3 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding("UTF-8"); response.setContentType("text/html;charset=UTF-8"); // 获取HttpSession对象 HttpSession session = request.getSession(); // 设置一天的访问时间间隔，如果超过这个时间，那么中断 session.setMaxInactiveInterval(24 * 60 * 60); // 获取转发对象，页面跳转 RequestDispatcher dispatcher = request .getRequestDispatcher("HTML/user.html"); // 获取表单的数据 String username = request.getParameter("username"); String password = request.getParameter("password"); String login = request.getParameter("login"); // 获取HttpSession中设置的属性名为login的值，如果为null，表示没有设置 String value = (String) session.getAttribute("login"); // 如果不为空，表示已经登录过一次了，并且允许自动登录，直接跳转到用户界面即可 if (value != null) &#123; // 直接跳转到用户界面 dispatcher.forward(request, response); &#125; else &#123; // 如果用户名和密码正确 if ("chenjiabing".equals(username) &amp;&amp; "123456".equals(password)) &#123; // 并且设置了自动登录 if ("auto".equals(login)) &#123; // 设置session的值 session.setAttribute("login", "auto"); &#125; response.sendRedirect("HTML/user.html"); &#125; &#125; &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 说明: user.html是用户的主页，这里没有给出，可以自己设计]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Servlet总结二(文件路径获取）]]></title>
      <url>%2F2017%2F09%2F15%2FServlet%E6%80%BB%E7%BB%93%E4%BA%8C(%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E8%8E%B7%E5%8F%96)%2F</url>
      <content type="text"><![CDATA[Servlet总结二（文件路径）前言 前面我们说过ServletContext表示的是web容器中的上下文，下面我们也是用到ServletContext中的方法读取文件 读取WebRoot文件下的文件 我们知道当我们将项目部署到Tomcat服务器中时，项目中的文件路径其实就是在Tomcat中的文件路径，所有的项目都是存储在webapps下的，我们可以看到webaapps下有两个文件夹(WEB-INF,META-INF)，这两个其实就是项目中webRoot下的两个文件夹。 public String getRealPath(String path) 为给定虚拟路径返回包含实际路径的String 12345678910111213141516 //获取ServletContext的对象ServletContext context = this.getServletContext();//context.getRealPath("/")获取项目的根目录的绝对路径(webRoot的绝对路径)//得到了webRoot的绝对路径，下面只要再接着写其他文件的路径即可File file = new File(context.getRealPath("/") + "\\WEB-INF\\lib\\file.txt");if (file.exists()) &#123; System.out.println("文件存在");&#125; else &#123; System.out.println("文件不存在，现在我们创建一个"); try &#123; file.createNewFile();// 创建一个新的文件 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; InputStream getResourceAsStream(String path) 根据传入的路径文件，返回一个InputStream对象 123456789101112 // 第一个"/"是表示webRoot的根目录，通过这个函数可以不用指定绝对路径就可以构造一个输入字节流InputStream stream = context .getResourceAsStream("/WEB-INF/lib/file.txt");// 通过InputStreamReader将字节流转换为字符流，然后创建缓冲字符流读取文件BufferedReader reader = new BufferedReader( new InputStreamReader(stream));try &#123; System.out.println(reader.readLine());&#125; catch (IOException e) &#123; System.out.println("文件没有成功读取"); e.printStackTrace();&#125; 注意：这个函数中的path传入的第一个&quot;/&quot;就表示根目录，在eclipse项目中表示webRoot的绝对路径，在Tomcat下的webapps表示项目名称的绝对路径，因此在下面的WEB-INF,META-INF文件夹下的文件只需要在后面继续添加即可 读取src下的class文件 前面我们获取的webRoot下的文件路径，但是如果我们想要获取src下的文件，那么我们要如何获取呢。 我们仔细看看Tomcat下的文件，可以发现在每一个WEB-INF下都有一个classes，这个就是相当于Tomcat下的src，因此我们利用上面得到的路径稍加修改就可以轻易的得到其中的文件路径 下面我们读取src文件夹下的file.txt中的内容，代码如下: 12345678910111213141516171819202122232425262728293031323334353637 // 获取ServletContext对象ServletContext context = this.getServletContext();// 这个是获取项目下的src文件夹下的file.txt文件File file = new File(context.getRealPath("/") + "\\WEB-INF\\classes\\file.txt");BufferedReader reader = null;if (file.exists()) &#123; System.out.println("文件存在，现在可以读取"); try &#123; // 创建缓冲流对象，实现读取文件 reader = new BufferedReader(new FileReader(file)); try &#123; // 输出第一行内容 System.out.println(reader.readLine()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; catch (FileNotFoundException e) &#123; System.out.println("文件不存在"); &#125; finally &#123; if (reader != null) &#123; try &#123; reader.close(); // 如果reader不是空，就关闭 &#125; catch (IOException e) &#123; System.out.println("文件关闭失败"); &#125; &#125; &#125;&#125; else &#123; System.out.println("文件不存在，现在开始创建一个"); try &#123; file.createNewFile();// 创建一个 &#125; catch (IOException e) &#123; System.out.println("没有创建成功"); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Eclipse配置Tomcat]]></title>
      <url>%2F2017%2F09%2F14%2FEclipse%E9%85%8D%E7%BD%AETomcat%2F</url>
      <content type="text"><![CDATA[Eclipse配置tomcatEclipse创建server 首先下载eclipse for javaEE developer 打开控制台，然后到server后右击空白处-&gt;New-&gt;Server-&gt;Apach-&gt;Tomact 7.0 -&gt;Next-&gt;添加tomcat的路径即可 ![第一步](http://ono60m7tl.bkt.clouddn.com/eclipse1.bmp 发布项目 在控制台server的空白处右击-&gt;Add and Remove-&gt;选择项目-&gt;Add-&gt;Finish 文档 javaee中英文对照文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Servlet总结一]]></title>
      <url>%2F2017%2F09%2F14%2FServlet%E6%80%BB%E7%BB%93%E4%B8%80%2F</url>
      <content type="text"><![CDATA[Servlet总结一HttpServlet 想要实现一个servlet必须继承这个类，其实一个servlet就是一个java文件，但是这个类必须是继承HttpServlet。 生命周期 servlet的生命周期是从创建到毁灭的一个过程，具体的过程如下： Servlet 通过调用 init () 方法进行初始化。 Servlet 调用 service() 方法来处理客户端的请求,但是在这一步还是要用到具体的实现的两个方法，分别是doPost(),doGet() Servlet 通过调用 destroy() 方法终止（结束）。 最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。 常用的方法 init() 初试化方法 doGet(HttpServletRequest request,HttpServletResponse response) 处理get请求的方法 doPost(HttpServletRequest request,HttpServletResponse response) 处理post请求的方法 destroy() 最后销毁 Enumeration&lt;E&gt; getInitParameterNames() 该方法从 servlet 的 ServletConfig 对象获取所有的参数名称 public String getInitParameter(String name) 该方法从 servlet 的 ServletConfig 对象获取指定参数的值 name是指定的param-name的值，返回的param-value的值，具体的使用如下： 123456789101112131415161718192021222324252627282930&lt;servlet&gt; &lt;display-name&gt;ServletConfigDemo&lt;/display-name&gt; &lt;servlet-name&gt;ServletConfigDemo&lt;/servlet-name&gt; &lt;servlet-class&gt;com.ServletConfigDemo&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; //定义的name &lt;param-value&gt;陈加兵&lt;/param-value&gt; //定义的value &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;123456&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletConfigDemo&lt;/servlet-name&gt; &lt;url-pattern&gt;/ServletConfigDemo&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; //下面只是一个servlet类中的init()方法，一般否是在init()方法中获取 public void init() throws ServletException &#123; username=this.getInitParameter("username"); //根据指定的名称获取参数的值 enumeration=this.getInitParameterNames(); //获取枚举对象 while(enumeration.hasMoreElements())&#123; //通过枚举的方法获取其中的所有的值 System.out.println(this.getInitParameter((String) enumeration.nextElement())); &#125; &#125; ServletConfig getServletConfig() 返回一个ServletConfig对象，这个方法在后面讲到ServletConfig类的时候回详细的说到 ServletContext getServletContext() 返回一个ServletContext对象，这个和ServletConfig类一样重要，在后面会详细讲解 HttpServletRequest 这是servlet容器中用来处理请求的类，并且该对象作为一个参数传给doGet,doPost方法中 常用的方法 getParameter(String name) 获取表单中的值，name是input中定义的name值，如果不存在返回null，否则返回的字符串 String[] getParameterValues(String name) 获取表单中有多个name相同的值，例如多选列表，复选框 Enumeration getParameterNames() 返回所有请求中的参数，返回的是一个枚举对象，可以通过对应的方法进行列出所有的参数 12345678910111213141516171819202122232425262728293031 //下面将会详细讲解上面三个方法的使用法，这三个参数是针对表单的，因此需要结合表单讲解，我们将会在index.jsp文件中定义表单 //index.jsp文件的内容如下： &lt;form action="ServletDemo" method="post"&gt; //servletDemo是要处理该请求的servlet的url，使用的是相对路径 username: &lt;input type="text" name="username"&gt; &lt;br&gt;Password: &lt;input type="password" name="pw"&gt; &lt;br&gt; &lt;input type="submit" value="提交"&gt; &lt;br&gt; &lt;label&gt;hobby:&lt;/label&gt; &lt;input type="checkbox" name="hobby" value="1"&gt;swing &lt;input type="checkbox" name="hobby" value="2"&gt;dancing &lt;input type="checkbox" name="hobby" value="3"&gt;song&lt;/form&gt; //下面是ServletDemo中的部分代码 String username = request.getParameter("username"); //获取username的值 String pw = request.getParameter("pw"); //获取password的值 //获取所有复选框的值 String[] hobbies=request.getParameterValues("hobby"); for(String hobby:hobbies)&#123; System.out.println(hobby); &#125; //获得所有的元素的name属性的名称，返回的是一个枚举的对象 Enumeration enumeration = request.getParameterNames(); while (enumeration.hasMoreElements()) &#123; String paramsString = (String) enumeration.nextElement(); //获取其中的每一名称 System.out.println(request.getParameter(request.getParameter)); //根据名称获取其中的值 &#125; Enumeration getHeaderNames() 获取所有请求头中的参数的名称，返回的是一个枚举对象 String getHeader(String name) 根据请求头中的名称获取对应名称的请求内容 1234567//获取所有请求头的名称，返回的是一个枚举对象 Enumeration enumeration=request.getHeaderNames(); while (enumeration.hasMoreElements()) &#123; String name=(String) enumeration.nextElement(); String value=request.getHeader(name); //根据名称返回对应的值 System.out.println(name+":"+value); &#125; String getContextPath() 获取应用程序的环境路径，就是上一级目录 String getMethod() 返回请求的方式 Get Post String getQueryString() 返回请求行中的参数部分 StringBuffer getRequestURL() 返回完整的URL String getRequestURI() 返回请求行中的资源名部分 getRemoteAddr方法返回发出请求的客户机的IP地址。 getRemoteHost方法返回发出请求的客户机的完整主机名。 getRemotePort方法返回客户机所使用的网络端口号。 getLocalAddr方法返回WEB服务器的IP地址。 getLocalName方法返回WEB服务器的主机名。 请求转发与包含 请求转发相当于一个重定向，但是这个又和重定向不同的是：请求转发是在web容器中进行的，因此浏览器的地址栏并不会改变，但是重定向是要求浏览器重新请求另一个url，因此可以在地址栏清楚的看到地址的变化 请求转发使用的是HttpServletRequest中的getRequestDispatcher方法，下面将会详细介绍 getRequestDispatcher RequestDispatcher getRequestDispatcher(String path) 返回的是一个RequestDispatcher对象，path是指定转发的url，可以是绝对url或者是相对url RequestDispatcher 定义接收来自客户端的请求并将它们发送到服务器上的任何资源（比如 servlet、HTML 文件或 JSP 文件）的对象。servlet 容器可创建 RequestDispatcher 对象，该对象被用作包装位于特定路径上的服务器资源或通过特定名称给定的服务器资源的包装器。 void forward(ServletRequest request, ServletResponse response) 执行转发请求,因为继承关系，因此其中的参数也是可以是HttpServletRequest和HttpServletResponse对象 123456789101112 public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123; request.setCharacterEncoding("UTF-8"); response.setContentType("text/html;charset=UTF-8"); //获取表单中的值 String name=request.getParameter("username"); String password=request.getParameter("password"); //上面虽然获取了其中的值，但是不可以此时对浏览器进行响应 RequestDispatcher dispatcher=request.getRequestDispatcher("Demo2"); dispatcher.forward(request, response);&#125; 注意： 在转发前后不可以对浏览器进行响应，否则会出现错误，其中forward传入的参数是当前的request和response，也就是说在转发之后的文件之中还是可以获取信息的（请求头，表单） void include(ServletRequest request, ServletResponse response) 包含转发 123456789101112131415161718public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123; request.setCharacterEncoding("UTF-8"); response.setContentType("text/html;charset=UTF-8"); //获取表单中的值 String name=request.getParameter("username"); String password=request.getParameter("password"); Cookie cookie=new Cookie("age", "22"); response.addCookie(cookie); PrintWriter pw=response.getWriter(); pw.println("在转发之前先对浏览器进行响应"); //上面可以看出这里对浏览器进行了响应，使用include可以在转发之前或者之后对浏览器进行响应 RequestDispatcher dispatcher=request.getRequestDispatcher("Demo2"); dispatcher.include(request, response); &#125; forward和include的区别 forward在转发之前和之后是不可以对浏览器进行响应的，但是include可以。使用include时，如果同时进行了响应，那么会同时响应在同一网页中，会出现在同一个页面中 相同点 请求转发后地址栏都不会出现改变 请求转发过后会重新回到当前的servlet容器中，因此如果想要在当前的servlet容器中处理一些东西是可以实现的，下面来看一个例子 1234567891011121314 public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123; request.setCharacterEncoding("UTF-8"); response.setContentType("text/html;charset=UTF-8"); //获取表单中的值 String name=request.getParameter("username"); String password=request.getParameter("password"); //上面虽然获取了其中的值，但是不可以此时对浏览器进行响应 RequestDispatcher dispatcher=request.getRequestDispatcher("Demo2"); dispatcher.forward(request, response); System.out.println(username); //这个语句当转发请求处理完成之后会返回到这里执行这句话 &#125; 传递数据 就像写到scrapy爬虫的时候，有时候一个数据会传入到下一个函数中使用，因此需要一个机制携带过去。这里可以使用HttpServletRequest中的 setAttribute方法，详细使用如下： public void setAttribute(String name, Object o) 这里其实相当于传入的是一个键值对，name是key，o是value public void removeAttribute(String name) 根据键值的name移除数据 12345678910111213141516171819202122232425262728293031323334 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 设置编码，这个是通过浏览器访问时能够实现中文显示的功能 response.setContentType("text/html;charset=UTF-8"); //设置和浏览器相应的编码方式，以便在控制台上输出中文，否则将会乱码显示 request.setCharacterEncoding("UTF-8"); String data="大家好，我是陈加兵"; request.setAttribute("data",data); //向请求中传入数据,这个是以键值对存在的，前面的是key，后面的参数是value //将请求转发给HttpServletDemo的servlet文件处理 RequestDispatcher dispatcher=request.getRequestDispatcher("HttpServletResponseDemo"); //如果转发成功，注意这里的转发，地址栏的网址并不会改变 if(dispatcher!=null)&#123; dispatcher.forward(request, response); &#125;&#125; //下面是HttpServletResponseDemo的处理代码 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html;charset=UTF-8"); //设置响应内容 request.setCharacterEncoding("UTF-8"); //设置接受的编码 //接收请求转发传递的data数据 String data=(String) request.getAttribute("data"); PrintWriter pWriter=response.getWriter(); pWriter.println(data+"&lt;br/&gt;"); //移除这个键值对 ，下面在访问这个数据就会显示不存在了 request.removeAttribute("data"); pWriter.close();&#125; HttpServletResponse 这个类是用于对浏览器进行响应的 常用的方法 PrintWriter getWriter() 返回一个PrintWriter对象，可以将字符串发送到客户端 addCookie(Cookie cookie) 将指定的cookie添加到响应中，这个是直接添加到set-cookie中，用于存储一些信息 123 Cookie cookie=new Cookie("age", "22");cookie.setMaxAge(7*24*60*60); //设置cookie的失效时间(秒为单位）response.addCookie(cookie); //添加cookie sendError(int src) 将指定的错误信息发送到客户端 比如401，302…. sendError(int sec,String message) 发送错误信息的同时，还发送提醒的信息message sendRedirect(String url) 网页重定向，url是重定向的网址，但是也可以是相对的url ServletOutputStream getOutputStream() 返回适用于在响应中编写二进制数据的 ServletOutputStream。 ServletConfig 在web.xml中对于每一个Servlet的设置web容器会为其生成一个ServletConfig作为代表对象，你可以从该对象中取得设置在web.xml中的Servlet初始参数 常用方法 String getInitParameter(String name) 根据属性的名称获取指定的值 Enumeration getInitParameterNames() 获取该servlet中设置的所有的属性的名称（并不是设置的初始值） ServletContext getServletContext() 获取ServletContext对象 设置和取得初始参数 ServletConfig相当于web.xml中个别Servlet设置代表对象，这意味着可以从ServletConfig中取得Servlet设置信息。ServletConfig定义了getInitParameter()、getInitParameterNames() 方法，可以取得设置的Servlet的初始参数 设置初始参数 直接在web.xml中定义如下： 12345678910111213141516&lt;servlet&gt; &lt;description&gt;This is the description of my J2EE component&lt;/description&gt; &lt;display-name&gt;This is the display name of my J2EE component&lt;/display-name&gt; &lt;servlet-name&gt;Demo3&lt;/servlet-name&gt; &lt;servlet-class&gt;com.Demo3&lt;/servlet-class&gt; &lt;init-param&gt; //定义标签 &lt;param-name&gt;username&lt;/param-name&gt; //定义的name &lt;param-value&gt;陈加兵&lt;/param-value&gt; //定义的value &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;123456&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; 取得初始参数 第一种方法：直接使用带有ServletConfig对象为参数的init直接获取12345678910111213141516 public void init(ServletConfig config) throws ServletException &#123;// username=config.getInitParameter("username"); //单独的获取每一个值// password=config.getInitParameter("password"); //首先获取所有的初始参数的名称 Enumeration enumeration=config.getInitParameterNames(); while(enumeration.hasMoreElements())&#123; String name=(String)enumeration.nextElement(); //获取每一个值 if(name.equals("username"))&#123; username=config.getInitParameter(name); &#125;else if (name.equals("password")) &#123; password=config.getInitParameter(name); &#125; &#125; &#125; 第二种：使用HttpServlet的getServletConfig() 方法直接获取ServletConfig对象，然后再获取参数 1234567 public void init() throws ServletException &#123; ServletConfig config=this.getServletConfig(); //获取ServletConfig对象 username=config.getInitParameter("username"); //获取参数的值 password=config.getInitParameter("password"); &#125; ServletContext ServletContext是整个web应用程序运行之后的代表对象，这是一个全局的对象，一个web项目中的所有Servlet文件都是可以共享这个数据的，因此这个有着很大的作用。 有人说这个不是和ServletConfig一样的用法吗，其实不然，ServletConfig并不是这个web程序的全局变量，它所设置的值只是对当前的servlet共享，并不能对web项目中的所有的servlet文件共享 常用方法 String getInitParameter(String name) 获取指定名称的属性值 Enumeration getInitParameterNames() 获取所有已经设置的属性的名称 void setAttribute(String name, Object object) 将对象绑定到此 servlet 上下文中的给定属性名称。如果已将指定名称用于某个属性，则此方法将使用新属性替换具有该名称的属性。 Object getAttribute(String name) 根据指定的属性名称获取绑定的值(需要进行强转) void removeAttribute(String name) 解除绑定的数据 设置初始参数 这个和ServletConfig是一样的，都是在web.xml中设置的，但是这个是设置在&lt;servlet&gt;&lt;/servlet&gt;的外面的，并不是针对单独的一个servlet来设置的，因此是全局共享的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;display-name&gt;web2&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!--全局变量，对工程中的所有的Servlet都是共享的--&gt; &lt;context-param&gt; &lt;param-name&gt;context_name&lt;/param-name&gt; &lt;param-value&gt;context_value&lt;/param-value&gt; &lt;!--在每一对context-param中只能定义一个变量的值--&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;param-value&gt;陈加兵&lt;/param-value&gt; &lt;/context-param&gt; &lt;servlet&gt; &lt;servlet-name&gt;Demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;com.Demo1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet&gt; &lt;servlet-name&gt;Demo2&lt;/servlet-name&gt; &lt;servlet-class&gt;com.Demo2&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/Demo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Demo2&lt;/servlet-name&gt; &lt;url-pattern&gt;/Demo2&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 获取设置的参数 第一种方法：使用无参初始化的方法init() ，结合父类HttpServlet的getServletContext()的方法获取ServletContext对象 1234567891011121314151617//使用无参构造函数public void init() throws ServletException &#123; ServletContext context=this.getServletContext(); //根据属性的名称获取指定的值 String value=context.getInitParameter("username"); System.out.println(value); //获取所有的属性的名称的枚举对象 Enumeration enumeration=context.getInitParameterNames(); while(enumeration.hasMoreElements())&#123; //获取属性的每一个名称 String name=(String) enumeration.nextElement(); //根据名称获取所有的值 System.out.println(name+" = "+context.getInitParameter(name)); &#125; &#125; 第二种方法：使用有参初始化方法init(ServletConfig config)，结合ServletConfig的getServletContext()方法获取对象 123456789//使用有参构造方法public void Init(ServletConfig config)&#123; //调用ServletConfig中的方法获取对象 ServletContext context=config.getServletContext(); //获取属性的值 String value=context.getInitParameter("username"); System.out.println(value); &#125; 绑定属性 有人可能会说如果想用共享数据在web.xml设置有点繁琐，这里可以直接绑定属性，然后就可以在整个web项目中共享这个绑定的属性了 123456789101112131415161718192021public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding("UTF-8"); response.setContentType("text/html;charset=UTF-8"); //获取对象（这是父类HttpServlet中的一个方法） ServletContext context=this.getServletContext(); //count表示访问页面的次数，在这里设置了属性可以全局共享该数据，意思就是在一个项目中的所有的servlet都是可以访问到该数据的 Integer count=(Integer) context.getAttribute("count"); //获取设置的属性值 //如果为空，表示该属性还没有被设置，因此这是第一次访问该页面 if(count==null)&#123; count=1; context.setAttribute("count", 1); //初始值为1，表示访问网页1次 &#125;else &#123; //否则表示已经不是第一次访问网页了，因此需要++1 context.setAttribute("count", ++count); &#125; PrintWriter pWriter=response.getWriter(); pWriter.println("该页面已经被访问了"+count+"次了......"); &#125; 参考文档 javaEE中英文对照文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[多线程的使用]]></title>
      <url>%2F2017%2F09%2F03%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[多线程前言 我看了不止一个人说多线程是鸡肋，但是就依照我个人觉得多线程在一些小型的爬虫中还是可以显著的提高速度的，相比多进程来说应该还是挺简单的 使用多线程继承threading.Thread 继承threading.Thread模块是一个很好的一个选择，就像java中也是可以继承类和实现接口一样，这都是很好的选择，下面我们来看看具体如何使用 1234567891011121314151617181920212223242526class Mythread(threading.Thread): def __init__(self,threadID,name,counter): threading.Thread.__init__(self) #首先需要先保留原来threading.Thread中的初始化函数 self.threadID=threadID #重命名线程的ID self.name=name #线程的名字 self.counter=counter #线程的数量 def run(self): lock.acquire() #获取线程锁Lock for i in range(10): print "线程"+self.name+"开始运行" lock.release() #释放线程锁Lockif __name__ == '__main__': lock=threading.Lock() t1=Mythread(0,"thread-1",3) t2=Mythread(1,"thread-2",3) t1.start() t2.start() threads=[] threads.append(t1) threads.append(t2) for t in threads: t.join() #阻塞主线程，直至线程运行完毕才运行main线程的语句 print "线程运行结束" 需要注意的是，这种继承的方式有一个缺点，这个和java中继承来实现多线程是一样的，就是一个对象只能是对应一个线程，并不能一个对象被多个线程共享，下面我们将会介绍另外的一种方式 直接调用threading.Thread 上面我们说过继承的方式，但是我个人觉得对于一些比较小的爬虫还是有些繁琐的，因为总是需要重写run方法，现在我们来看看如何简化实现多线程 12345678910"""这是一个简单的例子，其实也不是一个好的例子，但是为了演示方便就选用了，可以看出这里是直接调用了func函数，然后变成多个线程同时并行，其中target是要调用的方法(没有括号)，args是方法调用需要传入的参数其实这个还是和上面的继承比较相似的"""def func(name,age): for i in range(10): print name+"的年龄为："+str(age) t=threading.Thread(target=func,args=["陈加兵",22])t.start() Thread对象的相关方法 start() 启动线程 join([timeout]) 设置阻塞线程，timeout是可选的参数，表示阻塞的时间，如果没有就是当此线程运行结束才开始运行下一个线程 run() 线程活动的方法 getName() 获取线程名称 setName() 设置线程的名称 isAlive() 判断线程是否还活着 isDaemon() 判断是否是守护线程 setDaemon() 设置为守护线程，守护线程就是当主线程运行完后，这个线程也会随着主线程的结束而结束 共享队列 从源代码可以看出队列是实现了锁原语的，因此可以使用队列实现线程的同步，这里的主要原理就不细说了，简单的说就是get和put等方法都实现了锁原语，就是当一个操作正在执行的时候其他的操作会阻塞等待 下面我自己写了一个使用两个线程实现同时入队和出队的程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import randomimport timefrom Queue import Queueclass myThread(threading.Thread): def __init__(self,threadID,name,counter,q,flag): """ threadID是线程的ID name是线程的名称 q是先进先出队列 flag是用来调用get和put的标志 """ threading.Thread.__init__(self) self.name=name self.threadID=threadID self.counter=counter self.q=q self.flag=flag def run(self): """ 当flag为1时就调用put方法，否则调用get """ if self.flag==1: self.put() else: self.get() def put(self): while True: self.q.put(random.randint(0,10)) def get(self): while True: if not self.q.empty(): print self.q.get() if __name__=="__main__": threadLock=threading.Lock() q=Queue() t1=myThread(1,"Thread-1",1,q,1) t2=myThread(2,"Thread-2",2,q,2) threads=[] threads.append(t1) threads.append(t2) t1.start() t2.start() Queue相关的一些方法 Queue.qsize() 返回队列的大小 Queue.empty() 如果队列为空，返回True,反之False Queue.full() 如果队列满了，返回True,反之False Queue.full 与 maxsize 大小对应 Queue.get([block[, timeout]])获取队列，timeout等待时间 Queue.get_nowait() 相当Queue.get(False) Queue.put(item) 写入队列，timeout等待时间 Queue.put_nowait(item) 相当Queue.put(item, False) Queue.task_done() 在完成一项工作之后， Queue.task_done()函数向任务已经完成的队列发送一个信号 Queue.join() 实际上意味着等到队列为空，再执行别的操作]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[os模块中常用的的方法]]></title>
      <url>%2F2017%2F09%2F02%2Fos%E6%A8%A1%E5%9D%97%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[os模块中常用的方法常用的方法 os.getcwd() 获取当前的路径os.listdir(path) 获取path路径下的全部文件和文件夹，就是显示全部的文件的作用os.mkdir(path) 创建一个文件夹os.rmdir(path) 删除一个文件夹os.remove(path) 删除一个文件os.rename(path1,path2) 将文件或者文件夹重命名，path1是原来件路径，path2是改变后的文件的路径名称os.makedirs(path) 循环创建文件夹，给出一个路径，连续的创建这个路径的全部文件夹，并不是创建文件os.removedirs(path) 循环删除文件夹 会删除整个路径的文件夹os.path.abspath(path) 返回此文件的绝对路径os.path.exists(path) 判断文件或者文件夹是否存在os.path.basename(path) 返回绝对路径中的文件名os.path.normpath(path) 标准化文件路径，Windows下将双斜杠变成单斜杠os.path.commonprefix(list) 返回list中的相同的路径，只是多个路径相同的部分os.path.dirname(path) 返回文件所在上面一层的目录的名称，注意这里是所在紧接着一层的文件夹的名称os.path.split(path) 将路径分割成两个部分，返回的是一个元祖，第一个元素是前面的路径，第二个元素是文件的名称os.path.getatime(path) 返回文件的最后访问时间os.path.getmtime(path) 返回文件的最后修改时间os.path.getctime(path) 在unix的系统上返回的是文件最后修改的时间，在window的系统上返回的是文件的创建时间os.path.getsize(path) 返回文件的大小，以字节为单位os.path.isfile(path) 判断文件是否是文件os.path.isdir(path) 判断文件是否是文件夹os.path.join(path1,path2) 将两个文件的路径拼接在一起 例子 其中的每个方法的例子请点击这里]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python操作MongoDB]]></title>
      <url>%2F2017%2F07%2F09%2Fpython%E6%93%8D%E4%BD%9CMongoDB%2F</url>
      <content type="text"><![CDATA[python操作MongoDB前言 下面推荐本人写的MongoDB的基本操作博文，介绍的还是比较详细的，喜欢的朋友可以去看看 MongoDB干货篇之安装 MongoDB干货篇之查询数据 MongoDB干货篇之更新数据 综合应用 下面是自己写的一个简单的操作，分别对应了增删改查，虽然不太全面，但是只是简单的示范了一下，当然更多的功能还是需要自己去完善的，因为代码中都有注释，这里就不再详细的说了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# coding:utf-8import pymongoclass MongoDB: def __init__(self,db,collections): """ 初始化数据库 :param db:数据库名称 :param collections: 数据库的集合的名称 """ self.client = pymongo.MongoClient('localhost', 27017) #获取的连接 self.db = self.client[db] #创建数据库db self.post = self.db[collections] #创建或者选择要操作的集合 def update(self, data,upsert): """ 更新数据库中的数据，如果upsert为Ture，那么当没有找到指定的数据时就直接插入，反之不执行插入 :param data: 要插入的数据 :param upsert: 判断是插入还是不插入 :return: """ self.post.update(&#123;"ip": data&#125;, &#123;'$set': &#123;'ip': data&#125;&#125; , upsert) def find(self,select): """ 根据传入的参数查找指定的值，注意这里的select是字典 :param select: 指定的查找条件，这里的是字典类型的，比如&#123;"name":"chenjiabing","age":22&#125; :return: 返回的是查询的结果，同样是字典类型的 """ return self.post.find(select) def insert(self,data): """ 向数据库中插入指定的数据 :param data: 要插入的数据，这里的是字典的类型比如：&#123;"name":"chenjiabing","age":22&#125; :return: 插入成功返回True,反之返回false """ try: self.post.insert(data) return True except: return False def remove(self,select): """ 删除指定条件的记录 :param select: 指定的条件，这里是字典类型的，比如&#123;"age":22&#125; 表示删除age=22的所有数据 :return: 如果删除成功返回True，else返回False """ try: self.post.remove(select) return True except: return False 下面是利用上面的Mongo.py文件获取西刺网站的代理并且存入数据库 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# coding:utf-8import requestsfrom bs4 import BeautifulSoupimport timefrom Queue import Queueimport threadingfrom Mongo import MongoDB #导入文件class XICI: def __init__(self, page): """ self.header:请求头 self.q:存储ip的队列 slef.urls:页面的url :param page:传入的参数，表示获取多少页的ip """ self.header = &#123;"User-Agent": 'Mozilla/5.0 (Windows NT 6.3; WOW64; rv:43.0) Gecko/20100101 Firefox/43.0'&#125; self.q = Queue() self.urls = [] for i in range(1, page + 1): self.urls.append("http://www.xicidaili.com/nn/" + str(i)) self.mongo = MongoDB('python','ip') # 创建MogoDB对象 def get_ips(self, url): """ 根据一页的请求爬取一个页面的ip :param url:传入的参数，表示每一页的链接 :return: None """ try: res = requests.get(url, headers=self.header) if res.status_code == 200: soup = BeautifulSoup(res.text, 'lxml') ips = soup.find_all('tr') for i in range(1, len(ips)): ip = ips[i] tds = ip.find_all("td") ip_temp = "http://" + tds[1].contents[0] + ":" + tds[2].contents[0] print ip_temp self.q.put(ip_temp) # ip进入队列 except: print "-------------------------------------------请求出现异常------------------------------------------------" def insert(self, url): """ 验证出过来的ip，如果成功就直接存入数据库 :param url: 验证ip地址的url :return: 无返回值 """ while not self.q.empty(): ip = self.q.get() proxy = &#123;"http": ip&#125; print proxy try: res = requests.get(url, headers=self.header, proxies=proxy, timeout=5) if res.status_code == 200: self.mongo.update(ip,True) # 如果成功验证直接进入数据库 print "**************************成功存入数据库********************************************" else: print "这个ip地址不能用" except: print "--------------------------请求失败---------------------------------------------" def main(self): for url in self.urls: self.get_ips(url) threads = [] for i in range(5): t=threading.Thread(target=self.insert,args=["http://blog.csdn.net/qq_34162294/article/details/72353389"]) threads.append(t) for t in threads: t.start()if __name__ == '__main__': p = XICI(3) p.main()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Numpy指南]]></title>
      <url>%2F2017%2F07%2F01%2FNumpy%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[numpy指南 numpy是一个能够处理多维数组的库，虽然python中也内置了处理数组的库，但是这个并不能满足大数据时代的需求，因此产生了可以处理多维数组的numpy 安装 pip install numpy 创建array array函数是一个最基本的创建方式，其中传入的参数是一个序列，既可以创建一维数组，也可以创建二维数组，但是这种方法不太灵活，因为你要把这个序列显式的写出来，先不多说了，自己体会吧 123456import numpy as npa=np.array([1,2,3,4,5]) #创建一个二维数组b=np.array([[1,2,3,4],[2,3,4,5]]) #创建一个二维数组print a.shape #输出数组的维度，(5,)print b.shape #(2,4) arange arange(start,end,step) 创建一个一维数组，起始值为start，终值为end，步长为step，其中np.arrange(10) 表示起始值为0，终值为10，步长为1 12a=np.arange(0,10,1) b=np.arange(10) reshape reshape(a,b)能过改变当前数组的尺寸将其赋值给新的数组，但是当前数组并没有改变，这个用来改变当前数组的维度，可以将以为数组改变为二维数组 123a=np.arange(10) #创建一个有10个元素的一维数组b=np.reshape(2,5) #将改变后的当前数组赋值给b，但是a数组并没有改变 ，2*5=10c=np.reshape(5,-1) #第一个参数为5行，第二个-1表示自动计算生成，10/5=2 linspace linspace(start,end,number) 创建一个等距离的数组，start是起始值，end是终值，number是个数，创建的是一个一维数组，其中的元素全部是浮点数，默认的是包括终值的，但是可以通过endpoint=False指定不包括终值 12a=np.linspace(0,10,10) #包含10的一个等差数组b=np.linspace(0,10,10,endpoint=False) #不包含10的一个等差数组 logspace logspace(start,end,number) 创建的是在10^start和10^end之间包含number个元素的等比数组，创建的是一个等比数组 1a=np.logspace(0,1,10) #创建一个在1-10之间的10个元素的等比数组 存取数据下标存取123456789a=np.arange(10) #[0,1,2,3,4,5,6,7,8,9]a[0] #获取第一个元素的值1a[0:2] #获取下标我0,1的值，注意不包括2a[0:10:1] # 获取下标在0-10之间的(包括0,不包括9)，步长为1的元素，就是每隔一个区娶一个a[1:] #获取从第二个元素开始到最后的所有的元素a[:8] #获取下标为0-8之间的元素(不包括8)a[1::1] #获取下标为0到最后并且步长为1的所有元素a[8:4:-1] #获取起始下标为8，终止下标为4，并且步长为-1，这是从后向前获取元素a[::-1] #将数组逆置 使用整数序列 当使用整数序列对数组元素进行存取时，将使用整数序列中的每个元素作为下标，整数序列可以是列表或者数组。使用整数序列作为下标获得的数组不和原始数组共享数据空间。 12x = np.arange(10,1,-1) x[[3, 3, 1, 8]] # 获取x中的下标为3, 3, 1, 8的4个元素，组成一个新的数组 ufunc ufunc是universal function的缩写，它是一种能对数组的每个元素进行操作的函数。NumPy内置的许多ufunc函数都是在C语言级别实现的，因此它们的计算速度非常快. 12345678910111213np.sin(x) #对数组中的每一个值进行sin操作，并且返回一个数组np.sin(x,y) #对数组x中的值进行sin操纵，所得结果返回给y，但是也返回一个结果数组，这个数组和y共享一块空间的np.add(a,b) #将两个数组中的对应的值都相加，返回的是一个新的数组np.add(a,b,c) # 将两个数组中对应的值相加，结果复制给c，并且返回一个新的数组np.subtract(a,b) # 两个数组相减，a-b,返回的是一个新的数组np.subtract(a,b,c) np.multiply(a,b) #相乘np.multiply(a,b,c) #相乘divide(a,b,[,y]) #相除，如果是两个整数相除，那么返回的是整数true_divide(a,b,[,y]) #相除，总是返回精确的商floor_divide(a,b,[,y]) #总是对返回值取整power(a,b,[,y]) # a^b 平方mod(a,b,[,y]) #取余 %]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lock]]></title>
      <url>%2F2017%2F06%2F22%2FLock%2F</url>
      <content type="text"><![CDATA[Lock 在上一篇文章中我们讲到了如何使用关键字synchronized来实现同步访问。本文我们继续来探讨这个问题，从Java 5之后，在java.util.concurrent.locks包下提供了另外一种方式来实现同步访问，那就是Lock。 也许有朋友会问，既然都可以通过synchronized来实现同步访问了，那么为什么还需要提供Lock？这个问题将在下面进行阐述。本文先从synchronized的缺陷讲起，然后再讲述java.util.concurrent.locks包下常用的有哪些类和接口，最后讨论以下一些关于锁的概念方面的东西 synchronized缺陷 前面我们说过synchronized的线程释放锁的情况有两种: 代码块或者同步方法执行完毕 代码块或者同步方法出现异常有jvm自动释放锁 从上面的synchronized释放锁可以看出，只有synchronized代码块执行完毕或者异常才会释放，如果代码块中的程序因为IO原因阻塞了，那么线程将永远不会释放锁，但是此时另外的线程还要执行其他的程序，极大的影响了程序的执行效率，现在我们需要一种机制能够让线程不会一直无限的等待下去，能够响应中断，这个通过lock就可以办到 另外如果有一个程序，包含多个读线程和一个写线程，我们可以知道synchronized只能一个一个线程的执行，但是我们需要多个读线程同时进行读，那么使用synchronized肯定是不行的，但是我们使用lock同样可以办到 Lock 查看API可知，Lock是一个接口，因此是不可以直接创建对象的，但是我们可以利用其实现的类来创建对象，这个先不着急，我们先看看Lock类到底实现了什么方法,具体的实现我们将会在介绍其实现的类的时候再详细的讲解 方法 lock() 获取锁，如果没有获得就会一直等待 unlock() 释放锁 tryLock() 尝试获得锁，如果成功获得锁就执行，如果没有成功获得锁，那么就不会等待了 lockInterruptibly() 如果当前线程未被中断，则获取锁。 ReentrantLock ReentrantLock是可重入锁，是实现Lock接口的一个类，可重入是一种线程的分配机制，可重入的意思就是总是分配给最近获得锁的线程，这是一种不公平的分配机制，将会出现饥饿现象，当然为了解决这种现象，ReentrantLock的构造方法还提供了一个fair参数，如果fair为true表示使用公平分配机制，将会有等待时间最长的线程获得锁 构造方法 ReentrantLock() 创建一个对象，默认使用的时可重入的机制 ReentrantLock(boolean fair) 如果fair为true那么使用的是公平分配机制 常用方法 lock() 获取锁，如果没有获取到将会一直阻塞 下面使用一段程序演示以下lock方法的使用，代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344//实现接口的线程类public class MyThread implements Runnable &#123; public ReentrantLock rLock = null; //注意这里的锁一定要是全局变量，否则每一个线程都创建一把锁，那么将会毫无意义 public MyThread() &#123; this.rLock = new ReentrantLock(); // 创建默认的可重入锁 &#125; // 将unlock方法放在finally中确保执行中代码出现异常仍然能够释放锁，否则将会造成其它的线程阻塞 public void display() &#123; this.rLock.lock(); // 获取锁 try &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(Thread.currentThread().getName() + "正在输出" + i); &#125; &#125; finally &#123; this.rLock.unlock(); // 释放锁，注意这步是一定需要的 &#125; &#125; @Override public void run() &#123; this.display(); // 调用display方法 &#125;&#125;//线程的测试类，主要是创建对象启动线程public class Test &#123; public static void main(String[] args) &#123; final MyThread thread = new MyThread(); // 创建对象 // 下面创建两个线程,并且直接启动， new Thread(thread).start(); new Thread(thread).start(); &#125;&#125; 执行上面的代码得到下图的结果: 从上面的结果看出，线程是一个一个输出的，并且只有等待一个线程输出完毕才能执行下一个线程，这里的仅仅是针对lock和unlock之间的代码，之外的代码并不是受到控制 注意： 这里的创建的可重入锁的对象必须对于每一个线程来说是全局的变量，是可以共享的一个对象，如果你在display方法中创建这个对象，那么是毫无意义的，因为每一个线程用的根本不是同一把锁 boolean tryLock() 首先尝试获取锁，如果获取锁了就执行，否则就不会一直等待 下面使用一段代码尝试以下这个方法，代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//实现接口的线程类public class MyThread implements Runnable &#123; public ReentrantLock rLock = null; // 注意这里的锁一定要是全局变量，否则每一个线程都创建一把锁，那么将会毫无意义 public MyThread() &#123; this.rLock = new ReentrantLock(); // 创建默认的可重入锁 &#125; // 将unlock方法放在finally中确保执行中代码出现异常仍然能够释放锁，否则将会造成其它的线程阻塞 public void display() &#123; if (this.rLock.tryLock()) // 如果获取了锁 &#123; try &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(Thread.currentThread().getName() + "正在输出" + i); &#125; &#125; finally &#123; this.rLock.unlock(); // 释放锁，注意这步是一定需要的 &#125; &#125; else &#123; System.out.println(Thread.currentThread().getName() + "获取锁失败，我将不会一直等待........"); &#125; &#125; @Override public void run() &#123; this.display(); // 调用display方法 &#125;&#125;//线程的测试类，主要是创建对象启动线程public class Test &#123; public static void main(String[] args) &#123; final MyThread thread = new MyThread(); // 创建对象 // 下面创建两个线程,并且直接启动， new Thread(thread).start(); new Thread(thread).start(); &#125;&#125; 执行后的结果如下图: 从上面的结果我们知道线程0获取了锁开始执行，但是线程1并没有获取锁，但是使用的是tryLock并不是lock,因此不会一直等待下去，所以直接程序向下运行，直接跳过上锁的代码段，因此就输出了上面的那句话后直接结 ReadWriteLock 从API中可以知道，这个也是一个接口，用于实现读写线程，他有两个方法：Lock readLock(),Lock writeLock() 分别用于获得读锁和写锁，指定特定的锁可以实现特定的功能，比如读锁可以在写线程在执行的情况下可以实现多个读线程进行操作，下面我们来介绍它的具体的实现的类ReentrantReadWriteLock ReentrantReadWriteLock 这个类也是一个可重入分配的类，当然前面已经说过了什么是可重入，现在我们来说说说这个类的详细的用法 构造方法 ReentrantReadWriteLock() 使用默认（非公平）的排序属性创建一个新的 ReentrantReadWriteLock。 ReentrantReadWriteLock(boolean fair) 使用给定的公平策略创建一个新的ReentrantReadWriteLock。 常用的方法 ReentrantReadWriteLock.ReadLock readLock() 用于返回读取操作的锁 前面已经说过读取操作的锁是用来实现多个线程共同执行的，代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//实现接口的线程类public class MyThread implements Runnable &#123; public ReentrantReadWriteLock rwlock = null; public Lock rLock = null; public MyThread() &#123; this.rwlock = new ReentrantReadWriteLock(); // 创建对象，使用的是非公平的 this.rLock = this.rwlock.readLock(); // 获取读取锁对象 &#125; // 将unlock方法放在finally中确保执行中代码出现异常仍然能够释放锁，否则将会造成其它的线程阻塞 public void display() &#123; this.rLock.lock(); // 获取读取锁 try &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(Thread.currentThread().getName() + "正在输出" + i); &#125; &#125; finally &#123; this.rLock.unlock(); // 释放锁，注意这步是一定需要的 &#125; &#125; @Override public void run() &#123; this.display(); // 调用display方法 &#125;&#125;//线程的测试类，主要是创建对象启动线程public class Test &#123; public static void main(String[] args) &#123; final MyThread thread = new MyThread(); // 创建对象 // 下面创建两个线程,并且直接启动， for(int i=0;i&lt;5;i++) &#123; new Thread(thread).start(); &#125; &#125;&#125; 执行上面的程序结果如下: 从上面的结果可以知道，其实使用读取操作是多个线程同时进行读取的操作，因此一定要小心谨慎的使用，根据自己的需求，一般不能在里面进行修改了，因为出现结果不准确的结果，这个就不多说了，相信大家都明白，总之要小心使用 ReentrantReadWriteLock.WriteLock writeLock() 返回用于写入操作的锁 写入操作的锁和读取操作的锁不一样了，因为一次只能允许一个线程执行写入操作。 并且如果一个线程已经占用了读锁，另外一个线程申请写锁将会一直等待线程释放读锁。 如果一个线程已经占用了写锁，另外一个线程申请读锁，那么这个线程将会一直等待线程释放写锁才能执行。 总之意思就是写线程和读线程不能同时执行，但是多个读线程可以同时执行 下面将使用一个程序详细的体会以下读写锁的综合使用，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//实现接口的线程类public class MyThread &#123; public ReentrantReadWriteLock rwlock = null; public Lock rLock = null; public Lock wLock = null; public ArrayList&lt;Integer&gt; arrayList = null; public MyThread() &#123; this.rwlock = new ReentrantReadWriteLock(); // 创建对象，使用的是非公平的 this.rLock = this.rwlock.readLock(); // 获取读取锁对象 arrayList = new ArrayList&lt;&gt;(); // 实例化 this.wLock = this.rwlock.writeLock(); // 获取写入锁对象 &#125; // 将unlock方法放在finally中确保执行中代码出现异常仍然能够释放锁，否则将会造成其它的线程阻塞 // //向arraylist中写入数据 public void put() &#123; this.wLock.lock(); // 获取写入锁 try &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(Thread.currentThread().getName() + "正在执行写入操作，写入" + i); this.arrayList.add(i); &#125; &#125; finally &#123; this.wLock.unlock(); &#125; &#125; // 从arraylist中读取数据，这里只是随机读取使用的是get，并没有做什么修改，因为这仅仅是读取操作，如果进行了修改必须实现同步 public void get() &#123; this.rLock.lock(); // 获取读取操作的锁 Random random = new Random(); if (!arrayList.isEmpty()) &#123; try &#123; for (int i = 0; i &lt; 10; i++) &#123; int index = random.nextInt(this.arrayList.size() - 1); int data = this.arrayList.get(index); System.out.println(Thread.currentThread().getName() + "正在读取数据 " + data); &#125; &#125; finally &#123; this.rLock.unlock(); &#125; &#125; else &#123; System.out.println("ArrayList为空"); &#125; &#125;&#125;//线程的测试类，主要是创建对象启动线程public class Test &#123; public static void main(String[] args) &#123; final MyThread thread = new MyThread(); // 创建对象 ArrayList&lt;Thread&gt; arrayList = new ArrayList&lt;&gt;(); /* * 创建8个读线程，2个写线程 */ for (int i = 0; i &lt; 2; i++) &#123; arrayList.add(new Thread() &#123; @Override public void run() &#123; thread.put(); &#125; &#125;); &#125; for(int i=0;i&lt;8;i++) &#123; arrayList.add(new Thread()&#123; @Override public void run() &#123; thread.get(); &#125; &#125;); &#125; for (Thread t : arrayList) &#123; t.start(); &#125; &#125;&#125; 结果如下图: 从上面可以看出写入线程都是一个一个执行的，读取线程是一起执行的 注意： 所有的锁对象对于线程来说必须是全局变量，否则毫无意义。读线程只能进行不影响线程安全性的操作，比如不能进行对数据的修改插入，如果想要进行修改的话必须还要使用锁对必要的代码实现同步操作 参考文章 http://www.cnblogs.com/dolphin0520/p/3923167.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[synchronized]]></title>
      <url>%2F2017%2F06%2F20%2Fsynchronized%2F</url>
      <content type="text"><![CDATA[synchronized前言 相信大家都听说过线程安全问题，在学习操作系统的时候有一个知识点是临界资源，简单的说就是一次只能让一个进程操作的资源，但是我们在使用多线程的时候是并发操作的，并不能控制同时只对一个资源的访问和修改，想要控制那么有几种操作，今天我们就来讲讲第一种方法：线程同步块或者线程同步方法(synchronized) 实例 下面举一个例子说明synchronized关键字的使用 线程同步方法123456789101112131415161718192021222324252627public class Sychor &#123; public void insert(Thread thread) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(thread.getName() + "输出: " + i); &#125; &#125; public static void main(String[] args) &#123; final Sychor sychor = new Sychor(); Thread t1 = new Thread() &#123; public void run() &#123; sychor.insert(Thread.currentThread()); &#125;; &#125;; Thread t2 = new Thread() &#123; public void run() &#123; sychor.insert(Thread.currentThread()); &#125;; &#125;; t1.start(); t2.start(); &#125;&#125; 其中输出结果为下图 从上面的结果可以看出这里的两个线程是同时执行insert()方法的，下面我们在原有的代码上添加synchronized关键字看看效果如何，代码如下:123456789101112131415161718192021222324252627public class Sychor &#123; public synchronized void insert(Thread thread) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(thread.getName() + "输出: " + i); &#125; &#125; public static void main(String[] args) &#123; final Sychor sychor = new Sychor(); Thread t1 = new Thread() &#123; public void run() &#123; sychor.insert(Thread.currentThread()); &#125;; &#125;; Thread t2 = new Thread() &#123; public void run() &#123; sychor.insert(Thread.currentThread()); &#125;; &#125;; t1.start(); t2.start(); &#125;&#125; 上面程序的运行结果我就不列出来，自己可以试试，总之就是加上了synchronized关键字使得线程是一个一个的执行的，只有先执行完一个线程才能执行了另外一个线程。 线程同步块 当然上面的我们使用的是线程同步方法，我们可以使用线程同步块，这两个相比线程同步块更加灵活，只需要将需要同步的代码放在同步块中即可，代码如下；12345678910111213141516171819202122232425262728293031public class Sychor &#123; public void insert(Thread thread) &#123; synchronized (this) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(thread.getName() + "输出: " + i); &#125; &#125; &#125; public static void main(String[] args) &#123; final Sychor sychor = new Sychor(); Thread t1 = new Thread() &#123; public void run() &#123; sychor.insert(Thread.currentThread()); &#125;; &#125;; Thread t2 = new Thread() &#123; public void run() &#123; sychor.insert(Thread.currentThread()); &#125;; &#125;; t1.start(); t2.start(); &#125;&#125; 从上面的代码中可以看出这种方式更加灵活，只需要将需要同步的代码方法在同步块中，不需要同步的代码放在外面 详细原因 我们知道每一个对象都有一把锁，当我们使用线程同步方法或者线程同步块的时候实际上获得是对象的唯一的一把锁，当一个线程获得了这唯一的锁，那么其他的线程只能拒之门外了，注意这里我们说是一个对象，也就是说是同一个对象，如果是不同的对象，那么就不起作用了，因为不同对象有不同的对象锁，比如我们将上面的程序改成如下：123456789101112131415161718192021222324252627282930313233public class Sychor &#123; public void insert(Thread thread) &#123; synchronized (this) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(thread.getName() + "输出: " + i); &#125; &#125; &#125; public static void main(String[] args) &#123; //第一个线程 Thread t1 = new Thread() &#123; public void run() &#123; Sychor sychor = new Sychor(); //在run() 方法中创建一个对象 sychor.insert(Thread.currentThread()); &#125;; &#125;; //第二个线程 Thread t2 = new Thread() &#123; public void run() &#123; Sychor sychor = new Sychor(); //创建另外的一个对象 sychor.insert(Thread.currentThread()); &#125;; &#125;; t1.start(); t2.start(); &#125;&#125; 从上面的结果可知，此时线程同步块根本不起作用，因为他们调用的是不同对象的insert方法，获得锁是不一样的 上面我们已经说过一个对象有一把锁，线程同步方法和线程同步块实际获得的是对象的锁，因此线程同步块的括号中填入的是this，我们都知道this在一个类中的含义 一个类也有唯一的一把锁，我们前面说的是使用对象调用成员方法，现在如果我们要调用类中的静态方法，那么我们可以使用线程同步方法或者同步块获得类中的唯一一把锁，那么对于多个线程同时调用同一个类中的静态方法就可以实现控制了,代码如下:1234567891011121314151617181920212223242526272829public class Sychor &#123; // 静态方法 public static synchronized void insert(Thread thread) &#123; for(int i=0;i&lt;10;i++) &#123; System.out.println(thread.getName()+"输出 "+i); &#125; &#125; public static void main(String[] args) &#123; //第一个线程 Thread t1 = new Thread() &#123; public void run() &#123; Sychor.insert(Thread.currentThread()); //直接使用类调用静态方法 &#125;; &#125;; //第二个线程 Thread t2 = new Thread() &#123; public void run() &#123; Sychor.insert(Thread.currentThread()); //直接使用类调用静态方法 &#125;; &#125;; t1.start(); t2.start(); &#125;&#125; 为静态方法或者静态方法中的代码块加上同步锁 上面使用对象锁是为非静态方法实现线程同步的，因为我们在调用非静态方法的时候需要创建对象，因此这里使用的是对象锁。但是我们调用静态方法的时候直接使用的是类名直接调用，并没有用到对象，因此我们需要用到类锁，直接使用类名.class获取即可。 123456789public class myThread&#123; public static void display()&#123; synchronized(myThread.class)&#123; for(int i=0;i&lt;10;i++)&#123; System.out.println(i); &#125; &#125; &#125;&#125; 注意 要想实现线程安全和同步控制，如果执行的是非static同步方法或者其中的同步块，那么一定要使用同一个对象，如果调用的是static同步方法或者其中的同步块那么一定要使用同一个类去调用 如果一个线程访问的是static同步方法，而另外一个线程访问的是非static的同步方法，此时这两个是不会发生冲突的，因为一个是类的锁，一个是对象的锁 如果使用线程同步块，那么同步块中的代码是控制访问的，但是外面的代码是所有线程都可以访问的 当一个正在执行同步代码块的线程出现了异常，那么jvm会自动释放当前线程所占用的锁，因此不会出现由于异常导致死锁的现象 参考文章 http://www.cnblogs.com/dolphin0520/p/3923737.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Thread初探]]></title>
      <url>%2F2017%2F06%2F20%2FThread%E5%88%9D%E6%8E%A2%2F</url>
      <content type="text"><![CDATA[Thread初探前言 以前大家写的都是单线程的程序，全是在main函数中调用方法，可以清楚的看到它的效率是特别低的，就像python中使用单线程取爬一个网站，可以说能让你等的吐血，因为数据量实在太大了，今天我们就来看看java的并发编程多线程的学习 创建线程 创建一个线程可以有多种方法，比如继承Thread类，实现Runnable接口……下面我们来详细的看看创建的方法 继承Thread 为什么继承Thread可以直接调用start()方法启动线程呢，因为start()本身就是Thread的方法，也就是继承了Thread的start()方法，因此这个类的对象可以调用start()启动线程 12345678910111213141516//继承Threadpublic class MyThread extends Thread &#123; public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(this.getName()+"正在跑"); &#125; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Mythread t1=new MyThread(); //创建对象 t1.start(); //启动线程 &#125;&#125; 注意: 继承Thread类的创建方法一个对象只能创建一个线程，并不能多个线程共用一个对象，只能一个线程对应一个对象，因此我们来看看实现Runnable接口的类来实现多个线程共享同一个对象 实现Runnable接口12345678910111213141516171819202122232425//实现Runnable接口public class Demo implements Runnable &#123; @Override public void run() &#123; for(int i=0;i&lt;10;i++) &#123; System.out.println(Thread.currentThread().getName()+"正在跑"); &#125; &#125;&#125;//测试类public class Test&#123; public static void main(String[] args) &#123; Demo d=new Demo(); //创建对象 Thread thread1=new Thread(d); //为对象创建一个线程 Thread thread2=new Thread(d); //创建另外一个线程 //同时启动两个线程 thread1.start(); thread2.start(); &#125;&#125; 从上面可以清楚的看到实现Runnable接口的类一个对象可以供多个线程共享，并不像继承Thread类只为一个线程使用 简便的创建方法 直接在main方法中创建，如果创建的普通类的对象在外面，那么必须是final修饰，可以实现多个线程同时共享一个对象，这个和实现Runnable接口一样，这时候就要控制同步条件了，如果在run方法中定义对象，那么，就是一个线程对应一个对象,这个就和继承Thread类一样的效果。所以可以根据条件自由选择 123456789101112131415161718192021222324252627282930313233343536373839//普通的一个类public class Simple &#123; public void display() &#123; for(int i=0;i&lt;10;i++) &#123; System.out.println(Thread.currentThread().getName()+"正在跑"); &#125; &#125;&#125;//线程测试类public class Test &#123; public static void main(String[] args) &#123; //如果在外面必须使用final，当然也可以直写在run方法中,不过写在外面可以实现多个线程共享一个对象 //写在run方法中当前对象只能为一个线程使用，和继承Thread类一样的效果 final Simple simple=new Simple(); //下面创建使用同一个对象创建同两个线程，实现多个线程共享一个对象，和实现Runnable接口一样的效果 Thread t1=new Thread()&#123; public void run() &#123; simple.display(); &#125;; &#125;; Thread t2=new Thread()&#123; public void run() &#123; simple.display(); &#125;; &#125;; //启动这两个线程 t1.start(); t2.start(); &#125;&#125; 常用的方法 static void sleep(long mils) 使正在运行的线程休眠mils毫秒，但是这里需要注意的是如果线程加了锁，那么使线程休眠并不会释放锁 String getName() 得到线程的名称，上面的程序中已经使用了这个方法 void setName(String name) 设置正在运行的线程的名字为name start() 启动线程，线程的创建并不意味着线程的启动，只有调用start()方法线程才是真正的开始运行 long getId() 返回线程的标识符 run() 线程执行的代码都放在run()方法中，在run方法中的调用是有序的，都是按照程序运行的顺序开始执行 使用 下面使用上面的方法创建一个实例 123456789101112131415161718192021222324252627282930313233343536//线程的类，继承Threadpublic class MyThread1 extends Thread &#123; public void run() &#123; // 重载run方法，并且在其中写线程执行的代码块 for (int i = 0; i &lt; 10; i++) &#123; // 获取线程的id和name System.out.println("Thread-Name: " + this.getName() + " Thread-id: " + this.getId()); try &#123; this.sleep(1000); // 线程休眠1秒 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;//线程测试的类public class Test &#123; public static void main(String[] args) &#123; MyThread1 t1 = new MyThread1(); // 创建线程 t1.setName("第一个线程"); // 设置线程的名字 MyThread1 t2 = new MyThread1(); t2.setName("第二个线程"); t1.start(); // 启动线程，开始运行 t2.start(); &#125;&#125; void join() 等待该线程终止才能运行其他的线程 void join(long mils) 等待该线程的时间为mils毫秒，一旦过了这个时间其他线程正常执行 使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//线程类public class MyThread1 extends Thread &#123; public void run() &#123; // 重载run方法，并且在其中写线程执行的代码块 for (int i = 0; i &lt; 10; i++) &#123; // 获取线程的id和name System.out.println("Thread-Name: " + this.getName() + " Thread-id: " + this.getId()); try &#123; this.sleep(1000); // 线程休眠1秒 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;//测试类public class Test &#123; public static void main(String[] args) &#123; MyThread1 t1 = new MyThread1(); // 创建线程 t1.setName("第一个线程"); // 设置线程的名字 t1.start(); // 启动线程，开始运行 try &#123; t1.join(); //阻塞其他线程，只有当这个线程运行完之后才开始运行其他的线程 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; for (int i = 0; i &lt; 10; i++) &#123; System.out.println("主线程正在运行"); &#125; &#125;&#125;//输出结果/*Thread-Name: 第一个线程 Thread-id: 9Thread-Name: 第一个线程 Thread-id: 9Thread-Name: 第一个线程 Thread-id: 9Thread-Name: 第一个线程 Thread-id: 9Thread-Name: 第一个线程 Thread-id: 9Thread-Name: 第一个线程 Thread-id: 9Thread-Name: 第一个线程 Thread-id: 9Thread-Name: 第一个线程 Thread-id: 9Thread-Name: 第一个线程 Thread-id: 9Thread-Name: 第一个线程 Thread-id: 9主线程正在运行主线程正在运行主线程正在运行主线程正在运行主线程正在运行主线程正在运行主线程正在运行主线程正在运行主线程正在运行主线程正在运行 */ getPriority() 得到当前线程优先级 setPriority(int num) 更改线程的优先级(0-10)默认的是5，优先级越高获得cpu资源的几率就会越高 使用1234567891011121314151617181920212223242526272829303132333435363738394041//线程类public class MyThread1 extends Thread &#123; public void run() &#123; // 重载run方法，并且在其中写线程执行的代码块 for (int i = 0; i &lt; 10; i++) &#123; // 获取线程的id和name System.out.println("Thread-Name: " + this.getName() + " Thread-id: " + this.getId()); try &#123; this.sleep(1000); // 线程休眠1秒 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;//测试类public class Test &#123; public static void main(String[] args) &#123; MyThread1 t1 = new MyThread1(); // 创建线程 t1.setName("第一个线程"); // 设置线程的名字 MyThread1 t2 = new MyThread1(); t2.setName("第二个线程"); t2.setPriority(8); //设置第二个线程的优先级为8，第一个线程的优先级为5(是默认的) t1.start(); t2.start(); &#125;&#125;/* * 从上面的运行结果可以看出大部分的第二个线程都是在第一个线程之前开始执行的，也就是说优先级越高获得cpu执行的几率就越大 * / setDaemon(boolean) 是否设置为守护线程，如果设置为守护线程，那么主线程销毁守护线程也会随之销毁 isDaemon() 判断是否为守护线程 使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//测试类public class MyThread1 extends Thread &#123; public void run() &#123; // 重载run方法，并且在其中写线程执行的代码块 for (int i = 0; i &lt; 10; i++) &#123; // 获取线程的id和name System.out.println("Thread-Name: " + this.getName() + " Thread-id: " + this.getId()); try &#123; Thread.sleep(1000); //休眠一秒，方便主线程运行结束 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; MyThread1 t1 = new MyThread1(); // 创建线程 t1.setName("第一个线程"); // 设置线程的名字 t1.setDaemon(true); t1.start(); for (int i = 0; i &lt; 1; i++) &#123; System.out.println(i); &#125; &#125;&#125;//结果：/* 0123456789Thread-Name: 第一个线程 Thread-id: 9*//* * 从上面的结果可以看出，一旦主线程结束，那么守护线程就会自动的结束 * / 参考文章 http://www.cnblogs.com/dolphin0520/p/3920357.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java字符串进阶]]></title>
      <url>%2F2017%2F06%2F16%2FJava%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%2F</url>
      <content type="text"><![CDATA[Java字符串进阶前言 最常用的对字符串操作的类有三个，分别是String,StringBuilder,StringBuffer，下面将会详细的说说这三个类…… String String类代表字符串，这个是最基本的对字符串的类，这个也是使用比较多的类，这里就不再详细介绍了 构造 new String(String str) new String(StringBuilder str) new String(StringBuffer str) new String(byte[] bys,String charsetName) 通过使用指定的字符集解码指定的 byte 子数组，构造一个新的 String。 常用方法 str charAt(int index) 返回指定索引处的字符 String concat(String str) 将指定字符串str连接到此字符串的结尾，返回连接成功后的字符，因此需要接受才能有效果 boolean contains(CharSequence s) 判断此字符串是否包含指定的char值序列，这里的 CharSequence是一个接口，可以直接使用它的子类作为参数(String,StringBuffer,StringBuild) static String copyValueOf(char[] c) 将字符数组变成字符串并且返回 static String copyValueOf(char[] c,int off,int count) 将截取的字符数组变成字符串并且返回，off是开始截取的下标，count是截取的个数 boolean endWith(String s) 判断字符串是否是以s结尾 boolean equals(Object o) 用于比较 int indexOf(char c) 返回字符c在字符串中第一次出现的索引 int indexOf(char c,int fromIndex) 从指定索引处开始搜索，查找第一次出现的索引 int indexOf(String str) 返回指定子字符串在此字符串中第一次出现处的索引。 int indexOf(String str,int fromIndex) 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。 boolean isEmpty() int length() boolean matches(String regex) 是否匹配正则表达式 trim() 返回字符串的副本，忽略前导空白和尾部空白。 String substring(int beginIndex) 返回一个新的字符串，它是此字符串的一个子字符串。 String substring(int beginIndex, int endIndex) 返回一个新字符串，它是此字符串的一个子字符串。 String toUpperCase() 使用默认语言环境的规则将此 String 中的所有字符都转换为大写。 String[] split(String regex) 根据给定正则表达式的匹配拆分此字符串。 String[] split(String regex, int limit) 根据匹配给定的正则表达式来拆分此字符串。 char[] toCharArray() 将此字符串转换为一个新的字符数组。 byte[] getBytes(Charset charset) 使用给定的 charset 将此 String 编码到 byte 序列，并将结果存储到新的 byte 数组 注意 上面的new String(byte[] bys,String charsetName)这个构造方法很重要，它可以改变字符串的编码集(和byte[] getBytes(Charset charset))配合着使用，下面我们来看一个例子,代码如下:1234567891011121314151617181920212223242526272829 /* * InputStreamReader实现了将字节流FileInputStream转换为字符流，然后使用转换来的字节流创建高效流，从而实现高效的读写 *//* * 编码集(我的eclipse编辑器默认的是utf-8 * 下面将中文字符串的编码集变为GBK写入a.txt文件,因为a.txt默认的是utf-8的因此这里在文件中显示的是乱码 * 然后我们读出来的还是GBK的，因为我们写入的是GBK编码集的，但是我的eclipse是utf-8的编码集，因此在控制台上输出的还是乱码 * new String(byte[] bys,String * charsetName)使用这个构造方法将byte数组改变编码集并且转换为utf-8格式的，那么这次在控制台上输出的就不乱码了 */// 将GBK格式的中文写入a.txt文件File file = new File("src/a.txt");FileOutputStream fileOutputStream = new FileOutputStream(file);String str = "中";byte[] by = str.getBytes("GBK"); // 将字符串改为GBK编码集fileOutputStream.write(by);fileOutputStream.close();//从a.txt文件中读取中文FileInputStream fileInputStream = new FileInputStream(file);int len;byte[] bys = new byte[4];while ((len = fileInputStream.read(bys)) != -1) &#123; System.out.println(new String(bys, "GBK"));&#125;fileInputStream.close(); StringBuffer 线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。当然最重要的一点就是线程安全，我们可以从它的源码中可以看出，对于一些操作(append,insert..)都是使用了线程控制块来实现同步，适合与多线程下的使用，源代码如下:1234567891011121314151617181920212223public synchronized StringBuffer append(Object obj) &#123; super.append(String.valueOf(obj)); return this;&#125;public synchronized StringBuffer append(String str) &#123; super.append(str); return this;&#125;public synchronized StringBuffer delete(int start, int end) &#123; super.delete(start, end); return this;&#125;/** * @throws StringIndexOutOfBoundsException &#123;@inheritDoc&#125; * @since 1.2 */public synchronized StringBuffer deleteCharAt(int index) &#123; super.deleteCharAt(index); return this;&#125; 构造 new StringBuffer(StringBuilder str) new StringBuffer(String str) 常用的方法 StringBuffer append(str)将指定类型的str追加到此字符串的后面(String,char,char[],int,double,float,long,StringBuffer,StringBuilder) StringBuffer insert(int offest, str) 将指定类型的str插入到此序列中,offest表示开始插入的位置的索引,类型有 String,char,char[],int,double,float,long,StringBuffer,StringBuilder String delete(int fromIndex,int endIndex) 移除此序列中的字符串并且返回新的缓冲字符串 StringBuffer reverse() 反转字符串 String substring(int start) 返回一个新的 String，它包含此字符序列当前所包含的字符子序列。 String substring(int start, int end) 返回一个新的 String，它包含此序列当前所包含的字符子序列。 StringBuffer deleteCharAt(int index) 移除此序列指定位置的 char。 int length() 长度 String toString() 返回此序列中数据的字符串表示形式。 StringBuilder 建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。但是这个类不是线程安全的，只适合单线程，如果使用多线程推荐使用StringBuffer,当然使用这个也行，不过需要自己实现同步 构造方法 new StringBuilder(String str) 常用方法 这个类的常用方法和StringBuffer的一样，这里就不再一一列举了，参照上面的即可使用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java正则表达式]]></title>
      <url>%2F2017%2F06%2F16%2FJava%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[Java正则表达式 java.util.regex是一个用正则表达式所订制的模式来对字符串进行匹配工作的类库包。它包括两个类：Pattern和Matcher。Pattern是一个正则表达式经编译后的表现模式。Matcher对象是一个状态机器，它依据Pattern对象做为匹配模式对字符串展开匹配检查。 首先一个Pattern实例订制了一个所用语法与PERL的类似的正则表达式经编译后的模式，然后一个Matcher实例在这个给定的Pattern实例的模式控制下进行字符串的匹配工作。 正则表达式的构造摘要 详细摘要请看jdk中文文档,下面我只是列出一些经常使用的 构造 匹配 . 任何字符（与行结束符可能匹配也可能不匹配） \d 数字：[0-9] \D 非数字： [^0-9] \s 空白字符：[ \t\n\x0B\f\r] \S 非空白字符：[^\s] \w 单词字符：[a-zA-Z_0-9] \W 非单词字符：[^\w] [abc] a、b 或 c（简单类） [^abc] 任何字符，除了 a、b 或 c（否定） [a-zA-Z] a 到 z 或 A 到 Z，两头的字母包括在内（范围） ^ 行的开头 $ 行的结尾 X? X，一次或一次也没有 X* X，零次或多次 X+ X，一次或多次 X{n} X，恰好 n 次 X{n,} X，至少 n 次 X{n,m} X，至少 n 次，但是不超过 m 次 Pattern 正则表达式的编译表示形式,学过python的都知道这个和python的正则表达式有异曲同工之妙。 但是它的构造方法是私有的，因此不能直接创建对象，但是可以调用它的静态方法返回一个对象，下面会详细介绍 创建对象 Pattern类用于创建一个正则表达式,也可以说创建一个匹配模式,它的构造方法是私有的,不可以直接创建,但可以通过Pattern.complie(String regex)简单工厂方法创建一个正则表达式，代码如下：12345//采用的complie(String regex)Pattern pattern = Pattern.compile("\\d+");//采用的是complie(String regex,int flag)其中flag表示标志，下面的标志表示忽略字母大小写，详细的字段请看文档Pattern pattern=Pattern.compile("(CHEN)(\\D*)(\\d*)",Pattern.CASE_INSENSITIVE); 常用方法 Pattern compile(String regex) 用于创建Pattern对象 Pattern compile(String regex,int flags) 用于创建Pattern对象，并且指定了标志(比如忽略字母大小写) int flags() 返回此模式的匹配标志 String pattern() 返回在其中编译过此模式的正则表达式。 String[] split(CharSequence input) 根据此模式的正则表达式将输入的字符串拆分成String数组,默认的都是全部拆分开 1234 //给出正则表达式用于匹配数字(0-9) Pattern pattern = Pattern.compile("\\d+"); String str = "我是陈加兵456郑元梅34擦市场的逻辑啊";String[] splits = pattern.split(str, 2); //结果:[我是陈加兵,郑元梅34擦市场的逻辑啊] String[] split(CharSequence input,int limit) 将字符串按照正则表达式表示的内容进行分组，如果limit&gt;0那么就分成limit个组，如果limit&lt;0就按照默认全部分开 1234//给出正则表达式用于匹配数字(0-9)Pattern pattern = Pattern.compile("\\d+");String str = "我是陈加兵456郑元梅34擦市场的逻辑啊";String[] splits = pattern.split(str, 2); //结果:[我是陈加兵,郑元梅34擦市场的逻辑啊] Pattern.matches(String regex,CharSequence input)是一个静态方法,用于快速匹配字符串,该方法适合用于只匹配一次,且匹配全部字符串 123Pattern.matches("\\d+","2223");//返回true Pattern.matches("\\d+","2223aa");//返回false,需要匹配到所有字符串才能返回true,这里aa不能匹配到 Pattern.matches("\\d+","22bb23");//返回false,需要匹配到所有字符串才能返回true,这里bb不能匹配到 Matcher matcher(CharSequence input) 创建匹配给定输入与此模式的匹配器,现在只是先了解以下，下面会详细解释Matcher这个类 12Pattern p=Pattern.compile("\\d+"); Matcher m=p.matcher("22bb23"); Matcher Pattern类只能做一些简单的匹配操作,要想得到更强更便捷的正则匹配操作,那就需要将Pattern与Matcher一起合作.Matcher类提供了对正则表达式的分组支持,以及对正则表达式的多次匹配支持.Matcher类和Pattern类一样它的构造方法同样是私有的，因此不能直接构造对象，但是上面我们说过Pattern类中有一个方法可以返回一个Matcher对象(matcher(CharSequence input)) 常用的方法 boolean mathces() 尝试将整个区域与模式匹配(针对的是整个字符串，如果整个字符串未完全匹配，那么返回false,如果完全匹配那么返回true) 12345 Pattern pattern=Pattern.compile("\\d+"); //创建Pattern对象String str="I am hreo 1234"; //需要匹配的字符串Matcher matcher=pattern.matcher(str); //并没有完全匹配，因此返回false，如果str="123445"，那么就会返回trueSystem.out.println(matcher.matches()); boolean lookingAt() 尝试从给定字符串的开头开始匹配，如果有子字符串匹配成功，那么返回true(针对的不是整个字符串，而是从开头开始，如果开头有一段字符串匹配成功，那么返回true) 12345 Pattern pattern=Pattern.compile("\\d+"); //创建Pattern对象String str="1234 I am a hero"; //需要匹配的字符串Matcher matcher=pattern.matcher(str);//开头的1234匹配到了，因此返回true，如果str="I am a hero 1234"将返回falseSystem.out.println(matcher.lookingAt()); int start() 匹配到的字符串的第一个元素的索引,如果没有匹配到调用此方法将会报错 int end() 匹配到的字符串的最后一个元素的索引,如果没有匹配到调用此方法将会报错 String group() 返回的是匹配到的字符串,如果没有匹配到调用此方法将会报错 123456789 Pattern pattern=Pattern.compile("\\d+"); //创建Pattern对象String str="1234 I am a hero 33455"; //需要匹配的字符串Matcher matcher=pattern.matcher(str);if(matcher.lookingAt())&#123; System.out.println("开始匹配到下标为"+matcher.start()); //0 System.out.println("匹配结束的下标为"+matcher.end()); //4 System.out.println("匹配的字符串为"+matcher.group()); //1234&#125; boolean find() 查找整个字符串，如果在任意位置有一段字符串能够匹配成功，那么返回true(任意位置),然后如果再次调用这个查找的话，那么就从上次查找到的末尾开始匹配，也就是说查找的是下一个子序列了 123456789101112131415161718192021222324252627 Pattern pattern=Pattern.compile("\\d+"); //创建Pattern对象String str="1234 I am a hero 6666 chenjiabing8888"; //需要匹配的字符串Matcher matcher=pattern.matcher(str);while(matcher.find()) //如果还有匹配的字符序列&#123; System.out.println("开始匹配到下标为"+matcher.start()); System.out.println("匹配结束的下标为"+matcher.end()); System.out.println("匹配的字符串为"+matcher.group()); &#125; /*结果如下： * 开始匹配到下标为0 匹配结束的下标为4 匹配的字符串为1234 开始匹配到下标为17 匹配结束的下标为21 匹配的字符串为6666 开始匹配到下标为33 匹配结束的下标为37 匹配的字符串为8888 */ /* * 从上面返回的结果可以知道，find()可以匹配多次只要这个字符串还有可以匹配， * 并且每次的匹配字段的开始下标都是上一次匹配的结束字母的下一个下标 */ boolean find(int start) 从指定的索引start位置开始匹配，这个用于重置find()匹配器，因为直接使用find()它的每次开始的索引都是不一样的 String group(int num) 返回指定分组匹配到的字符串,group(0)表示匹配到的整个字符串,group(1) 表示匹配到的第一个字符(即是第一个括号中匹配的模式) int groupCount() 返回匹配到的分组个数 String replaceAll(String str) 将所有于模式相匹配的 字符串全部替换程指定的字符串str,返回的是替换后的文本 String replaceFirst(String str) 只将第一次匹配到的字符串替换成指定的字符串str，返回的时替换后的文本 12345678910Pattern pattern=Pattern.compile("\\d+");String str="chenjiabing2344cal3445";Matcher matcher=pattern.matcher(str);str=matcher.replaceFirst("陈加兵"); System.out.println(str); //输出:chenjiabing陈加兵cal3445 /* * str=matcher.replaceAll("陈加兵"); * System.out.println(str) //输出:chenjiabing陈加兵cal陈加兵 */ 捕获组 捕获组可以通过从左到右计算其开括号来编号，编号是从1 开始的。例如，在表达式 ((A)(B(C)))中，存在四个这样的组：1234((A)(B(C)))(A)(B(C))(C) 总之在正则表达式中在括号中的就是一个分组,下面用一个实例来理解一下12345678910 Pattern pattern=Pattern.compile("(\\D*)(\\d+)\\s(\\D+)");Matcher matcher=pattern.matcher("chenjiabingshizuibangde6666 chenjiabign");if(matcher.find())&#123; System.out.println("总共匹配到了"+matcher.groupCount()+"个分组"); System.out.println("匹配到整个字符串为"+matcher.group(0)); System.out.println("匹配到的第一个字符串为"+matcher.group(1)); System.out.println("匹配到的第二个字符串为"+matcher.group(2)); System.out.println("匹配到的第三个字符串为"+matcher.group(3));&#125; 贪婪模式和非贪婪模式 贪婪与非贪婪模式影响的是被量词修饰的子表达式的匹配行为，贪婪模式在整个表达式匹配成功的前提下，尽可能多的匹配，而非贪婪模式在整个表达式匹配成功的前提下，尽可能少的匹配一般写python爬虫的时候使用的都是非贪婪模式来匹配使用了贪婪模式后会尽可能匹配更多的字符串，即是到了正则表达式定的末尾但是还是会继续向后匹配，看看是否还能匹配，非贪婪模式则是相反，到了正则表达式定义的结束字符就直接停止匹配了贪婪模式: .* , .+非贪婪模式: .*? , .+? 实例123456789101112 //使用了贪婪模式,因此当匹配到第一个&lt;/div&gt;的时候还要向后面匹配看看是否还能匹配到，由于后面还有&lt;/div&gt;结尾的，因此还是能够匹配的，因此匹配到的是:陈加兵&lt;/div&gt;&lt;div&gt;郑元梅 Pattern pattern=Pattern.compile("&lt;div&gt;(.*)&lt;/div&gt;"); //使用了非贪婪模式，因此当匹配到第一个&lt;/div&gt;的时候就不向后面匹配了，直接返回了，因此匹配到的是:陈加兵Pattern pattern1=Pattern.compile("&lt;div&gt;(.*?)&lt;/div&gt;"); String str="&lt;div&gt;陈加兵&lt;/div&gt;&lt;div&gt;郑元梅&lt;/div&gt;";Matcher matcher=pattern1.matcher(str);if(matcher.find())&#123; System.out.println(matcher.groupCount()); //1 System.out.println(matcher.group(1)); //输出匹配到的字符串,此时输出的是:陈加兵,如果使用贪婪模式输出的是：陈加兵&lt;/div&gt;&lt;div&gt;郑元梅&#125; 参考文章 http://www.cnblogs.com/ggjucheng/p/3423731.html http://www.runoob.com/java/java-regular-expressions.html http://blog.csdn.net/lxcnn/article/details/4756030]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java日期格式化]]></title>
      <url>%2F2017%2F06%2F15%2FJava%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96%2F</url>
      <content type="text"><![CDATA[日期格式化前言 更多文章请看本人博客https://chenjiabing666.github.io/ 版权所有，如需转载请注明来源 Date Date类表示特定的瞬间精确到毫秒，不过从API可以看出很多的方法已经废弃了，这个类已经在过多使用了，不过还是需要了解一下的，为了后面的学习做铺垫 构造方法 new Date() 常用的方法 long getTime() 返回计算机上面的时间，返回的是毫秒 setTime(long s) 用给定的毫秒值s设置时间 实例12Date date=new Date();System.out.println(date.getTime()); SimpleDateFormat 这个类是一个简单的格式化日期的类，继承与DateFormat,相对于父类来说使用简单 构造方法 new SimpleDateFormat() 使用默认的格式化模板创建对象 new SimpleDateFormat(String pattern) 使用指定的格式化模板创建对象 常用的方法 String format(Date date) 将给定的日期格式化指定的模板的样式,比如2017-01-29 23:22:11 applyPattern(String pattern) 将给定的格式应用于此日期的格式，相当于直接使用new Date(String pattern) Date parse(String d) 将给定的格式化的日期格式字符串转换成Date对象，需要注意的是转化的时候定义的模板一定要和字符串的日期格式的模板一样，否则将会解析不正确的形式 常用的日期格式化的模板 实例 使用默认的模板格式化日期 123SimpleDateFormat dateFormat=new SimpleDateFormat(); //默认的格式String formateString=dateFormat.format(date); //格式化当前的日期System.out.println(formateString); 使用指定的模板格式化日期 123String model="yyyy-MM-dd-FF HH:mm:ss"; //指定格式化的模板SimpleDateFormat dateFormat2=new SimpleDateFormat(model);System.out.println(dateFormat2.format(date)); 将格式化的日期转换成Date类型的，使用的parse(String s)，需要注意的是，下面定义的模板一定要和给定的格式化后的日期格式一样，否则转换后Date类型的毫秒值可能不正确 12345678910 String d = "2017-06-12 22:34:19"; //给出格式化后的日期String pattern = "yyyy-MM-dd HH:mm:ss"; //按照上面的日期格式定义模板，这个一定要完全和上面的一样，否则转换不正确SimpleDateFormat dateFormat = new SimpleDateFormat(pattern);try &#123; Date date = dateFormat.parse(d); //解析成Date类型 System.out.println(dateFormat.format(date));&#125; catch (ParseException e) &#123; System.err.println("解析错误");&#125; 综合使用：计算时间差 12345678910111213Scanner scanner=new Scanner(System.in);System.out.println("请输入年-月-日");String startTime=scanner.next();System.out.println("请输入结束时间(年-月-日)");String endTime=scanner.next();String moudle="yyyy-MM-dd"; //定义时间模板//创建指定模板的解析SimpleDateFormat dateFormat=new SimpleDateFormat(moudle);Date startDate=dateFormat.parse(startTime);//解析开始时间Date endDate =dateFormat.parse(endTime);//解析结束时间long time=startDate.getTime()-endDate.getTime(); //返回两个时间的差，毫秒int day=(int)(time/1000/60/60/24); //转化为天数，1秒等于1000毫秒，一分钟等于60秒，一小时等于60分钟，一天等于24小时System.out.println(day); Calendar Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等 日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。瞬间可用毫秒值来表示，它是距历元（即格林威治标准时间 1970 年 1 月 1 日的 00:00:00.000，格里高利历）的偏移量。 创建对象 Calendar.getInstance() 常用方法 int get(int field) 返回当前对象的一些日期信息 Date getTime() 获得当前日期的Date对象 add(int field,int amount) 根据日历的规则，为给定的日历字段添加或减去指定的时间量。例如，要从当前日历时间减去 5 天，可以通过调用以下方法做到这一点：add(Calendar.DAY_OF_MONTH, -5)。 setTime(Date date) 使用给定的Date对象，设置Calendar时间 实例 get方法获取一些字段的值 1234567891011121314151617181920 Calendar calendar = Calendar.getInstance(); // 创建对象System.out.println(calendar.get(Calendar.YEAR));// 获取年份System.out.println(calendar.get(Calendar.MONTH) + 1);// 月，从0开始，即是输出5表示6月System.out.println(calendar.get(Calendar.DATE));// 获取一个月中的第几天System.out.println(calendar.get(Calendar.HOUR)); // 小时System.out.println(calendar.get(Calendar.MINUTE)); // 分钟System.out.println(calendar.get(Calendar.SECOND)); // 秒System.out.println(calendar.get(Calendar.AM_PM)); // 获得是上午还是下午AM=0,PM=1System.out.println(calendar.get(Calendar.DAY_OF_MONTH)); // 一个月中的第几天System.out.println(calendar.get(Calendar.DAY_OF_WEEK)); // 一周中的第几天，星期日是第一天System.out.println(calendar.get(Calendar.DAY_OF_YEAR));// 一年中的第几天System.out.println(calendar.get(Calendar.HOUR_OF_DAY)); // 一天中的第几小时if (calendar.get(Calendar.AM_PM) == Calendar.AM) &#123; System.out.println("现在是上午");&#125;if (calendar.get(Calendar.MONTH) + 1 == Calendar.JULY) &#123; System.out.println("现在是6月");&#125; Date getTime()方法的使用 12345Calendar calendar=Calendar.getInstance();Date date=calendar.getTime(); //获得Date对象String pattern="yyyy-MM-dd HH:mm:ss";SimpleDateFormat dateFormat=new SimpleDateFormat(pattern);System.out.println(dateFormat.format(date)); add(int field,int amount)方法的使用 123 Calendar calendar=Calendar.getInstance();calendar.add(Calendar.DATE, -2);System.out.println(calendar.get(Calendar.DATE)); 综合实例：计算出当前的准确日期 12345678910111213141516171819 Calendar calendar = Calendar.getInstance();int year = calendar.get(Calendar.YEAR);int month = calendar.get(calendar.MONTH) + 1; // 从0开始算，因此加1int date = calendar.get(Calendar.DATE);int week = calendar.get(Calendar.WEEK_OF_MONTH) + 1; // 从周日开始算，因此加1int hour = calendar.get(Calendar.HOUR);int minute = calendar.get(Calendar.MINUTE);int seconds = calendar.get(Calendar.SECOND);if (calendar.get(Calendar.AM_PM) == Calendar.AM) &#123; System.out.println("现在是" + year + "年" + month + "月" + date + "号" + "星期" + week + "上午" + hour + "点" + minute + "分" + seconds + "秒");&#125; else &#123; System.out.println("现在是" + year + "年" + month + "月" + date + "号" + "星期" + week + "下午" + hour + "点" + minute + "分" + seconds + "秒");&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java反射机制]]></title>
      <url>%2F2017%2F06%2F14%2FJava%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%2F</url>
      <content type="text"><![CDATA[Java反射机制前言 网页版的jdk的API 离线版API 什么是反射机制 反射是java语言的一个特性，它允程序在运行时（注意不是编译的时候）来进行自我检查并且对内部的成员进行操作。例如它允许一个java的类获取他所有的成员变量和方法并且显示出来。这个能特定我们不常看到，但是在其他的比如C或者C++语言中很不就存在这个特性。一个常见的例子是在JavaBean中，一些组件可以通过一个构造器来操作。这个构造器就是用的反射在动态加载的时候来获取的java中类的属性的。 主要的类 Class 类的实例表示正在运行的 Java 应用程序中的类和接口。Class没有公共的构造方法，Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的 Constructor 提供关于类的单个构造方法的信息以及对它的访问权限(主要提供的是对构造方法使用) Method 提供关于类或接口上单独某个方法（以及如何访问该方法）的信息。所反映的方法可能是类方法或实例方法（包括抽象方法) Field 主要提供对类中的成员变量的访问和使用 Class Class类也使用了泛型，即是Class这种形式的，可以直接使用一个具体的类传入，这样的话就不需要强制转换了，比如Class.newInstance()这样使用默认的构造方法构造一个对象就需要不再需要强制转换了即使用(ClassName)Class.newInstance() 常用的方法 getConstructor(Class[] params) 获取公共的(public)的构造方法，并且限定其中的参数个数和类型可以获得不同的公共构造方法 Constructor[] getConstructors() 返回所有的公共(public)的构造方法 getDeclaredConstructor(Class[] params) 获取所有指定的构造方法，但是需要注意的是当获取私有的构造方法的时候需要使用setAccessible设置访问权限为true才能进行构造，否则出现异常 Constructor[] getDeclaredConstructors() 返所有的构造方法包括public和private，protected修饰的 T newInstance() 返回的是一个调用默认的构造方法(public class_name())实例化的一个Object对象，如果使用泛型那么就返回T类型的，反之返回的是Object需要强制转换才能使用这个对象调用成员函数和成员变量 Class forName(String class_name) 返回class对象，每一个类都有一个方法返回Class对象(类名.class)，注意这里的参数一定是具体的路径，包括包的名字，比如demo.Test Package getPackage() 返回此类所在的包名(package demo) 当然也可以使用Package.getName()获得包的名字(demo)比如class1.getPackage().getName() int getModifiers() 返回的是类的修饰符的整数 类型(修饰符的类型有public private protected)其中得到整数可以使用Modifier中toString(int num)得到public，private，protected的类型,比如Modifier.toString(class1.getModifiers())*Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 返回指定参数的方法Method对象,注意这里仅仅是返回的时公共的方法(public) 比如:Method method=class1.getMethod(&quot;display&quot;,new Class[]{int.class})这里的display是方法的名字，有一个参数，类型为int Method[] getMethods() 获取所有的公共的方法(public)返回的是一个数组(Method) Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes)返回所有的指定的参数的方法(public,private,protected，但是不包括继承的),其中参数可以为null(无参数) Method[] getDeclaredMethods() 获取所有的方法 Field getField(String name) 指定名字的公共成员变量(public) Field[] getFields() 获取所有的公共的成员变量 Field getDeclaredField(String name) 获取所有的指定名称的成员变量(public,protected,private),同样在调用私有成员变量的时候需要先设置访问的权限,field.setAccessible(true) Field[] getDeclaredFields() 获取所有的成员变量(public,protected,private) getSuperclass() 返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的超类的 Class。 URL getResource(String name) 查找指定名称的资源(图片，文件…)注意这个资源一定要和指定类在一个包中，否则返回null，比如查找Test类下的airplane.png图片:Test.class.getResource(&quot;airplane.png&quot;)这里返回的将是绝对路径 获取Class的对象并且实例化 使用Class.forName(String className) 其中className一定是包含包的名字，下面的demo就是包的名字，Test是类的名字。这是最常用的方法，学过JDBC的都知道加载驱动的时候就是使用的Class.forName() 12345/* * 第一种使用forName(String className),其中className一定是包含包的名字，下面的demo就是包的名字，Test是类的名字 */Class cls=Class.forName("demo.Test");Test test=(Test)cls.newInstance(); //这里只是使用了默认的构造方法实例化对象 使用类名.class 1Class cls=Test.class; 使用对象.getClass() 12Test test=new Test();Class cls=test.getClass(); Constructor 主要是用来对类的构造方法进行操作的，可以看出这个也使用了泛型，和上面的Class是一样的，注意这里如果没有使用泛型，那么原本放回T类型的现在都是返回Object 常用的方法 T newInstance(Object parms) 使用带有参数的构造方法实例化对象，如果使用了泛型，那么返回的就是T类型的，反之返回的是Object类型的，需要强制转换 getName() 以字符串的形式返回构造方法的名称，具体的路径包含包名(demo.Test) int getModifiers() 和Class类中的方法一样 Method 主要提供的是对类中的方法的操作 常用的方法 Object invoke(Object obj,object args) 使用得到的Method对象调用方法，obj是类的已经构造好的对象，如果是静态方法直接写null,因为静态方法的调用不需要对象，返回值是Object类型的，如果接受返回值，需要使用强制转换成相应的类型,args是传入的参数,如果有多个参数，那么可以直接在后面用逗号添加或者直接创建数组new Object[]{22,&quot;chenjiabing&quot;}比如：method.invoke(test,22,&quot;chenjiabing&quot;) method.invoke(test,new Object[]{22,&quot;chenjiabing&quot;})注意：如果调用的private类型的方法，那么需要在前面设置访问的权限,method.setAccessible(true) String getName() 返回此方法的名字(display) Modifier getModifiers() 返回此方法的修饰符的类型表示的整数(public,private…),可以使用Modifier.toString()转换成字符串形式 Class getReturnType() 返回这个方法的返回类型 String toString() 返回这个方法表示的字符串的形式 Field 主要提供对类的成员变量的操作 常用方法 String getName() 返回变量名字 Object get(Object obj) 返回此变量在指定对象中的值，因为在构造对象的时候每一个传入的变量的值都不一样，因此需要使用对象obj。obj表示传入的对象，返回的Object类型，因此需要强制转换 void set(Object obj,Object value) 改变obj对象上的变量的值为value Modifier getModifiers() 返回整数表示修饰的类型 String getType() 获取变量的类型(int,String,double float…..) Modifier Modifier 类提供了 static 方法和常量，对类和成员访问修饰符进行解码。修饰符集被表示为整数，用不同的位位置 (bit position) 表示不同的修饰符。 常用的方法 static String toString(int mode) 将代表修饰符的整数形式转换为字符串形式的修饰符，比如将1转换成public static isInterface(int mode) 如果整数参数包括 interface 修饰符，则返回 true，否则返回 false static isStatic(int mode) static isPrivate(int mode) static isPublic(int mode) static isAbstract(int mode) 实例1Modifier.toString(Test.class.getModifiers()) //得到Test类的修饰符 使用 有了上面的铺垫，我们就可以使用上面的这些类进行操作了，在进行操作之前，我们需要先定义一个类Test,放在demo包下，内容如下 12345678910111213141516171819202122232425262728293031323334package demo;import java.util.jar.Attributes.Name;import javax.print.attribute.standard.MediaSize.NA;public class Test &#123; public String name; private int age; public Test() &#123; this.name = "陈加兵"; this.age = 23; &#125; public Test(String name, int age) &#123; this.name = name; this.age = age; &#125; public void display() &#123; System.out.println("name=" + this.name + "----age=" + this.age); &#125; public void set(String name, int age) &#123; this.name = name; this.age = age; &#125; private int getAge() &#123; return this.age; &#125;&#125; 实例化对象 使用Class默认的构造newInstance() 123 Class class1=Class.forName("demo.Test"); //静态加载ClassTest test=(Test)class1.newInstance(); //调用默认的构造方法(public Test())实例化对象，由于没有使用泛型，因此需要强转test.display(); //调用display方法 使用Class中的getConstructor()方法构造对象,需要注意的使用private类型构造方法时一定要先设置访问权限为true-constructor.setAccessible(true); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 /* *调用public Test(String name,int age)得到Constructor的两种形式 * 1.Constructor constructor=class1.getConstructor(new Class[]&#123;String.class,int.class&#125;); * 2.Constructor constructor=class1.getConstructor(String.class,int.class);这个和上面的是一样的，就是使用的参数形式不一样 * * * * *使用newInstance()构造对象的两种方式 * 1.Test test=(Test)constructor.newInstance(new Object[]&#123;"chenjiabing",22&#125;); * 2.Test test=(Test)constructor.newInstance("chenjiabing",22); 只是形式不同而已，不过我还是喜欢上面的形式 * */ /* * 调用public Test(String name,int age) * Class.getConstructor()得到的是公共的构造方法，如果有私有的构造方法，那么就会报错，这时就要使用getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) * Test test=(Test)constructor.newInstance("陈加兵",22); * * * 调用public Test() * Constructor constructor=class1.getConstructor(null); * Test test=(Test)constructor.newInstance(null); * * * 调用private Test(int age) * Constructor constructor=class1.getDeclaredConstructor(new Class[]&#123;int.class&#125;); constructor.setAccessible(true); //因为private类型是不可以直接访问的，因此需要设置访问权限为true Test test=(Test)constructor.newInstance(new Object[]&#123;1000&#125;); */ Class class1=Class.forName("demo.Test"); //访问public Test(String name,int age)// Constructor constructor=class1.getConstructor(new Class[]&#123;String.class,int.class&#125;);// Test test=(Test)constructor.newInstance("陈加兵",22); //访问默认的构造方法// Constructor constructor=class1.getConstructor(null);// Test test=(Test)constructor.newInstance(null); //访问private类型的构造方法 Constructor constructor=class1.getDeclaredConstructor(new Class[]&#123;int.class&#125;); constructor.setAccessible(true); Test test=(Test)constructor.newInstance(new Object[]&#123;1000&#125;); test.display(); 成员方法的操作 使用Class.getMethod()和Class.getDeclaredMethod()方法获取方法，这两个方法的区别前面已经说过了，注意的是调用私有成员方法的之前一定要设置访问权限(method.setAccessible(true)) Method类中的其他方法前面也已经说过了，详细使用请自己尝试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 /* * 获取Method对象的两种方式: * 1.Method method_set=class1.getMethod("set", new Class[]&#123;String.class,int.class&#125;); * 2.Method method_set=class1.getMethod("set", String.class,int.class); * * * 使用Method.invoke()调用方法的两种方式 * 1.Object o=method_set.invoke(test, new Object[]&#123;"陈加兵",200&#125;); * 2.Object object=method_set.invoke(test, "陈加兵",2000); */ /* * 获取公共方法(public)： * 1.Method method=class1.getMethod("display",null); //public void display() * 2.Method method_set=class1.getMethod("set", new Class[]&#123;String.class,int.class&#125;); //获取public void set(String name,int age) * * * 获取私有方法(private,protected) * 1.Method method_getAge=class1.getDeclaredMethod("getAge", null); */ //使用构造方法构造一个Test对象 Class class1 =Class.forName("demo.Test"); Constructor&lt;Test&gt; constructor=class1.getDeclaredConstructor(new Class[]&#123;String.class,int.class&#125;); Test test=constructor.newInstance(new Object[]&#123;"陈加兵",22&#125;); Method method=class1.getMethod("display",null); //获取public void display()方法的Method对象 Object obj=method.invoke(test, null); //调用方法display //获取public void set(String name,int age)// Method method_set=class1.getMethod("set", new Class[]&#123;String.class,int.class&#125;); Method method_set=class1.getMethod("set", String.class,int.class); // Object o=method_set.invoke(test, new Object[]&#123;"陈加兵",200&#125;); Object object=method_set.invoke(test, "陈加兵",2000); test.display(); //获取私有方法private int getAge() Method method_getAge=class1.getDeclaredMethod("getAge", null); method_getAge.setAccessible(true); //必须设置访问权限为true //判断返回值类型是否为int类型的 if("int".equals(method_getAge.getReturnType().toString())) &#123; int ReturnData=(int) method_getAge.invoke(test, null); //调用并且获取返回值 System.out.println(ReturnData); &#125; 成员变量的操作 主要使用的Field类，前面已经详细的说过了 123456789101112131415161718/* * 获取public修饰的成员变量： * 1.Field field=class1.getField("name"); //获取public的成员变量name的Filed对象 * * 获取private，protected修饰的成员变量： * 1. Field field2=class1.getDeclaredField("age"); */ Class class1=Class.forName("demo.Test"); Test test=new Test("陈加兵",1000); Field field=class1.getField("name"); //获取public的成员变量name的Filed对象 System.out.println(field.get(test)); //获得test对象中的name属性的值 //获取private int age的Field对象 Field field2=class1.getDeclaredField("age"); field2.setAccessible(true); //设置访问权限 System.out.println(field2.get(test)); 参考文章 http://www.cnblogs.com/octobershiner/archive/2012/03/18/2404751.html http://www.cnblogs.com/ixenos/p/5699420.html https://yq.aliyun.com/wenzhang/show_17985]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java IO学习笔记总结]]></title>
      <url>%2F2017%2F05%2F26%2FJava-IO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[Java IO学习笔记总结前言 前面的八篇文章详细的讲述了Java IO的操作方法，文章列表如下 基本的文件操作 字符流和字节流的操作 InputStreamReader和OutputStreamWriter操作 内存操作流 管道流 打印流 System对IO的支持 BufferedReader和BufferedWriter 后续字节流 字节流的操作都是基于InputStream和OutputStream这两个抽象类 InputStream InputStream是字节输入流，主要的功能是从文件中读取数据,它的子类有内存操作流 ByteArrayInputStream，管道输入流PipedInputStream，和FileInputStream OutPutStream OutputStream是字节输出流，主要功能是向文件中写入数据，它的常用的子类有ByteArrayOutputStream, FileOutputStream, PipedOutputStream,PrintStream 字符流 字符流的操作都是基于家Writer和Reader这两个抽象类的，一个是输出流，一个是输入流 Writer 写入字符流的操作类，常用的子类有PrintWriter,BufferedWriter,OutputStreamWriter(字节流和字符流之间的桥梁) Reader 用于读取字符流的抽象类,常用的子类有BufferedReader，InputStreamReader 最好用的 其中最高效的输入和输出当然是字符流操作的BufferedReader和BufferedWriter 最便捷的，格式化最好的当然是PrintStream,PrintWriter这两个类都采用了格式化的输入和输出 输出流最好用的 输出流中比较好用的是PrintStream,PrintWriter 输出流最好用的当然是BufferedWriter和PrintWriter的结合，例子如下； 12345678File file=new File("/tmp"+File.separator+"test"+File.separator+"test.txt");//用BufferedWriter实例化PrintWriter，显著提高写入的效率PrintWriter printWriter=new PrintWriter(new BufferedWriter(new FileWriter(file)));String name="陈加兵";int age=22;float grade=99.9f;printWriter.printf("姓名:%s,年龄:%s,grade:%s",name,age,grade); //格式化的写入printWriter.close(); 输入流最好用的 本人觉得输入流中BufferedReader功能已经很强大了 综合运用 有时候在写程序的时候，你得到了一个字节流，但是你想要创建的却是字符流对象，怎么办了呢？前面已经说过，字节流转换成字符流对象的桥梁是InputStreamReader和InputStreamWiter他们的作用是传入字节流对象构造字符流对象，因此可以完美的实现字节流转换成字符流，这个是非常重要的 下面使用转换流将System.in转换成字符流并且使用高效流读取控制台输入的数据,代码如下:12345678910 // 读取键盘的输入的数据，System.in是字节流，因此要想创建高效流必须使用转换流InputStreamReaderBufferedReader br = new BufferedReader(new InputStreamReader(System.in));String line;//从键盘读取输入的数据，直到读到bye结束while ((line = br.readLine()) != null) &#123; if ("bye".equals(line)) &#123; break; &#125; System.out.println(line);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java IO学习笔记八]]></title>
      <url>%2F2017%2F05%2F26%2FJava-IO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AB%2F</url>
      <content type="text"><![CDATA[BufferedReader和BufferedWriter 这两个类是高效率的提高文件的读取速度，它们为字符输入和输出提供了一个缓冲区，可以显著的调高写入和读取的速度，特别针对大量的磁盘文件读取的时候,下面着重的讲讲这两个类 BufferedReader 从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取,要特别注意的是这个市针对字符流而不是字节流。 通常，Reader 所作的每个读取请求都会导致对底层字符或字节流进行相应的读取请求。因此，建议用 BufferedReader 包装所有其 read()操作可能开销很高的Reader（如 FileReader 和 InputStreamReader） 构造函数 BufferedReader(Reader in) 创建一个使用默认大小输入缓冲区的缓冲字符输入流。 BufferedReader(Reader in, int sz) 创建一个使用指定大小输入缓冲区的缓冲字符输入流。 实例 可以看出构造函数使用了Reader这个抽象类来初始化，我们前面说过这个是针对字符流的读取，因此可以使用Reader类的两个子类FileReader,InputStreamReader来初始化 1234File file=new File("/tmp"+File.separator+"test"+File.separator+"test.txt");BufferedReader bufferedReader=new BufferedReader(new FileReader(file)); //使用FileReader实例化//使用InputStreamReader来实例化BufferedReader bufferedReader=new BufferedReader(new InputStreamReader(new FileInputStream(file))); 常用方法 close() String readLine() 读取一行的数据 int read() 读取一个字符，注意这里的和字节的不一样，这里的汉字占用了一个字节，前面讲到读取字节流的时候使用byte读取汉字占用三个字节 skip(int n) 跳过n个字节 ready() 判断此流是否已准备好被读取。 实例 用于控制台的读取,前面已经说过System.in返回的是InputStream类型的，因此可以使用InputStreamReader实例化,当然这个有点多余了，我们完全可以使用java.util提供的Scanner直接进行输入 123BufferedReader bufferedReader=new BufferedReader(new InputStreamReader(System.in)); String str=bufferedReader.readLine(); //将控制台输入的字符串读取 System.out.println(str); //打印出来 用于文件的读取 1234567891011121314151617181920212223242526 BufferedReader bufferedReader=new BufferedReader(new FileReader(file)); // BufferedReader bufferedReader=new BufferedReader(new InputStreamReader(new FileInputStream(file)));// bufferedReader.skip(2); //跳过两个字节// // 第一种读取的方式 while(bufferedReader.ready()) //判断是否还有字符 &#123; String str=bufferedReader.readLine(); //直接读取一行 System.out.println(str); &#125; bufferedReader.close(); //第二种读取方式 int len=bufferedReader.read(); while(len!=-1) //判断是否读到文件的末尾 &#123; System.out.print((char)len); //强制转化成字符 len=bufferedReader.read(); &#125; //第三种方式，根据readLine读取一行，如果到达了文件的末尾返回null String s; while((s=bufferedReader.readLine())!=null) &#123; System.out.println(S); &#125; BufferedWriter 将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。 通常 Writer 将其输出立即发送到底层字符或字节流。除非要求提示输出，否则建议用 BufferedWriter 包装所有其 write() 操作可能开销很高的 Writer（如 FileWriters 和 OutputStreamWriters）。例如 12PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter("foo.out"))); 构造函数 BufferedWriter(Writer out) 创建一个使用默认大小输出缓冲区的缓冲字符输出流。 BufferedWriter(Writer out, int sz) 创建一个使用给定大小输出缓冲区的新缓冲字符输出流。 12File file=new File("/tmp"+File.separator+"test"+File.separator+"test.txt");BufferedWriter bufferedWriter=new BufferedWriter(new FileWriter(file)); 注意这里的FileWriter是Writer的子类，因此可以使用其实例化 常用函数 close() flush() newLine() 写入一个与平台相关的换行符 write(int data) 写入一个字符，这里的写入的不是整数 write(String str) 写入一个字符串 write(String str,int off,int len) 写入部分字符串 write(char[] c) write(char[] c,int off,int len) 实例1234567891011121314151617181920File file=new File("/tmp"+File.separator+"test"+File.separator+"test.txt");File file1=new File("/tmp"+File.separator+"test");File file2=new File("/tmp"+File.separator+"test"+File.separator+"demo.txt");if(!file1.exists())&#123; file1.mkdir(); System.out.println("文件夹创建成功");&#125;BufferedWriter bufferedWriter=new BufferedWriter(new FileWriter(file));String str="陈加兵";int data=48;String name="chenjiabing";char[] chars=name.toCharArray();bufferedWriter.write(str); //写入一个字符串，当然也可以截取这个字符串的某一段bufferedWriter.newLine(); //写入一个平台自带的换行符，因为每一个操作系统的换行符都不一样bufferedWriter.write(data); //写入的并不是整数，而是这个整数所代表的字符bufferedWriter.newLine();bufferedWriter.write(chars,1,4); //写入字符数组bufferedWriter.flush();bufferedWriter.close() 拓展：通过了上面的学习，你不觉得使用这个类写入文件数据有点烦了，只能写入String char类型的数据，此时我们就想到了前面说过的打印流(PrintWriter)，这是一个便捷的写入文件的类，可以指定任意格式任意类型的数据，同样是输出流，我么可以将他们结合起来，构成一个更加强大的输出流，如下: 12345678File file=new File("/tmp"+File.separator+"test"+File.separator+"test.txt");//用BufferedWriter实例化PrintWriter，显著提高写入的效率PrintWriter printWriter=new PrintWriter(new BufferedWriter(new FileWriter(file)));String name="陈加兵";int age=22;float grade=99.9f;printWriter.printf("姓名:%s,年龄:%s,grade:%s",name,age,grade); //格式化的写入printWriter.close(); 综合实例 将一个文件中数据转移到另外一个文件中 123456789101112131415161718192021222324252627282930313233343536373839package IO;import java.io.*;/** * Created by chenjiabing on 17-5-26. */public class demo13 &#123; /** * 常用函数： * newLine() * write(String str) * write(String str,int off,int len) * write(Char[] c) * write(Char[] c,int off,int len) * write(int data) * close() * flush() */ public static void main(String[] args) throws IOException &#123; File file = new File("/tmp" + File.separator + "test" + File.separator + "test.txt"); File file1 = new File("/tmp" + File.separator + "test"); File file2 = new File("/tmp" + File.separator + "test" + File.separator + "demo.txt"); BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(file2)); BufferedReader bufferedReader = new BufferedReader(new FileReader(file)); while (bufferedReader.ready()) &#123; String str = bufferedReader.readLine(); //读取文件test.txt中的一行数据 bufferedWriter.write(str); //将这一行数据写入文件demo.txt bufferedWriter.newLine(); &#125; bufferedReader.close(); bufferedWriter.flush(); bufferedWriter.close(); &#125;&#125; 参考文章 http://ifeve.com/java-io-char-buffered-filter/ http://www.cnblogs.com/lich/archive/2011/12/11/2284223.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java IO学习笔记七]]></title>
      <url>%2F2017%2F05%2F26%2FJava-IO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83%2F</url>
      <content type="text"><![CDATA[System对IO的支持 System是系统的类，其中的方法都是在控制台的输入和输出，但是通过重定向也是可以对文件的输入输出 System中定义了标准输入、标准输出和错误输出流，定义如下: static PrintStream err “标准”错误输出流。 static InputStream in “标准”输入流。 static PrintStream out “标准”输出流。 从上面的定义可以知道这里的返回值都是字节的输入和输出流，因此可以使用PrintStream接受这个返回值，然后利用其进行输出，同样的输入也是可以这样做,当然对于OutputStream和InputStream也是可以的，因为PrintStream是继承OutputStream System.out System.out是一个标准的输出流，可以使用PrintStream和OutputStream接收返回值，然后使用其进行标准的输出,实例如下 12345PrintStream printStream=System.out; //使用PrintStream//OutputStream outputStream=System.out; //使用OutputStream String name="陈加兵"; int age=22; printStream.printf("姓名:%s,年龄:%s",name,age); //使用格式话的输出 其实我还是比较用PrintStream进行格式话的输出的 System.out的重定向输出，可以使用这个将指定的内容输出到文件中，实例如下： 12345678try &#123; File file=new File("/tmp"+File.separator+"test"+File.separator+"test.txt"); System.setOut(new PrintStream(new PrintStream(file))); //设置重定向的文件 &#125;catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println("陈加兵的个人博客")；//向文件输入内容 System.in 这是一个标准输入流，可以使用InputStream来接受返回值，然后利用其进行输入，实例如下： 123456789byte[] bytes=new byte[1024]; InputStream inputStream=System.in; //使用InputStream来接收这个返回值 try &#123; inputStream.read(bytes); //读取控制台输入的字符串 &#125;catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println(new String(bytes)); //输出 说实话这种控制台输入的方式不太好，还是使用原来的Scanner比较好 System.in的重定向 12345678910byte[] bytes = new byte[1024];File file = new File("/tmp" + File.separator + "test" + File.separator + "test.txt");try &#123; System.setIn(new FileInputStream(file)); //设置重定向 System.in.read(bytes); //读取文件中字节数据&#125; catch (IOException e) &#123; e.printStackTrace();&#125;System.out.println(new String(bytes)); //打印出文件中的内容 System.err 这是一个标准错误输出流，在IDEA中输出的内容是红色的，和System.out输出的格式一样，只是颜色不一样，因为这里的重定向不太重要也不太常用，这里就不再详细说了，详情请看帮助文档 System.exit public static void exit(int status) 终止当前的java虚拟机，参数用作状态码；根据惯例，非0 的状态码表示异常终止,如System.exit(0) 参考文章 http://www.cnblogs.com/lich/archive/2011/12/11/2284155.html http://ifeve.com/java-io-system-in-system-out-system-err/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java IO学习笔记六]]></title>
      <url>%2F2017%2F05%2F25%2FJava-IO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD%2F</url>
      <content type="text"><![CDATA[打印流 在整个IO包中，打印流是输出信息最方便的类，主要包含字节打印流（PrintStream）和字符打印流（PrintWrite）。打印流提供了非常方便的打印功能，可以打印任何的数据类型，例如：小数、整数、字符串等等，相对于前面学习的几个文件的操作来说，这里的打印流是最简便的一个类了 PrintStream 主要功能是格式化的将内容写入文件，并不是打印在控制台上 PrintStream最大的好处就是可以格式化的输出，相信学过c的朋友都知道prinf这格式化输出函数，这里的PrintStream实现了更加简单的格式化输出，不需要使用什么%d,%f了，只需要都是用%s即可，这个很像python PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter类。 构造函数 PrintStream(File file) 创建具有指定文件且不带自动行刷新的新打印流。 PrintStream(OutputStream out) 创建新的打印流。 PrintStream(OutputStream out, boolean autoFlush) 创建新的打印流，并且设置自动刷新 PrintStream(String fileName) 创建具有指定文件名称且不带自动行刷新的新打印流。 123File file_2=new File("/tmp"+File.separator+"test"+File.separator+"test.txt");PrintStream printStream=new PrintStream(file_2); //直接使用FilePrintStream printStream=new PrintStream(new FileOutputStream(file_2)); //使用OutputStream的子类FileOutputStream 常用的函数 PrintStream append(char c) 在此输入流的后面追加字符。 PrintStream append(CharSequence csq) 将指定字符序列添加到此输出流。 PrintStream append(CharSequence csq, int start, int end) 将指定字符序列的子序列添加到此输出流。 print() 打印常用的数据类型，比如String,char,int ,double,float,boolean,long,short println() 打印常用的数据类型，但是带有换行符 printf(String format, Object... args) 使用指定格式字符串和参数将格式化的字符串写入此输出流的便捷方法。 format(String format, Object... args) 使用指定格式字符串和参数将格式化字符串写入此输出流中。 close() flush() 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 package IO;import java.io.*;/** * Created by chenjiabing on 17-5-25. */ /**test.txt文件中的结果如下: 陈加兵 2299.9 姓名:陈加兵,n年龄:22,成绩:99.9 姓名:陈加兵,n年龄:22,成绩:99.9 c chenjiabi */public class demo9 &#123; public static void main(String[] args) &#123; PrintStream printStream = null; File file_1 = new File("/tmp" + File.separator + "test"); File file_2 = new File("/tmp" + File.separator + "test" + File.separator + "test.txt"); if (!file_1.exists()) &#123; file_1.mkdir(); System.out.println("文件创建成功"); &#125; try &#123;// PrintStream printStream=new PrintStream(file_2); printStream = new PrintStream(new FileOutputStream(file_2)); String name = "陈加兵"; int age = 22; float grade = 99.9f; printStream.println(name);//println() printStream.print(age);//print() printStream.println(grade);//print() printStream.format("姓名:%s,n年龄:%s,成绩:%s%s", name, age, grade, "\n");//format() printStream.printf("姓名:%s,n年龄:%s,成绩:%s%s", name, age, grade, "\n"); printStream.append('c'); //append printStream.append("\nchenjiabing",0,10); //append &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if (printStream != null) &#123; printStream.flush(); printStream.close(); &#125; &#125; &#125;&#125; PrintWriter 继承Writer，主要针对的是字符流的操作 向文本输出流打印对象的格式化表示形式。此类实现在 PrintStream中的所有 print 方法。它不包含用于写入原始字节的方法，对于这些字节，程序应该使用未编码的字节流进行写入。 与PrintStream 类不同，如果启用了自动刷新，则只有在调用 println、printf 或 format 的其中一个方法时才可能完成此操作，而不是每当正好输出换行符时才完成。这些方法使用平台自有的行分隔符概念，而不是换行符。 此类中的方法不会抛出 I/O 异常，尽管其某些构造方法可能抛出异常。客户端可能会查询调用 checkError() 是否出现错误。 构造函数 PrintWriter(File file) 使用指定文件创建不具有自动行刷新的新 PrintWriter。 PrintWriter(OutputStream out) 根据现有的 OutputStream 创建不带自动行刷新的新 PrintWriter。 PrintWriter(OutputStream out, boolean autoFlush) 通过现有的 OutputStream 创建新的 PrintWriter。 PrintWriter(String fileName) 创建具有指定文件名称且不带自动行刷新的新 PrintWriter。 常用函数 这里的常用到的函数和PrintStream的差不多就不再详细的列出来了，详情请看帮助文档 实例12345678910111213141516171819202122232425262728package IO;import java.io.*;/** * Created by chenjiabing on 17-5-25. */public class demo10 &#123; public static void main(String[] args) &#123; PrintWriter printWriter=null; File file=new File("/tmp"+File.separator+"test"+File.separator+"file.txt"); try &#123; printWriter=new PrintWriter(new FileOutputStream(file)); printWriter.println("chenjiabing"); printWriter.println("陈加兵"); &#125;catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(printWriter!=null) &#123; printWriter.close(); &#125; &#125; &#125;&#125; 参考文章 http://www.cnblogs.com/lich/archive/2011/12/11/2284093.html http://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/PrintWriter.html http://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/PrintStream.html http://blog.csdn.net/yyyandroid/article/details/7756390]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java IO学习笔记五]]></title>
      <url>%2F2017%2F05%2F25%2FJava-IO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94%2F</url>
      <content type="text"><![CDATA[管道流 管道流的主要作用是可以进行两个线程间的通讯，分为管道输出流(PipedOutputStream)、管道输入流（PipedInputStream），如果想要进行管道输出，则必须要把输出流连在输入流之上，在PipedOutputStream类上有如下的一个方法用于连接管道：public void connect(PipedInputStream snk)throws IOException 通常是创建两个单独的线程来实现通信，如果是单个线程的话容易出现线程堵塞，因为输出流最多只能向缓冲区写入1024个字节的数据，如果超出就会出现线程堵塞，因此必须创建多个线程实现缓冲区的释放和存储 PipedOutputStream 管道输出流是管道的发送端，可以将管道输出流连接到管道输入流来创建一个通信管道，通常，数据由某个线程写入 PipedOutputStream对象，并由其他线程从连接的 PipedInputStream 读取。不建议对这两个对象尝试使用单个线程，因为这样可能会造成该线程死锁。如果某个线程正从连接的管道输入流中读取数据字节，但该线程不再处于活动状态，则该管道被视为处于 毁坏 状态。 构造函数 PipedOutputStream() 创建尚未连接到管道输入流的管道输出流。 PipedOutputStream(PipedInputStream snk) 创建连接到指定管道输入流的管道输出流。 常用函数 close() 关闭 void connect(PipedInputStream snk) 将此管道输出流连接到接收者。 void flush() 刷新此输出流并强制写出所有缓冲的输出字节。 void write(byte[] b, int off, int len) 将 len 字节从初始偏移量为 off 的指定 byte 数组写入该管道输出流。 void write(int b) 将指定 byte 写入传送的输出流。 PipedInputStream 管道输入流应该连接到管道输出流；管道输入流提供要写入管道输出流的所有数据字节。通常，数据由某个线程从 PipedInputStream 对象读取，并由其他线程将其写入到相应的 PipedOutputStream。不建议对这两个对象尝试使用单个线程，因为这样可能死锁线程。管道输入流包含一个缓冲区，可在缓冲区限定的范围内将读操作和写操作分离开。 如果向连接管道输出流提供数据字节的线程不再存在，则认为该管道已损坏。 构造函数 PipedInputStream() 创建尚未连接的 PipedInputStream。 PipedInputStream(PipedOutputStream src) 创建 PipedInputStream，使其连接到管道输出流 src。 常用函数 int available() 返回可以不受阻塞地从此输入流中读取的字节数。 void close() 关闭此管道输入流并释放与该流相关的所有系统资源。 void connect(PipedOutputStream src) 使此管道输入流连接到管道输出流 src。 int read() 读取此管道输入流中的下一个数据字节。 int read(byte[] b, int off, int len) 将最多 len 个数据字节从此管道输入流读入 byte 数组。 protected void receive(int b) 接收数据字节。 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package IO;import java.io.IOException;import java.io.PipedInputStream;import java.io.PipedOutputStream;/** * Created by chenjiabing on 17-5-25. *//** * 注意的问题： * 1.写线程正在往缓冲区写数据的时候，但是此时的读线程的管道结束，那么此时的写线程的管道就会发生IOException异常 * 2.读线程正在从缓冲区读数据的时候，但是此时的写线程的管道已经结束了，此时就会引起读线程的管道发生IOException异常 * 3.必须是启用多线程才能实现管道之间的读写，否则会出现堵塞现象，因为这里的PipeOutputStream每次向缓冲区写入的字节数最大是1024，如果不及时的减少缓冲区的数据量就会出现堵塞 */public class demo7 &#123; public static PipedOutputStream outputStream = new PipedOutputStream(); public static PipedInputStream inputStream = new PipedInputStream(); /** * 创建一个写入数据进程，使用的是PipeOutStream，将数据写入管道中 */ public static void send() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; byte[] bytes = new byte[2000]; //创建一个2000字节的数组 while (true) &#123; try &#123; outputStream.write(bytes, 0, 2000); //写入管道，但是这里的缓冲区最多写入1024个字节的数据，因此这个是一次没有写完 System.out.println("写入成功"); &#125; catch (IOException e) &#123; System.out.println("写入失败"); System.exit(1); &#125; &#125; &#125; &#125;).start(); &#125; /** * 使用PipeInputStream创建一个读取的线程 */ public static void receive() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; byte[] bytes = new byte[100]; //一次性只读取100个字节 int len = 0; try &#123; len = inputStream.read(bytes, 0, 100); //读取 while (len != -1) &#123; System.out.println("已经读取了" + len + "个字节"); len = inputStream.read(bytes, 0, 100); &#125; &#125; catch (IOException e) &#123; System.out.println("读取失败"); System.exit(1); &#125; &#125; &#125;).start(); &#125; public static void main(String args[]) &#123; try &#123; inputStream.connect(outputStream); //连接 &#125; catch (IOException e) &#123; System.out.println("连接失败"); System.exit(1); &#125; send(); receive(); &#125;&#125; 注意:从上面的运行结果可以看出，缓冲区最多可以写入1024个字节的数据，所以在缓冲区满了之后上面的send进程就会堵塞等待缓冲区空闲，如果recieve进程不继续读取数据了，那么就会一直出现堵塞 问题 写线程正在往缓冲区写数据的时候，但是此时的读线程的结束读取，那么此时的写线程的管道就会发生IOException异常，可以将上面receive进程中的while(true)去掉就可以清楚的看出 读线程正在从缓冲区读数据的时候，但是此时的写线程的管道已经结束了，此时就会引起读线程的管道发生IOException异常,将上面的send进程中的while(true)去掉就可以实现这个问题 必须是启用多线程才能实现管道之间的读写，否则会出现堵塞现象，因为这里的PipeOutputStream每次向缓冲区写入的字节数最大是1024，如果不及时的减少缓冲区的数据量就会出现堵塞 解决方法 后续更新中………. 参考文章 http://www.cnblogs.com/lich/archive/2011/12/11/2283928.html http://ifeve.com/java-io-%E7%AE%A1%E9%81%93/ http://www.cnblogs.com/chinareny2k/archive/2010/03/24/1693878.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java IO学习笔记四]]></title>
      <url>%2F2017%2F05%2F25%2FJava-IO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%2F</url>
      <content type="text"><![CDATA[内存操作流 之前的所有的流操作都是针对文件的，但是有时候只是想要实现数据间转换，此时如果我们想要创建一个文件然后再删除文件，那样显得有点麻烦，因此此时的内存操作流就显得很适合这类的操作，因为它只是在内存中存储，并不会真正的创建文件，内存操作流涉及的两个类是ByteArrayInputStream,ByteArrayOutputStream. ByteArrayInputStream ByteArrayInputStream 包含一个内部缓冲区，该缓冲区包含从流中读取的字节。内部计数器跟踪read方法要提供的下一个字节。 关闭 ByteArrayInputStream无效。此类中的方法在关闭此流后仍可被调用，而不会产生任何 IOException。 主要的功能是从缓冲区读取字节 构造函数 ByteArrayInputStream(byte[] buf) 创建一个 ByteArrayInputStream，使用 buf 作为其缓冲区数组。 ByteArrayInputStream(byte[] buf, int offset, int length) 创建 ByteArrayInputStream，使用 buf 作为其缓冲区数组。 常用的方法 close() 不过对这个无效，因为关闭之后仍然可以使用函数读取而不报错 int read() 从缓冲区中读取一个字节 int read(byte[] bytes) 将缓冲区中的内容读取到数组中 int read(byte[] bytes,int off,int len) 将最多 len 个数据字节从此输入流读入 byte 数组。 long skip(long n) 从此输入流中跳过n 个输入字节。 void reset() 将此 byte 数组输出流的 count 字段重置为零，从而丢弃输出流中目前已累积的所有输出（清除缓冲区） 实例1234567891011121314151617181920212223public class demo8 &#123; public static void main(String args[]) &#123; String str = "chenjiabing\n陈加兵"; byte[] bytes = str.getBytes(); //创建一个数组 ByteArrayInputStream inputStream = new ByteArrayInputStream(bytes); //使用bytes作为缓冲区数组 int temp = 0; /*第一种方法读取缓冲区中的数据，这个和文件的操作不一样，这个可以直接冲缓冲区中读取数据字节*/ while ((temp = inputStream.read()) != -1) &#123; System.out.print((char) temp); &#125; /*创建数组用于存储读取的内容，下面是第二种读取数据的方法*/ byte[] b = new byte[bytes.length]; try &#123; int len = inputStream.read(b); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println(new String(b)); &#125;&#125; ByteArrayOutputStream 此类实现了一个输出流，其中的数据被写入一个byte 数组。缓冲区会随着数据的不断写入而自动增长。可使用 toByteArray() 和 toString() 获取数据。 关闭 ByteArrayOutputStream 无效。此类中的方法在关闭此流后仍可被调用，而不会产生任何 IOException。 构造函数 ByteArrayOutputStream() 创建一个新的 byte数组输出流。 ByteArrayOutputStream(int size) 创建一个新的 byte 数组输出流，它具有指定大小的缓冲区容量（以字节为单位）。 常用函数 int size() 返回缓冲区的当前大小。 byte[] toByteArray() 创建一个新分配的 byte 数组。 String toString() 将缓冲区的字节转换成字符串 void write(byte[] b, int off, int len) 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此 byte 数组输出流。 void write(int b) 将指定的字节写入此 byte数组输出流。 实例12345678910111213141516171819202122232425262728293031public class demo8 &#123; public static void main(String args[]) &#123; ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); String str = "chenjiabing"; try &#123; outputStream.write(str.getBytes()); //将字符串转换成数组然后写入缓冲区 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; outputStream.close(); //这里的关闭无效 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //将缓冲区的数据转换成字符串后输出，这里同样可以看出输出流的关闭根本不影响函数的调用 System.out.println(outputStream.size()); //输出缓冲区的大小 System.out.println(outputStream.toString()); //输出chenjiabing outputStream.reset(); //清除缓冲区的内容，如果不清零那么原先写入的数据还是存在的，但是此时我们已经不需要前面的数据了 try &#123; outputStream.write("陈加兵".getBytes()); //继续向缓冲区写入数据 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println(outputStream.size()); //这里的一个汉字占了三个字节 System.out.println(outputStream.toString());//输出陈加兵 &#125;&#125; 综合 下面我们结合上面的两个类将字符串转换大小写 1234567891011121314151617public class demo8 &#123; public static void main(String args[]) &#123; ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); String str = "chenjiabing"; ByteArrayInputStream inputStream = new ByteArrayInputStream(str.getBytes()); //实例化输入流 int temp = 0; while ((temp = inputStream.read()) != -1) //读取缓冲区的字节数据 &#123; char c = (char) temp; //将整数转换成字符，ascii码的转换 outputStream.write(Character.toUpperCase(c)); //转换成大写，然后写入输出流的缓冲区中 &#125; System.out.println(outputStream.toString()); //利用输出流输出转换后的字符串，即是去取出内存中的数据 &#125;&#125; 参考文章 http://blog.csdn.net/yyyandroid/article/details/7756390 http://www.cnblogs.com/lich/archive/2011/12/11/2283883.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java IO学习笔记三]]></title>
      <url>%2F2017%2F05%2F24%2FJava-IO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89%2F</url>
      <content type="text"><![CDATA[Java IO学习笔记三 在整个IO包中，实际上就是分为字节流和字符流，但是除了这两个流之外，还存在了一组字节流-字符流的转换类。 OutputStreamWriter：是Writer的子类，将输出的字符流变为字节流，即：将一个字符流的输出对象变成字节流的输出对象。 InputStreamReader:是Reader的子类，将输入的字节流变为字符流，即：将一个字节流的输入对象变成字符流的输入对象。 一般在操作输入输出内容就需要使用字节或字符流，但是有些时候需要将字符流变成字节流的形式，或者将字节流变为字符流的形式，所以，就需要另外一组转换流的操作类。 InputStreamReader InputStreamReader 是字节流通向字符流的桥梁：它使用指定的 charset 读取字节并将其解码为字符。它使用的字符集可以由名称指定或显式给定，或者可以接受平台默认的字符集。 每次调用 InputStreamReader 中的一个 read() 方法都会导致从底层输入流读取一个或多个字节。要启用从字节到字符的有效转换，可以提前从底层流读取更多的字节，使其超过满足当前读取操作所需的字节。 主要的功能还是从文件中读取内容，不过是一次性的读取多个字节，这个很像它的子类FileReader 构造函数 InputStreamReader(InputStream in) 创建一个使用默认字符集的 InputStreamReader,不过这里的InputStream是抽下类，因此可以使用它的子类FileInputStream实例化，这里的FileInputStream是操作字节流的，显然看出这个类的作用就是字符流和字节流的桥梁 常用方法 close() int read() 读取单个字符 int read(Char[] c) 读取字符存储在字符数组中 int read(char[] cbuf, int offset, int length) 将字符读入数组中的某一部分 boolean ready() 判断此流是否已经准备好用于读取。 实例1234567891011121314151617181920212223242526272829303132333435363738394041package IO;import java.io.*;/** * Created by chenjiabing on 17-5-24. */public class demo4 &#123; public static void main(String args[]) &#123; File file = new File("/tmp" + File.separator + "test" + File.separator + "test.txt"); InputStreamReader inputStreamReader = null; try &#123; inputStreamReader = new InputStreamReader(new FileInputStream(file)); //初始化 char[] c = new char[(int) file.length()]; //创建数组 try &#123; int len = inputStreamReader.read(c); //将内容读取到数组中 System.out.println(len); for (int i = 0; i &lt; c.length; i++) &#123; System.out.print(c[i]); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125;finally &#123; if(inputStreamReader!=null) &#123; try &#123; inputStreamReader.close(); //关闭 &#125;catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 注意：从上面的代码中可以看到这个和FileReader的操作是一样的，只是构造的方法不一样 OutputStreamWriter OutputStreamWriter 是字符流通向字节流的桥梁：可使用指定的 charset 将要写入流中的字符编码成字节。它使用的字符集可以由名称指定或显式给定，否则将接受平台默认的字符集。 每次调用 write() 方法都会导致在给定字符（或字符集）上调用编码转换器。在写入底层输出流之前，得到的这些字节将在缓冲区中累积。可以指定此缓冲区的大小，不过，默认的缓冲区对多数用途来说已足够大。注意，传递给 write() 方法的字符没有缓冲。 主要的功能还是向文件中写入文件 构造函数 OutputStreamWriter(OutputStream out) 创建使用默认字符编码的 OutputStreamWriter。这里同样是抽象类，所以用它的子类FileOutputStream实例化 常用方法 close() flush() write(String str) 写入字符串 void write(String str, int off, int len) 写入字符串的某一部分。 write(int c) 写入单个字符 void write(char[] cbuf, int off, int len) 写入字符数组的某一部分。 实例12345678910111213141516171819202122232425262728293031323334353637383940414243package IO;import java.io.*;/** * Created by chenjiabing on 17-5-24. */public class demo5 &#123; public static void main(String[] args) &#123; File file=new File("/tmp"+File.separator+"test"+File.separator+"test.txt"); OutputStreamWriter outputStreamWriter=null; try &#123; outputStreamWriter=new OutputStreamWriter(new FileOutputStream(file,true)); String str="陈加兵\n"; int data=48; String name="chenjiabing"; try &#123; outputStreamWriter.write(str); outputStreamWriter.write(data); outputStreamWriter.write(name,0,2); //写入字符串的一部分 &#125;catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125;finally &#123; if(outputStreamWriter!=null) &#123; try &#123; outputStreamWriter.flush(); outputStreamWriter.close(); &#125;catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 从上面可以看出OutputStreamWriter和FileWriter的用法一样 综合使用 上面我们说了OutputStreamWriter和InputStreamWriter是字节流和字符流之间的桥梁，可以实现之间的转换，下面我们使用这两个之间的相互转换完成高效流的创建123456789/* * InputStreamReader实现了将字节流FileInputStream转换为字符流，然后使用转换来的字节流创建高效流，从而实现高效的读写 */File file = new File("/tmp/demo.txt");FileInputStream fileInputStream = new FileInputStream(file); // 创建字节输入流InputStreamReader inputStreamReader = new InputStreamReader( fileInputStream); // 转换为字符输入流BufferedReader bufferedReader = new BufferedReader(inputStreamReader); // 创建高效流对象 参考文章 http://www.cnblogs.com/lich/archive/2011/12/11/2283848.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java IO学习笔记二]]></title>
      <url>%2F2017%2F05%2F24%2FJava-IO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[Java IO学习笔记二流的概念 在程序中所有的数据都是以流的方式进行传输或保存的，程序需要数据的时候要使用输入流读取数据，而当程序需要将一些数据保存起来的时候，就要使用输出流完成。 程序中的输入输出都是以流的形式保存的，流中保存的实际上全都是字节文件。 字节流和字符流 实际上字节流在操作时本身不会用到缓冲区（内存），是文件本身直接操作的，而字符流在操作时使用了缓冲区，通过缓冲区再操作文件 在java.io包中操作文件内容的主要有两大类：字节流、字符流，两类都分为输入和输出操作。在字节流中输出数据主要是使用OutputStream完成，输入使的是InputStream，在字符流中输出主要是使用Writer类完成，输入流主要使用Reader类完成。（这四个都是抽象类） 操作流程 在Java中IO操作也是有相应步骤的，以文件操作为例，主要的操作流程如下： 使用File类打开一个文件 通过字节流或字符流的子类，指定输出的位置 进行读/写操作 关闭输入/输出 字节流 字节流主要是操作byte类型数据，以byte数组为准，主要操作类就是OutputStream、InputStream FileOutputStream 文件输出流是用于将数据写入 File 或 FileDescriptor 的输出流。文件是否可用或能否可以被创建取决于基础平台。特别是某些平台一次只允许一个 FileOutputStream（或其他文件写入对象）打开文件进行写入。在这种情况下，如果所涉及的文件已经打开，则此类中的构造方法将失败。 FileOutputStream 用于写入诸如图像数据之类的原始字节的流。要写入字符流，请考虑使用 FileWriter。 主要的功能就是用来向文件中写入内容的 构造函数 FileOutputStream(File file) 创建一个向指定 File 对象表示的文件中写入数据的文件输出流。 FileOutputStream(File file, boolean append) 如果在文件后面追加内容，如果append为true则追加内容 FileOutputStream(String name) 创建一个向具有指定名称的文件中写入数据的输出文件流。 FileOutputStream(String name, boolean append) 创建一个向具有指定 name 的文件中写入数据的输出文件流。 常用的方法 close() 关闭文件输出流 void write(byte[] b) 将 b.length 个字节从指定 byte 数组写入此文件输出流中。 void write(byte[] b, int off, int len) 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此文件输出流，这里需要注意的是中文所占字节数为3，英文所占字节数为1 void write(int b) 将指定字节写入此文件输出流，这个是按照ascii码写入文件的，并不是直接写入的是整数 实例123456789101112131415161718192021222324252627282930313233343536373839package File_demo;import java.io.*;public class demo &#123; public static void main(String[] args) &#123; FileOutputStream outputStream = null; File file = new File("/tmp" + File.separator + "test.txt"); try &#123; outputStream = new FileOutputStream(file); try &#123; int data = 48; String name = "陈加兵\n"; //使用\n换行 byte[] bytes = name.getBytes(); //将字符串转换成byte数组 outputStream.write(bytes, 0, 3); //将中文字符串的第一个字写入，这里一个中文占了三个字节 String age = "chenjiabing\n"; outputStream.write(age.getBytes()); outputStream.write(data); //这里的写入的acsii码中的( &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if (outputStream != null) &#123; try &#123; outputStream.close(); //关闭文件流 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 当然也可以一个一个的字节输出 1234567891011121314151617import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;public class Test11 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); OutputStream out=new FileOutputStream(f);//如果文件不存在会自动创建 String str="Hello World"; byte[] b=str.getBytes(); for(int i=0;i&lt;b.length;i++)&#123; out.write(b[i]); &#125; out.close(); &#125;&#125; FileInputStream FileInputStream 从文件系统中的某个文件中获得输入字节。哪些文件可用取决于主机环境。 FileInputStream 用于读取诸如图像数据之类的原始字节流。要读取字符流，请考虑使用 FileReader。 主要的功能是读取文件中的内容 构造函数 FileInputStream(File file) 通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的File对file指定。 FileInputStream(String name) 通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的路径名 name 指定。 常用方法 int read() 从输入流中读取数据字节，如果到达文件的末尾就返回-1 int read(byte[] b) 将文件中的内容读取到byte数组中，如果到达文件末尾返回-1 int read(byte[] b, int off, int len) 从此输入流中将最多 len 个字节的数据读入一个 byte 数组中,这个用于截取字节流，注意这里中文是占三个字节 long skip(long n) 从输入流中跳过并丢弃 n 个字节的数据，一旦跳过字节那么就从跳过的字节的后面开始读取 int available()返回的数据是输入流中的字节数，如果没有字节就返回0，因此可以用这个函数判断文件中是否还有内容 实例 针对知道的文件的大小然后创建一个数组存储，之后将数组转换成字符串，当然我们也可以一个一个的读取 1234567891011121314151617181920212223242526272829File file=new File("/tmp"+File.separator+"test.txt"); FileInputStream inputStream=null; try &#123; inputStream=new FileInputStream(file); try &#123; byte[] bytes=new byte[(int)file.length()]; //file.length返回文件的大小，这样就不会浪内存空间了 int flag=inputStream.read(bytes); //将文件的内容读入到数组中 System.out.println(new String(bytes)); //将bytes数组转换成字符串输出 System.out.println(flag); &#125;catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125;finally &#123; if(inputStream!=null) &#123; try &#123; inputStream.close(); &#125;catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 一个一个的读文件 1234567891011121314151617181920212223242526272829303132333435File file=new File("/tmp"+File.separator+"test.txt"); FileInputStream inputStream=null; try &#123; inputStream=new FileInputStream(file); try &#123; int len=0; //读取的字节 int i=0; //下标 byte[] bytes=new byte[(int)file.length()]; //创建数组 while((len=inputStream.read())!=-1) //判断是否读取到文件的末尾 &#123; bytes[i]=(byte)len; //将读到的整形数据转换成bytes类型的，存储在数组中 i++; &#125; System.out.println(new String(bytes)); //转换成字符串 &#125;catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125;finally &#123; if(inputStream!=null) &#123; try &#123; inputStream.close(); &#125;catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 使用available控制结束 12345678910111213141516171819202122232425262728293031323334353637File file = new File("/tmp" + File.separator + "test.txt"); FileInputStream inputStream = null; try &#123; inputStream = new FileInputStream(file); try &#123; byte[] bytes = new byte[(int) file.length()]; //file.length返回文件的大小，这样就不会浪内存空间了 int i = 0; while (inputStream.available() != 0) &#123; try &#123; bytes[i] = (byte) inputStream.read(); i++; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(new String(bytes)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if (inputStream != null) &#123; try &#123; inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 字符流 在程序中一个字符等于两个字节，那么java提供了Reader、Writer两个专门操作字符流的类。 前面已经说过字符流要用到缓冲区，因此在关闭字符流的时候一定要刷新缓冲区,清空缓冲区中的内容 字符输出流FileWriter 用来写入字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是可接受的。 FileWriter 用于写入字符流。要写入原始字节流，请考虑使用 FileOutputStream。 主要功能是向文件中写入内容 构造函数 FileWriter(File file) 根据给定的 File 对象构造一个 FileWriter 对象。 FileWriter(File file,boolean append) 追加 FileWriter(String fileName) 根据给定的文件名构造一个 FileWriter 对象。 FileWriter(String fileName, boolean append) 根据给定的文件名以及指示是否附加写入数据的 boolean 值来构造 FileWriter 对象。 常用方法 write(String str) 将字符写入文件 write(String str,int offest,int len) 截取字符串部分内容写入文件 write(int c) 写入单个字符，并不是整数 write(Char[] buf) 写入字符数组 close() 关闭流，在关闭之前必须刷新缓冲区 flush() 刷新缓冲区 实例123456789101112131415161718192021222324252627282930313233File file=new File("/tmp"+File.separator+"test"+File.separator+"test.txt"); File f1=new File("/tmp"+File.separator+"test"); if(!f1.exists()) &#123; f1.mkdir(); System.out.println("文件创建成功"); &#125; FileWriter fileWriter=null; try &#123; fileWriter=new FileWriter(file); String str="hello chenjiabing\n"; String name="陈加兵"; int data=48; fileWriter.write(str); //写入字符串 fileWriter.write(name); //写入中文字符串，这里直接写入不用转换成byte数组了 fileWriter.write(data); //写入单个字符 &#125;catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(fileWriter!=null) &#123; try &#123; fileWriter.flush(); //刷新缓冲区 fileWriter.close(); //关闭字符流 &#125;catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 注意: 这里字符流如果不关闭的话，那么就会就会写入文件失败，文件中没有内容，但是如果只有flush而没有close文件还是会写入成功的 字符输入流FileReader 用来读取字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的 主要的功能是读取文件内容 构造函数 FileReader(File file) 在给定从中读取数据的 File 的情况下创建一个新 FileReader。 FileReader(String fileName) 在给定从中读取数据的文件名的情况下创建一个新 FileReader。 常用函数 int read(char[] cbuf) 将字符读入数组。 int read() 读取单个字符，之后使用char类型强制转换成字符就行 read(char[] cbuf, int off, int len) 将字符读入数组的某一部分。 boolean ready() 判断是否准备读取此流，如果读到文件末尾那么就返回false long skip(long n) 跳过字符。 实例 用字符数组读取 12345678910111213141516171819202122232425File file = new File("/tmp" + File.separator + "test" + File.separator + "test.txt"); FileReader fileReader = null; try &#123; fileReader = new FileReader(file); char[] c = new char[(int) file.length()]; //根据文件的大小申请数组大小，不浪费 try &#123; int len = fileReader.read(c); //将文件的内容读取到字符数组中 for (int i = 0; i &lt; c.length; i++) &#123; System.out.println(c[i]); //将一个一个字符输出 &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if (fileReader != null) &#123; try &#123; fileReader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 使用ready控制是否读到文件末尾，当然也可以使用int read()==-1判断 12345678910111213141516171819202122232425File file = new File("/tmp" + File.separator + "test" + File.separator + "test.txt"); FileReader fileReader = null; try &#123; fileReader = new FileReader(file); char[] c = new char[(int) file.length()]; //根据文件的大小申请数组大小，不浪费 try &#123; while(fileReader.ready()) //判断是否读到文件末尾 &#123; System.out.println((char)fileReader.read()); //转换成字符 &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if (fileReader != null) &#123; try &#123; fileReader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 参考文章 http://www.cnblogs.com/lich/archive/2011/12/11/2283700.html http://www.cnblogs.com/absfree/p/5415092.html http://blog.csdn.net/zxman660/article/details/7875799 http://blog.csdn.net/cynhafa/article/details/6882061]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java IO学习笔记一]]></title>
      <url>%2F2017%2F05%2F23%2FJava-IO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%2F</url>
      <content type="text"><![CDATA[Java IO学习笔记一File File是文件和目录路径名的抽象表示形式，总的来说就是java创建删除文件目录的一个类库，但是作用不仅仅于此，详细见官方文档 构造函数 File(File parent, String child) 根据 parent 抽象路径名和 child 路径名字符串创建一个新 File 实例。 File(String pathname) 通过将给定路径名字符串转换为抽象路径名来创建一个新 File 实例。 File(String parent, String child) 根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例。 File(URI uri) 通过将给定的 file: URI 转换为一个抽象路径名来创建一个新的 File 实例。 实例123File file=new File("/tmp/demo"); //File(String pathname)File file=new File("/tmp","demo"); //File(String parent, String child) 常用方法字段 static String pathSeparator 与系统有关的路径分隔符，通常是: static String separator 与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。linux是/ 1File file=new File("/tmp"+File.separator+"demo"); //使用分隔符创建一个路径 方法摘要 boolean canExecute() 测试文件或者目录是否是可执行的，测试可执行权限 boolean canRead() 测试可读权限 boolean canWrite() 测试可写权限 boolean setExecutable(boolean executable) 设置文件或者目录的执行权限 setExecutable(boolean executable, boolean ownerOnly) 设置执行权限，如果第二个为true那么只有创建这个文件的用户拥有执行权限 boolean setReadable(boolean readable) 设置可读的权限 boolean setReadable(boolean readable, boolean ownerOnly) 同上 boolean setReadOnly() 标记此抽象路径名指定的文件或目录，从而只能对其进行读操作。 boolean setWritable(boolean writable) 设置可写的权限 boolean createNewFile() 创建一个文件，这里创建的不是目录 boolean mkdir() 创建文件夹 File getAbsoluteFile() 返回此抽象路径名的绝对路径名形式。 String getAbsolutePath() 返回此抽象路径名的绝对路径名字符串。 String getName() 返回由此抽象路径名表示的文件或目录的名称。 boolean isDirectory() 测试此抽象路径名表示的文件是否是一个目录。 boolean isFile() 测试此抽象路径名表示的文件是否是一个标准文件。 boolean isHidden() 测试此抽象路径名指定的文件是否是一个隐藏文件。 String[] list() 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中的文件和目录。 File[] listFiles() 返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。 实例创建文件12345678910111213141516File file=new File("/tmp/demo.txt"); if(file.exists())//如果文件存在就删除这个文件 &#123; file.delete(); &#125; else &#123; try&#123; file.createNewFile(); //创建一个文件 file.setExecutable(false); //设置执行权限 &#125;catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 创建文件夹1234567891011121314151617181920File file=new File("/tmp","test"); if(file.exists()) &#123; if(file.isDirectory()) //如果是一个文件夹 &#123; System.out.println("这是一个文件夹"); file.delete(); &#125; else if(file.isFile()) //如果是一个文件 &#123; System.out.println("这是一个文件"); &#125; &#125; else &#123; file.mkdir(); file.setWritable(false); //设置权限为不可读 &#125; 列出全部文件list 这个函数列出的是文件的名字并不是文件的路径 12345File f=new File("d:"+File.separator); String[] str=f.list(); //这里列出的仅仅是文件的名字，并不是文件的路径 for(String s:str)&#123; System.out.println(s); &#125; listFiles 这个列出的是文件的绝对路径 12345File f=new File("d:"+File.separator); File[] files=f.listFiles(); for(File file:files)&#123; System.out.println(file); &#125; 参考文章 http://www.cnblogs.com/lich/archive/2011/12/10/2283445.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python实现微信接口]]></title>
      <url>%2F2017%2F05%2F15%2Fpython%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E6%8E%A5%E5%8F%A3%2F</url>
      <content type="text"><![CDATA[python实现微信接口(itchat)安装 sudo pip install itchat 登录 itchat.auto_login() 这种方法将会通过微信扫描二维码登录，但是这种登录的方式确实短时间的登录，并不会保留登录的状态，也就是下次登录时还是需要扫描二维码，如果加上hotReload==True,那么就会保留登录的状态，至少在后面的几次登录过程中不会再次扫描二维码，该参数生成一个静态文件itchat.pkl用于存储登录状态 退出及登录完成后调用的特定的方法 这里主要使用的是灰调函数的方法,登录完成后的方法需要赋值在 loginCallback中退出后的方法,需要赋值在 exitCallback中.若不设置 loginCallback的值, 将会自动删除二维码图片并清空命令行显示. 12345678910import itchat, timedef lc(): print("Finash Login!")def ec(): print("exit")itchat.auto_login(loginCallback=lc, exitCallback=ec)time.sleep()itchat.logout() #强制退出登录 回复消息send send(msg=&quot;Text Message&quot;, toUserName=None) 参数： msg : 文本消息内容 @fil@path_to_file : 发送文件 @img@path_to_img : 发送图片 @vid@path_to_video : 发送视频 toUserName : 发送对象, 如果留空, 将发送给自己. 返回值 True or False 实例代码 1234567# coding-utf-8import itchatitchat.auto_login()itchat.send("Hello World!")ithcat.send("@fil@%s" % '/tmp/test.text')ithcat.send("@img@%s" % '/tmp/test.png')ithcat.send("@vid@%s" % '/tmp/test.mkv') send_msg send_msg(msg=&#39;Text Message&#39;, toUserName=None),其中的的msg是要发送的文本，toUserName是发送对象, 如果留空, 将发送给自己，返回值为True或者False 实例代码 123import itchatitchat.auto_login()itchat.send_msg("hello world.") send_file send_file(fileDir, toUserName=None) fileDir是文件路径, 当文件不存在时, 将打印无此文件的提醒，返回值为True或者False 实例代码 1234mport itchatitchat.auto_login()itchat.send_file("/tmp/test.txt") send_image send_image(fileDir, toUserName=None) 参数同上 实例代码 12345import itchatitchat.auto_login()itchat.send_img("/tmp/test.txt") send_video send_video(fileDir, toUserName=None) 参数同上 实例代码 1234import itchatitchat.auto_login()itchat.send_video("/tmp/test.txt") 注册消息方法 itchat 将根据接受到的消息类型寻找对应的已注册的方法.如果一个消息类型没有对应的注册方法, 该消息将会被舍弃.在运行过程中也可以动态注册方法, 注册方式与结果不变. 注册方法 不带具体对象注册, 将注册为普通消息的回复方法. 1234567import itchatfrom itchat.content import *@itchat.msg_register(TEXT) #这里的TEXT表示如果有人发送文本消息，那么就会调用下面的方法def simple_reply(msg): #这个是向发送者发送消息 itchat.send_msg('已经收到了文本消息，消息内容为%s'%msg['Text'],toUserName=msg['FromUserName']) return "T reveived: %s" % msg["Text"] #返回的给对方的消息，msg["Text"]表示消息的内容 带对象参数注册, 对应消息对象将调用该方法，其中isFriendChat表示好友之间，isGroupChat表示群聊，isMapChat表示公众号 123456import itchatfrom itchat.content import *@itchat.msg_register(TEXT, isFriendChat=True, isGroupChat=True,isMpChat=True)def text_reply(msg): msg.user.send("%s : %s" % (mst.type, msg.text)) 消息类型向注册方法传入的 msg 包含微信返回的字典的所有内容.itchat 增加 Text, Type(也就是参数) 键值, 方便操作.itcaht.content中包含所有的消息类型参数, 如下表 参数 l类型 Text 键值 TEXT 文本 文本内容(文字消息) MAP 地图 位置文本(位置分享) CARD 名片 推荐人字典(推荐人的名片) SHARING 分享 分享名称(分享的音乐或者文章等) PICTURE 下载方法 图片/表情 RECORDING 语音 下载方法 ATTACHMENT 附件 下载方法 VIDEO 小视频 下载方法 FRIENDS 好友邀请 添加好友所需参数 SYSTEM 系统消息 更新内容的用户或群聊的UserName组成的列表 NOTE 通知 通知文本(消息撤回等) 附件的下载与发送 itchat 的附件下载方法存储在 msg 的 Text 键中.发送的文件名(图片给出的默认文件名), 都存储在 msg 的 FileName 键中.下载方法, 接受一个可用的位置参数(包括文件名), 并将文件响应的存储.注意：下载的文件存储在指定的文件中，直接将路径与FileName连接即可，如msg[&quot;Text&quot;](&#39;/tmp/weichat&#39;+msg[&#39;FileName&#39;]) 123456@itchat.msg_register([PICTURE, RECORDING, ATTACHMENT, VIDEO])def download_files(msg): #msg.download(msg['FileName']) #这个同样是下载文件的方式 msg['Text'](msg['FileName']) #下载文件 #将下载的文件发送给发送者 itchat.send('@%s@%s' % ('img' if msg['Type'] == 'Picture' else 'fil', msg["FileName"]), msg["FromUserName"]) 群消息 增加了三个键值，如下： isAt 判断是否 @ 本号 ActualNickName : 实际 NickName(昵称) Content : 实际 Content 测试程序 1234567891011import itcahtfrom itchat.content import TEXT@itchat.msg_register(TEXT, isGroupChat=True)def text_reply(msg): if(msg.isAt): #判断是否有人@自己 #如果有人@自己，就发一个消息告诉对方我已经收到了信息 itchat.send_msg("我已经收到了来自&#123;0&#125;的消息，实际内容为&#123;1&#125;".format(msg['ActualNickName'],msg['Text']),toUserName=msg['FromUserName'])itchat.auto_login()itchat.run() 注册消息的优先级 总的来说就是后面注册同种类型的消息会覆盖之前注册的消息，详情见文档https://itchat.readthedocs.io/zh/latest/ 消息内容 注意：所有的消息内容都是可以用键值对来访问的，如msg[&quot;FromUserName]就是查看发送者，itchat.search_friends(userName=msg[&#39;FromUserName&#39;])[&#39;NickName&#39;]查看的是当发送者昵称 一般消息一般的消息都遵循以下的内容： 12345678910111213141516171819202122232425262728&#123; "FromUserName": "", "ToUserName": "", "Content": "", "StatusNotifyUserName": "", "ImgWidth": 0, "PlayLength": 0, "RecommendInfo": &#123;&#125;, "StatusNotifyCode": 0, "NewMsgId": "", "Status": 0, "VoiceLength": 0, "ForwardFlag": 0, "AppMsgType": 0, "Ticket": "", "AppInfo": &#123;&#125;, "Url": "", "ImgStatus": 0, "MsgType": 0, "ImgHeight": 0, "MediaId": "", "MsgId": "", "FileName": "", "HasProductId": 0, "FileSize": "", "CreateTime": 0, "SubMsgType": 0&#125; 初始化消息123456789101112131415161718192021222324252627MsgType: 51 FromUserName: 自己ID ToUserName: 自己ID StatusNotifyUserName: 最近联系的联系人ID Content: &lt;msg&gt; &lt;op id='4'&gt; &lt;username&gt; # 最近联系的联系人 filehelper,xxx@chatroom,wxid_xxx,xxx,... &lt;/username&gt; &lt;unreadchatlist&gt; &lt;chat&gt; &lt;username&gt; # 朋友圈 MomentsUnreadMsgStatus &lt;/username&gt; &lt;lastreadtime&gt; 1454502365 &lt;/lastreadtime&gt; &lt;/chat&gt; &lt;/unreadchatlist&gt; &lt;unreadfunctionlist&gt; # 未读的功能账号消息，群发助手，漂流瓶等 &lt;/unreadfunctionlist&gt; &lt;/op&gt; &lt;/msg&gt; 文本消息1234MsgType: 1 FromUserName: 发送方ID ToUserName: 接收方ID Content: 消息内容 图片消息 itchat 增加了 Text 键, 键值为 下载该图片的方法. 123456789MsgType: 3 FromUserName: 发送方ID ToUserName: 接收方ID MsgId: 用于获取图片，用于表示每一条消息 Content: &lt;msg&gt; &lt;img length="6503" hdlength="0" /&gt; &lt;commenturl&gt;&lt;/commenturl&gt; &lt;/msg&gt; 拓展：如果想要得到Content中的具体内容可以使用正则表达式匹配出来 视频消息 **itchat 增加了 Text 键, 键值为 下载该视频的方法. 123456789MsgType: 62FromUserName: 发送方IDToUserName: 接收方IDMsgId: 用于获取小视频Content: &lt;msg&gt; &lt;img length="6503" hdlength="0" /&gt; &lt;commenturl&gt;&lt;/commenturl&gt; &lt;/msg&gt; 地理位置消息 itchat 增加了 Text 键, 键值为 该地点的文本形式. 123456789MsgType: 1 FromUserName: 发送方ID ToUserName: 接收方ID Content: http://weixin.qq.com/cgi-bin/redirectforward?args=xxx OriContent:&lt;?xml version="1.0"?&gt;&lt;msg&gt; &lt;location x="34.195278" y="117.177803" scale="16" label="江苏省徐州市铜山区新区海河路" maptype="0" poiname="江苏师范大学大学生公寓园区" /&gt;&lt;/msg&gt; 名片消息 itchat 增加了Text 键, 键值为 该调用 add_friend 需要的属性. 123456789101112131415161718192021222324MsgType: 42 FromUserName: 发送方ID ToUserName: 接收方ID Content: &lt;?xml version="1.0"?&gt; &lt;msg bigheadimgurl="" smallheadimgurl="" username="" nickname="" shortpy="" alias="" imagestatus="3" scene="17" province="" city="" sign="" sex="1" certflag="0" certinfo="" brandIconUrl="" brandHomeUrl="" brandSubscriptConfigUrl="" brandFlags="0" regionCode="" /&gt; RecommendInfo: &#123; "UserName": "xxx", # ID，这里的是昵称 "Province": "xxx", "City": "xxx", "Scene": 17, "QQNum": 0, "Content": "", "Alias": "xxx", # 微信号 "OpCode": 0, "Signature": "", "Ticket": "", "Sex": 0, # 1:男, 2:女 "NickName": "xxx", # 昵称 "AttrStatus": 4293221, "VerifyFlag": 0 &#125; 下面是添加好友的测试代码 1234567@itchat.msg_register(itchat.content.CARD,isFriendChat=True)def simply(msg): print msg['Text'] print msg['Content'] itchat.add_friend(userName=msg['Text']['UserName']) #添加推荐的好友 print msg['RecommendInfo'] print msg['RecommendInfo']['UserName'] 语音消息 *itchat增加了Text键,键值为下载该语音文件的方法,下载下来的是MP3的格式 123456789MsgType: 34 FromUserName: 发送方ID ToUserName: 接收方ID MsgId: 用于获取语音 Content: &lt;msg&gt; &lt;voicemsg endflag="1" cancelflag="0" forwardflag="0" voiceformat="4" voicelength="1580" length="2026" bufid="216825389722501519" clientmsgid="49efec63a9774a65a932a4e5fcd4e923filehelper174_1454602489" fromusername="" /&gt; &lt;/msg&gt; 下载方法：msg[&#39;Text&#39;](msg[&#39;FileName&#39;]) 动画表情 itchat添加了Text键，键值为下载该图片表情的方法。注意：本人亲测对于一些微信商店提供的表情是不能下载成功的,这里的自带的表情emoji是属于TEXT类别的，因此如果将其注册为PICTURE消息类型的话是不可以监测到的 12345678MsgType: 47 FromUserName: 发送方ID ToUserName: 接收方ID Content: &lt;msg&gt; &lt;emoji fromusername = "" tousername = "" type="2" idbuffer="media:0_0" md5="e68363487d8f0519c4e1047de403b2e7" len = "86235" productid="com.tencent.xin.emoticon.bilibili" androidmd5="e68363487d8f0519c4e1047de403b2e7" androidlen="86235" s60v3md5 = "e68363487d8f0519c4e1047de403b2e7" s60v3len="86235" s60v5md5 = "e68363487d8f0519c4e1047de403b2e7" s60v5len="86235" cdnurl = "http://emoji.qpic.cn/wx_emoji/eFygWtxcoMF8M0oCCsksMA0gplXAFQNpiaqsmOicbXl1OC4Tyx18SGsQ/" designerid = "" thumburl = "http://mmbiz.qpic.cn/mmemoticon/dx4Y70y9XctRJf6tKsy7FwWosxd4DAtItSfhKS0Czr56A70p8U5O8g/0" encrypturl = "http://emoji.qpic.cn/wx_emoji/UyYVK8GMlq5VnJ56a4GkKHAiaC266Y0me0KtW6JN2FAZcXiaFKccRevA/" aeskey= "a911cc2ec96ddb781b5ca85d24143642" &gt;&lt;/emoji&gt; &lt;gameext type="0" content="0" &gt;&lt;/gameext&gt; &lt;/msg&gt; 普通链接或应用分享消息 主要针对的是分享的文章等等 12345678910111213141516171819202122MsgType: 49AppMsgType: 5FromUserName: 发送方IDToUserName: 接收方IDUrl: 链接地址FileName: 链接标题Content: &lt;msg&gt; &lt;appmsg appid="" sdkver="0"&gt; &lt;title&gt;&lt;/title&gt; &lt;des&gt;&lt;/des&gt; &lt;type&gt;5&lt;/type&gt; &lt;content&gt;&lt;/content&gt; &lt;url&gt;&lt;/url&gt; &lt;thumburl&gt;&lt;/thumburl&gt; ... &lt;/appmsg&gt; &lt;appinfo&gt; &lt;version&gt;&lt;/version&gt; &lt;appname&gt;&lt;/appname&gt; &lt;/appinfo&gt; &lt;/msg&gt; 音乐链接消息 主要针对的是音乐 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758MsgType: 49 AppMsgType: 3 FromUserName: 发送方ID ToUserName: 接收方ID Url: 链接地址 FileName: 音乐名 AppInfo: # 分享链接的应用 &#123; Type: 0, AppID: wx485a97c844086dc9 &#125; Content: &lt;msg&gt; &lt;appmsg appid="wx485a97c844086dc9" sdkver="0"&gt; &lt;title&gt;&lt;/title&gt; &lt;des&gt;&lt;/des&gt; &lt;action&gt;&lt;/action&gt; &lt;type&gt;3&lt;/type&gt; &lt;showtype&gt;0&lt;/showtype&gt; &lt;mediatagname&gt;&lt;/mediatagname&gt; &lt;messageext&gt;&lt;/messageext&gt; &lt;messageaction&gt;&lt;/messageaction&gt; &lt;content&gt;&lt;/content&gt; &lt;contentattr&gt;0&lt;/contentattr&gt; &lt;url&gt;&lt;/url&gt; &lt;lowurl&gt;&lt;/lowurl&gt; &lt;dataurl&gt; http://ws.stream.qqmusic.qq.com/C100003i9hMt1bgui0.m4a?vkey=6867EF99F3684&amp;amp;guid=ffffffffc104ea2964a111cf3ff3edaf&amp;amp;fromtag=46 &lt;/dataurl&gt; &lt;lowdataurl&gt; http://ws.stream.qqmusic.qq.com/C100003i9hMt1bgui0.m4a?vkey=6867EF99F3684&amp;amp;guid=ffffffffc104ea2964a111cf3ff3edaf&amp;amp;fromtag=46 &lt;/lowdataurl&gt; &lt;appattach&gt; &lt;totallen&gt;0&lt;/totallen&gt; &lt;attachid&gt;&lt;/attachid&gt; &lt;emoticonmd5&gt;&lt;/emoticonmd5&gt; &lt;fileext&gt;&lt;/fileext&gt; &lt;/appattach&gt; &lt;extinfo&gt;&lt;/extinfo&gt; &lt;sourceusername&gt;&lt;/sourceusername&gt; &lt;sourcedisplayname&gt;&lt;/sourcedisplayname&gt; &lt;commenturl&gt;&lt;/commenturl&gt; &lt;thumburl&gt; http://imgcache.qq.com/music/photo/album/63/180_albumpic_143163_0.jpg &lt;/thumburl&gt; &lt;md5&gt;&lt;/md5&gt; &lt;/appmsg&gt; &lt;fromusername&gt;&lt;/fromusername&gt; &lt;scene&gt;0&lt;/scene&gt; &lt;appinfo&gt; &lt;version&gt;29&lt;/version&gt; &lt;appname&gt;摇一摇搜歌&lt;/appname&gt; &lt;/appinfo&gt; &lt;commenturl&gt;&lt;/commenturl&gt; &lt;/msg&gt; 群消息 itchat 增加了三个群聊相关的键值: isAt : 判断是否 @ 本号 ActualNickName : 实际 NickName Content : 实际 Content 12345MsgType: 1FromUserName: @@xxxToUserName: @xxxContent: @xxx:&lt;br/&gt;xxx 红包消息12345MsgType: 49 AppMsgType: 2001 FromUserName: 发送方ID ToUserName: 接收方ID Content: 未知 系统消息1234567MsgType: 10000 FromUserName: 发送方ID ToUserName: 自己ID Content: "你已添加了 xxx ，现在可以开始聊天了。" "如果陌生人主动添加你为朋友，请谨慎核实对方身份。" "收到红包，请在手机上查看" 账号类型 tchat 为三种账号都提供了 整体获取方法与搜索方法. 好友get_friends itchat.get_friends() 返回完整的好友列表 每个好友为一个字典, 其中第一项为本人的账号信息; 传入update=True, 将更新好友列表并返回, get_friends(update=True) search_friends itchat.get_friends() 好友搜索，有以下四种方式 仅获取自己的用户信息 12# 获取自己的用户信息，返回自己的属性字典itchat.search_friends() 获取特定 UserName 的用户信息 12345678910# 获取特定UserName的用户信息itchat.search_friends(userName='@abcdefg1234567') ## 获取发送信息的好友的详细信息@itchat.msg_register(itchat.content.TEXT,isFriendChat=True)def reply(msg): print msg['FromUserName'] print itchat.search_friends(userName=msg['FromUserName']) #详细信息 print itchat.search_friends(userName=msg['FromUserName'])['NickName'] #获取昵称 获取备注,微信号, 昵称中的任何一项等于name键值的用户. (可以与下一项配置使用.) 比如在我的微信中有一个备注为autolife的人，我可以使用这个方法搜索出详细的信息 12# 获取任何一项等于name键值的用户itchat.search_friends(name='autolife') 获取备注,微信号, 昵称分别等于相应键值的用户. (可以与上一项配置使用.) 1234# 获取分别对应相应键值的用户itchat.search_friends(wechatAccount='littlecodersh')# 三、四项功能可以一同使用itchat.search_friends(name='LittleCoder机器人', wechatAccount='littlecodersh') update_friend 主要用于好友更新 特定用户: 传入用户UserName, 返回指定用户的最新信息. 用户列表: 传入 UserName 组成的列表, 返回用户最新信息组成的列表 1memberList = itchat.update_friend('@abcdefg1234567') 公众号get_mps 将返回完整的工作号列表 每个公众号为一个字典, 传入 update=True 将更新公众号列表, 并返回. search_mps 获取特定UserName的公众号 12# 获取特定UserName的公众号，返回值为一个字典itchat.search_mps(userName='@abcdefg1234567') 获取名字中还有特定字符的公众号. 12# 获取名字中含有特定字符的公众号，返回值为一个字典的列表itchat.search_mps(name='LittleCoder') 当两项都是勇士, 将仅返回特定UserName的公众号. 群聊 get_chatrooms : 返回完整的群聊列表. search_chatrooms : 群聊搜索. update_chatroom : 获取群聊用户列表或更新该群聊. 群聊在首次获取中不会获取群聊的用户列表, 所以需要调用该命令才能获取群聊成员. 传入群聊的 UserName , 返回特定群聊的详细信息. 传入UserName组成的列表, 返回指定用户的最新信息组成的列表. 1memberList = itchat.update_chatroom('@@abcdefg1234567', detailedMember=True) 创建群聊,增加/删除群聊用户: 由于之前通过群聊检测是否被好友拉黑的程序, 目前这三个方法都被严格限制了使用频率. 删除群聊需要本账号为管理员, 否则无效. 将用户加入群聊有直接加入与发送邀请, 通过 useInvitation 设置. 超过 40 人的群聊无法使用直接加入的加入方式. 1234567memberList = itchat.get_frients()[1:]# 创建群聊, topic 键值为群聊名称.chatroomUserName = itchat.create_chatroom(memberList, "test chatroom")# 删除群聊内的用户itchat.delete_member_from_chatroom(chatroomUserName, memberList[0])# 增加用户进入群聊.itchat.add_member_into_chatroom(chatroomUserName, memberList[0], useInvitation=False) 方法汇总1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253itchat.add_friend itchat.new_instance itchat.add_member_into_chatroom itchat.originInstance itchat.auto_login itchat.returnvalues itchat.check_login itchat.run itchat.components itchat.search_chatrooms itchat.config itchat.search_friends itchat.configured_reply itchat.search_mps itchat.content itchat.send itchat.core itchat.send_file itchat.Core itchat.send_image itchat.create_chatroom itchat.send_msg itchat.delete_member_from_chatroom itchat.send_raw_msg itchat.dump_login_status itchat.send_video itchat.get_chatrooms itchat.set_alias itchat.get_contact itchat.set_chatroom_name itchat.get_friends itchat.set_logging itchat.get_head_img itchat.set_pinned itchat.get_mps itchat.show_mobile_login itchat.get_msg itchat.start_receiving itchat.get_QR itchat.storage itchat.get_QRuuid itchat.update_chatroom itchat.instanceList itchat.update_friend itchat.load_login_status itchat.upload_file itchat.log itchat.utils itchat.login itchat.VERSION itchat.logout itchat.web_init itchat.msg_register 实例 下面是博主写的一个程序，该程序的主要功能是监控撤回消息，并且如果有消息撤回就会撤回的消息发送给你，以后再也不用担心看不到好友的撤回的消息了，由于注释写的很详细，因此这里就不在详细的讲解了，直接贴代码 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106# coding:utf-8import itchatfrom itchat.content import TEXTfrom itchat.content import *import sysimport timeimport rereload(sys)sys.setdefaultencoding('utf8')import osmsg_information = &#123;&#125;face_bug=None #针对表情包的内容@itchat.msg_register([TEXT, PICTURE, FRIENDS, CARD, MAP, SHARING, RECORDING, ATTACHMENT, VIDEO],isFriendChat=True, isGroupChat=True, isMpChat=True)def handle_receive_msg(msg): global face_bug msg_time_rec = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) #接受消息的时间 msg_from = itchat.search_friends(userName=msg['FromUserName'])['NickName'] #在好友列表中查询发送信息的好友昵称 msg_time = msg['CreateTime'] #信息发送的时间 msg_id = msg['MsgId'] #每条信息的id msg_content = None #储存信息的内容 msg_share_url = None #储存分享的链接，比如分享的文章和音乐 print msg['Type'] print msg['MsgId'] if msg['Type'] == 'Text' or msg['Type'] == 'Friends': #如果发送的消息是文本或者好友推荐 msg_content = msg['Text'] print msg_content #如果发送的消息是附件、视屏、图片、语音 elif msg['Type'] == "Attachment" or msg['Type'] == "Video" \ or msg['Type'] == 'Picture' \ or msg['Type'] == 'Recording': msg_content = msg['FileName'] #内容就是他们的文件名 msg['Text'](str(msg_content)) #下载文件 # print msg_content elif msg['Type'] == 'Card': #如果消息是推荐的名片 msg_content = msg['RecommendInfo']['NickName'] + '的名片' #内容就是推荐人的昵称和性别 if msg['RecommendInfo']['Sex'] == 1: msg_content += '性别为男' else: msg_content += '性别为女' print msg_content elif msg['Type'] == 'Map': #如果消息为分享的位置信息 x, y, location = re.search( "&lt;location x=\"(.*?)\" y=\"(.*?)\".*label=\"(.*?)\".*", msg['OriContent']).group(1, 2, 3) if location is None: msg_content = r"纬度-&gt;" + x.__str__() + " 经度-&gt;" + y.__str__() #内容为详细的地址 else: msg_content = r"" + location elif msg['Type'] == 'Sharing': #如果消息为分享的音乐或者文章，详细的内容为文章的标题或者是分享的名字 msg_content = msg['Text'] msg_share_url = msg['Url'] #记录分享的url print msg_share_url face_bug=msg_content##将信息存储在字典中，每一个msg_id对应一条信息 msg_information.update( &#123; msg_id: &#123; "msg_from": msg_from, "msg_time": msg_time, "msg_time_rec": msg_time_rec, "msg_type": msg["Type"], "msg_content": msg_content, "msg_share_url": msg_share_url &#125; &#125; )##这个是用于监听是否有消息撤回@itchat.msg_register(NOTE, isFriendChat=True, isGroupChat=True, isMpChat=True)def information(msg): #这里如果这里的msg['Content']中包含消息撤回和id，就执行下面的语句 if '撤回了一条消息' in msg['Content']: old_msg_id = re.search("\&lt;msgid\&gt;(.*?)\&lt;\/msgid\&gt;", msg['Content']).group(1) #在返回的content查找撤回的消息的id old_msg = msg_information.get(old_msg_id) #得到消息 print old_msg if len(old_msg_id)&lt;11: #如果发送的是表情包 itchat.send_file(face_bug,toUserName='filehelper') else: #发送撤回的提示给文件助手 msg_body = "告诉你一个秘密~" + "\n" \ + old_msg.get('msg_from') + " 撤回了 " + old_msg.get("msg_type") + " 消息" + "\n" \ + old_msg.get('msg_time_rec') + "\n" \ + "撤回了什么 ⇣" + "\n" \ + r"" + old_msg.get('msg_content') #如果是分享的文件被撤回了，那么就将分享的url加在msg_body中发送给文件助手 if old_msg['msg_type'] == "Sharing": msg_body += "\n就是这个链接➣ " + old_msg.get('msg_share_url') # 将撤回消息发送到文件助手 itchat.send_msg(msg_body, toUserName='filehelper') # 有文件的话也要将文件发送回去 if old_msg["msg_type"] == "Picture" \ or old_msg["msg_type"] == "Recording" \ or old_msg["msg_type"] == "Video" \ or old_msg["msg_type"] == "Attachment": file = '@fil@%s' % (old_msg['msg_content']) itchat.send(msg=file, toUserName='filehelper') os.remove(old_msg['msg_content']) # 删除字典旧消息 msg_information.pop(old_msg_id)itchat.auto_login(hotReload=True)itchat.run() 参考文章 文档：https://itchat.readthedocs.io/zh/latest/ http://www.cnblogs.com/yanjingnan/p/6831464.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python发送邮件]]></title>
      <url>%2F2017%2F05%2F13%2Fpython%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[python发送邮件准备 python中发送邮件主要用的是smtplib和email两个模块，下面主要对这两个模块进行讲解 在讲解之前需要准备至少两个测试的邮箱，其中要在邮箱的设置中开启smtplib协议才可以进行发送和接受 smtplib smtplib.SMTP( [host [, port [, local_hostname[,timeout]]]]) host是SMTP主机的服务器，其中163邮箱的是smtp.163.com,其他的可以在网上找到，port是端口号，这里默认的是25，local_hostname是你主机的SMTP,如果SMTP在你的本机上，你只需要指定服务器地址为 localhost 即可。timeout是设置的连接的限制时间，如果超过这个时间还没有连接上那么就会出现错误 SMTP.set_debuglevel(level)：设置是否为调试模式。默认为False，即非调试模式，表示不输出任何调试信息。如果设置为1就表示输出调试信息 SMTP.connect([host[, port]])：连接到指定的smtp服务器。参数分别表示smpt主机和端口。注意: 也可以在host参数中指定端口号（如：smpt.yeah.net:25），这样就没必要给出port参数。 SMTP.login(user, password) 登录服务器，这里的user是邮箱的用户名，但是这里的password并不是你邮箱的密码，当你开启SMTP的时候会提示你设置一个密码，这里的密码就是对应的密码 SMTP.sendmail(from_addr, [to_addrs,], msg[, mail_options, rcpt_options]) 发送邮件，from_addr是发送方也就是你的邮箱地址，to_addr是接受方的地址，当然这里的可以填上多个邮箱账号发送给多个账号，如果有多个账号需要使用列表传递参数 SMTP.quit()断开连接 email emial模块用来处理邮件消息，包括MIME和其他基于RFC 2822的消息文档。使用这些模块来定义邮件的内容，是非常简单的。其包括的类有（更加详细的介绍可见：http://docs.python.org/library/email.mime.html）： class email.mime.base.MIMEBase(_maintype, _subtype, **_params)：这是MIME的一个基类。一般不需要在使用时创建实例。其中_maintype是内容类型，如text或者image。_subtype是内容的minor type类型，如plain或者gif。 **_params是一个字典，直接传递给Message.add_header()。 class email.mime.multipart.MIMEMultipart([_subtype[, boundary[, _subparts[, _params]]]]：MIMEBase的一个子类，多个MIME对象的集合，_subtype默认值为mixed。boundary是MIMEMultipart的边界，默认边界是可数的。当需要发送附件的时候使用的就是这个类 class email.mime.application.MIMEApplication(_data[, _subtype[, _encoder[, **_params]]])：MIMEMultipart的一个子类。 class email.mime.audio. MIMEAudio(_audiodata[, _subtype[, _encoder[, **_params]]])： MIME音频对象 class email.mime.image.MIMEImage(_imagedata[, _subtype[, _encoder[, **_params]]])：MIME二进制文件对象。主要用来发送图片 普通文本邮件 class email.mime.text.MIMEText(_text[, _subtype[, _charset]])：MIME文本对象，其中_text是邮件内容，_subtype邮件类型，可以是text/plain（普通文本邮件），html/plain(html邮件), _charset编码，可以是gb2312等等。 普通文本邮件发送的实现，关键是要将MIMEText中_subtype设置为plain。首先导入smtplib和mimetext。创建smtplib.smtp实例，connect邮件smtp服务器，login后发送，具体代码如下* 1234567891011121314151617181920212223# 一个格式化邮件的函数，可以用来使用def _format_addr(s): name, addr = parseaddr(s) return formataddr(( Header(name, 'utf-8').encode(), addr.encode('utf-8') if isinstance(addr, unicode) else addr))from_addr='××××××××' #你的邮箱地址from_password='×××××××' #你的密码# to_email='chenjiabing666@yeah.net'to_email='××××××' #要发送的邮箱地址msg=MIMEText('乔装打扮，不择手段','plain','utf-8') #这里text=乔装打扮，不择手段msg['From'] = _format_addr(u'Python爱好者 &lt;%s&gt;' % from_addr) #格式化发件人msg['To'] = _format_addr(u'管理员 &lt;%s&gt;' % to_email) #格式化收件人msg['Subject'] = Header(u'来自SMTP的问候……', 'utf-8').encode() #格式化主题stmp='smtp.163.com'server=smtplib.SMTP(stmp,port=25,timeout=30) #连接，设置超时时间30sserver.login(from_addr,from_password) #登录server.set_debuglevel(1) #输出所有的信息server.sendmail(from_addr,to_email,msg.as_string()) #这里的as_string()是将msg转换成字符串类型的,如果你想要发给多个人，需要讲to_email换成一个列表 发送html邮件 还是用MIMEText来发送，不过其中的_subType设置成html即可，详细代码如下： 12345678910111213141516171819202122232425def _format_addr(s): name, addr = parseaddr(s) return formataddr(( Header(name, 'utf-8').encode(), addr.encode('utf-8') if isinstance(addr, unicode) else addr))from_addr='××××××××' #你的邮箱地址from_password='×××××××' #你的密码# to_email='chenjiabing666@yeah.net'to_email='××××××' #要发送的邮箱地址html="""&lt;p&gt;&lt;h1 style="color:red"&gt;大家好&lt;/h1&gt;&lt;/p&gt;"""msg=MIMEText(html,'html','utf-8') #这里text=html,设置成html格式的msg['From'] = _format_addr(u'Python爱好者 &lt;%s&gt;' % from_addr) #格式化发件人msg['To'] = _format_addr(u'管理员 &lt;%s&gt;' % to_email) #格式化收件人msg['Subject'] = Header(u'来自SMTP的问候……', 'utf-8').encode() #格式化主题stmp='smtp.163.com'server=smtplib.SMTP(stmp,port=25,timeout=30) #连接，设置超时时间30sserver.login(from_addr,from_password) #登录server.set_debuglevel(1) #输出所有的信息server.sendmail(from_addr,to_email,msg.as_string()) #这里的as_string()是将msg转换成字符串类型的,如果你想要发给多个人，需要讲to_email换成一个列表 附件的发送 发送带附件的邮件，首先要创建MIMEMultipart()实例，然后构造附件，如果有多个附件，可依次构造，最后利用smtplib.smtp发送，具体实力如下： 123456789101112131415161718192021222324252627282930313233343536373839404142from email.mime.multipart import MIMEMultipartfrom email.mime.text import MIMETextimport smtplibfrom email.mime.image import MIMEImagefrom email.mime.multipart import MIMEMultipartfrom email.mime.text import MIMETextfrom email.header import Headerdef _format_addr(s): name, addr = parseaddr(s) return formataddr(( Header(name, 'utf-8').encode(), addr.encode('utf-8') if isinstance(addr, unicode) else addr))from_addr='××××××××' #你的邮箱地址from_password='×××××××' #你的密码# to_email='chenjiabing666@yeah.net'to_email='××××××' #要发送的邮箱地址msg=MIMEMultipart() #创建实例text=MIMEText('&lt;h2 style="color:red"&gt;陈加兵&lt;/h2&gt;&lt;br/&gt;&lt;p&gt;大家好&lt;/p&gt;','html','utf-8')msg.attach(text) #添加一个正文信息，这里实在正文中显示的信息#创建一个文本附件，这里是从指定文本中读取信息，然后创建一个文本信息att1=MIMEText(open('/home/chenjiabing/文档/MeiZi_img/full/file.txt','rb').read(),'plain','utf-8')att1["Content-Type"] = 'application/octet-stream' #指定类型att1["Content-Disposition"] = 'attachment; filename="123.txt"'#这里的filename可以任意写，写什么名字，邮件中显示什么名字msg.attach(att1) #向其中添加附件img_path='/home/chenjiabing/文档/MeiZi_img/full/file.jpg' #图片路径image=MIMEImage(open(img_path,'rb').read()) #创建一个图片附件image.add_header('Content-ID','&lt;0&gt;') #指定图片的编号,这个会在后面用到image.add_header('Content-Disposition', 'attachment', filename='test.jpg') image.add_header('X-Attachment-Id', '0')msg.attach(image) #添加附件stmp='smtp.163.com'server=smtplib.SMTP(stmp,port=25,timeout=30) #连接，设置超时时间30sserver.login(from_addr,from_password) #登录server.set_debuglevel(1) #输出所有的信息server.sendmail(from_addr,to_email,msg.as_string()) #这里的as_string()是将msg转换成字符串类型的,如果你想要发给多个人，需要讲to_email换成一个列表 将图片嵌入到正文信息中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from email.mime.multipart import MIMEMultipartfrom email.mime.text import MIMETextimport smtplibfrom email.mime.image import MIMEImagefrom email.mime.multipart import MIMEMultipartfrom email.mime.text import MIMETextfrom email.header import Headerdef _format_addr(s): name, addr = parseaddr(s) return formataddr(( Header(name, 'utf-8').encode(), addr.encode('utf-8') if isinstance(addr, unicode) else addr))from_addr='××××××××' #你的邮箱地址from_password='×××××××' #你的密码# to_email='chenjiabing666@yeah.net'to_email='××××××' #要发送的邮箱地址msg=MIMEMultipart() #创建实例html="""&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;下面演示嵌入图片&lt;/p&gt;&lt;section&gt;&lt;img src='cid:0' style='float:left'/&gt;&lt;img src='cid:1' style='float:left'/&gt;&lt;/setcion&gt;&lt;/body&gt;&lt;/html&gt;"""text=MIMEText('&lt;h2 style="color:red"&gt;陈加兵&lt;/h2&gt;&lt;br/&gt;&lt;p&gt;大家好&lt;/p&gt;','html','utf-8')msg.attach(text) #添加一个正文信息，这里实在正文中显示的信息#创建一个文本附件，这里是从指定文本中读取信息，然后创建一个文本信息att1=MIMEText(open('/home/chenjiabing/文档/MeiZi_img/full/file.txt','rb').read(),'plain','utf-8')att1["Content-Type"] = 'application/octet-stream' #指定类型att1["Content-Disposition"] = 'attachment; filename="123.txt"'#这里的filename可以任意写，写什么名字，邮件中显示什么名字msg.attach(att1) #向其中添加附件## 创建一个图片附件img_path='/home/chenjiabing/文档/MeiZi_img/full/file.jpg' #图片路径image=MIMEImage(open(img_path,'rb').read()) #创建一个图片附件image.add_header('Content-ID','&lt;0&gt;') #指定图片的编号,image.add_header('Content-Disposition', 'attachment', filename='test.jpg') image.add_header('X-Attachment-Id', '0')msg.attach(image) #添加附件#创建第二个图片附件img_path_1='/home/chenjiabing/文档/MeiZi_img/full/test.jpg' #图片路径image1=MIMEImage(open(img_path,'rb').read()) #创建一个图片附件image1.add_header('Content-ID','&lt;1&gt;') #指定图片的编号,这个就是在上面对应的cid:1的那张图片，因此这里的编号一定要对应image1.add_header('Content-Disposition', 'attachment', filename='img.jpg') image1.add_header('X-Attachment-Id', '0')msg1.attach(image) #添加附件stmp='smtp.163.com'server=smtplib.SMTP(stmp,port=25,timeout=30) #连接，设置超时时间30sserver.login(from_addr,from_password) #登录server.set_debuglevel(1) #输出所有的信息server.sendmail(from_addr,to_email,msg.as_string()) #这里的as_string()是将msg转换成字符串类型的,如果你想要发给多个人，需要讲to_email换成一个列表]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python制作电子书]]></title>
      <url>%2F2017%2F05%2F13%2Fpython%E5%88%B6%E4%BD%9C%E7%94%B5%E5%AD%90%E4%B9%A6%2F</url>
      <content type="text"><![CDATA[python制作pdf电子书准备 制作电子书使用的是python的pdfkit这个库，pdfkit是 wkhtmltopdf 的Python封装包，因此在安装这个之前要安装wkhtmltopdf 安装wkhtmltopdf sudo apt-get install wkhtmltopdf (ubantu下，不过这里安装的时候可能对应的版本不同，会出现错误，如果不行的话还请自己百度下，我安装的时候是可以的) windows下的用户直接到wkhtmltopdf官网下载稳定版本，然后直接安装即可，但是安装之后需要注意的是一定要将其添加到环境变量中，否则会出现找不到路径的问题 python安装依赖包 以下都是我们需要用到的库 pip install requests pip install BeautifulSoup4 pip install pdfkit pdfkit的用法初级了解函数 pdfkit.from_url([url,],&#39;demo.pdf&#39;) 这个是直接传入一个url或者一个url列表，然后通过这个函数直接将其网页转换成demo.pdf,注意这里只能转换静态文本，如果使用js一些脚本的话是不能直接转换的 pdfkit.from_string(&quot;&lt;h1&gt;&lt;a href=&quot;https://chenjiabing666.gituhb.io&quot;&gt;陈加兵的博客&lt;/a&gt;&lt;/h1&gt;&quot;,&#39;demo.pdf&#39;) 这个是直接讲一个字符串转换成pdf格式的电子书，里面可以直接传一个字符串，也可以用html标签包裹这个字符串 pdfkit.from_file([file_name,],&#39;demo.pdf&#39;) 这个是直接传入一个文件或者一个列表即是多个文件，不过这里传入的文件一般都是html格式的文件 进阶 当然知道这个是多么枯燥，生成的电子书书也不能添加各种的样式，下面我们将会介绍一些添加的样式的方法 options 这个参数是上面函数的可选参数，其中制定了一些选项，详情请见http://wkhtmltopdf.org/usage/wkhtmltopdf.txt, 你可以移除选项名字前面的 ‘–’ .如果选项没有值, 使用None, Falseor ,* 作为字典值，例子如下： 12345678910111213141516options = &#123; 'page-size': 'Letter', 'margin-top': '0.75in', 'margin-right': '0.75in', 'margin-bottom': '0.75in', 'margin-left': '0.75in', 'encoding': "UTF-8", 'custom-header': [ ('Accept-Encoding', 'gzip') ], 'cookie': [ ('cookie-name1', 'cookie-value1'), ('cookie-name2', 'cookie-value2'), ], 'outline-depth': 10, &#125; cover 这个参数是用来制作封面的，也是函数中的一个参数，如果想要实现的话可以先写一个html文本，在其中嵌入几张图片或者文字作为封面，然后写入出传入函数即可 123456789101112131415161718options = &#123; 'page-size': 'Letter', 'margin-top': '0.75in', 'margin-right': '0.75in', 'margin-bottom': '0.75in', 'margin-left': '0.75in', 'encoding': "UTF-8", 'custom-header': [ ('Accept-Encoding', 'gzip') ], 'cookie': [ ('cookie-name1', 'cookie-value1'), ('cookie-name2', 'cookie-value2'), ], 'outline-depth': 10, &#125;cover='demo.html'pdfkit.from_file('demo.html','demo.pdf',cover=cover,options=options) css 这里的css也是函数中的一个可选参数，这个参数主要的作用作用就是在其中定义自己喜欢的样式，当然这里也可以传入一个列表，定义多个样式css文件，当然没有这个参数也可以实现定义自己的样式，只需要在自己的html模板中定义内嵌的样式，或者直接用&lt;link&gt;引用外面的样式即可，本人亲试是可以的，具体的使用如下 12css='demo.css'pdfkit.from_file('demo.html','demo.pdf',options=options,cover=cover,css=css) 注意 这里生成pdf的时候可能出现中文的乱码，请一定在html模板开头指定字体utf-8-&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; 可能在爬取生成的时候会出现ascii错误，只需要在py文件开头写下： 1234import sysimport threadingreload(sys)sys.setdefaultencoding('utf8') 写入文件的时候不想python3一样可以指定编码格式，这里我使用的是codecs库，可以向python3一样指定其中的编码格式 实战 本人爬了廖雪峰老师的python2.7的教程，并且做成了电子书，截图如下 注意 这里并没有使用框架，如果有兴趣的朋友可以用框架写一个爬取全站的 这里的主要用到的是BeautifulSoup和requests,详情可以看我的博客中的BeautifulSoup用法,后续还会更新requests的用法 源代码请见https://github.com/chenjiabing666/liaoxuefeng_pdfkit 参考文章 http://mp.weixin.qq.com/s/LH8nEFfVH4_tvYWo46CF5Q http://www.cnblogs.com/taceywong/p/5643978.html http://beautifulsoup.readthedocs.io/zh_CN/latest/#id44]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[回溯算法]]></title>
      <url>%2F2017%2F05%2F10%2F%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[回溯算法主要思想 回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。八皇后问题就是回溯算法的典型，第一步按照顺序放一个皇后，然后第二步符合要求放第2个皇后，如果没有位置符合要求，那么就要改变第一个皇后的位置，重新放第2个皇后的位置，直到找到符合条件的位置就可以了。回溯在迷宫搜索中使用很常见，就是这条路走不通，然后返回前一个路口，继续下一条路。回溯算法说白了就是穷举法。不过回溯算法使用剪枝函数，剪去一些不可能到达 最终状态（即答案状态）的节点，从而减少状态空间树节点的生成。回溯法是一个既带有系统性又带有跳跃性的的搜索算法。它在包含问题的所有解的解空间树中，按照深度优先的策略，从根结点出发搜索解空间树。算法搜索至解空间树的任一结点时，总是先判断该结点是否肯定不包含问题的解。如果肯定不包含，则跳过对以该结点为根的子树的系统搜索，逐层向其祖先结点回溯。否则，进入该子树，继续按深度优先的策略进行搜索。回溯法在用来求问题的所有解时，要回溯到根，且根结点的所有子树都已被搜索遍才结束。而回溯法在用来求问题的任一解时，只要搜索到问题的一个解就可以结束。这种以深度优先的方式系统地搜索问题的解的算法称为回溯法，它适用于解一些组合数较大的问题。回溯算法也叫试探法，它是一种系统地搜索问题的解的方法。回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。用回溯算法解决问题的一般步骤为： 定义一个解空间，它包含问题的解。 利用适于搜索的方法组织解空间。 利用深度优先法搜索解空间。 利用限界函数避免移动到不可能产生解的子空间。 解决迷宫问题解决思想 将迷宫问题对应为二维数组，数组中只有两种值0和1，其中0，1分别表示通路和墙。不过在解决这个问题的时候一般要在最外面添加一个围墙，这里设置每个围墙都为1，这样有利于防止当走到了迷宫的出口处还会向前走，这个并不一定，只是最一般的方法，也是最有利于理解的方法。这里的利用到了回溯法，需要走到了一个位置，然后向四处试探，如果有一个方向可以走了就将当前的点压入栈，并且标记当前点以便于区分是否走过，如果四处都无出路，只需要回到前一个走到的点，然后从前一个点再换一个方向重新走 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146import java.util.Stack;/** * Created by chenjiabing on 17-5-5. */class position &#123; public int row; public int col; public position(int row, int col) &#123; this.col = col; this.row = row; &#125; public position() &#123; row = 0; col = 0; &#125; public String toString() &#123; return "(" + (row - 1) + " ," + (col - 1) + ")"; &#125; //这里由于四周围上了墙，所以这里的输出就要在原来的基础上减一&#125;class Main &#123; private int[][] maze = null; private Stack&lt;position&gt; stack = null; //创建一个栈用于存储状态 private int row; //行数 private int col; boolean[][] p = null; //这里的p是用来标记已经走过的点，初始化为false public boolean end(int i, int j) &#123; return i == row &amp;&amp; j == col; &#125; public Main(int[][] maze) &#123; stack = new Stack&lt;position&gt;(); row = maze[0].length;// 行数 col = maze.length; //列数 p = new boolean[row + 2][col + 2]; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; p[i][j] = false; //初始化 &#125; &#125; this.maze = maze; &#125; public void findPath() &#123; //创建一个新的迷宫，将两边都围上墙，也就是在四周都填上1的墙，形成新的迷宫，主要的目的就是防止走到迷宫的边界的出口的位置还会继续向前走 //因此需要正确的判断是否在边界线上，所以要在外围加上一堵墙, int[][] temp = new int[row + 2][col + 2]; for (int i = 0; i &lt; row + 2; i++) &#123; for (int j = 0; j &lt; col + 2; j++) &#123; temp[0][j] = 1; //第一行围上 temp[row + 1][j] = 1; //最后一行围上 temp[i][0] = temp[i][col + 1] = 1; //两边的围上 &#125; &#125; // 将原始迷宫复制到新的迷宫中 for (int i = 0; i &lt; row; ++i) &#123; for (int j = 0; j &lt; col; ++j) &#123; temp[i + 1][j + 1] = maze[i][j]; &#125; &#125; int i = 1; int j = 1; p[i][j] = true; stack.push(new position(i, j)); //这里是是将走到的点入栈，然后如果前后左右都走不通的话才出栈 while (!stack.empty() &amp;&amp; !end(i, j)) &#123; //下面就开始在四周试探，如果有路就向前走，顺序分别是右，下，上，左，当然这是随便定义的，不过一般都是现向下和右的 if (temp[i][j + 1] == 0 &amp;&amp; p[i][j + 1] == false)//这里如果不在四周加上墙，那么在到达边界判断的时候就会出现超出数组的索引的错误，因为到达边界再加一就会溢出 &#123; p[i][j + 1] = true; stack.push(new position(i, j + 1)); j++; &#125; else if (temp[i + 1][j] == 0 &amp;&amp; p[i + 1][j] == false)//如果下面可以走的话，讲当前点压入栈，i++走到下一个点 &#123; p[i + 1][j] = true; stack.push(new position(i + 1, j)); i++; &#125; else if (temp[i][j - 1] == 0 &amp;&amp; p[i][j - 1] == false) &#123; p[i][j - 1] = true; stack.push(new position(i, j - 1)); j--; &#125; else if (temp[i - 1][j] == 0 &amp;&amp; p[i - 1][j] == false) &#123; p[i - 1][j] = true; stack.push(new position(i - 1, j)); i--; &#125; else //前后左右都不能走 &#123; System.out.println(i + "---------" + j); stack.pop(); //这个点不能走通，弹出 if (stack.empty()) //如果此栈中已经没有点了，那么直接跳出循环 &#123; System.out.println("没有路径了，出不去了"); return; //直接退出了，下面就不用找了 &#125; i = stack.peek().row; //获得最新点的坐标 j = stack.peek().col; &#125; //如果已经到达了边界，那么直接可以出去了，不需要继续向前走了，这里是规定边界的任意为0的位置都是出口 //如果不加这个判断的话，那么当到达边界的时候，只有走到不能再走的时候才会输出路线，那种线路相对这个而言是比较长的 if (j == temp[0].length - 2) &#123; //如果已经到达边界了，那么当前的位置就是出口，就不需要再走了 Stack&lt;position&gt; pos = new Stack&lt;position&gt;(); System.out.println("路径如下："); for (int count = 0; count &lt; stack.size(); count++) &#123; System.out.println(stack.elementAt(count)); &#125; &#125; &#125; &#125; public static void main(String args[]) &#123; int[][] maze = &#123; &#123;0, 1, 0, 0, 0&#125;, &#123;0, 1, 0, 1, 0&#125;, &#123;0, 0, 0, 0, 0&#125;, &#123;0, 1, 1, 1, 0&#125;, &#123;0, 0, 0, 1, 0&#125; &#125;; Main main = new Main(maze); main.findPath(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[跳跃链表]]></title>
      <url>%2F2017%2F05%2F09%2F%E8%B7%B3%E8%B7%83%E9%93%BE%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[数据结构之跳跃链表简介 总的来说跳跃链表最大的好处就是提高了检索了的速率，可以说说是大幅度的提高，相对于单链表来说是一种高效率的检索结构 原理 跳跃表的结构是：假如底层有10个节点， 那么底层的上一层理论上就有5个节点，再上一层理论上就有2个或3个节点，再上一层理论上就有1个节点。所以从这里可以看出每一层的节点个数为其下一层的1/2个元素，以此类推。从这里我们可以看到，从插入时我们只要保证上一层的元素个数为下一层元素个数的1/2，我们的跳跃表就能成为理想的跳跃表。那么怎么才能保证我们插入时上层元素个数是下层元素个数的1/2呢，？很简单 抛硬币就可以解决了，假设元素X要插入跳跃表，最底层是肯定要插入X的，那么次低层要不要插入呢，我们希望上层元素个数是下层的1/2，那么我们有1/2的概率要插入到次低层，这样就来抛硬币吧，正面就插入，反面就不插入，次次底层相对于次低层，我们还是有1/2的概率插入，那么就继续抛硬币吧 ， 以此类推元，素X插入第n层的概率是(1/2)的n次。这样，我们能在跳跃表中插入一个元素了。基本的样子如下图： 代码实现(java语言)节点定义123456789101112131415package skip;public class Node&#123; public Integer value; //插入的数据 public Node left; //分别对应的四个方向的指针 public Node down; public Node right; public Node up; public Node(Integer value) //构造函数 &#123; this.value=value; down=up=right=left=null; &#125;&#125; 表的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199package skip;import java.util.Random;public class SkipList &#123; private Node head; //最上面一侧的头结点，这里使用的是双链表 private Node tail; //最上面一层的尾节点，这里的头尾节点是不存储数据的，数据域全是null private int level; //表中的最高的层数，就是总共的层数 private int size; //插入节点的个数，头尾节点除外 private Random random; //用来判断是否需要增加高度的随机函数 public SkipList() &#123; level = 0; //level默认是0层，就是只有最下面的一层 head = new Node(null); tail = new Node(null); head.right = tail; //这里初始化成一个只有一层的双链表 tail.left = head; size = 0; //size初始化为0 random = new Random(); &#125; //这个函数的作用是找到插入节点的前面一个节点，这里默认的是将表升序存储 public Node findFirst(Integer value) &#123; Node p = head; while (true) &#123; //判断要插入的位置，当没有查到尾节点并且要插入的数据还是比前面的大的话，就将节点右移，知道找到合适的位置 //这里需要注意的是这里的head代表不一定是最底层的，因此这里的查找都是从最高层进行查找的，如果满足条件就要向下移动 //直到最底层 while (p.right.value != null &amp;&amp; p.right.value &lt;= value) &#123; p = p.right; &#125; //向下移动，直到到达最后一层 if (p.down != null) &#123; p = p.down; &#125; else &#123; //到达最底层跳出即可 break; &#125; &#125; return p; //此时这里的p就是要插入节点的前面一个节点 &#125; //这是插入函数，这里先执行插入，然后判断是否需要增加高度 public void insert(int value) &#123; Node curr = findFirst(value); //先找到插入位置的前面一个节点 Node q = new Node(value); //新建一个插入的节点 //下面执行插入步骤，这个和双链表是一样的步骤 q.right = curr.right; q.left = curr; curr.right.left = q; curr.right = q; int i = 0; //表示当前节点所在的层数，开始插入的是在下面插入的，所以开始的时候是在0层 //这里判断是否需要增加高度，每一层相对域下面来说都有二分之一的概率，也就是说每一层增加的概率是（1/2）^n //通俗的说就是每一层的节点是将会保证是下面一层的1/2 while (random.nextDouble() &lt; 0.5) &#123; if (i &gt;= level) &#123; //如果当前插入的节点所处的层数大于等于最大的层数，那么就需要增加高度了，因为这里要保证头尾节点的高度是最高的 //下面的代码就是在头尾节点的上插入新的节点，以此来增加高度 Node p1 = new Node(null); Node p2 = new Node(null); p1.right = p2; p1.down = head; p2.left = p1; p2.down = tail; head.up = p1; //将头尾节点上移，成为最顶层的节点，这就是为什么每次插入和查询的时候都是最上面开始查询的，因为这里的head默认的就是从最上面开始的 tail.up = p2; head = p1; tail = p2; level++; //最高层数加一 &#125; while (curr.up == null) &#123; //当然增加高度就是在插入节点上面新插入一个节点，然后将之与插入的节点相连 //既然这里新插入节点增高了，那么就需要找到与新插入节点上面的那个节点相连接，这里我们将新插入节点的前面的同等高度的节点与之相连 curr = curr.left; &#125; curr = curr.up; //通过前面的一个节点找到与之相连的节点 //下面就是创建一个节点插入到插入节点的头上以此来增加高度，并且这个节点与前面一样高的节点相连 Node e = new Node(value); e.left = curr; e.right = curr.right; curr.right.left = e; //此时的curr就是与之同等高度的节点 curr.right = e; e.down = q; q.up = e; q = e; //将新插入的节点上移到最上面，因为后面可能还要在这里增加高度，就是在最上面插入新的一模一样的节点 i++; //增加当前所处的高度，这里一定能要记得写上，如果还要继续增加的话，需要判读是否需要增加头尾节的高度 &#125; size++; //节点加一 &#125; //下面是打印每一层节点的情况 public void display() &#123; while (level &gt;= 0) &#123; Node p = head; while (p != null) &#123; System.out.print(p.value + "--------&gt;"); p = p.right; &#125; System.out.println(); System.out.println("*****************************"); level--; head = head.down; &#125; &#125; /*在链表中查找某个值是否存在，如果存在找到的节点，当然先从最高层开始查找，如果找到了在比这个值小的最后一个值，那么就顺着这个值的下面开始寻找，按照上面的步骤 再次寻找，如过这个值正好等于要找的值，就返回true，形象的来说就是形成一个梯度的感觉。注意这里返回的节点一定是最底层的节点，利于下面的删除操作 * */ public Node search(int value) &#123; Node p = head; while (true) &#123; /*这里一定要写成p.right.value!=null,如果写成p.right!=null运行可能有错误， 因为这里的尾节点的值为null，但是它的节点不是空的，如果成这样的话,那么节点可能会找到尾节点都没有找到，此时在判断value的值就出现错误 相当与判断tail.right.value&lt;=value,这个肯定是不行的，因为这个节点不存在，是空的更别说值了 */ //从最高层开始判断找到比这个小的最后一个值，就是找到一个节点的前面比value小的，后面的节点的值比value大的 while (p.right.value != null &amp;&amp; p.right.value &lt;= value) &#123; p = p.right; //如果没有找到就后移直到找到这个节点 &#125; //如果找到的这个节点不是最底层的话，就向下移动一层，然后循环再次寻找，总之就是从最高层开始，一层一层的寻找 if (p.down != null) &#123; //这个表示上面的循环没有找到的相等的，那么就向下移动一层 p = p.down; &#125; else &#123; //如果到了最底层了，这里的值仍然没有找到这个值，那么就表示不存在这个值 if (p.value == value) &#123; //判断是否存在value相等的值// System.out.println(p.value + "-----&gt;"); return p; //返回节点 &#125; return null; //仍然没有找到返回null &#125; &#125; &#125; /* 这里是利用上面的查找函数，找到当前需要删除的节点，当然这个节点是最底层的节点，然后循环从最底层开始删除所有的节点 * */ public void delete(int value) &#123; Node temp = search(value); //这里返回的必须是最底层的节点，因为要从最下面的往上面全部删除所有层的节点，否则的话可能在某一层上仍然存在这个节点 while (temp != null) &#123; temp.left.right = temp.right; temp.right.left = temp.left; temp = temp.up; //节点上移，继续删除上一层的节点 &#125; &#125; public static void main(String args[]) &#123; SkipList skipList = new SkipList(); Random random = new Random(); skipList.insert(33); skipList.insert(44); skipList.insert(11); skipList.insert(10); skipList.insert(22); skipList.insert(22); for (int i = 0; i &lt; 500; i++) &#123; int value = (int) (random.nextDouble() * 1000); skipList.insert(value);// System.out.println(value); &#125; Node p = skipList.search(22); if (p != null) &#123; System.out.println(p.value); &#125; else System.out.println("没有找到"); skipList.delete(33); skipList.display(); &#125;&#125; 源码地址 跳跃链表 双链表 单链表 参考文章 java实现跳跃链表]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git常用命令]]></title>
      <url>%2F2017%2F05%2F07%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[git常用操作第一次连接远程仓库的配置配置user.name 和user.email git config --global user.name &quot;name&quot; 设置你的用户名 git config --global user.email &quot;emil&quot; 设置用户的email账号 生成密钥 ssh-keygen -t rsa -C &quot;your email&quot; 其中填的是你的注册的github的账号，输入之后如果不需要输入密码的话，连续输入三个回车即可，最后在你的在终端输入 cd ~/.ssh 进入到你的文件下可以看到有两个文件id_rsa和id_rsa.pub,最后复制你的id_rsa.pub中的内容到github中的账号中即可 ssh -T git@github.com 如果上面的步骤已经完成了，那么就是验证是否完成了，输入上述语句，如果出现信息，那么证明说明你已经成功了 管理修改 通常我们在提交之后会想要修改，当然我们是在文件上直接修改，但是修改后在git上输入git status查看此时的工作区的状态，你会发现出现了出现了如下的语句： 12345678910On branch masterYour branch is ahead of &apos;origin/master&apos; by 2 commits. (use &quot;git push&quot; to publish your local commits)Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: file.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 从上面的提示可以看出我们有如下方案： 首先执行-&gt;git add file.txt,然后重新提交git commit -m &#39;modified file.txt 撤销修改(没有提交的[commit]) 这里的撤销修改仅仅是对于没有提交的撤销(git commit -m &#39;&#39;),在下面会讲到如何撤销提交后的撤销 未git add 当我们修改后会出现上面的提示，前面已经贴过了，这里就不再贴代码了，根据提示，我们可以git checkout -- file.txt来丢弃工作区的修改，之后就可以看见先前的修改已经不见了 已经git add 当我们修改文件后并且git add 添加到暂存区了，那么查看状态git status,出现的提示如下 1234567On branch masterYour branch is ahead of &apos;origin/master&apos; by 2 commits. (use &quot;git push&quot; to publish your local commits)Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: file.txt 根据上面提示的方法：输入git reset HEAD file.txt,可以看到文件回到未git add的状态了，这时如果你想要丢弃修改，使用git checkout -- file.txt,之后就可以看到你的修改已经不见了 删除文件 其实删除也是一种修改操作，我们在文件管理器中直接使用rm删除文件，这时输入git status可以看到如下的提示： 1234567891011On branch masterYour branch is ahead of &apos;origin/master&apos; by 2 commits. (use &quot;git push&quot; to publish your local commits)Changes not staged for commit: (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) deleted: file.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)PS G:\file&gt; git checkout -- file.txt 如果你不想删除了，想要恢复原来的文件，使用git checkout -- file.txt 这个命令可以让撤销修改，也可以撤销删除，起到一键还原的作用 如果你想要继续删除,那么有两种方法： first:git add file.txt,second:git commit -m &#39;&#39; first:git rm file.txt,second:git commit -m &#39;&#39; 注意： git rm file 可以用来删除提交到版本库中的文件，一般删除要执行以下命令：git rm file.txt,git commit -m &#39;delete&#39;，注意在git commit之前还是可以取消删除的，使用git checkout -- file.txt，可以一键取消删除 创建与合并分支常用命令： git checkout -b dev 创建并且切换到dev分支 git checkout dev 切换到dev分支 git branch 查看所有的分支，带有*的是当前所处的分支 git branch -d dev 删除dev分支，一般在合并之后删除 git branch -D dev ：强制删除分支，一般在没有合并就删除分支会出现不能删除，这是就要使用强制删除这个分支的命令 git merge dev 将dev分支合并到当前分支,使用到Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。 git merge --no-ff -m &quot;merge with no-ff&quot; dev 强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 git log --graph --pretty=oneline --abbrev-commit 查看分支历史 创建合并 首先我们创建一个dev分支,使用命令：git checkout -b dev(创建一个dev分支，并且切换到dev分支上)，我们可以使用git branch查看所有的分支 现在在改变之前master分支上的file.txt文件内容，之后git add file.txt,并且提交到版本库中了(git commit -m &#39;file.txt&#39;)，此时使用git checkout master切换到master分支上，查看file.txt的文件内容，可以看到里面的内容并没有改变，由此可知两个分支是独立的，如果你在一个分之上创建了文件并且提交到版本库中了，切换到另外一个分支上，此时可以发现原来创建的文件不见了，因为那是另外一个分支的文件，当然我们可以合并分支，使用git merge dev,这两个命令将dev分支合并到当前分支 Bug分支管理 如果正在一个分支上工作，另外一个分支上的程序有一个Bug需要马上修改，但是此时这个分支上的东西还需要很长时间才能完成，这应该怎么办呢？难道要放弃当前分支上的修改吗？当然不是了，幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作，具体步骤如下： git stash 将当前的工作状态暂时存储在stash中，输出如下信息 12Saved working directory and index state WIP on dev: 6224937 add mergeHEAD is now at 6224937 add merge 此时可以使用git status 查看当前的分支上的状态，可以知道当前的的工作区就是干净的，因此可以放心的修复另外一个分支上的的Bug了 git checkout master 切换分支，修复Bug git checkout dev 修复好Bug继续回到上一个分支干活 git stash list 可以看到工作现场还在，输出如下信息： 1stash@&#123;0&#125;: WIP on dev: 6224937 add merge 如果有多个修改的内容，这里的信息肯定不止一条 git stash apply：恢复修改，但是这只是恢复stash的内容并不会删除，这里建议使用git stash pop 既恢复了又删除了stash中内容，注意这里只能恢复一条数据，此时使用git status查看状态，可以看到已经出现修改的内容了 git stash list ：此时查看当前stash中的内容可以看到已经什么都没了，当然这只是清除一条，如果本来有多个，那么还是会有其他内容的 常用命令 git stash 将当前的分支上的工作暂存到stash中 git stash list 列出stash中的所有暂存的内容 git stash pop 恢复并且删除stash中的内容 git stash apply 恢复但是步删除stash中的内容 远程仓库的操作常用的命令 git remote -v 查看远程仓库的详细信息 git remote add remote-name URL 添加远程仓库 git remote rename origin pb 将远程仓库的origin改为pb，此时使用git remote 查看可以知道这里已经没有origin了，变成了pb git remote rm origin 将远程仓库origin删除 git push origin master 将内容提交到远程仓库origin的master上，当然这里亦可以使用其他的分支 git clone URL 克隆一个远程仓库，这里的URL是远程仓库的地址 git pull origin 将远程仓库中更新的数据拉到本地 git checkout -b branch-name origin/branch-name 在本地创建和远程仓库对应的分支，最好分支的名字相同 git push origin branch-name 推送到远程仓库的分支 注意 同一个文件夹中可以添加很多远程仓库，不过可以在提交的时候需要指定远程仓库的名字，比如在你的文件夹下有origin和pb两个远程仓库，可以使用git remote -v查看详细的信息，此时你在版本库中已经有想要推送的文件了，那么使用git push origin master就可以指定推送到origin远程仓库中 实例 假如你新建一个文件夹，此时要在里面添加远程仓库，具体实现如下： git clone URL 将一个仓库克隆来的同时也具有推送的权限了，这时就可以使用git remote add origin URL来添加远程仓库了 如果没有使用clone的方法创建一个版本库，那么先git init 然后git remote add origin URL 添加远程仓库，之后就是将本地仓库和远程仓库对应了，使用git pull origin master 来拉取远程仓库中内容，当然这也可以分两步，使用如下： git fetch origin master 这是将远程仓库中的文件拉取到本地，但是没有与本地的master合并，因此本地的master分支不能追踪远程仓库中的分支 git merge origin/master 将远程仓库和本地的master分支合并，那么就可以使用本地的master分支追踪远程仓库了，这就完成了 无论clone还是pull都只是拉取远程的master分支，但是一般远程仓库中还有其他的分支，那么怎么办呢？拉取远程仓库的次分支步骤如下： git checkout -b dev origin/dev 拉去远程仓库中的dev仓库到本地的dev分支]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[scrapy爬取淘宝女郎]]></title>
      <url>%2F2017%2F05%2F07%2Fscrapy%E7%88%AC%E5%8F%96%E6%B7%98%E5%AE%9D%E5%A5%B3%E9%83%8E%2F</url>
      <content type="text"><![CDATA[scrapy抓取淘宝女郎准备工作 首先在淘宝女郎的首页这里查看，当然想要爬取更多的话，当然这里要查看翻页的url,不过这操蛋的地方就是这里的翻页是使用javascript加载的，这个就有点尴尬了，找了好久没有找到，这里如果有朋友知道怎样翻页的话，麻烦告诉我一声，谢谢了…，不过就这样坐以待毙了吗，所以就在chrome上搜，结果看到有人直接使用的这个网页,我当时一看感觉神奇的样子，这就是简化版的首页啊，只需要改变page的数字就可以实现遍历了，不过还是有点小失落，为什么人家就能找到呢，这个我还是希望知道的朋友能够分享一下，我也会查看相关的资料，把这个空缺不上的，好了，现在开我们的工作了 我们的目的是抓取册以及相关的信息，所以我们需要随便打开一个淘女郎的相册页面，然后随便进入一个相册即可，很显然这里的相册是异步加载的，因此我们需要抓包，这里我抓到了含有相册的url以及相关信息的json数据，如下图： 然后我们查看它的url为https://mm.taobao.com/album/json/get_album_photo_list.htmuser_id=687471686&amp;album_id=10000702574&amp;top_pic_id=0&amp;cover=%2F%2Fimg.alicdn.com%2Fimgextra%2Fi2%2F687471686%2FTB1TlwDLFXXXXbxaXXXXXXXXXXX_!!2tstar.png&amp;page=1&amp;_ksTS=1494097545509_154&amp;callback=jsonp15 通过我尝试之后这条url可以简化为: https://mm.taobao.com/album/json/get_album_photo_list.htm?user_id={0}&amp;album_id={1}&amp;top_pic_id=0&amp;page={2}&amp;_ksTS=1493654931946_405 其中user_id是每一个女郎对的id,ablum_id时每一个相册的id,这里一个女郎有多个相册，因此这个id是不同的，但是page就是要翻页的作用了,可以看到我去掉了callback=json155这一项，因为如果加上这一项，返回的数据就不是json类型的数据，其中page是在抓包的时候点击翻页才会在下面出现的，可以看到同一个相册返回的除了page不同之外，其他的都是相同的，因此这里通过page来实现翻页的数据 上面分析了每一个相册的url数据的由来，可以看到我们下面需要找到user_id,ablum_id这两个数据. user_id的获取：我们打开首页,然后打开chrome的调试工具，可以看到每一个 女郎的url中都包含user_id这一项，因此我们只需要通过这个实现翻页然后获取每一个女郎的url,之后用正则将user_id匹配出来即可,代码如下 123456ps=response.xpath('//p[@class="top"]') for p in ps: item=JrtItem() href=p.xpath('a/@href').extract() #这个得到的是一个数组url if href: item['user_id']=self.pattern_user_id.findall(href[0])[0] #用则正匹配出user_id,其中的正则为 pattern_user_id=re.compile(r'user_id=(\d+)') ablum_id的获取：想要获取ablum_id当然要在相册的页面查找，于是我们在相册页面抓包获得了如下图的页面 通过上图我们清晰的知道每一个相册的里面包含多少相册，但最令人开心的是在这个页面中不是动态加载，因此我们可以查看它的源码，当我们查看源码的时候，我们可以看到和user_id一样，这里的ablum_id包含在了href中，因此我们只需要找到每一张相册的url，然后用正则匹配处来即可，其中这个页面的url简化为: https://mm.taobao.com/self/album/open_album_list.htm?_charset=utf-8&amp;user_id%20={0}&amp;page={1} 所以我们可以通过上面得到的user_id构成请求即可,代码如下： 12345678910## 解析得到ablum_id，根据ablum_id解析请求出每一个相册的json数据 def parse_ablum_id(self,response): if response.status==200: print response.url item = response.meta['item'] soup = BeautifulSoup(response.text, 'lxml') divs = soup.find_all('div', class_='mm-photo-cell-middle') for div in divs: href = div.find('h4').find('a').get('href') items = self.pattern_ablum_id.findall(href) #这里就得到了ablum_id 上面已经获得了user_id和ablum_id，那么现在就可以请求每一个相册的json数据了，这个就不用多说了，详情请看源代码 MongoDB存储安装方式 Windows下安装请看我的MogoDB干货篇 ubantu直接用sudo apt-get install安装即可 安装对应python的包：pip install pymongo 安装完成以后就可以连接了，下面贴出我的连接代码 1234567891011121314from pymongo import MongoClientclass MongoDBPipelines(object): collection_name = 'taobao' def open_spider(self,spider): self.client = MongoClient('localhost', 27017) #连接，这里的27017是默认的额端口号 self.db = self.client['python'] #python是自己的数据库，当然这里不用提前建好也可以 def close_spider(self, spider): self.client.close() def process_item(self,item,spider): self.db[self.collection_name].update(&#123;'picId':item['picId']&#125;, &#123;'$set': dict(item)&#125;, True) return item 现在这就算好了，当然这里还有很多东西需要优化的，像代理池。。。最后本人想在暑期找一个地方实习，但是一直没有好的地方，希望有实习的地方推荐的可以联系我，在这里先谢谢了 推荐 最后推荐博主的一些源码 scrapy爬取妹子网站实现图片的存储，这个只是一个演示怎样存储图片的实例，因此不想过多的投入时间去爬，因此写的不是很详细 scrapy爬取知乎用户的详细信息]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MongoDB干货篇之更新数据]]></title>
      <url>%2F2017%2F05%2F01%2FMongoDB%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B9%8B%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%2F</url>
      <content type="text"><![CDATA[MongoDB干货篇之数据更新常用的函数 update(&lt;query&gt;,&lt;update&gt;,&lt;upsert&gt;,&lt;multi&gt;),其中&lt;query&gt;表示筛选的条件，&lt;update&gt;是要更新的数据 updateMany() 更新所有匹配到的数据 upsert upsert是一个布尔类型的数据，如果为true时，当根据query条件没有找到匹配的数据时，就表示插入此条数据，如果为false就表示不插入数据 下面将会在一个空的集合中更新数据1234567//就会插入此条数据，因为没有找到匹配的信息db.user.update(&#123;'name':'chenjiabing','age':22,'sex':"Man"&#125;,&#123;$set:&#123;'hobby':'read'&#125;&#125;,&#123;'upsert':true&#125;); db.user.update(&#123;'name':'chenjiabing','age':22,'sex':"Man"&#125;,&#123;$set:&#123;'hobby':'read'&#125;&#125;,true); //和上面的语句等价//输出 db.user.find()&#123; "_id" : ObjectId("59067b70856d5893a687655f"), "age" : 22, "name" : "chenjiabing", "sex" : "Man", "hobby" : "read" &#125; multi 如果这个参数为true,就把按条件查出来多条记录全部更新。默认为false,如果为true的话和updateMany()一样的效果 下面将会更新所有匹配到的数据 1db.user.update(&#123;name:'chenjiabing'&#125;,&#123;$set:&#123;'hobby':'code'&#125;&#125;,&#123;'multi':true&#125;); 字段更新操作符 Field Update Operators$set $set用来指定一个键的值。如果这个键不存在，则创建它。注意这里的更新默认是只更新第一条匹配到的数据，如果第一条匹配的数据已经满足修改后的条件，那么将不会执行下面匹配的信息 下面我们将会添加一条信息在数据库中 1db.user.insert(&#123;"name":'jack',"age":22,"sex":'Man','school':&#123;'name':'jsnu','city':'xuzhou'&#125;&#125;); 运行下面的代码，将该用户的兴趣设置为“读书”并添加至文档中(此时文档中hobby键是不存在，该条文档就会创建它) 1db.user.update(&#123;name:'jack'&#125;,&#123;$set:&#123;'hobby':'read'&#125;&#125;) 下面将会修改用户的年龄 1db.user.update(&#123;'name':'jack'&#125;,&#123;$set:&#123;'age':20&#125;&#125;) 下面用$set修改数据类型，将sex设置为1 1db.user.update(&#123;'name':'jack'&#125;,&#123;$set:&#123;'sex':1&#125;&#125;) 下面用$set修改内嵌文档，必须指定文档的名字和键值 1db.user.update(&#123;name:'jack'&#125;,&#123;$set:&#123;'school.name':'shida','school.city':'beijing'&#125;&#125;) $unset 从文档中移除指定的键 下面将要删除上面插入的hobby键 1db.user.update(&#123;name:'jack'&#125;,&#123;$unset:&#123;'hobby':1&#125;&#125;) //这里的值是任意给的，随便什么值 $inc $inc修改器用来增加已有键的值，或者在键不存在时创建一个键$inc就是专门来增加（和减少）数字的。$inc只能用于整数、长整数或双精度浮点数。要是用在其他类型的数据上就会导致操作失败 例如毎次有人访问该博文，该条博文的浏览数就加1，用键pageViews保存浏览数信息。这个键值上面没有定义过，所以会自动创建一个 1db.user.update(&#123;name:'jack'&#125;,&#123;$inc:&#123;'pageViews':1&#125;&#125;); //起初没有就会自动创建一个键 下面演示增加和减少 123db.user.update(&#123;name:'jack'&#125;,&#123;$inc:&#123;'pageViews':100&#125;&#125;) ; //这里是在上面的基础上加上100，此时变成了101db.user.update(&#123;name:'jack'&#125;,&#123;$inc:&#123;"pageViews":-100&#125;&#125;) ; //这里是在上面的基础上减去100,此时还是变成了1 $rename 语法：{$rename: { &lt;old name1&gt;: &lt;new name1&gt;, &lt;old name2&gt;: &lt;new name2&gt;, ... } } $rename操作符可以重命名字段名称，新的字段名称不能和文档中现有的字段名相同。 下面重新插入一条数据，并且改变这条数据的键的名称 123db.user.insert(&#123;name:'chenjiabing','age':22,'sex':'Man','school':&#123;'name':'jsnu','city':'beijing'&#125;&#125;);db.user.update(&#123;name:'chenjiabing'&#125;,&#123;$rename:&#123;'age':'Age'&#125;&#125;) //重命名age为Age 下面将要演示怎样改变内嵌文档的键的名称，注意一定要带上文档的名字 1db.user.update(&#123;name:'chenjiabing'&#125;,&#123;$rename:&#123;'school.name':'school.Name','school.city':'school.City'&#125;&#125;); 如果重命名的字段字和集合中原有的字段名字相同的话就会覆盖原有的字段名称，那么就会造成数据的丢失 1234567db.user.update(&#123;name:'chenjiabing'&#125;,&#123;'$rename':&#123;'sex','age'&#125;&#125;); //这里sex变成age和原来的age相同，那么原来的age就会丢失db.user.find(&#123;name:'chenjiabing'&#125;); //输出，可以看到原来的age没有了,变成了覆盖之后的&#123; "_id" : ObjectId("590674ce30b9f88dd43d7ee4"), "name" : "chenjiabing", "age" : "Man", "school" : &#123; "name" : "jsnu", "city" : "beijing" &#125; &#125; 如果指定的字段不存在，那么将不会更新，对原来的字段没有影响 1db.user.update(&#123;name:'chenjiabing'&#125;,&#123;$rename:&#123;value:'name'&#125;&#125;); //将不会有任何的改变，因为value这个字段根本不存在 $rename操作符也可以将子文档中键值移到其他子文档中 12345db.user.update(&#123;name:'chenjiabing'&#125;,&#123;$rename:&#123;'school.name':'contact.name'&#125;&#125;);// 这里将会将school.name这个字段的值移到contact.name之中，如果contact不存在，那么就会创建一个//输出&#123; "_id" : ObjectId("590674ce30b9f88dd43d7ee4"), "name" : "chenjiabing", "age" : "Man", "school" : &#123; "city" : "beijing" &#125;, "contact" : &#123; "name" : "jsnu" &#125; &#125; 数组更新操作符 Array Update Operators 只能用在键值为数组的键上的数组操作。 $ (query) 语法:{ &quot;&lt;array&gt;.$&quot; : value } 当对数组字段进行更新时，且没有明确指定的元素在数组中的位置，我们使用定位操作符$标识一个元素，数字都是以0开始的。 注意: 定位操作符(“$”)作为第一个匹配查询条件的元素的占位符，也就是在数组中的索引值。 数组字段必须出现查询文档中。 向集合中插入两条数据 12db.students.insert(&#123; "_id" : 1, "grades" : [ 78, 88, 88 ] &#125;);db.students.insert(&#123; "_id" : 2, "grades" : [ 88, 90, 92 ] &#125;); 执行下列操作 1234//查询匹配的文档中，数组有2个88，只更新第一个匹配的元素，也就是"grades.1"db.students.update( &#123; _id: 1, grades: 88 &#125;, &#123; $set: &#123; "grades.$" : 82 &#125; &#125;) ;//查询文档中没有出现grades字段，查询报错db.students.update( &#123; _id: 2 &#125;, &#123; $set: &#123; "grades.$" : 82 &#125; &#125; ); $push 如果指定的键已经存在，会向已有的数组末尾加入一个元素，要是没有就会创建一个新的数组。 下面我们将使用$push对该文档添加一条评论信息。 1234567//将会创建一个comments数组，因为一开始这个数组没有存在db.user.update(&#123;name:'chenjiabing'&#125;,&#123;$push:&#123;comments:&#123;'name':'jack','content':'hello thanks'&#125;&#125;&#125;)//继续添加一条，在comments的末尾进行添加，此时comments变成两条数据了db.user.update(&#123;name:'chenjiabing'&#125;,&#123;$push:&#123;comments:&#123;'name':'john','content':'hello'&#125;&#125;&#125;) $pull 语法：db.collection.update( { field: &lt;query&gt; }, { $pull: { field: &lt;query&gt; } } ); $pull操作符移除指定字段值为数组，且匹配$pull操作符移除指定字段值为数组，且匹配$pull语句声明的查询条件的所有元素。 执行如下操作 123456789101112//插入一条文档db.profiles.insert(&#123; votes: [ 3, 5, 6, 7, 7, 8 ] &#125;);//移除数组中所有元素7db.profiles.update( &#123; votes: 3 &#125;, &#123; $pull: &#123; votes: 7 &#125; &#125; );//移除数组中所有大于6的元素db.profiles.update( &#123; votes: 3 &#125;, &#123; $pull: &#123; votes: &#123; $gt: 6 &#125; &#125; &#125; );//Result&#123; votes: [ 3, 5, 6, 8 ] &#125;&#123; votes: [ 3, 5, 6 ] &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MongoDB干货篇之查询数据]]></title>
      <url>%2F2017%2F04%2F30%2FMongoDB%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B9%8B%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%2F</url>
      <content type="text"><![CDATA[MongoDB干货篇之查询准备工作 在开始之前我们应该先准备数据方便演示，这里我插入的了几条数据，数据如下：12345678910111213141516171819202122232425262728293031323334db.user.insertMany([&#123;name:'jack',age:22,sex:'Man',tags:['python','c++','c'],grades:[22,33,44,55],school:&#123;name:'shida',city:'xuzhou'&#125;&#125;,&#123;name:'jhon',age:33,sex:null,tags:['python','java'],grades:[66,22,44,88],school:&#123;name:'kuangda',city:'xuzhou'&#125;&#125;,&#123;name:'xiaoming',age:33,tags:['python','java'],grades:[66,22,44,88],school:&#123;name:'kuangda',city:'xuzhou'&#125;&#125;]) find() 其中query表示查找的条件，相当于mysql中where子句,projection列出你想要查找的数据，格式为db.collection.find(find(&lt;query filter&gt;, &lt;projection&gt;)) 实例： 下面不带参数的查找，将会查找出所有的结果 12345678910111213141516171819202122232425 db.find().pretty(); //输出结果 &#123; &quot;_id&quot; : ObjectId(&quot;59056f81299fe049404b2899&quot;), &quot;name&quot; : &quot;jack&quot;, &quot;age&quot; : 22, &quot;tags&quot; : [ &quot;python&quot;, &quot;c++&quot;, &quot;c&quot; ], &quot;grades&quot; : [ 22, 33, 44, 55 ], &quot;school&quot; : &#123; &quot;name&quot; : &quot;shida&quot;, &quot;city&quot; : &quot;xuzhou&quot; &#125; &#125; 下面找出满足name为jack的数据，并且只输出name,age,这里的_id是默认输出的，如果不想输出将将它设置为0，想要输出那个字段将它设置为1 12345678910db.user.find(&#123;name:'jack'&#125;,&#123;name:1,age:1&#125;)//输出结果&#123; "_id" : ObjectId("59056f81299fe049404b2899"), "name" : "jack", "age" : 22 &#125;db.user.find(&#123;name:'jack'&#125;,&#123;name:1,age:1，_id:0&#125;)//输出结果&#123;"name" : "jack", "age" : 22 &#125; **注意这里的一个 projection不能 同时 指定包括和排除字段，除了排除 _id字段。 在 显式包括 字段的映射中，_id 字段是唯一一个您可以 显式排除 的。 查询内嵌文档 上述例子中插入的school数据就表示内嵌文档 完全匹配查询 完全匹配查询表示school中的查询数组必须和插入的数组完全一样，顺序都必须一样才能查找出来 1234567891011db.user.find(&#123;name:'jack',school:&#123;name:'shida',city:'xuzhou'&#125;&#125;);//输出结果&#123; "_id" : ObjectId("59056f81299fe049404b2899"), "name" : "jack", "age" : 22, "tags" : [ "python", "c++", "c" ], "grades" : [ 22, 33, 44, 55 ], "school" : &#123; "name" : "shida", "city" : "xuzhou" &#125; &#125;//下面是指定输出的字段，这里的school.name表示只输出school文档中name字段，必须加引号db.user.find(&#123;name:'jack',school:&#123;name:'shida',city:'xuzhou'&#125;&#125;,&#123;name:1,age:1,'school.name':1&#125;);//输出结果&#123; "_id" : ObjectId("59056f81299fe049404b2899"), "name" : "jack", "age" : 22, "school" : &#123; "name" : "shida" &#125; &#125; 键值对查询 可以通过键值对查询，不用考虑顺序，比如&#39;school.name&#39;:&#39;shida&#39;，表示查询学校名字为shida的数据，这里的引号是必须要的 12345db.user.find(&#123;'school.name':'shida'&#125;,&#123;name:1,school:1&#125;);//输出结果&#123; "_id" : ObjectId("59056f81299fe049404b2899"), "name" : "jack", "school" : &#123; "name" : "shida", "city" : "xuzhou" &#125; &#125; 查询操作符 下面我们将配合查询操作符来执行复杂的查询操作，比如元素查询、 逻辑查询 、比较查询操作。我们使用下面的比较操作符&quot;$gt&quot; 、&quot;$gte&quot;、 &quot;$lt&quot;、 &quot;$lte&quot;(分别对应&quot;&gt;&quot;、 &quot;&gt;=&quot; 、&quot;&lt;&quot; 、&quot;&lt;=&quot;) 实例 下面查询年龄在20-30之间的信息 123456db.user.find(&#123;age:&#123;$gt:20,$lt:30&#125; &#125;)//输出&#123; "_id" : ObjectId("59056f81299fe049404b2899"), "name" : "jack", "age" : 22, "tags" : [ "python", "c++", "c" ], "grades" : [ 22, 33, 44, 55 ], "school" : &#123; "name" : "shida", "city" : "xuzhou" &#125; &#125; $ne $ne表示不相等，例如查询年龄不等于22岁的信息 1234db.user.find(&#123;age:&#123;$ne:22&#125;&#125;)//输出&#123; "_id" : ObjectId("59057c16f551d8c9003d31e0"), "name" : "jhon", "age" : 33, "tags" : [ "python", "java" ], "grades" : [ 66, 22, 44, 88 ], "school" : &#123; "name" : "kuangda", "city" : "xuzhou" &#125; &#125; slice $slice操作符控制查询返回的数组中元素的个数。此操作符根据参数{ field: value } 指定键名和键值选择出文档集合，并且该文档集合中指定array键将返回从指定数量的元素。如果count的值大于数组中元素的数量，该查询返回数组中的所有元素的。 语法：db.collection.find( { field: value }, { array: {$slice: count }}); 下面将查询grades中的前两个数 12345db.user.find(&#123;name:'jack'&#125;,&#123;grades:&#123;$slice:2&#125;,name:1,age:1,'school.name':1&#125;);//输出，可以看出这里的grades只输出了前面两个&#123; "_id" : ObjectId("59057c16f551d8c9003d31df"), "name" : "jack", "age" : 22, "grades" : [ 22, 33 ], "school" : &#123; "name" : "shida" &#125; &#125; 下面将输出后3个数据 1234db.user.find(&#123;name:'jhon'&#125;,&#123;grades:&#123;$slice:-3&#125;,name:1&#125;);//输出&#123; "_id" : ObjectId("59057c16f551d8c9003d31e0"), "name" : "jhon", "grades" : [ 22, 44, 88 ] &#125; 下面介绍指定一个数组作为参数。数组参数使用[ skip , limit ] 格式，其中第一个值表示在数组中跳过的项目数,第二个值表示返回的项目数。 123456db.user.find(&#123;name:'jack'&#125;,&#123;grades:&#123;$slice:[2,2]&#125;,name:1&#125;); //这里将会跳过前面的两个，直接得到后面的两个数据//输出&#123; "_id" : ObjectId("59057c16f551d8c9003d31df"), "name" : "jack", "grades" : [ 44, 55 ] &#125; $exists 如果$exists的值为true,选择存在该字段的文档,若值为false则选择不包含该字段的文档 下面将会查询不存在sex这一项的信息 1234567891011db.user.find(&#123;sex:&#123;$exists:false&#125;&#125;)//结果&#123; "_id" : ObjectId("59058460fe58ed1089f2a5cd"), "name" : "xiaoming", "age" : 33, "tags" : [ "python", "java" ], "grades" : [ 66, 22, 44, 88 ], "school" : &#123; "name" : "kuangda", "city" : "xuzhou" &#125; &#125;db.user.find(&#123;sex:&#123;$exists:true&#125;&#125;);//结果&#123; "_id" : ObjectId("59058460fe58ed1089f2a5cb"), "name" : "jack", "age" : 22, "sex" : "Man", "tags" : [ "python", "c++", "c" ], "grades" : [ 22, 33, 44, 55 ], "school" : &#123; "name" : "shida", "city" : "xuzhou" &#125; &#125;&#123; "_id" : ObjectId("59058460fe58ed1089f2a5cc"), "name" : "jhon", "age" : 33, "sex" : null, "tags" : [ "python", "java" ], "grades" : [ 66, 22, 44, 88 ], "school" : &#123; "name" : "kuangda", "city" : "xuzhou" &#125; &#125; $or 执行逻辑OR运算,指定一个至少包含两个表达式的数组，选择出至少满足数组中一条表达式的文档。语法：{ $or: [ { &lt;expression1&gt; }, { &lt;expression2&gt; }, ... , { &lt;expressionN&gt; } ] } 下面将要查找age等于22或者age等于33的值 1234567db.user.find(&#123;$or:[&#123;age:22&#125;,&#123;age:33&#125;]&#125;)//结果&#123; "_id" : ObjectId("59058460fe58ed1089f2a5cb"), "name" : "jack", "age" : 22, "sex" : "Man", "tags" : [ "python", "c++", "c" ], "grades" : [ 22, 33, 44, 55 ], "school" : &#123; "name" : "shida", "city" : "xuzhou" &#125; &#125;&#123; "_id" : ObjectId("59058460fe58ed1089f2a5cc"), "name" : "jhon", "age" : 33, "sex" : null, "tags" : [ "python", "java" ], "grades" : [ 66, 22, 44, 88 ], "school" : &#123; "name" : "kuangda", "city" : "xuzhou" &#125; &#125;&#123; "_id" : ObjectId("59058460fe58ed1089f2a5cd"), "name" : "xiaoming", "age" : 33, "tags" : [ "python", "java" ], "grades" : [ 66, 22, 44, 88 ], "school" : &#123; "name" : "kuangda", "city" : "xuzhou" &#125; &#125; 下面将会查找出年龄为22或者33并且姓名为jack的人的信息 12345db.user.find(&#123;name:'jack',$or:[&#123;age:33&#125;,&#123;age:22&#125;]&#125;)//结果&#123; "_id" : ObjectId("59058460fe58ed1089f2a5cb"), "name" : "jack", "age" : 22, "sex" : "Man", "tags" : [ "python", "c++", "c" ], "grades" : [ 22, 33, 44, 55 ], "school" : &#123; "name" : "shida", "city" : "xuzhou" &#125; &#125; $and 指定一个至少包含两个表达式的数组，选择出满足该数组中所有表达式的文档。$and操作符使用短路操作，若第一个表达式的值为“false”,余下的表达式将不会执行。语法：{ $and: [ { &lt;expression1&gt; }, { &lt;expression2&gt; } , ... , { &lt;expressionN&gt; } ] } 下面将会查找年龄在20-30之间的信息，对于下面使用逗号分隔符的表达式列表，MongoDB会提供一个隐式的$and操作： 12345db.user.find(&#123;$and:[&#123;age:&#123;$gt:20&#125;&#125;,&#123;age:&#123;$lt:30&#125;&#125;]&#125;)//上述语句相当于db.user.find(&#123;age:&#123;$gt:20&#125;,age:&#123;$lt:30&#125;&#125;)//结果&#123; "_id" : ObjectId("59058460fe58ed1089f2a5cb"), "name" : "jack", "age" : 22, "sex" : "Man", "tags" : [ "python", "c++", "c" ], "grades" : [ 22, 33, 44, 55 ], "school" : &#123; "name" : "shida", "city" : "xuzhou" &#125; &#125; $in 匹配键值等于指定数组中任意值的文档。类似sql中in，只要匹配一个value就会输出语法：{ field: { $in: [&lt;value1&gt;, &lt;value2&gt;, ... &lt;valueN&gt; ] } } 下面将会查找grades中存在22,33之间的任意一个数的信息 1234567 db.user.find(&#123;grades:&#123;$in:[22,33]&#125;&#125;) //输出 &#123; "_id" : ObjectId("59058460fe58ed1089f2a5cb"), "name" : "jack", "age" : 22, "sex" : "Man", "tags" : [ "python", "c++", "c" ], "grades" : [ 22, 33, 44, 55 ], "school" : &#123; "name" : "shida", "city" : "xuzhou" &#125; &#125;&#123; "_id" : ObjectId("59058460fe58ed1089f2a5cc"), "name" : "jhon", "age" : 33, "sex" : null, "tags" : [ "python", "java" ], "grades" : [ 66, 22, 44, 88 ], "school" : &#123; "name" : "kuangda", "city" : "xuzhou" &#125; &#125;&#123; "_id" : ObjectId("59058460fe58ed1089f2a5cd"), "name" : "xiaoming", "age" : 33, "tags" : [ "python", "java" ], "grades" : [ 66, 22, 44, 88 ], "school" : &#123; "name" : "kuangda", "city" : "xuzhou" &#125; &#125; $nin 匹配键不存在或者键值不等于指定数组的任意值的文档。类似sql中not in(SQL中字段不存在使用会有语法错误). 查询出grades中不存在100或者44的文档 1db.user.find(&#123;grades:&#123;$nin:[100,44]&#125;&#125;) $not 执行逻辑NOT运算，选择出不能匹配表达式的文档 ，包括没有指定键的文档。$not操作符不能独立使用，必须跟其他操作一起使用 语法:{ field: { $not: { } } } 查询年龄不大于30的信息 1234db.user.find(&#123;age:&#123;$not:&#123;$gt:30&#125;&#125;&#125;)//输出&#123; "_id" : ObjectId("59058460fe58ed1089f2a5cb"), "name" : "jack", "age" : 22, "sex" : "Man", "tags" : [ "python", "c++", "c" ], "grades" : [ 22, 33, 44, 55 ], "school" : &#123; "name" : "shida", "city" : "xuzhou" &#125; &#125; 迭代游标的查询 学过高级语言的朋友都知道迭代的问题，像java,下面使用迭代的方法查询 1234567891011121314151617var cursor=db.usr.find();//这里使用迭代输出所有的数据while(cursor.hasNext()) //这里的hasNext()是判断是否下一个中还有可迭代的值，如果没有返回false&#123; printjson(cursor.next()); //这里的cursor.next是迭代的输出，printjson是代替print(tojson()) &#125;print cursor.count() //输出其中有多少个数据cursor.forEach(printjson); //forEach输出var document=cursor.toArray(); //将迭代对象转换成数组print document[0]; //以数组的形式输出]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python爬虫之BeautifulSoup]]></title>
      <url>%2F2017%2F04%2F29%2Fpython%E7%88%AC%E8%99%AB%E4%B9%8BBeautifulSoup%2F</url>
      <content type="text"><![CDATA[python爬虫之BeautifulSoup简介 Beautiful Soup提供一些简单的、python式的函数用来处理导航、搜索、修改分析树等功能。它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完整的应用程序。Beautiful Soup自动将输入文档转换为Unicode编码，输出文档转换为utf-8编码。你不需要考虑编码方式，除非文档没有指定一个编码方式，这时，Beautiful Soup就不能自动识别编码方式了。然后，你仅仅需要说明一下原始编码方式就可以了。Beautiful Soup已成为和lxml、html6lib一样出色的python解释器，为用户灵活地提供不同的解析策略或强劲的速度。 安装 pip install BeautifulSoup4 easy_install BeautifulSoup4 创建BeautifulSoup对象 首先应该导入BeautifulSoup类库 from bs4 import BeautifulSoup 下面开始创建对像，在开始之前为了方便演示，先创建一个html文本，如下： 1234567891011html = """&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class="title" name="dromouse"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and&lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class="story"&gt;...&lt;/p&gt;""" 创建对象：soup=BeautifulSoup(html,&#39;lxml&#39;),这里的lxml是解析的类库，目前来说个人觉得最好的解析器了，一直在用这个，安装方法：pip install lxml Tag Tag就是html中的一个标签，用BeautifulSoup就能解析出来Tag的具体内容，具体的格式为soup.name,其中name是html下的标签，具体实例如下： print soup.title输出title标签下的内容，包括此标签，这个将会输出&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt; print soup.head 注意： 这里的格式只能获取这些标签的第一个，后面会讲到获取多个标签的方法。其中对于Tag有两个重要的属性name和attrs,分别表示名字和属性,介绍如下： name:对于Tag，它的name就是其本身，如soup.p.name就是p attrs是一个字典类型的，对应的是属性-值，如print soup.p.attrs,输出的就是{&#39;class&#39;: [&#39;title&#39;], &#39;name&#39;: &#39;dromouse&#39;},当然你也可以得到具体的值，如print soup.p.attrs[&#39;class&#39;],输出的就是[title]是一个列表的类型，因为一个属性可能对应多个值,当然你也可以通过get方法得到属性的，如：print soup.p.get(&#39;class&#39;)。还可以直接使用print soup.p[&#39;class&#39;] get get方法用于得到标签下的属性值，注意这是一个重要的方法，在许多场合都能用到，比如你要得到&lt;img src=&quot;#&quot;&gt;标签下的图像url,那么就可以用soup.img.get(&#39;src&#39;),具体解析如下： 1print soup.p.get("class") #得到第一个p标签下的src属性 string 得到标签下的文本内容，只有在此标签下没有子标签，或者只有一个子标签的情况下才能返回其中的内容，否则返回的是None具体实例如下： 123print soup.p.string #在上面的一段文本中p标签没有子标签，因此能够正确返回文本的内容print soup.html.string #这里得到的就是None,因为这里的html中有很多的子标签 get_text() 可以获得一个标签中的所有文本内容，包括子孙节点的内容，这是最常用的方法 搜索文档树find_all( name , attrs , recursive , text , **kwargs ) find_all是用于搜索节点中所有符合过滤条件的节点 1.name参数：是Tag的名字，如p,div,title ….. soup.find_all(&quot;p&quot;) 查找所有的p标签，返回的是[&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;]，可以通过遍历获取每一个节点，如下： 123ps=soup.find_all("p")for p in ps: print p.get('class') #得到p标签下的class属性 传入正则表达式：soup.find_all(re.compile(r&#39;^b&#39;)查找以b开头的所有标签，这里的body和b标签都会被查到 传入类列表：如果传入列表参数,BeautifulSoup会将与列表中任一元素匹配的内容返回.下面代码找到文档中所有&lt;a&gt;标签和&lt;b&gt;标签 1soup.find_all(["a", "b"]) 2.KeyWords参数，就是传入属性和对应的属性值，或者一些其他的表达式 soup.find_all(id=&#39;link2&#39;),这个将会搜索找到所有的id属性为link2的标签。传入正则表达式soup.find_all(href=re.compile(&quot;elsie&quot;)),这个将会查找所有href属性满足正则表达式的标签 传入多个值：soup.find_all(id=&#39;link2&#39;,class_=&#39;title&#39;) ,这个将会查找到同时满足这两个属性的标签，这里的class必须用class_传入参数，因为class是python中的关键词 有些属性不能通过以上方法直接搜索，比如html5中的data-*属性，不过可以通过attrs参数指定一个字典参数来搜索包含特殊属性的标签，如下： 1234# [&lt;div data-foo="value"&gt;foo!&lt;/div&gt;]data_soup.find_all(attrs=&#123;"data-foo": "value"&#125;) #注意这里的atts不仅能够搜索特殊属性，亦可以搜索普通属性soup.find_all("p",attrs=&#123;'class':'title','id':'value'&#125;) #相当与soup.find_all('p',class_='title',id='value') 3.text参数：通过 text 参数可以搜搜文档中的字符串内容.与 name 参数的可选值一样, text 参数接受 字符串 , 正则表达式 , 列表, True12345678soup.find_all(text="Elsie")# [u'Elsie'] soup.find_all(text=["Tillie", "Elsie", "Lacie"])# [u'Elsie', u'Lacie', u'Tillie'] soup.find_all(text=re.compile("Dormouse"))[u"The Dormouse's story", u"The Dormouse's story"] 4.limit参数：find_all() 方法返回全部的搜索结构,如果文档树很大那么搜索会很慢.如果我们不需要全部结果,可以使用 limit 参数限制返回结果的数量.效果与SQL中的limit关键字类似,当搜索到的结果数量达到 limit 的限制时,就停止搜索返回结果. 文档树中有3个tag符合搜索条件,但结果只返回了2个,因为我们限制了返回数量,代码如下： 123soup.find_all("a", limit=2)# [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,# &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;] 5.recursive 参数:调用tag的 find_all() 方法时,BeautifulSoup会检索当前tag的所有子孙节点,如果只想搜索tag的直接子节点,可以使用参数 recursive=False find( name , attrs , recursive , text , **kwargs ) 它与 find_all() 方法唯一的区别是 find_all() 方法的返回结果是值包含一个元素的列表,而 find() 方法直接返回结果,就是直接返回第一匹配到的元素，不是列表，不用遍历，如soup.find(&quot;p&quot;).get(&quot;class&quot;) css选择器 我们在写 CSS 时，标签名不加任何修饰，类名前加点，id名前加#，在这里我们也可以利用类似的方法来筛选元素，用到的方法是 soup.select()，返回类型是 list 通过标签名查找123456print soup.select('title') #[&lt;title&gt;The Dormouse's story&lt;/title&gt;]print soup.select('a')#[&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;, &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;, &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;] 通过类名查找12print soup.select('.sister')#[&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;, &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;, &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;] 通过id名查找12print soup.select('#link1')#[&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;] 组合查找 学过css的都知道css选择器，如p #link1是查找p标签下的id属性为link1的标签 12345print soup.select('p #link1') #查找p标签中内容为id属性为link1的标签#[&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;]print soup.select("head &gt; title") #直接查找子标签#[&lt;title&gt;The Dormouse's story&lt;/title&gt;] 属性查找 查找时还可以加入属性元素，属性需要用中括号括起来，注意属性和标签属于同一节点，所以中间不能加空格，否则会无法匹配到。 123456print soup.select('a[class="sister"]')#[&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;, &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;, &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]print soup.select('a[href="http://example.com/elsie"]')#[&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;] 同样，属性仍然可以与上述查找方式组合，不在同一节点的空格隔开，同一节点的不加空格,代码如下： 12print soup.select('p a[href="http://example.com/elsie"]')#[&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;] 以上的 select 方法返回的结果都是列表形式，可以遍历形式输出，然后用 get_text() 方法来获取它的内容 1234567soup = BeautifulSoup(html, 'lxml')print type(soup.select('title'))print soup.select('title')[0].get_text()for title in soup.select('title'): print title.get_text() 修改文档树 Beautiful Soup的强项是文档树的搜索,但同时也可以方便的修改文档树,这个虽说对于一些其他的爬虫并不适用，因为他们都是爬文章的内容的，并不需要网页的源码并且修改它们，但是在我后续更新的文章中有用python制作pdf电子书的,这个就需要用到修改文档树的功能了，详情请见本人博客 修改tag的名称和属性1234567html="""&lt;p&gt;&lt;a href='#'&gt;修改文档树&lt;/a&gt;&lt;/p&gt;"""soup=BeautifulSoup(html,'lxml')tag=soup.a #得到标签a，可以使用print tag.name输出标签tag['class']='content' #修改标签a的属性class和divtag['div']='nav' 修改.string 注意这里如果标签的中还嵌套了子孙标签，那么如果直接使用string这个属性会将这里的所有的子孙标签都覆盖掉 1234567891011html="""&lt;p&gt;&lt;a href='#'&gt;修改文档树&lt;/a&gt;&lt;/p&gt;"""soup=BeautifulSoup(html,'lxml')tag=soup.atag.string='陈加兵的博客' #这里会将修改文档树变成修改的内容print tagsoup.p.string='陈加兵的博客' #这里修改了p标签的内容，那么就会覆盖掉a标签，直接变成的修改后的文本print soup append append的方法的作用是在在原本标签文本后面附加文本，就像python中列表的append方法 12345678html="""&lt;p&gt;&lt;a href='#'&gt;修改文档树&lt;/a&gt;&lt;/p&gt;"""soup=BeautifulSoup(html,'lxml')soup.a.append("陈加兵的博客") #在a标签和面添加文本，这里的文本内容将会变成修改文档树陈加兵的博客print soupprint soup.a.contents #这里输出a标签的内容，这里的必定是一个带有两个元素的列表 注意这里的append方法也可以将一个新的标签插入到文本的后面，下面将会讲到 new_tag 相信学过js的朋友都知道怎样创建一个新的标签，这里的方法和js中的大同小异，使用的new_tag 1234567891011html="""&lt;p&gt;&lt;p&gt;"""soup=BeautifulSoup(html,'lxml')tag=soup.pnew_tag=soup.new_tag('a') #创建一个新的标签anew_tag['href']='#' #添加属性new_tag.string='陈加兵的博客' #添加文本print new_tag tag.append(new_tag) #将新添加的标签写入到p标签中print tag insert Tag.insert() 方法与 Tag.append() 方法类似,区别是不会把新元素添加到父节点 .contents 属性的最后,而是把元素插入到指定的位置.与Python列表总的 .insert() 方法的用法下同: 1234567891011html="""&lt;p&gt;&lt;p&gt;"""soup=BeautifulSoup(html,'lxml')tag=soup.pnew_tag=soup.new_tag('a')new_tag['href']='#'new_tag.string='陈加兵的博客'tag.append("欢迎来到") #这里向p标签中插入文本，这个文本在contents下的序号为0tag.insert(1,new_tag) #在contents序号为1的位置插入新的标签，如果这里修改成0，那么将会出现a标签将会出现在欢饮来到的前面print tag 注意这的1是标签的内容在contents中的序号，可以用print tag.contents查看当前的内容 insert_before() 和 insert_after() insert_before() 方法在当前tag或文本节点前插入内容,insert_after() 方法在当前tag或文本节点后插入内容: 12345678910111213soup = BeautifulSoup("&lt;b&gt;stop&lt;/b&gt;")tag = soup.new_tag("i")tag.string = "Don't"soup.b.string.insert_before(tag)soup.b# &lt;b&gt;&lt;i&gt;Don't&lt;/i&gt;stop&lt;/b&gt;soup.b.i.insert_after(soup.new_string(" ever "))soup.b# &lt;b&gt;&lt;i&gt;Don't&lt;/i&gt; ever stop&lt;/b&gt;soup.b.contents# [&lt;i&gt;Don't&lt;/i&gt;, u' ever ', u'stop'] clear clear用来移除当前节点的所有的内容，包括其中的子孙节点和文本内容 123456789101112html="""&lt;p&gt;&lt;p&gt;"""soup=BeautifulSoup(html,'lxml')tag=soup.pnew_tag=soup.new_tag('a')new_tag['href']='#'new_tag.string='陈加兵的博客'tag.append("欢迎来到")tag.insert(1,new_tag)tag.clear() #这里将会移除所有内容print tag 参考文章 中文文档http://beautifulsoup.readthedocs.io/zh_CN/latest/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MongoDB干货篇之安装]]></title>
      <url>%2F2017%2F04%2F28%2FMongoDB%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B9%8B%E5%AE%89%E8%A3%85%2F</url>
      <content type="text"><![CDATA[MongoDB干货篇之安装安装 下载地址 点击安装,选择自定义，后选择安装路径，不过最好安装在根目录下(C盘)，然后点解next,这里我安装的路径是C:\MongoDB 创建文件夹:在C:\MongoDB下创建一个文件夹data,然后在data文件夹下创建db,log两个子文件夹,在log文件下创建一个MongoDB.log文档，总得来说创建了C:\MongoDB\data,C:\MongoDB\data\db,C:\MongoDB\data\log,C:\MongoDB\data\log\MongoDB.log 在C:\MongoDB\bin文件夹下运行cmd.exe进入dos命令，执行以下命令： 然后在cmd下输入mongod -dbpath &quot;C:\MongoDB\data\db,将会看到一些信息，说明已经安装成功了 测试连接 在C:\MongoDB\bin文件夹下运行cmd.exe,输入mongo或者mongo.exe,将会出现连接的信息，说明已经连接成功了 然后在另外一个cmd.exe在bin目录下运行mongo可以看到已经连接上MongoDB了，注意上面打开的终端不能关闭，否则不能成功连接，这是比较麻烦的，需要每次连接都要启动，下面我们需要把它安装为windows服务 安装程windows服务注意在管理员的cmd.exe中运行以下命令，否则在MongoDB.log文件里出现遭到拒绝 运行cmd，进入bin目录，执行以下命令: mongod --dbpath &quot;C:\MongoDB\data\db&quot; --logpath &quot;D:\MongoDB\data\log\MongoDB.log&quot; --install --serviceName &quot;MongoDB&quot;,这里的服务名为MongoDB，可以在C:\MongoDB\data\log\MongoDB.log文件里查看相关信息，如果出现遭到拒绝就是没有在管理员的权限下执行命令 接下来就是启动服务了，现在在cmd.exe中运行NET START MongoDB，如果看到服务成功启动，那么就成功了，但是我在启动的时候出现48错误，下面将会做出解决方法： 先删除服务:mongod --dbpath &quot;C:\MongoDB\data\db&quot; --logpath &quot;C:\MongoDB\data\log\MongoDB.log&quot; --remove --serviceName &quot;MongoDB&quot; 删除MongoDB目录下的mongod.lock 然后就是重新安装了,执行以下命令： mongod --logpath &quot;C:\MongoDB\data\log\MongoDB.log&quot; --logappend --dbpath &quot;C:\Mongodb\data&quot; --directoryperdb --serviceName &quot;MongoDB&quot; --serviceDisplayName &quot;MongoDB&quot; --install 接下来重新启动服务，net start MongoDB,可以看到成功启动了 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BootStrap干货篇之表单]]></title>
      <url>%2F2017%2F04%2F26%2FBootStrap%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B9%8B%E8%A1%A8%E5%8D%95%2F</url>
      <content type="text"><![CDATA[BootStrap干货篇之表单基本介绍 单独的表单控件会被自动赋予一些全局样式。所有设置了 .form-control 类的 &lt;input&gt;、&lt;textarea&gt; 和 &lt;select&gt; 元素都将被默认设置宽度属性为 width: 100%;。 将 label元素和前面提到的控件包裹在 .form-group 中可以获得最好的排列。 基本实例： 1234567891011121314151617181920212223 &lt;div class=&apos;container&apos;&gt; &lt;form&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputEmail1&quot;&gt;Email address&lt;/label&gt; &lt;input type=&quot;email&quot; class=&quot;form-control&quot; id=&quot;exampleInputEmail1&quot; placeholder=&quot;Email&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputPassword1&quot;&gt;Password&lt;/label&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;exampleInputPassword1&quot; placeholder=&quot;Password&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputFile&quot;&gt;File input&lt;/label&gt; &lt;input type=&quot;file&quot; id=&quot;exampleInputFile&quot;&gt; &lt;p class=&quot;help-block&quot;&gt;Example block-level help text here.&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot;&gt; Check me out &lt;/label&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt; &lt;/div&gt; 说明：这里的form-control是对所有的输入控件而言的,源码中将width设置为100%，表示会将这个输入控件占满一整行，form-group是用来对label和input更好的排版的，其中还有form-group-sm,form-group-lg，源码中分别利用这个对带有form-control的控件设置了不同的高度，具体看源码，不过正常情况下还是使用form-group 内联表单 为 &lt;form&gt; 元素添加 .form-inline 类可使其内容左对齐并且表现为inline-block级别的控件。只适用于视口（viewport）至少在 768px 宽度时（视口宽度再小的话就会使表单折叠）从源码中可以看到对form-inline下的form-group,form-control,form-control-static,input-group,radio,checkbox都是用了display:inline-block 注意： 在 Bootstrap 中，输入框和单选/多选框控件默认被设置为 width: 100%; 宽度。在内联表单，我们将这些元素的宽度设置为width: auto;，因此，多个控件可以排列在同一行。根据你的布局需求，可能需要一些额外的定制化组件。 一定要有label标签，如果不想要label标签可以设置.sr-only将其隐藏如果你没有为每个输入控件设置 label 标签，屏幕阅读器将无法正确识别。对于这些内联表单，你可以通过为 label 设置 .sr-only 类将其隐藏。还有一些辅助技术提供label标签的替代方案，比如 aria-label、aria-labelledby或 title 属性。如果这些都不存在，屏幕阅读器可能会采取使用 placeholder 属性，如果存在的话，使用占位符来替代其他的标记，但要注意，这种方法是不妥当的。 实例: 1234567891011121314151617&lt;form class=&quot;form-inline&quot;&gt; &lt;!--指定了form-inline类--&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;!--label中的for标签是用于绑定组件的，如果指定了for标签，input中的id也和for标签的内容相同，那么就会当鼠标点击&lt;label&gt;内容时会自动聚焦在input上--&gt; &lt;label class=&quot;sr-only&quot; for=&quot;exampleInputEmail3&quot;&gt;Email address&lt;/label&gt; &lt;input type=&quot;email&quot; class=&quot;form-control&quot; id=&quot;exampleInputEmail3&quot; placeholder=&quot;Email&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;sr-only&quot; for=&quot;exampleInputPassword3&quot;&gt;Password&lt;/label&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;exampleInputPassword3&quot; placeholder=&quot;Password&quot;&gt; &lt;/div&gt; &lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot;&gt; Remember me &lt;/label&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Sign in&lt;/button&gt;&lt;/form&gt; 水平表单 水平表单通过指定为form指定form-horizontal类来设定，其中可以使用BootStrap的栅栏系统设置水平间距，其中的form-group的div就表示一行了，相当于&lt;div class=&#39;row&#39;&gt;&lt;/div&gt;,因此只需要在label和input中指定列就行了，但是input标签不能直接使用，要在外面加上div 实例： 12345678910111213141516171819202122232425262728&lt;form class=&quot;form-horizontal&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;inputEmail3&quot; class=&quot;col-sm-2 control-label&quot;&gt;Email&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;email&quot; class=&quot;form-control&quot; id=&quot;inputEmail3&quot; placeholder=&quot;Email&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;!--相当与&lt;div class=&apos;row&apos;&gt;&lt;/div&gt;--&gt; &lt;label for=&quot;inputPassword3&quot; class=&quot;col-sm-2 control-label&quot;&gt;Password&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;inputPassword3&quot; placeholder=&quot;Password&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;col-sm-offset-2 col-sm-10&quot;&gt; &lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot;&gt; Remember me &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;col-sm-offset-2 col-sm-10&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Sign in&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 说明上面的label标签中的control-label主要的作用是设置文字的对齐方式为左对齐，如果不加这个将会在右边出现很大的空白 多选和单选框 多选框（checkbox）用于选择列表中的一个或多个选项，而单选框（radio）用于从多个选项中只选择一个。其中提供的类有checkbox,checkbox-inline,radio,radio-inline 内联单选和多选框 通过将 .checkbox-inline 或 .radio-inline 类应用到一系列的多选框（checkbox）或单选框（radio）控件上，可以使这些控件排列在一行。 实例： 12345678910111213141516171819202122232425262728&lt;label class=&quot;checkbox-inline&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;inlineCheckbox1&quot; value=&quot;option1&quot;&gt; 1&lt;/label&gt;&lt;label class=&quot;checkbox-inline&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;inlineCheckbox2&quot; value=&quot;option2&quot;&gt; 2&lt;/label&gt;&lt;label class=&quot;checkbox-inline&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;inlineCheckbox3&quot; value=&quot;option3&quot;&gt; 3&lt;/label&gt;&lt;label class=&quot;radio-inline&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;inlineRadioOptions&quot; id=&quot;inlineRadio1&quot; value=&quot;option1&quot;&gt; 1&lt;/label&gt;&lt;label class=&quot;radio-inline&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;inlineRadioOptions&quot; id=&quot;inlineRadio2&quot; value=&quot;option2&quot;&gt; 2&lt;/label&gt;&lt;label class=&quot;radio-inline&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;inlineRadioOptions&quot; id=&quot;inlineRadio3&quot; value=&quot;option3&quot;&gt; 3&lt;/label&gt;&lt;div class=&quot;checkbox-inline&quot;&gt; &lt;label for=&quot;sex&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;checkbox-inline&quot;&gt; &lt;label for=&quot;sex&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt;男&lt;/label&gt; &lt;/div&gt; 不带label文本的Checkbox 和 radio 如果需要 &lt;label&gt; 内没有文字，输入框（input）正是你所期望的。 目前只适用于非内联的 checkbox和 radio。 请记住，仍然需要为使用辅助技术的用户提供某种形式的 label（例如，使用 aria-label）。 实例： 12345678910&lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;blankCheckbox&quot; value=&quot;option1&quot; aria-label=&quot;...&quot;&gt; &lt;/label&gt;&lt;/div&gt;&lt;div class=&quot;radio&quot;&gt; &lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;blankRadio&quot; id=&quot;blankRadio1&quot; value=&quot;option1&quot; aria-label=&quot;...&quot;&gt; &lt;/label&gt;&lt;/div&gt; 下拉列表（select） 实例： 1234567&lt;select class=&quot;form-control&quot;&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt;&lt;/select&gt; 静态控件 如果需要在表单中将一行纯文本和 label 元素放置于同一行，为&lt;p&gt;标签设置为form-control-static 实例： 1234567891011121314&lt;form class=&quot;form-horizontal&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;col-sm-2 control-label&quot;&gt;Email&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;p class=&quot;form-control-static&quot;&gt;email@example.com&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;inputPassword&quot; class=&quot;col-sm-2 control-label&quot;&gt;Password&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;inputPassword&quot; placeholder=&quot;Password&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 参考文章 中文官网 文档手册 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Scrapyd部署爬虫]]></title>
      <url>%2F2017%2F04%2F24%2FScrapyd%E9%83%A8%E7%BD%B2%E7%88%AC%E8%99%AB%2F</url>
      <content type="text"><![CDATA[Scrapyd部署爬虫准备工作 安装scrapyd: pip install scrapyd 安装scrapyd-client : pip install scrapyd-client 安装curl:[安装地址](http://ono60m7tl.bkt.clouddn.com/curl.exe),安装完成以后将所在目录配置到环境变量中 开始部署 修改scrapy项目目录下的scrapy.cfg文件，修改如下 123[deploy:JD_Spider] #加上target :nameurl = http://localhost:6800/ #将前面的#删除project = JD #project的名字，可以使用默认的，当然也可以改变 在任意目录下的打开终端，输入scrapyd,观察是否运行成功，运行成功的话，就可以打开http://localhost:6800看是否正常显示，如果正常显示则看到下面的这张图,这里的JD是部署之后才能看到的，现在是看不到的，所以没出现也不要担心： 在项目的根目录下运行如下的命令：python E:\python2.7\Scripts\scrapyd-deploy target -p project,这里的E:\python2.7\Scripts\是你的python安装目录，Scripts是安装目录下的一个文件夹，注意前面一定要加上python,target是在前面scrapy.cfg中设置的deploy:JD_Spider，JD_Spider就是target,project 是JD,因此这个完整的命令是python E:\python2.7\Scripts\scrapyd-deploy JD_Spider -p JD,现在项目就部署到上面了，这下网页上就有JD了，详情请见上图 验证是否成功，你可以在网页上看有没有显示你的工程名字，另外在根目录下输入python E:\python2.7\Scripts\scrapyd-deploy -l就能列出你所有部署过的项目了 启动爬虫：curl http://localhost:6800/schedule.json -d project=myproject -d spider=spider_name,这里的project填入的是项目名，spider_name填入的是你的爬虫中定义的name,运行我的实例完整的代码为：curl http://localhost:6800/schedule.json -d project=JD -d spider=spider，这里将会显示如下信息： 12#这里的jobid比较重要，下面会用到这个取消爬虫&#123;"status": "ok", "jobid": "3013f9d1283611e79a63acb57dec5d04", "node_name": "DESKTOP-L78TJQ7"&#125; 取消爬虫：curl http://localhost:6800/cancel.json -d project=myproject -d job=jobid,jobid就是上面的提到过的，如果取消我的这个实例代码如：curl http://localhost:6800/cancel.json -d project=JD -d job=3013f9d1283611e79a63acb57dec5d04,那么它的状态就会变成如下： 1&#123;"status": "ok", "prevstate": "running", "node_name": "DESKTOP-L78TJQ7"&#125; 列出项目：curl http://localhost:6800/listprojects.json,下面将会出现你已经部署的项目 删除项目：curl http://localhost:6800/delproject.json -d project=myproject 列出版本：curl http://localhost:6800/listversions.json?project=myproject,这里的project是项目的名字，是在scrapy.cfg设置的 列出爬虫：curl http://localhost:6800/listspiders.json?project=myproject这里的project是项目的名字，是在scrapy.cfg设置的 列出job:curl http://localhost:6800/listjobs.json?project=myproject这里的project是项目的名字，是在scrapy.cfg设置的 删除版本：curl http://localhost:6800/delversion.json -d project=myproject -d version=r99，这里的version是自己的项目版本号，在删除之前需要查看版本号 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[scrapy大战京东商城]]></title>
      <url>%2F2017%2F04%2F23%2Fscrapy%E5%A4%A7%E6%88%98%E4%BA%AC%E4%B8%9C%E5%95%86%E5%9F%8E%2F</url>
      <content type="text"><![CDATA[SCrapy爬虫大战京东商城引言 上一篇已经讲过怎样获取链接，怎样获得参数了，详情请看python爬取京东商城普通篇 代码详解 首先应该构造请求，这里使用scrapy.Request,这个方法默认调用的是start_urls构造请求，如果要改变默认的请求，那么必须重载该方法，这个方法的返回值必须是一个可迭代的对象，一般是用yield返回，代码如下： 12345def start_requests(self): for i in range(1,101): page=i*2-1 #这里是构造请求url的page,表示奇数 url=self.start_url+str(page) yield scrapy.Request(url,meta=&#123;'search_page':page+1&#125;,callback=self.parse_url) #这里使用meta想回调函数传入数据，回调函数使用response.meta['search-page']接受数据 下面就是解析网页了，从上面看出这里的解析回调函数是parse_url,因此在此函数中解析网页。这里还是和上面说的一样，这个url得到的仅仅是前一半的信息，如果想要得到后一半的信息还有再次请求，这里还有注意的就是一个技巧：一般先解析出一个数据的数组，不急着取出第一个数，先要用if语句判断，因为如果得到的是[]，那么直接取出[0]是会报错的，这只是一个避免报错的方法吧，代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950def parse_url(self,response): if response.status==200: #判断是否请求成功 # print response.url pids = set() #这个集合用于过滤和保存得到的id,用于作为后面的ajax请求的url构成 try: all_goods = response.xpath("//div[@id='J_goodsList']/ul/li") #首先得到所有衣服的整个框架，然后从中抽取每一个框架 for goods in all_goods: #从中解析每一个 # scrapy.shell.inspect_response(response,self) #这是一个调试的方法，这里会直接打开调试模式 items = JdSpiderItem() #定义要抓取的数据 img_url_src = goods.xpath("div/div[1]/a/img/@src").extract() # 如果不存在就是一个空数组[]，因此不能在这里取[0] img_url_delay = goods.xpath( "div/div[1]/a/img/@data-lazy-img").extract() # 这个是没有加载出来的图片，这里不能写上数组取第一个[0] price = goods.xpath("div/div[3]/strong/i/text()").extract() #价格 cloths_name = goods.xpath("div/div[4]/a/em/text()").extract() shop_id = goods.xpath("div/div[7]/@ data-shopid").extract() cloths_url = goods.xpath("div/div[1]/a/@href").extract() person_number = goods.xpath("div/div[5]/strong/a/text()").extract() pid = goods.xpath("@data-pid").extract() # product_id=goods.xpath("@data-sku").extract() if pid: pids.add(pid[0]) if img_url_src: # 如果img_url_src存在 print img_url_src[0] items['img_url'] = img_url_src[0] if img_url_delay: # 如果到了没有加载完成的图片，就取这个url print img_url_delay[0] items['img_url'] = img_url_delay[0] # 这里如果数组不是空的，就能写了 if price: items['price'] = price[0] if cloths_name: items['cloths_name'] = cloths_name[0] if shop_id: items['shop_id'] = shop_id[0] shop_url = "https://mall.jd.com/index-" + str(shop_id[0]) + ".html" items['shop_url'] = shop_url if cloths_url: items['cloths_url'] = cloths_url[0] if person_number: items['person_number'] = person_number[0] # if product_id: # print "************************************csdjkvjfskvnk***********************" # print self.comments_url.format(str(product_id[0]),str(self.count)) # yield scrapy.Request(url=self.comments_url.format(str(product_id[0]),str(self.count)),callback=self.comments) #yield scrapy.Request写在这里就是每解析一个键裤子就会调用回调函数一次 yield items except Exception: print "********************************************ERROR**********************************************************************" yield scrapy.Request(url=self.search_url.format(str(response.meta['search_page']),",".join(pids)),callback=self.next_half_parse) #再次请求，这里是请求ajax加载的数据，必须放在这里，因为只有等到得到所有的pid才能构成这个请求，回调函数用于下面的解析 从上面代码的最后可以看出最后就是解析ajax加载的网页了，这里调用的next_half_parse函数，和解析前面一个网页一样，这里需要的注意的是，如果前面定义的数据没有搜索完毕是不能使用yield items的，必须将items通过meta传入下一个回调函数继续完善后才能yield items,这里就不需要了，代码如下： 12345678910111213141516171819202122232425262728293031323334353637#分析异步加载的网页 def next_half_parse(self,response): if response.status==200: print response.url items=JdSpiderItem() #scrapy.shell.inspect_response(response,self) #y用来调试的 try: lis=response.xpath("//li[@class='gl-item']") for li in lis: cloths_url=li.xpath("div/div[1]/a/@href").extract() img_url_1=li.xpath("div/div[1]/a/img/@src").extract() img_url_2=li.xpath("div/div[1]/a/img/@data-lazy-img").extract() cloths_name=li.xpath("div/div[4]/a/em/text()").extract() price=li.xpath("div/div[3]/strong/i/text()").extract() shop_id=li.xpath("div/div[7]/@data-shopid").extract() person_number=li.xpath("div/div[5]/strong/a/text()").extract() if cloths_url: print cloths_url[0] items['cloths_url']=cloths_url[0] if img_url_1: print img_url_1[0] items['img_url']=img_url_1 if img_url_2: print img_url_2[0] items['img_url']=img_url_2[0] if cloths_name: items['cloths_name']=cloths_name[0] if price: items['price']=price[0] if shop_id: items['shop_id']=shop_id[0] items['shop_url']="https://mall.jd.com/index-" + str(shop_id[0]) + ".html" if person_number: items['person_number']=person_number[0] yield items #又一次的生成，这里是完整的数据，因此可以yield items except Exception: print "**************************************************" 当然这里还用到了设置请求池，mysql存储，没有使用到ip代理，这个在我前面的博客中又讲到，这里就不再赘述了，想看源代码的朋友请点击这里 小技巧 人们会抱怨为什么自己的爬虫在中途断开就要重头开始爬，为什么不能从断开那里开始爬呢，这里提供一个方法：在配置文件settings.py中加入JOBDIR=file_name,这里的file_name是一个文件的名字 设置下载延迟防止被ban:DOWNLOAD_DELAY = 2:设置每一次的间隔时间 RANDOMIZE_DOWNLOAD_DELAY = True:这个是随机设置延迟时间 在设置的时间的0.5-1.5倍之间，这样可以更有效的防止被ban,一般是配套使用的 ROBOTSTXT_OBEY = False :这里是表示不遵循robots.txt文件，默认是True表示遵循，这里将之改成False CONCURRENT_REQUESTS :设置最大请求数，这里默认的时16，我们可以根据自己电脑的配置改的大一点来加快请求的速度 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python爬虫大战京东商城]]></title>
      <url>%2F2017%2F04%2F23%2Fpython%E7%88%AC%E8%99%AB%E5%A4%A7%E6%88%98%E4%BA%AC%E4%B8%9C%E5%95%86%E5%9F%8E%2F</url>
      <content type="text"><![CDATA[python大规模爬取京东主要工具 scrapy BeautifulSoup requests 分析步骤 打开京东首页，输入裤子将会看到页面跳转到了这里，这就是我们要分析的起点 我们可以看到这个页面并不是完全的，当我们往下拉的时候将会看到图片在不停的加载，这就是ajax,但是当我们下拉到底的时候就会看到整个页面加载了60条裤子的信息，我们打开chrome的调试工具，查找页面元素时可以看到每条裤子的信息都在&lt;li class=&#39;gl-item&#39;&gt;&lt;/li&gt;这个标签中，如下图： 接着我们打开网页源码就会发现其实网页源码只有前30条的数据，后面30条的数据找不到，因此这里就会想到ajax，一种异步加载的方式，于是我们就要开始抓包了，我们打开chrome按F12，点击上面的NetWork,然后点击XHR,这个比较容易好找,下面开始抓包，如下图： 从上面可以找到请求的url，发现有很长的一大段，我们试着去掉一些看看可不可以打开，简化之后的url=https://search.jd.com/s_new.php?keyword=%E8%A3%A4%E5%AD%90&amp;enc=utf-8&amp;qrst=1&amp;rt=1&amp;stop=1&amp;vt=2&amp;offset=3&amp;wq=%E8%A3%A4%E5%AD%90&amp;page={0}&amp;s=26&amp;scrolling=y&amp;pos=30&amp;show_items={1}这里的showitems是裤子的id,page是翻页的，可以看出来我们只需要改动两处就可以打开不同的网页了，这里的page很好找，你会发现一个很好玩的事情，就是主网页的page是奇数，但是异步加载的网页中的page是偶数，因此这里只要填上偶数就可以了，但是填奇数也是可以访问的。这里的show_items就是id了，我们可以在页面的源码中找到，通过查找可以看到id在li标签的data-pid中，详情请看下图 上面我们知道怎样找参数了，现在就可以撸代码了 代码讲解 首先我们要获取网页的源码，这里我用的requests库，安装方法为pip install requests，代码如下: 1234def get_html(self): res = requests.get(self.url, headers=self.headers) html = res.text return html #返回的源代码 根据上面的分析可以知道，第二步就是得到异步加载的url中的参数show_items,就是li标签中的data-pid,代码如下： 12345678def get_pids(self): html = self.get_html() soup = BeautifulSoup(html, 'lxml') #创建BeautifulSoup对象 lis = soup.find_all("li", class_='gl-item') #查找li标签 for li in lis: data_pid = li.get("data-pid") #得到li标签下的data-pid if (data_pid): self.pids.add(data_pid) #这里的self.pids是一个集合，用于过滤重复的 下面就是获取前30张图片的url了，也就是主网页上的图片，其中一个问题是img标签的属性并不是一样的，也就是源码中的img中不都是src属性，一开始已经加载出来的图片就是src属性，但是没有加载出来的图片是data-lazy-img，因此在解析页面的时候要加上讨论。代码如下： 12345678910111213141516def get_src_imgs_data(self): html = self.get_html() soup = BeautifulSoup(html, 'lxml') divs = soup.find_all("div", class_='p-img') # 图片 # divs_prices = soup.find_all("div", class_='p-price') #价格 for div in divs: img_1 = div.find("img").get('data-lazy-img') # 得到没有加载出来的url img_2 = div.find("img").get("src") # 得到已经加载出来的url if img_1: print img_1 self.sql.save_img(img_1) self.img_urls.add(img_1) if img_2: print img_2 self.sql.save_img(img_2) self.img_urls.add(img_2) 前三十张图片找到了，现在开始找后三十张图片了，当然是要请求那个异步加载的url，前面已经把需要的参数给找到了，下面就好办了，直接贴代码： 12345678910111213141516171819def get_extend_imgs_data(self): # self.search_urls=self.search_urls+','.join(self.pids) self.search_urls = self.search_urls.format(str(self.search_page), ','.join(self.pids)) #拼凑url,将获得的单数拼成url,其中show_items中的id是用','隔开的，因此要对集合中的每一个id分割，page就是偶数，这里直接用主网页的page加一就可以了 print self.search_urls html = requests.get(self.search_urls, headers=self.headers).text #请求 soup = BeautifulSoup(html, 'lxml') div_search = soup.find_all("div", class_='p-img') #解析 for div in div_search: img_3 = div.find("img").get('data-lazy-img') #这里可以看到分开查找img属性了 img_4 = div.find("img").get("src") if img_3: #如果是data-lazy-img print img_3 self.sql.save_img(img_3) #存储到数据库 self.img_urls.add(img_3) #用集合去重 if img_4: #如果是src属性 print img_4 self.sql.save_img(img_4) self.img_urls.add(img_4) 通过上面就可以爬取了，但是还是要考虑速度的问题，这里我用了多线程，直接每一页面开启一个线程，速度还是可以的，感觉这个速度还是可以的，几分钟解决问题，总共爬取了100个网页,这里的存储方式是mysql数据库存储的，要用发哦MySQLdb这个库，详情自己百度，当然也可以用mogodb但是还没有学呢，想要的源码的朋友请看GitHub源码 拓展写到这里可以看到搜索首页的网址中keyword和wq都是你输入的词，如果你想要爬取更多的信息，可以将这两个词改成你想要搜索的词即可，直接将汉字写上，在请求的时候会自动帮你编码的，我也试过了，可以抓取源码的，如果你想要不断的抓取，可以将要搜索的词写上文件里，然后从文件中读取就可以了。以上只是一个普通的爬虫，并没有用到什么框架，接下来将会写scrapy框架爬取的，请继续关注我的博客哦！！！ 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JQuery干货篇之处理元素]]></title>
      <url>%2F2017%2F04%2F22%2FJQuery%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B9%8B%E5%A4%84%E7%90%86%E5%85%83%E7%B4%A0%2F</url>
      <content type="text"><![CDATA[JQuery干货篇之处理元素 注意这里用的还是我前两篇用的例子，详情请看我的博客 attrattr() 方法设置或返回被选元素的属性值。 语法： $(selector).attr(attribute) 返回被选元素的属性值。 $(selector).attr(attribute,value) 设置被选元素的属性和值 $(selector).attr(attribute,function(index,oldvalue)) 设置被选元素的属性和值。 参数 描述 attribute 规定属性的名称。 function(index,oldvalue) 规定返回属性值的数。该函数可接收并使用选择器的 index 值和当前属性值。 实例：12345678910111213141516171819202122 $("img").filter(":first").attr('src'); //得到属性$("img").each(function (index,elem) &#123; if(index%2==0) $(elem).attr("src",'lily.png'); //设置属性 console.log($(elem).attr("src")); &#125;) $("img").attr('src',function (index,oldValue) &#123; //这里的oldValue表示原来属性的值，index是索引 if(oldValue=="rose.png") return 'lily.png'; else return 'astor.png'; &#125;) attrs=&#123; //使用映射对象一次设置多个值 src:'lily.png', style: 'border: thick double red' &#125;; $("img:eq(1)").attr(attrs); removeAttr removeAttr() 方法从被选元素中移除属性。 语法： $(selector).removeAttr(attribute) 这里的attribute是属性的名字 实例： 1$("img:first").removeAttr("src"); //删除属性src addClass addClass() 方法向被选元素添加一个或多个类 语法： $(selector).addClass(class) 这里的class是类名如果需要添加多个类，中间用空格隔开 $(selector).addClass(function(index,oldclass)) 这里的index是索引，oldClass是原来就有的类名，都是可选参数。这个函数的返回的就是要添加的类名 实例： 12345678910111213$("img:even").addClass("redBar"); //向偶数的img添加类redBar$("img").addClass(function (index,currentClass) &#123; //这里的currentClass就是原来有的类名，可选 if(index==1) return 'blueBar'; //第二个img应用blueBar这个类 else return 'redBar'; //这里需要注意的是，对同一个img应用类的时候，因为这个类的定义有优先级，上面定义会被后面定义的覆盖，所以要注意类定义的位置 &#125;) $("img").filter(":odd").addClass("redBar").end().filter(":even").addClass("blueBar"); //链式调用 $("img").addClass("blueBar redBar"); //添加两个类 hasClass hasClass() 方法检查被选元素是否包含指定的class 语法： $(selector).hasClass(class) //返回值是false和true 实例： 1console.log($("img:odd").hasClass("redBar")); toggleClass toggleClass() 对设置或移除被选元素的一个或多个类进行切换。该方法检查每个元素中指定的类。如果不存在则添加类，如果已设置则删除之。这就是所谓的切换效果 语法： $(selector).toggleClass(class,switch) class必需的，用来规定添加或移除class的指定元素，如需规定若干 class，请使用空格来分隔类名。switch是boolean可选参数，规定是否添加或移除class $(selector).toggleClass(function(index,class),switch) index表示索引，class表示选择器当前拥有的类 实例： 123456789101112131415161718192021222324$("img").toggleClass("redBar"); //这里对所有的img在redBar这个类之间切换$("img").toggleClass("redBar blueBar"); //在两个类之间来回的切换$("&lt;button&gt;ToggleClass&lt;/button&gt;").appendTo("#buttonDiv").click(function (e) &#123; $("img").toggleClass('redBar blueBar'); //在两种class之间切换，如果有就删除，没有的就添加 e.preventDefault(); &#125;) //下面添加一个按钮，完成同时添加多个图片的效果 $("&lt;button&gt;ToggleClass&lt;/button&gt;").appendTo("#buttonDiv").click(function (e) &#123; $("img").toggleClass(function (index,currentClass) &#123; if(index%2==0) return 'blueBar'; //动态的切换，这里是偶数就切换blue else return 'redBar blueBar'; //这里是奇数的图片在两种颜色来回的切换 &#125;); e.preventDefault(); &#125;) css css() 方法返回或设置匹配的元素的一个或多个样式属性，这里只说css，还有其他的设置css样式请看w3School 语法： $(selector).css(name) 返回第一个匹配元素的 CSS属性值。name是css属性的名称 $(selector).css(name,value) 设置所有匹配元素的指定 CSS 属性。name表示属性名称，value表示属性的值 $(selector).css(name,function(index,value)) 此函数返回要设置的属性值。接受两个参数，index为元素在对象集合中的索引位置，value 是原先的属性值。name表示要设置的属性名称，返回值就是要设置的属性值 实例： 1234567891011$("label").css('font-size','30px'); //设置字体大小$("label").css('font-size','+=10'); //使用相对值设置属性值，在原有的基础上加上10console.log($("h1").css('font-family')); //获取h1标签的字体var cssValues=&#123; 'border':'thick double red', 'font-size':'1.5em'&#125;;$("label").css(cssValues); //同时设置多个属性 text text() 方法方法设置或返回被选元素的文本内容。当该方法用于返回一个值时，它会返回所有匹配元素的组合的文本内容(会删除 HTML 标记) 语法： $(selector).text() 当该方法用于返回一个值时，它会返回所有匹配元素的组合的文本内容（会删除 HTML 标记）。 $(selector).text(content) 当该方法用于设置值时，它会覆盖被选元素的所有内容。 $(selector).text(function(index,oldcontent)) index表示索引,oldcontent表示选择器当前的文本内容 html html() 方法返回或设置被选元素的内容 (inner HTML)。如果该方法未设置参数，则返回被选元素的当前内容。 语法： $(selector).html() 当使用该方法返回一个值时，它会返回第一个匹配元素的内容。 $(selector).html(content) 当使用该方法设置一个值时，它会覆盖所有匹配元素的内容。 $(selector).html(function(index,oldcontent)) 使用函数来设置所有匹配元素的内容。index - 可选。接收选择器的index 位置,oldcontent - 可选。接收选择器的当前内容 val val() 方法返回或设置被选元素的值,元素的值是通过 value 属性设置的。该方法大多用于 input 元素,如果该方法未设置参数，则返回被选元素的当前值 语法： $(selector).val(value) 设置文本域的值为value $(selector).val() 得到文本域的值 $(selector).val(function(index,oldvalue)) 设置文本域的值，这里函数的返回值将会用来设置文本域的值，index表示元素索引，oldvalue表示选择器当前文本域的值 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JQuery干货篇之操控DOM]]></title>
      <url>%2F2017%2F04%2F21%2FJQuery%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B9%8B%E6%93%8D%E6%8E%A7DOM%2F</url>
      <content type="text"><![CDATA[JQuery干货篇之插入元素本次使用的html,css还是我上一篇的源代码，详情请看上一篇文章 分类 插入子元素：append,prepend ,appendTo,prependTo 封装包裹元素：wrap,wrapAll,wrapInner 插入兄弟元素：after,before,insertAfter,insertBefore 替换元素：replaceWith,replaceAll 删除元素：remove,deatch,unwrap,empty 创建新元素通常在把新元素插入到DOM中的目标位置之前，要先创建一个新元素才能将它插入到指定位置 使用$创建元素 $(&lt;div&gt;&lt;img src=&#39;rose.png&#39; alt=&#39;玫瑰&#39;&gt;&lt;/div&gt;) clone 克隆元素，使用clone方法以已有的元素为模子生成新的元素，这个在后面的插入元素起到关键作用，如果在要引用html中的一个标签内容的话，不使用clone方法，那么就会将这段内容移动，因此这里使用clone会很方便，详细请看append的用法实例 实例： 1$("div.dcell").clone(); //这里的clone方法必须是JQuery对象调用 使用DOM API创建新元素 DOM API是用js操作的，其实jquery在幕后悄悄的调用DOM API 实例： 1234567891011121314 var divElem=document.createElement("div"); //创建一个div元素 divElem.classList.add("dcell"); //为div添加class=dcellvar imgElem=document.createElement("img");imgElem.src="lily.png";divElem.appendChild(imgElem); //在新创建的元素后面插入imgvar newElem=$(divElem);newElem.each(function (index,elem) &#123; console.log(elem.tagName+" "+elem.className);&#125;); append 把参数指定的元素插入到所有的JQuery内含元素内容末尾成为他们的最后一个子元素，形式有append(html),append(Jquery),append(HTMLElements[])，append(function()) 实例： 12345678910111213141516171819202122232425//这里使用append元素创建了一个div元素，在末尾插入元素成为div的子元素// var orchildElems = $("&lt;div class='dcell'&gt;&lt;/div&gt;").append("&lt;img src='orchid.png'/&gt;") .append("&lt;label for='orchild'&gt;Orchild:&lt;/label&gt;") .append("&lt;input name='orchild' value='0' required&gt;"); var newElems = $("&lt;div class='dcell'&gt;&lt;/div&gt;").append("&lt;img src='lily.png'/&gt;") .append("&lt;label for='lily'&gt;Lily:&lt;/label&gt;") .append("&lt;input name='lily' value='0' required&gt;") .css("border", 'thick double red'); $("div.drow").append(orchildElems); //在末尾插入数据，这里的参数是jquery对象 $("div.drow").append(function(index,elem)&#123; if(elem.id=='row1') return orchildElems; else if(this.id='row2') return newElems; &#125;) $("div.drow").last().append(orchildElem,newElems); //在其中添加两个参数，插入的先后按照参数的先后位置，当然其中的参数个数没有限制 prepend 和append完全相反,向当前元素的前面插入html节点作为当前元素的子元素,形式有prepen d(Jquery),prepend(html),prepend(htmlElemnts[]),prepend(function()) 实例： 123456789101112131415161718 var orchildElems = $("&lt;div class='dcell'&gt;&lt;/div&gt;").append("&lt;img src='orchid.png'/&gt;") .append("&lt;label for='orchild'&gt;Orchild:&lt;/label&gt;") .append("&lt;input name='orchild' value='0' required&gt;");$("div.dcell").prepend(orchildElems); //将orchildElems插入到div.dcell的最前面，作为他的子元素$("div.dcell").prepend("&lt;img src='lily.png'&gt;"); //将参数html的内容插入到前面，作为子元素$("div.drow").append(function (index) &#123; //参数是函数，index是索引，返回的内容就是要插入到前面的内容 if (this.id == 'row1') return orchildElem; //返回的对象可以是jquery对象，也可以是html标签，如：return "&lt;img src='lily.png'&gt; else if (this.id = 'row2') return newElems; &#125;); appendTo appendTo是和append一样的函数，都是将指定的元素插入到指定元素的前面作为子元素，但是他们的参数就不同了，append是将指定的参数插入到当前调用它的的结果集中，而appendTo是将当前调用它的结果集插入到指定的参数中，主要的形式有appendTo(jquery),append(HTMLELments[]) 实例： 123456$("&lt;img src='lily.png'&gt;").appendTo($("img").last().parent()); //将图片插入到最后一个dcell中，这里参数是目标位置，开头调用的时想要插入的内容$("img:first").clone().appendTo($("img").last().parent()); //选择第一个图片插入到最后一个dcell中，这里必须用clone，否则就会将这张图片移到目标位置 $($("div.dcell").html()).appendTo($("img").last().parent()); //这里的.html()是获取html文本内容 prependTo .prepend()和.prependTo()实现同样的功能，主要的不同是语法，插入的内容和目标的位置不同。 对于 .prepend() 而言，选择器表达式写在方法的前面，作为待插入内容的容器，将要被插入的内容作为方法的参数。而 .prependTo() 正好相反，将要被插入的内容写在方法的前面，可以是选择器表达式或动态创建的标记，待插入内容的容器作为参数。 after 在匹配元素集合中的每个元素后面插入参数所指定的内容，作为其兄弟节点。形式有after(content[content,]),after(function()),这里的content内容有HTML字符串，DOM 元素，文本节点，元素和文本节点的数组，或者jQuery对象，用来插入到集合中每个匹配元素的后面 实例： 123456789101112131415 var orchildElems = $("&lt;div class='dcell'&gt;&lt;/div&gt;").append("&lt;img src='orchid.png'/&gt;") .append("&lt;label for='orchild'&gt;Orchild:&lt;/label&gt;") .append("&lt;input name='orchild' value='0' required&gt;"); //创建一个dcell内容 $("div.dcell").after(orchildElems); //插入元素作为兄弟元素，在当前元素的后面 $("#row1 div.dcell").after(function (index, html) &#123; //index表示索引，html表示原来的html文本，指的是没有插入之前的html console.log(html); if (index == 0)return orchildElem; //返回的可以是jquery对象，html文本 else if (index == 1) return newElems; &#125;);&#125;); before 根据参数设定，在匹配元素的前面插入内容,形式和after一样，内容也差不多 insertBefore 和prependTo的用法差不多，只是参数是要插入的目标位置，作为兄弟元素插入 实例： 1orchildElems.clone().insertBefore("#row2 div.dcell"); insertAfter 和append用法差不多，只是参数是要插入的目标位置，这里的也是作为兄弟元素插入的 实例： 1orchildElems.insertAfter("#row1 div.dcell"); wrap 在集合中匹配的每个元素周围包裹一个HTML结构，将会作为父元素存在。形式为wrap(html),wrap(jquery),wrap(HtmlElements[]),wrap(function()) 实例： 1234567891011 div=$("&lt;div&gt;&lt;/div&gt;").css("border",'thick double red'); $("div.drow").wrap(div); //在drow外层添加了一个div将作为父元素，可以看到现在的源代码变成了&lt;div style...&gt;&lt;div class='drow'&gt;...&lt;/div&gt;&lt;/div&gt; $(".drow").wrap(function (index) &#123; //index是索引 //if($(this).has("img[src*=astor]").length&gt;0) if(index==0) return div; //只在第一个drow中添加父元素div else return $("&lt;div&gt;&lt;/div&gt;").css("border",'thick double blue');&#125;) unwrap 将匹配元素集合的父级元素删除，保留自身（和兄弟元素，如果存在）在原来的位置。形式为unwrap(),unwrap(selector) 实例： 1234$("div.dcell").css("border",'thick double red'); $("div.dcell").children("img").first().unwrap(); //这里将第一个img元素的父级元素删除，并且保留了其中的子元素 $("div.dcell").children("img").unwrap(":first"); //这里使用参数来筛选要删除父级元素的当前元素，这里选择第一个元素 wrapAll 在集合中所有匹配元素的外面包裹一个HTML结构,也就是为结果集中的所有元素都设置了一个相同的父级元素来包裹所有的元素，形式为wrapAll(html),wrapAll(jquery),wrapAll(htmlElements[]),wrapAll(function()) 实例： 123var div = $("&lt;div&gt;&lt;/div&gt;").css("border", 'thick double red');$("div.drow").wrapAll(div); //这里的div成为了他共有的父级元素，原来的父级元素变成了祖先元素了$("img").wrapAll(div); //这里的img没有共同的父元素，那么就会强制的将所有的元素拉在一起为他们设置一个父级元素 wrapInner 在匹配元素里的内容外包一层结构,也就是为匹配元素的后代元素添加一个父级元素，但是这个父级元素是匹配元素的子代元素，也就是原来的匹配元素变成了祖先元素，形式为wrapInner(html),wrapInner(jquery),wrapInner(htmlElements),wrapInner(function()) 实例： 12var div = $("&lt;div&gt;&lt;/div&gt;").css("border", 'thick double red');$(".dcell").wrapInner(div); //这里的dcell元素将会变成祖先元素，而div将会变成内部后代元素新的父级元素 replaceWith 用提供的内容替换集合中所有匹配的元素并且返回被删除元素的集合,形式为replace(html),replaceWith(jquery),replaceWith(function()) 实例： 12345678910111213 var newElems = $("&lt;div class='dcell'&gt;&lt;/div&gt;").append("&lt;img src='lily.png'&gt;") .append("&lt;label for='lily'&gt;Lily&lt;/label&gt;").append("&lt;input name='lily' value='0' required&gt;").css("border", 'thick double blue');$(".dcell:first").replaceWith(newElems); //用newElems替换第一个dcell$("div.drow img").replaceWith(function () &#123; if (this.src.indexOf("rose") &gt; -1) return $("&lt;img src='lily.png'&gt;").css("border",'thick double red'); //返回的时替换的内容，可以是jquery或者html else if (this.src.indexOf("peony") &gt; -1) return newElems; else return $(this.clone()).css("border",'thick double blue');&#125;) replaceAll 用集合的匹配元素替换每个目标元素。.replaceAll()和.replaceWith()功能类似，但是目标和源相反 实例： 1$("&lt;img src='lily.png'&gt;").replaceAll("#row1 img"); //这里使用&lt;img src='lily.png'&gt;替换所有的img元素 remove 将匹配元素集合从DOM中删除,并且同时移除元素上的事件及 jQuery 数据 实例： 123$("div.dcell").remove(":has(img[src*=rose])"); //删除img$("div.dcell:first()").remove(); //不带参数 detach 从DOM中去掉所有匹配的元素,.detach() 方法和.remove()一样, 除了 .detach()保存所有jQuery数据和被移走的元素相关联。当需要移走一个元素，不久又将该元素插入DOM时，这种方法很有用。 实例： 123$("div.dcell").detach();$("div.dcell").detach(":has(img[src*=rose])"); empty 从DOM中移除集合中匹配元素的所有子节点。 1$(&quot;div.dcell:first&quot;).empty(); //删除所有的子节点 总结 append()和apppendTo()是将元素插入到指定元素的末尾作为其子元素的，其中append()的参数是新创建的节点，appendTo()的参数是将要插入到的元素 prepend()和prependTo() 是将元素插入到指定元素的最前面作为其子元素 after() 是在指定元素之后插入新建的节点，作为指定节点的第一个兄弟节点 ,参数是新建的节点 before() 是在指定元素之前插入新建的节点作为其兄弟节点，这个是紧挨着指定的元素的 insertAfter() 将新建元素插入到指定元素之后作为兄弟节点 参数是指定的元素 insertBefore() 将新建元素插入到指定元素之前作为兄弟节点 参数是指定的元素 remove() 删除所有匹配的元素 无参数 empty() 移除所有匹配元素的后代元素 无参数 参考文章 JQuery中文文档 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JQuery干货篇之选择元素]]></title>
      <url>%2F2017%2F04%2F20%2FJQuery%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B9%8B%E9%80%89%E6%8B%A9%E5%85%83%E7%B4%A0%2F</url>
      <content type="text"><![CDATA[JQuery 干货篇之选择元素实验的HTML+CSS的代码 html12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Example&lt;/title&gt; &lt;script src="jquery-3.2.1.min.js" type="text/javascript"&gt;&lt;/script&gt; &lt;link rel="stylesheet" type="text/css" href="main.css"/&gt; &lt;script src="main.js" type="text/javascript"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Jacqui's Flower Shop&lt;/h1&gt;&lt;form method="post"&gt; &lt;div id="oblock"&gt; &lt;div class="dtable"&gt; &lt;div id="row1" class="drow"&gt; &lt;div class="dcell"&gt; &lt;img src="astor.png"/&gt;&lt;label for="astor"&gt;Astor:&lt;/label&gt; &lt;input name="astor" value="0" required&gt; &lt;/div&gt; &lt;div class="dcell"&gt; &lt;img src="daffodil.png"/&gt;&lt;label for="daffodil"&gt;Daffodil:&lt;/label&gt; &lt;input name="daffodil" value="0" required&gt; &lt;/div&gt; &lt;div class="dcell"&gt; &lt;img src="rose.png"/&gt;&lt;label for="rose"&gt;Rose:&lt;/label&gt; &lt;input name="rose" value="0" required&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id="row2" class="drow"&gt; &lt;div class="dcell"&gt; &lt;img src="peony.png"/&gt;&lt;label for="peony"&gt;Peony:&lt;/label&gt; &lt;input name="peony" value="0" required&gt; &lt;/div&gt; &lt;div class="dcell"&gt; &lt;img src="primula.png"/&gt;&lt;label for="primula"&gt;Primula:&lt;/label&gt; &lt;input name="primula" value="0" required&gt; &lt;/div&gt; &lt;div class="dcell"&gt; &lt;img src="snowdrop.png"/&gt;&lt;label for="snowdrop"&gt;Snowdrop:&lt;/label&gt; &lt;input name="snowdrop" value="0" required&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id="buttonDiv"&gt; &lt;button type="submit"&gt;Place Order&lt;/button&gt; &lt;/div&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; css 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061h1 &#123; min-width: 70px; border: thick double black; margin-left: auto; margin-right: auto; text-align: center; font-size: x-large; padding: .5em; color: darkgreen; background-image: url("border.png"); background-size: contain; margin-top: 0;&#125;.dtable &#123; display: table;&#125;.drow &#123; display: table-row;&#125;.dcell &#123; display: table-cell; padding: 10px;&#125;.dcell &gt; * &#123; vertical-align: middle&#125;input &#123; width: 2em; text-align: right; border: thin solid black; padding: 2px;&#125;label &#123; width: 5em; padding-left: .5em; display: inline-block;&#125;#buttonDiv &#123; text-align: center;&#125;#oblock &#123; display: block; margin-left: auto; margin-right: auto; min-width: 700px;&#125;.hover&#123; background: blue; color: white; height:300px; width:300px;&#125; 选择器 :animated :选择正在处理动画的元素 :first :选择第一个元素 :last :选择最后一个元素 :eq(n) :选择第n个元素(从0开始) :even :选择序号为偶数的元素 :odd :选择序号为奇数的元素 :gt(n) :选择序号大于n的元素 :lt(n) :选择序号小于n的元素 :text :选择所有的文本输入框 :contains(text) :选择包含指定文本的元素 file :选择所有文件上传输入框 :button :选择所有的按钮 :checkbox :选择所有的复选框 :hidden :选择隐藏的元素 实例 $(&quot;img:odd&quot;).css(&quot;border&quot;,&quot;thick double red&quot;);选择序号为奇数的img元素$(&quot;img:first&quot;).css(&quot;border&quot;,&quot;thick double red&quot;) 选择第一个img元素 JQuery对象的方法 context 选择元素时使用的上下文对象 $(&quot;img:odd&quot;).context.TagName; each(function()) 在每个选中的元素上运行给定的函数 123 $("img").each(function(index,elem)&#123; console.log(ele.TagName+" "+elem.id);//这里的index表示每一个元素的索引，elem表示每一个元素的htmlElement对象，并不是jquery对象&#125;) index(jquery) || index(selector) 返回给定jquery对象在住对象中的序号，或者返回给定选择器参数的索引 $(&quot;img&quot;).index(&quot;img[src=*astor]&quot;) length || size() 返回的时jquery对象个数 $(&quot;img:odd&quot;).length toArray() 返回一个有jquery对象中包含的htmlEelments数组 var content=$(&quot;img:odd&quot;).toArray() 这里content返回的htmlElements数组 把jquery当成数组12345var content=$("img:odd");for(var i=0;i&lt;content.length;i++)&#123; console.log(content[i].TagName+" "+content[i].src); //这里的content[i]就是htmlElement数组了，$(content[i])就变成了Jquery对象了&#125; add add函数允许我们添加更多的项，常用的有add(htmlElement[]),add(selector),add(jquery) 实例： 1234567$("img:odd").add("img:even").css("border",'thick double red');var jq=$("img[src*=astor]");$("img:even").add(jq).add("img:even").css("border",'thick double red');var label=document.getElementsByTagName("label");$("img:odd").add(label).css("border","thick double red"); slice() 用来获取特定的一组子元素 实例： 123$("img").slice(0,3).css("border","thick double red"); //获取0-2的元素 $("img").slice(3).css("border","thick double red"); //获取3-结束 filter filter可以将不满足指定条件的元素剔除，常用的方法有filter(jquery),filter(htmlElement),filter(function(index)),filter(selector) 实例 1234567891011121314 //这里填入的参数selector$("label").filter("[for*=p]").css("background-color",'blue').css("font-size",'20px').css("border","2px solid red"); $("img").filter(function (index) &#123; //index是每一个元素的索引，如果返回的是true就会选定，false就会剔除这个元素 if(index==4) &#123; return true; &#125; else return false; &#125;).css("border",'thick double red'); var elem=document.getElementsByTagName("label")[1]; //只选择第二个label $("label").filter(elem).css("font-size",'30px') //这里填入的参数是htmlElement对象 not not方法是filter方法的补充，主要是删除匹配条件的元素，而filter则是保留满足匹配条件的元素，常用的方法有not(selector),not(htmlElement),not(jquery),not(function(index)) 实例： 123456789$("label").not("[for*=p]").css("background-color",'red'); //选择for不带p的label元素 $("label").not(function (index) &#123; //哪个元素返回true就删除，false保留 if(index==0) return true; //这里就会删除第一个label元素，保留后面的元素 else return false; &#125;).css("background-color","yellow"); has 选择拥有指定后代的选择器 实例：1234$("div.dcell").has("img[src*=astor]").css("border","thick double red"); //选择子代拥有img属性src带有astor的div.dcell元素var s=$("[for*=astor]");$("div.dcell").has(s).css("border","thick double red"); //参数为jquery对象 map 以一个函数为参数，map方法能够帮助我们灵活的处理一个jquery对象，从而得到满足需要的一个jquery对象。针对源jquery对象中的每一个元素都调用一次这个函数，而函数返回的HtmlElement对象将会变成一个jquery对象，参数是function(index,elem),其中`index是序号，elem是jquery对象中的每一个HTMLElelments对象，这里必须要有返回值，不然没有意义 实例： 12345678910$("div.dcell").map(function(index,elem)&#123; return elem.getElementsByTagName("img")[0]; //这里的elem是$(div.dcell)中的每一个HtmlElement对象，返回的是img元素&#125;).css("border",'thick double red'); //可以很清楚的看到这里返回的htmlElement对象变成了Jquery对象，因为调用了函数css$("img").map(function(index,elem)&#123; if(index==1) return elem; //返回的是第二个img的HtmlElement对象，但是经过map的包装就会变成jquery对象&#125;).css("border",'thick double red'); //可以很清楚的看到这里返回的htmlElement对象变成了Jquery对象，因为调用了函数css is is方法确定jquery对象中的某个或者某些元素是否满足测试条件，其中的形式有is(selector),is(HtmlElement),is(jquery),is(function(index))如果结果集中至少有一个元素匹配指定的条件，那么就返回true,否则false 实例：1234567891011console.log($("img").is("[src*=astor]"));//这里是判断img中的src属性有没有astor字段的，如果存在返回true$("img").is(function(index)&#123;&#125;)var c=$("img").is(function (index) &#123; //函数中如果至少有一个返回true，那么就会返回true，index是索引 return this.getAttribute('src')=='rose.png'; //判断属性 &#125;); console.log(c); end 当我们调用方法链来修改结果集的时候，jquery维护者一个历史结果集的查找，我们可以利用end回退到历史的结果集中,end用来扔掉当前的结果集，返回到上一层结果集 实例： 1234$("img").filter("[src*=astor]").end().css("border",'thick double red'); //这里回退到$("img")这个结果集中$("div.dcell").find("img").filter(":odd").filter(":eq(0)").end().end().css("border",'thick double red'); //这里调用了两个end将结果集回退到$("div.dcell").find("img")中 addBack 得到当前结果集和上一个结果集的合集 实例 123456$("div.dcell").children("img").addBack().css("border",'thick double red');//这里得到的是$("div.dcell")和$("div.dcell").children("img")的合集，并且应用css$("img").slice(0,3).filter("[src*=astor]").addBack().css("border",'thick double red');//$("img").slice(0,3)和$("img").slice(0,3).filter("[src*=astor]")的合集//这里的选择器参数过滤的是原结果集，相当于$("img").slice(0,3).filter("[src*=daff]")，$("img").slice(0,3).filter("[src*=astor]").addBack("[src*=daff]").css("border",'thick double red'); children children是用来访问子元素的，形式有childern(),children(selector),其中第一个是用来得到结果集中所有的子元素，第二个是用来过滤得到的子元素，保留满足selector的子元素 实例： 123$("div.dcell").children().css("border",'thick double red');//得到所有div.dcell的子元素，包括其中的img和input元素$("div.dcell").children("img").css("border",'thick double red');//得到所有子元素中的img元素 find find是用来得到结果集中的所有的后代元素，这里是后代元素，并不是只有子元素，还包括孙子。。。，形式有find(),find(selector),find(htmlElement),find(jquery),find(htmlElment[])，这里会自动去掉含有重复的元素，因此可以用来过滤元素 实例 1234$("div.dcell").find("img"); //找到div.dcell的后代元素imgvar content=document.getElementsByTagName("input");$("div.dcell").find(content).filter(":first").css("font-size",'1.5em');//找到div.dcell后代元素中的input元素 parent 选取结果集中的父元素，这里表示一层关系就是父元素，并不是祖先元素，形式有parent(),parent(selector) 实例：123$("img").parent(); //选取img的父元素$("img").parent(":first"); //选取img父元素中的第一个元素 parents 选取祖先元素，包括父元素，形式有parents(),parents(selector) 实例：123456$("img").parents().each(function(index,elem)&#123; //选取所有的祖先元素 console.log(elem.TagName+" "+elem.id);&#125;)$("img").parents("div.dcell").css("border",'thick double red'); //选择所有的div.dcell元素 parentsUntil 选择祖先元素，知道找到这个当前祖先元素匹配参数选择器为止,parentsUntil(selector),parentsUntil(selector,selector)，其中带有两个参数选择器中的第二个参数是用来筛选所得到的结果集，第一个是用来定位直到这个元素为止 实例： 123$("img").parentsUntil("div.drow");//找img的祖先元素，直到div.drow为止，不包括div.drow $("img").parentsUntil("div.drow",":first").css("border",'thick double red'); //这里选择了结果集中的第一个元素应用了样式 closest 得到结果集中元素的祖先元素中匹配selector选择器最接近的那个祖先元素，形式为closest(selector),closest(selctor,context),closest(htmlElemtent),closest(jquery) 实例： 12345678910$("img").closest("div.drow").each(function (index,elem) &#123; //选择满足div.drow的祖先元素，这里的最接近就是辈分最接近，这里的两个class=drow的div都是最接近的，因为这俩个是同级的关系 console.log(elem.tagName+" "+elem.id); &#125;); var jq=$("#row1,#row2,form"); //传入jquery对象 $("img").filter("[src*=astor]").closest(jq).each(function (index,elem) &#123; //这里选取的是最接近第一张图的祖先元素，当然是&lt;div id="row1"&gt; console.log(elem.tagName+" "+elem.id); &#125;) offestParent 得到距离最近的祖先定位元素，使用fixed,absolute,relative定位的元素，形式为offestParent() siblings 得到所有的兄弟元素，可选的selector用来过滤结果，形式为siblings(),siblings(selector) 实例： 123$("img").siblings().css("font-size",'1.4em');// 得到img的所有兄弟元素，这里是input$("img").siblings(":last"); //得到img所有兄弟元素中的最后一个元素 prev 得到上一个兄弟元素，形式为prev(),prev(selector)，其中的selector是用来过滤结果的 实例： 1$("input").prev().css("border",'thick double red'); //这里得到input的上一个元素Label元素 prevAll 得到当前元素的所有的上面的兄弟元素，形式为prevALl(),prevAll(selector) 实例： 123$("input").prevAll().css("border",'thick double red'); //得到input上面的所有的兄弟元素$("input").prev("img").css("border",'thick double red'); //得到input上面的所有的img元素 prevUntil 这个和parentsUntil一样，直到匹配selector就结束了，不包括 实例： 1$("input").prevUntil("i").css("border",'thick double red'); next 选择当前元素下面的一个兄弟元素，和prev一样 nextAll 选择当前元素下面的所有兄弟元素，和prevAll一样 nextUntil 和prevUntil一样 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java连接mysql初探篇]]></title>
      <url>%2F2017%2F04%2F16%2Fjava%E8%BF%9E%E6%8E%A5mysql%E5%88%9D%E6%8E%A2%E7%AF%87%2F</url>
      <content type="text"><![CDATA[java连接mysql基本连接 加载驱动: Class.forName(com.mysql.jdbc.Driver) 建立连接:Connection conn=DriverManager.getConnection(url,user,password) 其中url=&quot;jdbc:mysql://localhost:3306/java_demo&quot;,这里的java_demo是自己创建的数据库的名字,user是mysql数据库的管理员，password是密码下面直接连接数据库，返回的是接口Connection对象 1234567891011121314151617181920212223242526import java.sql.*;public static Connection getConnection()&#123; Connection conn; String driver="com.mysql.jdbc.Driver"; //驱动名称 String url="jdbc:mysql://localhost:3306/java_demo"; //url String user="root"; String password="root"; //管理员和密码都是root try&#123; Class.forName(driver); //加载驱动，但是会有ClassNotFoundException异常，因此要避免异常 try&#123; conn = Dri verManager.getConnection(url, user, password); //获得数据库连接 return conn; //返回conn &#125;catch(SQLException e) &#123; e.printStackTrace(); &#125; &#125;catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return null; //如果出现异常就会返回null &#125; 查询数据 **首先根据所得的Connection对象创建Statement对象：Statement statement = connection.createStatement(); 写查询语句：String sql=&quot;select * from student;&quot;这里是查询所有student中的数据，详细内容请看我的SQL干货篇二 创建ResultSet对象存储查询结果:ResultSet res=statement.executeQuery(sql),详细的内容请看官方文档ResultSet详细用法 代码1234567891011String sql="select * from student";if(!conn.isClosed())&#123; Statement statement=conn.createStatement(); //这里的conn是上面连接数据库的返回的Connection对象 ResultSet res=statement.executeQuery(sql); //执行查询，注意这里只能是executeQuery，Statement还有一些执行mysql函数，但是都不适合查询，后面会详细说 while(res.next()) //如果res结果中还有元素，那么返回true，否则返回的是false,用来判断是否res中还有结果 &#123; int id=res.getInt("id"); //得到id,这里的id是student表中的属性名 对应的时int BigInt smallint..... String name=res.getString("name"); //得到姓名，对应的是mysql中的Char varChar类型 &#125;&#125; 当然上面只是对于基本的查询数据，在一些项目中根本用不到，因为不太灵活，上面的方法只适合全局查询，并不适合在项目中根据条件查询，下面介绍预编译sql语句的接口PrepareStatement 首先编写sql语句:sql=&quot;select * from student where id=?;&quot;;,这里的?表示一个占位，将条件在后面给出，但是这里一定要用? 创建对象：PrepareStatement pre=conn.preparestatement(sql);这里传入参数sql 设置sql中的条件语句，填补占位?的值:pre.setInt(1,1);这里的SetInt设置id值的为1，因为这的id是int类型的，第一个参数是表示prepareindex，就是表示第一个占位?,当然第二个就是2,其中还有SetString(prepareindex String var),用来给定表中的char后者varchar类型的值 代码：1234567891011121314if(!connection.isClosed()) &#123; String sql="select * from course where id=?,name=?"; PreparedStatement preparedStatement=connection.prepareStatement(sql); preparedStatement.setInt(1,1); //给定条件中的值 prepareStatement.setString(2,"jack"); //为第二个？赋值 ResultSet res=preparedStatement.executeQuery(); //执行查询，返回的仍然是ResultSet对象 while(res.next()) &#123; int id=res.getInt("id"); String name=res.getString("name"); System.out.println(id+"--"+name); &#125; &#125; 插入数据 插入数据和上面的两种方法基本是一样的，不同的是mysql语句不同，还有的就是执行语句改成了executeUpdate(sql)，下面的代码值给出了预编译对象的方法，另外一种的方法使用范围并不是很大，只要把上面的查询改为executeUpdate即可 代码：1234567891011121314151617181920212223242526272829303132public static int save(MemoBean memo) &#123; String sql = "insert into student (username, title, content, momotype, memotime) values (?, ?, ?, ?, ?);"; Connection conn = getConnection(); PreparedStatement ps = null; try &#123; ps = conn.prepareStatement(sql); ps.setString(1, memo.getUsername()); //设值value中的值 ps.setString(2, memo.getTitle()); ps.setString(3, memo.getContent()); ps.setString(4, memo.getMemotype()); ps.setString(5, memo.getMemotime()); return ps.executeUpdate(); //这里使用的是excuteUpdate &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; if (ps != null) &#123; try &#123; ps.close(); //关闭预编译对象 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); //关闭Connection对象 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return -1; //没有插入成功返回-1 &#125; 更新数据 这里是同样的思路，和插入的基本是一样，只需要改变sql语句即可 代码：1234567891011121314151617181920212223242526272829303132333435363738public static int update(MemoBean memo) &#123; String sql = "update student set username=?,title=?,content=?,momotype=?,memotime=? where id=?;";//查询语句 Connection connection = getConnection(); PreparedStatement ps = null; try &#123; ps = connection.prepareStatement(sql); ps.setString(1, memo.getUsername()); //设置条件语句中的值 ps.setString(2, memo.getTitle()); ps.setString(3, memo.getContent()); ps.setString(4, memo.getMemotype()); ps.setString(5, memo.getMemotime()); ps.setInt(6,memo.getId()); return ps.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; if(ps!=null) &#123; try &#123; ps.close(); &#125;catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(connection!=null) &#123; try &#123; connection.close(); &#125;catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return -1; &#125; 最后说 上面的代码是从自己项目中截取的一部分代码，这个是比较适用于面向对象的，也是最常用的对于目前来看 上面只是给出了查询，插入，更新，因为这是最常用到的方法，其中还有创建表，删除表，当然还有一些他的，这里的创建表直接用execute(sql)即可执行，删除表也是用execute(sql)即可执行，当然如果要按照指定的条件删除，那么可以使用预编译对象执行 其中executeUpdate(sql)适用于create,insert,update,delete,但是executeQuery(sql)适用于select,具体见官方文档 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux干货篇一]]></title>
      <url>%2F2017%2F04%2F13%2FLinux%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B8%80%2F</url>
      <content type="text"><![CDATA[Linux干货篇一虚拟机的安装(VMware) 选择文件-&gt;新建虚拟机 选择自定义 设置安装来源，选择稍后安装 选择安装的操作系统，选择Linux,然后选择自己安装的对应版本即可 设置虚拟机的安装路径，自己选择 指定磁盘容量，选择默认20G,然后选择将虚拟磁盘存储为单个文件 设置cpu数量，内存大小，默认即可 设置Linux安装镜像文件路径 点击开启虚拟机即可根据对应的设置安装 目录文件 /boot:存放系统引导时所需要的文件，包括Linux内核以及引导程序(BootLoader) /bin:存放可执行程序 /etc:存放系统配置文件 /home:普通用户的主目录所在位置 /lib:存放基本的共享文件和内核模块 /mnt(mount):用户为需要挂载的文件系统提供挂载点 /proc(process):存放与内核进程有关的信息 /root:根用户的主目录 /tmp(temporary):存放临时性文件 /usr(user):存放可共享的只读文件 /var(variable):存放各类的数据文件 ls重要选项 -a(all) 列出目录中的所有项，包括”.”开头的隐藏文件 -l(list) 以列表的方式显示文件 -R(recursive) 用于递归列出子目录中的内容，如果在选择的目录下还有子文件夹，那么可以列出子文件夹中的文件 -d仅仅列出目录本身的信息实例 ls -al /etc 以列表的方式列出ect目录下的所有文件 pwd 显示当前路径cd(切换目录) cd .. 跳闸到当前目录的上一级 cd ~ 跳转到当前用户的主目录 例子 cd /tmp/testdir 跳转到tmp文件下的testdir目录 stat 获取关于某文件的基本信息，包括创建的信息，大小，时间。。。。 实例 stat test 查看test文件的基本信息 touch 创建或者更新一个文件的访问和修改的时间，如果一个文件存在，那么更新这个文件的创建时间，但是文件的内容不会改变，如果文件不存在，那么就会在当前目录下创建一个文件 实例 touch /tmp/testdir/test 在指定路径下创建一个test文件，如果存在那么会更新创建的时间，可以使用stat命令查看创建时间 mkdir(创建目录) mkdir /tmp/testdir/test_file 在/tmp/testdir目录下创建一个test_file文件夹 mv 移动或者重命名文件或目录 重要选项 b(backup):若存在同名文件，覆盖前先备份原来的文件 f(force):强制覆盖同名的文件 实例12345mkdir /tmp/testdir //创建一个目录testdirtouch test1 test2 //创建两个文件test1 test2mv -b test1 test2 //移动test1为test2,这里会先备份原来的test2为test2~mv -b test1 /tmp/testdir1/test //移动文件到指定目录下 cp(copy) 复制文件和目录 选项 -b: 若存在同名文件，覆盖前先备份 -f :强制覆盖同名文件 -r : 以递归的方式复制文件，就是复制文件夹，如果不使用这个，那么文件夹就无法复制 实例 cp /tmp/testdir tmp/testdir1 复制文件夹，这里表示不能复制，因此要加上-r选项才能复制文件夹 -&gt; cp -r /tmp/testdir /tmp/testdir1 可以复制，复制到/tmp文件夹下命名为testdir1 cp -b /tmp/testdir/test1 /tmp/testdir1/test 将文件test1复制到testdir1文件夹下命名为test rm 删除命令 选项 -f 强制删除 -r 删除文件夹（递归删除） 实例 rm -rf /tmp/testdir 强制删除testdir目录 rmdir 删除目录，但是要求目录必须是空的，这里实用性不大，一般用rm -r cat 查看文件内容 重要选项 -n 显示行数 实例 cat -n /tmp/testdir/test 查看文件test的内容，显示行数 more 分屏显示文件内容，首先显示一屏后如果还有内容，按回车键在显示下一行，按Space显示下一屏的内容 实例 more /tmp/testdir/test tail 显示文本文件结尾的部分，默认显示最后10行 重要选项 -n 指定显示的行数 head 显示开头的内容，与tail类似 wc 一次显示文本文件的行数，单词数，字节数 重要选项 -c 显示文件字节数 -l(line) 显示文件行数 -w(word) 显示文件单词数 实例 wc -cl /tmp/testdir/test 查看文件的字数和文件的行数 date查看或者修改系统命令 实例 date 查看系统时间 date 09012017 修改系统时间为2017-09-01 who列出当前系统的登录用户 重要选项 -r 显示系统当前的运行级 -q 显示当前所有登录的用户名称和在线人数 shutdown关闭重启系统 重要选项 -r(reboot) 重启系统 -h(halt) 关闭系统 -P(poweroff) 关闭系统同时关闭电源 注意上面选项均可给出数字参数指定多少分钟之后执行操作 实例 shutdown -h 10 设置10分钟后关闭系统 clear清楚当前终端的屏幕内容 man显示命令的使用手册，按上下键移动光标，Q键退出 实例 man cat 快速查询cat命令的手册 histroy查看shell命令的历史记录 实例 histroy 5 显示最近的5条记录 vim调用vim编辑器，按i键插入，w键保存，q键退出，wq保存后退出 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java干货篇之文字特效]]></title>
      <url>%2F2017%2F04%2F09%2Fjava%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B9%8B%E6%96%87%E5%AD%97%E7%89%B9%E6%95%88%2F</url>
      <content type="text"><![CDATA[java干货篇文字特效立体效果的文字主要使用了Graphics类中的setFont和setColor的方法，绘制多层字然后加上平移一个坐标即可实现多重叠加的效果,让人看起来就像是立体一样,详情请见源码 阴影效果的文字和面一样，只是平移的方式有些不同，详情请见源码 倾斜效果的文字主要使用的时Graphics2D类的shear方法，使绘图上下文倾斜，详情见源码public abstract void shear(double shx,double shy)其中shx表示在正x轴方向移动坐标的乘数，可以作为其y坐标的函数 渐变效果的文字主要使用了Graphics2D中的setPaint的方法,详情请见源码public abstract void setPaint(Paint paint)paint封装了渐变颜色的Paint对象其中Paint对象的创建是由GradientPaint初始化的,其中的构造函数如下：GradientPaint(float x1, float y1, Color color1, float x2, float y2, Color color2) 会变色的文字这个主要使用了多线程的方式实现的，用多线程改变Color方法中的RGB的值,用Random在指定范围内任意取值然后组成了不同的颜色，详情请见源码 水印文字特效(源码)水印文字主要通过改变了文字的透明度实现的，将文字绘制在图片上，然后改变图片的透明度，主要使用了Graphaics2D中的setComposite方法，定义如下：public abstract void setComposite(Composite comp)，其中Comp是AlphaComposite对象，可以使用以下两种方式创建 AlphaComposite alpha=AlphaComposite.getInstance(AlphaComposite.SRC_OVER,0.3f)获得一个SRC_OVER规则的对象 AlphaComposite alpha=AlphaComposite.SC_OVER.driver(0.3f)同上 动态绘制文本(源码)主要使用BufferedReader缓冲流从指定文件中读取一个字符，然后使用线程一个一个的绘制在画板上，中间sleep了400ms，这样就能展示出动态的效果，还使用了System类的getProperty方法获得项目的路径,以下提供了两种方法读取文件，更多的读取方法请看我的博客文章 BufferedReader read=new BufferedReader(new FileReader(pathname)) BufferedReader read=new BufferedReader(new InputStreamReader(in)) 由于都是比较简单的代码，这里不再贴出来le，有想要看的朋友，请点击上面的源码 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[swing干货系列之JTextField]]></title>
      <url>%2F2017%2F04%2F08%2FSwing%E5%B9%B2%E8%B4%A7%E7%B3%BB%E5%88%97%E4%B9%8BJTextField%2F</url>
      <content type="text"><![CDATA[Swing系列之JTextField(单行文本框)介绍 JTextField是一个轻量级组件，它允许编辑单行文本。 JTextField 具有建立字符串的方法，此字符串用作针对被激发的操作事件的命令字符串。java.awt.TextField 把字段文本用作针对 ActionEvent 的命令字符串。如果通过 setActionCommand 方法设置的命令字符串不为 null，则 JTextField 将使用该字符串来保持与 java.awt.TextField 的兼容性，否则将使用字段文本来保持兼容性。 setEchoChar 和 getEchoChar 方法不是直接提供的，以避免可插入的外观的新实现意外公开密码字符。为了提供类似密码的服务，单独的类 JPasswordField 扩展了 JTextField，从而通过可插入外观独立地提供此服务。 JTextField 的水平对齐方式可以设置为左对齐、前端对齐、居中对齐、右对齐或尾部对齐。右对齐/尾部对齐在所需的字段文本尺寸小于为它分配的尺寸时使用。这是由 setHorizontalAlignment 和 getHorizontalAlignment 方法确定的。默认情况下为前端对齐。 文本字段如何使用 VK_ENTER 事件取决于文本字段是否具有任何操作侦听器。如果具有操作侦听器，则 VK_ENTER 导致侦听器获取一个 ActionEvent，并使用 VK_ENTER 事件。这与 AWT 文本字段处理 VK_ENTER 事件的方式是兼容的。如果文本字段没有操作侦听器，则从 1.3 版本开始不使用 VK_ENTER 事件。而是处理祖先组件的绑定，这将启用 JFC/Swing 的默认按钮特性。 Swing 不是线程安全的 构造函数 JTextField() 构造一个新的 TextField JTextField(Document doc, String text, int columns) 构造一个新的 JTextField，它使用给定文本存储模型和给定的列数。 JTextField(int columns) 构造一个具有指定列数的新的空 TextField。 JTextField(String text)构造一个用指定文本初始化的新 TextField。 JTextField(String text, int columns) 构造一个用指定文本和列初始化的新 TextField。 常用的函数 get/setHorizontalAlignment(int alignment) 设置/得到文本的水平对齐方式。其中水平的对齐方式有：JTextField.LEFT JTextField.CENTER JTextField.RIGHT JTextField.LEADING (the default) JTextField.TRAILING setFont(Font font) 设置字体 setScrollOffset(int scrollOffset) 获取滚动偏移量（以像素为单位）。 setDocument(Document doc) 将编辑器与一个文本文档关联，这里的意思就是将此文本框与一个文本文档关联，这将会保持内容一致，如果一个改变了，另外一个也会改变。 setInputVerifier(verifier) 设置验证方式，如果此文本不能通过验证那么就不能将焦点聚焦到下一个组件上，就会一直聚焦到这个文本框上 setDragEnabled(boolean x) 设置在文本框中是否能够拖放文本,为true则是能够，这里的意思就是能够将文本选中后能不能将文本拖走 addActionListener(ActionListener action) 添加监听机制，输入文本按回车即可触发，和按钮的监听机制相同 write(InfileWriter writer) 将文本框中的内容输入到文件中 addKeyListener(KeyListener event) 添加键盘监听，在文本框中输入内容时会触发键盘，其中有按下，释放，键入的动作，详情见官方文档 addCaretListener(CareListener event) 添加一个侦听文本组件插入符的位置更改的侦听器，只要鼠标指针的位置改变就会触发 一个简单的实例1234567891011121314151617181920212223242526272829303132333435363738394041import javax.swing.*;import java.awt.*;class text extends JFrame &#123; private JTextField textField1; private JTextField textField2; public static void main(String args[]) &#123; text my = new text(); my.setVisible(true); &#125; public text() &#123; //this.setBounds(100,100,300,200); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JPanel panel = new JPanel(new GridLayout(2, 1)); textField1 = new JTextField(10); textField2 = new JTextField(); panel.add(textField1); panel.add(textField2); this.getContentPane().add(panel, BorderLayout.CENTER); this.pack(); InputVerifier verifier = new InputVerifier() &#123; //添加验证方式 @Override public boolean verify(JComponent input) &#123; //重载函数 boolean value; textField1 = (JTextField) input; //将input组件强制转化为JTextField类型的单行文本框 return textField1.getText().equals("pass"); //判断是否输入的时pass,如果不是就会验证错误 &#125; &#125;; textField1.setInputVerifier(verifier); //设置验证方式 textField1.setHorizontalAlignment(JTextField.CENTER); //设置水平对齐方式 Font font = new Font("楷体", Font.BOLD + Font.ITALIC, 20); textField1.setFont(font); //设置字体 textField1.setDragEnabled(true); //设置在单行文本框中能够拖放文本，如果为false则不能够拖放文本 &#125;&#125; 关联文本文档123456789101112131415161718192021222324252627282930313233343536import java.awt.Container;import java.awt.GridLayout;/*from w ww.jav a 2s . co m*/import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JTextField;import javax.swing.text.Document;public class Main extends JFrame &#123; JLabel nameLabel = new JLabel("Name:"); JLabel mirroredNameLabel = new JLabel("Mirrored:"); JTextField name = new JTextField(20); JTextField mirroredName = new JTextField(20); public Main() &#123; this.setDefaultCloseOperation(EXIT_ON_CLOSE); this.setLayout(new GridLayout(2, 0)); Container contentPane = this.getContentPane(); contentPane.add(nameLabel); contentPane.add(name); contentPane.add(mirroredNameLabel); contentPane.add(mirroredName); Document nameModel = name.getDocument(); //得到文本框的文本文档，将之与第二个文本框关联 mirroredName.setDocument(nameModel); //两个文本框中的内容相互关联，这样只需要在一个里面输入文本，同时也会在另外一个文本框中显示 pack(); setVisible(true); &#125; public static void main(String[] args) &#123; Main frame = new Main(); &#125;&#125; 说明：这里是将两个文本框相关联，这样就能达到一个文本框输入的同时，另外一个也会同时更新内容 Action Listener(动作监听机制)输入文本后按回车即可触发123456789101112131415161718192021222324252627import java.awt.event.ActionEvent;//from w w w. ja va2s .c o mimport javax.swing.JFrame;import javax.swing.JTextField;public class Main &#123; public static void main(String[] a) &#123; JFrame frame = new JFrame(); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JTextField jTextField1 = new JTextField(); jTextField1.setText("jTextField1"); //添加监听机制 jTextField1.addActionListener(new java.awt.event.ActionListener() &#123; public void actionPerformed(ActionEvent e) &#123; System.out.println("action"); &#125; &#125;); frame.add(jTextField1); frame.setSize(300, 200); frame.setVisible(true); &#125;&#125; 验证文本内容使用InputVerifier)验证 12345678910111213141516171819202122232425262728293031import java.awt.BorderLayout;import javax.swing.InputVerifier;import javax.swing.JComponent;import javax.swing.JFrame;import javax.swing.JTextField;public class Main &#123; public static void main(String args[]) &#123; JFrame frame = new JFrame("Verifier Sample"); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JTextField textField1 = new JTextField(); JTextField textField2 = new JTextField(); InputVerifier verifier = new InputVerifier() &#123; //创建一个验证 public boolean verify(JComponent comp) &#123; boolean returnValue; JTextField textField = (JTextField) comp; //强制转换，将控件类型的comp转换成JTextFiled类型的 try &#123; Integer.parseInt(textField.getText()); //将输入的内容转化程int类型，如果输入的字符串不是十进制的话就会触发 //NumberFormateException错误 returnValue = true; &#125; catch (NumberFormatException e) &#123; returnValue = false; &#125; return returnValue; //如果返回false的话，那么指针就会一直聚焦在此文本框中，不能移动到其他的组件上 &#125; &#125;; textField1.setInputVerifier(verifier); frame.add(textField1, BorderLayout.NORTH); frame.add(textField2, BorderLayout.CENTER); frame.setSize(300, 100); frame.setVisible(true); &#125;&#125; 说明：如果返回false的话，那么指针就会一直聚焦在此文本框中，不能移动到其他的组件上 将文本框中的内容保存到文件中12345678910111213141516171819202122232425262728293031323334353637383940414243444546import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.io.File;import java.io.FileWriter;import java.io.IOException;class Main extends JFrame &#123; private JTextField textField; private FileWriter writer; public static void main(String args[]) &#123; Main my = new Main(); my.setVisible(true); &#125; public Main() &#123; this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JPanel panel = new JPanel(new BorderLayout()); JButton button = new JButton("运行"); JLabel label = new JLabel("name"); textField = new JTextField(); panel.add(label, BorderLayout.WEST); panel.add(textField, BorderLayout.CENTER); String filename = "text.txt"; button.addActionListener(new ActionListener() &#123; //添加一个按钮触发装置，这里只要点击一下anniu就会将文本框中的内容输入到文件中 @Override public void actionPerformed(ActionEvent e) &#123; try &#123; writer = new FileWriter(filename, false); //创建一个写入文件的对象，这里的false表示不在文件的末尾添加 textField.write(writer); //将单行文本中输入的内容写入到文件中 writer.close(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); System.out.println("false"); &#125; &#125; &#125;); panel.add(button, BorderLayout.SOUTH); this.getContentPane().add(panel, BorderLayout.CENTER); this.pack(); &#125;&#125; 说明：这里使用的是FileWriter类将内容写入到文件中，详情请看我的上一篇文章 复制、粘贴、剪切文本 这里使用的时copy()、paste()、cut()函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.awt.FlowLayout;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JTextField;import javax.swing.event.CaretEvent;import javax.swing.event.CaretListener;public class Main &#123; public static void main(String args[]) &#123; final JTextField textField = new JTextField(15); JButton buttonCut = new JButton("Cut"); JButton buttonPaste = new JButton("Paste"); JButton buttonCopy = new JButton("Copy"); JFrame jfrm = new JFrame("Cut, Copy, and Paste"); jfrm.setLayout(new FlowLayout()); jfrm.setSize(230, 150); jfrm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); buttonCut.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent le) &#123; textField.cut(); &#125; &#125;); buttonPaste.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent le) &#123; textField.paste(); &#125; &#125;); buttonCopy.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent le) &#123; textField.copy(); &#125; &#125;); textField.addCaretListener(new CaretListener() &#123; public void caretUpdate(CaretEvent ce) &#123; System.out.println("All text: " + textField.getText()); if (textField.getSelectedText() != null) System.out.println("Selected text: " + textField.getSelectedText()); else System.out.println("Selected text: "); &#125; &#125;); jfrm.add(textField); jfrm.add(buttonCut); jfrm.add(buttonPaste); jfrm.add(buttonCopy); jfrm.setVisible(true); &#125;&#125; 说明：这里使用的时用三个按钮监听操作，只需要按住对应的按钮就会触发机制 添加键盘监听机制12345678910111213141516171819202122232425262728293031323334353637383940import java.awt.Dimension;import java.awt.FlowLayout;import java.awt.HeadlessException;import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JTextField;public class Main extends JFrame &#123; public Main() throws HeadlessException &#123; setSize(200, 200); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setLayout(new FlowLayout(FlowLayout.LEFT)); JLabel usernameLabel = new JLabel("Username: "); JTextField usernameTextField = new JTextField(); usernameTextField.setPreferredSize(new Dimension(100, 20)); add(usernameLabel); add(usernameTextField); usernameTextField.addKeyListener(new KeyAdapter() &#123; //创建机制 public void keyReleased(KeyEvent e) &#123; //重载函数，释放按键触发 JTextField textField = (JTextField) e.getSource(); //得到最初发生event的组件对象,既是文本框对象 String text = textField.getText(); textField.setText(text.toUpperCase()); //将所有的小写字母转换成大写字母 &#125; public void keyTyped(KeyEvent e) &#123; //键入时触发 &#125; public void keyPressed(KeyEvent e) &#123; //释放按键时触发的函数 &#125; &#125;); &#125; public static void main(String[] args) &#123; new Main().setVisible(true); &#125;&#125; 添加插入符位置变化的监听机制使用的是CareListener类来实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.zzk;import java.awt.BorderLayout;import java.awt.Color;import java.awt.Font;import java.awt.Graphics;import java.awt.Graphics2D;import javax.swing.JFrame;import javax.swing.JPanel;import javax.swing.JTextField;import javax.swing.event.CaretEvent;import javax.swing.event.CaretListener;public class ClockwiseTextFrame extends JFrame &#123; private JTextField textField; ClockwiseTextPanel clockwiseTextPanel = new ClockwiseTextPanel(); // 创建面板类的实例 public static void main(String args[]) &#123; // 主方法 ClockwiseTextFrame frame = new ClockwiseTextFrame(); // 创建窗体类的实例 frame.setVisible(true); // 显示窗体 &#125; public ClockwiseTextFrame() &#123; super(); // 调用超类的构造方法 setTitle("顺时针旋转文字"); // 窗体标题 setBounds(100, 100, 340, 240); // 窗体的显示位置和大小 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 窗体关闭方式 add(clockwiseTextPanel); // 将面板类的实例添加到窗体容器中 textField = new JTextField(); textField.addCaretListener(new CaretListener() &#123; public void caretUpdate(CaretEvent arg0) &#123; String text = textField.getText();// 获取文本框字符串 clockwiseTextPanel.setText(text);// 为面板中的text变量赋值 &#125; &#125;); getContentPane().add(textField, BorderLayout.SOUTH); &#125; class ClockwiseTextPanel extends JPanel &#123; // 创建内部面板类 private String text; public ClockwiseTextPanel() &#123; setOpaque(false);// 设置面板为透明 setLayout(null);// 设置为绝对布局 &#125; public String getText() &#123; return text; // 获得成员变量的值 &#125; public void setText(String text) &#123; this.text = text;// 为成员变量赋值 repaint();// 调整paint()方法 &#125; public void paint(Graphics g) &#123;// 重写paint()方法 Graphics2D g2 = (Graphics2D) g;// 获得Graphics2D的实例 int width = getWidth();// 获得面板的宽度 int height = getHeight();// 获得面板的高度 if (text != null) &#123; char[] array = text.toCharArray();// 将文本转换为字符数组 int len = array.length * 5;// 定义圆的半径，同时可以调整文字的距离 Font font = new Font("宋体", Font.BOLD, 22);// 创建字体 g2.setFont(font);// 设置字体 double angle = 0;// 定义初始角度 for (int i = 0; i &lt; array.length; i++) &#123;// 遍历字符串中的字符 if (i == 0) &#123; g2.setColor(Color.BLUE);// 第一个字符用蓝色 &#125; else &#123; g2.setColor(Color.BLACK);// 其他字符用黑色 &#125; int x = (int) (len * Math.sin(Math.toRadians(angle + 270)));// 计算每个文字的横坐标位置 int y = (int) (len * Math.cos(Math.toRadians(angle + 270)));// 计算每个文字的纵坐标位置 g2.drawString(array[i] + "", width / 2 + x, height / 2 - y);// 绘制字符 angle = angle + 360d / array.length;// 改变角度 &#125; &#125; &#125; &#125;&#125; 参考文档 官方网站) 英文文档 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[scrapy爬取豆瓣全站]]></title>
      <url>%2F2017%2F04%2F08%2Fscrapy%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E5%85%A8%E7%AB%99%2F</url>
      <content type="text"><![CDATA[Scrapy爬取豆瓣读书全站分析网页 首先打开豆瓣读书中的分类浏览，可以看到其中有很多的分类 豆瓣应该是一个比较好爬的网站，所有的数据都不是ajax加载的，我们打开谷歌的F12或者是火狐的FireBug可以很轻松的找到每一个分类的链接 这里我们使用scrapy中的一个linkextractors库,这个库的作用是会根据提供的限制，自动爬取和深入每一个页面并且提取需要的链接，如果想要找到每一个分类的url,只需Rule(LinkExtractor(allow=&#39;/tag/&#39;,restrict_xpaths=&quot;//div[@class=&#39;article&#39;]&quot;),follow=True),这里的allow是一个正则表达式，用来筛选分类url,restrict_xpaths是限制在哪个结构中筛选url,这里限制的是在&lt;div class=&#39;article&#39;&gt;这个盒模型中，follow表示是否深入，这里当然是要深入,这里就能得到每一个分类url了，自己可以在回调函数中测试下，输入所得的url,可以使用respose.url 得到所有的分类url，就可以继续深入到每一步作品所在的页面了，如下图! 但是我们需要不止是这一页，我们要爬的时全站，因此这里必须实现翻页，我们可以看到页面底部清楚的写着下一页，我们通过解析页面同样可以得到url,如下图所示 可以看到所有的url的规则，我们就可以用正则表达式限制，以获取我们的需要，我们可以写出翻页的代码 1Rule(LinkExtractor(allow="\?start=\d+\&amp;type=",restrict_xpaths="//div[@class='pa&gt;ginator']"),follow=True), 最后一步就是打开每一部书的网页得到所需的信息了，我们就可以通过这里通过解析网页还是可以很清楚的知道url,这里就不再详细的说怎么解析了，这里可以看到所有的url都在li标签中，如下图 我们打开li标签可以很清楚的看大url的规律，因此这里还是用到上面说的库解析深入，连同上面的代码如下 123Rule(LinkExtractor(allow='/tag/',restrict_xpaths="/ /div[@class='article']"),follow=True),#第一步Rule(LinkExtractor(allow="\?start=\d+\&amp;type=",restrict_xpaths="//div[@class='pa&gt;ginator']"),follow=True), #第二步翻翻页Rule(LinkExtractor(allow="/subject/\d+/$",restrict_&gt;xpaths="//ul[@class='subject-list']"),callback='parse_item')#得到所需网页的url 到了这里总算是大功告成了，下面就需要解析自己的所需要的信息了,这里附上网页 下面就是写自己解析代码了，这里就不需要详细的说了，详细内容请看源码,值得注意的是爬取的网页速度不要太快，豆瓣会禁IP的，这里可以采用一些反爬虫措施,如请求头的更换，ip地址的更换，下一篇会详细解说。 参考文档： scrapy中文文档 最后附上本人的github地址,不要忘了给个star哦 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[swing布局管理器]]></title>
      <url>%2F2017%2F04%2F05%2Fjava%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8%2F</url>
      <content type="text"><![CDATA[Swing系列之布局管理器流布局(FlowLayout)默认的JApplet,JPanel,JScrollPane 流布局是相对比较简单的一种布局管理器，也是最常用的布局管理器。在流布局中放置控件时，将按照控件的添加顺序，依次将控件从左到右进行摆放，并且在一行的最后会进行自动换行放置 。在一行中，控件是默认居中放置的。 布局管理器也是通过构造器来创建的。流布局是通过FlowLayout 类来创建，FlowLayout类具有三种构造器。首先是无参构造器， 使用无参构造器能够创建一个默认的以居中对齐方式，控件间水 平和垂直间距为5个像素的流布局。 FlowLayout类还具有一个需要整型参数的构造器，使用该构造器能够创建一个指定对齐方式的流布局管理器，它的控件间水平和垂直间距仍然是默认的5个像素。流布局管理器的对齐方式如下所示。 LEFT 左对齐方式 CENTER 居中对齐方式 RIGHT 右对齐方式 LEADING 控件与容器开始边对齐 TRAILING 构造函数： FlowLayout(),生成一个默认的FlowLayout布局。默认情况下，组件居中，间隙为5个像素。 FlowLayout(int aligment),设定每珩的组件的对齐方式。alignment取值可以为FlowLayout.LEFT,FlowLayout.CENTER,FlowLayout.RIGHT。 FlowLayout(int aligment,int horz, int vert),设定对齐方式，并设定组件的水平间距horz和垂直间距vert，用超类Container的方法setLayout()为容器设定布局。例如，代码setLayout(new FlowLayout())为容器设定 FlowLayout布局。将组件加入容器的方法是add(组件名)。 常用的函数：getAlignment方法和setAlignment方法分别获取和设置流布局管理器的对齐方式。 getHgap方法和setHgap方法分别获取和设置流布局管理器中控件和控件之间的水平间距。getVgap方法和setVgap方法分别获取和 设置流布局管理器中控件和控件之间的垂直间距。12345678910111213141516171819202122232425262728293031import javax.swing.*;import java.awt.*;/** * Created by Chenjiabing on 2017/4/5. */public class BuJu &#123; public static void main(String args[]) &#123; JFrame frame=new JFrame(); FlowLayout flowLayout=new FlowLayout(FlowLayout.LEFT); JPanel panel=new JPanel(flowLayout); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setBounds(100,100,500,400); flowLayout.setHgap(20); //设置水平间距 flowLayout.setVgap(20); //控件之间的垂直间距 for(int i=0;i&lt;6;i++) &#123; JButton button=new JButton("按钮"); panel.add(button); &#125; frame.getContentPane().add(panel); frame.setVisible(true); &#125;&#125; 网格布局(GridLayout) 网络布局也是一种比较常见的布局管理器。使用网格布局管理器后，会将所有的控件尽量按照给出的行数和列数来排列，同时网格布局管理器也会对控件进行尺寸的调整，使所有的控件具有相同的尺寸。在网格布局中，也会尽量使使用的空间成矩形的形式来显示。当窗体发生大小变化时，所有的空间也将自动改变大小来填充窗体。 网格布局是通过GridLayout类来创建的。GridLayout类具有三个构造器，使用无参构造器将创建具有默认行和默认列的网格布局。在创建网格布局管理器时最常用的就是具有两个整型参数的构造器，第一个参数表示网格布局管理器的行数，第二个参数表示网格布局管理器的列数。还有一个具有四个参数的构造器，除了可以定义行数和列数外，还可以定义控件间水平间距和垂直间距。 GridLayout类中还定义了一些方法来对创建的网格布局进行操作 。getRows方法和setRows方法分别是获取和设置网格布局的行数。getColumns方法和setColumns方法分别是获取和设置网格布局 的列数。getHgap方法和setHgap方法分别是获取和设置网格布局 中控件间水平间距。getVgap方法和setVgap方法分别是获取和设 置网络布局中的控件间垂直间距。 构造函数： GridLayout(),生成一个单列的GridLayout布局。默认情况下，无间隙。1.GridLayout(int row,int col),设定一个有行row和列`col的GridLayout布局。 GridLayout(int row,int col,int horz,int vert),设定布局的行数和列数、组件的水平间距和垂直间距 代码大概和上面的设置一样，这里注意的是，网格布局是以行为基准的，如果定义的控件多了或者少了，不会改变行的数量，会根据情况改变列的数量 边框布局(BorderLayout)默认的是JWindow、JFrame,JDialog 上面学习的流布局和网格布局具有很多相似的地方，但是边框布局就和他们存在很大的不同。在使用边框布局时，通常都会由程序员来为控件指定在容器中的位置。边框布局将容器分为五个部分，包括东南西北中五部分。在每一个部分中只能放置一个控件 ，所以如果控件超过五个将不能完全显示。在使用边框布局时需 要注意的是，当容器的大小发生变化时，四周的控件是不会发生变化的，只有中间的控件将发生变化。 边框布局是通过BorderLayout类创建的。BorderLayout类具有两个构造器，一个是无参构造器，另一个是指定控件间间距的构造器，通常使用无参构造器来创建边框布局管理器。 在前面将控件添加到容器中都是通过add方法，将控件作为add方法的参 数来进行添加的。但是在向边框布局容器中添加控件时，这样是不完全 的。在向边框布局容器中添加控件是使用具有两个参数的add方法。其中 第一个参数表示要添加的控件，第二个参数表示要添加到边框布局中的 哪一个位置。边框布局的位置表示是通过常量来表示的，具体常量如下所示 NORTH 容器顶部 SOUTH 容器底部 WEST 容器左边 EAST 容器右边 CENTER 容器的中央 构造函数： BorderLayout(),生成一个默认的BorderLayout布局。默认情况下，没有间隙。 BorderLayout(int horz,int vert),设定组件之间的水平间距和垂直间距。 注意这里还有一些常用的方法，就是设置水平和垂直的间距，上面已经赘述过了，这里就不再详说了 空布局(null) 空布局就是没有使用布局管理器，在空布局的情况下将根据控件的自身信息来为控件指定位置。这就使得控件的布局更加灵活，与此同时给开发人员带来了更大的工作量。 空布局是不需要使用类来创建的，只需要在程序指定布局管理器 为null。将控件添加到空布局容器中时，仍然是使用add方法。因 为这里使用的是空布局管理器，所以在添加控件之前，要对控件 进行设置操作。设置操作是通过setBounds方法来完成的， setBounds方法的基本语法格式如下所示。 public void setBounds(int x,int y,int width,int height); 其中x和y表示的是控件最左上侧的坐标，从而也固定了该控件的 位置。width和height表示的是空间的宽度和高度，从而也指定了控件的大小。 示例代码：1234567&gt;frame.setLayout(null);//布局管理器设置为null JLabel label = new JLabel("First Name:"); label.setBounds(20, 20, 100, 20);//四个参数分别是x,y坐标和label的宽和高 JTextField textField = new JTextField(); textField.setBounds(124, 25, 100, 20); frame.add(label); frame.add(textField); BoxLayout BoxLayout是一种能够实现所有的控件水平放置和垂直放置，因为用到的不多，这里就简单的说一下构造函数：public BoxLayout(Container target,int axis):其中axis表示放置的样式，主要有两种常用到的: X_AXIS:指定组件应该从左到右放置。 Y_AXIS：指定组件从上到下放置 代码 12345678910111213141516171819202122232425262728import oracle.jrockit.jfr.JFR;import javax.swing.*;import java.awt.*;public class BuJu &#123; public static void main(String args[]) &#123; JFrame frame = new JFrame(); // frame.setLayout(new BorderLayout(frame.getComponentCount(),BoxLayout.Y_AXIS)); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JPanel panel = new JPanel(); BoxLayout boxLayout = new BoxLayout(panel, BoxLayout.X_AXIS); panel.setLayout(boxLayout); for (int i = 0; i &lt; 10; i++) &#123; JButton button = new JButton("cma"); panel.add(button); &#125; frame.getContentPane().add(panel, BorderLayout.CENTER); // System.out.println(boxLayout.getTarget()); frame.pack(); //frame.setSize(300,200); frame.setVisible(true); &#125;&#125; 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java图像处理干货篇一]]></title>
      <url>%2F2017%2F04%2F04%2Fjava%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%B9%B2%E8%B4%A7%E7%AF%87%2F</url>
      <content type="text"><![CDATA[java图像处理干货篇绘制图像 绘制图像主要用到的是Graphics类中drawImage方法，当然Graphics2D中也有相应的方法 主要的用法： public abstract boolean drawImage(Image img,x,y,ImageObserver observer):img是Image对象，x,y起始坐标,observer是观察对象 drawImage(Image img,int x,int y,int width,int height,Imageobersver observer):width和height是指定图像的宽度和高度，主要的作用是放大和缩小图像 drawImage(Image img,int dx1,int dy1,int dx2,int dx2,int sx1,int sy1,int sx2,int sy2,ImageObserver observer):主要用来翻转图形,通过互换源矩形的第一个和第二个角的x坐标可以实现水平翻转，通过互换源矩形的第一个和第二个角的y坐标可以实现垂直翻转 翻转图像12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.zzk;import java.awt.BorderLayout;import java.awt.Graphics;import java.awt.Image;import java.awt.Toolkit;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.net.URL;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JPanel;public class PartImageFrame extends JFrame &#123; private Image img = null; // 声明图像对象 private PartImagePanel imagePanel = null; // 声明图像面板对象 private int dx1, dy1, dx2, dy2; // 目标矩形第一个角与第二个角的X、Y坐标 private int sx1, sy1, sx2, sy2; // 源矩形第一个角与第二个角的X、Y坐标 public static void main(String args[]) &#123; PartImageFrame frame = new PartImageFrame(); frame.setVisible(true); &#125; public PartImageFrame() &#123; super(); URL imgUrl = PartImageFrame.class.getResource("/img/image.jpg");// 获取图片资源的路径 img = Toolkit.getDefaultToolkit().getImage(imgUrl); // 获取图像资源 dx2 = sx2 = 340; // 初始化图像大小 dy2 = sy2 = 200; // 初始化图像大小 imagePanel = new PartImagePanel(); // 创建图像面板对象 this.setBounds(200, 160, 355, 276); // 设置窗体大小和位置 this.add(imagePanel); // 在窗体中部位置添加图像面板对象 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置窗体关闭模式 this.setTitle("翻转图像"); // 设置窗体标题 final JPanel panel = new JPanel(); getContentPane().add(panel, BorderLayout.SOUTH); final JButton btn_h = new JButton(); btn_h.addActionListener(new ActionListener() &#123; public void actionPerformed(final ActionEvent e) &#123; // 下面3行代码用于交换sx1和sx2的值 int x = sx1; sx1 = sx2; sx2 = x; imagePanel.repaint(); // 重新调用面板类的paint()方法 &#125; &#125;); btn_h.setText("水平翻转"); panel.add(btn_h); final JButton btn_v = new JButton(); btn_v.addActionListener(new ActionListener() &#123; public void actionPerformed(final ActionEvent e) &#123; // 下面3行代码用于交换sy1和sy2的值 int y = sy1; sy1 = sy2; sy2 = y; imagePanel.repaint();// 重新调用面板类的paint()方法 &#125; &#125;); btn_v.setText("垂直翻转"); panel.add(btn_v); &#125; // 创建面板类 class PartImagePanel extends JPanel &#123; public void paint(Graphics g) &#123; g.clearRect(0, 0, this.getWidth(), this.getHeight());// 清除绘图上下文的内容 g.drawImage(img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, this);// 绘制图像 &#125; &#125;&#125; 旋转图像 主要用到的是Graphics2D类中的rotate函数，定义如下:public abstract void rotate(double theta): theta是角度，以弧度为单位代码如下 123456789101112131415161718192021222324252627282930package com.zzk;import java.awt.*;import java.net.URL;import javax.swing.*;public class RotateImageFrame extends JFrame &#123; private Image img = null; private RotatePanel rotatePanel = null; public RotateImageFrame() &#123; URL imgUrl = RotateImageFrame.class.getResource(&quot;/img/image.jpg&quot;);// 获取图片资源的路径 img = Toolkit.getDefaultToolkit().getImage(imgUrl); // 获取图片资源 rotatePanel = new RotatePanel(); // 创建旋转图像的面板对象 this.setBounds(150, 120, 380, 310); // 设置窗体大小和位置 add(rotatePanel);// 在窗体上放置图像面板 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置窗体关闭模式 this.setTitle(&quot;旋转图像&quot;); // 设置窗体标题 &#125; public static void main(String[] args) &#123; new RotateImageFrame().setVisible(true); &#125; class RotatePanel extends JPanel &#123; public void paint(Graphics g) &#123; Graphics2D g2 = (Graphics2D) g; // 获得Graphics2D对象 g2.drawImage(img, 80, 10, 260, 150, this); // 绘制指定大小的图片 g2.rotate(Math.toRadians(10)); // 将图片旋转10度 g2.drawImage(img, 80, 10, 260, 150, this); // 绘制指定大小的图片 g2.rotate(Math.toRadians(10)); // 将图片旋转10度 g2.drawImage(img, 80, 10, 260, 150, this); // 绘制指定大小的图片 &#125; &#125;&#125; 倾斜图像 主要用到的是Graphics2D中的shear函数定义如：public abstract void shear(doubel shx,double shy):shx是在正x轴上移动坐标的乘数，它可以作为其纵坐标的值,shy是在正y轴方形移动坐标的乘数，它可以作为其x坐标的函数。本人的理解：倾斜画布，如果shx&gt;0就是向正方向平移，平移的长度为shx*height(图形纵坐标的值，如果是矩形就是乘以矩形的高)相同的对于shy是乘以矩形宽123456789101112131415161718192021222324252627package com.zzk;import java.awt.*;import java.net.URL;import javax.swing.*;public class ShearImageFrame extends JFrame &#123; private Image img; private ShearImagePanel canvasPanel = null; public ShearImageFrame() &#123; URL imgUrl = ShearImageFrame.class.getResource("/img/image.jpg");// 获取图片资源的路径 img = Toolkit.getDefaultToolkit().getImage(imgUrl); // 获取图片资源 canvasPanel = new ShearImagePanel(); // 创建绘制倾斜图像的面板对象 this.setBounds(100, 100, 360, 240); // 设置窗体大小和位置 add(canvasPanel);// 在窗体上添加面板对象 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置窗体关闭模式 this.setTitle("倾斜图像"); // 设置窗体标题 &#125; public static void main(String[] args) &#123; new ShearImageFrame().setVisible(true); &#125; class ShearImagePanel extends JPanel &#123;// 绘制倾斜图像的面板类 public void paint(Graphics g) &#123; Graphics2D g2=(Graphics2D) g;// 获得Graphics2D对象 g2.shear(0, -0.5);// 倾斜图像 g2.drawImage(img, 10, 20, 220, 160, this); // 绘制指定大小的图片 &#125; &#125;&#125; 裁剪图片 public BufferedImage createScreenCapture(Rectangle screenRect):返回的是一个BufferedImage对象，参数是Rectangle对象，这个函数是Robot类中的，主要用于裁剪图形 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package com.zzk;import java.awt.AWTException;import java.awt.BasicStroke;import java.awt.BorderLayout;import java.awt.Color;import java.awt.Graphics;import java.awt.Graphics2D;import java.awt.Image;import java.awt.Rectangle;import java.awt.Robot;import java.awt.Toolkit;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import java.awt.event.MouseMotionAdapter;import java.awt.image.BufferedImage;import java.net.URL;import javax.swing.JFrame;import javax.swing.JPanel;import javax.swing.JSplitPane;public class CutImageFrame extends JFrame &#123; private Image img = null; // 声明图像对象 private OldImagePanel oldImagePanel = null; // 声明图像面板对象 private int pressPanelX = 0, pressPanelY = 0;// 鼠标按下点的X、Y坐标 private int pressX = 0, pressY = 0;// 鼠标按下点在屏幕上的X、Y坐标 private int releaseX = 0, releaseY = 0;// 鼠标释放点在屏幕上的X、Y坐标 private Robot robot = null; // 声明Robot对象 private BufferedImage buffImage = null; // 声明缓冲图像对象 private CutImagePanel cutImagePanel = new CutImagePanel(); // 创建绘制裁剪结果的面板 private boolean flag = false; // 声明标记变量，为true时显示选择区域的矩形，否则不显示 public static void main(String args[]) &#123; CutImageFrame frame = new CutImageFrame(); frame.setVisible(true); &#125; public CutImageFrame() &#123; super(); URL imgUrl = CutImageFrame.class.getResource("/img/image.jpg");// 获取图片资源的路径 img = Toolkit.getDefaultToolkit().getImage(imgUrl); // 获取图像资源 oldImagePanel = new OldImagePanel(); // 创建图像面板对象 this.setBounds(200, 160, 355, 276); // 设置窗体大小和位置 final JSplitPane splitPane = new JSplitPane(); splitPane.setDividerLocation((this.getWidth() / 2) - 10); getContentPane().add(splitPane, BorderLayout.CENTER); splitPane.setLeftComponent(oldImagePanel); splitPane.setRightComponent(cutImagePanel); oldImagePanel.addMouseListener(new MouseAdapter() &#123; public void mousePressed(final MouseEvent e) &#123; // 鼠标键按下事件 pressPanelX = e.getX(); // 获得鼠标按下点的X坐标 pressPanelY = e.getY();// 获得鼠标按下点的Y坐标 pressX = e.getXOnScreen() + 1;// 鼠标按下点在屏幕上的X坐标加1，即去除选择线 pressY = e.getYOnScreen() + 1;// 鼠标按下点在屏幕上的Y坐标加1，即去除选择线 flag = true;// 为标记变量赋值为true &#125; public void mouseReleased(final MouseEvent e) &#123; // 鼠标键释放事件 releaseX = e.getXOnScreen() - 1;// 鼠标释放点在屏幕上的X坐标减1，即去除选择线 releaseY = e.getYOnScreen() - 1;// 鼠标释放点在屏幕上的Y坐标减1，即去除选择线 try &#123; robot = new Robot();// 创建Robot对象 if (releaseX - pressX &gt; 0 &amp;&amp; releaseY - pressY &gt; 0) &#123; Rectangle rect = new Rectangle(pressX, pressY, releaseX - pressX, releaseY - pressY);// 创建Rectangle对象 buffImage = robot.createScreenCapture(rect);// 获得缓冲图像对象 cutImagePanel.repaint(); // 调用CutImagePanel面板的paint()方法 &#125; &#125; catch (AWTException e1) &#123; e1.printStackTrace(); &#125; flag = false;// 为标记变量赋值为false &#125; &#125;); oldImagePanel.addMouseMotionListener(new MouseMotionAdapter() &#123; public void mouseDragged(final MouseEvent e) &#123;// 鼠标拖动事件 if (flag) &#123; releaseX = e.getXOnScreen();// 获得鼠标释放点在屏幕上的X坐标 releaseY = e.getYOnScreen();// 获得鼠标释放点在屏幕上的Y坐标 oldImagePanel.repaint();// 调用OldImagePanel面板的paint()方法 &#125; &#125; &#125;); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置窗体关闭模式 this.setTitle("裁剪图片"); // 设置窗体标题 &#125; class OldImagePanel extends JPanel &#123;// 创建绘制原图像的面板类 public void paint(Graphics g) &#123; Graphics2D g2 = (Graphics2D) g; g2.drawImage(img, 0, 0, this.getWidth(), this.getHeight(), this);// 绘制图像 g2.setColor(Color.WHITE); if (flag) &#123; float[] arr = &#123;5.0f&#125;; // 创建虚线模式的数组 BasicStroke stroke = new BasicStroke(1, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 1.0f, arr, 0); // 创建宽度是1的平头虚线笔画对象 g2.setStroke(stroke);// 设置笔画对象 g2.drawRect(pressPanelX, pressPanelY, releaseX - pressX, releaseY - pressY);// 绘制矩形选区 &#125; &#125; &#125; class CutImagePanel extends JPanel &#123;// 创建绘制裁剪结果的面板类 public void paint(Graphics g) &#123; g.clearRect(0, 0, this.getWidth(), this.getHeight());// 清除绘图上下文的内容 g.drawImage(buffImage, 0, 0, releaseX - pressX, releaseY - pressY, this);// 绘制图像 &#125; &#125;&#125; 调整图片的亮度 RescaleOp类中的filter方法原缓冲图像进行重缩放，定义如下public abstract BufferedImage filter(BufferedImage src,BufferedImage dst):src是要过滤的源对象，dst是目标对象，或则为null 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.zzk;import java.awt.BorderLayout;import java.awt.Graphics;import java.awt.Image;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.image.BufferedImage;import java.awt.image.RescaleOp;import java.io.File;import java.io.IOException;import javax.imageio.ImageIO;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JPanel;public class ImageBrightenFrame extends JFrame &#123; private BufferedImage image;// 用于调整亮度的缓冲图像对象 private BufferedImage oldImage;// 用于存放调整亮度之前的原缓冲图像对象 private ImageBrightenPanel imageBrightenPanel = new ImageBrightenPanel(); public static void main(String args[]) &#123; ImageBrightenFrame frame = new ImageBrightenFrame(); frame.setVisible(true); &#125; public ImageBrightenFrame() &#123; super(); setBounds(100, 100, 357, 276); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setTitle("调整图片的亮度"); Image img = null; try &#123; img = ImageIO.read(new File("src/img/image.jpg")); // 创建图像对象 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; image = new BufferedImage(img.getWidth(this), img.getHeight(this), BufferedImage.TYPE_INT_RGB);// 创建缓冲图像对象 image.getGraphics().drawImage(img, 0, 0, null);// 在缓冲图像对象上绘制图像 oldImage = image;// 存储原来的图像对象，用于以后的恢复操作 getContentPane().add(imageBrightenPanel, BorderLayout.CENTER); final JPanel panel = new JPanel(); getContentPane().add(panel, BorderLayout.SOUTH); final JButton button = new JButton(); button.addActionListener(new ActionListener() &#123; public void actionPerformed(final ActionEvent e) &#123; float a = 1.0f;// 定义缩放因子 float b = 5.0f;// 定义偏移量 RescaleOp op = new RescaleOp(a,b,null);// 创建具有指定缩放因子和偏移量的 RescaleOp对象 image = op.filter(image, null);// 对源图像中的数据进行逐像素重缩放，达到变亮的效果 repaint();// 重新绘制图像 &#125; &#125;); button.setText("变 亮"); panel.add(button); final JButton button_3 = new JButton(); button_3.addActionListener(new ActionListener() &#123; public void actionPerformed(final ActionEvent e) &#123; float a = 1.0f;// 定义缩放因子 float b = -5.0f;// 定义偏移量 RescaleOp op = new RescaleOp(a,b,null);// 创建具有指定缩放因子和偏移量的 RescaleOp对象 image = op.filter(image, null);// 对源图像中的数据进行逐像素重缩放，达到变暗的效果 repaint();// 重新绘制图像 &#125; &#125;); button_3.setText("变 暗"); panel.add(button_3); final JButton button_2 = new JButton(); button_2.addActionListener(new ActionListener() &#123; public void actionPerformed(final ActionEvent e) &#123; image = oldImage; // 获得变亮前的图像 imageBrightenPanel.repaint();// 重新绘制原图像，即恢复为变亮前的图像 &#125; &#125;); button_2.setText("恢 复"); panel.add(button_2); final JButton button_1 = new JButton(); button_1.addActionListener(new ActionListener() &#123; public void actionPerformed(final ActionEvent e) &#123; System.exit(0); &#125; &#125;); button_1.setText("退 出"); panel.add(button_1); &#125; class ImageBrightenPanel extends JPanel &#123; public void paint(Graphics g) &#123; if (image != null) &#123; g.drawImage(image, 0, 0, null); // 将缓冲图像对象绘制到面板上 &#125; &#125; &#125;&#125; 补充说明：这里的RescaleOp类可以调整色数，其原理是每一个样本值乘以一个缩放因子然后加上偏移量就是缩放的数，如果要变亮的话就将偏移量为正，反之为负，这里将缩放因子设置为1.0f是因为不想那么快速的变亮，如果你设置的大一点，就会很快变得很亮，反之亦然 转换彩色图片为灰色图片 主要使用ColorConvertOp类，其构造函数如下public ColorConvertOp(ColorSpace src,ColorSpace dst,RenderingHints hints):src是原颜色空间对象，dst是目标颜色空间对象，hints是用于控制颜色转换的RenderingHints对象，可以为null使用ColorConvertOp类中的filter方法将彩色图像转换成灰色图像，定义如下：public final BufferedImage filter(BufferedImage src,BufferedImage dst):scr要过滤的对象，dst目标空间对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.zzk;import java.awt.BorderLayout;import java.awt.Graphics;import java.awt.Image;import java.awt.color.ColorSpace;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.image.BufferedImage;import java.awt.image.ColorConvertOp;import java.io.File;import java.io.IOException;import javax.imageio.ImageIO;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JPanel;public class MultiColorToGrayFrame extends JFrame &#123; private BufferedImage image; private ColorToGrayPanel colorToGrayPanel = new ColorToGrayPanel(); public static void main(String args[]) &#123; MultiColorToGrayFrame frame = new MultiColorToGrayFrame(); frame.setVisible(true); &#125; public MultiColorToGrayFrame() &#123; super(); setBounds(100, 100, 357, 276); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setTitle("彩色图像转换为灰度"); Image img = null; try &#123; img = ImageIO.read(new File("src/img/image.jpg")); // 创建图像对象 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; image = new BufferedImage(img.getWidth(this), img.getHeight(this), BufferedImage.TYPE_INT_RGB);// 创建缓冲图像对象 image.getGraphics().drawImage(img, 0, 0, null);// 在缓冲图像对象上绘制图像 getContentPane().add(colorToGrayPanel, BorderLayout.CENTER); final JPanel panel = new JPanel(); getContentPane().add(panel, BorderLayout.SOUTH); final JButton button = new JButton(); button.addActionListener(new ActionListener() &#123; public void actionPerformed(final ActionEvent e) &#123; ColorSpace colorSpace1 = ColorSpace.getInstance(ColorSpace.CS_GRAY);// 创建内置线性为灰度的颜色空间 ColorSpace colorSpace2 = ColorSpace.getInstance(ColorSpace.CS_LINEAR_RGB);// 创建内置线性为 RGB的颜色空间 ColorConvertOp op = new ColorConvertOp(colorSpace1,colorSpace2, null);// 创建进行颜色转换的对象 image = op.filter(image, null);// 对缓冲图像进行颜色转换 repaint();// 重新绘制图像 &#125; &#125;); button.setText("转换为灰度"); panel.add(button); final JButton button_1 = new JButton(); button_1.addActionListener(new ActionListener() &#123; public void actionPerformed(final ActionEvent e) &#123; System.exit(0); &#125; &#125;); button_1.setText("退 出"); panel.add(button_1); &#125; class ColorToGrayPanel extends JPanel &#123; public void paint(Graphics g) &#123; if (image != null) &#123; g.drawImage(image, 0, 0, null); // 将缓冲图像对象绘制到面板上 &#125; &#125; &#125;&#125; 补充说明：这里的image.getGraphics().drawImage(img, 0, 0, null)可以删除的，因为这里Graphics类中的drawImage可以直接绘制BufferedImage类型的缓冲图像，下面会给出一段代码做个示范 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import javax.imageio.ImageIO;import javax.swing.*;import java.awt.*;import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;/** * Created by Chenjiabing on 2017/4/5. */public class demo extends JFrame&#123; private BufferedImage image=null; private Graphics2D graphics2D=null; private draw my_draw=new draw(); public static void main(String args[]) &#123; demo my=new demo(); my.setVisible(true); &#125; public demo() &#123; this.setBounds(100,100,1000,1000); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); try&#123; image= ImageIO.read(new File("src/img/image.jpg")); //graphics2D=image.createGraphics(); //graphics2D.drawImage(image,0,0,null); // image.getGraphics().drawImage(image,0,0,null); &#125; catch (IOException e) &#123; e.printStackTrace(); System.out.println("error"); &#125; this.getContentPane().add(my_draw); &#125; class draw extends JPanel &#123; public void paint(Graphics g) &#123; g.drawImage(image,0,0,image.getWidth(),image.getHeight(),this); &#125; &#125;&#125; 总结： 从文件中读取图像的方法 URL imgUrl = CutImageFrame.class.getResource(“/img/image.jpg”);//得到的是URL img = Toolkit.getDefaultToolkit().getImage(imgUrl); //得到的是Image对象，同样的想要得到BufferedImage对象可以进行转 化 Image img=ImageIo(new File(&quot;path&quot;));这里得到的是Image对象，如果想要得到BufferedImage对象，可以用BufferedImage的构造方法BufferedImage(int width,int height,) 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[matplotlib绘制图形基础]]></title>
      <url>%2F2017%2F04%2F01%2Fmatplotlib%E7%BB%98%E5%88%B6%E5%9B%BE%E5%BD%A2%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[matplotlib绘制基本图形折线图12345678import matplotlib.pyplot as pltimport numpy as npx=np.arange(0,10,1) #创建一个0-10之间以1为间隔的numpy数组y=x+10 plt.plot(x,y,color='red',linestyle='--',marker='&gt;',linewidth=3,label='example one') #绘制图形plt.savefig('first.png',dpi=50) #保存图形，dpi表示plt.legend() #显示图例plt.show() #显示图形 图形展示说明plt.plot()可以直接绘制折线，其中marker是折线上的标记，linewidth是折线的宽度，label是图例，如果要想显示就要设置plt.legend(),linestyle是折线的风格，color是颜色 饼状图123456789101112131415import matplotlib.pyplot as pltslices = [2,3,4,9] #指定每一个切片的大小，这里就是每块的比例activities = ['sleeping','eating','working','playing'] #指定标签cols = ['c','m','r','b'] #y颜色plt.pie(slices, labels=activities, colors=cols, #指定每一个区块的颜色 startangle=90, #开始角度，默认是0度，从x轴开始，90度从y轴开始 shadow= True, #阴影效果 explode=(0,0.1,0,0), #拉出第二个切片，如果全为0就不拉出，这里的数字是相对与圆心的距离 autopct='%1.1f%%') #显示百分比plt.title('Interesting Graph\nCheck it out') #设置标题plt.show() 图片展示 散点图12345678import numpy as npimport matplotlib.pyplot as pltx=np.random.rand(1000)y=np.random.rand(len(x))plt.scatter(x,y,color='r',alpha=0.3,label='example one',marker='o') #绘图plt.legend()#plt.axis([0,2,0,2]) #设置坐标的范围plt.show() 图片展示 直方图123456789import matplotlib.pyplot as pltimport numpy as npx=np.random.randint(1,1000,200)axis=plt.gca() #得到当前的绘图对象axis.hist(x,bins=35,facecolor='r',normed=True,histtype='bar',alpha=0.5)#bins表示直方图的个数，histtype表示直方图的样式，normed如果为True就将直方归一化，显示概率密度，默认是Falseaxis.set_xlabel("Values") #设置x的标签axis.set_ylabel("Frequency") axis.set_title("HIST")plt.show() 图片展示 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swing干货系列之JSplitPane(分割面板)]]></title>
      <url>%2F2017%2F03%2F28%2FSwing%E4%B8%AD%E7%9A%84JSplitPane%2F</url>
      <content type="text"><![CDATA[Swing中的JSplitPane(分割面板)引言 JSplitPane 用于分隔两个（只能两个）Component。两个 Component 图形化分隔以外观实现为基础，并且这两个 Component 可以由用户交互式调整大小。有关如何使用 JSplitPane 的信息，请参阅 The Java Tutorial 中的 How to Use Split Panes 一节。 使用 JSplitPane.HORIZONTAL_SPLIT 可让分隔窗格中的两个 Component 从左到右排列，或者使用 JSplitPane.VERTICAL_SPLIT 使其从上到下排列。改变 Component 大小的首选方式是调用 setDividerLocation，其中 location 是新的 x 或 y 位置，具体取决于 JSplitPane 的方向。 要将 Component 调整到其首选大小，可调用 resetToPreferredSizes。 当用户调整 Component 的大小时，Component 的最小大小用于确定 Component 能够设置的最大/最小位置。如果两个组件的最小大小大于分隔窗格的大小，则分隔条将不允许您调整其大小。改变 JComponent 最小大小，请参阅 JComponent.setMinimumSize(java.awt.Dimension)。 当用户调整分隔窗格大小时，新的空间以 resizeWeight 为基础在两个组件之间分配。默认情况下，值为 0 表示右边/底部的组件获得所有空间，而值为 1 表示左边/顶部的组件获得所有空间。补充说明： 这里的JComponebt.SetMinimumSize(java.awt.Dimension):用于设置组件的最小值，这里的Dimension是一个封装组件的高度和宽度的一个类，其中的一个构造函数就是Dimension(int width,int height),详情见文档，当然有设置最小的就有设置最大的啊，详情看文档吧 构造函数 public JSplitPanel():创建一个配置为将其子组件水平排列、无连续布局、为组件使用两个按钮的新 JSplitPane public JSplitPanel(int newOrientation):创建一个指定方向的分割板，这里的newOrientation可以设置两个值， VERTICAL_SPLIT(设置分割板为上下布局),HORIZONTAL_SPLIT(设置分隔板左右布局) public JSplitPane(int newOrientation,Component newLeftComponent,Component newRightComponent):创建一个具有指定方向和不连续重绘的指定组件的新 JSplitPane。 public JSplitPane(int newOrientation,boolean newContinuousLayout,Component newLeftComponent,Component newRightComponent):创建一个具有指定方向、重绘方式和指定组件的新 JSplitPane。 常用方法 setContinuousLayout(boolean newContinuousLayout):设置是否连续重新显示组件，如果为false就会发现在调整面板的过程中会显示一道黑线，只有当停下的时候才能正常的显示，默认是false setDividerSize(int newSize):设置分割条的大小* setDividerLocation(double size):设置分隔条的位置,这里的size是小数，个人觉得官方文档好像这里有点对劲，相当于占整个面板的百分比 setLeftComponent(Componentcomp)/setTopComponent(Component comp): 将组件设置到分隔条的上面或者左边。 setRightComponent(Component comp)/setBottomComponent(Component comp):将组件设置到分隔条的下面或者右边。 setOneTouchExpandable(boolean newValue):设置 oneTouchExpandable 属性的值，要使 JSplitPane 在分隔条上提供一个 UI 小部件来快速展开/折叠分隔条，此属性必须为 true。 补充说明： 上面只是常用的几个函数，具体的请看官方文档，注意这里的setLeftComponent的四个设置组件的函数要根据分隔板的分布来确定 开始撸代码 初步实现(创建两个按钮实现分隔板的布局)12345678910111213141516171819202122232425262728import java.awt.BorderLayout;import javax.swing.JButton;import javax.swing.JComponent;import javax.swing.JFrame;import javax.swing.JSplitPane;public class Main &#123; public static void main(String[] a) &#123; JFrame horizontalFrame = new JFrame(); horizontalFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JComponent topButton = new JButton("Left"); JComponent bottomButton = new JButton("Right"); final JSplitPane splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT); splitPane.setTopComponent(topButton); splitPane.setBottomComponent(bottomButton); horizontalFrame.add(splitPane, BorderLayout.CENTER); horizontalFrame.setSize(150, 150); horizontalFrame.setVisible(true); splitPane.setDividerLocation(0.5); &#125;&#125; 更进一步(两种布局的操作)123456789101112131415161718192021222324import java.awt.BorderLayout;import javax.swing.JButton;import javax.swing.JComponent;import javax.swing.JFrame;import javax.swing.JSplitPane;public class Main &#123; public static void main(String[] a) &#123; JFrame horizontalFrame = new JFrame(); horizontalFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JComponent leftButton = new JButton("Left"); JComponent rightButton = new JButton("Right"); JSplitPane splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT); splitPane.setLeftComponent(leftButton); splitPane.setRightComponent(rightButton); horizontalFrame.add(splitPane, BorderLayout.CENTER); horizontalFrame.setSize(150, 150); horizontalFrame.setVisible(true); &#125;&#125; 嵌套分隔板12345678910111213141516171819202122232425262728293031323334import javax.swing.JApplet;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JSplitPane;public class Main&#123; public static void main(String[] a) &#123; int HORIZSPLIT = JSplitPane.HORIZONTAL_SPLIT; int VERTSPLIT = JSplitPane.VERTICAL_SPLIT; boolean continuousLayout = true; JLabel label1 = new JLabel("a"); JLabel label2 = new JLabel("b"); JLabel label3 = new JLabel("c"); JSplitPane splitPane1 = new JSplitPane(VERTSPLIT, continuousLayout, label1, label2); splitPane1.setOneTouchExpandable(true); splitPane1.setDividerSize(2); splitPane1.setDividerLocation(0.5); JSplitPane splitPane2 = new JSplitPane(HORIZSPLIT, splitPane1, label3);//将分隔板和一个label放在第二个分割板中实现嵌套 splitPane2.setOneTouchExpandable(true); splitPane2.setDividerLocation(0.4); splitPane2.setDividerSize(2); JFrame frame = new JFrame(); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.add(splitPane2); frame.pack(); frame.setVisible(true); &#125;&#125; 事件监听12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.awt.BorderLayout;import java.beans.PropertyChangeEvent;import java.beans.PropertyChangeListener;// w w w . j a va2s . co mimport javax.swing.JButton;import javax.swing.JComponent;import javax.swing.JFrame;import javax.swing.JSplitPane;public class Main &#123; public static void main(String args[]) &#123; JFrame frame = new JFrame("Property Split"); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JSplitPane splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT); splitPane.setContinuousLayout(true); splitPane.setOneTouchExpandable(true); JComponent topComponent = new JButton("A"); splitPane.setTopComponent(topComponent); JComponent bottomComponent = new JButton("B"); splitPane.setBottomComponent(bottomComponent); PropertyChangeListener propertyChangeListener = new PropertyChangeListener() &#123; public void propertyChange(PropertyChangeEvent changeEvent) &#123; JSplitPane sourceSplitPane = (JSplitPane) changeEvent.getSource(); String propertyName = changeEvent.getPropertyName(); if (propertyName.equals(JSplitPane.LAST_DIVIDER_LOCATION_PROPERTY)) &#123; int current = sourceSplitPane.getDividerLocation(); System.out.println("Current: " + current); Integer last = (Integer) changeEvent.getNewValue(); System.out.println("Last: " + last); Integer priorLast = (Integer) changeEvent.getOldValue(); System.out.println("Prior last: " + priorLast); &#125; &#125; &#125;; splitPane.addPropertyChangeListener(propertyChangeListener); frame.add(splitPane, BorderLayout.CENTER); frame.setSize(300, 150); frame.setVisible(true); &#125;&#125; 说明无论 bean 何时更改 bound 属性，都会激发一个 PropertyChange 事件。可以向源 bean 注册一个 PropertyChangeListener，以便获得所有绑定 (bound) 属性更改的通知。 类 PropertyChangeEvent无论 bean 何时更改 “bound” 或 “constrained” 属性，都会提交一个 “PropertyChange” 事件。PropertyChangeEvent 对象被作为参数发送给 PropertyChangeListener 和 VetoableChangeListener 方法。通常 PropertyChangeEvent 还附带名称和已更改属性的旧值和新值。如果新值是基本类型（比如 int 或 boolean），则必须将它包装为相应的 java.lang.* Object 类型（比如 Integer 或 Boolean）。如果旧值和新值的真实值是未知的，则可能为它们提供 null 值。事件源可能发送一个 null 对象作为名称，以指示其属性的任意事件集已更改。在这种情况下，旧值和新值应该仍然为 null。getSource():返回最初未变化的对象，未Object类型的,因此这里需要强制转换成JSplitPanel 参考文章 官方文档 英文Swing教程 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swing干货系列之JSlider(滑块)]]></title>
      <url>%2F2017%2F03%2F27%2FSwing-%E5%B9%B2%E8%B4%A7%E7%B3%BB%E5%88%97%E4%B9%8BJSlider%2F</url>
      <content type="text"><![CDATA[Swing干货系列之JSlider(滑块)引言 一个让用户以图形方式在有界区间内通过移动滑块来选择值的组件。 滑块可以显示主刻度标记以及主刻度之间的次刻度标记。刻度标记之间的值的个数由 setMajorTickSpacing和 setMinorTickSpacing 来控制。刻度标记的绘制由 setPaintTicks 控制。 滑块也可以在固定时间间隔（或在任意位置）沿滑块刻度打印文本标签。标签的绘制由 setLabelTable 和 setPaintLabels 控制。 构造函数 JSlider():创建一个空值的滑块组件，但是默认的刻度是100，其中如果获得其值的话可以很清楚的看见 JSlider(BoundedRangeModel brm):使用指定的 BoundedRangeModel 创建一个水平滑块 JSlider(int min,int max):创建一个带有最小值和最大值得滑块 JSlider(int min,int max,int value):创建一个带有最小值，最大值和当前值的滑块 常用的方法 getValue(int x)/setValue(int x):得到和设置当前值 getPaintsLabels():return boolean 告知是否绘制了签 SetFont(Font font):设置组件的字体，其中Font类的font对象是参数 setInverted(boolean b):反转滑块的刻度 setMaximum(int maximum) ：设置最大值 setMinimum(int min):设置最小值 setMinorTickSpacing(int n) :设置次刻度，就是主刻度中间不用标记数值的刻度 setMajorTickSpacing(int n):设置主刻度 setPaintTicks(boolean b):确定是否在滑块下面显示刻度线，如果为false表示不显示 setPaintLabels(boolean b):确定是否在刻度线下绘制数值，默认不绘制以上只是列了几个常用的函数，详情见官方文档 下面撸个代码试试身手12345678910111213141516171819202122232425262728293031323334353637383940package com;import javax.swing.*;import javax.swing.event.ChangeEvent;import javax.swing.event.ChangeListener;import java.awt.*;/** * Created by chenjiabing on 2017/3/27. */public class Java_swing extends JFrame &#123; public JSlider points = null; public Java_swing() &#123; super(); setTitle("记事本"); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setSize(300, 400);// points=new JSlider(); points = new JSlider(0, 50, 5); points.setMinorTickSpacing(5);//设置次要的间隔，每个一个间隔，这个显示时中间不标记数值 points.setMajorTickSpacing(10);//显示主要的刻度线，每个两个间隔，这个设置了，如果setPaintLabels为true就会显示数值 points.setPaintTicks(true); //确定是否显示刻度线 points.setPaintLabels(true); //确定是否显示刻度的值 //points.setInverted(true);//指定为true反转刻 度 points.setSnapToTicks(true); points.addChangeListener(new ChangeListener() &#123; @Override public void stateChanged(ChangeEvent e) &#123; int value = points.getValue(); System.out.println(value); &#125; &#125;); getContentPane().add(points, BorderLayout.CENTER); &#125; public static void main(String args[]) &#123; Java_swing my = new Java_swing(); my.setVisible(true); &#125;&#125; Change Listener(一个监听机制)1234567891011121314151617181920212223242526272829303132333435import java.awt.Dimension;/*from w ww . ja v a 2 s .c o m*/import javax.swing.JFrame;import javax.swing.JSlider;import javax.swing.event.ChangeEvent;import javax.swing.event.ChangeListener;public class Main &#123; public static void main(String[] args) &#123; JFrame f = new JFrame(); final JSlider slider = new JSlider(0, 150, 0); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); slider.setPreferredSize(new Dimension(150, 30)); //添加change Listener,当然这里的和JButton的也是一样，可以在一个类中实现 slider.addChangeListener(new ChangeListener() &#123; public void stateChanged(ChangeEvent event) &#123; int value = slider.getValue(); if (value == 0) &#123; System.out.println("0"); &#125; else if (value &gt; 0 &amp;&amp; value &lt;= 30) &#123; System.out.println("value &gt; 0 &amp;&amp; value &lt;= 30"); &#125; else if (value &gt; 30 &amp;&amp; value &lt; 80) &#123; System.out.println("value &gt; 30 &amp;&amp; value &lt; 80"); &#125; else &#123; System.out.println("max"); &#125; &#125; &#125;); f.add(slider); f.pack(); f.setLocationRelativeTo(null); f.setVisible(true); &#125;&#125; 当然以上只是JSlider的一部分内容，还有的后面会陆续更新本文参考的文章： 中文文档 英文文档 福利时间，博主写了一个小例子，想要的朋友可以参见github,不要忘了随手点个赞哦！！！ 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[scrapy设置请求池]]></title>
      <url>%2F2017%2F03%2F26%2Fscrapy%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E6%B1%A0%2F</url>
      <content type="text"><![CDATA[scrapy设置”请求池”引言 相信大家有时候爬虫发出请求的时候会被ban，返回的是403错误，这个就是请求头的问题，其实在python发出请求时，使用的是默认的自己的请求头，网站管理者肯定会不允许机器访问的，但是有些比较low的网站还是可以访问的，有时候网站管理者看到同一个请求头在一秒内请求多次，傻子都知道这是机器在访问，因此会被ban掉，这时就需要设置请求池了，这个和ip代理池是一个概念 爬虫请求常见的错误 200：请求成功 处理方式：获得响应的内容，进行处理201：请求完成，结果是创建了新资源。新创建资源的 URI 可在响应的实体中得到 处理方式：爬虫中不会遇到202：请求被接受，但处理尚未完成 处理方式：阻塞等待204：服务器端已经实现了请求，但是没有返回新的信 息。如果客户是用户代理，则无须为此更新自身的文档视图。 处理方式：丢弃300：该状态码不被 HTTP/1.0 的应用程序直接使用， 只是作为 3XX 类型回应的默认解释。存在多个可用的被请求资源。 处理方式：若程序中能够处理，则进行进一步处理，如果程序中不能处理，则丢弃301：请求到的资源都会分配一个永久的 URL，这样就可以在将来通过该 URL 来访问此资源 处理方式：重定向到分配的 URL302：请求到的资源在一个不同的 URL 处临时保存 处理方式：重定向到临时的 URL304 请求的资源未更新 处理方式：丢弃400 非法请求 处理方式：丢弃401 未授权 处理方式：丢弃403 禁止 处理方式：丢弃404 没有找到 处理方式：丢弃5XX 回应代码以“5”开头的状态码表示服务器端发现自己出现错误，不能继续执行请求 处理方式：丢弃 话不多说直接撸代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from scrapy import logimport randomfrom scrapy.downloadermiddlewares.useragent import UserAgentMiddlewareclass RotateUserAgentMiddleware(UserAgentMiddleware):# for more user agent strings,you can find it in http://www.useragentstring.com/pages/useragentstring.phpuser_agent_list = [ "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 " "(KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1", "Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 " "(KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11", "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 " "(KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6", "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.6 " "(KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6", "Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.1 " "(KHTML, like Gecko) Chrome/19.77.34.5 Safari/537.1", "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 " "(KHTML, like Gecko) Chrome/19.0.1084.9 Safari/536.5", "Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 " "(KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5", "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3", "Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3", "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3", "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3", "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3", "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3", "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3", "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1061.0 Safari/536.3", "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 " "(KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24", "Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 " "(KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24"]def process_request(self, request, spider): ua = random.choice(self.user_agent_list) if ua: # 显示当前使用的useragent print "********Current UserAgent:%s************" % ua # 记录 log.msg('Current UserAgent: ' + ua) request.headers.setdefault('User-Agent', ua) 说明 这里的思路就是在下载器中间件中对request设置请求，这里是使用request.headers.setdefault(&quot;User-Agent&quot;,user_agent)这个函数设置请求头，对于下载器中间件在我博客前面的文章已经有说明，想要了解的请点击 注意 这里还要说明的是设置了请求池还要在配置文件settins中设置一下，具体设置方法和设置代理ip一样，详情请看scrapy代理ip的设置 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Scrapy中使用cookie免于验证登录和模拟登录]]></title>
      <url>%2F2017%2F03%2F26%2FScrapy%E4%B8%AD%E4%BD%BF%E7%94%A8cookie%E5%85%8D%E4%BA%8E%E9%AA%8C%E8%AF%81%E7%99%BB%E5%BD%95%E5%92%8C%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%2F</url>
      <content type="text"><![CDATA[Scrapy中使用cookie免于验证登录和模拟登录引言 python爬虫我认为最困难的问题一个是ip代理，另外一个就是模拟登录了，更操蛋的就是模拟登录了之后还有验证码，真的是不让人省心，不过既然有了反爬虫，那么就有反反爬虫的策略，这里就先介绍一个cookie模拟登陆，后续还有seleminum+phantomjs模拟浏览器登录的文章。还不知道cookie是什么朋友们，可以点击这里 cookie提取方法： 打开谷歌浏览器或者火狐浏览器，如果是谷歌浏览器的按F12这个键就会跳出来浏览器控制台，然后点击Network，之后就是刷新网页开始抓包了，之后在抓到的页面中随便打开一个，就能看到cokie了，但是这里的cookie并不符合python中的格式，因此需要转换格式，下面提供了转换的代码 1234567891011121314151617181920212223# -*- coding: utf-8 -*-class transCookie:def __init__(self, cookie): self.cookie = cookiedef stringToDict(self): ''' 将从浏览器上Copy来的cookie字符串转化为Scrapy能使用的Dict :return: ''' itemDict = &#123;&#125; items = self.cookie.split(';') for item in items: key = item.split('=')[0].replace(' ', '') value = item.split('=')[1] itemDict[key] = value return itemDictif __name__ == "__main__":cookie = "你复制的cookie"trans = transCookie(cookie)print trans.stringToDict() 补充说明： 只需要将你网页上的cookie复制到上述代码中直接运行就可以了 使用cookie操作scrapy 直接撸代码 123456789101112131415161718# -*- coding: utf-8 -*-import scrapyfrom scrapy.conf import settings #从settings文件中导入Cookie，这里也可以室友from scrapy.conf import settings.COOKIEclass DemoSpider(scrapy.Spider):name = "demo"#allowed_domains = ["csdn.com"]start_urls = ["http://write.blog.csdn.net/postlist"]cookie = settings['COOKIE'] # 带着Cookie向网页发请求\headers = &#123; 'Connection': 'keep - alive', # 保持链接状态 'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.82 Safari/537.36'&#125;def start_requests(self): yield scrapy.Request(url=self.start_urls[0],headers=self.headers,cookies=self.cookie)# 这里带着cookie发出请求def parse(self, response): print response.body 说明 这里是scrapy工程目录下spiders目录下的主要的解析网页的py文件相信学过scrapy的应该不会陌生，上述代码中的cookie值是放在Settings文件中的，因此使用的时候需要导入，当然你也可以直接将cookie粘贴到这个文件中 注意 虽说这里使用直接使用cookie可以省去很多麻烦，但是cookie的生命周期特别的短，不过小型的项目足够使用了，向那些需要爬两三天甚至几个月的项目就不适用了，因此在隔一段时间就要重新换cookie的值，虽说有很多麻烦，但是我还是比较喜欢这种方法的，因为可以省去不少脑筋 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持。 最后欢迎大家看看我的其他scrapy文章 scrapy设置代理ip scrapy架构初探 scrapy初试 scrapy下载器中间件 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[scrapy设置代理ip]]></title>
      <url>%2F2017%2F03%2F26%2Fscrapy%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86ip%2F</url>
      <content type="text"><![CDATA[scrapy代理的设置 在我的上一篇文章介绍了scrapy下载器中间件的使用,这里的scrapyIP的代理就是用这个原理实现的，重写了下载器中间件的process_request(self,request,spider)这个函数,这个函数的主要作用就是对request进行处理。 话不多说直接撸代码 123456789101112131415161718192021222324import random import scrapyimport loggingclass proxMiddleware(object):#proxy_list=[&#123;'http': 'http://123.157.146.116:8123'&#125;, &#123;'http': 'http://116.55.16.233:8998'&#125;, &#123;'http': 'http://115.85.233.94:80'&#125;, &#123;'http': 'http://180.76.154.5:8888'&#125;, &#123;'http': 'http://139.213.135.81:80'&#125;, &#123;'http': 'http://124.88.67.14:80'&#125;, &#123;'http': 'http://106.46.136.90:808'&#125;, &#123;'http': 'http://106.46.136.226:808'&#125;, &#123;'http': 'http://124.88.67.21:843'&#125;, &#123;'http': 'http://113.245.84.253:8118'&#125;, &#123;'http': 'http://124.88.67.10:80'&#125;, &#123;'http': 'http://171.38.141.12:8123'&#125;, &#123;'http': 'http://124.88.67.52:843'&#125;, &#123;'http': 'http://106.46.136.237:808'&#125;, &#123;'http': 'http://106.46.136.105:808'&#125;, &#123;'http': 'http://106.46.136.190:808'&#125;, &#123;'http': 'http://106.46.136.186:808'&#125;, &#123;'http': 'http://101.81.120.58:8118'&#125;, &#123;'http': 'http://106.46.136.250:808'&#125;, &#123;'http': 'http://106.46.136.8:808'&#125;, &#123;'http': 'http://111.78.188.157:8998'&#125;, &#123;'http': 'http://106.46.136.139:808'&#125;, &#123;'http': 'http://101.53.101.172:9999'&#125;, &#123;'http': 'http://27.159.125.68:8118'&#125;, &#123;'http': 'http://183.32.88.133:808'&#125;, &#123;'http': 'http://171.38.37.193:8123'&#125;]proxy_list=[ "http://180.76.154.5:8888", "http://14.109.107.1:8998", "http://106.46.136.159:808", "http://175.155.24.107:808", "http://124.88.67.10:80", "http://124.88.67.14:80", "http://58.23.122.79:8118", "http://123.157.146.116:8123", "http://124.88.67.21:843", "http://106.46.136.226:808", "http://101.81.120.58:8118", "http://180.175.145.148:808"]def process_request(self,request,spider): # if not request.meta['proxies']: ip = random.choice(self.proxy_list) print ip #print 'ip=' %ip request.meta['proxy'] = ip 主要的原理： 给出一个代理列表，然后在这个列表中随机取出一个代理，设置在request中，其中request.meta[&#39;proxy&#39;]就是设置代理的格式 但是现在主要的问题就是没有代理ip可用，如果去买的话又太贵了，自己玩玩买代理不值当，所以只好自己写爬虫去爬取免费的代理了，但是免费的代理存活的时间是有限的，这是个非常麻烦的事情，我提供的方法就是实现自己的一个ip代理池，每天定时更新自己的代理池，具体的实现方法会在下一篇文章中介绍，现在提供一段代码用来爬取西刺网站的代理 直接撸代码，接招吧 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#coding:utf-8import requestsfrom bs4 import BeautifulSoupimport threadingimport Queueclass Get_ips():def __init__(self,page): self.ips=[] self.urls=[] for i in range(page): self.urls.append("http://www.xicidaili.com/nn/" + str(i)) self.header = &#123;"User-Agent": 'Mozilla/5.0 (Windows NT 6.3; WOW64; rv:43.0) Gecko/20100101 Firefox/43.0'&#125; #self.file=open("ips",'w') self.q=Queue.Queue() self.Lock=threading.Lock()def get_ips(self): for url in self.urls: res = requests.get(url, headers=self.header) soup = BeautifulSoup(res.text, 'lxml') ips = soup.find_all('tr') for i in range(1, len(ips)): ip = ips[i] tds = ip.find_all("td") ip_temp = "http://" + tds[1].contents[0] + ":" + tds[2].contents[0] # print str(ip_temp) self.q.put(str(ip_temp))def review_ips(self): while not self.q.empty(): ip=self.q.get() try: proxy=&#123;"http": ip&#125; #print proxy res = requests.get("http://www.baidu.com", proxies=proxy,timeout=5) self.Lock.acquire() if res.status_code == 200: self.ips.append(ip) print ip self.Lock.release() except Exception: pass #print 'error'def main(self): self.get_ips() threads=[] for i in range(40): threads.append(threading.Thread(target=self.review_ips,args=[])) for t in threads: t.start() for t in threads: t.join() return self.ipsdef get_ip():my=Get_ips(4)return my.main()get_ip() 实现的原理 这里用到了BeautifulSoup解析页面，然后将提取到的代理交给队列，然后再通过共享队列分配给线程，这里主要开启线程通过设置代理ip访问一个网站，因为访问网站的时间比较长，因此要开起多个线程，相信大家能够学习设置代理ip了应该都是比较上手的了，这里具体的代码就不一一解释了，如果代码有什么问题可以及时联系我，我的联系方式在关于我的一栏中有提到 补充 想要ip应用起来，还要在配置文件settings中添加DOWNLOADER_MIDDLEWARES = { &#39;demo.proxy.proxMiddleware&#39;:400 }这里的demo是工程的名字，proxy是py文件的名,proxMiddleware是类的名字 当然这里可能你觉得proxy_list写在这里有点冗余，你可以在配置文件中定义，然后将配置文件的内容import到py文件中 以上全是博主慢慢摸索出来的，可以说自学一门技术真的很难，学习python爬虫已经有两三个月了，可以说全是自己通过看项目，网上查资料才有了今天的成功，不过现在还有几个问题没有解决，就是分布式爬虫、移动端爬取，博主接下来就要主攻这两个方面，学好之后会在自己的博客上分享学习心得的，因为网上没有系统的学习教程，对于自学的人来说实在是太痛苦了 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[scrapy的下载器中间件]]></title>
      <url>%2F2017%2F03%2F25%2Fscrapy%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%99%A8%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[scrapy中的下载器中间件下载中间件 下载器中间件是介于Scrapy的request/response处理的钩子框架。 是用于全局修改Scrapy request和response的一个轻量、底层的系统。 编写下载器中间件 1. process_request(request, spider)当每个request通过下载中间件时，该方法被调用。process_request() 必须返回其中之一: 返回 None 、返回一个 Response 对象、返回一个 Request对象或raise IgnoreRequest 。 如果其返回 None ，Scrapy将继续处理该request，执行其他的中间件的相应方法，直到合适的下载器处理函数(download handler)被调用， 该request被执行(其response被下载)。 如果其返回 Response 对象，Scrapy将不会调用 任何 其他的 process_request() 或 process_exception() 方法，或相应地下载函数； 其将返回该response。 已安装的中间件的 process_response() 方法则会在每个response返回时被调用。 如果其返回 Request 对象，Scrapy则停止调用 process_request方法并重新调度返回的request。当新返回的request被执行后， 相应地中间件链将会根据下载的response被调用。 如果其raise一个 IgnoreRequest 异常，则安装的下载中间件的 process_exception() 方法会被调用。如果没有任何一个方法处理该异常， 则request的errback(Request.errback)方法会被调用。如果没有代码处理抛出的异常， 则该异常被忽略且不记录(不同于其他异常那样)。 参数: request (Request 对象) – 处理的request spider (Spider 对象) – 该request对应的spider 2. process_response(request, response, spider) process_response() 必须返回以下之一: 返回一个 Response对象、 返回一个Request 对象或raise一个 IgnoreRequest 异常。 如果其返回一个 Response (可以与传入的response相同，也可以是全新的对象)， 该response会被在链中的其他中间件的 process_response() 方法处理。 如果其返回一个 Request 对象，则中间件链停止， 返回的request会被重新调度下载。处理类似于 process_request() 返回request所做的那样。 如果其抛出一个 IgnoreRequest 异常，则调用request的errback(Request.errback)。 如果没有代码处理抛出的异常，则该异常被忽略且不记录(不同于其他异常那样)。 参数: request (Request对象) – response所对应的request response (Response 对象) – 被处理的response spider (Spider 对象) – response所对应的spider 3.process_exception(request, exception, spider) 当下载处理器(download handler)或 process_request() (下载中间件)抛出异常(包括 IgnoreRequest 异常)时， Scrapy调用 process_exception() 。 process_exception() 应该返回以下之一: 返回 None 、 一个 Response 对象、或者一个 Request 对象。 如果其返回 None ，Scrapy将会继续处理该异常，接着调用已安装的其他中间件的 process_exception() 方法，直到所有中间件都被调用完毕，则调用默认的异常处理。 如果其返回一个 Response 对象，则已安装的中间件链的 process_response() 方法被调用。Scrapy将不会调用任何其他中间件的 process_exception() 方法。 如果其返回一个 Request 对象， 则返回的request将会被重新调用下载。这将停止中间件的 process_exception() 方法执行，就如返回一个response的那样。 参数: request (是 Request 对象) – 产生异常的request exception (Exception 对象) – 抛出的异常 spider (Spider 对象) – request对应的spider 总结： 总的来说下载器中间件就是起到处理request请求并且返回response的作用，一切从网页爬取的url发起的请求会组成一个请求队列，然后一个一个排队经过下载器中间件，之后下载器中间件会对request做出相应的处理，比如添加请求头，添加代理等等，然后通过process_response返回一个response，之后就是用得到的response做出相应的分析，当然这里的内容页可以不实现，但是如果要爬取大型的网站，会遇到被ban的可能就要在下载器中间件这里着手，设置一些相应的请求头，ip代理等等内容。以上纯属个人逐渐摸索总结出来的内容，如果有什么错误欢迎指正 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[scrapy初试]]></title>
      <url>%2F2017%2F03%2F25%2Fscrapy%E5%88%9D%E8%AF%95%2F</url>
      <content type="text"><![CDATA[scrapy初试 创建项目 打开cmd，在终端输入scrapy startproject tutorial,这里将在指定的文件夹下创建一个scrapy工程 其中将会创建以下的文件： scrapy.cfg: 项目的配置文件 tutorial/: 该项目的python模块。之后您将在此加入代码。 tutorial/items.py: 项目中的item文件. tutorial/pipelines.py: 项目中的pipelines文件. tutorial/settings.py: 项目的设置文件. tutorial/spiders/: 放置spider代码的目录. 定义item Item是保存爬取到的数据的容器；其使用方法和python字典类似， 并且提供了额外保护机制来避免拼写错误导致的未定义字段错误。 类似在ORM中做的一样，您可以通过创建一个 scrapy.Item 类， 并且定义类型为 scrapy.Field的类属性来定义一个Item。 (如果不了解ORM, 不用担心，您会发现这个步骤非常简单) 首先根据需要从dmoz.org获取到的数据对item进行建模。 我们需要从dmoz中获取名字，url，以及网站的描述。 对此，在item中定义相应的字段。编辑 tutorial 目录中的 items.py 文件: 12345import scrapyclass DmozItem(scrapy.Item):title = scrapy.Field()link = scrapy.Field()desc = scrapy.Field() 一开始这看起来可能有点复杂，但是通过定义item， 您可以很方便的使用Scrapy的其他方法。而这些方法需要知道您的item的定义. 编写第一个爬虫 在工程的根目录下打开终端输入scrapy genspider demo douban.com这里的demo是spders文件下的主要py文件douban.com是要爬取的域名，会在demo.py中的 allowed_domains中显示，主要的功能就是限制爬取的url spider代码中内容解析 name: 用于区别Spider。 该名字必须是唯一的，您不可以为不同的Spider设定相同的名字。 start_urls: 包含了Spider在启动时进行爬取的url列表。 因此，第一个被获取到的页面将是其中之一。 后续的URL则从初始的URL获取到的数据中提取。 parse() 是spider的一个方法。 被调用时，每个初始URL完成下载后生成的 Response 对象将会作为唯一的参数传递给该函数。 该方法负责解析返回的数据(response data)，提取数据(生成item)以及生成需要进一步处理的URL的 Request对象。 以下是spider目录下的demo.py的代码 1234567891011121314import scrapyclass DmozSpider(scrapy.Spider):name = "dmoz"allowed_domains = ["dmoz.org"]start_urls = [ "http://www.dmoz.org/Computers/Programming/Languages/Python/Books/", "http://www.dmoz.org/Computers/Programming/Languages/Python/Resources/"]def parse(self, response): filename = response.url.split("/")[-2] with open(filename, 'wb') as f: f.write(response.body) spider的爬取 进入工程的根目录下打开终端输入：scrapy crawl dmoz spider中的数据存取 在工程的根目录下打开终端输入scrapy crawl dmoz -o items.json这里是将数据存储到json文件中]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java中的IO操作]]></title>
      <url>%2F2017%2F03%2F25%2Fjava%E4%B8%AD%E7%9A%84IO%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[java中IO操作读取文件中的内容 使用Scanner读取文本中的内容 相信大家都知道Scanner console=new Scanner(System.in)是用来读取控制台上输入的内容，但是这里是用来读取文件的内容，原理是一样的，只是对象不同罢了，这里用到的是File对象，用来创建一个文件对象 123456Scanner input=new Scanner(new File("hello.txt"));//创建一个对象inputwhile(input.hasNextLine()) //这里用来判断是否还有内容， 以免读到最后发生错误&#123;String content=input.nextLine();System.out.println(content);&#125; 这里顺便补充一下Scannner中的几个函数： nextLine():读取一行的内容，包括空格，换行 nextInt():读取一个整型内容 nexDouble():读取一个双精度的浮点数 next():读取下一个内容，无论什么类型，其中遇到空格和换行默认是一个标记（即是跳过）和nextLine()类似 hasNext():用来判断文件中的还有下一个内容，无论什么类型的 hasNextInt() hasNextDouble()://相似，不在赘述 使用FileReader读取 用来读取字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的。要自己指定这些值，可以先在 FileInputStream上构造一个 InputStreamReader。FileReader 用于读取字符流。要读取原始字节流，请考虑使用 FileInputStream。 //这里使用new File创建一个对象，同样的也可以直接将文件的绝对路径传入 FileReader file=new FileReader(new File(&quot;hello.txt&quot;)); while(file.ready()) //用来判断是否还有字符可读 { int content=file.read(); //这里的read是读取将单个字符 返回的是int，即是ascii码,这里官方文档说返回的是读取的字符数，但是我实验了一下返回的ascii码 System.out.println((char)content); //所以要将ascii码转换成字符 } file.close(); 常用的几个方法： read(): return int 上面介绍过 read(char[] cbuf,int int length):将内容读入到一个char类型的数组，length是读取的字符数，offest是偏移量 使用BufferedReader的类实现高效的读取文件 123456//传入一个reader创建一个对象 BufferedReader file= new BufferedReader(new FileReader("hello.txt")); System.out.println(file.skip(3));//实现将指针跳过3个字符 System.out.println((char)file.read()); //read的方法，和FileReader中的read一样 String line=file.readLine(); //读取一行 System.out.println(line); 常用的方法： readLine() read()：如果到了末尾返回-1 read(char [],int off,int length):和FileReader中的一样 ready():判断是否还可以读取，一般和read配对使用 skip(long n):跳过的字符数 close() 文件的写入 用FileWriter写入文件 12345/*创建将对象f传入FileWriter,其中Filewriter有两个参数，第一个是File对象后者是一个String(即是文件的路径），第二个参数是boolean类型的，表示是否在文件的末尾追加内容，默认的是false表示不用在末尾追加，如果想要在末尾追加要写入另外一个参数true,当然这里可以用更加简洁的方式创建：FileWriter file=new FileWriter("hello.txt",false);*/FileWriter file=new FileWriter(f,true);file.write("chenjiabing");//写入函数writefile.close(); //最后必须关闭文件的输入流，否则写入将会失败，这里不想c和c++ 其中Filewriter中的方法还有 flush：刷新缓存流 close append():当前的领会的就是写入数组:append(Arrays.toString(list)); getEncoding():返回此流使用的字符编码 用PrintStream写入文件 这里同样的是和System.out.println()一样的原理，System.out.println只是内部实现了PrintStream，这里是用来将指定的内容写入到文件中而已 12345PrintStream output=new PrintStream(new File("hello.txt"));//创建一个写入的对象outputoutput.print("flan");output.println("vmlkfamla");output.println("vmslfkmadvmfs;dm"); 这里是用BufferedWriter类写入文件(一个高效的写入方式) 简单介绍 将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。可以指定缓冲区的大小，或者接受默认的大小。在大多数情况下，默认值就足够大了。该类提供了 newLine() 方法，它使用平台自己的行分隔符概念，此概念由系统属性 line.separator 定义。并非所有平台都使用新行符 (‘\n’) 来终止各行。因此调用此方法来终止每个输出行要优于直接写入新行符。通常 Writer 将其输出立即发送到底层字符或字节流。除非要求提示输出，否则建议用 BufferedWriter 包装所有其 write() 操作可能开销很高的 Writer（如 FileWriters 和 OutputStreamWriters）。例如， PrintWriter out= new PrintWriter(new BufferedWriter(new FileWriter(&quot;foo.out&quot;))); 将缓冲 PrintWriter对文件的输出。如果没有缓冲，则每次调用 print() 方法会导致将字符转换为字节，然后立即入到文件，而这是极其低效的。 例子 12345BufferedWriter input=new BufferedWriter(new FileWriter("hello.txt")); input.write("这是一个文件读入的方法"); input.newLine(); input.write("一个高效的方法"); input.close(); 其他的方法 close() flush() newLine():写入一个换行，因为每一个操作系统上的换行符可能不一样，不能系统的都用”\n”表示 write() 详情参见API 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[scrapy架构初探]]></title>
      <url>%2F2017%2F03%2F25%2Fscrapy%E6%9E%B6%E6%9E%84%E5%88%9D%E6%8E%A2%2F</url>
      <content type="text"><![CDATA[scrapy架构初探引言 Python即时网络爬虫启动的目标是一起把互联网变成大数据库。单纯的开放源代码并不是开源的全部，开源的核心是“开放的思想”，聚合最好的想法、技术、人员，所以将会参照众多领先产品，比如，Scrapy，ScrapingHub，import io等。 本文简单讲解一下Scrapy的架构。没错，通用提取器gsExtractor就是要集成到Scrapy架构中。 请注意，本文不想复述原文内容，而是为了开源Python爬虫的发展方向找参照，而且以9年来开发网络爬虫经验作为对标，从而本文含有不少笔者主观评述，如果想读Scrapy官方原文，请点击Scrapy官网的Architecture。 scrapy数据流 Scrapy中的数据流由执行引擎控制，下面的原文摘自Scrapy官网，我根据猜测做了点评，为进一步开发GooSeeker开源爬虫指示方向： The Engine gets the first URLs to crawl from the Spider and schedules them in the Scheduler, as Requests. URL谁来准备呢？看样子是Spider自己来准备，那么可以猜测Scrapy架构部分（不包括Spider）主要做事件调度，不管网址的存储。看起来类似GooSeeker会员中心的爬虫罗盘，为目标网站准备一批网址，放在罗盘中准备执行爬虫调度操作。所以，这个开源项目的下一个目标是把URL的管理放在一个集中的调度库里面。 The Engine asks the Scheduler for the next URLs to crawl. 看到这里其实挺难理解的，要看一些其他文档才能理解透。接第1点，引擎从Spider中把网址拿到以后，封装成一个Request，交给了事件循环，会被Scheduler收来做调度管理的，暂且理解成对Request做排队。引擎现在就找Scheduler要接下来要下载的网页地址。 The Scheduler returns the next URLs to crawl to the Engine and the Engine sends them to the Downloader, passing through the Downloader Middleware (request direction). 从调度器申请任务，把申请到的任务交给下载器，在下载器和引擎之间有个下载器中间件，这是作为一个开发框架的必备亮点，开发者可以在这里进行一些定制化扩展。 Once the page finishes downloading the Downloader generates a Response (with that page) and sends it to the Engine, passing through the Downloader Middleware (response direction). 下载完成了，产生一个Response，通过下载器中间件交给引擎。注意，Response和前面的Request的首字母都是大写，虽然我还没有看其它Scrapy文档，但是我猜测这是Scrapy框架内部的事件对象，也可以推测出是一个异步的事件驱动的引擎，就像DS打数机的三级事件循环一样，对于高性能、低开销引擎来说，这是必须的。 The Engine receives the Response from the Downloader and sends it to the Spider for processing, passing through the Spider Middleware (input direction). 再次出现一个中间件，给开发者足够的发挥空间。 The Spider processes the Response and returns scraped items and new Requests (to follow) to the Engine. 每个Spider顺序抓取一个个网页，完成一个就构造另一个Request事件，开始另一个网页的抓取。 The Engine passes scraped items and new Requests returned by a spider through Spider Middleware (output direction), and then sends processed items to Item Pipelines and processed Requests to the Scheduler. 引擎作事件分发 The process repeats (from step 1) until there are no more requests from the Scheduler. 持续不断地运行。 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java图形与文本处理一]]></title>
      <url>%2F2017%2F03%2F25%2Fjava%E5%9B%BE%E5%BD%A2%E4%B8%8E%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%80%2F</url>
      <content type="text"><![CDATA[java绘制图形和文本&lt;一&gt;开篇介绍(官方文档) java.awt类 Graphicsjava.lang.Object继承者 java.awt.Graphics直接已知子类：DebugGraphics, Graphics2Dpublic abstract class Graphics extends Object Graphics 类是所有图形上下文的抽象基类，允许应用程序在组件（已经在各种设备上实现）以及闭屏图像上进行绘制。Graphics 对象封装了 Java 支持的基本呈现操作所需的状态信息。此状态信息包括以下属性：要在其上绘制的 Component 对象。呈现和剪贴坐标的转换原点。当前剪贴区。当前颜色。当前字体。当前逻辑像素操作函数（XOR 或 Paint）。当前 XOR 交替颜色（参见 setXORMode(java.awt.Color)）。坐标是无限细分的，并且位于输出设备的像素之间。绘制图形轮廓的操作是通过使用像素大小的画笔遍历像素间无限细分路径的操作，画笔从路径上的锚点向下和向右绘制。填充图形的操作是填充图形内部区域无限细分路径操作。呈现水平文本的操作是呈现字符字形完全位于基线坐标之上的上升部分。图形画笔从要遍历的路径向下和向右绘制。其含义如下：如果绘制一个覆盖给定矩形的图形，那么该图形与填充被相同矩形所限定的图形相比，在右侧和底边多占用一行像素。如果沿着与一行文本基线相同的 y 坐标绘制一条水平线，那么除了文字的所有下降部分外，该线完全画在文本的下面。所有作为此 Graphics 对象方法的参数而出现的坐标，都是相对于调用该方法前的此 Graphics 对象转换原点的。所有呈现操作仅修改当前剪贴区所限定区域内的像素，此剪贴区是由用户空间中的 Shape 指定的，并通过使用 Graphics 对象的程序来控制。此用户剪贴区 被转换到设备空间中，并与设备剪贴区 组合，后者是通过窗口可见性和设备范围定义的。用户剪贴区和设备剪贴区的组合定义复合剪贴区，复合剪贴区确定最终的剪贴区域。用户剪贴区不能由呈现系统修改，以反映得到的复合剪贴区。用户剪贴区只能通过 setClip 或 clipRect 方法更改。所有的绘制或写入都以当前的颜色、当前绘图模式和当前字体完成。 绘制直线主要用到的内容是Graphics类中的drawLine函数定义： public abstract void drawLine(int x1,int y1,int x2,int y2)x1,y1是起始点的坐标，x2,y2是尾点的坐标 拓展 SetColor(Color color) setColor是Graphics类中的一个函数，主要是设置颜色作用，其中参数是Color类中的一个对象，用于定义自己的颜色，里面的变量的是RGB,定义的方法：Color color=newe Color(R,G,B) 代码 123456789101112131415161718192021222324252627282930 import java.awt.Graphics; import javax.swing.JFrame; import javax.swing.JPanel; public class DrawLineFrame extends JFrame &#123; DrawLinePanel linePanel = new DrawLinePanel(); public static void main(String args[]) &#123; // 主函数 DrawLineFrame frame = new DrawLineFrame(); // 创建一个继承JFrame的一个类对象 frame.setVisible(true); // 设置窗体可见，true为可见，false为不可见 &#125; public DrawLineFrame() &#123; super(); setTitle("绘制直线"); // 设置窗体的标题 setBounds(100, 100, 273, 167); // 设置窗体的显示位置和大小 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置窗体的关闭方式，具体见官方文档 add(linePanel); // 将继承Jpanel类的容器对象添加在窗体中 &#125; class DrawLinePanel extends JPanel &#123; // 继承在JPanel类的一个内部类，用于定义直线 public void paint(Graphics g) &#123; // 重写JCommponent类中的paint方法，用来绘制直线 Color color=new Color(Color.Red);//这里用的是Color提供的颜色，当然读者也可以自己定义RGB颜色 g.setColor(Color);//将颜色作用于绘图上下文 g.drawLine(70, 50, 180, 50); // 调用方法 g.drawLine(70, 80, 180, 80); // 第二条直线 g.drawLine(110, 10, 140, 120); // 第三条 &#125; &#125;&#125; 绘制矩形主要用到的函数是：public abstract void drawRect(int x,int y,int width,int height)这里的x,y是矩形左上角的坐标，width，height是矩形的长和宽 拓展fillRect(int x,int y,int width,int height):绘制实心矩形 代码 1234567891011121314151617181920212223242526import java.awt.Graphics;import javax.swing.JFrame;import javax.swing.JPanel;public class DrawRectangleFrame extends JFrame &#123;DrawRectanglePanel rectPanel = new DrawRectanglePanel(); // 创建面板类的实例public static void main(String args[]) &#123; // 主方法 DrawRectangleFrame frame = new DrawRectangleFrame(); // 创建窗体类的实例 frame.setVisible(true); // 显示窗体&#125;public DrawRectangleFrame() &#123; super(); // 调用超类的构造方法 setTitle("绘制矩形"); // 窗体标题 setBounds(100, 100, 269, 184); // 窗体的显示位置和大小 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 窗体关闭方式 add(rectPanel); // 将面板类的实例添加到窗体容器中&#125;class DrawRectanglePanel extends JPanel &#123; // 创建内部面板类 public void paint(Graphics g) &#123; // 重写paint()方法 g.drawRect(30, 40, 80, 60); // 绘制空心矩形 g.fillRect(140, 40, 80, 60); // 绘制实心矩形 &#125;&#125;&#125; 绘制椭圆 函数：public abstract void drawOval(int x,int y,int width,int height),其中x,y是外切矩形的左上角的坐标，width，height是长宽 拓展 其中将令width=height，即是一个圆了，fillOval(int x,int y,int width,int height)用来绘制实心的椭圆 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 package com.zzk; import java.awt.Graphics; import javax.swing.JFrame; import javax.swing.JPanel; public class DrawEllipseFrame extends JFrame &#123; DrawEllipsePanel ellipsePanel = new DrawEllipsePanel(); // 创建面板类的实例 public static void main(String args[]) &#123; // 主方法 DrawEllipseFrame frame = new DrawEllipseFrame(); // 创建窗体类的实例 frame.setVisible(true); // 显示窗体 &#125; public DrawEllipseFrame() &#123; super(); // 调用超类的构造方法 setTitle("绘制椭圆"); // 窗体标题 setBounds(100, 100, 269, 222); // 窗体的显示位置和大小 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 窗体关闭方式 add(ellipsePanel); // 将面板类的实例添加到窗体容器中 &#125; class DrawEllipsePanel extends JPanel &#123; // 创建内部面板类 public void paint(Graphics g) &#123; // 重写paint()方法 g.drawOval(30, 20, 80, 50); // 绘制空心椭圆 g.drawOval(150, 10, 50, 80); // 绘制空心椭圆 g.fillOval(40, 90, 50, 80); // 绘制实心椭圆 g.fillOval(140, 110, 80, 50); // 绘制实心椭圆 &#125; &#125; &#125; ``` &gt;&gt;## 绘制圆弧&gt;&gt;&gt;主要用到的函数`public astract void drawArc(int x,int y,int width,int height,int startAngle,int arcAngle)`，其中x,y是要绘制圆弧的左上角的坐标，width，height是要绘制的长宽，startAngle是开始角度，arcAngle是相对于开始角度而言的，弧跨越的角度，&gt;&gt;&gt;&gt;### 拓展:&gt;&gt;&gt;&gt;&gt;fillArc(int x,int y,int width,int height,int startAngle,int arcAngle)用来绘制实心圆弧&gt;&gt;&gt;&gt;&gt;当然你也可以用这个来绘制扇形，用drawLine方法将圆弧的两端连起来就可以了，不过这个对坐标的精确度就要求很高了，暂时不想费那个脑筋来搞了&gt;&gt;&gt;&gt;### 代码```java package com.zzk; import java.awt.Graphics; import javax.swing.JFrame; import javax.swing.JPanel; public class DrawArcFrame extends JFrame &#123; DrawArcPanel arcPanel = new DrawArcPanel(); // 创建面板类的实例 public static void main(String args[]) &#123; // 主方法 DrawArcFrame frame = new DrawArcFrame(); // 创建窗体类的实例 frame.setVisible(true); // 显示窗体 &#125; public DrawArcFrame() &#123; super(); // 调用超类的构造方法 setTitle("绘制圆弧"); // 窗体标题 setBounds(100, 100, 269, 184); // 窗体的显示位置和大小 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 窗体关闭方式 add(arcPanel); // 将面板类的实例添加到窗体容器中 &#125; class DrawArcPanel extends JPanel &#123; // 创建内部面板类 public void paint(Graphics g) &#123; // 重写paint()方法 g.drawArc(20, 20, 80, 80, 0, 120); // 绘制圆弧 g.drawArc(20, 40, 80, 80, 0, -120); // 绘制圆弧 g.drawArc(150, 20, 80, 80, 180, -120);// 绘制圆弧 g.drawArc(150, 40, 80, 80, 180, 120); // 绘制圆弧 &#125; &#125; &#125; 绘制多边形 主要用到的函数是：public abstract void drawPolygon(int[] xpoints,int[] ypoints,int npoints)，其中xpoints：要绘制多边形的x坐标组，ypoints是要绘制多边形的y坐标组，npoints是多边形的n条边 拓展 fillPolygon(...)是绘制实心多边形的函数 代码 1234567891011121314151617181920212223242526package com.zzk;import java.awt.Graphics;import javax.swing.JFrame;import javax.swing.JPanel;public class DrawSectorFrame extends JFrame &#123;DrawSectorPanel sectorPanel = new DrawSectorPanel(); // 创建面板类的实例public static void main(String args[]) &#123; // 主方法 DrawSectorFrame frame = new DrawSectorFrame(); // 创建窗体类的实例 frame.setVisible(true); // 显示窗体&#125;public DrawSectorFrame() &#123; super(); // 调用超类的构造方法 setTitle("绘制填充扇形"); // 窗体标题 setBounds(100, 100, 278, 184); // 窗体的显示位置和大小 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 窗体关闭方式 add(sectorPanel); // 将面板类的实例添加到窗体容器中&#125;class DrawSectorPanel extends JPanel &#123; // 创建内部面板类 public void paint(Graphics g) &#123; // 重写paint()方法 g.fillArc(40, 20, 80, 80, 0, 150); // 绘制填充扇形 g.fillArc(140, 20, 80, 80, 180, -150);// 绘制填充扇形 g.fillArc(40, 40, 80, 80, 0, -110); // 绘制填充扇形 g.fillArc(140, 40, 80, 80, 180, 110); // 绘制填充扇形 &#125;&#125;&#125; 绘制文本 主要用到的函数是：public abstract void drawString(String value,int x,int y),其中value是要绘制的文本，x,y是第一个字的坐标 拓展 SetFont(Font font):这个函数是用来设置文本的字体大小，颜色的，其中参数font是Font类中的 代码 12345678910111213141516171819202122232425262728293031323334353637package com.zzk;import java.awt.Font;import java.awt.Graphics;import javax.swing.JFrame;import javax.swing.JPanel;public class TextFontFrame extends JFrame &#123;ChangeTextFontPanel changeTextFontPanel = new ChangeTextFontPanel(); // 创建面板类的实例public static void main(String args[]) &#123; // 主方法 TextFontFrame frame = new TextFontFrame(); // 创建窗体类的实例 frame.setVisible(true); // 显示窗体&#125;public TextFontFrame() &#123; super(); // 调用超类的构造方法 setTitle("设置文本的字体"); // 窗体标题 setBounds(100, 100, 333, 199); // 窗体的显示位置和大小 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 窗体关闭方式 add(changeTextFontPanel); // 将面板类的实例添加到窗体容器中&#125;class ChangeTextFontPanel extends JPanel &#123; // 创建内部面板类 public void paint(Graphics g) &#123; // 重写paint()方法 String value = "明日编程词典社区"; int x = 40; // 文本位置的横坐标 int y = 50; // 文本位置的纵坐标 Font font = new Font("华文行楷", Font.BOLD + Font.ITALIC, 26); // 创建字体对象 g.setFont(font); // 设置字体 g.drawString(value, x, y); // 绘制文本 value = "http://community.mrbccd.com"; x = 10; // 文本位置的横坐标 y = 100; // 文本位置的纵坐标 font = new Font("宋体", Font.BOLD, 20); // 创建字体对象 g.setFont(font); // 设置字体 g.drawString(value, x, y); // 绘制文本 &#125;&#125;&#125; 补充 字体样式包括Font.BLOD(粗体)，Font.ITALIC(斜体)，Font.PLAIN(普通字体)，其中如果要设置两种样式，可以用”+”连接，如：Font.BLOD+Font.ITALIC，这样就会同时设置了斜体和粗体样式 以上是本人的学习成果，通过不断的学习和探索，发现网上没有什么系统的学习java图形处理的文章，就下定决心准备好好写，于是前几天就花了一晚上的时间搭建了博客，以前都是在CSDN上写的，发现在那上面写，没有逼格，为了提高逼格，自己撸了一个博客，让我来自由发挥，另外喜欢编程的朋友可以加我的联系方式，我们可以一起探讨，在下面留言也是可以的哦,联系方式可以在我的关于我可以找到 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
  
  
</search>
