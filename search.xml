<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JSP总结三(JSTL核心标签库的使用)]]></title>
      <url>%2F2017%2F09%2F22%2FJSP%E6%80%BB%E7%BB%93%E4%B8%89-JSTL%E6%A0%B8%E5%BF%83%E6%A0%87%E7%AD%BE%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[JSP总结三(JSTL核心标签库的使用)简介 其实在我们编写JSP网页的时候是不希望在JSP页面中出现Java代码的，这里我们就要使用JSTL的核心标签库来实现。 想要使用JSTL，一定要填上这句话：&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; 属性处理与输出标签属性处理标签 在定义变量的时候，我们难免会用到Java代码，但是这里我们介绍&lt;c:set&gt;标签，这个能够实现变量的定义 &lt;c:set&gt;标签中的属性有 var(定义的变量)、value(变量的值)、target(为JavaBean对象赋值的时候使用)、scope(设置变量的存活范围，有request,session,application,page)、property(JavaBean的变量) 使用set标签相当于调用存活范围内的setAttribute()方法来绑定属性 定义一个普通的变量: 123&lt;%--x的值为10，这句话相当于String x="10" --%&gt;&lt;c:set var="x" value="10"&gt;&lt;/c:set&gt; 定义session范围的变量(当然还可以定义其他存活范围的变量，这里就不一一讲了) 123456789&lt;%--seesion范围的变量代表整个会话期间都是可以共享这个变量的，相当于下面这句话： session.setAttribute("x",100); 在另外一个JSP文件中可以使用下面的语句得到其中的值： session.getAttribute("x"); &lt;c:out value="$&#123;sessionScope.x&#125;"&gt;&lt;/c:out&gt;--%&gt;&lt;c:set var="x" value="100" scope="session"&gt;&lt;/c:set&gt; 设置JavaBean对象的值： 12345678&lt;%--获取JavaBean的对象person,如果没有那么就是直接创建一个对象，范围为session,下面可以用到 --%&gt;&lt;jsp:useBean id="person" class="com.Person" scope="session"&gt;&lt;/jsp:useBean&gt;&lt;%-- target是对象的person，这里使用EL表达式，得到session范围内的Person对象 --%&gt;&lt;c:set target="$&#123;sessionScope.person &#125;" property="username" value="陈加兵"&gt;&lt;/c:set&gt;&lt;%-- 输出变量的username的值，这里使用的EL表达式 相当于 session.getAttribute("person").getUsername() --%&gt;&lt;c:out value="$&#123;sessionScope.person.username &#125;"&gt;&lt;/c:out&gt; 如果设置的值太冗长了，那么可以在标签体的中间设置 1&lt;c:set scope="request"&gt;陈加兵&lt;/c:set&gt; 移除变量 使用的是&lt;c:remove&gt;(一定要指定存活范围) 1234&lt;%--移除session范围内的变量x 相当于 session.removeAttribute("x") 这里一定要指定范围--%&gt;&lt;c:remove var="x" scope="session"/&gt; 输出标签 &lt;c:out&gt;相当于out.println()方法，是一个用来向网页中输出内容的 其中的属性有value (输出的内容，其中可以是JEL的${}或者一个字符串) ，escapeXml(这个使用来控制是否将输出的内容中有html标签的是否用替代字符替换，默认为true表示用替代字符替换),default(如果输出的内容为null或者为空的时候那么就直接不显示任何内容，但是我们可以定义default的值来默认显示的值) 使用EL表达式输出 123&lt;%--输出request范围内的属性x 相当于 out.println(request.getAttribute("x"))--%&gt;&lt;c:out value="$&#123;requestScope.x&#125;"&gt;&lt;/c:out&gt; 直接使用字符串输出一个值 12&lt;c:out value="我是陈加兵"&gt;&lt;/c:out&gt; 输出html语句 123&lt;%--设置escapeXml为false--%&gt;&lt;c:out value="&lt;h1&gt;我是陈加兵&lt;/h1&gt;" escapeXml="false"&gt;&lt;/c:out&gt; 指定输出的默认的内容 123&lt;%--如果$&#123;param.username&#125;为空，那么就输出0--%&gt;&lt;c:out value="$&#123;param.username&#125;" default="0"&gt;&lt;/c:out&gt; 流程处理标签 流程处理就是判断，循环语句 if判断语句 &lt;c:if&gt;可以判断语句是否正确，如果正确即可执行，但是这个标签没有else语句，只能处理判断为正确的结果其中的属性有test，这个是设置判断条件的，如果为true即可执行，反之不执行，var是保留判断结果的test中的判断条件既可以是EL表达式也可以是&lt;%=%&gt; 1234567 &lt;c:set var="salary" value="$&#123;3000 &#125;"&gt;&lt;/c:set&gt;&lt;%-- test中写的是判断条件，如果为true那么才执行，这里写的是EL表达式，当然也是可以用&lt;%=%&gt; --%&gt; &lt;c:if test="$&#123;salary&gt;2000 &#125;"&gt; &lt;c:out value="这个员工的工资大于2000"&gt;&lt;/c:out&gt;&lt;/c:if&gt; 高级判断 前面的说过的&lt;c:if&gt;仅仅当判断为真时才执行，但是我们想要当不为真时也执行语句，这时我们要使用&lt;c:choose&gt;,&lt;c:when&gt;,&lt;c:otherwise&gt; 123456789101112131415161718 &lt;%-- 判断题必须在choose中 --%&gt;&lt;c:choose&gt; &lt;%-- 如果提交的username和password都对的话，那么就登录成功 相当于if --%&gt; &lt;c:when test='$&#123;param.username=="陈加兵" &amp;&amp; param.password=="123456"&#125;'&gt; &lt;h1&gt; &lt;c:out value="$&#123;param.username &#125;"&gt;&lt;/c:out&gt; 登录成功 &lt;/h1&gt; &lt;/c:when&gt; &lt;%-- 相当于else --%&gt; &lt;c:otherwise&gt; &lt;h1&gt; &lt;c:out value="$&#123;param.username &#125;"&gt;&lt;/c:out&gt; 登录失败 &lt;/h1&gt; &lt;/c:otherwise&gt;&lt;/c:choose&gt; 网页导入和重定向标签网页导入标签 之前学过JSP中的网页导入，一个是静态导入，一个是动态导入，详情请看上篇文章。 在JSTL中也有一个标签(&lt;c:import&gt;)，用于动态导入网页,并且还可以使用&lt;c:param&gt;设置传入的参数 12345 &lt;%-- url就是要导入的网页，name是设置初始值的变量，value是设置的值。在demo1.jsp中可以使用 request.getParameter(String name)取得参数 --%&gt;&lt;c:import url="demo1.jsp"&gt; &lt;c:param name="username" value="陈加兵"&gt;&lt;/c:param&gt; &lt;c:param name="password" value="123456"&gt;&lt;/c:param&gt;&lt;/c:import&gt; 除了导入web应用程序中的网页，我们还可以导入非目前web应用程序中的网页 12&lt;%--导入百度的首页，并且设置字符集为utf-8，注意这里一定要设置网页的字符集格式和当前的jsp格式一样，否则会出现乱码--%&gt;&lt;c:import url="http://www.baidu.com"&gt;&lt;/c:import charEncoding="utf-8"&gt; 重定向标签 之前的重定向必须使用HttpServletResponse的sendRedirect()方法 现在我们可以使用JSTL标签&lt;c:redirect url&gt; 1&lt;c:redirect url="demo1.jsp"&gt;&lt;/c:rediect&gt; 当然我们也是可以传入参数的，使用&lt;c:param name=&quot;&quot; value=&quot;&quot;&gt; 123&lt;c:redirect url="demo1.jsp"&gt; &lt;c:param name="username" value="陈加兵"/&gt;&lt;/c:rediect&gt; 错误处理标签 在之前的JSP文件中，必须定义errorPage属性才能跳转到指定的页面或者处理错误 现在我们使用JSTL标签&lt;c:catch&gt;,可以捕捉异常，如果有异常就会将异常对象保存下来 1234567891011 &lt;%--捕捉异常，如果有了异常，那么保存在error变量中 --%&gt;&lt;c:catch var="error"&gt; $&#123;10/0 &#125;&lt;/c:catch&gt;&lt;%-- 如果捕捉到了异常，那么error就不是null --%&gt;&lt;c:if test="$&#123;error!=null &#125;"&gt; &lt;h1&gt; &lt;c:out value="$&#123;error.message &#125;"&gt;&lt;/c:out&gt; &lt;/h1&gt;&lt;/c:if&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JSP总结二(动作元素)]]></title>
      <url>%2F2017%2F09%2F20%2FJSP%E6%80%BB%E7%BB%93%E4%BA%8C-%E5%8A%A8%E4%BD%9C%E5%85%83%E7%B4%A0%2F</url>
      <content type="text"><![CDATA[JSP总结二(动作元素)&lt;jsp:include&gt; 前面介绍了一种指令元素include，那是一种静态包含JSP文件，这个标签是动态包含一个JSP页面，也就是被包含的JSP页面和原JSP将合并在一起，转译为一个Servlet类。这是有一定的局限性的，如变量的定义不能重复。 动态的包含JSP文件即是被包含的JSP和原JSP分别转译为一个Servlet类，这就保证了其中的变量可以重复定义了，因为并不是在一个类中了 &lt;jsp:include page=&quot;相对的文件路径&quot;&gt;&lt;/jsp:include&gt;这种标签转译为Servlet和指令元素include是一样的 123456&lt;%--动态导入在编译的时候是两个jsp文件各自编译成一个Servlet文件，因此其中的变量是不可以共享的，在当前页面中还是可以定义导入页面定义的变量 --%&gt;&lt;jsp:include page="form.jsp"&gt; //定义的param可以在form.jsp中使用request.getParameter(String name)取得其中的值 &lt;jsp:param value="陈加兵" name="username"/&gt; &lt;jsp:param value="123456" name="password"/&gt;&lt;/jsp:include&gt; &lt;jsp:forward&gt; 这是将请求转发给另外一个JSP或者Servlet文件处理，这个和RequestDispatcher是一样的原理，就是Servlet中转发123456//绑定属性，在login.jsp中可以获取request.setAttribute("username","陈加兵");//当前页面的请求将会交给login.jsp文件处理&lt;jsp:forward page='login.jsp'&gt;&lt;/jsp:forward&gt; &lt;jsp:useBean&gt; 这个动作元素是用来搭配JavaBean组件的标准标签。JavaBean必须满足下面的条件： 必须实现Java.io.Serializable接口 没有公开的(public)类变量 具有无参构造函数（默认的都有） 具有公开的设置方法（setter）与取值方法（getter） 下面就是一个JavaBean组件 12345678910111213141516171819202122232425262728293031323334353637383940package com;import java.io.Serializable;public class Person implements Serializable &#123; //这里的变量的值一定要和表单的中的name属性的值一样，否则不能获取 private String username; private String password; private int age; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Boolean Checkout()&#123; return "陈加兵".equals(username)&amp;&amp;"123456".equals(password); &#125;&#125; 使用JavaBean的目的是减少Scriptlet的使用。其中搭配&lt;jsp:useBean&gt;来使用这个JavaBean,并且使用&lt;jsp:setProperty&gt;与&lt;jsp:getProperty&gt;对javaBean进行设值与取值 注意javaBean一定要搭配表单使用，因为设值的值其实是隐式的调用request.getParameter(String name)来获取表单的值 下面是一个登录的表单(注意这里的input中的name属性的值一定要和JavaBean组件类的成员变量的名字一样) 123456789101112131415161718192021&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--提交给Demo1.jsp处理，下面就实现Demo1.jsp--&gt;&lt;form action="Demo1.jsp"&gt; &lt;label&gt;姓名：&lt;/label&gt; &lt;input type="text" name="username"&gt; &lt;label&gt;密码：&lt;/label&gt; &lt;input type="password" name="password"&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 下面我们写一个JSP文件设置JavaBean 12345678910111213141516171819202122232425262728293031323334353637383940&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%--使用JavaBean person是Person创建的对象，相当于 Person person=new Person() 其中class是JavaBean的类所在的路径(在com包下的Person文件中) id就是相当于创建的对象 --%&gt; &lt;jsp:useBean id="person" class="com.Person"&gt;&lt;/jsp:useBean&gt; &lt;%--为username和password设置值,相当于下面的语句 person.setUsername(request.getParameter("username")); person.setPassword(request.getParameter("password")); JavaBean中的变量一定要和表单中的值一样，否则就不能对应，出现错误 其中name就是指定上面的id，即是使用的对象，property就是指定变量 --%&gt; &lt;jsp:setProperty property="uesrname" name="person"/&gt; &lt;jsp:setProperty property="password" name="person"/&gt; &lt;%--age是另外的变量，并没有对应着表单的name属性，因此我们可以单独的为其设置值，使用value实行即可设置，这里不必考虑类型，因为在内部会自动转换成JavaBean中的类型 --%&gt; &lt;jsp:setProperty property="age" name="person" value="20"/&gt; &lt;%--获取设置的值，相当于下面的语句： person.getUsername(); person.getPassword(); person.getAge(); --%&gt; &lt;h1&gt;&lt;jsp:getProperty property="username" name="person" /&gt;&lt;/h1&gt; &lt;h1&gt;&lt;jsp:getProperty property="password" name="person" /&gt;&lt;/h1&gt; &lt;h1&gt;&lt;jsp:getProperty property="age" name="person" /&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 其实我们还可以不但可以将表单中的值赋值给变量，还可以使用value和param自己设置 1234567&lt;%-- 将请求的url中的password的值赋值给username，注意这里的使用的get的请求的话，提交的时候url会有请求值的 http://localhost:8080/web2/JSP/Demo1.jsp?username=%E9%99%88%E5%8A%A0%E5%85%B5&amp;password=123456 --%&gt; &lt;jsp:setProperty property="username" name="person" param="password"/&gt; &lt;%--age是另外的变量，并没有对应着表单的name属性，因此我们可以单独的为其设置值，使用value实行即可设置，这里不必考虑类型，因为在内部会自动转换成JavaBean中的类型 --%&gt; &lt;jsp:setProperty property="age" name="person" value="20"/&gt; JavaBean的存活范围 Scope属性决定了javabean对象的存在的范围。可选值有: page(默认值) request session application 1&lt;jsp:useBean id="person" class="com.anllin.bean.Person" scope="page"&gt;&lt;/jsp:useBean&gt; 在page范围 客户每次请求访问jsp页面时，都会创建一个javabean对象。JavaBean对象的有效范围就是当前的jsp文件中，如果不在当前Jsp中，那么就不可以使用该JavaBean对象中设置的值 比如使用forward转发给另外一个JSP文件，那么此时就会再创建一个JavaBean对象，原来页面的JavaBean对象并没有传过来，也就不能使用其中的值，这个和变量的共享是一个道理的，这个JavaBean对象只能在当前的Jsp文件中调用，不能实现共享 在request范围 客户每次请求访问jsp页面时，都会创建新的javabean对象。有效范围为： 客户请求访问的当前jsp网页。 和当前网页共享一个客户请求的网页，即当前jsp网页中&lt;%@include %&gt;指令以及&lt;forward&gt;标记包含的其他jsp文件,也就是转发和包含的Jsp文件也是可以共享这个JavaBean对象的，这个和Servlet中的request是一样的，一旦转发了，就可以通过setAttribute()设置属性，那么在转发的页面中就可以访问这个属性 当所有共享同一个客户请求的jsp页面执行完毕并向客户端发加响应时，javabean对象结束生命周期。 javabean对象作为属性保存在httpServletRequest对象中，属性名javabean的id,属性值为javabean对象，因此可以通过HttpRequest.getAttribute()方法取得javabean对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 //Demo1.jsp文件 表单请求提交的JSp文件 &lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt; &lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%--设置scope属性为request，这个是必须的，这里的JavaBean对象为person--%&gt; &lt;jsp:useBean id="person" class="com.Person" scope="request"&gt;&lt;/jsp:useBean&gt; &lt;jsp:setProperty property="uesrname" name="person"/&gt; &lt;jsp:setProperty property="password" name="person"/&gt; &lt;jsp:setProperty property="age" name="person" value="20"/&gt;&gt; e &lt;%--转发请求到Demo2.jsp文件中，那么就可以在Demo.jsp中共享person对象了--%&gt; &lt;jsp:forward page="Demo2.jsp"&gt;&lt;/jsp:forward&gt;&lt;/body&gt;&lt;/html&gt;//Demo2.jsp &lt;%@page import="com.Person"%&gt; &lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt; &lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%-- 使用JavaBean,这里的scope是必须的，一定要和Demo1.jsp一样，id也要一样 --%&gt; &lt;jsp:useBean id="person" class="com.Person" scope="request"&gt;&lt;/jsp:useBean&gt; &lt;%--获取username的值 --%&gt; &lt;jsp:getProperty property="username" name="person"/&gt; &lt;% //使用HttpServletRequest获取对象person Person p=(Person)request.getAttribute("person"); out.println(p.getUsername()); //获取username的值 %&gt; &lt;/body&gt; &lt;/html&gt; 在session范围内 我们知道HttpSession是可以在会话期间实现数据共享的，只要是同一个项目中的Jsp文件都是可以共享这个JavaBean对象，但是并不是永久的，因为会话也是有时间限制的， javabean对象作为属性保存在HttpSession对象中，属性名为javabean的id,属性值为javabean对象。除了可以通过javabean的id直接引用javabean对象外，也可以通过HttpSession.getAttribute（）方法取得javabean对象 一定要注意在每一个&lt;jsp:useBean&gt;中都要写上scope=&quot;session&quot; 在application范围内 我们知道ServletContext存在于整个web应用的生命周期，这个不像session，一旦设置的会话时间结束，那么就不存在了，这个是永远存在的，只要web程序在继续 javabean对象作为属性保存在application对象中，属性名为javabean的id，属性值为javabean对象，除了可以通过javabean的id直接引用对象外，也可以通过javabean的application.getAttribute()方法取得javabean对象 重要的属性 其实不仅仅可以对于表单中请求可以转换为对象的值，上面我们说过了存活范围，其实只要在这个请求范围内，并且将对象绑定到响应的属性上面，那么就可以在jsp文件中使用改标签接收其值。 其实一般在表单提交之后，我们会使用Sevlet文件验证是否密码和用户名正确，那么就不是直接提交给jsp文件，此时就像上面说过的，不影响标签的使用，只要将JavaBean对象绑定到响应范围的属性上，便是可以实现对象的共享，代码如下： ServletDemo文件 123456789101112131415161718192021222324252627282930313233343536package com;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class ServletDemo extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //创建对象，并且设置值 Person person=new Person(); person.setUsername("陈加兵"); person.setPassword("123456"); //将JavaBean对象绑定到request上，相当于存活范围为request //注意这里的键值一定要是和对象的名称一样，否则不行 request.setAttribute("person", person); //转发请求到jsp文件，下面我们就将在jsp文件中使用JavaBean标签接收 RequestDispatcher dispatcher=request.getRequestDispatcher("JSP/demo1.jsp"); dispatcher.forward(request, response); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; &#125; demo1.jsp:上面文件转发过来的，接收JavaBean对象 123456789101112131415161718&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%-- 使用标签接收转发过来的JavaBean对象，scope一定要设置为request,id就是传过来的对象，一定要和前面的名称一样，下面的语句相当于： Person person=(Person)request.getAttribute("person"); --%&gt;&lt;jsp:useBean id="person" class="com.Person" scope="request"&gt;&lt;/jsp:useBean&gt;&lt;h1&gt;&lt;jsp:getProperty property="username" name="person"/&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 参考文章http://www.cnblogs.com/zfc2201/archive/2011/08/17/2143615.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JSP总结一(标签）]]></title>
      <url>%2F2017%2F09%2F20%2FJSP%E6%80%BB%E7%BB%93%E4%B8%80-%E6%A0%87%E7%AD%BE%EF%BC%89%2F</url>
      <content type="text"><![CDATA[JSP总结一(标签)生命周期 JSP文件在部署到web服务器上的时候还是会编译成Servlet文件，因此JSP的生命周期和Servlet是一样的，都是有_JSPInit()，_JSPService(),_JSPDestroy()方法的 指示元素 在jsp中有三个指示类型，分别为：page,include,tablig。 page page指示类型告知容器如何转译目前的JSP网页。 1&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" import="java.util.*"%&gt; language指定解析语言，contentType表明为html文件，pageEncoding告诉容器转译及编译的时候如何处理这个这个JSP网页中的额中文编码，import是导入包的作用，如果有多个包导入，那么可以使用逗号隔开。 errorPage用于设置当JSP运行错误而产生异常的时候，该转发哪一个页面处理这个异常，可以自己定义一个异常的JSP或者html文件显示这个异常，但是这个必须和isErrorPage配合使用，必须在处理异常的page指令中协商isErrorPage=&quot;true&quot; 还有一些其他的属性，自己可以看看菜鸟教程上的内容 include include是用于静态的包含其他页面中的内容。这个还是很重要的，如果在网页中每一张页面都需要使用一样的导航栏，导入一样的css，js文件，那么可以将这些内容单独做一个jsp文件或者html文件，要使用的时候就直接包含即可。 12 //file指定文件的相对路径 &lt;%@include file="daoru.jsp" %&gt; 其实上面的语句在Servlet语句相当于下面这句话： 12RequestDispatcher dis=request.getRequestDispatcher();dis.include(request,response); 注意这句话写在页面的哪里，那么就将其中的内容导入到哪里，比如要导入css，js文件，那么直接在head标签中直接导入 静态导入的方式在部署到服务器会自动和当前的JSP文件编译为一个Servlet文件，也就是在一个Servlet类中。因此在包含的JSP文件中如果定义了变量或者方法，那么在当前的JSP页面中就不能重复定义，否则将会出现变量重复的错误，代码如下： 1234567891011121314151617181920212223242526272829303132//Demo1.jsp&lt;%@ page language="java" contentType="text/html; charset=UTF-8"pageEncoding="UTF-8"%&gt;&lt;% String name="陈加兵"; int age=22;%&gt;//Demo2.jsp&lt;%@ page language="java" contentType="text/html; charset=UTF-8"pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;//包含Demo1.jsp文件&lt;%@ include file="Demo1.jsp" %&gt;&lt;% //String name="chenji"; //这里不能重复定义，否则将会报错%&gt;//直接输出name的值 &lt;h1&gt;&lt;%=name%&gt;&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 注意这里的Demo1.jsp文件中一定不能重复的出现&lt;html&gt;标签，因为包含的时候是全部内容都是包含到当前页面中，如果出现重复的html标签代码就会混乱。 声明元素 &lt;%! &gt; 这就是声明元素，主要是用来定义类成员和方法声明的。其中不可以出现循环语句等，只能出现定义语句，当然在定义方法的时候函数体中可以出现其他的语句。 声明元素中的内容在编译的都将变成Servlet中的类的成员变量和方法 1234567891011 &lt;%! //变量 String name="陈加兵"; private int age=20; //方法 public void display()&#123; System.out.println(name+":"+age);&#125; %&gt; Scriptlet &lt;% %&gt;这个是写正常的java语句的，其中将会转译成_jspService()方法中的内容 12345&lt;% String name="陈加兵"; request.setAttribute("name",name);%&gt; 表达式元素 &lt;%= %&gt; 其中可以直接写一个表达式 123&lt;h1&gt;&lt;%= new Date() %&gt; &lt;/h1&gt;&lt;h1&gt;&lt;%= 2+3 %&gt; &lt;/h1&gt;&lt;h1&gt;&lt;%= request.getAttribute("name") %&gt; &lt;/h1&gt; 注释元素 &lt;%----%&gt;这是JSP的注释，在浏览器中查看源代码的时候是看不到的 &lt;!-- --&gt; 这是html中的注释，在网页源代码中是可以看到的 隐含对象 request 转译后对应的是HttpServletRequest resposne 译后对应的是HttpServletResponse out 译后对应的是JspWriter对象，其内部关系一个PrintWriter对象 Config 译后对应的是ServletConfig session 译后对应的是HttpSession application 译后对应的是ServletContext pageContext 译后对应的是PageContext对象 exception 译后对应的是Throwable对象 page 译后对应的是this]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Servlet总结五(监听器)]]></title>
      <url>%2F2017%2F09%2F19%2FServlet%E6%80%BB%E7%BB%93%E4%BA%94-%E7%9B%91%E5%90%AC%E5%99%A8%2F</url>
      <content type="text"><![CDATA[Servlet总结五(监听器)分类 监听器按其功能可以分为三种，分别是生命周期监听器(ServletContextListener,ServletRequestListener,HttpSessionListener)，属性监听器(ServletRequestAttributeListener,HttpSessionAttributeListener,ServletContextAttributeListener)，会话属性监听器(HttpSessionBindingListener,HttpSessionActivationListener)。下面我们将会详细的介绍这三种监听器。 生命周期监听器生命周期就是从创建到销毁，因此顾名思义，就是在对象创建的时候会触发，销毁的时候也会触发 ServletContextListener 前面我们说过ServletContext是上下文的，是应用程序共享的，当应用程序启动就会生成的。在应用程序初始化或者结束前，会分别调用contextInitialized()和contextDestroyed()方法，通过传入的ServletContextEvent取得ServletContext对象。 实例 下面读取设置的初始化参数，并且在监听器中将其绑定为属性实现全文共享 web.xml的文件，主要是设置初始化属性值，前面已经讲过 1234567891011121314151617&lt;!-- 设置ServletContext初始参数 --&gt; &lt;context-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;param-value&gt;陈加兵&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;123456&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 设置ServletContext初始参数 --&gt; &lt;!-- 设置监听器，ServletContextListener --&gt; &lt;listener&gt; &lt;listener-class&gt;com.ServletContextListenerDemo&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 设置监听器，ServletContextListener --&gt; 下面是实现监听器的功能 123456789101112131415161718192021222324252627282930313233343536373839package com;import java.util.Enumeration;import javax.servlet.ServletContext;import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;public class ServletContextListenerDemo implements ServletContextListener &#123; // ServletContext销毁的时候触发 public void contextDestroyed(ServletContextEvent arg0) &#123; //当销毁的时候就移除其中绑定的属性 ServletContext context = arg0.getServletContext(); // 获取所有属性的名称 Enumeration enumeration = context.getAttributeNames(); while (enumeration.hasMoreElements()) &#123; String name = (String) enumeration.nextElement(); // 移除绑定的属性 context.removeAttribute(name); &#125; &#125; // ServletContext生成的时候触发，一般当web程序应用的时候就会初始化ServletContext参数 public void contextInitialized(ServletContextEvent arg0) &#123; //获取ServletContext对象 ServletContext context = arg0.getServletContext(); // 读取参数 String name = context.getInitParameter("username"); String password = context.getInitParameter("password"); // 绑定属性，用于全文共享 context.setAttribute("username", name); context.setAttribute("password", password); &#125;&#125; ServletRequestListener 这是在对象ServletRequest对象生成或结束时，会触发的监听器。当生成的时候会触发requestInitialized(),结束时会触发requestDestroyed()方法。ServletRequest对象生成一般在浏览器发出请求，或者转发重定向。注意这个触发是在Servlet的doGet()或者doPost()之前。 实例 ServletRequestListener文件:在ServletRequest对象生成时绑定属性 1234567891011121314151617181920212223242526package com;import javax.servlet.ServletRequestEvent;import javax.servlet.ServletRequestListener;import javax.servlet.http.HttpServletRequest;public class ServletRequestListenerDemo implements ServletRequestListener &#123; //在ServletRequest对象结束时触发 public void requestDestroyed(ServletRequestEvent arg0) &#123; HttpServletRequest request=(HttpServletRequest)arg0.getServletRequest(); &#125; //在ServletRequest对象生成时触发(比如浏览器请求) public void requestInitialized(ServletRequestEvent arg0) &#123; //强制转换成其子类 HttpServletRequest request=(HttpServletRequest) arg0.getServletRequest(); //绑定属性，这里的request和触发其的Servlet中的是一样的，因此可以实现共享 //就好像forward,include一样 request.setAttribute("login", "atuo"); //绑定属性 &#125;&#125; Servlet文件：取得绑定的值 123456public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; PrintWriter pWriter=response.getWriter(); pWriter.println(request.getAttribute("login")); //取得上面监听器绑定的值 &#125; web.xml文件 12345&lt;!-- 设置监听器，ServletRequestListener --&gt; &lt;listener&gt; &lt;listener-class&gt;com.ServletRequestListenerDemo&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 设置监听器，ServletRequestListener --&gt; HttpSessionListener 在HttpSession对象初始化后或者结束时，会分别调用sessionCreated()和sessionDestroyed()方法，你可以通过传入的HttpSessionEvent来取得HttpSession，以针对会话对象做出响应的创建或者结束处理操作 实例 Servlet文件：用来验证登录是否正确，如果正确就创建HttpSession对象，并且绑定属性用来实现自动登录 12345678910111213141516171819202122232425262728293031323334353637package com;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import javax.xml.registry.infomodel.User;public class ServletDemo3 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String name=request.getParameter("username"); String password=request.getParameter("password"); if ("chenjiabing".equals(name)&amp;&amp;"123456".equals(password)) &#123; //用户名和密码正确创建对象 HttpSession session=request.getSession(); session.setAttribute("login", "auto"); &#125; &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; public void init() throws ServletException &#123; &#125;&#125; HttpSessionListenerDemo文件：用来记录登录的人数 123456789101112131415161718192021222324package com;import javax.servlet.http.HttpSession;import javax.servlet.http.HttpSessionEvent;import javax.servlet.http.HttpSessionListener;import org.omg.CORBA.Request;public class ServletHttpSessionListenerDemo implements HttpSessionListener &#123; private static int count=0; //HttpSession创建时触发 public void sessionCreated(HttpSessionEvent arg0) &#123; count++; //人数++ &#125; //HttpSession销毁时触发 public void sessionDestroyed(HttpSessionEvent arg0) &#123; // TODO Auto-generated method stub count--; //人数-- &#125;&#125; 属性操作监听器 顾名思义，属性操作监听器就是当绑定属性或者移除绑定属性的时候会触发，共有三个监听器，分别为：ServletContextAttributeListener,ServletRequestAttributeListener,HttpSessionAtrributeListener。相同的是它们都有共同需要实现的方法，分别为：attributeAdded(绑定属性的时候触发),attributeRemoved(属性移除的时候触发),attributeReplace(属性被替换的时候触发) 由于这三个监听器实现的方法都是一样的，下面就演示一个即可，其他的都是相同的 HttpSessionAttributeListener 这是监听HttpSession对象属性的，主要有（添加，移除，替换）,当然这个也是要在web.xml设置的 12345678910111213141516171819202122232425262728293031323334package com;import javax.servlet.http.HttpSession;import javax.servlet.http.HttpSessionBindingEvent;public class HttpSessionAttributeListener implements javax.servlet.http.HttpSessionAttributeListener &#123; /*HttpSessionBindingEvent方法 * String getName() 返回最近改变的属性的名称 * Object getValue() 返回已添加、移除或替换的属性的值。如果添加（或绑定）了属性，则这是该属性的值。如果移除（或取消绑定）了属性，则这是被移除属性的值。如果替换了属性，则这是属性原来的值。 * getSession() 获取HttpSession对象 */ //添加新的属性时触发，每绑定一个属性就触发一次 public void attributeAdded(HttpSessionBindingEvent arg0) &#123; //获取HttpSession对象 HttpSession session=arg0.getSession(); String name=arg0.getName(); //获取添加的属性名称 String attribute=(String) arg0.getValue(); //获取添加的属性的值 &#125; //移除属性的时候触发 ，每移除一次就会触发一次 public void attributeRemoved(HttpSessionBindingEvent arg0) &#123; String value=(String) arg0.getValue(); System.out.println("被移除的属性的值为："+value); &#125; //属性值被替换的时候触发，直接重新设置属性值就是替换 public void attributeReplaced(HttpSessionBindingEvent arg0) &#123; System.out.println("被替换的属性的值："+arg0.getValue()); &#125;&#125; 会话属性监听器 先前介绍的几个监听器都是要在web.xml中使用&lt;listener&gt;定义的，这个会话属性监听器是不要在web.xml设置的 这里介绍的监听器分别为：HttpSessionBindingListener,HttpSessionActivationListener HttpSessionBindingListener 当实现HttpSessionBindingListener接口的类的对象被移除或者绑定到HttpSession成为属性的时候就会触发 下面是实现HttpSessionBindingListener接口的类 1234567891011121314151617181920212223242526272829303132package com;import javax.servlet.http.HttpSession;import javax.servlet.http.HttpSessionBindingEvent;public class HttpSessionBindingListenerDemo implements javax.servlet.http.HttpSessionBindingListener &#123; public String name; private int age; public HttpSessionBindingListenerDemo() &#123; super(); this.name="陈加兵"; this.age=22; &#125; //当这个类的对象绑定成为HttpSession的属性的时候将会触发 public void valueBound(HttpSessionBindingEvent arg0) &#123; //获取绑定的属性的对象 HttpSessionBindingListenerDemo listenerDemo=(HttpSessionBindingListenerDemo)arg0.getValue(); //获取对象的值 System.out.println(listenerDemo.name); &#125; //当这个类的对象被移除的时候就会触发 //getValue() getName() public void valueUnbound(HttpSessionBindingEvent arg0) &#123; &#125;&#125; 下面是Servlet文件： 123456789101112131415161718192021222324252627282930313233343536373839package com;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;public class ServletDemo1 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取对象 HttpSession session=request.getSession(); //对象 HttpSessionBindingListenerDemo listener=new HttpSessionBindingListenerDemo(); //绑定对象 session.setAttribute("listener", listener); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; public void init() throws ServletException &#123; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Servlet总结四(过滤器)]]></title>
      <url>%2F2017%2F09%2F17%2FServlet%E6%80%BB%E7%BB%93%E5%9B%9B-%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
      <content type="text"><![CDATA[Servlet总结四(过滤器的使用)简介 在容器调用Servlet的service()的方法钱，Servlet其实并不会知道有请求的到来，而在service()方法执行后，容器真正对浏览器进行HTTP响应之前，浏览器也不知道Servlet真正响应是什么。过滤器(Filter)正如其名称所示，它介于Servlet之前，可拦截浏览器对Servlet的请求，也可以改变Servlet对浏览器的响应。 其实说白了，过滤器就是应用程序的一个额外的组件，为了方便使用并且不改变Servlet源代码，比如用户验证，字符替换，压缩这类的需求，你可能只是暂时的需要这类需求，但是过一段时间又不需要了，如果直接在Servlet中改动源码，那么就太麻烦了。因此此时就需要设置一个独立的组件，在使用的时候直接引用，不需要的时候直接删除即可，这就是过滤器的必要。 过滤器的实现 想要实现过滤器，那么需要实现Filter接口，这个接口中有三个必须实现的方法，分别为init(),doFilter(),destroy()。 init(FilterConfig config) 这是一个初始化方法，其中的参数可以获取定义的初始值，这个在后面会详细说 destroy() 这个是销毁方法 doFilter(HttpServletRequest request,HttpServletResponse response,FilterChain chain) 这是主要的方法，用来执行过滤的作用。当请求来到了web容器中，容器发现了调用Servlet的service()方法之前可以应用某过滤器的时候就会调用该过滤器的doFilter()方法。就是在doFilter()方法中进行了service()方法的前置处理，而后根据是否调用FilterChain中的doFilter()决定是否执行下一个过滤器，如果没有那么就执行第一个过滤器。 如果执行了FilterChain的doFilter()方法，那么就会执行下一个过滤器，如果没有就调用指定的Servlet的service()方法。 重点 Servlet的响应分为前置处理和后置处理。前置处理就是在调用service()方法之前进行的处理，就是Servlet还没有接受到请求的时候，后置处理就是在Servlet执行过service()方法之后，就是Servlet已经处理完请求之后。因此FilterChain的doFilter()方法就将过滤器处理分为了前置处理和后置处理，在调用FilterChain的doFilter()方法之前的都是对Servlet的前置处理，也就是说这时候Servlet并不知道此时有请求过来，而在其之后的都是对Servlet的后置处理。 123456doFilter(HttpServletRequest request,HttpServletResponse response,FilterChain chain)&#123; //service()的前置处理 chain.doFilter(request,response); //service()的后置处理&#125; 在FilterChain执行后会一堆栈顺序返回，就是说如果有多个Filter，那么就先按照顺序执行chain.doFilter(request,response)之前的代码，即是先前置处理，然后入栈，这样一直到执行到最后一个Filter，之后就从栈顶开始执行chain.doFilter()的方法之后的代码，即是后置处理。总的来说就是先执行前置处理，然后入栈，待全部执行完毕之后再从栈顶开始后置处理的代码。 在Filter的doFilter的方法中的request，response和Servlet的doGet()和doPost()方法中的是一样的，即是可以设置属性，可以得到表单提交的值，总之是一样的。 简单的例子 下面实现一个过滤器用来验证提交请求的用户名和密码是否正确 1234567891011121314151617181920212223242526272829303132333435363738package com;import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequestWrapper;import javax.servlet.http.HttpServletResponse;public class FilterDemo1 implements Filter &#123; public void destroy() &#123; &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; // 根据request获取表单的用户名和密码 String username = request.getParameter("username"); String password = request.getParameter("password"); // 如果用户名和密码正确 if ("陈加兵".equals(username) &amp;&amp; "123456".equals("password")) &#123; System.out.println("用户名或者密码错误，请重新输入"); &#125; //继续执行下一个过滤器，如果有就执行 chain.doFilter(request, response); //当所有过滤器的前置处理都执行完毕才执行这个语句 System.out.println("Servlet已经执行完毕"); &#125; public void init(FilterConfig config) throws ServletException &#123; &#125;&#125; 过滤器的设置 在web.xml中设置过滤器，设置的方式如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;display-name&gt;web2&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 定义FilterDemo1的过滤器 --&gt;&lt;filter&gt; &lt;!--设置过滤器文件的名字--&gt; &lt;filter-name&gt;FilterDemo1&lt;/filter-name&gt; &lt;!--设置过滤器类所在的路径，具体到包名--&gt; &lt;filter-class&gt;com.FilterDemo1&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;FilterDemo3&lt;/filter-name&gt; &lt;!--设置作用的url，即是Demo9这个Servlet应用这个过滤器--&gt; &lt;url-pattern&gt;/Demo9&lt;/url-pattern&gt; &lt;!-- &lt;servlet-name&gt;Demo9&lt;/servlet-name&gt; 这个标签和上面的&lt;url-pattern&gt;是一个效果，直接指明应用的Servlet的名称 --&gt; &lt;!--Demo1也应用这个过滤器--&gt; &lt;servlet-name&gt;Demo1&lt;/servlet-name&gt; &lt;/filter-mapping&gt;&lt;!-- 定义FilterDemo1的过滤器 --&gt; &lt;!-- 定义FilterDemo2的过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;FilterDemo2&lt;/filter-name&gt; &lt;filter-class&gt;com.FilterDemo2&lt;/filter-class&gt; &lt;/filte&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;FilterDemo2&lt;/filter-name&gt;&lt;!-- Demo1这个Servlet文件也应用FilterDemo2这个过滤器，那么当请求Demo的时候要按照定义的先后顺序先执行FilterDemo1这个过滤器 --&gt; &lt;url-pattern&gt;/Demo1&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 定义FilterDemo2的过滤器 --&gt; &lt;/web-app&gt; 注意 可以在同一个&lt;filter-mapping&gt;中定义多个Servlet文件，表示多个Servlet都应用于这个过滤器 一个Servlet文件可以同时应用多个过滤器，但是执行的顺序要按照定义的先后顺序执行 初始参数的设置和获取设置初始值 这个和ServletConfig一样的都存在初始参数，当然定义的方式也是不尽相同，都是在web.xml中定义的，如下： 123456789101112131415&lt;filter&gt; &lt;filter-name&gt;FilterDemo3&lt;/filter-name&gt; &lt;filter-class&gt;com.FilterDemo3&lt;/filter-class&gt; &lt;!--直接在filter下可以设置初始参数，当然我们可以在过滤器中获取参数--&gt; &lt;init-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;param-value&gt;陈加兵&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;123456&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; 获取初始参数的值 直接利用其中的init(FilteConfig config) 获取初始化参数 12345678910111213141516171819202122232425262728293031323334package com;import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequestWrapper;import javax.servlet.http.HttpServletResponse;public class FilterDemo1 implements Filter &#123; public String username; public String password; public void destroy() &#123; &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; &#125; //直接在init方法中利用FilterConfig的方法获取参数的值 public void init(FilterConfig config) throws ServletException &#123; //获取初始值 username=config.getInitParameter("username"); password=config.getInitParameter("password"); &#125;&#125; 设置触发的时机 当我们直接请求Servlet文件的url或者表单提交的时候使用的都是浏览器默认发出的请求，这个是可以触发过滤器的。但是如果是那些重定向(sendirect)或者转发包含(forward,include)就不会默认触发，因此我们需要在web.xml设置触发的时机，定义如下: 12345678&lt;filter-mapping&gt; &lt;filter-name&gt;FilterDemo1&lt;/filter-name&gt; &lt;url-pattern&gt;/Demo1&lt;/url-pattern&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;!--默认的--&gt; &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt; &lt;!--forward--&gt; &lt;dispatcher&gt;INCLUDE&lt;/dispatcher&gt; &lt;!--include--&gt; &lt;dispatcher&gt;ERROR&lt;/dispatcher&gt; &lt;!--error --&gt;&lt;/filter-mapping&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Servlet总结三(HttpSession会话管理)]]></title>
      <url>%2F2017%2F09%2F16%2FServlet%E6%80%BB%E7%BB%93%E4%B8%89-HttpSession%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[Servlet总结三(HttpSession会话管理)简介 HttpSession是提供一种方式，跨多个页面请求或对 Web 站点的多次访问标识用户并存储有关该用户的信息。简单的来说就是能够实现全局的共享数据，可以跨多个页面请求，当然在Servlet中可以在同一个项目中的不同的Servlet中共享数据 常用方法 void setAttribute(String name, Object value) 绑定对象到此会话上 public void removeAttribute(String name) 移除绑定的对象 Object getAttribute(String name) 根据指定的属性名称获取指定的值(需要强转) Enumeration getAttributeNames() 返回一个所有属性的枚举对象,可以通过Enumeration得到其中的值 public int getMaxInactiveInterval() 返回 servlet 容器在客户端访问之间将使此会话保持打开状态的最大时间间隔，以秒为单位（根据测试，这个默认的值为1800秒，如果在这个默认的时间之内没有响应，那么会话将会中断） public void setMaxInactiveInterval(int interval) 指定在 servlet 容器使此会话失效之前客户端请求之间的时间间隔，以秒为单位。负数时间指示会话永远不会超时。 使用 我们可以通过HttpServletRequest的方法getSession() 获取对象，下面我们来使用其中的函数 1234567891011121314151617 //Demo1中的doGet方法 public void doGet(HttpServletRequest request,HttpServletResponse response)&#123; request.setCharacterEncoding("UTF-8"); response.setContentType("text/html;charset=UTF-8"); //获取对象 HttpSession session=request.getSession(); //设置属性login的值为auto session.setAttribute("login", "auto"); &#125; //Demo2中的doGet方法 public void doGet(HttpServletRequest request,HttpServletResponse response)&#123; //获取对象 HttpSession session=request.getSession(); //获取其中的login的值 String login=session.getAttribute("login");&#125; 简单的例子 下面是一个简单的例子实现自动登录,在填入用户名和密码正确之后，并且勾选其中的自动登录选项，那么登录过一次后在一天之内，如果直接登录首页将会直接跳转到用户界面，实现自动登录的功能 index.jsp文件中实现的是简单的表单登录，并没有加上一些css，js,仅仅是一个例子 123456789101112131415161718192021222324252627282930313233&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort() + path + "/";%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt;&lt;head&gt;&lt;base href="&lt;%=basePath%&gt;"&gt;&lt;title&gt;My JSP 'index.jsp' starting page&lt;/title&gt;&lt;meta http-equiv="pragma" content="no-cache"&gt;&lt;meta http-equiv="cache-control" content="no-cache"&gt;&lt;meta http-equiv="expires" content="0"&gt;&lt;meta http-equiv="keywords" content="keyword1,keyword2,keyword3"&gt;&lt;meta http-equiv="description" content="This is my page"&gt;&lt;!-- &lt;link rel="stylesheet" type="text/css" href="styles.css"&gt; --&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="Demo3" method="get"&gt; &lt;label&gt;username:&lt;/label&gt;&lt;input type="text" name="username"&gt;&lt;/br&gt; &lt;label&gt;password:&lt;/label&gt;&lt;input type="password" name="password"&gt;&lt;/br&gt; &lt;label&gt;自动登录：&lt;/label&gt;&lt;input type="checkbox" name="login" value="auto"&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; Demo3.java是用户的首页，实现检测自动登录，没有加一些页面在上面，但是其实是用户的首页 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com;import java.io.BufferedReader;import java.io.File;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.PrintWriter;import java.io.Reader;import javax.servlet.RequestDispatcher;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;public class Demo3 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding("UTF-8"); response.setContentType("text/html;charset=UTF-8"); // 获取HttpSession对象 HttpSession session = request.getSession(); // 设置一天的访问时间间隔，如果超过这个时间，那么中断 session.setMaxInactiveInterval(24 * 60 * 60); // 获取转发对象，页面跳转 RequestDispatcher dispatcher = request .getRequestDispatcher("HTML/user.html"); // 获取表单的数据 String username = request.getParameter("username"); String password = request.getParameter("password"); String login = request.getParameter("login"); // 获取HttpSession中设置的属性名为login的值，如果为null，表示没有设置 String value = (String) session.getAttribute("login"); // 如果不为空，表示已经登录过一次了，并且允许自动登录，直接跳转到用户界面即可 if (value != null) &#123; // 直接跳转到用户界面 dispatcher.forward(request, response); &#125; else &#123; // 如果用户名和密码正确 if ("chenjiabing".equals(username) &amp;&amp; "123456".equals(password)) &#123; // 并且设置了自动登录 if ("auto".equals(login)) &#123; // 设置session的值 session.setAttribute("login", "auto"); &#125; response.sendRedirect("HTML/user.html"); &#125; &#125; &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 说明: user.html是用户的主页，这里没有给出，可以自己设计]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Servlet总结二(文件路径获取）]]></title>
      <url>%2F2017%2F09%2F15%2FServlet%E6%80%BB%E7%BB%93%E4%BA%8C(%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E8%8E%B7%E5%8F%96)%2F</url>
      <content type="text"><![CDATA[Servlet总结二（文件路径）前言 前面我们说过ServletContext表示的是web容器中的上下文，下面我们也是用到ServletContext中的方法读取文件 读取WebRoot文件下的文件 我们知道当我们将项目部署到Tomcat服务器中时，项目中的文件路径其实就是在Tomcat中的文件路径，所有的项目都是存储在webapps下的，我们可以看到webaapps下有两个文件夹(WEB-INF,META-INF)，这两个其实就是项目中webRoot下的两个文件夹。 public String getRealPath(String path) 为给定虚拟路径返回包含实际路径的String 12345678910111213141516 //获取ServletContext的对象ServletContext context = this.getServletContext();//context.getRealPath("/")获取项目的根目录的绝对路径(webRoot的绝对路径)//得到了webRoot的绝对路径，下面只要再接着写其他文件的路径即可File file = new File(context.getRealPath("/") + "\\WEB-INF\\lib\\file.txt");if (file.exists()) &#123; System.out.println("文件存在");&#125; else &#123; System.out.println("文件不存在，现在我们创建一个"); try &#123; file.createNewFile();// 创建一个新的文件 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; InputStream getResourceAsStream(String path) 根据传入的路径文件，返回一个InputStream对象 123456789101112 // 第一个"/"是表示webRoot的根目录，通过这个函数可以不用指定绝对路径就可以构造一个输入字节流InputStream stream = context .getResourceAsStream("/WEB-INF/lib/file.txt");// 通过InputStreamReader将字节流转换为字符流，然后创建缓冲字符流读取文件BufferedReader reader = new BufferedReader( new InputStreamReader(stream));try &#123; System.out.println(reader.readLine());&#125; catch (IOException e) &#123; System.out.println("文件没有成功读取"); e.printStackTrace();&#125; 注意：这个函数中的path传入的第一个&quot;/&quot;就表示根目录，在eclipse项目中表示webRoot的绝对路径，在Tomcat下的webapps表示项目名称的绝对路径，因此在下面的WEB-INF,META-INF文件夹下的文件只需要在后面继续添加即可 读取src下的class文件 前面我们获取的webRoot下的文件路径，但是如果我们想要获取src下的文件，那么我们要如何获取呢。 我们仔细看看Tomcat下的文件，可以发现在每一个WEB-INF下都有一个classes，这个就是相当于Tomcat下的src，因此我们利用上面得到的路径稍加修改就可以轻易的得到其中的文件路径 下面我们读取src文件夹下的file.txt中的内容，代码如下: 12345678910111213141516171819202122232425262728293031323334353637 // 获取ServletContext对象ServletContext context = this.getServletContext();// 这个是获取项目下的src文件夹下的file.txt文件File file = new File(context.getRealPath("/") + "\\WEB-INF\\classes\\file.txt");BufferedReader reader = null;if (file.exists()) &#123; System.out.println("文件存在，现在可以读取"); try &#123; // 创建缓冲流对象，实现读取文件 reader = new BufferedReader(new FileReader(file)); try &#123; // 输出第一行内容 System.out.println(reader.readLine()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; catch (FileNotFoundException e) &#123; System.out.println("文件不存在"); &#125; finally &#123; if (reader != null) &#123; try &#123; reader.close(); // 如果reader不是空，就关闭 &#125; catch (IOException e) &#123; System.out.println("文件关闭失败"); &#125; &#125; &#125;&#125; else &#123; System.out.println("文件不存在，现在开始创建一个"); try &#123; file.createNewFile();// 创建一个 &#125; catch (IOException e) &#123; System.out.println("没有创建成功"); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Eclipse配置Tomcat]]></title>
      <url>%2F2017%2F09%2F14%2FEclipse%E9%85%8D%E7%BD%AETomcat%2F</url>
      <content type="text"><![CDATA[Eclipse配置tomcatEclipse创建server 首先下载eclipse for javaEE developer 打开控制台，然后到server后右击空白处-&gt;New-&gt;Server-&gt;Apach-&gt;Tomact 7.0 -&gt;Next-&gt;添加tomcat的路径即可 ![第一步](http://ono60m7tl.bkt.clouddn.com/eclipse1.bmp 发布项目 在控制台server的空白处右击-&gt;Add and Remove-&gt;选择项目-&gt;Add-&gt;Finish 文档 javaee中英文对照文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Servlet总结一]]></title>
      <url>%2F2017%2F09%2F14%2FServlet%E6%80%BB%E7%BB%93%E4%B8%80%2F</url>
      <content type="text"><![CDATA[Servlet总结一HttpServlet 想要实现一个servlet必须继承这个类，其实一个servlet就是一个java文件，但是这个类必须是继承HttpServlet。 生命周期 servlet的生命周期是从创建到毁灭的一个过程，具体的过程如下： Servlet 通过调用 init () 方法进行初始化。 Servlet 调用 service() 方法来处理客户端的请求,但是在这一步还是要用到具体的实现的两个方法，分别是doPost(),doGet() Servlet 通过调用 destroy() 方法终止（结束）。 最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。 常用的方法 init() 初试化方法 doGet(HttpServletRequest request,HttpServletResponse response) 处理get请求的方法 doPost(HttpServletRequest request,HttpServletResponse response) 处理post请求的方法 destroy() 最后销毁 Enumeration&lt;E&gt; getInitParameterNames() 该方法从 servlet 的 ServletConfig 对象获取所有的参数名称 public String getInitParameter(String name) 该方法从 servlet 的 ServletConfig 对象获取指定参数的值 name是指定的param-name的值，返回的param-value的值，具体的使用如下： 123456789101112131415161718192021222324252627282930&lt;servlet&gt; &lt;display-name&gt;ServletConfigDemo&lt;/display-name&gt; &lt;servlet-name&gt;ServletConfigDemo&lt;/servlet-name&gt; &lt;servlet-class&gt;com.ServletConfigDemo&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; //定义的name &lt;param-value&gt;陈加兵&lt;/param-value&gt; //定义的value &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;123456&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletConfigDemo&lt;/servlet-name&gt; &lt;url-pattern&gt;/ServletConfigDemo&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; //下面只是一个servlet类中的init()方法，一般否是在init()方法中获取 public void init() throws ServletException &#123; username=this.getInitParameter("username"); //根据指定的名称获取参数的值 enumeration=this.getInitParameterNames(); //获取枚举对象 while(enumeration.hasMoreElements())&#123; //通过枚举的方法获取其中的所有的值 System.out.println(this.getInitParameter((String) enumeration.nextElement())); &#125; &#125; ServletConfig getServletConfig() 返回一个ServletConfig对象，这个方法在后面讲到ServletConfig类的时候回详细的说到 ServletContext getServletContext() 返回一个ServletContext对象，这个和ServletConfig类一样重要，在后面会详细讲解 HttpServletRequest 这是servlet容器中用来处理请求的类，并且该对象作为一个参数传给doGet,doPost方法中 常用的方法 getParameter(String name) 获取表单中的值，name是input中定义的name值，如果不存在返回null，否则返回的字符串 String[] getParameterValues(String name) 获取表单中有多个name相同的值，例如多选列表，复选框 Enumeration getParameterNames() 返回所有请求中的参数，返回的是一个枚举对象，可以通过对应的方法进行列出所有的参数 12345678910111213141516171819202122232425262728293031 //下面将会详细讲解上面三个方法的使用法，这三个参数是针对表单的，因此需要结合表单讲解，我们将会在index.jsp文件中定义表单 //index.jsp文件的内容如下： &lt;form action="ServletDemo" method="post"&gt; //servletDemo是要处理该请求的servlet的url，使用的是相对路径 username: &lt;input type="text" name="username"&gt; &lt;br&gt;Password: &lt;input type="password" name="pw"&gt; &lt;br&gt; &lt;input type="submit" value="提交"&gt; &lt;br&gt; &lt;label&gt;hobby:&lt;/label&gt; &lt;input type="checkbox" name="hobby" value="1"&gt;swing &lt;input type="checkbox" name="hobby" value="2"&gt;dancing &lt;input type="checkbox" name="hobby" value="3"&gt;song&lt;/form&gt; //下面是ServletDemo中的部分代码 String username = request.getParameter("username"); //获取username的值 String pw = request.getParameter("pw"); //获取password的值 //获取所有复选框的值 String[] hobbies=request.getParameterValues("hobby"); for(String hobby:hobbies)&#123; System.out.println(hobby); &#125; //获得所有的元素的name属性的名称，返回的是一个枚举的对象 Enumeration enumeration = request.getParameterNames(); while (enumeration.hasMoreElements()) &#123; String paramsString = (String) enumeration.nextElement(); //获取其中的每一名称 System.out.println(request.getParameter(request.getParameter)); //根据名称获取其中的值 &#125; Enumeration getHeaderNames() 获取所有请求头中的参数的名称，返回的是一个枚举对象 String getHeader(String name) 根据请求头中的名称获取对应名称的请求内容 1234567//获取所有请求头的名称，返回的是一个枚举对象 Enumeration enumeration=request.getHeaderNames(); while (enumeration.hasMoreElements()) &#123; String name=(String) enumeration.nextElement(); String value=request.getHeader(name); //根据名称返回对应的值 System.out.println(name+":"+value); &#125; String getContextPath() 获取应用程序的环境路径，就是上一级目录 String getMethod() 返回请求的方式 Get Post String getQueryString() 返回请求行中的参数部分 StringBuffer getRequestURL() 返回完整的URL String getRequestURI() 返回请求行中的资源名部分 getRemoteAddr方法返回发出请求的客户机的IP地址。 getRemoteHost方法返回发出请求的客户机的完整主机名。 getRemotePort方法返回客户机所使用的网络端口号。 getLocalAddr方法返回WEB服务器的IP地址。 getLocalName方法返回WEB服务器的主机名。 请求转发与包含 请求转发相当于一个重定向，但是这个又和重定向不同的是：请求转发是在web容器中进行的，因此浏览器的地址栏并不会改变，但是重定向是要求浏览器重新请求另一个url，因此可以在地址栏清楚的看到地址的变化 请求转发使用的是HttpServletRequest中的getRequestDispatcher方法，下面将会详细介绍 getRequestDispatcher RequestDispatcher getRequestDispatcher(String path) 返回的是一个RequestDispatcher对象，path是指定转发的url，可以是绝对url或者是相对url RequestDispatcher 定义接收来自客户端的请求并将它们发送到服务器上的任何资源（比如 servlet、HTML 文件或 JSP 文件）的对象。servlet 容器可创建 RequestDispatcher 对象，该对象被用作包装位于特定路径上的服务器资源或通过特定名称给定的服务器资源的包装器。 void forward(ServletRequest request, ServletResponse response) 执行转发请求,因为继承关系，因此其中的参数也是可以是HttpServletRequest和HttpServletResponse对象 123456789101112 public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123; request.setCharacterEncoding("UTF-8"); response.setContentType("text/html;charset=UTF-8"); //获取表单中的值 String name=request.getParameter("username"); String password=request.getParameter("password"); //上面虽然获取了其中的值，但是不可以此时对浏览器进行响应 RequestDispatcher dispatcher=request.getRequestDispatcher("Demo2"); dispatcher.forward(request, response);&#125; 注意： 在转发前后不可以对浏览器进行响应，否则会出现错误，其中forward传入的参数是当前的request和response，也就是说在转发之后的文件之中还是可以获取信息的（请求头，表单） void include(ServletRequest request, ServletResponse response) 包含转发 123456789101112131415161718public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123; request.setCharacterEncoding("UTF-8"); response.setContentType("text/html;charset=UTF-8"); //获取表单中的值 String name=request.getParameter("username"); String password=request.getParameter("password"); Cookie cookie=new Cookie("age", "22"); response.addCookie(cookie); PrintWriter pw=response.getWriter(); pw.println("在转发之前先对浏览器进行响应"); //上面可以看出这里对浏览器进行了响应，使用include可以在转发之前或者之后对浏览器进行响应 RequestDispatcher dispatcher=request.getRequestDispatcher("Demo2"); dispatcher.include(request, response); &#125; forward和include的区别 forward在转发之前和之后是不可以对浏览器进行响应的，但是include可以。使用include时，如果同时进行了响应，那么会同时响应在同一网页中，会出现在同一个页面中 相同点 请求转发后地址栏都不会出现改变 请求转发过后会重新回到当前的servlet容器中，因此如果想要在当前的servlet容器中处理一些东西是可以实现的，下面来看一个例子 1234567891011121314 public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123; request.setCharacterEncoding("UTF-8"); response.setContentType("text/html;charset=UTF-8"); //获取表单中的值 String name=request.getParameter("username"); String password=request.getParameter("password"); //上面虽然获取了其中的值，但是不可以此时对浏览器进行响应 RequestDispatcher dispatcher=request.getRequestDispatcher("Demo2"); dispatcher.forward(request, response); System.out.println(username); //这个语句当转发请求处理完成之后会返回到这里执行这句话 &#125; 传递数据 就像写到scrapy爬虫的时候，有时候一个数据会传入到下一个函数中使用，因此需要一个机制携带过去。这里可以使用HttpServletRequest中的 setAttribute方法，详细使用如下： public void setAttribute(String name, Object o) 这里其实相当于传入的是一个键值对，name是key，o是value public void removeAttribute(String name) 根据键值的name移除数据 12345678910111213141516171819202122232425262728293031323334 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 设置编码，这个是通过浏览器访问时能够实现中文显示的功能 response.setContentType("text/html;charset=UTF-8"); //设置和浏览器相应的编码方式，以便在控制台上输出中文，否则将会乱码显示 request.setCharacterEncoding("UTF-8"); String data="大家好，我是陈加兵"; request.setAttribute("data",data); //向请求中传入数据,这个是以键值对存在的，前面的是key，后面的参数是value //将请求转发给HttpServletDemo的servlet文件处理 RequestDispatcher dispatcher=request.getRequestDispatcher("HttpServletResponseDemo"); //如果转发成功，注意这里的转发，地址栏的网址并不会改变 if(dispatcher!=null)&#123; dispatcher.forward(request, response); &#125;&#125; //下面是HttpServletResponseDemo的处理代码 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html;charset=UTF-8"); //设置响应内容 request.setCharacterEncoding("UTF-8"); //设置接受的编码 //接收请求转发传递的data数据 String data=(String) request.getAttribute("data"); PrintWriter pWriter=response.getWriter(); pWriter.println(data+"&lt;br/&gt;"); //移除这个键值对 ，下面在访问这个数据就会显示不存在了 request.removeAttribute("data"); pWriter.close();&#125; HttpServletResponse 这个类是用于对浏览器进行响应的 常用的方法 PrintWriter getWriter() 返回一个PrintWriter对象，可以将字符串发送到客户端 addCookie(Cookie cookie) 将指定的cookie添加到响应中，这个是直接添加到set-cookie中，用于存储一些信息 123 Cookie cookie=new Cookie("age", "22");cookie.setMaxAge(7*24*60*60); //设置cookie的失效时间(秒为单位）response.addCookie(cookie); //添加cookie sendError(int src) 将指定的错误信息发送到客户端 比如401，302…. sendError(int sec,String message) 发送错误信息的同时，还发送提醒的信息message sendRedirect(String url) 网页重定向，url是重定向的网址，但是也可以是相对的url ServletOutputStream getOutputStream() 返回适用于在响应中编写二进制数据的 ServletOutputStream。 ServletConfig 在web.xml中对于每一个Servlet的设置web容器会为其生成一个ServletConfig作为代表对象，你可以从该对象中取得设置在web.xml中的Servlet初始参数 常用方法 String getInitParameter(String name) 根据属性的名称获取指定的值 Enumeration getInitParameterNames() 获取该servlet中设置的所有的属性的名称（并不是设置的初始值） ServletContext getServletContext() 获取ServletContext对象 设置和取得初始参数 ServletConfig相当于web.xml中个别Servlet设置代表对象，这意味着可以从ServletConfig中取得Servlet设置信息。ServletConfig定义了getInitParameter()、getInitParameterNames() 方法，可以取得设置的Servlet的初始参数 设置初始参数 直接在web.xml中定义如下： 12345678910111213141516&lt;servlet&gt; &lt;description&gt;This is the description of my J2EE component&lt;/description&gt; &lt;display-name&gt;This is the display name of my J2EE component&lt;/display-name&gt; &lt;servlet-name&gt;Demo3&lt;/servlet-name&gt; &lt;servlet-class&gt;com.Demo3&lt;/servlet-class&gt; &lt;init-param&gt; //定义标签 &lt;param-name&gt;username&lt;/param-name&gt; //定义的name &lt;param-value&gt;陈加兵&lt;/param-value&gt; //定义的value &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;123456&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; 取得初始参数 第一种方法：直接使用带有ServletConfig对象为参数的init直接获取12345678910111213141516 public void init(ServletConfig config) throws ServletException &#123;// username=config.getInitParameter("username"); //单独的获取每一个值// password=config.getInitParameter("password"); //首先获取所有的初始参数的名称 Enumeration enumeration=config.getInitParameterNames(); while(enumeration.hasMoreElements())&#123; String name=(String)enumeration.nextElement(); //获取每一个值 if(name.equals("username"))&#123; username=config.getInitParameter(name); &#125;else if (name.equals("password")) &#123; password=config.getInitParameter(name); &#125; &#125; &#125; 第二种：使用HttpServlet的getServletConfig() 方法直接获取ServletConfig对象，然后再获取参数 1234567 public void init() throws ServletException &#123; ServletConfig config=this.getServletConfig(); //获取ServletConfig对象 username=config.getInitParameter("username"); //获取参数的值 password=config.getInitParameter("password"); &#125; ServletContext ServletContext是整个web应用程序运行之后的代表对象，这是一个全局的对象，一个web项目中的所有Servlet文件都是可以共享这个数据的，因此这个有着很大的作用。 有人说这个不是和ServletConfig一样的用法吗，其实不然，ServletConfig并不是这个web程序的全局变量，它所设置的值只是对当前的servlet共享，并不能对web项目中的所有的servlet文件共享 常用方法 String getInitParameter(String name) 获取指定名称的属性值 Enumeration getInitParameterNames() 获取所有已经设置的属性的名称 void setAttribute(String name, Object object) 将对象绑定到此 servlet 上下文中的给定属性名称。如果已将指定名称用于某个属性，则此方法将使用新属性替换具有该名称的属性。 Object getAttribute(String name) 根据指定的属性名称获取绑定的值(需要进行强转) void removeAttribute(String name) 解除绑定的数据 设置初始参数 这个和ServletConfig是一样的，都是在web.xml中设置的，但是这个是设置在&lt;servlet&gt;&lt;/servlet&gt;的外面的，并不是针对单独的一个servlet来设置的，因此是全局共享的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;display-name&gt;web2&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!--全局变量，对工程中的所有的Servlet都是共享的--&gt; &lt;context-param&gt; &lt;param-name&gt;context_name&lt;/param-name&gt; &lt;param-value&gt;context_value&lt;/param-value&gt; &lt;!--在每一对context-param中只能定义一个变量的值--&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;param-value&gt;陈加兵&lt;/param-value&gt; &lt;/context-param&gt; &lt;servlet&gt; &lt;servlet-name&gt;Demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;com.Demo1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet&gt; &lt;servlet-name&gt;Demo2&lt;/servlet-name&gt; &lt;servlet-class&gt;com.Demo2&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/Demo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Demo2&lt;/servlet-name&gt; &lt;url-pattern&gt;/Demo2&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 获取设置的参数 第一种方法：使用无参初始化的方法init() ，结合父类HttpServlet的getServletContext()的方法获取ServletContext对象 1234567891011121314151617//使用无参构造函数public void init() throws ServletException &#123; ServletContext context=this.getServletContext(); //根据属性的名称获取指定的值 String value=context.getInitParameter("username"); System.out.println(value); //获取所有的属性的名称的枚举对象 Enumeration enumeration=context.getInitParameterNames(); while(enumeration.hasMoreElements())&#123; //获取属性的每一个名称 String name=(String) enumeration.nextElement(); //根据名称获取所有的值 System.out.println(name+" = "+context.getInitParameter(name)); &#125; &#125; 第二种方法：使用有参初始化方法init(ServletConfig config)，结合ServletConfig的getServletContext()方法获取对象 123456789//使用有参构造方法public void Init(ServletConfig config)&#123; //调用ServletConfig中的方法获取对象 ServletContext context=config.getServletContext(); //获取属性的值 String value=context.getInitParameter("username"); System.out.println(value); &#125; 绑定属性 有人可能会说如果想用共享数据在web.xml设置有点繁琐，这里可以直接绑定属性，然后就可以在整个web项目中共享这个绑定的属性了 123456789101112131415161718192021public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding("UTF-8"); response.setContentType("text/html;charset=UTF-8"); //获取对象（这是父类HttpServlet中的一个方法） ServletContext context=this.getServletContext(); //count表示访问页面的次数，在这里设置了属性可以全局共享该数据，意思就是在一个项目中的所有的servlet都是可以访问到该数据的 Integer count=(Integer) context.getAttribute("count"); //获取设置的属性值 //如果为空，表示该属性还没有被设置，因此这是第一次访问该页面 if(count==null)&#123; count=1; context.setAttribute("count", 1); //初始值为1，表示访问网页1次 &#125;else &#123; //否则表示已经不是第一次访问网页了，因此需要++1 context.setAttribute("count", ++count); &#125; PrintWriter pWriter=response.getWriter(); pWriter.println("该页面已经被访问了"+count+"次了......"); &#125; 参考文档 javaEE中英文对照文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[多线程的使用]]></title>
      <url>%2F2017%2F09%2F03%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[多线程前言 我看了不止一个人说多线程是鸡肋，但是就依照我个人觉得多线程在一些小型的爬虫中还是可以显著的提高速度的，相比多进程来说应该还是挺简单的 使用多线程继承threading.Thread 继承threading.Thread模块是一个很好的一个选择，就像java中也是可以继承类和实现接口一样，这都是很好的选择，下面我们来看看具体如何使用 1234567891011121314151617181920212223242526class Mythread(threading.Thread): def __init__(self,threadID,name,counter): threading.Thread.__init__(self) #首先需要先保留原来threading.Thread中的初始化函数 self.threadID=threadID #重命名线程的ID self.name=name #线程的名字 self.counter=counter #线程的数量 def run(self): lock.acquire() #获取线程锁Lock for i in range(10): print "线程"+self.name+"开始运行" lock.release() #释放线程锁Lockif __name__ == '__main__': lock=threading.Lock() t1=Mythread(0,"thread-1",3) t2=Mythread(1,"thread-2",3) t1.start() t2.start() threads=[] threads.append(t1) threads.append(t2) for t in threads: t.join() #阻塞主线程，直至线程运行完毕才运行main线程的语句 print "线程运行结束" 需要注意的是，这种继承的方式有一个缺点，这个和java中继承来实现多线程是一样的，就是一个对象只能是对应一个线程，并不能一个对象被多个线程共享，下面我们将会介绍另外的一种方式 直接调用threading.Thread 上面我们说过继承的方式，但是我个人觉得对于一些比较小的爬虫还是有些繁琐的，因为总是需要重写run方法，现在我们来看看如何简化实现多线程 12345678910"""这是一个简单的例子，其实也不是一个好的例子，但是为了演示方便就选用了，可以看出这里是直接调用了func函数，然后变成多个线程同时并行，其中target是要调用的方法(没有括号)，args是方法调用需要传入的参数其实这个还是和上面的继承比较相似的"""def func(name,age): for i in range(10): print name+"的年龄为："+str(age) t=threading.Thread(target=func,args=["陈加兵",22])t.start() Thread对象的相关方法 start() 启动线程 join([timeout]) 设置阻塞线程，timeout是可选的参数，表示阻塞的时间，如果没有就是当此线程运行结束才开始运行下一个线程 run() 线程活动的方法 getName() 获取线程名称 setName() 设置线程的名称 isAlive() 判断线程是否还活着 isDaemon() 判断是否是守护线程 setDaemon() 设置为守护线程，守护线程就是当主线程运行完后，这个线程也会随着主线程的结束而结束 共享队列 从源代码可以看出队列是实现了锁原语的，因此可以使用队列实现线程的同步，这里的主要原理就不细说了，简单的说就是get和put等方法都实现了锁原语，就是当一个操作正在执行的时候其他的操作会阻塞等待 下面我自己写了一个使用两个线程实现同时入队和出队的程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import randomimport timefrom Queue import Queueclass myThread(threading.Thread): def __init__(self,threadID,name,counter,q,flag): """ threadID是线程的ID name是线程的名称 q是先进先出队列 flag是用来调用get和put的标志 """ threading.Thread.__init__(self) self.name=name self.threadID=threadID self.counter=counter self.q=q self.flag=flag def run(self): """ 当flag为1时就调用put方法，否则调用get """ if self.flag==1: self.put() else: self.get() def put(self): while True: self.q.put(random.randint(0,10)) def get(self): while True: if not self.q.empty(): print self.q.get() if __name__=="__main__": threadLock=threading.Lock() q=Queue() t1=myThread(1,"Thread-1",1,q,1) t2=myThread(2,"Thread-2",2,q,2) threads=[] threads.append(t1) threads.append(t2) t1.start() t2.start() Queue相关的一些方法 Queue.qsize() 返回队列的大小 Queue.empty() 如果队列为空，返回True,反之False Queue.full() 如果队列满了，返回True,反之False Queue.full 与 maxsize 大小对应 Queue.get([block[, timeout]])获取队列，timeout等待时间 Queue.get_nowait() 相当Queue.get(False) Queue.put(item) 写入队列，timeout等待时间 Queue.put_nowait(item) 相当Queue.put(item, False) Queue.task_done() 在完成一项工作之后， Queue.task_done()函数向任务已经完成的队列发送一个信号 Queue.join() 实际上意味着等到队列为空，再执行别的操作]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[os模块中常用的的方法]]></title>
      <url>%2F2017%2F09%2F02%2Fos%E6%A8%A1%E5%9D%97%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[os模块中常用的方法常用的方法 os.getcwd() 获取当前的路径os.listdir(path) 获取path路径下的全部文件和文件夹，就是显示全部的文件的作用os.mkdir(path) 创建一个文件夹os.rmdir(path) 删除一个文件夹os.remove(path) 删除一个文件os.rename(path1,path2) 将文件或者文件夹重命名，path1是原来件路径，path2是改变后的文件的路径名称os.makedirs(path) 循环创建文件夹，给出一个路径，连续的创建这个路径的全部文件夹，并不是创建文件os.removedirs(path) 循环删除文件夹 会删除整个路径的文件夹os.path.abspath(path) 返回此文件的绝对路径os.path.exists(path) 判断文件或者文件夹是否存在os.path.basename(path) 返回绝对路径中的文件名os.path.normpath(path) 标准化文件路径，Windows下将双斜杠变成单斜杠os.path.commonprefix(list) 返回list中的相同的路径，只是多个路径相同的部分os.path.dirname(path) 返回文件所在上面一层的目录的名称，注意这里是所在紧接着一层的文件夹的名称os.path.split(path) 将路径分割成两个部分，返回的是一个元祖，第一个元素是前面的路径，第二个元素是文件的名称os.path.getatime(path) 返回文件的最后访问时间os.path.getmtime(path) 返回文件的最后修改时间os.path.getctime(path) 在unix的系统上返回的是文件最后修改的时间，在window的系统上返回的是文件的创建时间os.path.getsize(path) 返回文件的大小，以字节为单位os.path.isfile(path) 判断文件是否是文件os.path.isdir(path) 判断文件是否是文件夹os.path.join(path1,path2) 将两个文件的路径拼接在一起 例子 其中的每个方法的例子请点击这里]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python操作MongoDB]]></title>
      <url>%2F2017%2F07%2F09%2Fpython%E6%93%8D%E4%BD%9CMongoDB%2F</url>
      <content type="text"><![CDATA[python操作MongoDB前言 下面推荐本人写的MongoDB的基本操作博文，介绍的还是比较详细的，喜欢的朋友可以去看看 MongoDB干货篇之安装 MongoDB干货篇之查询数据 MongoDB干货篇之更新数据 综合应用 下面是自己写的一个简单的操作，分别对应了增删改查，虽然不太全面，但是只是简单的示范了一下，当然更多的功能还是需要自己去完善的，因为代码中都有注释，这里就不再详细的说了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# coding:utf-8import pymongoclass MongoDB: def __init__(self,db,collections): """ 初始化数据库 :param db:数据库名称 :param collections: 数据库的集合的名称 """ self.client = pymongo.MongoClient('localhost', 27017) #获取的连接 self.db = self.client[db] #创建数据库db self.post = self.db[collections] #创建或者选择要操作的集合 def update(self, data,upsert): """ 更新数据库中的数据，如果upsert为Ture，那么当没有找到指定的数据时就直接插入，反之不执行插入 :param data: 要插入的数据 :param upsert: 判断是插入还是不插入 :return: """ self.post.update(&#123;"ip": data&#125;, &#123;'$set': &#123;'ip': data&#125;&#125; , upsert) def find(self,select): """ 根据传入的参数查找指定的值，注意这里的select是字典 :param select: 指定的查找条件，这里的是字典类型的，比如&#123;"name":"chenjiabing","age":22&#125; :return: 返回的是查询的结果，同样是字典类型的 """ return self.post.find(select) def insert(self,data): """ 向数据库中插入指定的数据 :param data: 要插入的数据，这里的是字典的类型比如：&#123;"name":"chenjiabing","age":22&#125; :return: 插入成功返回True,反之返回false """ try: self.post.insert(data) return True except: return False def remove(self,select): """ 删除指定条件的记录 :param select: 指定的条件，这里是字典类型的，比如&#123;"age":22&#125; 表示删除age=22的所有数据 :return: 如果删除成功返回True，else返回False """ try: self.post.remove(select) return True except: return False 下面是利用上面的Mongo.py文件获取西刺网站的代理并且存入数据库 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# coding:utf-8import requestsfrom bs4 import BeautifulSoupimport timefrom Queue import Queueimport threadingfrom Mongo import MongoDB #导入文件class XICI: def __init__(self, page): """ self.header:请求头 self.q:存储ip的队列 slef.urls:页面的url :param page:传入的参数，表示获取多少页的ip """ self.header = &#123;"User-Agent": 'Mozilla/5.0 (Windows NT 6.3; WOW64; rv:43.0) Gecko/20100101 Firefox/43.0'&#125; self.q = Queue() self.urls = [] for i in range(1, page + 1): self.urls.append("http://www.xicidaili.com/nn/" + str(i)) self.mongo = MongoDB('python','ip') # 创建MogoDB对象 def get_ips(self, url): """ 根据一页的请求爬取一个页面的ip :param url:传入的参数，表示每一页的链接 :return: None """ try: res = requests.get(url, headers=self.header) if res.status_code == 200: soup = BeautifulSoup(res.text, 'lxml') ips = soup.find_all('tr') for i in range(1, len(ips)): ip = ips[i] tds = ip.find_all("td") ip_temp = "http://" + tds[1].contents[0] + ":" + tds[2].contents[0] print ip_temp self.q.put(ip_temp) # ip进入队列 except: print "-------------------------------------------请求出现异常------------------------------------------------" def insert(self, url): """ 验证出过来的ip，如果成功就直接存入数据库 :param url: 验证ip地址的url :return: 无返回值 """ while not self.q.empty(): ip = self.q.get() proxy = &#123;"http": ip&#125; print proxy try: res = requests.get(url, headers=self.header, proxies=proxy, timeout=5) if res.status_code == 200: self.mongo.update(ip,True) # 如果成功验证直接进入数据库 print "**************************成功存入数据库********************************************" else: print "这个ip地址不能用" except: print "--------------------------请求失败---------------------------------------------" def main(self): for url in self.urls: self.get_ips(url) threads = [] for i in range(5): t=threading.Thread(target=self.insert,args=["http://blog.csdn.net/qq_34162294/article/details/72353389"]) threads.append(t) for t in threads: t.start()if __name__ == '__main__': p = XICI(3) p.main()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Numpy指南]]></title>
      <url>%2F2017%2F07%2F01%2FNumpy%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[numpy指南 numpy是一个能够处理多维数组的库，虽然python中也内置了处理数组的库，但是这个并不能满足大数据时代的需求，因此产生了可以处理多维数组的numpy 安装 pip install numpy 创建array array函数是一个最基本的创建方式，其中传入的参数是一个序列，既可以创建一维数组，也可以创建二维数组，但是这种方法不太灵活，因为你要把这个序列显式的写出来，先不多说了，自己体会吧 123456import numpy as npa=np.array([1,2,3,4,5]) #创建一个二维数组b=np.array([[1,2,3,4],[2,3,4,5]]) #创建一个二维数组print a.shape #输出数组的维度，(5,)print b.shape #(2,4) arange arange(start,end,step) 创建一个一维数组，起始值为start，终值为end，步长为step，其中np.arrange(10) 表示起始值为0，终值为10，步长为1 12a=np.arange(0,10,1) b=np.arange(10) reshape reshape(a,b)能过改变当前数组的尺寸将其赋值给新的数组，但是当前数组并没有改变，这个用来改变当前数组的维度，可以将以为数组改变为二维数组 123a=np.arange(10) #创建一个有10个元素的一维数组b=np.reshape(2,5) #将改变后的当前数组赋值给b，但是a数组并没有改变 ，2*5=10c=np.reshape(5,-1) #第一个参数为5行，第二个-1表示自动计算生成，10/5=2 linspace linspace(start,end,number) 创建一个等距离的数组，start是起始值，end是终值，number是个数，创建的是一个一维数组，其中的元素全部是浮点数，默认的是包括终值的，但是可以通过endpoint=False指定不包括终值 12a=np.linspace(0,10,10) #包含10的一个等差数组b=np.linspace(0,10,10,endpoint=False) #不包含10的一个等差数组 logspace logspace(start,end,number) 创建的是在10^start和10^end之间包含number个元素的等比数组，创建的是一个等比数组 1a=np.logspace(0,1,10) #创建一个在1-10之间的10个元素的等比数组 存取数据下标存取123456789a=np.arange(10) #[0,1,2,3,4,5,6,7,8,9]a[0] #获取第一个元素的值1a[0:2] #获取下标我0,1的值，注意不包括2a[0:10:1] # 获取下标在0-10之间的(包括0,不包括9)，步长为1的元素，就是每隔一个区娶一个a[1:] #获取从第二个元素开始到最后的所有的元素a[:8] #获取下标为0-8之间的元素(不包括8)a[1::1] #获取下标为0到最后并且步长为1的所有元素a[8:4:-1] #获取起始下标为8，终止下标为4，并且步长为-1，这是从后向前获取元素a[::-1] #将数组逆置 使用整数序列 当使用整数序列对数组元素进行存取时，将使用整数序列中的每个元素作为下标，整数序列可以是列表或者数组。使用整数序列作为下标获得的数组不和原始数组共享数据空间。 12x = np.arange(10,1,-1) x[[3, 3, 1, 8]] # 获取x中的下标为3, 3, 1, 8的4个元素，组成一个新的数组 ufunc ufunc是universal function的缩写，它是一种能对数组的每个元素进行操作的函数。NumPy内置的许多ufunc函数都是在C语言级别实现的，因此它们的计算速度非常快. 12345678910111213np.sin(x) #对数组中的每一个值进行sin操作，并且返回一个数组np.sin(x,y) #对数组x中的值进行sin操纵，所得结果返回给y，但是也返回一个结果数组，这个数组和y共享一块空间的np.add(a,b) #将两个数组中的对应的值都相加，返回的是一个新的数组np.add(a,b,c) # 将两个数组中对应的值相加，结果复制给c，并且返回一个新的数组np.subtract(a,b) # 两个数组相减，a-b,返回的是一个新的数组np.subtract(a,b,c) np.multiply(a,b) #相乘np.multiply(a,b,c) #相乘divide(a,b,[,y]) #相除，如果是两个整数相除，那么返回的是整数true_divide(a,b,[,y]) #相除，总是返回精确的商floor_divide(a,b,[,y]) #总是对返回值取整power(a,b,[,y]) # a^b 平方mod(a,b,[,y]) #取余 %]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lock]]></title>
      <url>%2F2017%2F06%2F22%2FLock%2F</url>
      <content type="text"><![CDATA[Lock 在上一篇文章中我们讲到了如何使用关键字synchronized来实现同步访问。本文我们继续来探讨这个问题，从Java 5之后，在java.util.concurrent.locks包下提供了另外一种方式来实现同步访问，那就是Lock。 也许有朋友会问，既然都可以通过synchronized来实现同步访问了，那么为什么还需要提供Lock？这个问题将在下面进行阐述。本文先从synchronized的缺陷讲起，然后再讲述java.util.concurrent.locks包下常用的有哪些类和接口，最后讨论以下一些关于锁的概念方面的东西 synchronized缺陷 前面我们说过synchronized的线程释放锁的情况有两种: 代码块或者同步方法执行完毕 代码块或者同步方法出现异常有jvm自动释放锁 从上面的synchronized释放锁可以看出，只有synchronized代码块执行完毕或者异常才会释放，如果代码块中的程序因为IO原因阻塞了，那么线程将永远不会释放锁，但是此时另外的线程还要执行其他的程序，极大的影响了程序的执行效率，现在我们需要一种机制能够让线程不会一直无限的等待下去，能够响应中断，这个通过lock就可以办到 另外如果有一个程序，包含多个读线程和一个写线程，我们可以知道synchronized只能一个一个线程的执行，但是我们需要多个读线程同时进行读，那么使用synchronized肯定是不行的，但是我们使用lock同样可以办到 Lock 查看API可知，Lock是一个接口，因此是不可以直接创建对象的，但是我们可以利用其实现的类来创建对象，这个先不着急，我们先看看Lock类到底实现了什么方法,具体的实现我们将会在介绍其实现的类的时候再详细的讲解 方法 lock() 获取锁，如果没有获得就会一直等待 unlock() 释放锁 tryLock() 尝试获得锁，如果成功获得锁就执行，如果没有成功获得锁，那么就不会等待了 lockInterruptibly() 如果当前线程未被中断，则获取锁。 ReentrantLock ReentrantLock是可重入锁，是实现Lock接口的一个类，可重入是一种线程的分配机制，可重入的意思就是总是分配给最近获得锁的线程，这是一种不公平的分配机制，将会出现饥饿现象，当然为了解决这种现象，ReentrantLock的构造方法还提供了一个fair参数，如果fair为true表示使用公平分配机制，将会有等待时间最长的线程获得锁 构造方法 ReentrantLock() 创建一个对象，默认使用的时可重入的机制 ReentrantLock(boolean fair) 如果fair为true那么使用的是公平分配机制 常用方法 lock() 获取锁，如果没有获取到将会一直阻塞 下面使用一段程序演示以下lock方法的使用，代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344//实现接口的线程类public class MyThread implements Runnable &#123; public ReentrantLock rLock = null; //注意这里的锁一定要是全局变量，否则每一个线程都创建一把锁，那么将会毫无意义 public MyThread() &#123; this.rLock = new ReentrantLock(); // 创建默认的可重入锁 &#125; // 将unlock方法放在finally中确保执行中代码出现异常仍然能够释放锁，否则将会造成其它的线程阻塞 public void display() &#123; this.rLock.lock(); // 获取锁 try &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(Thread.currentThread().getName() + "正在输出" + i); &#125; &#125; finally &#123; this.rLock.unlock(); // 释放锁，注意这步是一定需要的 &#125; &#125; @Override public void run() &#123; this.display(); // 调用display方法 &#125;&#125;//线程的测试类，主要是创建对象启动线程public class Test &#123; public static void main(String[] args) &#123; final MyThread thread = new MyThread(); // 创建对象 // 下面创建两个线程,并且直接启动， new Thread(thread).start(); new Thread(thread).start(); &#125;&#125; 执行上面的代码得到下图的结果: 从上面的结果看出，线程是一个一个输出的，并且只有等待一个线程输出完毕才能执行下一个线程，这里的仅仅是针对lock和unlock之间的代码，之外的代码并不是受到控制 注意： 这里的创建的可重入锁的对象必须对于每一个线程来说是全局的变量，是可以共享的一个对象，如果你在display方法中创建这个对象，那么是毫无意义的，因为每一个线程用的根本不是同一把锁 boolean tryLock() 首先尝试获取锁，如果获取锁了就执行，否则就不会一直等待 下面使用一段代码尝试以下这个方法，代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//实现接口的线程类public class MyThread implements Runnable &#123; public ReentrantLock rLock = null; // 注意这里的锁一定要是全局变量，否则每一个线程都创建一把锁，那么将会毫无意义 public MyThread() &#123; this.rLock = new ReentrantLock(); // 创建默认的可重入锁 &#125; // 将unlock方法放在finally中确保执行中代码出现异常仍然能够释放锁，否则将会造成其它的线程阻塞 public void display() &#123; if (this.rLock.tryLock()) // 如果获取了锁 &#123; try &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(Thread.currentThread().getName() + "正在输出" + i); &#125; &#125; finally &#123; this.rLock.unlock(); // 释放锁，注意这步是一定需要的 &#125; &#125; else &#123; System.out.println(Thread.currentThread().getName() + "获取锁失败，我将不会一直等待........"); &#125; &#125; @Override public void run() &#123; this.display(); // 调用display方法 &#125;&#125;//线程的测试类，主要是创建对象启动线程public class Test &#123; public static void main(String[] args) &#123; final MyThread thread = new MyThread(); // 创建对象 // 下面创建两个线程,并且直接启动， new Thread(thread).start(); new Thread(thread).start(); &#125;&#125; 执行后的结果如下图: 从上面的结果我们知道线程0获取了锁开始执行，但是线程1并没有获取锁，但是使用的是tryLock并不是lock,因此不会一直等待下去，所以直接程序向下运行，直接跳过上锁的代码段，因此就输出了上面的那句话后直接结 ReadWriteLock 从API中可以知道，这个也是一个接口，用于实现读写线程，他有两个方法：Lock readLock(),Lock writeLock() 分别用于获得读锁和写锁，指定特定的锁可以实现特定的功能，比如读锁可以在写线程在执行的情况下可以实现多个读线程进行操作，下面我们来介绍它的具体的实现的类ReentrantReadWriteLock ReentrantReadWriteLock 这个类也是一个可重入分配的类，当然前面已经说过了什么是可重入，现在我们来说说说这个类的详细的用法 构造方法 ReentrantReadWriteLock() 使用默认（非公平）的排序属性创建一个新的 ReentrantReadWriteLock。 ReentrantReadWriteLock(boolean fair) 使用给定的公平策略创建一个新的ReentrantReadWriteLock。 常用的方法 ReentrantReadWriteLock.ReadLock readLock() 用于返回读取操作的锁 前面已经说过读取操作的锁是用来实现多个线程共同执行的，代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//实现接口的线程类public class MyThread implements Runnable &#123; public ReentrantReadWriteLock rwlock = null; public Lock rLock = null; public MyThread() &#123; this.rwlock = new ReentrantReadWriteLock(); // 创建对象，使用的是非公平的 this.rLock = this.rwlock.readLock(); // 获取读取锁对象 &#125; // 将unlock方法放在finally中确保执行中代码出现异常仍然能够释放锁，否则将会造成其它的线程阻塞 public void display() &#123; this.rLock.lock(); // 获取读取锁 try &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(Thread.currentThread().getName() + "正在输出" + i); &#125; &#125; finally &#123; this.rLock.unlock(); // 释放锁，注意这步是一定需要的 &#125; &#125; @Override public void run() &#123; this.display(); // 调用display方法 &#125;&#125;//线程的测试类，主要是创建对象启动线程public class Test &#123; public static void main(String[] args) &#123; final MyThread thread = new MyThread(); // 创建对象 // 下面创建两个线程,并且直接启动， for(int i=0;i&lt;5;i++) &#123; new Thread(thread).start(); &#125; &#125;&#125; 执行上面的程序结果如下: 从上面的结果可以知道，其实使用读取操作是多个线程同时进行读取的操作，因此一定要小心谨慎的使用，根据自己的需求，一般不能在里面进行修改了，因为出现结果不准确的结果，这个就不多说了，相信大家都明白，总之要小心使用 ReentrantReadWriteLock.WriteLock writeLock() 返回用于写入操作的锁 写入操作的锁和读取操作的锁不一样了，因为一次只能允许一个线程执行写入操作。 并且如果一个线程已经占用了读锁，另外一个线程申请写锁将会一直等待线程释放读锁。 如果一个线程已经占用了写锁，另外一个线程申请读锁，那么这个线程将会一直等待线程释放写锁才能执行。 总之意思就是写线程和读线程不能同时执行，但是多个读线程可以同时执行 下面将使用一个程序详细的体会以下读写锁的综合使用，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//实现接口的线程类public class MyThread &#123; public ReentrantReadWriteLock rwlock = null; public Lock rLock = null; public Lock wLock = null; public ArrayList&lt;Integer&gt; arrayList = null; public MyThread() &#123; this.rwlock = new ReentrantReadWriteLock(); // 创建对象，使用的是非公平的 this.rLock = this.rwlock.readLock(); // 获取读取锁对象 arrayList = new ArrayList&lt;&gt;(); // 实例化 this.wLock = this.rwlock.writeLock(); // 获取写入锁对象 &#125; // 将unlock方法放在finally中确保执行中代码出现异常仍然能够释放锁，否则将会造成其它的线程阻塞 // //向arraylist中写入数据 public void put() &#123; this.wLock.lock(); // 获取写入锁 try &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(Thread.currentThread().getName() + "正在执行写入操作，写入" + i); this.arrayList.add(i); &#125; &#125; finally &#123; this.wLock.unlock(); &#125; &#125; // 从arraylist中读取数据，这里只是随机读取使用的是get，并没有做什么修改，因为这仅仅是读取操作，如果进行了修改必须实现同步 public void get() &#123; this.rLock.lock(); // 获取读取操作的锁 Random random = new Random(); if (!arrayList.isEmpty()) &#123; try &#123; for (int i = 0; i &lt; 10; i++) &#123; int index = random.nextInt(this.arrayList.size() - 1); int data = this.arrayList.get(index); System.out.println(Thread.currentThread().getName() + "正在读取数据 " + data); &#125; &#125; finally &#123; this.rLock.unlock(); &#125; &#125; else &#123; System.out.println("ArrayList为空"); &#125; &#125;&#125;//线程的测试类，主要是创建对象启动线程public class Test &#123; public static void main(String[] args) &#123; final MyThread thread = new MyThread(); // 创建对象 ArrayList&lt;Thread&gt; arrayList = new ArrayList&lt;&gt;(); /* * 创建8个读线程，2个写线程 */ for (int i = 0; i &lt; 2; i++) &#123; arrayList.add(new Thread() &#123; @Override public void run() &#123; thread.put(); &#125; &#125;); &#125; for(int i=0;i&lt;8;i++) &#123; arrayList.add(new Thread()&#123; @Override public void run() &#123; thread.get(); &#125; &#125;); &#125; for (Thread t : arrayList) &#123; t.start(); &#125; &#125;&#125; 结果如下图: 从上面可以看出写入线程都是一个一个执行的，读取线程是一起执行的 注意： 所有的锁对象对于线程来说必须是全局变量，否则毫无意义。读线程只能进行不影响线程安全性的操作，比如不能进行对数据的修改插入，如果想要进行修改的话必须还要使用锁对必要的代码实现同步操作 参考文章 http://www.cnblogs.com/dolphin0520/p/3923167.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[synchronized]]></title>
      <url>%2F2017%2F06%2F20%2Fsynchronized%2F</url>
      <content type="text"><![CDATA[synchronized前言 相信大家都听说过线程安全问题，在学习操作系统的时候有一个知识点是临界资源，简单的说就是一次只能让一个进程操作的资源，但是我们在使用多线程的时候是并发操作的，并不能控制同时只对一个资源的访问和修改，想要控制那么有几种操作，今天我们就来讲讲第一种方法：线程同步块或者线程同步方法(synchronized) 实例 下面举一个例子说明synchronized关键字的使用 线程同步方法123456789101112131415161718192021222324252627public class Sychor &#123; public void insert(Thread thread) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(thread.getName() + "输出: " + i); &#125; &#125; public static void main(String[] args) &#123; final Sychor sychor = new Sychor(); Thread t1 = new Thread() &#123; public void run() &#123; sychor.insert(Thread.currentThread()); &#125;; &#125;; Thread t2 = new Thread() &#123; public void run() &#123; sychor.insert(Thread.currentThread()); &#125;; &#125;; t1.start(); t2.start(); &#125;&#125; 其中输出结果为下图 从上面的结果可以看出这里的两个线程是同时执行insert()方法的，下面我们在原有的代码上添加synchronized关键字看看效果如何，代码如下:123456789101112131415161718192021222324252627public class Sychor &#123; public synchronized void insert(Thread thread) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(thread.getName() + "输出: " + i); &#125; &#125; public static void main(String[] args) &#123; final Sychor sychor = new Sychor(); Thread t1 = new Thread() &#123; public void run() &#123; sychor.insert(Thread.currentThread()); &#125;; &#125;; Thread t2 = new Thread() &#123; public void run() &#123; sychor.insert(Thread.currentThread()); &#125;; &#125;; t1.start(); t2.start(); &#125;&#125; 上面程序的运行结果我就不列出来，自己可以试试，总之就是加上了synchronized关键字使得线程是一个一个的执行的，只有先执行完一个线程才能执行了另外一个线程。 线程同步块 当然上面的我们使用的是线程同步方法，我们可以使用线程同步块，这两个相比线程同步块更加灵活，只需要将需要同步的代码放在同步块中即可，代码如下；12345678910111213141516171819202122232425262728293031public class Sychor &#123; public void insert(Thread thread) &#123; synchronized (this) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(thread.getName() + "输出: " + i); &#125; &#125; &#125; public static void main(String[] args) &#123; final Sychor sychor = new Sychor(); Thread t1 = new Thread() &#123; public void run() &#123; sychor.insert(Thread.currentThread()); &#125;; &#125;; Thread t2 = new Thread() &#123; public void run() &#123; sychor.insert(Thread.currentThread()); &#125;; &#125;; t1.start(); t2.start(); &#125;&#125; 从上面的代码中可以看出这种方式更加灵活，只需要将需要同步的代码方法在同步块中，不需要同步的代码放在外面 详细原因 我们知道每一个对象都有一把锁，当我们使用线程同步方法或者线程同步块的时候实际上获得是对象的唯一的一把锁，当一个线程获得了这唯一的锁，那么其他的线程只能拒之门外了，注意这里我们说是一个对象，也就是说是同一个对象，如果是不同的对象，那么就不起作用了，因为不同对象有不同的对象锁，比如我们将上面的程序改成如下：123456789101112131415161718192021222324252627282930313233public class Sychor &#123; public void insert(Thread thread) &#123; synchronized (this) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(thread.getName() + "输出: " + i); &#125; &#125; &#125; public static void main(String[] args) &#123; //第一个线程 Thread t1 = new Thread() &#123; public void run() &#123; Sychor sychor = new Sychor(); //在run() 方法中创建一个对象 sychor.insert(Thread.currentThread()); &#125;; &#125;; //第二个线程 Thread t2 = new Thread() &#123; public void run() &#123; Sychor sychor = new Sychor(); //创建另外的一个对象 sychor.insert(Thread.currentThread()); &#125;; &#125;; t1.start(); t2.start(); &#125;&#125; 从上面的结果可知，此时线程同步块根本不起作用，因为他们调用的是不同对象的insert方法，获得锁是不一样的 上面我们已经说过一个对象有一把锁，线程同步方法和线程同步块实际获得的是对象的锁，因此线程同步块的括号中填入的是this，我们都知道this在一个类中的含义 一个类也有唯一的一把锁，我们前面说的是使用对象调用成员方法，现在如果我们要调用类中的静态方法，那么我们可以使用线程同步方法或者同步块获得类中的唯一一把锁，那么对于多个线程同时调用同一个类中的静态方法就可以实现控制了,代码如下:1234567891011121314151617181920212223242526272829public class Sychor &#123; // 静态方法 public static synchronized void insert(Thread thread) &#123; for(int i=0;i&lt;10;i++) &#123; System.out.println(thread.getName()+"输出 "+i); &#125; &#125; public static void main(String[] args) &#123; //第一个线程 Thread t1 = new Thread() &#123; public void run() &#123; Sychor.insert(Thread.currentThread()); //直接使用类调用静态方法 &#125;; &#125;; //第二个线程 Thread t2 = new Thread() &#123; public void run() &#123; Sychor.insert(Thread.currentThread()); //直接使用类调用静态方法 &#125;; &#125;; t1.start(); t2.start(); &#125;&#125; 注意 要想实现线程安全和同步控制，如果执行的是非static同步方法或者其中的同步块，那么一定要使用同一个对象，如果调用的是static同步方法或者其中的同步块那么一定要使用同一个类去调用 如果一个线程访问的是static同步方法，而另外一个线程访问的是非static的同步方法，此时这两个是不会发生冲突的，因为一个是类的锁，一个是对象的锁 如果使用线程同步块，那么同步块中的代码是控制访问的，但是外面的代码是所有线程都可以访问的 当一个正在执行同步代码块的线程出现了异常，那么jvm会自动释放当前线程所占用的锁，因此不会出现由于异常导致死锁的现象 参考文章 http://www.cnblogs.com/dolphin0520/p/3923737.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Thread初探]]></title>
      <url>%2F2017%2F06%2F20%2FThread%E5%88%9D%E6%8E%A2%2F</url>
      <content type="text"><![CDATA[Thread初探前言 以前大家写的都是单线程的程序，全是在main函数中调用方法，可以清楚的看到它的效率是特别低的，就像python中使用单线程取爬一个网站，可以说能让你等的吐血，因为数据量实在太大了，今天我们就来看看java的并发编程多线程的学习 创建线程 创建一个线程可以有多种方法，比如继承Thread类，实现Runnable接口……下面我们来详细的看看创建的方法 继承Thread 为什么继承Thread可以直接调用start()方法启动线程呢，因为start()本身就是Thread的方法，也就是继承了Thread的start()方法，因此这个类的对象可以调用start()启动线程 12345678910111213141516//继承Threadpublic class MyThread extends Thread &#123; public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(this.getName()+"正在跑"); &#125; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Mythread t1=new MyThread(); //创建对象 t1.start(); //启动线程 &#125;&#125; 注意: 继承Thread类的创建方法一个对象只能创建一个线程，并不能多个线程共用一个对象，只能一个线程对应一个对象，因此我们来看看实现Runnable接口的类来实现多个线程共享同一个对象 实现Runnable接口12345678910111213141516171819202122232425//实现Runnable接口public class Demo implements Runnable &#123; @Override public void run() &#123; for(int i=0;i&lt;10;i++) &#123; System.out.println(Thread.currentThread().getName()+"正在跑"); &#125; &#125;&#125;//测试类public class Test&#123; public static void main(String[] args) &#123; Demo d=new Demo(); //创建对象 Thread thread1=new Thread(d); //为对象创建一个线程 Thread thread2=new Thread(d); //创建另外一个线程 //同时启动两个线程 thread1.start(); thread2.start(); &#125;&#125; 从上面可以清楚的看到实现Runnable接口的类一个对象可以供多个线程共享，并不像继承Thread类只为一个线程使用 简便的创建方法 直接在main方法中创建，如果创建的普通类的对象在外面，那么必须是final修饰，可以实现多个线程同时共享一个对象，这个和实现Runnable接口一样，这时候就要控制同步条件了，如果在run方法中定义对象，那么，就是一个线程对应一个对象,这个就和继承Thread类一样的效果。所以可以根据条件自由选择 123456789101112131415161718192021222324252627282930313233343536373839//普通的一个类public class Simple &#123; public void display() &#123; for(int i=0;i&lt;10;i++) &#123; System.out.println(Thread.currentThread().getName()+"正在跑"); &#125; &#125;&#125;//线程测试类public class Test &#123; public static void main(String[] args) &#123; //如果在外面必须使用final，当然也可以直写在run方法中,不过写在外面可以实现多个线程共享一个对象 //写在run方法中当前对象只能为一个线程使用，和继承Thread类一样的效果 final Simple simple=new Simple(); //下面创建使用同一个对象创建同两个线程，实现多个线程共享一个对象，和实现Runnable接口一样的效果 Thread t1=new Thread()&#123; public void run() &#123; simple.display(); &#125;; &#125;; Thread t2=new Thread()&#123; public void run() &#123; simple.display(); &#125;; &#125;; //启动这两个线程 t1.start(); t2.start(); &#125;&#125; 常用的方法 static void sleep(long mils) 使正在运行的线程休眠mils毫秒，但是这里需要注意的是如果线程加了锁，那么使线程休眠并不会释放锁 String getName() 得到线程的名称，上面的程序中已经使用了这个方法 void setName(String name) 设置正在运行的线程的名字为name start() 启动线程，线程的创建并不意味着线程的启动，只有调用start()方法线程才是真正的开始运行 long getId() 返回线程的标识符 run() 线程执行的代码都放在run()方法中，在run方法中的调用是有序的，都是按照程序运行的顺序开始执行 使用 下面使用上面的方法创建一个实例 123456789101112131415161718192021222324252627282930313233343536//线程的类，继承Threadpublic class MyThread1 extends Thread &#123; public void run() &#123; // 重载run方法，并且在其中写线程执行的代码块 for (int i = 0; i &lt; 10; i++) &#123; // 获取线程的id和name System.out.println("Thread-Name: " + this.getName() + " Thread-id: " + this.getId()); try &#123; this.sleep(1000); // 线程休眠1秒 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;//线程测试的类public class Test &#123; public static void main(String[] args) &#123; MyThread1 t1 = new MyThread1(); // 创建线程 t1.setName("第一个线程"); // 设置线程的名字 MyThread1 t2 = new MyThread1(); t2.setName("第二个线程"); t1.start(); // 启动线程，开始运行 t2.start(); &#125;&#125; void join() 等待该线程终止才能运行其他的线程 void join(long mils) 等待该线程的时间为mils毫秒，一旦过了这个时间其他线程正常执行 使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//线程类public class MyThread1 extends Thread &#123; public void run() &#123; // 重载run方法，并且在其中写线程执行的代码块 for (int i = 0; i &lt; 10; i++) &#123; // 获取线程的id和name System.out.println("Thread-Name: " + this.getName() + " Thread-id: " + this.getId()); try &#123; this.sleep(1000); // 线程休眠1秒 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;//测试类public class Test &#123; public static void main(String[] args) &#123; MyThread1 t1 = new MyThread1(); // 创建线程 t1.setName("第一个线程"); // 设置线程的名字 t1.start(); // 启动线程，开始运行 try &#123; t1.join(); //阻塞其他线程，只有当这个线程运行完之后才开始运行其他的线程 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; for (int i = 0; i &lt; 10; i++) &#123; System.out.println("主线程正在运行"); &#125; &#125;&#125;//输出结果/*Thread-Name: 第一个线程 Thread-id: 9Thread-Name: 第一个线程 Thread-id: 9Thread-Name: 第一个线程 Thread-id: 9Thread-Name: 第一个线程 Thread-id: 9Thread-Name: 第一个线程 Thread-id: 9Thread-Name: 第一个线程 Thread-id: 9Thread-Name: 第一个线程 Thread-id: 9Thread-Name: 第一个线程 Thread-id: 9Thread-Name: 第一个线程 Thread-id: 9Thread-Name: 第一个线程 Thread-id: 9主线程正在运行主线程正在运行主线程正在运行主线程正在运行主线程正在运行主线程正在运行主线程正在运行主线程正在运行主线程正在运行主线程正在运行 */ getPriority() 得到当前线程优先级 setPriority(int num) 更改线程的优先级(0-10)默认的是5，优先级越高获得cpu资源的几率就会越高 使用1234567891011121314151617181920212223242526272829303132333435363738394041//线程类public class MyThread1 extends Thread &#123; public void run() &#123; // 重载run方法，并且在其中写线程执行的代码块 for (int i = 0; i &lt; 10; i++) &#123; // 获取线程的id和name System.out.println("Thread-Name: " + this.getName() + " Thread-id: " + this.getId()); try &#123; this.sleep(1000); // 线程休眠1秒 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;//测试类public class Test &#123; public static void main(String[] args) &#123; MyThread1 t1 = new MyThread1(); // 创建线程 t1.setName("第一个线程"); // 设置线程的名字 MyThread1 t2 = new MyThread1(); t2.setName("第二个线程"); t2.setPriority(8); //设置第二个线程的优先级为8，第一个线程的优先级为5(是默认的) t1.start(); t2.start(); &#125;&#125;/* * 从上面的运行结果可以看出大部分的第二个线程都是在第一个线程之前开始执行的，也就是说优先级越高获得cpu执行的几率就越大 * / setDaemon(boolean) 是否设置为守护线程，如果设置为守护线程，那么主线程销毁守护线程也会随之销毁 isDaemon() 判断是否为守护线程 使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//测试类public class MyThread1 extends Thread &#123; public void run() &#123; // 重载run方法，并且在其中写线程执行的代码块 for (int i = 0; i &lt; 10; i++) &#123; // 获取线程的id和name System.out.println("Thread-Name: " + this.getName() + " Thread-id: " + this.getId()); try &#123; Thread.sleep(1000); //休眠一秒，方便主线程运行结束 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; MyThread1 t1 = new MyThread1(); // 创建线程 t1.setName("第一个线程"); // 设置线程的名字 t1.setDaemon(true); t1.start(); for (int i = 0; i &lt; 1; i++) &#123; System.out.println(i); &#125; &#125;&#125;//结果：/* 0123456789Thread-Name: 第一个线程 Thread-id: 9*//* * 从上面的结果可以看出，一旦主线程结束，那么守护线程就会自动的结束 * / 参考文章 http://www.cnblogs.com/dolphin0520/p/3920357.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java字符串进阶]]></title>
      <url>%2F2017%2F06%2F16%2FJava%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%2F</url>
      <content type="text"><![CDATA[Java字符串进阶前言 最常用的对字符串操作的类有三个，分别是String,StringBuilder,StringBuffer，下面将会详细的说说这三个类…… String String类代表字符串，这个是最基本的对字符串的类，这个也是使用比较多的类，这里就不再详细介绍了 构造 new String(String str) new String(StringBuilder str) new String(StringBuffer str) new String(byte[] bys,String charsetName) 通过使用指定的字符集解码指定的 byte 子数组，构造一个新的 String。 常用方法 str charAt(int index) 返回指定索引处的字符 String concat(String str) 将指定字符串str连接到此字符串的结尾，返回连接成功后的字符，因此需要接受才能有效果 boolean contains(CharSequence s) 判断此字符串是否包含指定的char值序列，这里的 CharSequence是一个接口，可以直接使用它的子类作为参数(String,StringBuffer,StringBuild) static String copyValueOf(char[] c) 将字符数组变成字符串并且返回 static String copyValueOf(char[] c,int off,int count) 将截取的字符数组变成字符串并且返回，off是开始截取的下标，count是截取的个数 boolean endWith(String s) 判断字符串是否是以s结尾 boolean equals(Object o) 用于比较 int indexOf(char c) 返回字符c在字符串中第一次出现的索引 int indexOf(char c,int fromIndex) 从指定索引处开始搜索，查找第一次出现的索引 int indexOf(String str) 返回指定子字符串在此字符串中第一次出现处的索引。 int indexOf(String str,int fromIndex) 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。 boolean isEmpty() int length() boolean matches(String regex) 是否匹配正则表达式 trim() 返回字符串的副本，忽略前导空白和尾部空白。 String substring(int beginIndex) 返回一个新的字符串，它是此字符串的一个子字符串。 String substring(int beginIndex, int endIndex) 返回一个新字符串，它是此字符串的一个子字符串。 String toUpperCase() 使用默认语言环境的规则将此 String 中的所有字符都转换为大写。 String[] split(String regex) 根据给定正则表达式的匹配拆分此字符串。 String[] split(String regex, int limit) 根据匹配给定的正则表达式来拆分此字符串。 char[] toCharArray() 将此字符串转换为一个新的字符数组。 byte[] getBytes(Charset charset) 使用给定的 charset 将此 String 编码到 byte 序列，并将结果存储到新的 byte 数组 注意 上面的new String(byte[] bys,String charsetName)这个构造方法很重要，它可以改变字符串的编码集(和byte[] getBytes(Charset charset))配合着使用，下面我们来看一个例子,代码如下:1234567891011121314151617181920212223242526272829 /* * InputStreamReader实现了将字节流FileInputStream转换为字符流，然后使用转换来的字节流创建高效流，从而实现高效的读写 *//* * 编码集(我的eclipse编辑器默认的是utf-8 * 下面将中文字符串的编码集变为GBK写入a.txt文件,因为a.txt默认的是utf-8的因此这里在文件中显示的是乱码 * 然后我们读出来的还是GBK的，因为我们写入的是GBK编码集的，但是我的eclipse是utf-8的编码集，因此在控制台上输出的还是乱码 * new String(byte[] bys,String * charsetName)使用这个构造方法将byte数组改变编码集并且转换为utf-8格式的，那么这次在控制台上输出的就不乱码了 */// 将GBK格式的中文写入a.txt文件File file = new File("src/a.txt");FileOutputStream fileOutputStream = new FileOutputStream(file);String str = "中";byte[] by = str.getBytes("GBK"); // 将字符串改为GBK编码集fileOutputStream.write(by);fileOutputStream.close();//从a.txt文件中读取中文FileInputStream fileInputStream = new FileInputStream(file);int len;byte[] bys = new byte[4];while ((len = fileInputStream.read(bys)) != -1) &#123; System.out.println(new String(bys, "GBK"));&#125;fileInputStream.close(); StringBuffer 线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。当然最重要的一点就是线程安全，我们可以从它的源码中可以看出，对于一些操作(append,insert..)都是使用了线程控制块来实现同步，适合与多线程下的使用，源代码如下:1234567891011121314151617181920212223public synchronized StringBuffer append(Object obj) &#123; super.append(String.valueOf(obj)); return this;&#125;public synchronized StringBuffer append(String str) &#123; super.append(str); return this;&#125;public synchronized StringBuffer delete(int start, int end) &#123; super.delete(start, end); return this;&#125;/** * @throws StringIndexOutOfBoundsException &#123;@inheritDoc&#125; * @since 1.2 */public synchronized StringBuffer deleteCharAt(int index) &#123; super.deleteCharAt(index); return this;&#125; 构造 new StringBuffer(StringBuilder str) new StringBuffer(String str) 常用的方法 StringBuffer append(str)将指定类型的str追加到此字符串的后面(String,char,char[],int,double,float,long,StringBuffer,StringBuilder) StringBuffer insert(int offest, str) 将指定类型的str插入到此序列中,offest表示开始插入的位置的索引,类型有 String,char,char[],int,double,float,long,StringBuffer,StringBuilder String delete(int fromIndex,int endIndex) 移除此序列中的字符串并且返回新的缓冲字符串 StringBuffer reverse() 反转字符串 String substring(int start) 返回一个新的 String，它包含此字符序列当前所包含的字符子序列。 String substring(int start, int end) 返回一个新的 String，它包含此序列当前所包含的字符子序列。 StringBuffer deleteCharAt(int index) 移除此序列指定位置的 char。 int length() 长度 String toString() 返回此序列中数据的字符串表示形式。 StringBuilder 建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。但是这个类不是线程安全的，只适合单线程，如果使用多线程推荐使用StringBuffer,当然使用这个也行，不过需要自己实现同步 构造方法 new StringBuilder(String str) 常用方法 这个类的常用方法和StringBuffer的一样，这里就不再一一列举了，参照上面的即可使用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java正则表达式]]></title>
      <url>%2F2017%2F06%2F16%2FJava%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[Java正则表达式 java.util.regex是一个用正则表达式所订制的模式来对字符串进行匹配工作的类库包。它包括两个类：Pattern和Matcher。Pattern是一个正则表达式经编译后的表现模式。Matcher对象是一个状态机器，它依据Pattern对象做为匹配模式对字符串展开匹配检查。 首先一个Pattern实例订制了一个所用语法与PERL的类似的正则表达式经编译后的模式，然后一个Matcher实例在这个给定的Pattern实例的模式控制下进行字符串的匹配工作。 正则表达式的构造摘要 详细摘要请看jdk中文文档,下面我只是列出一些经常使用的 构造 匹配 . 任何字符（与行结束符可能匹配也可能不匹配） \d 数字：[0-9] \D 非数字： [^0-9] \s 空白字符：[ \t\n\x0B\f\r] \S 非空白字符：[^\s] \w 单词字符：[a-zA-Z_0-9] \W 非单词字符：[^\w] [abc] a、b 或 c（简单类） [^abc] 任何字符，除了 a、b 或 c（否定） [a-zA-Z] a 到 z 或 A 到 Z，两头的字母包括在内（范围） ^ 行的开头 $ 行的结尾 X? X，一次或一次也没有 X* X，零次或多次 X+ X，一次或多次 X{n} X，恰好 n 次 X{n,} X，至少 n 次 X{n,m} X，至少 n 次，但是不超过 m 次 Pattern 正则表达式的编译表示形式,学过python的都知道这个和python的正则表达式有异曲同工之妙。 但是它的构造方法是私有的，因此不能直接创建对象，但是可以调用它的静态方法返回一个对象，下面会详细介绍 创建对象 Pattern类用于创建一个正则表达式,也可以说创建一个匹配模式,它的构造方法是私有的,不可以直接创建,但可以通过Pattern.complie(String regex)简单工厂方法创建一个正则表达式，代码如下：12345//采用的complie(String regex)Pattern pattern = Pattern.compile("\\d+");//采用的是complie(String regex,int flag)其中flag表示标志，下面的标志表示忽略字母大小写，详细的字段请看文档Pattern pattern=Pattern.compile("(CHEN)(\\D*)(\\d*)",Pattern.CASE_INSENSITIVE); 常用方法 Pattern compile(String regex) 用于创建Pattern对象 Pattern compile(String regex,int flags) 用于创建Pattern对象，并且指定了标志(比如忽略字母大小写) int flags() 返回此模式的匹配标志 String pattern() 返回在其中编译过此模式的正则表达式。 String[] split(CharSequence input) 根据此模式的正则表达式将输入的字符串拆分成String数组,默认的都是全部拆分开 1234 //给出正则表达式用于匹配数字(0-9) Pattern pattern = Pattern.compile("\\d+"); String str = "我是陈加兵456郑元梅34擦市场的逻辑啊";String[] splits = pattern.split(str, 2); //结果:[我是陈加兵,郑元梅34擦市场的逻辑啊] String[] split(CharSequence input,int limit) 将字符串按照正则表达式表示的内容进行分组，如果limit&gt;0那么就分成limit个组，如果limit&lt;0就按照默认全部分开 1234//给出正则表达式用于匹配数字(0-9)Pattern pattern = Pattern.compile("\\d+");String str = "我是陈加兵456郑元梅34擦市场的逻辑啊";String[] splits = pattern.split(str, 2); //结果:[我是陈加兵,郑元梅34擦市场的逻辑啊] Pattern.matches(String regex,CharSequence input)是一个静态方法,用于快速匹配字符串,该方法适合用于只匹配一次,且匹配全部字符串 123Pattern.matches("\\d+","2223");//返回true Pattern.matches("\\d+","2223aa");//返回false,需要匹配到所有字符串才能返回true,这里aa不能匹配到 Pattern.matches("\\d+","22bb23");//返回false,需要匹配到所有字符串才能返回true,这里bb不能匹配到 Matcher matcher(CharSequence input) 创建匹配给定输入与此模式的匹配器,现在只是先了解以下，下面会详细解释Matcher这个类 12Pattern p=Pattern.compile("\\d+"); Matcher m=p.matcher("22bb23"); Matcher Pattern类只能做一些简单的匹配操作,要想得到更强更便捷的正则匹配操作,那就需要将Pattern与Matcher一起合作.Matcher类提供了对正则表达式的分组支持,以及对正则表达式的多次匹配支持.Matcher类和Pattern类一样它的构造方法同样是私有的，因此不能直接构造对象，但是上面我们说过Pattern类中有一个方法可以返回一个Matcher对象(matcher(CharSequence input)) 常用的方法 boolean mathces() 尝试将整个区域与模式匹配(针对的是整个字符串，如果整个字符串未完全匹配，那么返回false,如果完全匹配那么返回true) 12345 Pattern pattern=Pattern.compile("\\d+"); //创建Pattern对象String str="I am hreo 1234"; //需要匹配的字符串Matcher matcher=pattern.matcher(str); //并没有完全匹配，因此返回false，如果str="123445"，那么就会返回trueSystem.out.println(matcher.matches()); boolean lookingAt() 尝试从给定字符串的开头开始匹配，如果有子字符串匹配成功，那么返回true(针对的不是整个字符串，而是从开头开始，如果开头有一段字符串匹配成功，那么返回true) 12345 Pattern pattern=Pattern.compile("\\d+"); //创建Pattern对象String str="1234 I am a hero"; //需要匹配的字符串Matcher matcher=pattern.matcher(str);//开头的1234匹配到了，因此返回true，如果str="I am a hero 1234"将返回falseSystem.out.println(matcher.lookingAt()); int start() 匹配到的字符串的第一个元素的索引,如果没有匹配到调用此方法将会报错 int end() 匹配到的字符串的最后一个元素的索引,如果没有匹配到调用此方法将会报错 String group() 返回的是匹配到的字符串,如果没有匹配到调用此方法将会报错 123456789 Pattern pattern=Pattern.compile("\\d+"); //创建Pattern对象String str="1234 I am a hero 33455"; //需要匹配的字符串Matcher matcher=pattern.matcher(str);if(matcher.lookingAt())&#123; System.out.println("开始匹配到下标为"+matcher.start()); //0 System.out.println("匹配结束的下标为"+matcher.end()); //4 System.out.println("匹配的字符串为"+matcher.group()); //1234&#125; boolean find() 查找整个字符串，如果在任意位置有一段字符串能够匹配成功，那么返回true(任意位置),然后如果再次调用这个查找的话，那么就从上次查找到的末尾开始匹配，也就是说查找的是下一个子序列了 123456789101112131415161718192021222324252627 Pattern pattern=Pattern.compile("\\d+"); //创建Pattern对象String str="1234 I am a hero 6666 chenjiabing8888"; //需要匹配的字符串Matcher matcher=pattern.matcher(str);while(matcher.find()) //如果还有匹配的字符序列&#123; System.out.println("开始匹配到下标为"+matcher.start()); System.out.println("匹配结束的下标为"+matcher.end()); System.out.println("匹配的字符串为"+matcher.group()); &#125; /*结果如下： * 开始匹配到下标为0 匹配结束的下标为4 匹配的字符串为1234 开始匹配到下标为17 匹配结束的下标为21 匹配的字符串为6666 开始匹配到下标为33 匹配结束的下标为37 匹配的字符串为8888 */ /* * 从上面返回的结果可以知道，find()可以匹配多次只要这个字符串还有可以匹配， * 并且每次的匹配字段的开始下标都是上一次匹配的结束字母的下一个下标 */ boolean find(int start) 从指定的索引start位置开始匹配，这个用于重置find()匹配器，因为直接使用find()它的每次开始的索引都是不一样的 String group(int num) 返回指定分组匹配到的字符串,group(0)表示匹配到的整个字符串,group(1) 表示匹配到的第一个字符(即是第一个括号中匹配的模式) int groupCount() 返回匹配到的分组个数 String replaceAll(String str) 将所有于模式相匹配的 字符串全部替换程指定的字符串str,返回的是替换后的文本 String replaceFirst(String str) 只将第一次匹配到的字符串替换成指定的字符串str，返回的时替换后的文本 12345678910Pattern pattern=Pattern.compile("\\d+");String str="chenjiabing2344cal3445";Matcher matcher=pattern.matcher(str);str=matcher.replaceFirst("陈加兵"); System.out.println(str); //输出:chenjiabing陈加兵cal3445 /* * str=matcher.replaceAll("陈加兵"); * System.out.println(str) //输出:chenjiabing陈加兵cal陈加兵 */ 捕获组 捕获组可以通过从左到右计算其开括号来编号，编号是从1 开始的。例如，在表达式 ((A)(B(C)))中，存在四个这样的组：1234((A)(B(C)))(A)(B(C))(C) 总之在正则表达式中在括号中的就是一个分组,下面用一个实例来理解一下12345678910 Pattern pattern=Pattern.compile("(\\D*)(\\d+)\\s(\\D+)");Matcher matcher=pattern.matcher("chenjiabingshizuibangde6666 chenjiabign");if(matcher.find())&#123; System.out.println("总共匹配到了"+matcher.groupCount()+"个分组"); System.out.println("匹配到整个字符串为"+matcher.group(0)); System.out.println("匹配到的第一个字符串为"+matcher.group(1)); System.out.println("匹配到的第二个字符串为"+matcher.group(2)); System.out.println("匹配到的第三个字符串为"+matcher.group(3));&#125; 贪婪模式和非贪婪模式 贪婪与非贪婪模式影响的是被量词修饰的子表达式的匹配行为，贪婪模式在整个表达式匹配成功的前提下，尽可能多的匹配，而非贪婪模式在整个表达式匹配成功的前提下，尽可能少的匹配一般写python爬虫的时候使用的都是非贪婪模式来匹配使用了贪婪模式后会尽可能匹配更多的字符串，即是到了正则表达式定的末尾但是还是会继续向后匹配，看看是否还能匹配，非贪婪模式则是相反，到了正则表达式定义的结束字符就直接停止匹配了贪婪模式: .* , .+非贪婪模式: .*? , .+? 实例123456789101112 //使用了贪婪模式,因此当匹配到第一个&lt;/div&gt;的时候还要向后面匹配看看是否还能匹配到，由于后面还有&lt;/div&gt;结尾的，因此还是能够匹配的，因此匹配到的是:陈加兵&lt;/div&gt;&lt;div&gt;郑元梅 Pattern pattern=Pattern.compile("&lt;div&gt;(.*)&lt;/div&gt;"); //使用了非贪婪模式，因此当匹配到第一个&lt;/div&gt;的时候就不向后面匹配了，直接返回了，因此匹配到的是:陈加兵Pattern pattern1=Pattern.compile("&lt;div&gt;(.*?)&lt;/div&gt;"); String str="&lt;div&gt;陈加兵&lt;/div&gt;&lt;div&gt;郑元梅&lt;/div&gt;";Matcher matcher=pattern1.matcher(str);if(matcher.find())&#123; System.out.println(matcher.groupCount()); //1 System.out.println(matcher.group(1)); //输出匹配到的字符串,此时输出的是:陈加兵,如果使用贪婪模式输出的是：陈加兵&lt;/div&gt;&lt;div&gt;郑元梅&#125; 参考文章 http://www.cnblogs.com/ggjucheng/p/3423731.html http://www.runoob.com/java/java-regular-expressions.html http://blog.csdn.net/lxcnn/article/details/4756030]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java日期格式化]]></title>
      <url>%2F2017%2F06%2F15%2FJava%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96%2F</url>
      <content type="text"><![CDATA[日期格式化前言 更多文章请看本人博客https://chenjiabing666.github.io/ 版权所有，如需转载请注明来源 Date Date类表示特定的瞬间精确到毫秒，不过从API可以看出很多的方法已经废弃了，这个类已经在过多使用了，不过还是需要了解一下的，为了后面的学习做铺垫 构造方法 new Date() 常用的方法 long getTime() 返回计算机上面的时间，返回的是毫秒 setTime(long s) 用给定的毫秒值s设置时间 实例12Date date=new Date();System.out.println(date.getTime()); SimpleDateFormat 这个类是一个简单的格式化日期的类，继承与DateFormat,相对于父类来说使用简单 构造方法 new SimpleDateFormat() 使用默认的格式化模板创建对象 new SimpleDateFormat(String pattern) 使用指定的格式化模板创建对象 常用的方法 String format(Date date) 将给定的日期格式化指定的模板的样式,比如2017-01-29 23:22:11 applyPattern(String pattern) 将给定的格式应用于此日期的格式，相当于直接使用new Date(String pattern) Date parse(String d) 将给定的格式化的日期格式字符串转换成Date对象，需要注意的是转化的时候定义的模板一定要和字符串的日期格式的模板一样，否则将会解析不正确的形式 常用的日期格式化的模板 实例 使用默认的模板格式化日期 123SimpleDateFormat dateFormat=new SimpleDateFormat(); //默认的格式String formateString=dateFormat.format(date); //格式化当前的日期System.out.println(formateString); 使用指定的模板格式化日期 123String model="yyyy-MM-dd-FF HH:mm:ss"; //指定格式化的模板SimpleDateFormat dateFormat2=new SimpleDateFormat(model);System.out.println(dateFormat2.format(date)); 将格式化的日期转换成Date类型的，使用的parse(String s)，需要注意的是，下面定义的模板一定要和给定的格式化后的日期格式一样，否则转换后Date类型的毫秒值可能不正确 12345678910 String d = "2017-06-12 22:34:19"; //给出格式化后的日期String pattern = "yyyy-MM-dd HH:mm:ss"; //按照上面的日期格式定义模板，这个一定要完全和上面的一样，否则转换不正确SimpleDateFormat dateFormat = new SimpleDateFormat(pattern);try &#123; Date date = dateFormat.parse(d); //解析成Date类型 System.out.println(dateFormat.format(date));&#125; catch (ParseException e) &#123; System.err.println("解析错误");&#125; 综合使用：计算时间差 12345678910111213Scanner scanner=new Scanner(System.in);System.out.println("请输入年-月-日");String startTime=scanner.next();System.out.println("请输入结束时间(年-月-日)");String endTime=scanner.next();String moudle="yyyy-MM-dd"; //定义时间模板//创建指定模板的解析SimpleDateFormat dateFormat=new SimpleDateFormat(moudle);Date startDate=dateFormat.parse(startTime);//解析开始时间Date endDate =dateFormat.parse(endTime);//解析结束时间long time=startDate.getTime()-endDate.getTime(); //返回两个时间的差，毫秒int day=(int)(time/1000/60/60/24); //转化为天数，1秒等于1000毫秒，一分钟等于60秒，一小时等于60分钟，一天等于24小时System.out.println(day); Calendar Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等 日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。瞬间可用毫秒值来表示，它是距历元（即格林威治标准时间 1970 年 1 月 1 日的 00:00:00.000，格里高利历）的偏移量。 创建对象 Calendar.getInstance() 常用方法 int get(int field) 返回当前对象的一些日期信息 Date getTime() 获得当前日期的Date对象 add(int field,int amount) 根据日历的规则，为给定的日历字段添加或减去指定的时间量。例如，要从当前日历时间减去 5 天，可以通过调用以下方法做到这一点：add(Calendar.DAY_OF_MONTH, -5)。 setTime(Date date) 使用给定的Date对象，设置Calendar时间 实例 get方法获取一些字段的值 1234567891011121314151617181920 Calendar calendar = Calendar.getInstance(); // 创建对象System.out.println(calendar.get(Calendar.YEAR));// 获取年份System.out.println(calendar.get(Calendar.MONTH) + 1);// 月，从0开始，即是输出5表示6月System.out.println(calendar.get(Calendar.DATE));// 获取一个月中的第几天System.out.println(calendar.get(Calendar.HOUR)); // 小时System.out.println(calendar.get(Calendar.MINUTE)); // 分钟System.out.println(calendar.get(Calendar.SECOND)); // 秒System.out.println(calendar.get(Calendar.AM_PM)); // 获得是上午还是下午AM=0,PM=1System.out.println(calendar.get(Calendar.DAY_OF_MONTH)); // 一个月中的第几天System.out.println(calendar.get(Calendar.DAY_OF_WEEK)); // 一周中的第几天，星期日是第一天System.out.println(calendar.get(Calendar.DAY_OF_YEAR));// 一年中的第几天System.out.println(calendar.get(Calendar.HOUR_OF_DAY)); // 一天中的第几小时if (calendar.get(Calendar.AM_PM) == Calendar.AM) &#123; System.out.println("现在是上午");&#125;if (calendar.get(Calendar.MONTH) + 1 == Calendar.JULY) &#123; System.out.println("现在是6月");&#125; Date getTime()方法的使用 12345Calendar calendar=Calendar.getInstance();Date date=calendar.getTime(); //获得Date对象String pattern="yyyy-MM-dd HH:mm:ss";SimpleDateFormat dateFormat=new SimpleDateFormat(pattern);System.out.println(dateFormat.format(date)); add(int field,int amount)方法的使用 123 Calendar calendar=Calendar.getInstance();calendar.add(Calendar.DATE, -2);System.out.println(calendar.get(Calendar.DATE)); 综合实例：计算出当前的准确日期 12345678910111213141516171819 Calendar calendar = Calendar.getInstance();int year = calendar.get(Calendar.YEAR);int month = calendar.get(calendar.MONTH) + 1; // 从0开始算，因此加1int date = calendar.get(Calendar.DATE);int week = calendar.get(Calendar.WEEK_OF_MONTH) + 1; // 从周日开始算，因此加1int hour = calendar.get(Calendar.HOUR);int minute = calendar.get(Calendar.MINUTE);int seconds = calendar.get(Calendar.SECOND);if (calendar.get(Calendar.AM_PM) == Calendar.AM) &#123; System.out.println("现在是" + year + "年" + month + "月" + date + "号" + "星期" + week + "上午" + hour + "点" + minute + "分" + seconds + "秒");&#125; else &#123; System.out.println("现在是" + year + "年" + month + "月" + date + "号" + "星期" + week + "下午" + hour + "点" + minute + "分" + seconds + "秒");&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java反射机制]]></title>
      <url>%2F2017%2F06%2F14%2FJava%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%2F</url>
      <content type="text"><![CDATA[Java反射机制前言 网页版的jdk的API 离线版API 什么是反射机制 反射是java语言的一个特性，它允程序在运行时（注意不是编译的时候）来进行自我检查并且对内部的成员进行操作。例如它允许一个java的类获取他所有的成员变量和方法并且显示出来。这个能特定我们不常看到，但是在其他的比如C或者C++语言中很不就存在这个特性。一个常见的例子是在JavaBean中，一些组件可以通过一个构造器来操作。这个构造器就是用的反射在动态加载的时候来获取的java中类的属性的。 主要的类 Class 类的实例表示正在运行的 Java 应用程序中的类和接口。Class没有公共的构造方法，Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的 Constructor 提供关于类的单个构造方法的信息以及对它的访问权限(主要提供的是对构造方法使用) Method 提供关于类或接口上单独某个方法（以及如何访问该方法）的信息。所反映的方法可能是类方法或实例方法（包括抽象方法) Field 主要提供对类中的成员变量的访问和使用 Class Class类也使用了泛型，即是Class这种形式的，可以直接使用一个具体的类传入，这样的话就不需要强制转换了，比如Class.newInstance()这样使用默认的构造方法构造一个对象就需要不再需要强制转换了即使用(ClassName)Class.newInstance() 常用的方法 getConstructor(Class[] params) 获取公共的(public)的构造方法，并且限定其中的参数个数和类型可以获得不同的公共构造方法 Constructor[] getConstructors() 返回所有的公共(public)的构造方法 getDeclaredConstructor(Class[] params) 获取所有指定的构造方法，但是需要注意的是当获取私有的构造方法的时候需要使用setAccessible设置访问权限为true才能进行构造，否则出现异常 Constructor[] getDeclaredConstructors() 返所有的构造方法包括public和private，protected修饰的 T newInstance() 返回的是一个调用默认的构造方法(public class_name())实例化的一个Object对象，如果使用泛型那么就返回T类型的，反之返回的是Object需要强制转换才能使用这个对象调用成员函数和成员变量 Class forName(String class_name) 返回class对象，每一个类都有一个方法返回Class对象(类名.class)，注意这里的参数一定是具体的路径，包括包的名字，比如demo.Test Package getPackage() 返回此类所在的包名(package demo) 当然也可以使用Package.getName()获得包的名字(demo)比如class1.getPackage().getName() int getModifiers() 返回的是类的修饰符的整数 类型(修饰符的类型有public private protected)其中得到整数可以使用Modifier中toString(int num)得到public，private，protected的类型,比如Modifier.toString(class1.getModifiers())*Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 返回指定参数的方法Method对象,注意这里仅仅是返回的时公共的方法(public) 比如:Method method=class1.getMethod(&quot;display&quot;,new Class[]{int.class})这里的display是方法的名字，有一个参数，类型为int Method[] getMethods() 获取所有的公共的方法(public)返回的是一个数组(Method) Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes)返回所有的指定的参数的方法(public,private,protected，但是不包括继承的),其中参数可以为null(无参数) Method[] getDeclaredMethods() 获取所有的方法 Field getField(String name) 指定名字的公共成员变量(public) Field[] getFields() 获取所有的公共的成员变量 Field getDeclaredField(String name) 获取所有的指定名称的成员变量(public,protected,private),同样在调用私有成员变量的时候需要先设置访问的权限,field.setAccessible(true) Field[] getDeclaredFields() 获取所有的成员变量(public,protected,private) getSuperclass() 返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的超类的 Class。 URL getResource(String name) 查找指定名称的资源(图片，文件…)注意这个资源一定要和指定类在一个包中，否则返回null，比如查找Test类下的airplane.png图片:Test.class.getResource(&quot;airplane.png&quot;)这里返回的将是绝对路径 获取Class的对象并且实例化 使用Class.forName(String className) 其中className一定是包含包的名字，下面的demo就是包的名字，Test是类的名字。这是最常用的方法，学过JDBC的都知道加载驱动的时候就是使用的Class.forName() 12345/* * 第一种使用forName(String className),其中className一定是包含包的名字，下面的demo就是包的名字，Test是类的名字 */Class cls=Class.forName("demo.Test");Test test=(Test)cls.newInstance(); //这里只是使用了默认的构造方法实例化对象 使用类名.class 1Class cls=Test.class; 使用对象.getClass() 12Test test=new Test();Class cls=test.getClass(); Constructor 主要是用来对类的构造方法进行操作的，可以看出这个也使用了泛型，和上面的Class是一样的，注意这里如果没有使用泛型，那么原本放回T类型的现在都是返回Object 常用的方法 T newInstance(Object parms) 使用带有参数的构造方法实例化对象，如果使用了泛型，那么返回的就是T类型的，反之返回的是Object类型的，需要强制转换 getName() 以字符串的形式返回构造方法的名称，具体的路径包含包名(demo.Test) int getModifiers() 和Class类中的方法一样 Method 主要提供的是对类中的方法的操作 常用的方法 Object invoke(Object obj,object args) 使用得到的Method对象调用方法，obj是类的已经构造好的对象，如果是静态方法直接写null,因为静态方法的调用不需要对象，返回值是Object类型的，如果接受返回值，需要使用强制转换成相应的类型,args是传入的参数,如果有多个参数，那么可以直接在后面用逗号添加或者直接创建数组new Object[]{22,&quot;chenjiabing&quot;}比如：method.invoke(test,22,&quot;chenjiabing&quot;) method.invoke(test,new Object[]{22,&quot;chenjiabing&quot;})注意：如果调用的private类型的方法，那么需要在前面设置访问的权限,method.setAccessible(true) String getName() 返回此方法的名字(display) Modifier getModifiers() 返回此方法的修饰符的类型表示的整数(public,private…),可以使用Modifier.toString()转换成字符串形式 Class getReturnType() 返回这个方法的返回类型 String toString() 返回这个方法表示的字符串的形式 Field 主要提供对类的成员变量的操作 常用方法 String getName() 返回变量名字 Object get(Object obj) 返回此变量在指定对象中的值，因为在构造对象的时候每一个传入的变量的值都不一样，因此需要使用对象obj。obj表示传入的对象，返回的Object类型，因此需要强制转换 void set(Object obj,Object value) 改变obj对象上的变量的值为value Modifier getModifiers() 返回整数表示修饰的类型 String getType() 获取变量的类型(int,String,double float…..) Modifier Modifier 类提供了 static 方法和常量，对类和成员访问修饰符进行解码。修饰符集被表示为整数，用不同的位位置 (bit position) 表示不同的修饰符。 常用的方法 static String toString(int mode) 将代表修饰符的整数形式转换为字符串形式的修饰符，比如将1转换成public static isInterface(int mode) 如果整数参数包括 interface 修饰符，则返回 true，否则返回 false static isStatic(int mode) static isPrivate(int mode) static isPublic(int mode) static isAbstract(int mode) 实例1Modifier.toString(Test.class.getModifiers()) //得到Test类的修饰符 使用 有了上面的铺垫，我们就可以使用上面的这些类进行操作了，在进行操作之前，我们需要先定义一个类Test,放在demo包下，内容如下 12345678910111213141516171819202122232425262728293031323334package demo;import java.util.jar.Attributes.Name;import javax.print.attribute.standard.MediaSize.NA;public class Test &#123; public String name; private int age; public Test() &#123; this.name = "陈加兵"; this.age = 23; &#125; public Test(String name, int age) &#123; this.name = name; this.age = age; &#125; public void display() &#123; System.out.println("name=" + this.name + "----age=" + this.age); &#125; public void set(String name, int age) &#123; this.name = name; this.age = age; &#125; private int getAge() &#123; return this.age; &#125;&#125; 实例化对象 使用Class默认的构造newInstance() 123 Class class1=Class.forName("demo.Test"); //静态加载ClassTest test=(Test)class1.newInstance(); //调用默认的构造方法(public Test())实例化对象，由于没有使用泛型，因此需要强转test.display(); //调用display方法 使用Class中的getConstructor()方法构造对象,需要注意的使用private类型构造方法时一定要先设置访问权限为true-constructor.setAccessible(true); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 /* *调用public Test(String name,int age)得到Constructor的两种形式 * 1.Constructor constructor=class1.getConstructor(new Class[]&#123;String.class,int.class&#125;); * 2.Constructor constructor=class1.getConstructor(String.class,int.class);这个和上面的是一样的，就是使用的参数形式不一样 * * * * *使用newInstance()构造对象的两种方式 * 1.Test test=(Test)constructor.newInstance(new Object[]&#123;"chenjiabing",22&#125;); * 2.Test test=(Test)constructor.newInstance("chenjiabing",22); 只是形式不同而已，不过我还是喜欢上面的形式 * */ /* * 调用public Test(String name,int age) * Class.getConstructor()得到的是公共的构造方法，如果有私有的构造方法，那么就会报错，这时就要使用getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) * Test test=(Test)constructor.newInstance("陈加兵",22); * * * 调用public Test() * Constructor constructor=class1.getConstructor(null); * Test test=(Test)constructor.newInstance(null); * * * 调用private Test(int age) * Constructor constructor=class1.getDeclaredConstructor(new Class[]&#123;int.class&#125;); constructor.setAccessible(true); //因为private类型是不可以直接访问的，因此需要设置访问权限为true Test test=(Test)constructor.newInstance(new Object[]&#123;1000&#125;); */ Class class1=Class.forName("demo.Test"); //访问public Test(String name,int age)// Constructor constructor=class1.getConstructor(new Class[]&#123;String.class,int.class&#125;);// Test test=(Test)constructor.newInstance("陈加兵",22); //访问默认的构造方法// Constructor constructor=class1.getConstructor(null);// Test test=(Test)constructor.newInstance(null); //访问private类型的构造方法 Constructor constructor=class1.getDeclaredConstructor(new Class[]&#123;int.class&#125;); constructor.setAccessible(true); Test test=(Test)constructor.newInstance(new Object[]&#123;1000&#125;); test.display(); 成员方法的操作 使用Class.getMethod()和Class.getDeclaredMethod()方法获取方法，这两个方法的区别前面已经说过了，注意的是调用私有成员方法的之前一定要设置访问权限(method.setAccessible(true)) Method类中的其他方法前面也已经说过了，详细使用请自己尝试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 /* * 获取Method对象的两种方式: * 1.Method method_set=class1.getMethod("set", new Class[]&#123;String.class,int.class&#125;); * 2.Method method_set=class1.getMethod("set", String.class,int.class); * * * 使用Method.invoke()调用方法的两种方式 * 1.Object o=method_set.invoke(test, new Object[]&#123;"陈加兵",200&#125;); * 2.Object object=method_set.invoke(test, "陈加兵",2000); */ /* * 获取公共方法(public)： * 1.Method method=class1.getMethod("display",null); //public void display() * 2.Method method_set=class1.getMethod("set", new Class[]&#123;String.class,int.class&#125;); //获取public void set(String name,int age) * * * 获取私有方法(private,protected) * 1.Method method_getAge=class1.getDeclaredMethod("getAge", null); */ //使用构造方法构造一个Test对象 Class class1 =Class.forName("demo.Test"); Constructor&lt;Test&gt; constructor=class1.getDeclaredConstructor(new Class[]&#123;String.class,int.class&#125;); Test test=constructor.newInstance(new Object[]&#123;"陈加兵",22&#125;); Method method=class1.getMethod("display",null); //获取public void display()方法的Method对象 Object obj=method.invoke(test, null); //调用方法display //获取public void set(String name,int age)// Method method_set=class1.getMethod("set", new Class[]&#123;String.class,int.class&#125;); Method method_set=class1.getMethod("set", String.class,int.class); // Object o=method_set.invoke(test, new Object[]&#123;"陈加兵",200&#125;); Object object=method_set.invoke(test, "陈加兵",2000); test.display(); //获取私有方法private int getAge() Method method_getAge=class1.getDeclaredMethod("getAge", null); method_getAge.setAccessible(true); //必须设置访问权限为true //判断返回值类型是否为int类型的 if("int".equals(method_getAge.getReturnType().toString())) &#123; int ReturnData=(int) method_getAge.invoke(test, null); //调用并且获取返回值 System.out.println(ReturnData); &#125; 成员变量的操作 主要使用的Field类，前面已经详细的说过了 123456789101112131415161718/* * 获取public修饰的成员变量： * 1.Field field=class1.getField("name"); //获取public的成员变量name的Filed对象 * * 获取private，protected修饰的成员变量： * 1. Field field2=class1.getDeclaredField("age"); */ Class class1=Class.forName("demo.Test"); Test test=new Test("陈加兵",1000); Field field=class1.getField("name"); //获取public的成员变量name的Filed对象 System.out.println(field.get(test)); //获得test对象中的name属性的值 //获取private int age的Field对象 Field field2=class1.getDeclaredField("age"); field2.setAccessible(true); //设置访问权限 System.out.println(field2.get(test)); 参考文章 http://www.cnblogs.com/octobershiner/archive/2012/03/18/2404751.html http://www.cnblogs.com/ixenos/p/5699420.html https://yq.aliyun.com/wenzhang/show_17985]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java IO学习笔记总结]]></title>
      <url>%2F2017%2F05%2F26%2FJava-IO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[Java IO学习笔记总结前言 前面的八篇文章详细的讲述了Java IO的操作方法，文章列表如下 基本的文件操作 字符流和字节流的操作 InputStreamReader和OutputStreamWriter操作 内存操作流 管道流 打印流 System对IO的支持 BufferedReader和BufferedWriter 后续字节流 字节流的操作都是基于InputStream和OutputStream这两个抽象类 InputStream InputStream是字节输入流，主要的功能是从文件中读取数据,它的子类有内存操作流 ByteArrayInputStream，管道输入流PipedInputStream，和FileInputStream OutPutStream OutputStream是字节输出流，主要功能是向文件中写入数据，它的常用的子类有ByteArrayOutputStream, FileOutputStream, PipedOutputStream,PrintStream 字符流 字符流的操作都是基于家Writer和Reader这两个抽象类的，一个是输出流，一个是输入流 Writer 写入字符流的操作类，常用的子类有PrintWriter,BufferedWriter,OutputStreamWriter(字节流和字符流之间的桥梁) Reader 用于读取字符流的抽象类,常用的子类有BufferedReader，InputStreamReader 最好用的 其中最高效的输入和输出当然是字符流操作的BufferedReader和BufferedWriter 最便捷的，格式化最好的当然是PrintStream,PrintWriter这两个类都采用了格式化的输入和输出 输出流最好用的 输出流中比较好用的是PrintStream,PrintWriter 输出流最好用的当然是BufferedWriter和PrintWriter的结合，例子如下； 12345678File file=new File("/tmp"+File.separator+"test"+File.separator+"test.txt");//用BufferedWriter实例化PrintWriter，显著提高写入的效率PrintWriter printWriter=new PrintWriter(new BufferedWriter(new FileWriter(file)));String name="陈加兵";int age=22;float grade=99.9f;printWriter.printf("姓名:%s,年龄:%s,grade:%s",name,age,grade); //格式化的写入printWriter.close(); 输入流最好用的 本人觉得输入流中BufferedReader功能已经很强大了 综合运用 有时候在写程序的时候，你得到了一个字节流，但是你想要创建的却是字符流对象，怎么办了呢？前面已经说过，字节流转换成字符流对象的桥梁是InputStreamReader和InputStreamWiter他们的作用是传入字节流对象构造字符流对象，因此可以完美的实现字节流转换成字符流，这个是非常重要的 下面使用转换流将System.in转换成字符流并且使用高效流读取控制台输入的数据,代码如下:12345678910 // 读取键盘的输入的数据，System.in是字节流，因此要想创建高效流必须使用转换流InputStreamReaderBufferedReader br = new BufferedReader(new InputStreamReader(System.in));String line;//从键盘读取输入的数据，直到读到bye结束while ((line = br.readLine()) != null) &#123; if ("bye".equals(line)) &#123; break; &#125; System.out.println(line);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java IO学习笔记八]]></title>
      <url>%2F2017%2F05%2F26%2FJava-IO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AB%2F</url>
      <content type="text"><![CDATA[BufferedReader和BufferedWriter 这两个类是高效率的提高文件的读取速度，它们为字符输入和输出提供了一个缓冲区，可以显著的调高写入和读取的速度，特别针对大量的磁盘文件读取的时候,下面着重的讲讲这两个类 BufferedReader 从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取,要特别注意的是这个市针对字符流而不是字节流。 通常，Reader 所作的每个读取请求都会导致对底层字符或字节流进行相应的读取请求。因此，建议用 BufferedReader 包装所有其 read()操作可能开销很高的Reader（如 FileReader 和 InputStreamReader） 构造函数 BufferedReader(Reader in) 创建一个使用默认大小输入缓冲区的缓冲字符输入流。 BufferedReader(Reader in, int sz) 创建一个使用指定大小输入缓冲区的缓冲字符输入流。 实例 可以看出构造函数使用了Reader这个抽象类来初始化，我们前面说过这个是针对字符流的读取，因此可以使用Reader类的两个子类FileReader,InputStreamReader来初始化 1234File file=new File("/tmp"+File.separator+"test"+File.separator+"test.txt");BufferedReader bufferedReader=new BufferedReader(new FileReader(file)); //使用FileReader实例化//使用InputStreamReader来实例化BufferedReader bufferedReader=new BufferedReader(new InputStreamReader(new FileInputStream(file))); 常用方法 close() String readLine() 读取一行的数据 int read() 读取一个字符，注意这里的和字节的不一样，这里的汉字占用了一个字节，前面讲到读取字节流的时候使用byte读取汉字占用三个字节 skip(int n) 跳过n个字节 ready() 判断此流是否已准备好被读取。 实例 用于控制台的读取,前面已经说过System.in返回的是InputStream类型的，因此可以使用InputStreamReader实例化,当然这个有点多余了，我们完全可以使用java.util提供的Scanner直接进行输入 123BufferedReader bufferedReader=new BufferedReader(new InputStreamReader(System.in)); String str=bufferedReader.readLine(); //将控制台输入的字符串读取 System.out.println(str); //打印出来 用于文件的读取 1234567891011121314151617181920212223242526 BufferedReader bufferedReader=new BufferedReader(new FileReader(file)); // BufferedReader bufferedReader=new BufferedReader(new InputStreamReader(new FileInputStream(file)));// bufferedReader.skip(2); //跳过两个字节// // 第一种读取的方式 while(bufferedReader.ready()) //判断是否还有字符 &#123; String str=bufferedReader.readLine(); //直接读取一行 System.out.println(str); &#125; bufferedReader.close(); //第二种读取方式 int len=bufferedReader.read(); while(len!=-1) //判断是否读到文件的末尾 &#123; System.out.print((char)len); //强制转化成字符 len=bufferedReader.read(); &#125; //第三种方式，根据readLine读取一行，如果到达了文件的末尾返回null String s; while((s=bufferedReader.readLine())!=null) &#123; System.out.println(S); &#125; BufferedWriter 将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。 通常 Writer 将其输出立即发送到底层字符或字节流。除非要求提示输出，否则建议用 BufferedWriter 包装所有其 write() 操作可能开销很高的 Writer（如 FileWriters 和 OutputStreamWriters）。例如 12PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter("foo.out"))); 构造函数 BufferedWriter(Writer out) 创建一个使用默认大小输出缓冲区的缓冲字符输出流。 BufferedWriter(Writer out, int sz) 创建一个使用给定大小输出缓冲区的新缓冲字符输出流。 12File file=new File("/tmp"+File.separator+"test"+File.separator+"test.txt");BufferedWriter bufferedWriter=new BufferedWriter(new FileWriter(file)); 注意这里的FileWriter是Writer的子类，因此可以使用其实例化 常用函数 close() flush() newLine() 写入一个与平台相关的换行符 write(int data) 写入一个字符，这里的写入的不是整数 write(String str) 写入一个字符串 write(String str,int off,int len) 写入部分字符串 write(char[] c) write(char[] c,int off,int len) 实例1234567891011121314151617181920File file=new File("/tmp"+File.separator+"test"+File.separator+"test.txt");File file1=new File("/tmp"+File.separator+"test");File file2=new File("/tmp"+File.separator+"test"+File.separator+"demo.txt");if(!file1.exists())&#123; file1.mkdir(); System.out.println("文件夹创建成功");&#125;BufferedWriter bufferedWriter=new BufferedWriter(new FileWriter(file));String str="陈加兵";int data=48;String name="chenjiabing";char[] chars=name.toCharArray();bufferedWriter.write(str); //写入一个字符串，当然也可以截取这个字符串的某一段bufferedWriter.newLine(); //写入一个平台自带的换行符，因为每一个操作系统的换行符都不一样bufferedWriter.write(data); //写入的并不是整数，而是这个整数所代表的字符bufferedWriter.newLine();bufferedWriter.write(chars,1,4); //写入字符数组bufferedWriter.flush();bufferedWriter.close() 拓展：通过了上面的学习，你不觉得使用这个类写入文件数据有点烦了，只能写入String char类型的数据，此时我们就想到了前面说过的打印流(PrintWriter)，这是一个便捷的写入文件的类，可以指定任意格式任意类型的数据，同样是输出流，我么可以将他们结合起来，构成一个更加强大的输出流，如下: 12345678File file=new File("/tmp"+File.separator+"test"+File.separator+"test.txt");//用BufferedWriter实例化PrintWriter，显著提高写入的效率PrintWriter printWriter=new PrintWriter(new BufferedWriter(new FileWriter(file)));String name="陈加兵";int age=22;float grade=99.9f;printWriter.printf("姓名:%s,年龄:%s,grade:%s",name,age,grade); //格式化的写入printWriter.close(); 综合实例 将一个文件中数据转移到另外一个文件中 123456789101112131415161718192021222324252627282930313233343536373839package IO;import java.io.*;/** * Created by chenjiabing on 17-5-26. */public class demo13 &#123; /** * 常用函数： * newLine() * write(String str) * write(String str,int off,int len) * write(Char[] c) * write(Char[] c,int off,int len) * write(int data) * close() * flush() */ public static void main(String[] args) throws IOException &#123; File file = new File("/tmp" + File.separator + "test" + File.separator + "test.txt"); File file1 = new File("/tmp" + File.separator + "test"); File file2 = new File("/tmp" + File.separator + "test" + File.separator + "demo.txt"); BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(file2)); BufferedReader bufferedReader = new BufferedReader(new FileReader(file)); while (bufferedReader.ready()) &#123; String str = bufferedReader.readLine(); //读取文件test.txt中的一行数据 bufferedWriter.write(str); //将这一行数据写入文件demo.txt bufferedWriter.newLine(); &#125; bufferedReader.close(); bufferedWriter.flush(); bufferedWriter.close(); &#125;&#125; 参考文章 http://ifeve.com/java-io-char-buffered-filter/ http://www.cnblogs.com/lich/archive/2011/12/11/2284223.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java IO学习笔记七]]></title>
      <url>%2F2017%2F05%2F26%2FJava-IO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83%2F</url>
      <content type="text"><![CDATA[System对IO的支持 System是系统的类，其中的方法都是在控制台的输入和输出，但是通过重定向也是可以对文件的输入输出 System中定义了标准输入、标准输出和错误输出流，定义如下: static PrintStream err “标准”错误输出流。 static InputStream in “标准”输入流。 static PrintStream out “标准”输出流。 从上面的定义可以知道这里的返回值都是字节的输入和输出流，因此可以使用PrintStream接受这个返回值，然后利用其进行输出，同样的输入也是可以这样做,当然对于OutputStream和InputStream也是可以的，因为PrintStream是继承OutputStream System.out System.out是一个标准的输出流，可以使用PrintStream和OutputStream接收返回值，然后使用其进行标准的输出,实例如下 12345PrintStream printStream=System.out; //使用PrintStream//OutputStream outputStream=System.out; //使用OutputStream String name="陈加兵"; int age=22; printStream.printf("姓名:%s,年龄:%s",name,age); //使用格式话的输出 其实我还是比较用PrintStream进行格式话的输出的 System.out的重定向输出，可以使用这个将指定的内容输出到文件中，实例如下： 12345678try &#123; File file=new File("/tmp"+File.separator+"test"+File.separator+"test.txt"); System.setOut(new PrintStream(new PrintStream(file))); //设置重定向的文件 &#125;catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println("陈加兵的个人博客")；//向文件输入内容 System.in 这是一个标准输入流，可以使用InputStream来接受返回值，然后利用其进行输入，实例如下： 123456789byte[] bytes=new byte[1024]; InputStream inputStream=System.in; //使用InputStream来接收这个返回值 try &#123; inputStream.read(bytes); //读取控制台输入的字符串 &#125;catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println(new String(bytes)); //输出 说实话这种控制台输入的方式不太好，还是使用原来的Scanner比较好 System.in的重定向 12345678910byte[] bytes = new byte[1024];File file = new File("/tmp" + File.separator + "test" + File.separator + "test.txt");try &#123; System.setIn(new FileInputStream(file)); //设置重定向 System.in.read(bytes); //读取文件中字节数据&#125; catch (IOException e) &#123; e.printStackTrace();&#125;System.out.println(new String(bytes)); //打印出文件中的内容 System.err 这是一个标准错误输出流，在IDEA中输出的内容是红色的，和System.out输出的格式一样，只是颜色不一样，因为这里的重定向不太重要也不太常用，这里就不再详细说了，详情请看帮助文档 System.exit public static void exit(int status) 终止当前的java虚拟机，参数用作状态码；根据惯例，非0 的状态码表示异常终止,如System.exit(0) 参考文章 http://www.cnblogs.com/lich/archive/2011/12/11/2284155.html http://ifeve.com/java-io-system-in-system-out-system-err/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java IO学习笔记六]]></title>
      <url>%2F2017%2F05%2F25%2FJava-IO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD%2F</url>
      <content type="text"><![CDATA[打印流 在整个IO包中，打印流是输出信息最方便的类，主要包含字节打印流（PrintStream）和字符打印流（PrintWrite）。打印流提供了非常方便的打印功能，可以打印任何的数据类型，例如：小数、整数、字符串等等，相对于前面学习的几个文件的操作来说，这里的打印流是最简便的一个类了 PrintStream 主要功能是格式化的将内容写入文件，并不是打印在控制台上 PrintStream最大的好处就是可以格式化的输出，相信学过c的朋友都知道prinf这格式化输出函数，这里的PrintStream实现了更加简单的格式化输出，不需要使用什么%d,%f了，只需要都是用%s即可，这个很像python PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter类。 构造函数 PrintStream(File file) 创建具有指定文件且不带自动行刷新的新打印流。 PrintStream(OutputStream out) 创建新的打印流。 PrintStream(OutputStream out, boolean autoFlush) 创建新的打印流，并且设置自动刷新 PrintStream(String fileName) 创建具有指定文件名称且不带自动行刷新的新打印流。 123File file_2=new File("/tmp"+File.separator+"test"+File.separator+"test.txt");PrintStream printStream=new PrintStream(file_2); //直接使用FilePrintStream printStream=new PrintStream(new FileOutputStream(file_2)); //使用OutputStream的子类FileOutputStream 常用的函数 PrintStream append(char c) 在此输入流的后面追加字符。 PrintStream append(CharSequence csq) 将指定字符序列添加到此输出流。 PrintStream append(CharSequence csq, int start, int end) 将指定字符序列的子序列添加到此输出流。 print() 打印常用的数据类型，比如String,char,int ,double,float,boolean,long,short println() 打印常用的数据类型，但是带有换行符 printf(String format, Object... args) 使用指定格式字符串和参数将格式化的字符串写入此输出流的便捷方法。 format(String format, Object... args) 使用指定格式字符串和参数将格式化字符串写入此输出流中。 close() flush() 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 package IO;import java.io.*;/** * Created by chenjiabing on 17-5-25. */ /**test.txt文件中的结果如下: 陈加兵 2299.9 姓名:陈加兵,n年龄:22,成绩:99.9 姓名:陈加兵,n年龄:22,成绩:99.9 c chenjiabi */public class demo9 &#123; public static void main(String[] args) &#123; PrintStream printStream = null; File file_1 = new File("/tmp" + File.separator + "test"); File file_2 = new File("/tmp" + File.separator + "test" + File.separator + "test.txt"); if (!file_1.exists()) &#123; file_1.mkdir(); System.out.println("文件创建成功"); &#125; try &#123;// PrintStream printStream=new PrintStream(file_2); printStream = new PrintStream(new FileOutputStream(file_2)); String name = "陈加兵"; int age = 22; float grade = 99.9f; printStream.println(name);//println() printStream.print(age);//print() printStream.println(grade);//print() printStream.format("姓名:%s,n年龄:%s,成绩:%s%s", name, age, grade, "\n");//format() printStream.printf("姓名:%s,n年龄:%s,成绩:%s%s", name, age, grade, "\n"); printStream.append('c'); //append printStream.append("\nchenjiabing",0,10); //append &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if (printStream != null) &#123; printStream.flush(); printStream.close(); &#125; &#125; &#125;&#125; PrintWriter 继承Writer，主要针对的是字符流的操作 向文本输出流打印对象的格式化表示形式。此类实现在 PrintStream中的所有 print 方法。它不包含用于写入原始字节的方法，对于这些字节，程序应该使用未编码的字节流进行写入。 与PrintStream 类不同，如果启用了自动刷新，则只有在调用 println、printf 或 format 的其中一个方法时才可能完成此操作，而不是每当正好输出换行符时才完成。这些方法使用平台自有的行分隔符概念，而不是换行符。 此类中的方法不会抛出 I/O 异常，尽管其某些构造方法可能抛出异常。客户端可能会查询调用 checkError() 是否出现错误。 构造函数 PrintWriter(File file) 使用指定文件创建不具有自动行刷新的新 PrintWriter。 PrintWriter(OutputStream out) 根据现有的 OutputStream 创建不带自动行刷新的新 PrintWriter。 PrintWriter(OutputStream out, boolean autoFlush) 通过现有的 OutputStream 创建新的 PrintWriter。 PrintWriter(String fileName) 创建具有指定文件名称且不带自动行刷新的新 PrintWriter。 常用函数 这里的常用到的函数和PrintStream的差不多就不再详细的列出来了，详情请看帮助文档 实例12345678910111213141516171819202122232425262728package IO;import java.io.*;/** * Created by chenjiabing on 17-5-25. */public class demo10 &#123; public static void main(String[] args) &#123; PrintWriter printWriter=null; File file=new File("/tmp"+File.separator+"test"+File.separator+"file.txt"); try &#123; printWriter=new PrintWriter(new FileOutputStream(file)); printWriter.println("chenjiabing"); printWriter.println("陈加兵"); &#125;catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(printWriter!=null) &#123; printWriter.close(); &#125; &#125; &#125;&#125; 参考文章 http://www.cnblogs.com/lich/archive/2011/12/11/2284093.html http://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/PrintWriter.html http://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/PrintStream.html http://blog.csdn.net/yyyandroid/article/details/7756390]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java IO学习笔记五]]></title>
      <url>%2F2017%2F05%2F25%2FJava-IO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94%2F</url>
      <content type="text"><![CDATA[管道流 管道流的主要作用是可以进行两个线程间的通讯，分为管道输出流(PipedOutputStream)、管道输入流（PipedInputStream），如果想要进行管道输出，则必须要把输出流连在输入流之上，在PipedOutputStream类上有如下的一个方法用于连接管道：public void connect(PipedInputStream snk)throws IOException 通常是创建两个单独的线程来实现通信，如果是单个线程的话容易出现线程堵塞，因为输出流最多只能向缓冲区写入1024个字节的数据，如果超出就会出现线程堵塞，因此必须创建多个线程实现缓冲区的释放和存储 PipedOutputStream 管道输出流是管道的发送端，可以将管道输出流连接到管道输入流来创建一个通信管道，通常，数据由某个线程写入 PipedOutputStream对象，并由其他线程从连接的 PipedInputStream 读取。不建议对这两个对象尝试使用单个线程，因为这样可能会造成该线程死锁。如果某个线程正从连接的管道输入流中读取数据字节，但该线程不再处于活动状态，则该管道被视为处于 毁坏 状态。 构造函数 PipedOutputStream() 创建尚未连接到管道输入流的管道输出流。 PipedOutputStream(PipedInputStream snk) 创建连接到指定管道输入流的管道输出流。 常用函数 close() 关闭 void connect(PipedInputStream snk) 将此管道输出流连接到接收者。 void flush() 刷新此输出流并强制写出所有缓冲的输出字节。 void write(byte[] b, int off, int len) 将 len 字节从初始偏移量为 off 的指定 byte 数组写入该管道输出流。 void write(int b) 将指定 byte 写入传送的输出流。 PipedInputStream 管道输入流应该连接到管道输出流；管道输入流提供要写入管道输出流的所有数据字节。通常，数据由某个线程从 PipedInputStream 对象读取，并由其他线程将其写入到相应的 PipedOutputStream。不建议对这两个对象尝试使用单个线程，因为这样可能死锁线程。管道输入流包含一个缓冲区，可在缓冲区限定的范围内将读操作和写操作分离开。 如果向连接管道输出流提供数据字节的线程不再存在，则认为该管道已损坏。 构造函数 PipedInputStream() 创建尚未连接的 PipedInputStream。 PipedInputStream(PipedOutputStream src) 创建 PipedInputStream，使其连接到管道输出流 src。 常用函数 int available() 返回可以不受阻塞地从此输入流中读取的字节数。 void close() 关闭此管道输入流并释放与该流相关的所有系统资源。 void connect(PipedOutputStream src) 使此管道输入流连接到管道输出流 src。 int read() 读取此管道输入流中的下一个数据字节。 int read(byte[] b, int off, int len) 将最多 len 个数据字节从此管道输入流读入 byte 数组。 protected void receive(int b) 接收数据字节。 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package IO;import java.io.IOException;import java.io.PipedInputStream;import java.io.PipedOutputStream;/** * Created by chenjiabing on 17-5-25. *//** * 注意的问题： * 1.写线程正在往缓冲区写数据的时候，但是此时的读线程的管道结束，那么此时的写线程的管道就会发生IOException异常 * 2.读线程正在从缓冲区读数据的时候，但是此时的写线程的管道已经结束了，此时就会引起读线程的管道发生IOException异常 * 3.必须是启用多线程才能实现管道之间的读写，否则会出现堵塞现象，因为这里的PipeOutputStream每次向缓冲区写入的字节数最大是1024，如果不及时的减少缓冲区的数据量就会出现堵塞 */public class demo7 &#123; public static PipedOutputStream outputStream = new PipedOutputStream(); public static PipedInputStream inputStream = new PipedInputStream(); /** * 创建一个写入数据进程，使用的是PipeOutStream，将数据写入管道中 */ public static void send() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; byte[] bytes = new byte[2000]; //创建一个2000字节的数组 while (true) &#123; try &#123; outputStream.write(bytes, 0, 2000); //写入管道，但是这里的缓冲区最多写入1024个字节的数据，因此这个是一次没有写完 System.out.println("写入成功"); &#125; catch (IOException e) &#123; System.out.println("写入失败"); System.exit(1); &#125; &#125; &#125; &#125;).start(); &#125; /** * 使用PipeInputStream创建一个读取的线程 */ public static void receive() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; byte[] bytes = new byte[100]; //一次性只读取100个字节 int len = 0; try &#123; len = inputStream.read(bytes, 0, 100); //读取 while (len != -1) &#123; System.out.println("已经读取了" + len + "个字节"); len = inputStream.read(bytes, 0, 100); &#125; &#125; catch (IOException e) &#123; System.out.println("读取失败"); System.exit(1); &#125; &#125; &#125;).start(); &#125; public static void main(String args[]) &#123; try &#123; inputStream.connect(outputStream); //连接 &#125; catch (IOException e) &#123; System.out.println("连接失败"); System.exit(1); &#125; send(); receive(); &#125;&#125; 注意:从上面的运行结果可以看出，缓冲区最多可以写入1024个字节的数据，所以在缓冲区满了之后上面的send进程就会堵塞等待缓冲区空闲，如果recieve进程不继续读取数据了，那么就会一直出现堵塞 问题 写线程正在往缓冲区写数据的时候，但是此时的读线程的结束读取，那么此时的写线程的管道就会发生IOException异常，可以将上面receive进程中的while(true)去掉就可以清楚的看出 读线程正在从缓冲区读数据的时候，但是此时的写线程的管道已经结束了，此时就会引起读线程的管道发生IOException异常,将上面的send进程中的while(true)去掉就可以实现这个问题 必须是启用多线程才能实现管道之间的读写，否则会出现堵塞现象，因为这里的PipeOutputStream每次向缓冲区写入的字节数最大是1024，如果不及时的减少缓冲区的数据量就会出现堵塞 解决方法 后续更新中………. 参考文章 http://www.cnblogs.com/lich/archive/2011/12/11/2283928.html http://ifeve.com/java-io-%E7%AE%A1%E9%81%93/ http://www.cnblogs.com/chinareny2k/archive/2010/03/24/1693878.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java IO学习笔记四]]></title>
      <url>%2F2017%2F05%2F25%2FJava-IO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%2F</url>
      <content type="text"><![CDATA[内存操作流 之前的所有的流操作都是针对文件的，但是有时候只是想要实现数据间转换，此时如果我们想要创建一个文件然后再删除文件，那样显得有点麻烦，因此此时的内存操作流就显得很适合这类的操作，因为它只是在内存中存储，并不会真正的创建文件，内存操作流涉及的两个类是ByteArrayInputStream,ByteArrayOutputStream. ByteArrayInputStream ByteArrayInputStream 包含一个内部缓冲区，该缓冲区包含从流中读取的字节。内部计数器跟踪read方法要提供的下一个字节。 关闭 ByteArrayInputStream无效。此类中的方法在关闭此流后仍可被调用，而不会产生任何 IOException。 主要的功能是从缓冲区读取字节 构造函数 ByteArrayInputStream(byte[] buf) 创建一个 ByteArrayInputStream，使用 buf 作为其缓冲区数组。 ByteArrayInputStream(byte[] buf, int offset, int length) 创建 ByteArrayInputStream，使用 buf 作为其缓冲区数组。 常用的方法 close() 不过对这个无效，因为关闭之后仍然可以使用函数读取而不报错 int read() 从缓冲区中读取一个字节 int read(byte[] bytes) 将缓冲区中的内容读取到数组中 int read(byte[] bytes,int off,int len) 将最多 len 个数据字节从此输入流读入 byte 数组。 long skip(long n) 从此输入流中跳过n 个输入字节。 void reset() 将此 byte 数组输出流的 count 字段重置为零，从而丢弃输出流中目前已累积的所有输出（清除缓冲区） 实例1234567891011121314151617181920212223public class demo8 &#123; public static void main(String args[]) &#123; String str = "chenjiabing\n陈加兵"; byte[] bytes = str.getBytes(); //创建一个数组 ByteArrayInputStream inputStream = new ByteArrayInputStream(bytes); //使用bytes作为缓冲区数组 int temp = 0; /*第一种方法读取缓冲区中的数据，这个和文件的操作不一样，这个可以直接冲缓冲区中读取数据字节*/ while ((temp = inputStream.read()) != -1) &#123; System.out.print((char) temp); &#125; /*创建数组用于存储读取的内容，下面是第二种读取数据的方法*/ byte[] b = new byte[bytes.length]; try &#123; int len = inputStream.read(b); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println(new String(b)); &#125;&#125; ByteArrayOutputStream 此类实现了一个输出流，其中的数据被写入一个byte 数组。缓冲区会随着数据的不断写入而自动增长。可使用 toByteArray() 和 toString() 获取数据。 关闭 ByteArrayOutputStream 无效。此类中的方法在关闭此流后仍可被调用，而不会产生任何 IOException。 构造函数 ByteArrayOutputStream() 创建一个新的 byte数组输出流。 ByteArrayOutputStream(int size) 创建一个新的 byte 数组输出流，它具有指定大小的缓冲区容量（以字节为单位）。 常用函数 int size() 返回缓冲区的当前大小。 byte[] toByteArray() 创建一个新分配的 byte 数组。 String toString() 将缓冲区的字节转换成字符串 void write(byte[] b, int off, int len) 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此 byte 数组输出流。 void write(int b) 将指定的字节写入此 byte数组输出流。 实例12345678910111213141516171819202122232425262728293031public class demo8 &#123; public static void main(String args[]) &#123; ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); String str = "chenjiabing"; try &#123; outputStream.write(str.getBytes()); //将字符串转换成数组然后写入缓冲区 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; outputStream.close(); //这里的关闭无效 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //将缓冲区的数据转换成字符串后输出，这里同样可以看出输出流的关闭根本不影响函数的调用 System.out.println(outputStream.size()); //输出缓冲区的大小 System.out.println(outputStream.toString()); //输出chenjiabing outputStream.reset(); //清除缓冲区的内容，如果不清零那么原先写入的数据还是存在的，但是此时我们已经不需要前面的数据了 try &#123; outputStream.write("陈加兵".getBytes()); //继续向缓冲区写入数据 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println(outputStream.size()); //这里的一个汉字占了三个字节 System.out.println(outputStream.toString());//输出陈加兵 &#125;&#125; 综合 下面我们结合上面的两个类将字符串转换大小写 1234567891011121314151617public class demo8 &#123; public static void main(String args[]) &#123; ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); String str = "chenjiabing"; ByteArrayInputStream inputStream = new ByteArrayInputStream(str.getBytes()); //实例化输入流 int temp = 0; while ((temp = inputStream.read()) != -1) //读取缓冲区的字节数据 &#123; char c = (char) temp; //将整数转换成字符，ascii码的转换 outputStream.write(Character.toUpperCase(c)); //转换成大写，然后写入输出流的缓冲区中 &#125; System.out.println(outputStream.toString()); //利用输出流输出转换后的字符串，即是去取出内存中的数据 &#125;&#125; 参考文章 http://blog.csdn.net/yyyandroid/article/details/7756390 http://www.cnblogs.com/lich/archive/2011/12/11/2283883.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java IO学习笔记三]]></title>
      <url>%2F2017%2F05%2F24%2FJava-IO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89%2F</url>
      <content type="text"><![CDATA[Java IO学习笔记三 在整个IO包中，实际上就是分为字节流和字符流，但是除了这两个流之外，还存在了一组字节流-字符流的转换类。 OutputStreamWriter：是Writer的子类，将输出的字符流变为字节流，即：将一个字符流的输出对象变成字节流的输出对象。 InputStreamReader:是Reader的子类，将输入的字节流变为字符流，即：将一个字节流的输入对象变成字符流的输入对象。 一般在操作输入输出内容就需要使用字节或字符流，但是有些时候需要将字符流变成字节流的形式，或者将字节流变为字符流的形式，所以，就需要另外一组转换流的操作类。 InputStreamReader InputStreamReader 是字节流通向字符流的桥梁：它使用指定的 charset 读取字节并将其解码为字符。它使用的字符集可以由名称指定或显式给定，或者可以接受平台默认的字符集。 每次调用 InputStreamReader 中的一个 read() 方法都会导致从底层输入流读取一个或多个字节。要启用从字节到字符的有效转换，可以提前从底层流读取更多的字节，使其超过满足当前读取操作所需的字节。 主要的功能还是从文件中读取内容，不过是一次性的读取多个字节，这个很像它的子类FileReader 构造函数 InputStreamReader(InputStream in) 创建一个使用默认字符集的 InputStreamReader,不过这里的InputStream是抽下类，因此可以使用它的子类FileInputStream实例化，这里的FileInputStream是操作字节流的，显然看出这个类的作用就是字符流和字节流的桥梁 常用方法 close() int read() 读取单个字符 int read(Char[] c) 读取字符存储在字符数组中 int read(char[] cbuf, int offset, int length) 将字符读入数组中的某一部分 boolean ready() 判断此流是否已经准备好用于读取。 实例1234567891011121314151617181920212223242526272829303132333435363738394041package IO;import java.io.*;/** * Created by chenjiabing on 17-5-24. */public class demo4 &#123; public static void main(String args[]) &#123; File file = new File("/tmp" + File.separator + "test" + File.separator + "test.txt"); InputStreamReader inputStreamReader = null; try &#123; inputStreamReader = new InputStreamReader(new FileInputStream(file)); //初始化 char[] c = new char[(int) file.length()]; //创建数组 try &#123; int len = inputStreamReader.read(c); //将内容读取到数组中 System.out.println(len); for (int i = 0; i &lt; c.length; i++) &#123; System.out.print(c[i]); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125;finally &#123; if(inputStreamReader!=null) &#123; try &#123; inputStreamReader.close(); //关闭 &#125;catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 注意：从上面的代码中可以看到这个和FileReader的操作是一样的，只是构造的方法不一样 OutputStreamWriter OutputStreamWriter 是字符流通向字节流的桥梁：可使用指定的 charset 将要写入流中的字符编码成字节。它使用的字符集可以由名称指定或显式给定，否则将接受平台默认的字符集。 每次调用 write() 方法都会导致在给定字符（或字符集）上调用编码转换器。在写入底层输出流之前，得到的这些字节将在缓冲区中累积。可以指定此缓冲区的大小，不过，默认的缓冲区对多数用途来说已足够大。注意，传递给 write() 方法的字符没有缓冲。 主要的功能还是向文件中写入文件 构造函数 OutputStreamWriter(OutputStream out) 创建使用默认字符编码的 OutputStreamWriter。这里同样是抽象类，所以用它的子类FileOutputStream实例化 常用方法 close() flush() write(String str) 写入字符串 void write(String str, int off, int len) 写入字符串的某一部分。 write(int c) 写入单个字符 void write(char[] cbuf, int off, int len) 写入字符数组的某一部分。 实例12345678910111213141516171819202122232425262728293031323334353637383940414243package IO;import java.io.*;/** * Created by chenjiabing on 17-5-24. */public class demo5 &#123; public static void main(String[] args) &#123; File file=new File("/tmp"+File.separator+"test"+File.separator+"test.txt"); OutputStreamWriter outputStreamWriter=null; try &#123; outputStreamWriter=new OutputStreamWriter(new FileOutputStream(file,true)); String str="陈加兵\n"; int data=48; String name="chenjiabing"; try &#123; outputStreamWriter.write(str); outputStreamWriter.write(data); outputStreamWriter.write(name,0,2); //写入字符串的一部分 &#125;catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125;finally &#123; if(outputStreamWriter!=null) &#123; try &#123; outputStreamWriter.flush(); outputStreamWriter.close(); &#125;catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 从上面可以看出OutputStreamWriter和FileWriter的用法一样 综合使用 上面我们说了OutputStreamWriter和InputStreamWriter是字节流和字符流之间的桥梁，可以实现之间的转换，下面我们使用这两个之间的相互转换完成高效流的创建123456789/* * InputStreamReader实现了将字节流FileInputStream转换为字符流，然后使用转换来的字节流创建高效流，从而实现高效的读写 */File file = new File("/tmp/demo.txt");FileInputStream fileInputStream = new FileInputStream(file); // 创建字节输入流InputStreamReader inputStreamReader = new InputStreamReader( fileInputStream); // 转换为字符输入流BufferedReader bufferedReader = new BufferedReader(inputStreamReader); // 创建高效流对象 参考文章 http://www.cnblogs.com/lich/archive/2011/12/11/2283848.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java IO学习笔记二]]></title>
      <url>%2F2017%2F05%2F24%2FJava-IO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[Java IO学习笔记二流的概念 在程序中所有的数据都是以流的方式进行传输或保存的，程序需要数据的时候要使用输入流读取数据，而当程序需要将一些数据保存起来的时候，就要使用输出流完成。 程序中的输入输出都是以流的形式保存的，流中保存的实际上全都是字节文件。 字节流和字符流 实际上字节流在操作时本身不会用到缓冲区（内存），是文件本身直接操作的，而字符流在操作时使用了缓冲区，通过缓冲区再操作文件 在java.io包中操作文件内容的主要有两大类：字节流、字符流，两类都分为输入和输出操作。在字节流中输出数据主要是使用OutputStream完成，输入使的是InputStream，在字符流中输出主要是使用Writer类完成，输入流主要使用Reader类完成。（这四个都是抽象类） 操作流程 在Java中IO操作也是有相应步骤的，以文件操作为例，主要的操作流程如下： 使用File类打开一个文件 通过字节流或字符流的子类，指定输出的位置 进行读/写操作 关闭输入/输出 字节流 字节流主要是操作byte类型数据，以byte数组为准，主要操作类就是OutputStream、InputStream FileOutputStream 文件输出流是用于将数据写入 File 或 FileDescriptor 的输出流。文件是否可用或能否可以被创建取决于基础平台。特别是某些平台一次只允许一个 FileOutputStream（或其他文件写入对象）打开文件进行写入。在这种情况下，如果所涉及的文件已经打开，则此类中的构造方法将失败。 FileOutputStream 用于写入诸如图像数据之类的原始字节的流。要写入字符流，请考虑使用 FileWriter。 主要的功能就是用来向文件中写入内容的 构造函数 FileOutputStream(File file) 创建一个向指定 File 对象表示的文件中写入数据的文件输出流。 FileOutputStream(File file, boolean append) 如果在文件后面追加内容，如果append为true则追加内容 FileOutputStream(String name) 创建一个向具有指定名称的文件中写入数据的输出文件流。 FileOutputStream(String name, boolean append) 创建一个向具有指定 name 的文件中写入数据的输出文件流。 常用的方法 close() 关闭文件输出流 void write(byte[] b) 将 b.length 个字节从指定 byte 数组写入此文件输出流中。 void write(byte[] b, int off, int len) 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此文件输出流，这里需要注意的是中文所占字节数为3，英文所占字节数为1 void write(int b) 将指定字节写入此文件输出流，这个是按照ascii码写入文件的，并不是直接写入的是整数 实例123456789101112131415161718192021222324252627282930313233343536373839package File_demo;import java.io.*;public class demo &#123; public static void main(String[] args) &#123; FileOutputStream outputStream = null; File file = new File("/tmp" + File.separator + "test.txt"); try &#123; outputStream = new FileOutputStream(file); try &#123; int data = 48; String name = "陈加兵\n"; //使用\n换行 byte[] bytes = name.getBytes(); //将字符串转换成byte数组 outputStream.write(bytes, 0, 3); //将中文字符串的第一个字写入，这里一个中文占了三个字节 String age = "chenjiabing\n"; outputStream.write(age.getBytes()); outputStream.write(data); //这里的写入的acsii码中的( &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if (outputStream != null) &#123; try &#123; outputStream.close(); //关闭文件流 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 当然也可以一个一个的字节输出 1234567891011121314151617import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;public class Test11 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); OutputStream out=new FileOutputStream(f);//如果文件不存在会自动创建 String str="Hello World"; byte[] b=str.getBytes(); for(int i=0;i&lt;b.length;i++)&#123; out.write(b[i]); &#125; out.close(); &#125;&#125; FileInputStream FileInputStream 从文件系统中的某个文件中获得输入字节。哪些文件可用取决于主机环境。 FileInputStream 用于读取诸如图像数据之类的原始字节流。要读取字符流，请考虑使用 FileReader。 主要的功能是读取文件中的内容 构造函数 FileInputStream(File file) 通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的File对file指定。 FileInputStream(String name) 通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的路径名 name 指定。 常用方法 int read() 从输入流中读取数据字节，如果到达文件的末尾就返回-1 int read(byte[] b) 将文件中的内容读取到byte数组中，如果到达文件末尾返回-1 int read(byte[] b, int off, int len) 从此输入流中将最多 len 个字节的数据读入一个 byte 数组中,这个用于截取字节流，注意这里中文是占三个字节 long skip(long n) 从输入流中跳过并丢弃 n 个字节的数据，一旦跳过字节那么就从跳过的字节的后面开始读取 int available()返回的数据是输入流中的字节数，如果没有字节就返回0，因此可以用这个函数判断文件中是否还有内容 实例 针对知道的文件的大小然后创建一个数组存储，之后将数组转换成字符串，当然我们也可以一个一个的读取 1234567891011121314151617181920212223242526272829File file=new File("/tmp"+File.separator+"test.txt"); FileInputStream inputStream=null; try &#123; inputStream=new FileInputStream(file); try &#123; byte[] bytes=new byte[(int)file.length()]; //file.length返回文件的大小，这样就不会浪内存空间了 int flag=inputStream.read(bytes); //将文件的内容读入到数组中 System.out.println(new String(bytes)); //将bytes数组转换成字符串输出 System.out.println(flag); &#125;catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125;finally &#123; if(inputStream!=null) &#123; try &#123; inputStream.close(); &#125;catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 一个一个的读文件 1234567891011121314151617181920212223242526272829303132333435File file=new File("/tmp"+File.separator+"test.txt"); FileInputStream inputStream=null; try &#123; inputStream=new FileInputStream(file); try &#123; int len=0; //读取的字节 int i=0; //下标 byte[] bytes=new byte[(int)file.length()]; //创建数组 while((len=inputStream.read())!=-1) //判断是否读取到文件的末尾 &#123; bytes[i]=(byte)len; //将读到的整形数据转换成bytes类型的，存储在数组中 i++; &#125; System.out.println(new String(bytes)); //转换成字符串 &#125;catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125;finally &#123; if(inputStream!=null) &#123; try &#123; inputStream.close(); &#125;catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 使用available控制结束 12345678910111213141516171819202122232425262728293031323334353637File file = new File("/tmp" + File.separator + "test.txt"); FileInputStream inputStream = null; try &#123; inputStream = new FileInputStream(file); try &#123; byte[] bytes = new byte[(int) file.length()]; //file.length返回文件的大小，这样就不会浪内存空间了 int i = 0; while (inputStream.available() != 0) &#123; try &#123; bytes[i] = (byte) inputStream.read(); i++; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(new String(bytes)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if (inputStream != null) &#123; try &#123; inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 字符流 在程序中一个字符等于两个字节，那么java提供了Reader、Writer两个专门操作字符流的类。 前面已经说过字符流要用到缓冲区，因此在关闭字符流的时候一定要刷新缓冲区,清空缓冲区中的内容 字符输出流FileWriter 用来写入字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是可接受的。 FileWriter 用于写入字符流。要写入原始字节流，请考虑使用 FileOutputStream。 主要功能是向文件中写入内容 构造函数 FileWriter(File file) 根据给定的 File 对象构造一个 FileWriter 对象。 FileWriter(File file,boolean append) 追加 FileWriter(String fileName) 根据给定的文件名构造一个 FileWriter 对象。 FileWriter(String fileName, boolean append) 根据给定的文件名以及指示是否附加写入数据的 boolean 值来构造 FileWriter 对象。 常用方法 write(String str) 将字符写入文件 write(String str,int offest,int len) 截取字符串部分内容写入文件 write(int c) 写入单个字符，并不是整数 write(Char[] buf) 写入字符数组 close() 关闭流，在关闭之前必须刷新缓冲区 flush() 刷新缓冲区 实例123456789101112131415161718192021222324252627282930313233File file=new File("/tmp"+File.separator+"test"+File.separator+"test.txt"); File f1=new File("/tmp"+File.separator+"test"); if(!f1.exists()) &#123; f1.mkdir(); System.out.println("文件创建成功"); &#125; FileWriter fileWriter=null; try &#123; fileWriter=new FileWriter(file); String str="hello chenjiabing\n"; String name="陈加兵"; int data=48; fileWriter.write(str); //写入字符串 fileWriter.write(name); //写入中文字符串，这里直接写入不用转换成byte数组了 fileWriter.write(data); //写入单个字符 &#125;catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(fileWriter!=null) &#123; try &#123; fileWriter.flush(); //刷新缓冲区 fileWriter.close(); //关闭字符流 &#125;catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 注意: 这里字符流如果不关闭的话，那么就会就会写入文件失败，文件中没有内容，但是如果只有flush而没有close文件还是会写入成功的 字符输入流FileReader 用来读取字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的 主要的功能是读取文件内容 构造函数 FileReader(File file) 在给定从中读取数据的 File 的情况下创建一个新 FileReader。 FileReader(String fileName) 在给定从中读取数据的文件名的情况下创建一个新 FileReader。 常用函数 int read(char[] cbuf) 将字符读入数组。 int read() 读取单个字符，之后使用char类型强制转换成字符就行 read(char[] cbuf, int off, int len) 将字符读入数组的某一部分。 boolean ready() 判断是否准备读取此流，如果读到文件末尾那么就返回false long skip(long n) 跳过字符。 实例 用字符数组读取 12345678910111213141516171819202122232425File file = new File("/tmp" + File.separator + "test" + File.separator + "test.txt"); FileReader fileReader = null; try &#123; fileReader = new FileReader(file); char[] c = new char[(int) file.length()]; //根据文件的大小申请数组大小，不浪费 try &#123; int len = fileReader.read(c); //将文件的内容读取到字符数组中 for (int i = 0; i &lt; c.length; i++) &#123; System.out.println(c[i]); //将一个一个字符输出 &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if (fileReader != null) &#123; try &#123; fileReader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 使用ready控制是否读到文件末尾，当然也可以使用int read()==-1判断 12345678910111213141516171819202122232425File file = new File("/tmp" + File.separator + "test" + File.separator + "test.txt"); FileReader fileReader = null; try &#123; fileReader = new FileReader(file); char[] c = new char[(int) file.length()]; //根据文件的大小申请数组大小，不浪费 try &#123; while(fileReader.ready()) //判断是否读到文件末尾 &#123; System.out.println((char)fileReader.read()); //转换成字符 &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if (fileReader != null) &#123; try &#123; fileReader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 参考文章 http://www.cnblogs.com/lich/archive/2011/12/11/2283700.html http://www.cnblogs.com/absfree/p/5415092.html http://blog.csdn.net/zxman660/article/details/7875799 http://blog.csdn.net/cynhafa/article/details/6882061]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java IO学习笔记一]]></title>
      <url>%2F2017%2F05%2F23%2FJava-IO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%2F</url>
      <content type="text"><![CDATA[Java IO学习笔记一File File是文件和目录路径名的抽象表示形式，总的来说就是java创建删除文件目录的一个类库，但是作用不仅仅于此，详细见官方文档 构造函数 File(File parent, String child) 根据 parent 抽象路径名和 child 路径名字符串创建一个新 File 实例。 File(String pathname) 通过将给定路径名字符串转换为抽象路径名来创建一个新 File 实例。 File(String parent, String child) 根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例。 File(URI uri) 通过将给定的 file: URI 转换为一个抽象路径名来创建一个新的 File 实例。 实例123File file=new File("/tmp/demo"); //File(String pathname)File file=new File("/tmp","demo"); //File(String parent, String child) 常用方法字段 static String pathSeparator 与系统有关的路径分隔符，通常是: static String separator 与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。linux是/ 1File file=new File("/tmp"+File.separator+"demo"); //使用分隔符创建一个路径 方法摘要 boolean canExecute() 测试文件或者目录是否是可执行的，测试可执行权限 boolean canRead() 测试可读权限 boolean canWrite() 测试可写权限 boolean setExecutable(boolean executable) 设置文件或者目录的执行权限 setExecutable(boolean executable, boolean ownerOnly) 设置执行权限，如果第二个为true那么只有创建这个文件的用户拥有执行权限 boolean setReadable(boolean readable) 设置可读的权限 boolean setReadable(boolean readable, boolean ownerOnly) 同上 boolean setReadOnly() 标记此抽象路径名指定的文件或目录，从而只能对其进行读操作。 boolean setWritable(boolean writable) 设置可写的权限 boolean createNewFile() 创建一个文件，这里创建的不是目录 boolean mkdir() 创建文件夹 File getAbsoluteFile() 返回此抽象路径名的绝对路径名形式。 String getAbsolutePath() 返回此抽象路径名的绝对路径名字符串。 String getName() 返回由此抽象路径名表示的文件或目录的名称。 boolean isDirectory() 测试此抽象路径名表示的文件是否是一个目录。 boolean isFile() 测试此抽象路径名表示的文件是否是一个标准文件。 boolean isHidden() 测试此抽象路径名指定的文件是否是一个隐藏文件。 String[] list() 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中的文件和目录。 File[] listFiles() 返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。 实例创建文件12345678910111213141516File file=new File("/tmp/demo.txt"); if(file.exists())//如果文件存在就删除这个文件 &#123; file.delete(); &#125; else &#123; try&#123; file.createNewFile(); //创建一个文件 file.setExecutable(false); //设置执行权限 &#125;catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 创建文件夹1234567891011121314151617181920File file=new File("/tmp","test"); if(file.exists()) &#123; if(file.isDirectory()) //如果是一个文件夹 &#123; System.out.println("这是一个文件夹"); file.delete(); &#125; else if(file.isFile()) //如果是一个文件 &#123; System.out.println("这是一个文件"); &#125; &#125; else &#123; file.mkdir(); file.setWritable(false); //设置权限为不可读 &#125; 列出全部文件list 这个函数列出的是文件的名字并不是文件的路径 12345File f=new File("d:"+File.separator); String[] str=f.list(); //这里列出的仅仅是文件的名字，并不是文件的路径 for(String s:str)&#123; System.out.println(s); &#125; listFiles 这个列出的是文件的绝对路径 12345File f=new File("d:"+File.separator); File[] files=f.listFiles(); for(File file:files)&#123; System.out.println(file); &#125; 参考文章 http://www.cnblogs.com/lich/archive/2011/12/10/2283445.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python实现微信接口]]></title>
      <url>%2F2017%2F05%2F15%2Fpython%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E6%8E%A5%E5%8F%A3%2F</url>
      <content type="text"><![CDATA[python实现微信接口(itchat)安装 sudo pip install itchat 登录 itchat.auto_login() 这种方法将会通过微信扫描二维码登录，但是这种登录的方式确实短时间的登录，并不会保留登录的状态，也就是下次登录时还是需要扫描二维码，如果加上hotReload==True,那么就会保留登录的状态，至少在后面的几次登录过程中不会再次扫描二维码，该参数生成一个静态文件itchat.pkl用于存储登录状态 退出及登录完成后调用的特定的方法 这里主要使用的是灰调函数的方法,登录完成后的方法需要赋值在 loginCallback中退出后的方法,需要赋值在 exitCallback中.若不设置 loginCallback的值, 将会自动删除二维码图片并清空命令行显示. 12345678910import itchat, timedef lc(): print("Finash Login!")def ec(): print("exit")itchat.auto_login(loginCallback=lc, exitCallback=ec)time.sleep()itchat.logout() #强制退出登录 回复消息send send(msg=&quot;Text Message&quot;, toUserName=None) 参数： msg : 文本消息内容 @fil@path_to_file : 发送文件 @img@path_to_img : 发送图片 @vid@path_to_video : 发送视频 toUserName : 发送对象, 如果留空, 将发送给自己. 返回值 True or False 实例代码 1234567# coding-utf-8import itchatitchat.auto_login()itchat.send("Hello World!")ithcat.send("@fil@%s" % '/tmp/test.text')ithcat.send("@img@%s" % '/tmp/test.png')ithcat.send("@vid@%s" % '/tmp/test.mkv') send_msg send_msg(msg=&#39;Text Message&#39;, toUserName=None),其中的的msg是要发送的文本，toUserName是发送对象, 如果留空, 将发送给自己，返回值为True或者False 实例代码 123import itchatitchat.auto_login()itchat.send_msg("hello world.") send_file send_file(fileDir, toUserName=None) fileDir是文件路径, 当文件不存在时, 将打印无此文件的提醒，返回值为True或者False 实例代码 1234mport itchatitchat.auto_login()itchat.send_file("/tmp/test.txt") send_image send_image(fileDir, toUserName=None) 参数同上 实例代码 12345import itchatitchat.auto_login()itchat.send_img("/tmp/test.txt") send_video send_video(fileDir, toUserName=None) 参数同上 实例代码 1234import itchatitchat.auto_login()itchat.send_video("/tmp/test.txt") 注册消息方法 itchat 将根据接受到的消息类型寻找对应的已注册的方法.如果一个消息类型没有对应的注册方法, 该消息将会被舍弃.在运行过程中也可以动态注册方法, 注册方式与结果不变. 注册方法 不带具体对象注册, 将注册为普通消息的回复方法. 1234567import itchatfrom itchat.content import *@itchat.msg_register(TEXT) #这里的TEXT表示如果有人发送文本消息，那么就会调用下面的方法def simple_reply(msg): #这个是向发送者发送消息 itchat.send_msg('已经收到了文本消息，消息内容为%s'%msg['Text'],toUserName=msg['FromUserName']) return "T reveived: %s" % msg["Text"] #返回的给对方的消息，msg["Text"]表示消息的内容 带对象参数注册, 对应消息对象将调用该方法，其中isFriendChat表示好友之间，isGroupChat表示群聊，isMapChat表示公众号 123456import itchatfrom itchat.content import *@itchat.msg_register(TEXT, isFriendChat=True, isGroupChat=True,isMpChat=True)def text_reply(msg): msg.user.send("%s : %s" % (mst.type, msg.text)) 消息类型向注册方法传入的 msg 包含微信返回的字典的所有内容.itchat 增加 Text, Type(也就是参数) 键值, 方便操作.itcaht.content中包含所有的消息类型参数, 如下表 参数 l类型 Text 键值 TEXT 文本 文本内容(文字消息) MAP 地图 位置文本(位置分享) CARD 名片 推荐人字典(推荐人的名片) SHARING 分享 分享名称(分享的音乐或者文章等) PICTURE 下载方法 图片/表情 RECORDING 语音 下载方法 ATTACHMENT 附件 下载方法 VIDEO 小视频 下载方法 FRIENDS 好友邀请 添加好友所需参数 SYSTEM 系统消息 更新内容的用户或群聊的UserName组成的列表 NOTE 通知 通知文本(消息撤回等) 附件的下载与发送 itchat 的附件下载方法存储在 msg 的 Text 键中.发送的文件名(图片给出的默认文件名), 都存储在 msg 的 FileName 键中.下载方法, 接受一个可用的位置参数(包括文件名), 并将文件响应的存储.注意：下载的文件存储在指定的文件中，直接将路径与FileName连接即可，如msg[&quot;Text&quot;](&#39;/tmp/weichat&#39;+msg[&#39;FileName&#39;]) 123456@itchat.msg_register([PICTURE, RECORDING, ATTACHMENT, VIDEO])def download_files(msg): #msg.download(msg['FileName']) #这个同样是下载文件的方式 msg['Text'](msg['FileName']) #下载文件 #将下载的文件发送给发送者 itchat.send('@%s@%s' % ('img' if msg['Type'] == 'Picture' else 'fil', msg["FileName"]), msg["FromUserName"]) 群消息 增加了三个键值，如下： isAt 判断是否 @ 本号 ActualNickName : 实际 NickName(昵称) Content : 实际 Content 测试程序 1234567891011import itcahtfrom itchat.content import TEXT@itchat.msg_register(TEXT, isGroupChat=True)def text_reply(msg): if(msg.isAt): #判断是否有人@自己 #如果有人@自己，就发一个消息告诉对方我已经收到了信息 itchat.send_msg("我已经收到了来自&#123;0&#125;的消息，实际内容为&#123;1&#125;".format(msg['ActualNickName'],msg['Text']),toUserName=msg['FromUserName'])itchat.auto_login()itchat.run() 注册消息的优先级 总的来说就是后面注册同种类型的消息会覆盖之前注册的消息，详情见文档https://itchat.readthedocs.io/zh/latest/ 消息内容 注意：所有的消息内容都是可以用键值对来访问的，如msg[&quot;FromUserName]就是查看发送者，itchat.search_friends(userName=msg[&#39;FromUserName&#39;])[&#39;NickName&#39;]查看的是当发送者昵称 一般消息一般的消息都遵循以下的内容： 12345678910111213141516171819202122232425262728&#123; "FromUserName": "", "ToUserName": "", "Content": "", "StatusNotifyUserName": "", "ImgWidth": 0, "PlayLength": 0, "RecommendInfo": &#123;&#125;, "StatusNotifyCode": 0, "NewMsgId": "", "Status": 0, "VoiceLength": 0, "ForwardFlag": 0, "AppMsgType": 0, "Ticket": "", "AppInfo": &#123;&#125;, "Url": "", "ImgStatus": 0, "MsgType": 0, "ImgHeight": 0, "MediaId": "", "MsgId": "", "FileName": "", "HasProductId": 0, "FileSize": "", "CreateTime": 0, "SubMsgType": 0&#125; 初始化消息123456789101112131415161718192021222324252627MsgType: 51 FromUserName: 自己ID ToUserName: 自己ID StatusNotifyUserName: 最近联系的联系人ID Content: &lt;msg&gt; &lt;op id='4'&gt; &lt;username&gt; # 最近联系的联系人 filehelper,xxx@chatroom,wxid_xxx,xxx,... &lt;/username&gt; &lt;unreadchatlist&gt; &lt;chat&gt; &lt;username&gt; # 朋友圈 MomentsUnreadMsgStatus &lt;/username&gt; &lt;lastreadtime&gt; 1454502365 &lt;/lastreadtime&gt; &lt;/chat&gt; &lt;/unreadchatlist&gt; &lt;unreadfunctionlist&gt; # 未读的功能账号消息，群发助手，漂流瓶等 &lt;/unreadfunctionlist&gt; &lt;/op&gt; &lt;/msg&gt; 文本消息1234MsgType: 1 FromUserName: 发送方ID ToUserName: 接收方ID Content: 消息内容 图片消息 itchat 增加了 Text 键, 键值为 下载该图片的方法. 123456789MsgType: 3 FromUserName: 发送方ID ToUserName: 接收方ID MsgId: 用于获取图片，用于表示每一条消息 Content: &lt;msg&gt; &lt;img length="6503" hdlength="0" /&gt; &lt;commenturl&gt;&lt;/commenturl&gt; &lt;/msg&gt; 拓展：如果想要得到Content中的具体内容可以使用正则表达式匹配出来 视频消息 **itchat 增加了 Text 键, 键值为 下载该视频的方法. 123456789MsgType: 62FromUserName: 发送方IDToUserName: 接收方IDMsgId: 用于获取小视频Content: &lt;msg&gt; &lt;img length="6503" hdlength="0" /&gt; &lt;commenturl&gt;&lt;/commenturl&gt; &lt;/msg&gt; 地理位置消息 itchat 增加了 Text 键, 键值为 该地点的文本形式. 123456789MsgType: 1 FromUserName: 发送方ID ToUserName: 接收方ID Content: http://weixin.qq.com/cgi-bin/redirectforward?args=xxx OriContent:&lt;?xml version="1.0"?&gt;&lt;msg&gt; &lt;location x="34.195278" y="117.177803" scale="16" label="江苏省徐州市铜山区新区海河路" maptype="0" poiname="江苏师范大学大学生公寓园区" /&gt;&lt;/msg&gt; 名片消息 itchat 增加了Text 键, 键值为 该调用 add_friend 需要的属性. 123456789101112131415161718192021222324MsgType: 42 FromUserName: 发送方ID ToUserName: 接收方ID Content: &lt;?xml version="1.0"?&gt; &lt;msg bigheadimgurl="" smallheadimgurl="" username="" nickname="" shortpy="" alias="" imagestatus="3" scene="17" province="" city="" sign="" sex="1" certflag="0" certinfo="" brandIconUrl="" brandHomeUrl="" brandSubscriptConfigUrl="" brandFlags="0" regionCode="" /&gt; RecommendInfo: &#123; "UserName": "xxx", # ID，这里的是昵称 "Province": "xxx", "City": "xxx", "Scene": 17, "QQNum": 0, "Content": "", "Alias": "xxx", # 微信号 "OpCode": 0, "Signature": "", "Ticket": "", "Sex": 0, # 1:男, 2:女 "NickName": "xxx", # 昵称 "AttrStatus": 4293221, "VerifyFlag": 0 &#125; 下面是添加好友的测试代码 1234567@itchat.msg_register(itchat.content.CARD,isFriendChat=True)def simply(msg): print msg['Text'] print msg['Content'] itchat.add_friend(userName=msg['Text']['UserName']) #添加推荐的好友 print msg['RecommendInfo'] print msg['RecommendInfo']['UserName'] 语音消息 *itchat增加了Text键,键值为下载该语音文件的方法,下载下来的是MP3的格式 123456789MsgType: 34 FromUserName: 发送方ID ToUserName: 接收方ID MsgId: 用于获取语音 Content: &lt;msg&gt; &lt;voicemsg endflag="1" cancelflag="0" forwardflag="0" voiceformat="4" voicelength="1580" length="2026" bufid="216825389722501519" clientmsgid="49efec63a9774a65a932a4e5fcd4e923filehelper174_1454602489" fromusername="" /&gt; &lt;/msg&gt; 下载方法：msg[&#39;Text&#39;](msg[&#39;FileName&#39;]) 动画表情 itchat添加了Text键，键值为下载该图片表情的方法。注意：本人亲测对于一些微信商店提供的表情是不能下载成功的,这里的自带的表情emoji是属于TEXT类别的，因此如果将其注册为PICTURE消息类型的话是不可以监测到的 12345678MsgType: 47 FromUserName: 发送方ID ToUserName: 接收方ID Content: &lt;msg&gt; &lt;emoji fromusername = "" tousername = "" type="2" idbuffer="media:0_0" md5="e68363487d8f0519c4e1047de403b2e7" len = "86235" productid="com.tencent.xin.emoticon.bilibili" androidmd5="e68363487d8f0519c4e1047de403b2e7" androidlen="86235" s60v3md5 = "e68363487d8f0519c4e1047de403b2e7" s60v3len="86235" s60v5md5 = "e68363487d8f0519c4e1047de403b2e7" s60v5len="86235" cdnurl = "http://emoji.qpic.cn/wx_emoji/eFygWtxcoMF8M0oCCsksMA0gplXAFQNpiaqsmOicbXl1OC4Tyx18SGsQ/" designerid = "" thumburl = "http://mmbiz.qpic.cn/mmemoticon/dx4Y70y9XctRJf6tKsy7FwWosxd4DAtItSfhKS0Czr56A70p8U5O8g/0" encrypturl = "http://emoji.qpic.cn/wx_emoji/UyYVK8GMlq5VnJ56a4GkKHAiaC266Y0me0KtW6JN2FAZcXiaFKccRevA/" aeskey= "a911cc2ec96ddb781b5ca85d24143642" &gt;&lt;/emoji&gt; &lt;gameext type="0" content="0" &gt;&lt;/gameext&gt; &lt;/msg&gt; 普通链接或应用分享消息 主要针对的是分享的文章等等 12345678910111213141516171819202122MsgType: 49AppMsgType: 5FromUserName: 发送方IDToUserName: 接收方IDUrl: 链接地址FileName: 链接标题Content: &lt;msg&gt; &lt;appmsg appid="" sdkver="0"&gt; &lt;title&gt;&lt;/title&gt; &lt;des&gt;&lt;/des&gt; &lt;type&gt;5&lt;/type&gt; &lt;content&gt;&lt;/content&gt; &lt;url&gt;&lt;/url&gt; &lt;thumburl&gt;&lt;/thumburl&gt; ... &lt;/appmsg&gt; &lt;appinfo&gt; &lt;version&gt;&lt;/version&gt; &lt;appname&gt;&lt;/appname&gt; &lt;/appinfo&gt; &lt;/msg&gt; 音乐链接消息 主要针对的是音乐 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758MsgType: 49 AppMsgType: 3 FromUserName: 发送方ID ToUserName: 接收方ID Url: 链接地址 FileName: 音乐名 AppInfo: # 分享链接的应用 &#123; Type: 0, AppID: wx485a97c844086dc9 &#125; Content: &lt;msg&gt; &lt;appmsg appid="wx485a97c844086dc9" sdkver="0"&gt; &lt;title&gt;&lt;/title&gt; &lt;des&gt;&lt;/des&gt; &lt;action&gt;&lt;/action&gt; &lt;type&gt;3&lt;/type&gt; &lt;showtype&gt;0&lt;/showtype&gt; &lt;mediatagname&gt;&lt;/mediatagname&gt; &lt;messageext&gt;&lt;/messageext&gt; &lt;messageaction&gt;&lt;/messageaction&gt; &lt;content&gt;&lt;/content&gt; &lt;contentattr&gt;0&lt;/contentattr&gt; &lt;url&gt;&lt;/url&gt; &lt;lowurl&gt;&lt;/lowurl&gt; &lt;dataurl&gt; http://ws.stream.qqmusic.qq.com/C100003i9hMt1bgui0.m4a?vkey=6867EF99F3684&amp;amp;guid=ffffffffc104ea2964a111cf3ff3edaf&amp;amp;fromtag=46 &lt;/dataurl&gt; &lt;lowdataurl&gt; http://ws.stream.qqmusic.qq.com/C100003i9hMt1bgui0.m4a?vkey=6867EF99F3684&amp;amp;guid=ffffffffc104ea2964a111cf3ff3edaf&amp;amp;fromtag=46 &lt;/lowdataurl&gt; &lt;appattach&gt; &lt;totallen&gt;0&lt;/totallen&gt; &lt;attachid&gt;&lt;/attachid&gt; &lt;emoticonmd5&gt;&lt;/emoticonmd5&gt; &lt;fileext&gt;&lt;/fileext&gt; &lt;/appattach&gt; &lt;extinfo&gt;&lt;/extinfo&gt; &lt;sourceusername&gt;&lt;/sourceusername&gt; &lt;sourcedisplayname&gt;&lt;/sourcedisplayname&gt; &lt;commenturl&gt;&lt;/commenturl&gt; &lt;thumburl&gt; http://imgcache.qq.com/music/photo/album/63/180_albumpic_143163_0.jpg &lt;/thumburl&gt; &lt;md5&gt;&lt;/md5&gt; &lt;/appmsg&gt; &lt;fromusername&gt;&lt;/fromusername&gt; &lt;scene&gt;0&lt;/scene&gt; &lt;appinfo&gt; &lt;version&gt;29&lt;/version&gt; &lt;appname&gt;摇一摇搜歌&lt;/appname&gt; &lt;/appinfo&gt; &lt;commenturl&gt;&lt;/commenturl&gt; &lt;/msg&gt; 群消息 itchat 增加了三个群聊相关的键值: isAt : 判断是否 @ 本号 ActualNickName : 实际 NickName Content : 实际 Content 12345MsgType: 1FromUserName: @@xxxToUserName: @xxxContent: @xxx:&lt;br/&gt;xxx 红包消息12345MsgType: 49 AppMsgType: 2001 FromUserName: 发送方ID ToUserName: 接收方ID Content: 未知 系统消息1234567MsgType: 10000 FromUserName: 发送方ID ToUserName: 自己ID Content: "你已添加了 xxx ，现在可以开始聊天了。" "如果陌生人主动添加你为朋友，请谨慎核实对方身份。" "收到红包，请在手机上查看" 账号类型 tchat 为三种账号都提供了 整体获取方法与搜索方法. 好友get_friends itchat.get_friends() 返回完整的好友列表 每个好友为一个字典, 其中第一项为本人的账号信息; 传入update=True, 将更新好友列表并返回, get_friends(update=True) search_friends itchat.get_friends() 好友搜索，有以下四种方式 仅获取自己的用户信息 12# 获取自己的用户信息，返回自己的属性字典itchat.search_friends() 获取特定 UserName 的用户信息 12345678910# 获取特定UserName的用户信息itchat.search_friends(userName='@abcdefg1234567') ## 获取发送信息的好友的详细信息@itchat.msg_register(itchat.content.TEXT,isFriendChat=True)def reply(msg): print msg['FromUserName'] print itchat.search_friends(userName=msg['FromUserName']) #详细信息 print itchat.search_friends(userName=msg['FromUserName'])['NickName'] #获取昵称 获取备注,微信号, 昵称中的任何一项等于name键值的用户. (可以与下一项配置使用.) 比如在我的微信中有一个备注为autolife的人，我可以使用这个方法搜索出详细的信息 12# 获取任何一项等于name键值的用户itchat.search_friends(name='autolife') 获取备注,微信号, 昵称分别等于相应键值的用户. (可以与上一项配置使用.) 1234# 获取分别对应相应键值的用户itchat.search_friends(wechatAccount='littlecodersh')# 三、四项功能可以一同使用itchat.search_friends(name='LittleCoder机器人', wechatAccount='littlecodersh') update_friend 主要用于好友更新 特定用户: 传入用户UserName, 返回指定用户的最新信息. 用户列表: 传入 UserName 组成的列表, 返回用户最新信息组成的列表 1memberList = itchat.update_friend('@abcdefg1234567') 公众号get_mps 将返回完整的工作号列表 每个公众号为一个字典, 传入 update=True 将更新公众号列表, 并返回. search_mps 获取特定UserName的公众号 12# 获取特定UserName的公众号，返回值为一个字典itchat.search_mps(userName='@abcdefg1234567') 获取名字中还有特定字符的公众号. 12# 获取名字中含有特定字符的公众号，返回值为一个字典的列表itchat.search_mps(name='LittleCoder') 当两项都是勇士, 将仅返回特定UserName的公众号. 群聊 get_chatrooms : 返回完整的群聊列表. search_chatrooms : 群聊搜索. update_chatroom : 获取群聊用户列表或更新该群聊. 群聊在首次获取中不会获取群聊的用户列表, 所以需要调用该命令才能获取群聊成员. 传入群聊的 UserName , 返回特定群聊的详细信息. 传入UserName组成的列表, 返回指定用户的最新信息组成的列表. 1memberList = itchat.update_chatroom('@@abcdefg1234567', detailedMember=True) 创建群聊,增加/删除群聊用户: 由于之前通过群聊检测是否被好友拉黑的程序, 目前这三个方法都被严格限制了使用频率. 删除群聊需要本账号为管理员, 否则无效. 将用户加入群聊有直接加入与发送邀请, 通过 useInvitation 设置. 超过 40 人的群聊无法使用直接加入的加入方式. 1234567memberList = itchat.get_frients()[1:]# 创建群聊, topic 键值为群聊名称.chatroomUserName = itchat.create_chatroom(memberList, "test chatroom")# 删除群聊内的用户itchat.delete_member_from_chatroom(chatroomUserName, memberList[0])# 增加用户进入群聊.itchat.add_member_into_chatroom(chatroomUserName, memberList[0], useInvitation=False) 方法汇总1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253itchat.add_friend itchat.new_instance itchat.add_member_into_chatroom itchat.originInstance itchat.auto_login itchat.returnvalues itchat.check_login itchat.run itchat.components itchat.search_chatrooms itchat.config itchat.search_friends itchat.configured_reply itchat.search_mps itchat.content itchat.send itchat.core itchat.send_file itchat.Core itchat.send_image itchat.create_chatroom itchat.send_msg itchat.delete_member_from_chatroom itchat.send_raw_msg itchat.dump_login_status itchat.send_video itchat.get_chatrooms itchat.set_alias itchat.get_contact itchat.set_chatroom_name itchat.get_friends itchat.set_logging itchat.get_head_img itchat.set_pinned itchat.get_mps itchat.show_mobile_login itchat.get_msg itchat.start_receiving itchat.get_QR itchat.storage itchat.get_QRuuid itchat.update_chatroom itchat.instanceList itchat.update_friend itchat.load_login_status itchat.upload_file itchat.log itchat.utils itchat.login itchat.VERSION itchat.logout itchat.web_init itchat.msg_register 实例 下面是博主写的一个程序，该程序的主要功能是监控撤回消息，并且如果有消息撤回就会撤回的消息发送给你，以后再也不用担心看不到好友的撤回的消息了，由于注释写的很详细，因此这里就不在详细的讲解了，直接贴代码 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106# coding:utf-8import itchatfrom itchat.content import TEXTfrom itchat.content import *import sysimport timeimport rereload(sys)sys.setdefaultencoding('utf8')import osmsg_information = &#123;&#125;face_bug=None #针对表情包的内容@itchat.msg_register([TEXT, PICTURE, FRIENDS, CARD, MAP, SHARING, RECORDING, ATTACHMENT, VIDEO],isFriendChat=True, isGroupChat=True, isMpChat=True)def handle_receive_msg(msg): global face_bug msg_time_rec = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) #接受消息的时间 msg_from = itchat.search_friends(userName=msg['FromUserName'])['NickName'] #在好友列表中查询发送信息的好友昵称 msg_time = msg['CreateTime'] #信息发送的时间 msg_id = msg['MsgId'] #每条信息的id msg_content = None #储存信息的内容 msg_share_url = None #储存分享的链接，比如分享的文章和音乐 print msg['Type'] print msg['MsgId'] if msg['Type'] == 'Text' or msg['Type'] == 'Friends': #如果发送的消息是文本或者好友推荐 msg_content = msg['Text'] print msg_content #如果发送的消息是附件、视屏、图片、语音 elif msg['Type'] == "Attachment" or msg['Type'] == "Video" \ or msg['Type'] == 'Picture' \ or msg['Type'] == 'Recording': msg_content = msg['FileName'] #内容就是他们的文件名 msg['Text'](str(msg_content)) #下载文件 # print msg_content elif msg['Type'] == 'Card': #如果消息是推荐的名片 msg_content = msg['RecommendInfo']['NickName'] + '的名片' #内容就是推荐人的昵称和性别 if msg['RecommendInfo']['Sex'] == 1: msg_content += '性别为男' else: msg_content += '性别为女' print msg_content elif msg['Type'] == 'Map': #如果消息为分享的位置信息 x, y, location = re.search( "&lt;location x=\"(.*?)\" y=\"(.*?)\".*label=\"(.*?)\".*", msg['OriContent']).group(1, 2, 3) if location is None: msg_content = r"纬度-&gt;" + x.__str__() + " 经度-&gt;" + y.__str__() #内容为详细的地址 else: msg_content = r"" + location elif msg['Type'] == 'Sharing': #如果消息为分享的音乐或者文章，详细的内容为文章的标题或者是分享的名字 msg_content = msg['Text'] msg_share_url = msg['Url'] #记录分享的url print msg_share_url face_bug=msg_content##将信息存储在字典中，每一个msg_id对应一条信息 msg_information.update( &#123; msg_id: &#123; "msg_from": msg_from, "msg_time": msg_time, "msg_time_rec": msg_time_rec, "msg_type": msg["Type"], "msg_content": msg_content, "msg_share_url": msg_share_url &#125; &#125; )##这个是用于监听是否有消息撤回@itchat.msg_register(NOTE, isFriendChat=True, isGroupChat=True, isMpChat=True)def information(msg): #这里如果这里的msg['Content']中包含消息撤回和id，就执行下面的语句 if '撤回了一条消息' in msg['Content']: old_msg_id = re.search("\&lt;msgid\&gt;(.*?)\&lt;\/msgid\&gt;", msg['Content']).group(1) #在返回的content查找撤回的消息的id old_msg = msg_information.get(old_msg_id) #得到消息 print old_msg if len(old_msg_id)&lt;11: #如果发送的是表情包 itchat.send_file(face_bug,toUserName='filehelper') else: #发送撤回的提示给文件助手 msg_body = "告诉你一个秘密~" + "\n" \ + old_msg.get('msg_from') + " 撤回了 " + old_msg.get("msg_type") + " 消息" + "\n" \ + old_msg.get('msg_time_rec') + "\n" \ + "撤回了什么 ⇣" + "\n" \ + r"" + old_msg.get('msg_content') #如果是分享的文件被撤回了，那么就将分享的url加在msg_body中发送给文件助手 if old_msg['msg_type'] == "Sharing": msg_body += "\n就是这个链接➣ " + old_msg.get('msg_share_url') # 将撤回消息发送到文件助手 itchat.send_msg(msg_body, toUserName='filehelper') # 有文件的话也要将文件发送回去 if old_msg["msg_type"] == "Picture" \ or old_msg["msg_type"] == "Recording" \ or old_msg["msg_type"] == "Video" \ or old_msg["msg_type"] == "Attachment": file = '@fil@%s' % (old_msg['msg_content']) itchat.send(msg=file, toUserName='filehelper') os.remove(old_msg['msg_content']) # 删除字典旧消息 msg_information.pop(old_msg_id)itchat.auto_login(hotReload=True)itchat.run() 参考文章 文档：https://itchat.readthedocs.io/zh/latest/ http://www.cnblogs.com/yanjingnan/p/6831464.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python发送邮件]]></title>
      <url>%2F2017%2F05%2F13%2Fpython%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[python发送邮件准备 python中发送邮件主要用的是smtplib和email两个模块，下面主要对这两个模块进行讲解 在讲解之前需要准备至少两个测试的邮箱，其中要在邮箱的设置中开启smtplib协议才可以进行发送和接受 smtplib smtplib.SMTP( [host [, port [, local_hostname[,timeout]]]]) host是SMTP主机的服务器，其中163邮箱的是smtp.163.com,其他的可以在网上找到，port是端口号，这里默认的是25，local_hostname是你主机的SMTP,如果SMTP在你的本机上，你只需要指定服务器地址为 localhost 即可。timeout是设置的连接的限制时间，如果超过这个时间还没有连接上那么就会出现错误 SMTP.set_debuglevel(level)：设置是否为调试模式。默认为False，即非调试模式，表示不输出任何调试信息。如果设置为1就表示输出调试信息 SMTP.connect([host[, port]])：连接到指定的smtp服务器。参数分别表示smpt主机和端口。注意: 也可以在host参数中指定端口号（如：smpt.yeah.net:25），这样就没必要给出port参数。 SMTP.login(user, password) 登录服务器，这里的user是邮箱的用户名，但是这里的password并不是你邮箱的密码，当你开启SMTP的时候会提示你设置一个密码，这里的密码就是对应的密码 SMTP.sendmail(from_addr, [to_addrs,], msg[, mail_options, rcpt_options]) 发送邮件，from_addr是发送方也就是你的邮箱地址，to_addr是接受方的地址，当然这里的可以填上多个邮箱账号发送给多个账号，如果有多个账号需要使用列表传递参数 SMTP.quit()断开连接 email emial模块用来处理邮件消息，包括MIME和其他基于RFC 2822的消息文档。使用这些模块来定义邮件的内容，是非常简单的。其包括的类有（更加详细的介绍可见：http://docs.python.org/library/email.mime.html）： class email.mime.base.MIMEBase(_maintype, _subtype, **_params)：这是MIME的一个基类。一般不需要在使用时创建实例。其中_maintype是内容类型，如text或者image。_subtype是内容的minor type类型，如plain或者gif。 **_params是一个字典，直接传递给Message.add_header()。 class email.mime.multipart.MIMEMultipart([_subtype[, boundary[, _subparts[, _params]]]]：MIMEBase的一个子类，多个MIME对象的集合，_subtype默认值为mixed。boundary是MIMEMultipart的边界，默认边界是可数的。当需要发送附件的时候使用的就是这个类 class email.mime.application.MIMEApplication(_data[, _subtype[, _encoder[, **_params]]])：MIMEMultipart的一个子类。 class email.mime.audio. MIMEAudio(_audiodata[, _subtype[, _encoder[, **_params]]])： MIME音频对象 class email.mime.image.MIMEImage(_imagedata[, _subtype[, _encoder[, **_params]]])：MIME二进制文件对象。主要用来发送图片 普通文本邮件 class email.mime.text.MIMEText(_text[, _subtype[, _charset]])：MIME文本对象，其中_text是邮件内容，_subtype邮件类型，可以是text/plain（普通文本邮件），html/plain(html邮件), _charset编码，可以是gb2312等等。 普通文本邮件发送的实现，关键是要将MIMEText中_subtype设置为plain。首先导入smtplib和mimetext。创建smtplib.smtp实例，connect邮件smtp服务器，login后发送，具体代码如下* 1234567891011121314151617181920212223# 一个格式化邮件的函数，可以用来使用def _format_addr(s): name, addr = parseaddr(s) return formataddr(( Header(name, 'utf-8').encode(), addr.encode('utf-8') if isinstance(addr, unicode) else addr))from_addr='××××××××' #你的邮箱地址from_password='×××××××' #你的密码# to_email='chenjiabing666@yeah.net'to_email='××××××' #要发送的邮箱地址msg=MIMEText('乔装打扮，不择手段','plain','utf-8') #这里text=乔装打扮，不择手段msg['From'] = _format_addr(u'Python爱好者 &lt;%s&gt;' % from_addr) #格式化发件人msg['To'] = _format_addr(u'管理员 &lt;%s&gt;' % to_email) #格式化收件人msg['Subject'] = Header(u'来自SMTP的问候……', 'utf-8').encode() #格式化主题stmp='smtp.163.com'server=smtplib.SMTP(stmp,port=25,timeout=30) #连接，设置超时时间30sserver.login(from_addr,from_password) #登录server.set_debuglevel(1) #输出所有的信息server.sendmail(from_addr,to_email,msg.as_string()) #这里的as_string()是将msg转换成字符串类型的,如果你想要发给多个人，需要讲to_email换成一个列表 发送html邮件 还是用MIMEText来发送，不过其中的_subType设置成html即可，详细代码如下： 12345678910111213141516171819202122232425def _format_addr(s): name, addr = parseaddr(s) return formataddr(( Header(name, 'utf-8').encode(), addr.encode('utf-8') if isinstance(addr, unicode) else addr))from_addr='××××××××' #你的邮箱地址from_password='×××××××' #你的密码# to_email='chenjiabing666@yeah.net'to_email='××××××' #要发送的邮箱地址html="""&lt;p&gt;&lt;h1 style="color:red"&gt;大家好&lt;/h1&gt;&lt;/p&gt;"""msg=MIMEText(html,'html','utf-8') #这里text=html,设置成html格式的msg['From'] = _format_addr(u'Python爱好者 &lt;%s&gt;' % from_addr) #格式化发件人msg['To'] = _format_addr(u'管理员 &lt;%s&gt;' % to_email) #格式化收件人msg['Subject'] = Header(u'来自SMTP的问候……', 'utf-8').encode() #格式化主题stmp='smtp.163.com'server=smtplib.SMTP(stmp,port=25,timeout=30) #连接，设置超时时间30sserver.login(from_addr,from_password) #登录server.set_debuglevel(1) #输出所有的信息server.sendmail(from_addr,to_email,msg.as_string()) #这里的as_string()是将msg转换成字符串类型的,如果你想要发给多个人，需要讲to_email换成一个列表 附件的发送 发送带附件的邮件，首先要创建MIMEMultipart()实例，然后构造附件，如果有多个附件，可依次构造，最后利用smtplib.smtp发送，具体实力如下： 123456789101112131415161718192021222324252627282930313233343536373839404142from email.mime.multipart import MIMEMultipartfrom email.mime.text import MIMETextimport smtplibfrom email.mime.image import MIMEImagefrom email.mime.multipart import MIMEMultipartfrom email.mime.text import MIMETextfrom email.header import Headerdef _format_addr(s): name, addr = parseaddr(s) return formataddr(( Header(name, 'utf-8').encode(), addr.encode('utf-8') if isinstance(addr, unicode) else addr))from_addr='××××××××' #你的邮箱地址from_password='×××××××' #你的密码# to_email='chenjiabing666@yeah.net'to_email='××××××' #要发送的邮箱地址msg=MIMEMultipart() #创建实例text=MIMEText('&lt;h2 style="color:red"&gt;陈加兵&lt;/h2&gt;&lt;br/&gt;&lt;p&gt;大家好&lt;/p&gt;','html','utf-8')msg.attach(text) #添加一个正文信息，这里实在正文中显示的信息#创建一个文本附件，这里是从指定文本中读取信息，然后创建一个文本信息att1=MIMEText(open('/home/chenjiabing/文档/MeiZi_img/full/file.txt','rb').read(),'plain','utf-8')att1["Content-Type"] = 'application/octet-stream' #指定类型att1["Content-Disposition"] = 'attachment; filename="123.txt"'#这里的filename可以任意写，写什么名字，邮件中显示什么名字msg.attach(att1) #向其中添加附件img_path='/home/chenjiabing/文档/MeiZi_img/full/file.jpg' #图片路径image=MIMEImage(open(img_path,'rb').read()) #创建一个图片附件image.add_header('Content-ID','&lt;0&gt;') #指定图片的编号,这个会在后面用到image.add_header('Content-Disposition', 'attachment', filename='test.jpg') image.add_header('X-Attachment-Id', '0')msg.attach(image) #添加附件stmp='smtp.163.com'server=smtplib.SMTP(stmp,port=25,timeout=30) #连接，设置超时时间30sserver.login(from_addr,from_password) #登录server.set_debuglevel(1) #输出所有的信息server.sendmail(from_addr,to_email,msg.as_string()) #这里的as_string()是将msg转换成字符串类型的,如果你想要发给多个人，需要讲to_email换成一个列表 将图片嵌入到正文信息中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from email.mime.multipart import MIMEMultipartfrom email.mime.text import MIMETextimport smtplibfrom email.mime.image import MIMEImagefrom email.mime.multipart import MIMEMultipartfrom email.mime.text import MIMETextfrom email.header import Headerdef _format_addr(s): name, addr = parseaddr(s) return formataddr(( Header(name, 'utf-8').encode(), addr.encode('utf-8') if isinstance(addr, unicode) else addr))from_addr='××××××××' #你的邮箱地址from_password='×××××××' #你的密码# to_email='chenjiabing666@yeah.net'to_email='××××××' #要发送的邮箱地址msg=MIMEMultipart() #创建实例html="""&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;下面演示嵌入图片&lt;/p&gt;&lt;section&gt;&lt;img src='cid:0' style='float:left'/&gt;&lt;img src='cid:1' style='float:left'/&gt;&lt;/setcion&gt;&lt;/body&gt;&lt;/html&gt;"""text=MIMEText('&lt;h2 style="color:red"&gt;陈加兵&lt;/h2&gt;&lt;br/&gt;&lt;p&gt;大家好&lt;/p&gt;','html','utf-8')msg.attach(text) #添加一个正文信息，这里实在正文中显示的信息#创建一个文本附件，这里是从指定文本中读取信息，然后创建一个文本信息att1=MIMEText(open('/home/chenjiabing/文档/MeiZi_img/full/file.txt','rb').read(),'plain','utf-8')att1["Content-Type"] = 'application/octet-stream' #指定类型att1["Content-Disposition"] = 'attachment; filename="123.txt"'#这里的filename可以任意写，写什么名字，邮件中显示什么名字msg.attach(att1) #向其中添加附件## 创建一个图片附件img_path='/home/chenjiabing/文档/MeiZi_img/full/file.jpg' #图片路径image=MIMEImage(open(img_path,'rb').read()) #创建一个图片附件image.add_header('Content-ID','&lt;0&gt;') #指定图片的编号,image.add_header('Content-Disposition', 'attachment', filename='test.jpg') image.add_header('X-Attachment-Id', '0')msg.attach(image) #添加附件#创建第二个图片附件img_path_1='/home/chenjiabing/文档/MeiZi_img/full/test.jpg' #图片路径image1=MIMEImage(open(img_path,'rb').read()) #创建一个图片附件image1.add_header('Content-ID','&lt;1&gt;') #指定图片的编号,这个就是在上面对应的cid:1的那张图片，因此这里的编号一定要对应image1.add_header('Content-Disposition', 'attachment', filename='img.jpg') image1.add_header('X-Attachment-Id', '0')msg1.attach(image) #添加附件stmp='smtp.163.com'server=smtplib.SMTP(stmp,port=25,timeout=30) #连接，设置超时时间30sserver.login(from_addr,from_password) #登录server.set_debuglevel(1) #输出所有的信息server.sendmail(from_addr,to_email,msg.as_string()) #这里的as_string()是将msg转换成字符串类型的,如果你想要发给多个人，需要讲to_email换成一个列表]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python制作电子书]]></title>
      <url>%2F2017%2F05%2F13%2Fpython%E5%88%B6%E4%BD%9C%E7%94%B5%E5%AD%90%E4%B9%A6%2F</url>
      <content type="text"><![CDATA[python制作pdf电子书准备 制作电子书使用的是python的pdfkit这个库，pdfkit是 wkhtmltopdf 的Python封装包，因此在安装这个之前要安装wkhtmltopdf 安装wkhtmltopdf sudo apt-get install wkhtmltopdf (ubantu下，不过这里安装的时候可能对应的版本不同，会出现错误，如果不行的话还请自己百度下，我安装的时候是可以的) windows下的用户直接到wkhtmltopdf官网下载稳定版本，然后直接安装即可，但是安装之后需要注意的是一定要将其添加到环境变量中，否则会出现找不到路径的问题 python安装依赖包 以下都是我们需要用到的库 pip install requests pip install BeautifulSoup4 pip install pdfkit pdfkit的用法初级了解函数 pdfkit.from_url([url,],&#39;demo.pdf&#39;) 这个是直接传入一个url或者一个url列表，然后通过这个函数直接将其网页转换成demo.pdf,注意这里只能转换静态文本，如果使用js一些脚本的话是不能直接转换的 pdfkit.from_string(&quot;&lt;h1&gt;&lt;a href=&quot;https://chenjiabing666.gituhb.io&quot;&gt;陈加兵的博客&lt;/a&gt;&lt;/h1&gt;&quot;,&#39;demo.pdf&#39;) 这个是直接讲一个字符串转换成pdf格式的电子书，里面可以直接传一个字符串，也可以用html标签包裹这个字符串 pdfkit.from_file([file_name,],&#39;demo.pdf&#39;) 这个是直接传入一个文件或者一个列表即是多个文件，不过这里传入的文件一般都是html格式的文件 进阶 当然知道这个是多么枯燥，生成的电子书书也不能添加各种的样式，下面我们将会介绍一些添加的样式的方法 options 这个参数是上面函数的可选参数，其中制定了一些选项，详情请见http://wkhtmltopdf.org/usage/wkhtmltopdf.txt, 你可以移除选项名字前面的 ‘–’ .如果选项没有值, 使用None, Falseor ,* 作为字典值，例子如下： 12345678910111213141516options = &#123; 'page-size': 'Letter', 'margin-top': '0.75in', 'margin-right': '0.75in', 'margin-bottom': '0.75in', 'margin-left': '0.75in', 'encoding': "UTF-8", 'custom-header': [ ('Accept-Encoding', 'gzip') ], 'cookie': [ ('cookie-name1', 'cookie-value1'), ('cookie-name2', 'cookie-value2'), ], 'outline-depth': 10, &#125; cover 这个参数是用来制作封面的，也是函数中的一个参数，如果想要实现的话可以先写一个html文本，在其中嵌入几张图片或者文字作为封面，然后写入出传入函数即可 123456789101112131415161718options = &#123; 'page-size': 'Letter', 'margin-top': '0.75in', 'margin-right': '0.75in', 'margin-bottom': '0.75in', 'margin-left': '0.75in', 'encoding': "UTF-8", 'custom-header': [ ('Accept-Encoding', 'gzip') ], 'cookie': [ ('cookie-name1', 'cookie-value1'), ('cookie-name2', 'cookie-value2'), ], 'outline-depth': 10, &#125;cover='demo.html'pdfkit.from_file('demo.html','demo.pdf',cover=cover,options=options) css 这里的css也是函数中的一个可选参数，这个参数主要的作用作用就是在其中定义自己喜欢的样式，当然这里也可以传入一个列表，定义多个样式css文件，当然没有这个参数也可以实现定义自己的样式，只需要在自己的html模板中定义内嵌的样式，或者直接用&lt;link&gt;引用外面的样式即可，本人亲试是可以的，具体的使用如下 12css='demo.css'pdfkit.from_file('demo.html','demo.pdf',options=options,cover=cover,css=css) 注意 这里生成pdf的时候可能出现中文的乱码，请一定在html模板开头指定字体utf-8-&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; 可能在爬取生成的时候会出现ascii错误，只需要在py文件开头写下： 1234import sysimport threadingreload(sys)sys.setdefaultencoding('utf8') 写入文件的时候不想python3一样可以指定编码格式，这里我使用的是codecs库，可以向python3一样指定其中的编码格式 实战 本人爬了廖雪峰老师的python2.7的教程，并且做成了电子书，截图如下 注意 这里并没有使用框架，如果有兴趣的朋友可以用框架写一个爬取全站的 这里的主要用到的是BeautifulSoup和requests,详情可以看我的博客中的BeautifulSoup用法,后续还会更新requests的用法 源代码请见https://github.com/chenjiabing666/liaoxuefeng_pdfkit 参考文章 http://mp.weixin.qq.com/s/LH8nEFfVH4_tvYWo46CF5Q http://www.cnblogs.com/taceywong/p/5643978.html http://beautifulsoup.readthedocs.io/zh_CN/latest/#id44]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[回溯算法]]></title>
      <url>%2F2017%2F05%2F10%2F%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[回溯算法主要思想 回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。八皇后问题就是回溯算法的典型，第一步按照顺序放一个皇后，然后第二步符合要求放第2个皇后，如果没有位置符合要求，那么就要改变第一个皇后的位置，重新放第2个皇后的位置，直到找到符合条件的位置就可以了。回溯在迷宫搜索中使用很常见，就是这条路走不通，然后返回前一个路口，继续下一条路。回溯算法说白了就是穷举法。不过回溯算法使用剪枝函数，剪去一些不可能到达 最终状态（即答案状态）的节点，从而减少状态空间树节点的生成。回溯法是一个既带有系统性又带有跳跃性的的搜索算法。它在包含问题的所有解的解空间树中，按照深度优先的策略，从根结点出发搜索解空间树。算法搜索至解空间树的任一结点时，总是先判断该结点是否肯定不包含问题的解。如果肯定不包含，则跳过对以该结点为根的子树的系统搜索，逐层向其祖先结点回溯。否则，进入该子树，继续按深度优先的策略进行搜索。回溯法在用来求问题的所有解时，要回溯到根，且根结点的所有子树都已被搜索遍才结束。而回溯法在用来求问题的任一解时，只要搜索到问题的一个解就可以结束。这种以深度优先的方式系统地搜索问题的解的算法称为回溯法，它适用于解一些组合数较大的问题。回溯算法也叫试探法，它是一种系统地搜索问题的解的方法。回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。用回溯算法解决问题的一般步骤为： 定义一个解空间，它包含问题的解。 利用适于搜索的方法组织解空间。 利用深度优先法搜索解空间。 利用限界函数避免移动到不可能产生解的子空间。 解决迷宫问题解决思想 将迷宫问题对应为二维数组，数组中只有两种值0和1，其中0，1分别表示通路和墙。不过在解决这个问题的时候一般要在最外面添加一个围墙，这里设置每个围墙都为1，这样有利于防止当走到了迷宫的出口处还会向前走，这个并不一定，只是最一般的方法，也是最有利于理解的方法。这里的利用到了回溯法，需要走到了一个位置，然后向四处试探，如果有一个方向可以走了就将当前的点压入栈，并且标记当前点以便于区分是否走过，如果四处都无出路，只需要回到前一个走到的点，然后从前一个点再换一个方向重新走 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146import java.util.Stack;/** * Created by chenjiabing on 17-5-5. */class position &#123; public int row; public int col; public position(int row, int col) &#123; this.col = col; this.row = row; &#125; public position() &#123; row = 0; col = 0; &#125; public String toString() &#123; return "(" + (row - 1) + " ," + (col - 1) + ")"; &#125; //这里由于四周围上了墙，所以这里的输出就要在原来的基础上减一&#125;class Main &#123; private int[][] maze = null; private Stack&lt;position&gt; stack = null; //创建一个栈用于存储状态 private int row; //行数 private int col; boolean[][] p = null; //这里的p是用来标记已经走过的点，初始化为false public boolean end(int i, int j) &#123; return i == row &amp;&amp; j == col; &#125; public Main(int[][] maze) &#123; stack = new Stack&lt;position&gt;(); row = maze[0].length;// 行数 col = maze.length; //列数 p = new boolean[row + 2][col + 2]; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; p[i][j] = false; //初始化 &#125; &#125; this.maze = maze; &#125; public void findPath() &#123; //创建一个新的迷宫，将两边都围上墙，也就是在四周都填上1的墙，形成新的迷宫，主要的目的就是防止走到迷宫的边界的出口的位置还会继续向前走 //因此需要正确的判断是否在边界线上，所以要在外围加上一堵墙, int[][] temp = new int[row + 2][col + 2]; for (int i = 0; i &lt; row + 2; i++) &#123; for (int j = 0; j &lt; col + 2; j++) &#123; temp[0][j] = 1; //第一行围上 temp[row + 1][j] = 1; //最后一行围上 temp[i][0] = temp[i][col + 1] = 1; //两边的围上 &#125; &#125; // 将原始迷宫复制到新的迷宫中 for (int i = 0; i &lt; row; ++i) &#123; for (int j = 0; j &lt; col; ++j) &#123; temp[i + 1][j + 1] = maze[i][j]; &#125; &#125; int i = 1; int j = 1; p[i][j] = true; stack.push(new position(i, j)); //这里是是将走到的点入栈，然后如果前后左右都走不通的话才出栈 while (!stack.empty() &amp;&amp; !end(i, j)) &#123; //下面就开始在四周试探，如果有路就向前走，顺序分别是右，下，上，左，当然这是随便定义的，不过一般都是现向下和右的 if (temp[i][j + 1] == 0 &amp;&amp; p[i][j + 1] == false)//这里如果不在四周加上墙，那么在到达边界判断的时候就会出现超出数组的索引的错误，因为到达边界再加一就会溢出 &#123; p[i][j + 1] = true; stack.push(new position(i, j + 1)); j++; &#125; else if (temp[i + 1][j] == 0 &amp;&amp; p[i + 1][j] == false)//如果下面可以走的话，讲当前点压入栈，i++走到下一个点 &#123; p[i + 1][j] = true; stack.push(new position(i + 1, j)); i++; &#125; else if (temp[i][j - 1] == 0 &amp;&amp; p[i][j - 1] == false) &#123; p[i][j - 1] = true; stack.push(new position(i, j - 1)); j--; &#125; else if (temp[i - 1][j] == 0 &amp;&amp; p[i - 1][j] == false) &#123; p[i - 1][j] = true; stack.push(new position(i - 1, j)); i--; &#125; else //前后左右都不能走 &#123; System.out.println(i + "---------" + j); stack.pop(); //这个点不能走通，弹出 if (stack.empty()) //如果此栈中已经没有点了，那么直接跳出循环 &#123; System.out.println("没有路径了，出不去了"); return; //直接退出了，下面就不用找了 &#125; i = stack.peek().row; //获得最新点的坐标 j = stack.peek().col; &#125; //如果已经到达了边界，那么直接可以出去了，不需要继续向前走了，这里是规定边界的任意为0的位置都是出口 //如果不加这个判断的话，那么当到达边界的时候，只有走到不能再走的时候才会输出路线，那种线路相对这个而言是比较长的 if (j == temp[0].length - 2) &#123; //如果已经到达边界了，那么当前的位置就是出口，就不需要再走了 Stack&lt;position&gt; pos = new Stack&lt;position&gt;(); System.out.println("路径如下："); for (int count = 0; count &lt; stack.size(); count++) &#123; System.out.println(stack.elementAt(count)); &#125; &#125; &#125; &#125; public static void main(String args[]) &#123; int[][] maze = &#123; &#123;0, 1, 0, 0, 0&#125;, &#123;0, 1, 0, 1, 0&#125;, &#123;0, 0, 0, 0, 0&#125;, &#123;0, 1, 1, 1, 0&#125;, &#123;0, 0, 0, 1, 0&#125; &#125;; Main main = new Main(maze); main.findPath(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[跳跃链表]]></title>
      <url>%2F2017%2F05%2F09%2F%E8%B7%B3%E8%B7%83%E9%93%BE%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[数据结构之跳跃链表简介 总的来说跳跃链表最大的好处就是提高了检索了的速率，可以说说是大幅度的提高，相对于单链表来说是一种高效率的检索结构 原理 跳跃表的结构是：假如底层有10个节点， 那么底层的上一层理论上就有5个节点，再上一层理论上就有2个或3个节点，再上一层理论上就有1个节点。所以从这里可以看出每一层的节点个数为其下一层的1/2个元素，以此类推。从这里我们可以看到，从插入时我们只要保证上一层的元素个数为下一层元素个数的1/2，我们的跳跃表就能成为理想的跳跃表。那么怎么才能保证我们插入时上层元素个数是下层元素个数的1/2呢，？很简单 抛硬币就可以解决了，假设元素X要插入跳跃表，最底层是肯定要插入X的，那么次低层要不要插入呢，我们希望上层元素个数是下层的1/2，那么我们有1/2的概率要插入到次低层，这样就来抛硬币吧，正面就插入，反面就不插入，次次底层相对于次低层，我们还是有1/2的概率插入，那么就继续抛硬币吧 ， 以此类推元，素X插入第n层的概率是(1/2)的n次。这样，我们能在跳跃表中插入一个元素了。基本的样子如下图： 代码实现(java语言)节点定义123456789101112131415package skip;public class Node&#123; public Integer value; //插入的数据 public Node left; //分别对应的四个方向的指针 public Node down; public Node right; public Node up; public Node(Integer value) //构造函数 &#123; this.value=value; down=up=right=left=null; &#125;&#125; 表的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199package skip;import java.util.Random;public class SkipList &#123; private Node head; //最上面一侧的头结点，这里使用的是双链表 private Node tail; //最上面一层的尾节点，这里的头尾节点是不存储数据的，数据域全是null private int level; //表中的最高的层数，就是总共的层数 private int size; //插入节点的个数，头尾节点除外 private Random random; //用来判断是否需要增加高度的随机函数 public SkipList() &#123; level = 0; //level默认是0层，就是只有最下面的一层 head = new Node(null); tail = new Node(null); head.right = tail; //这里初始化成一个只有一层的双链表 tail.left = head; size = 0; //size初始化为0 random = new Random(); &#125; //这个函数的作用是找到插入节点的前面一个节点，这里默认的是将表升序存储 public Node findFirst(Integer value) &#123; Node p = head; while (true) &#123; //判断要插入的位置，当没有查到尾节点并且要插入的数据还是比前面的大的话，就将节点右移，知道找到合适的位置 //这里需要注意的是这里的head代表不一定是最底层的，因此这里的查找都是从最高层进行查找的，如果满足条件就要向下移动 //直到最底层 while (p.right.value != null &amp;&amp; p.right.value &lt;= value) &#123; p = p.right; &#125; //向下移动，直到到达最后一层 if (p.down != null) &#123; p = p.down; &#125; else &#123; //到达最底层跳出即可 break; &#125; &#125; return p; //此时这里的p就是要插入节点的前面一个节点 &#125; //这是插入函数，这里先执行插入，然后判断是否需要增加高度 public void insert(int value) &#123; Node curr = findFirst(value); //先找到插入位置的前面一个节点 Node q = new Node(value); //新建一个插入的节点 //下面执行插入步骤，这个和双链表是一样的步骤 q.right = curr.right; q.left = curr; curr.right.left = q; curr.right = q; int i = 0; //表示当前节点所在的层数，开始插入的是在下面插入的，所以开始的时候是在0层 //这里判断是否需要增加高度，每一层相对域下面来说都有二分之一的概率，也就是说每一层增加的概率是（1/2）^n //通俗的说就是每一层的节点是将会保证是下面一层的1/2 while (random.nextDouble() &lt; 0.5) &#123; if (i &gt;= level) &#123; //如果当前插入的节点所处的层数大于等于最大的层数，那么就需要增加高度了，因为这里要保证头尾节点的高度是最高的 //下面的代码就是在头尾节点的上插入新的节点，以此来增加高度 Node p1 = new Node(null); Node p2 = new Node(null); p1.right = p2; p1.down = head; p2.left = p1; p2.down = tail; head.up = p1; //将头尾节点上移，成为最顶层的节点，这就是为什么每次插入和查询的时候都是最上面开始查询的，因为这里的head默认的就是从最上面开始的 tail.up = p2; head = p1; tail = p2; level++; //最高层数加一 &#125; while (curr.up == null) &#123; //当然增加高度就是在插入节点上面新插入一个节点，然后将之与插入的节点相连 //既然这里新插入节点增高了，那么就需要找到与新插入节点上面的那个节点相连接，这里我们将新插入节点的前面的同等高度的节点与之相连 curr = curr.left; &#125; curr = curr.up; //通过前面的一个节点找到与之相连的节点 //下面就是创建一个节点插入到插入节点的头上以此来增加高度，并且这个节点与前面一样高的节点相连 Node e = new Node(value); e.left = curr; e.right = curr.right; curr.right.left = e; //此时的curr就是与之同等高度的节点 curr.right = e; e.down = q; q.up = e; q = e; //将新插入的节点上移到最上面，因为后面可能还要在这里增加高度，就是在最上面插入新的一模一样的节点 i++; //增加当前所处的高度，这里一定能要记得写上，如果还要继续增加的话，需要判读是否需要增加头尾节的高度 &#125; size++; //节点加一 &#125; //下面是打印每一层节点的情况 public void display() &#123; while (level &gt;= 0) &#123; Node p = head; while (p != null) &#123; System.out.print(p.value + "--------&gt;"); p = p.right; &#125; System.out.println(); System.out.println("*****************************"); level--; head = head.down; &#125; &#125; /*在链表中查找某个值是否存在，如果存在找到的节点，当然先从最高层开始查找，如果找到了在比这个值小的最后一个值，那么就顺着这个值的下面开始寻找，按照上面的步骤 再次寻找，如过这个值正好等于要找的值，就返回true，形象的来说就是形成一个梯度的感觉。注意这里返回的节点一定是最底层的节点，利于下面的删除操作 * */ public Node search(int value) &#123; Node p = head; while (true) &#123; /*这里一定要写成p.right.value!=null,如果写成p.right!=null运行可能有错误， 因为这里的尾节点的值为null，但是它的节点不是空的，如果成这样的话,那么节点可能会找到尾节点都没有找到，此时在判断value的值就出现错误 相当与判断tail.right.value&lt;=value,这个肯定是不行的，因为这个节点不存在，是空的更别说值了 */ //从最高层开始判断找到比这个小的最后一个值，就是找到一个节点的前面比value小的，后面的节点的值比value大的 while (p.right.value != null &amp;&amp; p.right.value &lt;= value) &#123; p = p.right; //如果没有找到就后移直到找到这个节点 &#125; //如果找到的这个节点不是最底层的话，就向下移动一层，然后循环再次寻找，总之就是从最高层开始，一层一层的寻找 if (p.down != null) &#123; //这个表示上面的循环没有找到的相等的，那么就向下移动一层 p = p.down; &#125; else &#123; //如果到了最底层了，这里的值仍然没有找到这个值，那么就表示不存在这个值 if (p.value == value) &#123; //判断是否存在value相等的值// System.out.println(p.value + "-----&gt;"); return p; //返回节点 &#125; return null; //仍然没有找到返回null &#125; &#125; &#125; /* 这里是利用上面的查找函数，找到当前需要删除的节点，当然这个节点是最底层的节点，然后循环从最底层开始删除所有的节点 * */ public void delete(int value) &#123; Node temp = search(value); //这里返回的必须是最底层的节点，因为要从最下面的往上面全部删除所有层的节点，否则的话可能在某一层上仍然存在这个节点 while (temp != null) &#123; temp.left.right = temp.right; temp.right.left = temp.left; temp = temp.up; //节点上移，继续删除上一层的节点 &#125; &#125; public static void main(String args[]) &#123; SkipList skipList = new SkipList(); Random random = new Random(); skipList.insert(33); skipList.insert(44); skipList.insert(11); skipList.insert(10); skipList.insert(22); skipList.insert(22); for (int i = 0; i &lt; 500; i++) &#123; int value = (int) (random.nextDouble() * 1000); skipList.insert(value);// System.out.println(value); &#125; Node p = skipList.search(22); if (p != null) &#123; System.out.println(p.value); &#125; else System.out.println("没有找到"); skipList.delete(33); skipList.display(); &#125;&#125; 源码地址 跳跃链表 双链表 单链表 参考文章 java实现跳跃链表]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git常用命令]]></title>
      <url>%2F2017%2F05%2F07%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[git常用操作第一次连接远程仓库的配置配置user.name 和user.email git config --global user.name &quot;name&quot; 设置你的用户名 git config --global user.email &quot;emil&quot; 设置用户的email账号 生成密钥 ssh-keygen -t rsa -C &quot;your email&quot; 其中填的是你的注册的github的账号，输入之后如果不需要输入密码的话，连续输入三个回车即可，最后在你的在终端输入 cd ~/.ssh 进入到你的文件下可以看到有两个文件id_rsa和id_rsa.pub,最后复制你的id_rsa.pub中的内容到github中的账号中即可 ssh -T git@github.com 如果上面的步骤已经完成了，那么就是验证是否完成了，输入上述语句，如果出现信息，那么证明说明你已经成功了 管理修改 通常我们在提交之后会想要修改，当然我们是在文件上直接修改，但是修改后在git上输入git status查看此时的工作区的状态，你会发现出现了出现了如下的语句： 12345678910On branch masterYour branch is ahead of &apos;origin/master&apos; by 2 commits. (use &quot;git push&quot; to publish your local commits)Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: file.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 从上面的提示可以看出我们有如下方案： 首先执行-&gt;git add file.txt,然后重新提交git commit -m &#39;modified file.txt 撤销修改(没有提交的[commit]) 这里的撤销修改仅仅是对于没有提交的撤销(git commit -m &#39;&#39;),在下面会讲到如何撤销提交后的撤销 未git add 当我们修改后会出现上面的提示，前面已经贴过了，这里就不再贴代码了，根据提示，我们可以git checkout -- file.txt来丢弃工作区的修改，之后就可以看见先前的修改已经不见了 已经git add 当我们修改文件后并且git add 添加到暂存区了，那么查看状态git status,出现的提示如下 1234567On branch masterYour branch is ahead of &apos;origin/master&apos; by 2 commits. (use &quot;git push&quot; to publish your local commits)Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: file.txt 根据上面提示的方法：输入git reset HEAD file.txt,可以看到文件回到未git add的状态了，这时如果你想要丢弃修改，使用git checkout -- file.txt,之后就可以看到你的修改已经不见了 删除文件 其实删除也是一种修改操作，我们在文件管理器中直接使用rm删除文件，这时输入git status可以看到如下的提示： 1234567891011On branch masterYour branch is ahead of &apos;origin/master&apos; by 2 commits. (use &quot;git push&quot; to publish your local commits)Changes not staged for commit: (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) deleted: file.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)PS G:\file&gt; git checkout -- file.txt 如果你不想删除了，想要恢复原来的文件，使用git checkout -- file.txt 这个命令可以让撤销修改，也可以撤销删除，起到一键还原的作用 如果你想要继续删除,那么有两种方法： first:git add file.txt,second:git commit -m &#39;&#39; first:git rm file.txt,second:git commit -m &#39;&#39; 注意： git rm file 可以用来删除提交到版本库中的文件，一般删除要执行以下命令：git rm file.txt,git commit -m &#39;delete&#39;，注意在git commit之前还是可以取消删除的，使用git checkout -- file.txt，可以一键取消删除 创建与合并分支常用命令： git checkout -b dev 创建并且切换到dev分支 git checkout dev 切换到dev分支 git branch 查看所有的分支，带有*的是当前所处的分支 git branch -d dev 删除dev分支，一般在合并之后删除 git branch -D dev ：强制删除分支，一般在没有合并就删除分支会出现不能删除，这是就要使用强制删除这个分支的命令 git merge dev 将dev分支合并到当前分支,使用到Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。 git merge --no-ff -m &quot;merge with no-ff&quot; dev 强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 git log --graph --pretty=oneline --abbrev-commit 查看分支历史 创建合并 首先我们创建一个dev分支,使用命令：git checkout -b dev(创建一个dev分支，并且切换到dev分支上)，我们可以使用git branch查看所有的分支 现在在改变之前master分支上的file.txt文件内容，之后git add file.txt,并且提交到版本库中了(git commit -m &#39;file.txt&#39;)，此时使用git checkout master切换到master分支上，查看file.txt的文件内容，可以看到里面的内容并没有改变，由此可知两个分支是独立的，如果你在一个分之上创建了文件并且提交到版本库中了，切换到另外一个分支上，此时可以发现原来创建的文件不见了，因为那是另外一个分支的文件，当然我们可以合并分支，使用git merge dev,这两个命令将dev分支合并到当前分支 Bug分支管理 如果正在一个分支上工作，另外一个分支上的程序有一个Bug需要马上修改，但是此时这个分支上的东西还需要很长时间才能完成，这应该怎么办呢？难道要放弃当前分支上的修改吗？当然不是了，幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作，具体步骤如下： git stash 将当前的工作状态暂时存储在stash中，输出如下信息 12Saved working directory and index state WIP on dev: 6224937 add mergeHEAD is now at 6224937 add merge 此时可以使用git status 查看当前的分支上的状态，可以知道当前的的工作区就是干净的，因此可以放心的修复另外一个分支上的的Bug了 git checkout master 切换分支，修复Bug git checkout dev 修复好Bug继续回到上一个分支干活 git stash list 可以看到工作现场还在，输出如下信息： 1stash@&#123;0&#125;: WIP on dev: 6224937 add merge 如果有多个修改的内容，这里的信息肯定不止一条 git stash apply：恢复修改，但是这只是恢复stash的内容并不会删除，这里建议使用git stash pop 既恢复了又删除了stash中内容，注意这里只能恢复一条数据，此时使用git status查看状态，可以看到已经出现修改的内容了 git stash list ：此时查看当前stash中的内容可以看到已经什么都没了，当然这只是清除一条，如果本来有多个，那么还是会有其他内容的 常用命令 git stash 将当前的分支上的工作暂存到stash中 git stash list 列出stash中的所有暂存的内容 git stash pop 恢复并且删除stash中的内容 git stash apply 恢复但是步删除stash中的内容 远程仓库的操作常用的命令 git remote -v 查看远程仓库的详细信息 git remote add remote-name URL 添加远程仓库 git remote rename origin pb 将远程仓库的origin改为pb，此时使用git remote 查看可以知道这里已经没有origin了，变成了pb git remote rm origin 将远程仓库origin删除 git push origin master 将内容提交到远程仓库origin的master上，当然这里亦可以使用其他的分支 git clone URL 克隆一个远程仓库，这里的URL是远程仓库的地址 git pull origin 将远程仓库中更新的数据拉到本地 git checkout -b branch-name origin/branch-name 在本地创建和远程仓库对应的分支，最好分支的名字相同 git push origin branch-name 推送到远程仓库的分支 注意 同一个文件夹中可以添加很多远程仓库，不过可以在提交的时候需要指定远程仓库的名字，比如在你的文件夹下有origin和pb两个远程仓库，可以使用git remote -v查看详细的信息，此时你在版本库中已经有想要推送的文件了，那么使用git push origin master就可以指定推送到origin远程仓库中 实例 假如你新建一个文件夹，此时要在里面添加远程仓库，具体实现如下： git clone URL 将一个仓库克隆来的同时也具有推送的权限了，这时就可以使用git remote add origin URL来添加远程仓库了 如果没有使用clone的方法创建一个版本库，那么先git init 然后git remote add origin URL 添加远程仓库，之后就是将本地仓库和远程仓库对应了，使用git pull origin master 来拉取远程仓库中内容，当然这也可以分两步，使用如下： git fetch origin master 这是将远程仓库中的文件拉取到本地，但是没有与本地的master合并，因此本地的master分支不能追踪远程仓库中的分支 git merge origin/master 将远程仓库和本地的master分支合并，那么就可以使用本地的master分支追踪远程仓库了，这就完成了 无论clone还是pull都只是拉取远程的master分支，但是一般远程仓库中还有其他的分支，那么怎么办呢？拉取远程仓库的次分支步骤如下： git checkout -b dev origin/dev 拉去远程仓库中的dev仓库到本地的dev分支]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[scrapy爬取淘宝女郎]]></title>
      <url>%2F2017%2F05%2F07%2Fscrapy%E7%88%AC%E5%8F%96%E6%B7%98%E5%AE%9D%E5%A5%B3%E9%83%8E%2F</url>
      <content type="text"><![CDATA[scrapy抓取淘宝女郎准备工作 首先在淘宝女郎的首页这里查看，当然想要爬取更多的话，当然这里要查看翻页的url,不过这操蛋的地方就是这里的翻页是使用javascript加载的，这个就有点尴尬了，找了好久没有找到，这里如果有朋友知道怎样翻页的话，麻烦告诉我一声，谢谢了…，不过就这样坐以待毙了吗，所以就在chrome上搜，结果看到有人直接使用的这个网页,我当时一看感觉神奇的样子，这就是简化版的首页啊，只需要改变page的数字就可以实现遍历了，不过还是有点小失落，为什么人家就能找到呢，这个我还是希望知道的朋友能够分享一下，我也会查看相关的资料，把这个空缺不上的，好了，现在开我们的工作了 我们的目的是抓取册以及相关的信息，所以我们需要随便打开一个淘女郎的相册页面，然后随便进入一个相册即可，很显然这里的相册是异步加载的，因此我们需要抓包，这里我抓到了含有相册的url以及相关信息的json数据，如下图： 然后我们查看它的url为https://mm.taobao.com/album/json/get_album_photo_list.htmuser_id=687471686&amp;album_id=10000702574&amp;top_pic_id=0&amp;cover=%2F%2Fimg.alicdn.com%2Fimgextra%2Fi2%2F687471686%2FTB1TlwDLFXXXXbxaXXXXXXXXXXX_!!2tstar.png&amp;page=1&amp;_ksTS=1494097545509_154&amp;callback=jsonp15 通过我尝试之后这条url可以简化为: https://mm.taobao.com/album/json/get_album_photo_list.htm?user_id={0}&amp;album_id={1}&amp;top_pic_id=0&amp;page={2}&amp;_ksTS=1493654931946_405 其中user_id是每一个女郎对的id,ablum_id时每一个相册的id,这里一个女郎有多个相册，因此这个id是不同的，但是page就是要翻页的作用了,可以看到我去掉了callback=json155这一项，因为如果加上这一项，返回的数据就不是json类型的数据，其中page是在抓包的时候点击翻页才会在下面出现的，可以看到同一个相册返回的除了page不同之外，其他的都是相同的，因此这里通过page来实现翻页的数据 上面分析了每一个相册的url数据的由来，可以看到我们下面需要找到user_id,ablum_id这两个数据. user_id的获取：我们打开首页,然后打开chrome的调试工具，可以看到每一个 女郎的url中都包含user_id这一项，因此我们只需要通过这个实现翻页然后获取每一个女郎的url,之后用正则将user_id匹配出来即可,代码如下 123456ps=response.xpath('//p[@class="top"]') for p in ps: item=JrtItem() href=p.xpath('a/@href').extract() #这个得到的是一个数组url if href: item['user_id']=self.pattern_user_id.findall(href[0])[0] #用则正匹配出user_id,其中的正则为 pattern_user_id=re.compile(r'user_id=(\d+)') ablum_id的获取：想要获取ablum_id当然要在相册的页面查找，于是我们在相册页面抓包获得了如下图的页面 通过上图我们清晰的知道每一个相册的里面包含多少相册，但最令人开心的是在这个页面中不是动态加载，因此我们可以查看它的源码，当我们查看源码的时候，我们可以看到和user_id一样，这里的ablum_id包含在了href中，因此我们只需要找到每一张相册的url，然后用正则匹配处来即可，其中这个页面的url简化为: https://mm.taobao.com/self/album/open_album_list.htm?_charset=utf-8&amp;user_id%20={0}&amp;page={1} 所以我们可以通过上面得到的user_id构成请求即可,代码如下： 12345678910## 解析得到ablum_id，根据ablum_id解析请求出每一个相册的json数据 def parse_ablum_id(self,response): if response.status==200: print response.url item = response.meta['item'] soup = BeautifulSoup(response.text, 'lxml') divs = soup.find_all('div', class_='mm-photo-cell-middle') for div in divs: href = div.find('h4').find('a').get('href') items = self.pattern_ablum_id.findall(href) #这里就得到了ablum_id 上面已经获得了user_id和ablum_id，那么现在就可以请求每一个相册的json数据了，这个就不用多说了，详情请看源代码 MongoDB存储安装方式 Windows下安装请看我的MogoDB干货篇 ubantu直接用sudo apt-get install安装即可 安装对应python的包：pip install pymongo 安装完成以后就可以连接了，下面贴出我的连接代码 1234567891011121314from pymongo import MongoClientclass MongoDBPipelines(object): collection_name = 'taobao' def open_spider(self,spider): self.client = MongoClient('localhost', 27017) #连接，这里的27017是默认的额端口号 self.db = self.client['python'] #python是自己的数据库，当然这里不用提前建好也可以 def close_spider(self, spider): self.client.close() def process_item(self,item,spider): self.db[self.collection_name].update(&#123;'picId':item['picId']&#125;, &#123;'$set': dict(item)&#125;, True) return item 现在这就算好了，当然这里还有很多东西需要优化的，像代理池。。。最后本人想在暑期找一个地方实习，但是一直没有好的地方，希望有实习的地方推荐的可以联系我，在这里先谢谢了 推荐 最后推荐博主的一些源码 scrapy爬取妹子网站实现图片的存储，这个只是一个演示怎样存储图片的实例，因此不想过多的投入时间去爬，因此写的不是很详细 scrapy爬取知乎用户的详细信息]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MongoDB干货篇之更新数据]]></title>
      <url>%2F2017%2F05%2F01%2FMongoDB%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B9%8B%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%2F</url>
      <content type="text"><![CDATA[MongoDB干货篇之数据更新常用的函数 update(&lt;query&gt;,&lt;update&gt;,&lt;upsert&gt;,&lt;multi&gt;),其中&lt;query&gt;表示筛选的条件，&lt;update&gt;是要更新的数据 updateMany() 更新所有匹配到的数据 upsert upsert是一个布尔类型的数据，如果为true时，当根据query条件没有找到匹配的数据时，就表示插入此条数据，如果为false就表示不插入数据 下面将会在一个空的集合中更新数据1234567//就会插入此条数据，因为没有找到匹配的信息db.user.update(&#123;'name':'chenjiabing','age':22,'sex':"Man"&#125;,&#123;$set:&#123;'hobby':'read'&#125;&#125;,&#123;'upsert':true&#125;); db.user.update(&#123;'name':'chenjiabing','age':22,'sex':"Man"&#125;,&#123;$set:&#123;'hobby':'read'&#125;&#125;,true); //和上面的语句等价//输出 db.user.find()&#123; "_id" : ObjectId("59067b70856d5893a687655f"), "age" : 22, "name" : "chenjiabing", "sex" : "Man", "hobby" : "read" &#125; multi 如果这个参数为true,就把按条件查出来多条记录全部更新。默认为false,如果为true的话和updateMany()一样的效果 下面将会更新所有匹配到的数据 1db.user.update(&#123;name:'chenjiabing'&#125;,&#123;$set:&#123;'hobby':'code'&#125;&#125;,&#123;'multi':true&#125;); 字段更新操作符 Field Update Operators$set $set用来指定一个键的值。如果这个键不存在，则创建它。注意这里的更新默认是只更新第一条匹配到的数据，如果第一条匹配的数据已经满足修改后的条件，那么将不会执行下面匹配的信息 下面我们将会添加一条信息在数据库中 1db.user.insert(&#123;"name":'jack',"age":22,"sex":'Man','school':&#123;'name':'jsnu','city':'xuzhou'&#125;&#125;); 运行下面的代码，将该用户的兴趣设置为“读书”并添加至文档中(此时文档中hobby键是不存在，该条文档就会创建它) 1db.user.update(&#123;name:'jack'&#125;,&#123;$set:&#123;'hobby':'read'&#125;&#125;) 下面将会修改用户的年龄 1db.user.update(&#123;'name':'jack'&#125;,&#123;$set:&#123;'age':20&#125;&#125;) 下面用$set修改数据类型，将sex设置为1 1db.user.update(&#123;'name':'jack'&#125;,&#123;$set:&#123;'sex':1&#125;&#125;) 下面用$set修改内嵌文档，必须指定文档的名字和键值 1db.user.update(&#123;name:'jack'&#125;,&#123;$set:&#123;'school.name':'shida','school.city':'beijing'&#125;&#125;) $unset 从文档中移除指定的键 下面将要删除上面插入的hobby键 1db.user.update(&#123;name:'jack'&#125;,&#123;$unset:&#123;'hobby':1&#125;&#125;) //这里的值是任意给的，随便什么值 $inc $inc修改器用来增加已有键的值，或者在键不存在时创建一个键$inc就是专门来增加（和减少）数字的。$inc只能用于整数、长整数或双精度浮点数。要是用在其他类型的数据上就会导致操作失败 例如毎次有人访问该博文，该条博文的浏览数就加1，用键pageViews保存浏览数信息。这个键值上面没有定义过，所以会自动创建一个 1db.user.update(&#123;name:'jack'&#125;,&#123;$inc:&#123;'pageViews':1&#125;&#125;); //起初没有就会自动创建一个键 下面演示增加和减少 123db.user.update(&#123;name:'jack'&#125;,&#123;$inc:&#123;'pageViews':100&#125;&#125;) ; //这里是在上面的基础上加上100，此时变成了101db.user.update(&#123;name:'jack'&#125;,&#123;$inc:&#123;"pageViews":-100&#125;&#125;) ; //这里是在上面的基础上减去100,此时还是变成了1 $rename 语法：{$rename: { &lt;old name1&gt;: &lt;new name1&gt;, &lt;old name2&gt;: &lt;new name2&gt;, ... } } $rename操作符可以重命名字段名称，新的字段名称不能和文档中现有的字段名相同。 下面重新插入一条数据，并且改变这条数据的键的名称 123db.user.insert(&#123;name:'chenjiabing','age':22,'sex':'Man','school':&#123;'name':'jsnu','city':'beijing'&#125;&#125;);db.user.update(&#123;name:'chenjiabing'&#125;,&#123;$rename:&#123;'age':'Age'&#125;&#125;) //重命名age为Age 下面将要演示怎样改变内嵌文档的键的名称，注意一定要带上文档的名字 1db.user.update(&#123;name:'chenjiabing'&#125;,&#123;$rename:&#123;'school.name':'school.Name','school.city':'school.City'&#125;&#125;); 如果重命名的字段字和集合中原有的字段名字相同的话就会覆盖原有的字段名称，那么就会造成数据的丢失 1234567db.user.update(&#123;name:'chenjiabing'&#125;,&#123;'$rename':&#123;'sex','age'&#125;&#125;); //这里sex变成age和原来的age相同，那么原来的age就会丢失db.user.find(&#123;name:'chenjiabing'&#125;); //输出，可以看到原来的age没有了,变成了覆盖之后的&#123; "_id" : ObjectId("590674ce30b9f88dd43d7ee4"), "name" : "chenjiabing", "age" : "Man", "school" : &#123; "name" : "jsnu", "city" : "beijing" &#125; &#125; 如果指定的字段不存在，那么将不会更新，对原来的字段没有影响 1db.user.update(&#123;name:'chenjiabing'&#125;,&#123;$rename:&#123;value:'name'&#125;&#125;); //将不会有任何的改变，因为value这个字段根本不存在 $rename操作符也可以将子文档中键值移到其他子文档中 12345db.user.update(&#123;name:'chenjiabing'&#125;,&#123;$rename:&#123;'school.name':'contact.name'&#125;&#125;);// 这里将会将school.name这个字段的值移到contact.name之中，如果contact不存在，那么就会创建一个//输出&#123; "_id" : ObjectId("590674ce30b9f88dd43d7ee4"), "name" : "chenjiabing", "age" : "Man", "school" : &#123; "city" : "beijing" &#125;, "contact" : &#123; "name" : "jsnu" &#125; &#125; 数组更新操作符 Array Update Operators 只能用在键值为数组的键上的数组操作。 $ (query) 语法:{ &quot;&lt;array&gt;.$&quot; : value } 当对数组字段进行更新时，且没有明确指定的元素在数组中的位置，我们使用定位操作符$标识一个元素，数字都是以0开始的。 注意: 定位操作符(“$”)作为第一个匹配查询条件的元素的占位符，也就是在数组中的索引值。 数组字段必须出现查询文档中。 向集合中插入两条数据 12db.students.insert(&#123; "_id" : 1, "grades" : [ 78, 88, 88 ] &#125;);db.students.insert(&#123; "_id" : 2, "grades" : [ 88, 90, 92 ] &#125;); 执行下列操作 1234//查询匹配的文档中，数组有2个88，只更新第一个匹配的元素，也就是"grades.1"db.students.update( &#123; _id: 1, grades: 88 &#125;, &#123; $set: &#123; "grades.$" : 82 &#125; &#125;) ;//查询文档中没有出现grades字段，查询报错db.students.update( &#123; _id: 2 &#125;, &#123; $set: &#123; "grades.$" : 82 &#125; &#125; ); $push 如果指定的键已经存在，会向已有的数组末尾加入一个元素，要是没有就会创建一个新的数组。 下面我们将使用$push对该文档添加一条评论信息。 1234567//将会创建一个comments数组，因为一开始这个数组没有存在db.user.update(&#123;name:'chenjiabing'&#125;,&#123;$push:&#123;comments:&#123;'name':'jack','content':'hello thanks'&#125;&#125;&#125;)//继续添加一条，在comments的末尾进行添加，此时comments变成两条数据了db.user.update(&#123;name:'chenjiabing'&#125;,&#123;$push:&#123;comments:&#123;'name':'john','content':'hello'&#125;&#125;&#125;) $pull 语法：db.collection.update( { field: &lt;query&gt; }, { $pull: { field: &lt;query&gt; } } ); $pull操作符移除指定字段值为数组，且匹配$pull操作符移除指定字段值为数组，且匹配$pull语句声明的查询条件的所有元素。 执行如下操作 123456789101112//插入一条文档db.profiles.insert(&#123; votes: [ 3, 5, 6, 7, 7, 8 ] &#125;);//移除数组中所有元素7db.profiles.update( &#123; votes: 3 &#125;, &#123; $pull: &#123; votes: 7 &#125; &#125; );//移除数组中所有大于6的元素db.profiles.update( &#123; votes: 3 &#125;, &#123; $pull: &#123; votes: &#123; $gt: 6 &#125; &#125; &#125; );//Result&#123; votes: [ 3, 5, 6, 8 ] &#125;&#123; votes: [ 3, 5, 6 ] &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MongoDB干货篇之查询数据]]></title>
      <url>%2F2017%2F04%2F30%2FMongoDB%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B9%8B%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%2F</url>
      <content type="text"><![CDATA[MongoDB干货篇之查询准备工作 在开始之前我们应该先准备数据方便演示，这里我插入的了几条数据，数据如下：12345678910111213141516171819202122232425262728293031323334db.user.insertMany([&#123;name:'jack',age:22,sex:'Man',tags:['python','c++','c'],grades:[22,33,44,55],school:&#123;name:'shida',city:'xuzhou'&#125;&#125;,&#123;name:'jhon',age:33,sex:null,tags:['python','java'],grades:[66,22,44,88],school:&#123;name:'kuangda',city:'xuzhou'&#125;&#125;,&#123;name:'xiaoming',age:33,tags:['python','java'],grades:[66,22,44,88],school:&#123;name:'kuangda',city:'xuzhou'&#125;&#125;]) find() 其中query表示查找的条件，相当于mysql中where子句,projection列出你想要查找的数据，格式为db.collection.find(find(&lt;query filter&gt;, &lt;projection&gt;)) 实例： 下面不带参数的查找，将会查找出所有的结果 12345678910111213141516171819202122232425 db.find().pretty(); //输出结果 &#123; &quot;_id&quot; : ObjectId(&quot;59056f81299fe049404b2899&quot;), &quot;name&quot; : &quot;jack&quot;, &quot;age&quot; : 22, &quot;tags&quot; : [ &quot;python&quot;, &quot;c++&quot;, &quot;c&quot; ], &quot;grades&quot; : [ 22, 33, 44, 55 ], &quot;school&quot; : &#123; &quot;name&quot; : &quot;shida&quot;, &quot;city&quot; : &quot;xuzhou&quot; &#125; &#125; 下面找出满足name为jack的数据，并且只输出name,age,这里的_id是默认输出的，如果不想输出将将它设置为0，想要输出那个字段将它设置为1 12345678910db.user.find(&#123;name:'jack'&#125;,&#123;name:1,age:1&#125;)//输出结果&#123; "_id" : ObjectId("59056f81299fe049404b2899"), "name" : "jack", "age" : 22 &#125;db.user.find(&#123;name:'jack'&#125;,&#123;name:1,age:1，_id:0&#125;)//输出结果&#123;"name" : "jack", "age" : 22 &#125; **注意这里的一个 projection不能 同时 指定包括和排除字段，除了排除 _id字段。 在 显式包括 字段的映射中，_id 字段是唯一一个您可以 显式排除 的。 查询内嵌文档 上述例子中插入的school数据就表示内嵌文档 完全匹配查询 完全匹配查询表示school中的查询数组必须和插入的数组完全一样，顺序都必须一样才能查找出来 1234567891011db.user.find(&#123;name:'jack',school:&#123;name:'shida',city:'xuzhou'&#125;&#125;);//输出结果&#123; "_id" : ObjectId("59056f81299fe049404b2899"), "name" : "jack", "age" : 22, "tags" : [ "python", "c++", "c" ], "grades" : [ 22, 33, 44, 55 ], "school" : &#123; "name" : "shida", "city" : "xuzhou" &#125; &#125;//下面是指定输出的字段，这里的school.name表示只输出school文档中name字段，必须加引号db.user.find(&#123;name:'jack',school:&#123;name:'shida',city:'xuzhou'&#125;&#125;,&#123;name:1,age:1,'school.name':1&#125;);//输出结果&#123; "_id" : ObjectId("59056f81299fe049404b2899"), "name" : "jack", "age" : 22, "school" : &#123; "name" : "shida" &#125; &#125; 键值对查询 可以通过键值对查询，不用考虑顺序，比如&#39;school.name&#39;:&#39;shida&#39;，表示查询学校名字为shida的数据，这里的引号是必须要的 12345db.user.find(&#123;'school.name':'shida'&#125;,&#123;name:1,school:1&#125;);//输出结果&#123; "_id" : ObjectId("59056f81299fe049404b2899"), "name" : "jack", "school" : &#123; "name" : "shida", "city" : "xuzhou" &#125; &#125; 查询操作符 下面我们将配合查询操作符来执行复杂的查询操作，比如元素查询、 逻辑查询 、比较查询操作。我们使用下面的比较操作符&quot;$gt&quot; 、&quot;$gte&quot;、 &quot;$lt&quot;、 &quot;$lte&quot;(分别对应&quot;&gt;&quot;、 &quot;&gt;=&quot; 、&quot;&lt;&quot; 、&quot;&lt;=&quot;) 实例 下面查询年龄在20-30之间的信息 123456db.user.find(&#123;age:&#123;$gt:20,$lt:30&#125; &#125;)//输出&#123; "_id" : ObjectId("59056f81299fe049404b2899"), "name" : "jack", "age" : 22, "tags" : [ "python", "c++", "c" ], "grades" : [ 22, 33, 44, 55 ], "school" : &#123; "name" : "shida", "city" : "xuzhou" &#125; &#125; $ne $ne表示不相等，例如查询年龄不等于22岁的信息 1234db.user.find(&#123;age:&#123;$ne:22&#125;&#125;)//输出&#123; "_id" : ObjectId("59057c16f551d8c9003d31e0"), "name" : "jhon", "age" : 33, "tags" : [ "python", "java" ], "grades" : [ 66, 22, 44, 88 ], "school" : &#123; "name" : "kuangda", "city" : "xuzhou" &#125; &#125; slice $slice操作符控制查询返回的数组中元素的个数。此操作符根据参数{ field: value } 指定键名和键值选择出文档集合，并且该文档集合中指定array键将返回从指定数量的元素。如果count的值大于数组中元素的数量，该查询返回数组中的所有元素的。 语法：db.collection.find( { field: value }, { array: {$slice: count }}); 下面将查询grades中的前两个数 12345db.user.find(&#123;name:'jack'&#125;,&#123;grades:&#123;$slice:2&#125;,name:1,age:1,'school.name':1&#125;);//输出，可以看出这里的grades只输出了前面两个&#123; "_id" : ObjectId("59057c16f551d8c9003d31df"), "name" : "jack", "age" : 22, "grades" : [ 22, 33 ], "school" : &#123; "name" : "shida" &#125; &#125; 下面将输出后3个数据 1234db.user.find(&#123;name:'jhon'&#125;,&#123;grades:&#123;$slice:-3&#125;,name:1&#125;);//输出&#123; "_id" : ObjectId("59057c16f551d8c9003d31e0"), "name" : "jhon", "grades" : [ 22, 44, 88 ] &#125; 下面介绍指定一个数组作为参数。数组参数使用[ skip , limit ] 格式，其中第一个值表示在数组中跳过的项目数,第二个值表示返回的项目数。 123456db.user.find(&#123;name:'jack'&#125;,&#123;grades:&#123;$slice:[2,2]&#125;,name:1&#125;); //这里将会跳过前面的两个，直接得到后面的两个数据//输出&#123; "_id" : ObjectId("59057c16f551d8c9003d31df"), "name" : "jack", "grades" : [ 44, 55 ] &#125; $exists 如果$exists的值为true,选择存在该字段的文档,若值为false则选择不包含该字段的文档 下面将会查询不存在sex这一项的信息 1234567891011db.user.find(&#123;sex:&#123;$exists:false&#125;&#125;)//结果&#123; "_id" : ObjectId("59058460fe58ed1089f2a5cd"), "name" : "xiaoming", "age" : 33, "tags" : [ "python", "java" ], "grades" : [ 66, 22, 44, 88 ], "school" : &#123; "name" : "kuangda", "city" : "xuzhou" &#125; &#125;db.user.find(&#123;sex:&#123;$exists:true&#125;&#125;);//结果&#123; "_id" : ObjectId("59058460fe58ed1089f2a5cb"), "name" : "jack", "age" : 22, "sex" : "Man", "tags" : [ "python", "c++", "c" ], "grades" : [ 22, 33, 44, 55 ], "school" : &#123; "name" : "shida", "city" : "xuzhou" &#125; &#125;&#123; "_id" : ObjectId("59058460fe58ed1089f2a5cc"), "name" : "jhon", "age" : 33, "sex" : null, "tags" : [ "python", "java" ], "grades" : [ 66, 22, 44, 88 ], "school" : &#123; "name" : "kuangda", "city" : "xuzhou" &#125; &#125; $or 执行逻辑OR运算,指定一个至少包含两个表达式的数组，选择出至少满足数组中一条表达式的文档。语法：{ $or: [ { &lt;expression1&gt; }, { &lt;expression2&gt; }, ... , { &lt;expressionN&gt; } ] } 下面将要查找age等于22或者age等于33的值 1234567db.user.find(&#123;$or:[&#123;age:22&#125;,&#123;age:33&#125;]&#125;)//结果&#123; "_id" : ObjectId("59058460fe58ed1089f2a5cb"), "name" : "jack", "age" : 22, "sex" : "Man", "tags" : [ "python", "c++", "c" ], "grades" : [ 22, 33, 44, 55 ], "school" : &#123; "name" : "shida", "city" : "xuzhou" &#125; &#125;&#123; "_id" : ObjectId("59058460fe58ed1089f2a5cc"), "name" : "jhon", "age" : 33, "sex" : null, "tags" : [ "python", "java" ], "grades" : [ 66, 22, 44, 88 ], "school" : &#123; "name" : "kuangda", "city" : "xuzhou" &#125; &#125;&#123; "_id" : ObjectId("59058460fe58ed1089f2a5cd"), "name" : "xiaoming", "age" : 33, "tags" : [ "python", "java" ], "grades" : [ 66, 22, 44, 88 ], "school" : &#123; "name" : "kuangda", "city" : "xuzhou" &#125; &#125; 下面将会查找出年龄为22或者33并且姓名为jack的人的信息 12345db.user.find(&#123;name:'jack',$or:[&#123;age:33&#125;,&#123;age:22&#125;]&#125;)//结果&#123; "_id" : ObjectId("59058460fe58ed1089f2a5cb"), "name" : "jack", "age" : 22, "sex" : "Man", "tags" : [ "python", "c++", "c" ], "grades" : [ 22, 33, 44, 55 ], "school" : &#123; "name" : "shida", "city" : "xuzhou" &#125; &#125; $and 指定一个至少包含两个表达式的数组，选择出满足该数组中所有表达式的文档。$and操作符使用短路操作，若第一个表达式的值为“false”,余下的表达式将不会执行。语法：{ $and: [ { &lt;expression1&gt; }, { &lt;expression2&gt; } , ... , { &lt;expressionN&gt; } ] } 下面将会查找年龄在20-30之间的信息，对于下面使用逗号分隔符的表达式列表，MongoDB会提供一个隐式的$and操作： 12345db.user.find(&#123;$and:[&#123;age:&#123;$gt:20&#125;&#125;,&#123;age:&#123;$lt:30&#125;&#125;]&#125;)//上述语句相当于db.user.find(&#123;age:&#123;$gt:20&#125;,age:&#123;$lt:30&#125;&#125;)//结果&#123; "_id" : ObjectId("59058460fe58ed1089f2a5cb"), "name" : "jack", "age" : 22, "sex" : "Man", "tags" : [ "python", "c++", "c" ], "grades" : [ 22, 33, 44, 55 ], "school" : &#123; "name" : "shida", "city" : "xuzhou" &#125; &#125; $in 匹配键值等于指定数组中任意值的文档。类似sql中in，只要匹配一个value就会输出语法：{ field: { $in: [&lt;value1&gt;, &lt;value2&gt;, ... &lt;valueN&gt; ] } } 下面将会查找grades中存在22,33之间的任意一个数的信息 1234567 db.user.find(&#123;grades:&#123;$in:[22,33]&#125;&#125;) //输出 &#123; "_id" : ObjectId("59058460fe58ed1089f2a5cb"), "name" : "jack", "age" : 22, "sex" : "Man", "tags" : [ "python", "c++", "c" ], "grades" : [ 22, 33, 44, 55 ], "school" : &#123; "name" : "shida", "city" : "xuzhou" &#125; &#125;&#123; "_id" : ObjectId("59058460fe58ed1089f2a5cc"), "name" : "jhon", "age" : 33, "sex" : null, "tags" : [ "python", "java" ], "grades" : [ 66, 22, 44, 88 ], "school" : &#123; "name" : "kuangda", "city" : "xuzhou" &#125; &#125;&#123; "_id" : ObjectId("59058460fe58ed1089f2a5cd"), "name" : "xiaoming", "age" : 33, "tags" : [ "python", "java" ], "grades" : [ 66, 22, 44, 88 ], "school" : &#123; "name" : "kuangda", "city" : "xuzhou" &#125; &#125; $nin 匹配键不存在或者键值不等于指定数组的任意值的文档。类似sql中not in(SQL中字段不存在使用会有语法错误). 查询出grades中不存在100或者44的文档 1db.user.find(&#123;grades:&#123;$nin:[100,44]&#125;&#125;) $not 执行逻辑NOT运算，选择出不能匹配表达式的文档 ，包括没有指定键的文档。$not操作符不能独立使用，必须跟其他操作一起使用 语法:{ field: { $not: { } } } 查询年龄不大于30的信息 1234db.user.find(&#123;age:&#123;$not:&#123;$gt:30&#125;&#125;&#125;)//输出&#123; "_id" : ObjectId("59058460fe58ed1089f2a5cb"), "name" : "jack", "age" : 22, "sex" : "Man", "tags" : [ "python", "c++", "c" ], "grades" : [ 22, 33, 44, 55 ], "school" : &#123; "name" : "shida", "city" : "xuzhou" &#125; &#125; 迭代游标的查询 学过高级语言的朋友都知道迭代的问题，像java,下面使用迭代的方法查询 1234567891011121314151617var cursor=db.usr.find();//这里使用迭代输出所有的数据while(cursor.hasNext()) //这里的hasNext()是判断是否下一个中还有可迭代的值，如果没有返回false&#123; printjson(cursor.next()); //这里的cursor.next是迭代的输出，printjson是代替print(tojson()) &#125;print cursor.count() //输出其中有多少个数据cursor.forEach(printjson); //forEach输出var document=cursor.toArray(); //将迭代对象转换成数组print document[0]; //以数组的形式输出]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python爬虫之BeautifulSoup]]></title>
      <url>%2F2017%2F04%2F29%2Fpython%E7%88%AC%E8%99%AB%E4%B9%8BBeautifulSoup%2F</url>
      <content type="text"><![CDATA[python爬虫之BeautifulSoup简介 Beautiful Soup提供一些简单的、python式的函数用来处理导航、搜索、修改分析树等功能。它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完整的应用程序。Beautiful Soup自动将输入文档转换为Unicode编码，输出文档转换为utf-8编码。你不需要考虑编码方式，除非文档没有指定一个编码方式，这时，Beautiful Soup就不能自动识别编码方式了。然后，你仅仅需要说明一下原始编码方式就可以了。Beautiful Soup已成为和lxml、html6lib一样出色的python解释器，为用户灵活地提供不同的解析策略或强劲的速度。 安装 pip install BeautifulSoup4 easy_install BeautifulSoup4 创建BeautifulSoup对象 首先应该导入BeautifulSoup类库 from bs4 import BeautifulSoup 下面开始创建对像，在开始之前为了方便演示，先创建一个html文本，如下： 1234567891011html = """&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class="title" name="dromouse"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and&lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class="story"&gt;...&lt;/p&gt;""" 创建对象：soup=BeautifulSoup(html,&#39;lxml&#39;),这里的lxml是解析的类库，目前来说个人觉得最好的解析器了，一直在用这个，安装方法：pip install lxml Tag Tag就是html中的一个标签，用BeautifulSoup就能解析出来Tag的具体内容，具体的格式为soup.name,其中name是html下的标签，具体实例如下： print soup.title输出title标签下的内容，包括此标签，这个将会输出&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt; print soup.head 注意： 这里的格式只能获取这些标签的第一个，后面会讲到获取多个标签的方法。其中对于Tag有两个重要的属性name和attrs,分别表示名字和属性,介绍如下： name:对于Tag，它的name就是其本身，如soup.p.name就是p attrs是一个字典类型的，对应的是属性-值，如print soup.p.attrs,输出的就是{&#39;class&#39;: [&#39;title&#39;], &#39;name&#39;: &#39;dromouse&#39;},当然你也可以得到具体的值，如print soup.p.attrs[&#39;class&#39;],输出的就是[title]是一个列表的类型，因为一个属性可能对应多个值,当然你也可以通过get方法得到属性的，如：print soup.p.get(&#39;class&#39;)。还可以直接使用print soup.p[&#39;class&#39;] get get方法用于得到标签下的属性值，注意这是一个重要的方法，在许多场合都能用到，比如你要得到&lt;img src=&quot;#&quot;&gt;标签下的图像url,那么就可以用soup.img.get(&#39;src&#39;),具体解析如下： 1print soup.p.get("class") #得到第一个p标签下的src属性 string 得到标签下的文本内容，只有在此标签下没有子标签，或者只有一个子标签的情况下才能返回其中的内容，否则返回的是None具体实例如下： 123print soup.p.string #在上面的一段文本中p标签没有子标签，因此能够正确返回文本的内容print soup.html.string #这里得到的就是None,因为这里的html中有很多的子标签 get_text() 可以获得一个标签中的所有文本内容，包括子孙节点的内容，这是最常用的方法 搜索文档树find_all( name , attrs , recursive , text , **kwargs ) find_all是用于搜索节点中所有符合过滤条件的节点 1.name参数：是Tag的名字，如p,div,title ….. soup.find_all(&quot;p&quot;) 查找所有的p标签，返回的是[&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;]，可以通过遍历获取每一个节点，如下： 123ps=soup.find_all("p")for p in ps: print p.get('class') #得到p标签下的class属性 传入正则表达式：soup.find_all(re.compile(r&#39;^b&#39;)查找以b开头的所有标签，这里的body和b标签都会被查到 传入类列表：如果传入列表参数,BeautifulSoup会将与列表中任一元素匹配的内容返回.下面代码找到文档中所有&lt;a&gt;标签和&lt;b&gt;标签 1soup.find_all(["a", "b"]) 2.KeyWords参数，就是传入属性和对应的属性值，或者一些其他的表达式 soup.find_all(id=&#39;link2&#39;),这个将会搜索找到所有的id属性为link2的标签。传入正则表达式soup.find_all(href=re.compile(&quot;elsie&quot;)),这个将会查找所有href属性满足正则表达式的标签 传入多个值：soup.find_all(id=&#39;link2&#39;,class_=&#39;title&#39;) ,这个将会查找到同时满足这两个属性的标签，这里的class必须用class_传入参数，因为class是python中的关键词 有些属性不能通过以上方法直接搜索，比如html5中的data-*属性，不过可以通过attrs参数指定一个字典参数来搜索包含特殊属性的标签，如下： 1234# [&lt;div data-foo="value"&gt;foo!&lt;/div&gt;]data_soup.find_all(attrs=&#123;"data-foo": "value"&#125;) #注意这里的atts不仅能够搜索特殊属性，亦可以搜索普通属性soup.find_all("p",attrs=&#123;'class':'title','id':'value'&#125;) #相当与soup.find_all('p',class_='title',id='value') 3.text参数：通过 text 参数可以搜搜文档中的字符串内容.与 name 参数的可选值一样, text 参数接受 字符串 , 正则表达式 , 列表, True12345678soup.find_all(text="Elsie")# [u'Elsie'] soup.find_all(text=["Tillie", "Elsie", "Lacie"])# [u'Elsie', u'Lacie', u'Tillie'] soup.find_all(text=re.compile("Dormouse"))[u"The Dormouse's story", u"The Dormouse's story"] 4.limit参数：find_all() 方法返回全部的搜索结构,如果文档树很大那么搜索会很慢.如果我们不需要全部结果,可以使用 limit 参数限制返回结果的数量.效果与SQL中的limit关键字类似,当搜索到的结果数量达到 limit 的限制时,就停止搜索返回结果. 文档树中有3个tag符合搜索条件,但结果只返回了2个,因为我们限制了返回数量,代码如下： 123soup.find_all("a", limit=2)# [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,# &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;] 5.recursive 参数:调用tag的 find_all() 方法时,BeautifulSoup会检索当前tag的所有子孙节点,如果只想搜索tag的直接子节点,可以使用参数 recursive=False find( name , attrs , recursive , text , **kwargs ) 它与 find_all() 方法唯一的区别是 find_all() 方法的返回结果是值包含一个元素的列表,而 find() 方法直接返回结果,就是直接返回第一匹配到的元素，不是列表，不用遍历，如soup.find(&quot;p&quot;).get(&quot;class&quot;) css选择器 我们在写 CSS 时，标签名不加任何修饰，类名前加点，id名前加#，在这里我们也可以利用类似的方法来筛选元素，用到的方法是 soup.select()，返回类型是 list 通过标签名查找123456print soup.select('title') #[&lt;title&gt;The Dormouse's story&lt;/title&gt;]print soup.select('a')#[&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;, &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;, &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;] 通过类名查找12print soup.select('.sister')#[&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;, &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;, &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;] 通过id名查找12print soup.select('#link1')#[&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;] 组合查找 学过css的都知道css选择器，如p #link1是查找p标签下的id属性为link1的标签 12345print soup.select('p #link1') #查找p标签中内容为id属性为link1的标签#[&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;]print soup.select("head &gt; title") #直接查找子标签#[&lt;title&gt;The Dormouse's story&lt;/title&gt;] 属性查找 查找时还可以加入属性元素，属性需要用中括号括起来，注意属性和标签属于同一节点，所以中间不能加空格，否则会无法匹配到。 123456print soup.select('a[class="sister"]')#[&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;, &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;, &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]print soup.select('a[href="http://example.com/elsie"]')#[&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;] 同样，属性仍然可以与上述查找方式组合，不在同一节点的空格隔开，同一节点的不加空格,代码如下： 12print soup.select('p a[href="http://example.com/elsie"]')#[&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;] 以上的 select 方法返回的结果都是列表形式，可以遍历形式输出，然后用 get_text() 方法来获取它的内容 1234567soup = BeautifulSoup(html, 'lxml')print type(soup.select('title'))print soup.select('title')[0].get_text()for title in soup.select('title'): print title.get_text() 修改文档树 Beautiful Soup的强项是文档树的搜索,但同时也可以方便的修改文档树,这个虽说对于一些其他的爬虫并不适用，因为他们都是爬文章的内容的，并不需要网页的源码并且修改它们，但是在我后续更新的文章中有用python制作pdf电子书的,这个就需要用到修改文档树的功能了，详情请见本人博客 修改tag的名称和属性1234567html="""&lt;p&gt;&lt;a href='#'&gt;修改文档树&lt;/a&gt;&lt;/p&gt;"""soup=BeautifulSoup(html,'lxml')tag=soup.a #得到标签a，可以使用print tag.name输出标签tag['class']='content' #修改标签a的属性class和divtag['div']='nav' 修改.string 注意这里如果标签的中还嵌套了子孙标签，那么如果直接使用string这个属性会将这里的所有的子孙标签都覆盖掉 1234567891011html="""&lt;p&gt;&lt;a href='#'&gt;修改文档树&lt;/a&gt;&lt;/p&gt;"""soup=BeautifulSoup(html,'lxml')tag=soup.atag.string='陈加兵的博客' #这里会将修改文档树变成修改的内容print tagsoup.p.string='陈加兵的博客' #这里修改了p标签的内容，那么就会覆盖掉a标签，直接变成的修改后的文本print soup append append的方法的作用是在在原本标签文本后面附加文本，就像python中列表的append方法 12345678html="""&lt;p&gt;&lt;a href='#'&gt;修改文档树&lt;/a&gt;&lt;/p&gt;"""soup=BeautifulSoup(html,'lxml')soup.a.append("陈加兵的博客") #在a标签和面添加文本，这里的文本内容将会变成修改文档树陈加兵的博客print soupprint soup.a.contents #这里输出a标签的内容，这里的必定是一个带有两个元素的列表 注意这里的append方法也可以将一个新的标签插入到文本的后面，下面将会讲到 new_tag 相信学过js的朋友都知道怎样创建一个新的标签，这里的方法和js中的大同小异，使用的new_tag 1234567891011html="""&lt;p&gt;&lt;p&gt;"""soup=BeautifulSoup(html,'lxml')tag=soup.pnew_tag=soup.new_tag('a') #创建一个新的标签anew_tag['href']='#' #添加属性new_tag.string='陈加兵的博客' #添加文本print new_tag tag.append(new_tag) #将新添加的标签写入到p标签中print tag insert Tag.insert() 方法与 Tag.append() 方法类似,区别是不会把新元素添加到父节点 .contents 属性的最后,而是把元素插入到指定的位置.与Python列表总的 .insert() 方法的用法下同: 1234567891011html="""&lt;p&gt;&lt;p&gt;"""soup=BeautifulSoup(html,'lxml')tag=soup.pnew_tag=soup.new_tag('a')new_tag['href']='#'new_tag.string='陈加兵的博客'tag.append("欢迎来到") #这里向p标签中插入文本，这个文本在contents下的序号为0tag.insert(1,new_tag) #在contents序号为1的位置插入新的标签，如果这里修改成0，那么将会出现a标签将会出现在欢饮来到的前面print tag 注意这的1是标签的内容在contents中的序号，可以用print tag.contents查看当前的内容 insert_before() 和 insert_after() insert_before() 方法在当前tag或文本节点前插入内容,insert_after() 方法在当前tag或文本节点后插入内容: 12345678910111213soup = BeautifulSoup("&lt;b&gt;stop&lt;/b&gt;")tag = soup.new_tag("i")tag.string = "Don't"soup.b.string.insert_before(tag)soup.b# &lt;b&gt;&lt;i&gt;Don't&lt;/i&gt;stop&lt;/b&gt;soup.b.i.insert_after(soup.new_string(" ever "))soup.b# &lt;b&gt;&lt;i&gt;Don't&lt;/i&gt; ever stop&lt;/b&gt;soup.b.contents# [&lt;i&gt;Don't&lt;/i&gt;, u' ever ', u'stop'] clear clear用来移除当前节点的所有的内容，包括其中的子孙节点和文本内容 123456789101112html="""&lt;p&gt;&lt;p&gt;"""soup=BeautifulSoup(html,'lxml')tag=soup.pnew_tag=soup.new_tag('a')new_tag['href']='#'new_tag.string='陈加兵的博客'tag.append("欢迎来到")tag.insert(1,new_tag)tag.clear() #这里将会移除所有内容print tag 参考文章 中文文档http://beautifulsoup.readthedocs.io/zh_CN/latest/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MongoDB干货篇之安装]]></title>
      <url>%2F2017%2F04%2F28%2FMongoDB%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B9%8B%E5%AE%89%E8%A3%85%2F</url>
      <content type="text"><![CDATA[MongoDB干货篇之安装安装 下载地址 点击安装,选择自定义，后选择安装路径，不过最好安装在根目录下(C盘)，然后点解next,这里我安装的路径是C:\MongoDB 创建文件夹:在C:\MongoDB下创建一个文件夹data,然后在data文件夹下创建db,log两个子文件夹,在log文件下创建一个MongoDB.log文档，总得来说创建了C:\MongoDB\data,C:\MongoDB\data\db,C:\MongoDB\data\log,C:\MongoDB\data\log\MongoDB.log 在C:\MongoDB\bin文件夹下运行cmd.exe进入dos命令，执行以下命令： 然后在cmd下输入mongod -dbpath &quot;C:\MongoDB\data\db,将会看到一些信息，说明已经安装成功了 测试连接 在C:\MongoDB\bin文件夹下运行cmd.exe,输入mongo或者mongo.exe,将会出现连接的信息，说明已经连接成功了 然后在另外一个cmd.exe在bin目录下运行mongo可以看到已经连接上MongoDB了，注意上面打开的终端不能关闭，否则不能成功连接，这是比较麻烦的，需要每次连接都要启动，下面我们需要把它安装为windows服务 安装程windows服务注意在管理员的cmd.exe中运行以下命令，否则在MongoDB.log文件里出现遭到拒绝 运行cmd，进入bin目录，执行以下命令: mongod --dbpath &quot;C:\MongoDB\data\db&quot; --logpath &quot;D:\MongoDB\data\log\MongoDB.log&quot; --install --serviceName &quot;MongoDB&quot;,这里的服务名为MongoDB，可以在C:\MongoDB\data\log\MongoDB.log文件里查看相关信息，如果出现遭到拒绝就是没有在管理员的权限下执行命令 接下来就是启动服务了，现在在cmd.exe中运行NET START MongoDB，如果看到服务成功启动，那么就成功了，但是我在启动的时候出现48错误，下面将会做出解决方法： 先删除服务:mongod --dbpath &quot;C:\MongoDB\data\db&quot; --logpath &quot;C:\MongoDB\data\log\MongoDB.log&quot; --remove --serviceName &quot;MongoDB&quot; 删除MongoDB目录下的mongod.lock 然后就是重新安装了,执行以下命令： mongod --logpath &quot;C:\MongoDB\data\log\MongoDB.log&quot; --logappend --dbpath &quot;C:\Mongodb\data&quot; --directoryperdb --serviceName &quot;MongoDB&quot; --serviceDisplayName &quot;MongoDB&quot; --install 接下来重新启动服务，net start MongoDB,可以看到成功启动了 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JDBC干货篇一]]></title>
      <url>%2F2017%2F04%2F27%2FJDBC%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B8%80%2F</url>
      <content type="text"><![CDATA[JDBC干货篇一JDBC基础 JDBC的全称是Java Database Connectivity，即Java数据库连接，它是一种可以执行SQL语句的Java API。程序可通过JDBC API连接到关系数据库，并使用结构化查询语言（SQL，数据库标准的查询语言）来完成对数据库的查询、更新 与其他数据库编程环境相比，JDBC为数据库开发提供了标准的API，使用JDBC开发的数据库应用可以跨平台运行，而且还可以跨数据库（如果全部使用标准的SQL语句）。也就是说如果使用JDBC开发一个数据库应用，则该应用既可以在Windows操作系统上运行，又可以在Unix等其他操作系统上运行，既可以使用MySQL数据库，又可以使用Oracle等其他的数据库，应用程序不需要做任何的修改 加载数据库驱动 Class.forName(classDriver)其中classDriver就是数据库驱动类对应的字符串,下面给出加载mysql,oracle数据库的例子： 12Class.forName("com.mysql.jdbc.Driver"); //mysqlClass.forName("oracle.jabc.driver.OracleDriver"); //oracle 获取数据库连接获得数据库连接的方法为DriverManager.getConnection(),其中有不同的参数，也对应不同的方法，下面将会详细介绍 DriverManager.getConnection(String url) DriverManager.getConnection(String url, Properties prop) 这里的Properties是一个属性集，详情请看文档 DriverManager.getConnection(String url,String user,String password) 这里的url是jdbc:mysql://localhost:3306/java_demo，其中java_demo表示你自己创建的数据库名字，urser表示当前数据库的登录的用户名，password表示密码 12345678910111213//第二种方法String url="jdbc:mysql://localhost:3306/java_demo"; //这是连接的urlString user="root";String password="root"; Properties properties=new Properties(); //创建属性集properties.setProperty("password", password); //向起中添加属性,很想python中的字典properties.setProperty("user",user); Class.forName("com.mysql.jdbc.Driver"); //加载数据库驱动Connection conn=DriverManager.getConnection(url,properties); //连接数据库//第三种方法Connection conn=DriverManager.getConnection(url,user,password); //连接数据库 注意：以上只是一些例子，并不是完整的代码，其中并没有处理异常，还应该注意的是要关闭connection 查询数据 查询数据有两种方法，分别为静态查询和动态查询，静态查询使用的Statement，动态查询使用的PrepareStatement,下面详细介绍这两种查询方法 静态查询 使用的是Statement,其中常用的函数如下： boolean execute(String SQL) 如果ResultSet对象可以被检索，则返回的布尔值为true，否则返回 false 。当你需要使用真正的动态 SQL 时，可以使用这个方法来执行 SQL DDL 语句 int executeUpdate(String SQL) 返回执行 SQL 语句影响的行的数目。使用该方法来执行 SQL 语句，是希望得到一些受影响的行的数目，例如，INSERT，UPDATE 或 DELETE 语句 ResultSet executeQuery(String SQL): 返回一个 ResultSet 对象。当你希望得到一个结果集时使用该方法，就像你使用一个 SELECT 语句。 close()关闭statement对象，这个是必须有的，为了程序的安全，必须在结束之前关闭 实例： 1234567891011121314151617181920212223242526272829303132 Statement stmt = null; //申请对象try &#123; stmt = connection.createStatement( ); //通过Connection对象创建statement对象 String sql_1="select * from course;"; String sql_2="select * from course where id=2;"; ResultSet res_1=stm.executeQuery(sql_1); //执行查询语句，返回的是一个结果集合，上面已经说明了 ResultSet res_2=stm.executeQuery(sql_1); while(res_1.next()) &#123; System.out.println(res_1.getInt(1)+"---"+res_1.getString(2)); //分别查询第一列和第二列的值，通过列数查询 System.out.println(res_1.getInt("id")+"---"+res_1.getString("name")); //通过列名查询 &#125; &#125;catch (SQLException e) &#123; //捕捉异常 . . .&#125;finally &#123; if(connection!=null) &#123; connection.close(); //关闭连接 &#125; if(stmt!=null) &#123; stmt.close(); //关闭 &#125;&#125; 说明：ResultSet常用的方法如下：注意下面的方法会发生SQLException异常 public void beforeFirst() 将光标移动到第一行之前。 public void afterLast() 将光标移动到最后一行之后。 public boolean first() 将光标移动到第一行。从第一行的数据开始读取 public void last() 将光标移动到最后一行。 public boolean absolute(int row) 将光标移动到指定的第row行。 public boolean previous() 将光标移动到上一行，如果超过结果集的范围则返回false。 public boolean next() 将光标移动到下一行，如果是结果集的最后一行则返回 false。 public int getRow() 返回当前光标指向的行数的值。 public void moveToInsertRow() 将光标移动到结果集中指定的行，可以在数据库中插入新的一行。当前光标位置将被记住 public void moveToCurrentRow() 如果光标处于插入行，则将光标返回到当前行，其他情况下，这个方法不执行任何操作 public int getInt(String columnName)返回当前行中名为 columnName的列的 int 值。 public int getInt(int columnIndex) 返回当前行中指定列的索引的int值。列索引从 1 开始，意味着行中的第一列是1 ，第二列是 2 ，以此类推。 getString(int columIndex) 返回指定列的String类型的数据 getString(String columName) 返回当前行中名为columName的String类型的值 动态查询 动态查询使用的PrepareStatement这个类实现的，PreparedStatement 接口扩展了 Statement 接口，它让你用一个常用的 Statement 对象增加几个高级功能。这个 statement 对象可以提供灵活多变的动态参数 实例： 123456789101112131415161718192021222324252627282930PreparedStatement pstmt = null;try &#123; String SQL = "select * from course where age=? and name=?"; pstmt = conn.prepareStatement(SQL); //创建对象 pstmt.setInt(1,22); //设置参数age的值 ，1表示第一个参数 pstmt.setString(2,"chenjiabing"); //设置name的值，其中2表示第二个参数 ResultSet res=pstmt.execteQuery(); while(res.next) &#123; .... &#125; . . .&#125;catch (SQLException e) &#123; . . .&#125;finally &#123; if(connection!=null) &#123; connection.close(); &#125; if(pstmt!=null) &#123; pstmt.close(); //关闭 &#125; . . .&#125; 说明:JDBC 中所有的参数都被用?符号表示，这是已知的参数标记。在执行SQL 语句之前，你必须赋予每一个参数确切的数值。其中PrepareStatement的常用函数如下，当然Statement中的execute ,executeQuery,executeUpdate也可以使用 void setInt(int parameterIndex, int x) parameterIndex表示第几个?,这里的int x表示是mysql中定义的int类型的值 void setString(int parameterIndex,String x) 为第parameterIndex个String类型的?赋予x的值 其他的操作 这里还有delete,update,alter等一系列的操作都是和上面的一样，就是把sql语句改变以下，如果使用的是静态的就要为delete,update,使用Statement.execteUpdate(sql)这个函数,当然要使用动态的也是executeUpdate函数 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BootStrap干货篇之表单]]></title>
      <url>%2F2017%2F04%2F26%2FBootStrap%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B9%8B%E8%A1%A8%E5%8D%95%2F</url>
      <content type="text"><![CDATA[BootStrap干货篇之表单基本介绍 单独的表单控件会被自动赋予一些全局样式。所有设置了 .form-control 类的 &lt;input&gt;、&lt;textarea&gt; 和 &lt;select&gt; 元素都将被默认设置宽度属性为 width: 100%;。 将 label元素和前面提到的控件包裹在 .form-group 中可以获得最好的排列。 基本实例： 1234567891011121314151617181920212223 &lt;div class=&apos;container&apos;&gt; &lt;form&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputEmail1&quot;&gt;Email address&lt;/label&gt; &lt;input type=&quot;email&quot; class=&quot;form-control&quot; id=&quot;exampleInputEmail1&quot; placeholder=&quot;Email&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputPassword1&quot;&gt;Password&lt;/label&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;exampleInputPassword1&quot; placeholder=&quot;Password&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputFile&quot;&gt;File input&lt;/label&gt; &lt;input type=&quot;file&quot; id=&quot;exampleInputFile&quot;&gt; &lt;p class=&quot;help-block&quot;&gt;Example block-level help text here.&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot;&gt; Check me out &lt;/label&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt; &lt;/div&gt; 说明：这里的form-control是对所有的输入控件而言的,源码中将width设置为100%，表示会将这个输入控件占满一整行，form-group是用来对label和input更好的排版的，其中还有form-group-sm,form-group-lg，源码中分别利用这个对带有form-control的控件设置了不同的高度，具体看源码，不过正常情况下还是使用form-group 内联表单 为 &lt;form&gt; 元素添加 .form-inline 类可使其内容左对齐并且表现为inline-block级别的控件。只适用于视口（viewport）至少在 768px 宽度时（视口宽度再小的话就会使表单折叠）从源码中可以看到对form-inline下的form-group,form-control,form-control-static,input-group,radio,checkbox都是用了display:inline-block 注意： 在 Bootstrap 中，输入框和单选/多选框控件默认被设置为 width: 100%; 宽度。在内联表单，我们将这些元素的宽度设置为width: auto;，因此，多个控件可以排列在同一行。根据你的布局需求，可能需要一些额外的定制化组件。 一定要有label标签，如果不想要label标签可以设置.sr-only将其隐藏如果你没有为每个输入控件设置 label 标签，屏幕阅读器将无法正确识别。对于这些内联表单，你可以通过为 label 设置 .sr-only 类将其隐藏。还有一些辅助技术提供label标签的替代方案，比如 aria-label、aria-labelledby或 title 属性。如果这些都不存在，屏幕阅读器可能会采取使用 placeholder 属性，如果存在的话，使用占位符来替代其他的标记，但要注意，这种方法是不妥当的。 实例: 1234567891011121314151617&lt;form class=&quot;form-inline&quot;&gt; &lt;!--指定了form-inline类--&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;!--label中的for标签是用于绑定组件的，如果指定了for标签，input中的id也和for标签的内容相同，那么就会当鼠标点击&lt;label&gt;内容时会自动聚焦在input上--&gt; &lt;label class=&quot;sr-only&quot; for=&quot;exampleInputEmail3&quot;&gt;Email address&lt;/label&gt; &lt;input type=&quot;email&quot; class=&quot;form-control&quot; id=&quot;exampleInputEmail3&quot; placeholder=&quot;Email&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;sr-only&quot; for=&quot;exampleInputPassword3&quot;&gt;Password&lt;/label&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;exampleInputPassword3&quot; placeholder=&quot;Password&quot;&gt; &lt;/div&gt; &lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot;&gt; Remember me &lt;/label&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Sign in&lt;/button&gt;&lt;/form&gt; 水平表单 水平表单通过指定为form指定form-horizontal类来设定，其中可以使用BootStrap的栅栏系统设置水平间距，其中的form-group的div就表示一行了，相当于&lt;div class=&#39;row&#39;&gt;&lt;/div&gt;,因此只需要在label和input中指定列就行了，但是input标签不能直接使用，要在外面加上div 实例： 12345678910111213141516171819202122232425262728&lt;form class=&quot;form-horizontal&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;inputEmail3&quot; class=&quot;col-sm-2 control-label&quot;&gt;Email&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;email&quot; class=&quot;form-control&quot; id=&quot;inputEmail3&quot; placeholder=&quot;Email&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;!--相当与&lt;div class=&apos;row&apos;&gt;&lt;/div&gt;--&gt; &lt;label for=&quot;inputPassword3&quot; class=&quot;col-sm-2 control-label&quot;&gt;Password&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;inputPassword3&quot; placeholder=&quot;Password&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;col-sm-offset-2 col-sm-10&quot;&gt; &lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot;&gt; Remember me &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;col-sm-offset-2 col-sm-10&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Sign in&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 说明上面的label标签中的control-label主要的作用是设置文字的对齐方式为左对齐，如果不加这个将会在右边出现很大的空白 多选和单选框 多选框（checkbox）用于选择列表中的一个或多个选项，而单选框（radio）用于从多个选项中只选择一个。其中提供的类有checkbox,checkbox-inline,radio,radio-inline 内联单选和多选框 通过将 .checkbox-inline 或 .radio-inline 类应用到一系列的多选框（checkbox）或单选框（radio）控件上，可以使这些控件排列在一行。 实例： 12345678910111213141516171819202122232425262728&lt;label class=&quot;checkbox-inline&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;inlineCheckbox1&quot; value=&quot;option1&quot;&gt; 1&lt;/label&gt;&lt;label class=&quot;checkbox-inline&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;inlineCheckbox2&quot; value=&quot;option2&quot;&gt; 2&lt;/label&gt;&lt;label class=&quot;checkbox-inline&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;inlineCheckbox3&quot; value=&quot;option3&quot;&gt; 3&lt;/label&gt;&lt;label class=&quot;radio-inline&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;inlineRadioOptions&quot; id=&quot;inlineRadio1&quot; value=&quot;option1&quot;&gt; 1&lt;/label&gt;&lt;label class=&quot;radio-inline&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;inlineRadioOptions&quot; id=&quot;inlineRadio2&quot; value=&quot;option2&quot;&gt; 2&lt;/label&gt;&lt;label class=&quot;radio-inline&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;inlineRadioOptions&quot; id=&quot;inlineRadio3&quot; value=&quot;option3&quot;&gt; 3&lt;/label&gt;&lt;div class=&quot;checkbox-inline&quot;&gt; &lt;label for=&quot;sex&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;checkbox-inline&quot;&gt; &lt;label for=&quot;sex&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt;男&lt;/label&gt; &lt;/div&gt; 不带label文本的Checkbox 和 radio 如果需要 &lt;label&gt; 内没有文字，输入框（input）正是你所期望的。 目前只适用于非内联的 checkbox和 radio。 请记住，仍然需要为使用辅助技术的用户提供某种形式的 label（例如，使用 aria-label）。 实例： 12345678910&lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;blankCheckbox&quot; value=&quot;option1&quot; aria-label=&quot;...&quot;&gt; &lt;/label&gt;&lt;/div&gt;&lt;div class=&quot;radio&quot;&gt; &lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;blankRadio&quot; id=&quot;blankRadio1&quot; value=&quot;option1&quot; aria-label=&quot;...&quot;&gt; &lt;/label&gt;&lt;/div&gt; 下拉列表（select） 实例： 1234567&lt;select class=&quot;form-control&quot;&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt;&lt;/select&gt; 静态控件 如果需要在表单中将一行纯文本和 label 元素放置于同一行，为&lt;p&gt;标签设置为form-control-static 实例： 1234567891011121314&lt;form class=&quot;form-horizontal&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;col-sm-2 control-label&quot;&gt;Email&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;p class=&quot;form-control-static&quot;&gt;email@example.com&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;inputPassword&quot; class=&quot;col-sm-2 control-label&quot;&gt;Password&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;inputPassword&quot; placeholder=&quot;Password&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 参考文章 中文官网 文档手册 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Scrapyd部署爬虫]]></title>
      <url>%2F2017%2F04%2F24%2FScrapyd%E9%83%A8%E7%BD%B2%E7%88%AC%E8%99%AB%2F</url>
      <content type="text"><![CDATA[Scrapyd部署爬虫准备工作 安装scrapyd: pip install scrapyd 安装scrapyd-client : pip install scrapyd-client 安装curl:[安装地址](http://ono60m7tl.bkt.clouddn.com/curl.exe),安装完成以后将所在目录配置到环境变量中 开始部署 修改scrapy项目目录下的scrapy.cfg文件，修改如下 123[deploy:JD_Spider] #加上target :nameurl = http://localhost:6800/ #将前面的#删除project = JD #project的名字，可以使用默认的，当然也可以改变 在任意目录下的打开终端，输入scrapyd,观察是否运行成功，运行成功的话，就可以打开http://localhost:6800看是否正常显示，如果正常显示则看到下面的这张图,这里的JD是部署之后才能看到的，现在是看不到的，所以没出现也不要担心： 在项目的根目录下运行如下的命令：python E:\python2.7\Scripts\scrapyd-deploy target -p project,这里的E:\python2.7\Scripts\是你的python安装目录，Scripts是安装目录下的一个文件夹，注意前面一定要加上python,target是在前面scrapy.cfg中设置的deploy:JD_Spider，JD_Spider就是target,project 是JD,因此这个完整的命令是python E:\python2.7\Scripts\scrapyd-deploy JD_Spider -p JD,现在项目就部署到上面了，这下网页上就有JD了，详情请见上图 验证是否成功，你可以在网页上看有没有显示你的工程名字，另外在根目录下输入python E:\python2.7\Scripts\scrapyd-deploy -l就能列出你所有部署过的项目了 启动爬虫：curl http://localhost:6800/schedule.json -d project=myproject -d spider=spider_name,这里的project填入的是项目名，spider_name填入的是你的爬虫中定义的name,运行我的实例完整的代码为：curl http://localhost:6800/schedule.json -d project=JD -d spider=spider，这里将会显示如下信息： 12#这里的jobid比较重要，下面会用到这个取消爬虫&#123;"status": "ok", "jobid": "3013f9d1283611e79a63acb57dec5d04", "node_name": "DESKTOP-L78TJQ7"&#125; 取消爬虫：curl http://localhost:6800/cancel.json -d project=myproject -d job=jobid,jobid就是上面的提到过的，如果取消我的这个实例代码如：curl http://localhost:6800/cancel.json -d project=JD -d job=3013f9d1283611e79a63acb57dec5d04,那么它的状态就会变成如下： 1&#123;"status": "ok", "prevstate": "running", "node_name": "DESKTOP-L78TJQ7"&#125; 列出项目：curl http://localhost:6800/listprojects.json,下面将会出现你已经部署的项目 删除项目：curl http://localhost:6800/delproject.json -d project=myproject 列出版本：curl http://localhost:6800/listversions.json?project=myproject,这里的project是项目的名字，是在scrapy.cfg设置的 列出爬虫：curl http://localhost:6800/listspiders.json?project=myproject这里的project是项目的名字，是在scrapy.cfg设置的 列出job:curl http://localhost:6800/listjobs.json?project=myproject这里的project是项目的名字，是在scrapy.cfg设置的 删除版本：curl http://localhost:6800/delversion.json -d project=myproject -d version=r99，这里的version是自己的项目版本号，在删除之前需要查看版本号 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[scrapy大战京东商城]]></title>
      <url>%2F2017%2F04%2F23%2Fscrapy%E5%A4%A7%E6%88%98%E4%BA%AC%E4%B8%9C%E5%95%86%E5%9F%8E%2F</url>
      <content type="text"><![CDATA[SCrapy爬虫大战京东商城引言 上一篇已经讲过怎样获取链接，怎样获得参数了，详情请看python爬取京东商城普通篇 代码详解 首先应该构造请求，这里使用scrapy.Request,这个方法默认调用的是start_urls构造请求，如果要改变默认的请求，那么必须重载该方法，这个方法的返回值必须是一个可迭代的对象，一般是用yield返回，代码如下： 12345def start_requests(self): for i in range(1,101): page=i*2-1 #这里是构造请求url的page,表示奇数 url=self.start_url+str(page) yield scrapy.Request(url,meta=&#123;'search_page':page+1&#125;,callback=self.parse_url) #这里使用meta想回调函数传入数据，回调函数使用response.meta['search-page']接受数据 下面就是解析网页了，从上面看出这里的解析回调函数是parse_url,因此在此函数中解析网页。这里还是和上面说的一样，这个url得到的仅仅是前一半的信息，如果想要得到后一半的信息还有再次请求，这里还有注意的就是一个技巧：一般先解析出一个数据的数组，不急着取出第一个数，先要用if语句判断，因为如果得到的是[]，那么直接取出[0]是会报错的，这只是一个避免报错的方法吧，代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950def parse_url(self,response): if response.status==200: #判断是否请求成功 # print response.url pids = set() #这个集合用于过滤和保存得到的id,用于作为后面的ajax请求的url构成 try: all_goods = response.xpath("//div[@id='J_goodsList']/ul/li") #首先得到所有衣服的整个框架，然后从中抽取每一个框架 for goods in all_goods: #从中解析每一个 # scrapy.shell.inspect_response(response,self) #这是一个调试的方法，这里会直接打开调试模式 items = JdSpiderItem() #定义要抓取的数据 img_url_src = goods.xpath("div/div[1]/a/img/@src").extract() # 如果不存在就是一个空数组[]，因此不能在这里取[0] img_url_delay = goods.xpath( "div/div[1]/a/img/@data-lazy-img").extract() # 这个是没有加载出来的图片，这里不能写上数组取第一个[0] price = goods.xpath("div/div[3]/strong/i/text()").extract() #价格 cloths_name = goods.xpath("div/div[4]/a/em/text()").extract() shop_id = goods.xpath("div/div[7]/@ data-shopid").extract() cloths_url = goods.xpath("div/div[1]/a/@href").extract() person_number = goods.xpath("div/div[5]/strong/a/text()").extract() pid = goods.xpath("@data-pid").extract() # product_id=goods.xpath("@data-sku").extract() if pid: pids.add(pid[0]) if img_url_src: # 如果img_url_src存在 print img_url_src[0] items['img_url'] = img_url_src[0] if img_url_delay: # 如果到了没有加载完成的图片，就取这个url print img_url_delay[0] items['img_url'] = img_url_delay[0] # 这里如果数组不是空的，就能写了 if price: items['price'] = price[0] if cloths_name: items['cloths_name'] = cloths_name[0] if shop_id: items['shop_id'] = shop_id[0] shop_url = "https://mall.jd.com/index-" + str(shop_id[0]) + ".html" items['shop_url'] = shop_url if cloths_url: items['cloths_url'] = cloths_url[0] if person_number: items['person_number'] = person_number[0] # if product_id: # print "************************************csdjkvjfskvnk***********************" # print self.comments_url.format(str(product_id[0]),str(self.count)) # yield scrapy.Request(url=self.comments_url.format(str(product_id[0]),str(self.count)),callback=self.comments) #yield scrapy.Request写在这里就是每解析一个键裤子就会调用回调函数一次 yield items except Exception: print "********************************************ERROR**********************************************************************" yield scrapy.Request(url=self.search_url.format(str(response.meta['search_page']),",".join(pids)),callback=self.next_half_parse) #再次请求，这里是请求ajax加载的数据，必须放在这里，因为只有等到得到所有的pid才能构成这个请求，回调函数用于下面的解析 从上面代码的最后可以看出最后就是解析ajax加载的网页了，这里调用的next_half_parse函数，和解析前面一个网页一样，这里需要的注意的是，如果前面定义的数据没有搜索完毕是不能使用yield items的，必须将items通过meta传入下一个回调函数继续完善后才能yield items,这里就不需要了，代码如下： 12345678910111213141516171819202122232425262728293031323334353637#分析异步加载的网页 def next_half_parse(self,response): if response.status==200: print response.url items=JdSpiderItem() #scrapy.shell.inspect_response(response,self) #y用来调试的 try: lis=response.xpath("//li[@class='gl-item']") for li in lis: cloths_url=li.xpath("div/div[1]/a/@href").extract() img_url_1=li.xpath("div/div[1]/a/img/@src").extract() img_url_2=li.xpath("div/div[1]/a/img/@data-lazy-img").extract() cloths_name=li.xpath("div/div[4]/a/em/text()").extract() price=li.xpath("div/div[3]/strong/i/text()").extract() shop_id=li.xpath("div/div[7]/@data-shopid").extract() person_number=li.xpath("div/div[5]/strong/a/text()").extract() if cloths_url: print cloths_url[0] items['cloths_url']=cloths_url[0] if img_url_1: print img_url_1[0] items['img_url']=img_url_1 if img_url_2: print img_url_2[0] items['img_url']=img_url_2[0] if cloths_name: items['cloths_name']=cloths_name[0] if price: items['price']=price[0] if shop_id: items['shop_id']=shop_id[0] items['shop_url']="https://mall.jd.com/index-" + str(shop_id[0]) + ".html" if person_number: items['person_number']=person_number[0] yield items #又一次的生成，这里是完整的数据，因此可以yield items except Exception: print "**************************************************" 当然这里还用到了设置请求池，mysql存储，没有使用到ip代理，这个在我前面的博客中又讲到，这里就不再赘述了，想看源代码的朋友请点击这里 小技巧 人们会抱怨为什么自己的爬虫在中途断开就要重头开始爬，为什么不能从断开那里开始爬呢，这里提供一个方法：在配置文件settings.py中加入JOBDIR=file_name,这里的file_name是一个文件的名字 设置下载延迟防止被ban:DOWNLOAD_DELAY = 2:设置每一次的间隔时间 RANDOMIZE_DOWNLOAD_DELAY = True:这个是随机设置延迟时间 在设置的时间的0.5-1.5倍之间，这样可以更有效的防止被ban,一般是配套使用的 ROBOTSTXT_OBEY = False :这里是表示不遵循robots.txt文件，默认是True表示遵循，这里将之改成False CONCURRENT_REQUESTS :设置最大请求数，这里默认的时16，我们可以根据自己电脑的配置改的大一点来加快请求的速度 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python爬虫大战京东商城]]></title>
      <url>%2F2017%2F04%2F23%2Fpython%E7%88%AC%E8%99%AB%E5%A4%A7%E6%88%98%E4%BA%AC%E4%B8%9C%E5%95%86%E5%9F%8E%2F</url>
      <content type="text"><![CDATA[python大规模爬取京东主要工具 scrapy BeautifulSoup requests 分析步骤 打开京东首页，输入裤子将会看到页面跳转到了这里，这就是我们要分析的起点 我们可以看到这个页面并不是完全的，当我们往下拉的时候将会看到图片在不停的加载，这就是ajax,但是当我们下拉到底的时候就会看到整个页面加载了60条裤子的信息，我们打开chrome的调试工具，查找页面元素时可以看到每条裤子的信息都在&lt;li class=&#39;gl-item&#39;&gt;&lt;/li&gt;这个标签中，如下图： 接着我们打开网页源码就会发现其实网页源码只有前30条的数据，后面30条的数据找不到，因此这里就会想到ajax，一种异步加载的方式，于是我们就要开始抓包了，我们打开chrome按F12，点击上面的NetWork,然后点击XHR,这个比较容易好找,下面开始抓包，如下图： 从上面可以找到请求的url，发现有很长的一大段，我们试着去掉一些看看可不可以打开，简化之后的url=https://search.jd.com/s_new.php?keyword=%E8%A3%A4%E5%AD%90&amp;enc=utf-8&amp;qrst=1&amp;rt=1&amp;stop=1&amp;vt=2&amp;offset=3&amp;wq=%E8%A3%A4%E5%AD%90&amp;page={0}&amp;s=26&amp;scrolling=y&amp;pos=30&amp;show_items={1}这里的showitems是裤子的id,page是翻页的，可以看出来我们只需要改动两处就可以打开不同的网页了，这里的page很好找，你会发现一个很好玩的事情，就是主网页的page是奇数，但是异步加载的网页中的page是偶数，因此这里只要填上偶数就可以了，但是填奇数也是可以访问的。这里的show_items就是id了，我们可以在页面的源码中找到，通过查找可以看到id在li标签的data-pid中，详情请看下图 上面我们知道怎样找参数了，现在就可以撸代码了 代码讲解 首先我们要获取网页的源码，这里我用的requests库，安装方法为pip install requests，代码如下: 1234def get_html(self): res = requests.get(self.url, headers=self.headers) html = res.text return html #返回的源代码 根据上面的分析可以知道，第二步就是得到异步加载的url中的参数show_items,就是li标签中的data-pid,代码如下： 12345678def get_pids(self): html = self.get_html() soup = BeautifulSoup(html, 'lxml') #创建BeautifulSoup对象 lis = soup.find_all("li", class_='gl-item') #查找li标签 for li in lis: data_pid = li.get("data-pid") #得到li标签下的data-pid if (data_pid): self.pids.add(data_pid) #这里的self.pids是一个集合，用于过滤重复的 下面就是获取前30张图片的url了，也就是主网页上的图片，其中一个问题是img标签的属性并不是一样的，也就是源码中的img中不都是src属性，一开始已经加载出来的图片就是src属性，但是没有加载出来的图片是data-lazy-img，因此在解析页面的时候要加上讨论。代码如下： 12345678910111213141516def get_src_imgs_data(self): html = self.get_html() soup = BeautifulSoup(html, 'lxml') divs = soup.find_all("div", class_='p-img') # 图片 # divs_prices = soup.find_all("div", class_='p-price') #价格 for div in divs: img_1 = div.find("img").get('data-lazy-img') # 得到没有加载出来的url img_2 = div.find("img").get("src") # 得到已经加载出来的url if img_1: print img_1 self.sql.save_img(img_1) self.img_urls.add(img_1) if img_2: print img_2 self.sql.save_img(img_2) self.img_urls.add(img_2) 前三十张图片找到了，现在开始找后三十张图片了，当然是要请求那个异步加载的url，前面已经把需要的参数给找到了，下面就好办了，直接贴代码： 12345678910111213141516171819def get_extend_imgs_data(self): # self.search_urls=self.search_urls+','.join(self.pids) self.search_urls = self.search_urls.format(str(self.search_page), ','.join(self.pids)) #拼凑url,将获得的单数拼成url,其中show_items中的id是用','隔开的，因此要对集合中的每一个id分割，page就是偶数，这里直接用主网页的page加一就可以了 print self.search_urls html = requests.get(self.search_urls, headers=self.headers).text #请求 soup = BeautifulSoup(html, 'lxml') div_search = soup.find_all("div", class_='p-img') #解析 for div in div_search: img_3 = div.find("img").get('data-lazy-img') #这里可以看到分开查找img属性了 img_4 = div.find("img").get("src") if img_3: #如果是data-lazy-img print img_3 self.sql.save_img(img_3) #存储到数据库 self.img_urls.add(img_3) #用集合去重 if img_4: #如果是src属性 print img_4 self.sql.save_img(img_4) self.img_urls.add(img_4) 通过上面就可以爬取了，但是还是要考虑速度的问题，这里我用了多线程，直接每一页面开启一个线程，速度还是可以的，感觉这个速度还是可以的，几分钟解决问题，总共爬取了100个网页,这里的存储方式是mysql数据库存储的，要用发哦MySQLdb这个库，详情自己百度，当然也可以用mogodb但是还没有学呢，想要的源码的朋友请看GitHub源码 拓展写到这里可以看到搜索首页的网址中keyword和wq都是你输入的词，如果你想要爬取更多的信息，可以将这两个词改成你想要搜索的词即可，直接将汉字写上，在请求的时候会自动帮你编码的，我也试过了，可以抓取源码的，如果你想要不断的抓取，可以将要搜索的词写上文件里，然后从文件中读取就可以了。以上只是一个普通的爬虫，并没有用到什么框架，接下来将会写scrapy框架爬取的，请继续关注我的博客哦！！！ 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JQuery干货篇之处理元素]]></title>
      <url>%2F2017%2F04%2F22%2FJQuery%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B9%8B%E5%A4%84%E7%90%86%E5%85%83%E7%B4%A0%2F</url>
      <content type="text"><![CDATA[JQuery干货篇之处理元素 注意这里用的还是我前两篇用的例子，详情请看我的博客 attrattr() 方法设置或返回被选元素的属性值。 语法： $(selector).attr(attribute) 返回被选元素的属性值。 $(selector).attr(attribute,value) 设置被选元素的属性和值 $(selector).attr(attribute,function(index,oldvalue)) 设置被选元素的属性和值。 参数 描述 attribute 规定属性的名称。 function(index,oldvalue) 规定返回属性值的数。该函数可接收并使用选择器的 index 值和当前属性值。 实例：12345678910111213141516171819202122 $("img").filter(":first").attr('src'); //得到属性$("img").each(function (index,elem) &#123; if(index%2==0) $(elem).attr("src",'lily.png'); //设置属性 console.log($(elem).attr("src")); &#125;) $("img").attr('src',function (index,oldValue) &#123; //这里的oldValue表示原来属性的值，index是索引 if(oldValue=="rose.png") return 'lily.png'; else return 'astor.png'; &#125;) attrs=&#123; //使用映射对象一次设置多个值 src:'lily.png', style: 'border: thick double red' &#125;; $("img:eq(1)").attr(attrs); removeAttr removeAttr() 方法从被选元素中移除属性。 语法： $(selector).removeAttr(attribute) 这里的attribute是属性的名字 实例： 1$("img:first").removeAttr("src"); //删除属性src addClass addClass() 方法向被选元素添加一个或多个类 语法： $(selector).addClass(class) 这里的class是类名如果需要添加多个类，中间用空格隔开 $(selector).addClass(function(index,oldclass)) 这里的index是索引，oldClass是原来就有的类名，都是可选参数。这个函数的返回的就是要添加的类名 实例： 12345678910111213$("img:even").addClass("redBar"); //向偶数的img添加类redBar$("img").addClass(function (index,currentClass) &#123; //这里的currentClass就是原来有的类名，可选 if(index==1) return 'blueBar'; //第二个img应用blueBar这个类 else return 'redBar'; //这里需要注意的是，对同一个img应用类的时候，因为这个类的定义有优先级，上面定义会被后面定义的覆盖，所以要注意类定义的位置 &#125;) $("img").filter(":odd").addClass("redBar").end().filter(":even").addClass("blueBar"); //链式调用 $("img").addClass("blueBar redBar"); //添加两个类 hasClass hasClass() 方法检查被选元素是否包含指定的class 语法： $(selector).hasClass(class) //返回值是false和true 实例： 1console.log($("img:odd").hasClass("redBar")); toggleClass toggleClass() 对设置或移除被选元素的一个或多个类进行切换。该方法检查每个元素中指定的类。如果不存在则添加类，如果已设置则删除之。这就是所谓的切换效果 语法： $(selector).toggleClass(class,switch) class必需的，用来规定添加或移除class的指定元素，如需规定若干 class，请使用空格来分隔类名。switch是boolean可选参数，规定是否添加或移除class $(selector).toggleClass(function(index,class),switch) index表示索引，class表示选择器当前拥有的类 实例： 123456789101112131415161718192021222324$("img").toggleClass("redBar"); //这里对所有的img在redBar这个类之间切换$("img").toggleClass("redBar blueBar"); //在两个类之间来回的切换$("&lt;button&gt;ToggleClass&lt;/button&gt;").appendTo("#buttonDiv").click(function (e) &#123; $("img").toggleClass('redBar blueBar'); //在两种class之间切换，如果有就删除，没有的就添加 e.preventDefault(); &#125;) //下面添加一个按钮，完成同时添加多个图片的效果 $("&lt;button&gt;ToggleClass&lt;/button&gt;").appendTo("#buttonDiv").click(function (e) &#123; $("img").toggleClass(function (index,currentClass) &#123; if(index%2==0) return 'blueBar'; //动态的切换，这里是偶数就切换blue else return 'redBar blueBar'; //这里是奇数的图片在两种颜色来回的切换 &#125;); e.preventDefault(); &#125;) css css() 方法返回或设置匹配的元素的一个或多个样式属性，这里只说css，还有其他的设置css样式请看w3School 语法： $(selector).css(name) 返回第一个匹配元素的 CSS属性值。name是css属性的名称 $(selector).css(name,value) 设置所有匹配元素的指定 CSS 属性。name表示属性名称，value表示属性的值 $(selector).css(name,function(index,value)) 此函数返回要设置的属性值。接受两个参数，index为元素在对象集合中的索引位置，value 是原先的属性值。name表示要设置的属性名称，返回值就是要设置的属性值 实例： 1234567891011$("label").css('font-size','30px'); //设置字体大小$("label").css('font-size','+=10'); //使用相对值设置属性值，在原有的基础上加上10console.log($("h1").css('font-family')); //获取h1标签的字体var cssValues=&#123; 'border':'thick double red', 'font-size':'1.5em'&#125;;$("label").css(cssValues); //同时设置多个属性 text text() 方法方法设置或返回被选元素的文本内容。当该方法用于返回一个值时，它会返回所有匹配元素的组合的文本内容(会删除 HTML 标记) 语法： $(selector).text() 当该方法用于返回一个值时，它会返回所有匹配元素的组合的文本内容（会删除 HTML 标记）。 $(selector).text(content) 当该方法用于设置值时，它会覆盖被选元素的所有内容。 $(selector).text(function(index,oldcontent)) index表示索引,oldcontent表示选择器当前的文本内容 html html() 方法返回或设置被选元素的内容 (inner HTML)。如果该方法未设置参数，则返回被选元素的当前内容。 语法： $(selector).html() 当使用该方法返回一个值时，它会返回第一个匹配元素的内容。 $(selector).html(content) 当使用该方法设置一个值时，它会覆盖所有匹配元素的内容。 $(selector).html(function(index,oldcontent)) 使用函数来设置所有匹配元素的内容。index - 可选。接收选择器的index 位置,oldcontent - 可选。接收选择器的当前内容 val val() 方法返回或设置被选元素的值,元素的值是通过 value 属性设置的。该方法大多用于 input 元素,如果该方法未设置参数，则返回被选元素的当前值 语法： $(selector).val(value) 设置文本域的值为value $(selector).val() 得到文本域的值 $(selector).val(function(index,oldvalue)) 设置文本域的值，这里函数的返回值将会用来设置文本域的值，index表示元素索引，oldvalue表示选择器当前文本域的值 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JQuery干货篇之操控DOM]]></title>
      <url>%2F2017%2F04%2F21%2FJQuery%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B9%8B%E6%93%8D%E6%8E%A7DOM%2F</url>
      <content type="text"><![CDATA[JQuery干货篇之插入元素本次使用的html,css还是我上一篇的源代码，详情请看上一篇文章 分类 插入子元素：append,prepend ,appendTo,prependTo 封装包裹元素：wrap,wrapAll,wrapInner 插入兄弟元素：after,before,insertAfter,insertBefore 替换元素：replaceWith,replaceAll 删除元素：remove,deatch,unwrap,empty 创建新元素通常在把新元素插入到DOM中的目标位置之前，要先创建一个新元素才能将它插入到指定位置 使用$创建元素 $(&lt;div&gt;&lt;img src=&#39;rose.png&#39; alt=&#39;玫瑰&#39;&gt;&lt;/div&gt;) clone 克隆元素，使用clone方法以已有的元素为模子生成新的元素，这个在后面的插入元素起到关键作用，如果在要引用html中的一个标签内容的话，不使用clone方法，那么就会将这段内容移动，因此这里使用clone会很方便，详细请看append的用法实例 实例： 1$("div.dcell").clone(); //这里的clone方法必须是JQuery对象调用 使用DOM API创建新元素 DOM API是用js操作的，其实jquery在幕后悄悄的调用DOM API 实例： 1234567891011121314 var divElem=document.createElement("div"); //创建一个div元素 divElem.classList.add("dcell"); //为div添加class=dcellvar imgElem=document.createElement("img");imgElem.src="lily.png";divElem.appendChild(imgElem); //在新创建的元素后面插入imgvar newElem=$(divElem);newElem.each(function (index,elem) &#123; console.log(elem.tagName+" "+elem.className);&#125;); append 把参数指定的元素插入到所有的JQuery内含元素内容末尾成为他们的最后一个子元素，形式有append(html),append(Jquery),append(HTMLElements[])，append(function()) 实例： 12345678910111213141516171819202122232425//这里使用append元素创建了一个div元素，在末尾插入元素成为div的子元素// var orchildElems = $("&lt;div class='dcell'&gt;&lt;/div&gt;").append("&lt;img src='orchid.png'/&gt;") .append("&lt;label for='orchild'&gt;Orchild:&lt;/label&gt;") .append("&lt;input name='orchild' value='0' required&gt;"); var newElems = $("&lt;div class='dcell'&gt;&lt;/div&gt;").append("&lt;img src='lily.png'/&gt;") .append("&lt;label for='lily'&gt;Lily:&lt;/label&gt;") .append("&lt;input name='lily' value='0' required&gt;") .css("border", 'thick double red'); $("div.drow").append(orchildElems); //在末尾插入数据，这里的参数是jquery对象 $("div.drow").append(function(index,elem)&#123; if(elem.id=='row1') return orchildElems; else if(this.id='row2') return newElems; &#125;) $("div.drow").last().append(orchildElem,newElems); //在其中添加两个参数，插入的先后按照参数的先后位置，当然其中的参数个数没有限制 prepend 和append完全相反,向当前元素的前面插入html节点作为当前元素的子元素,形式有prepen d(Jquery),prepend(html),prepend(htmlElemnts[]),prepend(function()) 实例： 123456789101112131415161718 var orchildElems = $("&lt;div class='dcell'&gt;&lt;/div&gt;").append("&lt;img src='orchid.png'/&gt;") .append("&lt;label for='orchild'&gt;Orchild:&lt;/label&gt;") .append("&lt;input name='orchild' value='0' required&gt;");$("div.dcell").prepend(orchildElems); //将orchildElems插入到div.dcell的最前面，作为他的子元素$("div.dcell").prepend("&lt;img src='lily.png'&gt;"); //将参数html的内容插入到前面，作为子元素$("div.drow").append(function (index) &#123; //参数是函数，index是索引，返回的内容就是要插入到前面的内容 if (this.id == 'row1') return orchildElem; //返回的对象可以是jquery对象，也可以是html标签，如：return "&lt;img src='lily.png'&gt; else if (this.id = 'row2') return newElems; &#125;); appendTo appendTo是和append一样的函数，都是将指定的元素插入到指定元素的前面作为子元素，但是他们的参数就不同了，append是将指定的参数插入到当前调用它的的结果集中，而appendTo是将当前调用它的结果集插入到指定的参数中，主要的形式有appendTo(jquery),append(HTMLELments[]) 实例： 123456$("&lt;img src='lily.png'&gt;").appendTo($("img").last().parent()); //将图片插入到最后一个dcell中，这里参数是目标位置，开头调用的时想要插入的内容$("img:first").clone().appendTo($("img").last().parent()); //选择第一个图片插入到最后一个dcell中，这里必须用clone，否则就会将这张图片移到目标位置 $($("div.dcell").html()).appendTo($("img").last().parent()); //这里的.html()是获取html文本内容 prependTo .prepend()和.prependTo()实现同样的功能，主要的不同是语法，插入的内容和目标的位置不同。 对于 .prepend() 而言，选择器表达式写在方法的前面，作为待插入内容的容器，将要被插入的内容作为方法的参数。而 .prependTo() 正好相反，将要被插入的内容写在方法的前面，可以是选择器表达式或动态创建的标记，待插入内容的容器作为参数。 after 在匹配元素集合中的每个元素后面插入参数所指定的内容，作为其兄弟节点。形式有after(content[content,]),after(function()),这里的content内容有HTML字符串，DOM 元素，文本节点，元素和文本节点的数组，或者jQuery对象，用来插入到集合中每个匹配元素的后面 实例： 123456789101112131415 var orchildElems = $("&lt;div class='dcell'&gt;&lt;/div&gt;").append("&lt;img src='orchid.png'/&gt;") .append("&lt;label for='orchild'&gt;Orchild:&lt;/label&gt;") .append("&lt;input name='orchild' value='0' required&gt;"); //创建一个dcell内容 $("div.dcell").after(orchildElems); //插入元素作为兄弟元素，在当前元素的后面 $("#row1 div.dcell").after(function (index, html) &#123; //index表示索引，html表示原来的html文本，指的是没有插入之前的html console.log(html); if (index == 0)return orchildElem; //返回的可以是jquery对象，html文本 else if (index == 1) return newElems; &#125;);&#125;); before 根据参数设定，在匹配元素的前面插入内容,形式和after一样，内容也差不多 insertBefore 和prependTo的用法差不多，只是参数是要插入的目标位置，作为兄弟元素插入 实例： 1orchildElems.clone().insertBefore("#row2 div.dcell"); insertAfter 和append用法差不多，只是参数是要插入的目标位置，这里的也是作为兄弟元素插入的 实例： 1orchildElems.insertAfter("#row1 div.dcell"); wrap 在集合中匹配的每个元素周围包裹一个HTML结构，将会作为父元素存在。形式为wrap(html),wrap(jquery),wrap(HtmlElements[]),wrap(function()) 实例： 1234567891011 div=$("&lt;div&gt;&lt;/div&gt;").css("border",'thick double red'); $("div.drow").wrap(div); //在drow外层添加了一个div将作为父元素，可以看到现在的源代码变成了&lt;div style...&gt;&lt;div class='drow'&gt;...&lt;/div&gt;&lt;/div&gt; $(".drow").wrap(function (index) &#123; //index是索引 //if($(this).has("img[src*=astor]").length&gt;0) if(index==0) return div; //只在第一个drow中添加父元素div else return $("&lt;div&gt;&lt;/div&gt;").css("border",'thick double blue');&#125;) unwrap 将匹配元素集合的父级元素删除，保留自身（和兄弟元素，如果存在）在原来的位置。形式为unwrap(),unwrap(selector) 实例： 1234$("div.dcell").css("border",'thick double red'); $("div.dcell").children("img").first().unwrap(); //这里将第一个img元素的父级元素删除，并且保留了其中的子元素 $("div.dcell").children("img").unwrap(":first"); //这里使用参数来筛选要删除父级元素的当前元素，这里选择第一个元素 wrapAll 在集合中所有匹配元素的外面包裹一个HTML结构,也就是为结果集中的所有元素都设置了一个相同的父级元素来包裹所有的元素，形式为wrapAll(html),wrapAll(jquery),wrapAll(htmlElements[]),wrapAll(function()) 实例： 123var div = $("&lt;div&gt;&lt;/div&gt;").css("border", 'thick double red');$("div.drow").wrapAll(div); //这里的div成为了他共有的父级元素，原来的父级元素变成了祖先元素了$("img").wrapAll(div); //这里的img没有共同的父元素，那么就会强制的将所有的元素拉在一起为他们设置一个父级元素 wrapInner 在匹配元素里的内容外包一层结构,也就是为匹配元素的后代元素添加一个父级元素，但是这个父级元素是匹配元素的子代元素，也就是原来的匹配元素变成了祖先元素，形式为wrapInner(html),wrapInner(jquery),wrapInner(htmlElements),wrapInner(function()) 实例： 12var div = $("&lt;div&gt;&lt;/div&gt;").css("border", 'thick double red');$(".dcell").wrapInner(div); //这里的dcell元素将会变成祖先元素，而div将会变成内部后代元素新的父级元素 replaceWith 用提供的内容替换集合中所有匹配的元素并且返回被删除元素的集合,形式为replace(html),replaceWith(jquery),replaceWith(function()) 实例： 12345678910111213 var newElems = $("&lt;div class='dcell'&gt;&lt;/div&gt;").append("&lt;img src='lily.png'&gt;") .append("&lt;label for='lily'&gt;Lily&lt;/label&gt;").append("&lt;input name='lily' value='0' required&gt;").css("border", 'thick double blue');$(".dcell:first").replaceWith(newElems); //用newElems替换第一个dcell$("div.drow img").replaceWith(function () &#123; if (this.src.indexOf("rose") &gt; -1) return $("&lt;img src='lily.png'&gt;").css("border",'thick double red'); //返回的时替换的内容，可以是jquery或者html else if (this.src.indexOf("peony") &gt; -1) return newElems; else return $(this.clone()).css("border",'thick double blue');&#125;) replaceAll 用集合的匹配元素替换每个目标元素。.replaceAll()和.replaceWith()功能类似，但是目标和源相反 实例： 1$("&lt;img src='lily.png'&gt;").replaceAll("#row1 img"); //这里使用&lt;img src='lily.png'&gt;替换所有的img元素 remove 将匹配元素集合从DOM中删除,并且同时移除元素上的事件及 jQuery 数据 实例： 123$("div.dcell").remove(":has(img[src*=rose])"); //删除img$("div.dcell:first()").remove(); //不带参数 detach 从DOM中去掉所有匹配的元素,.detach() 方法和.remove()一样, 除了 .detach()保存所有jQuery数据和被移走的元素相关联。当需要移走一个元素，不久又将该元素插入DOM时，这种方法很有用。 实例： 123$("div.dcell").detach();$("div.dcell").detach(":has(img[src*=rose])"); empty 从DOM中移除集合中匹配元素的所有子节点。 1$(&quot;div.dcell:first&quot;).empty(); //删除所有的子节点 参考文章 JQuery中文文档 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JQuery干货篇之选择元素]]></title>
      <url>%2F2017%2F04%2F20%2FJQuery%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B9%8B%E9%80%89%E6%8B%A9%E5%85%83%E7%B4%A0%2F</url>
      <content type="text"><![CDATA[JQuery 干货篇之选择元素实验的HTML+CSS的代码 html12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Example&lt;/title&gt; &lt;script src="jquery-3.2.1.min.js" type="text/javascript"&gt;&lt;/script&gt; &lt;link rel="stylesheet" type="text/css" href="main.css"/&gt; &lt;script src="main.js" type="text/javascript"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Jacqui's Flower Shop&lt;/h1&gt;&lt;form method="post"&gt; &lt;div id="oblock"&gt; &lt;div class="dtable"&gt; &lt;div id="row1" class="drow"&gt; &lt;div class="dcell"&gt; &lt;img src="astor.png"/&gt;&lt;label for="astor"&gt;Astor:&lt;/label&gt; &lt;input name="astor" value="0" required&gt; &lt;/div&gt; &lt;div class="dcell"&gt; &lt;img src="daffodil.png"/&gt;&lt;label for="daffodil"&gt;Daffodil:&lt;/label&gt; &lt;input name="daffodil" value="0" required&gt; &lt;/div&gt; &lt;div class="dcell"&gt; &lt;img src="rose.png"/&gt;&lt;label for="rose"&gt;Rose:&lt;/label&gt; &lt;input name="rose" value="0" required&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id="row2" class="drow"&gt; &lt;div class="dcell"&gt; &lt;img src="peony.png"/&gt;&lt;label for="peony"&gt;Peony:&lt;/label&gt; &lt;input name="peony" value="0" required&gt; &lt;/div&gt; &lt;div class="dcell"&gt; &lt;img src="primula.png"/&gt;&lt;label for="primula"&gt;Primula:&lt;/label&gt; &lt;input name="primula" value="0" required&gt; &lt;/div&gt; &lt;div class="dcell"&gt; &lt;img src="snowdrop.png"/&gt;&lt;label for="snowdrop"&gt;Snowdrop:&lt;/label&gt; &lt;input name="snowdrop" value="0" required&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id="buttonDiv"&gt; &lt;button type="submit"&gt;Place Order&lt;/button&gt; &lt;/div&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; css 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061h1 &#123; min-width: 70px; border: thick double black; margin-left: auto; margin-right: auto; text-align: center; font-size: x-large; padding: .5em; color: darkgreen; background-image: url("border.png"); background-size: contain; margin-top: 0;&#125;.dtable &#123; display: table;&#125;.drow &#123; display: table-row;&#125;.dcell &#123; display: table-cell; padding: 10px;&#125;.dcell &gt; * &#123; vertical-align: middle&#125;input &#123; width: 2em; text-align: right; border: thin solid black; padding: 2px;&#125;label &#123; width: 5em; padding-left: .5em; display: inline-block;&#125;#buttonDiv &#123; text-align: center;&#125;#oblock &#123; display: block; margin-left: auto; margin-right: auto; min-width: 700px;&#125;.hover&#123; background: blue; color: white; height:300px; width:300px;&#125; 选择器 :animated :选择正在处理动画的元素 :first :选择第一个元素 :last :选择最后一个元素 :eq(n) :选择第n个元素(从0开始) :even :选择序号为偶数的元素 :odd :选择序号为奇数的元素 :gt(n) :选择序号大于n的元素 :lt(n) :选择序号小于n的元素 :text :选择所有的文本输入框 :contains(text) :选择包含指定文本的元素 file :选择所有文件上传输入框 :button :选择所有的按钮 :checkbox :选择所有的复选框 :hidden :选择隐藏的元素 实例 $(&quot;img:odd&quot;).css(&quot;border&quot;,&quot;thick double red&quot;);选择序号为奇数的img元素$(&quot;img:first&quot;).css(&quot;border&quot;,&quot;thick double red&quot;) 选择第一个img元素 JQuery对象的方法 context 选择元素时使用的上下文对象 $(&quot;img:odd&quot;).context.TagName; each(function()) 在每个选中的元素上运行给定的函数 123 $("img").each(function(index,elem)&#123; console.log(ele.TagName+" "+elem.id);//这里的index表示每一个元素的索引，elem表示每一个元素的htmlElement对象，并不是jquery对象&#125;) index(jquery) || index(selector) 返回给定jquery对象在住对象中的序号，或者返回给定选择器参数的索引 $(&quot;img&quot;).index(&quot;img[src=*astor]&quot;) length || size() 返回的时jquery对象个数 $(&quot;img:odd&quot;).length toArray() 返回一个有jquery对象中包含的htmlEelments数组 var content=$(&quot;img:odd&quot;).toArray() 这里content返回的htmlElements数组 把jquery当成数组12345var content=$("img:odd");for(var i=0;i&lt;content.length;i++)&#123; console.log(content[i].TagName+" "+content[i].src); //这里的content[i]就是htmlElement数组了，$(content[i])就变成了Jquery对象了&#125; add add函数允许我们添加更多的项，常用的有add(htmlElement[]),add(selector),add(jquery) 实例： 1234567$("img:odd").add("img:even").css("border",'thick double red');var jq=$("img[src*=astor]");$("img:even").add(jq).add("img:even").css("border",'thick double red');var label=document.getElementsByTagName("label");$("img:odd").add(label).css("border","thick double red"); slice() 用来获取特定的一组子元素 实例： 123$("img").slice(0,3).css("border","thick double red"); //获取0-2的元素 $("img").slice(3).css("border","thick double red"); //获取3-结束 filter filter可以将不满足指定条件的元素剔除，常用的方法有filter(jquery),filter(htmlElement),filter(function(index)),filter(selector) 实例 1234567891011121314 //这里填入的参数selector$("label").filter("[for*=p]").css("background-color",'blue').css("font-size",'20px').css("border","2px solid red"); $("img").filter(function (index) &#123; //index是每一个元素的索引，如果返回的是true就会选定，false就会剔除这个元素 if(index==4) &#123; return true; &#125; else return false; &#125;).css("border",'thick double red'); var elem=document.getElementsByTagName("label")[1]; //只选择第二个label $("label").filter(elem).css("font-size",'30px') //这里填入的参数是htmlElement对象 not not方法是filter方法的补充，主要是删除匹配条件的元素，而filter则是保留满足匹配条件的元素，常用的方法有not(selector),not(htmlElement),not(jquery),not(function(index)) 实例： 123456789$("label").not("[for*=p]").css("background-color",'red'); //选择for不带p的label元素 $("label").not(function (index) &#123; //哪个元素返回true就删除，false保留 if(index==0) return true; //这里就会删除第一个label元素，保留后面的元素 else return false; &#125;).css("background-color","yellow"); has 选择拥有指定后代的选择器 实例：1234$("div.dcell").has("img[src*=astor]").css("border","thick double red"); //选择子代拥有img属性src带有astor的div.dcell元素var s=$("[for*=astor]");$("div.dcell").has(s).css("border","thick double red"); //参数为jquery对象 map 以一个函数为参数，map方法能够帮助我们灵活的处理一个jquery对象，从而得到满足需要的一个jquery对象。针对源jquery对象中的每一个元素都调用一次这个函数，而函数返回的HtmlElement对象将会变成一个jquery对象，参数是function(index,elem),其中`index是序号，elem是jquery对象中的每一个HTMLElelments对象，这里必须要有返回值，不然没有意义 实例： 12345678910$("div.dcell").map(function(index,elem)&#123; return elem.getElementsByTagName("img")[0]; //这里的elem是$(div.dcell)中的每一个HtmlElement对象，返回的是img元素&#125;).css("border",'thick double red'); //可以很清楚的看到这里返回的htmlElement对象变成了Jquery对象，因为调用了函数css$("img").map(function(index,elem)&#123; if(index==1) return elem; //返回的是第二个img的HtmlElement对象，但是经过map的包装就会变成jquery对象&#125;).css("border",'thick double red'); //可以很清楚的看到这里返回的htmlElement对象变成了Jquery对象，因为调用了函数css is is方法确定jquery对象中的某个或者某些元素是否满足测试条件，其中的形式有is(selector),is(HtmlElement),is(jquery),is(function(index))如果结果集中至少有一个元素匹配指定的条件，那么就返回true,否则false 实例：1234567891011console.log($("img").is("[src*=astor]"));//这里是判断img中的src属性有没有astor字段的，如果存在返回true$("img").is(function(index)&#123;&#125;)var c=$("img").is(function (index) &#123; //函数中如果至少有一个返回true，那么就会返回true，index是索引 return this.getAttribute('src')=='rose.png'; //判断属性 &#125;); console.log(c); end 当我们调用方法链来修改结果集的时候，jquery维护者一个历史结果集的查找，我们可以利用end回退到历史的结果集中,end用来扔掉当前的结果集，返回到上一层结果集 实例： 1234$("img").filter("[src*=astor]").end().css("border",'thick double red'); //这里回退到$("img")这个结果集中$("div.dcell").find("img").filter(":odd").filter(":eq(0)").end().end().css("border",'thick double red'); //这里调用了两个end将结果集回退到$("div.dcell").find("img")中 addBack 得到当前结果集和上一个结果集的合集 实例 123456$("div.dcell").children("img").addBack().css("border",'thick double red');//这里得到的是$("div.dcell")和$("div.dcell").children("img")的合集，并且应用css$("img").slice(0,3).filter("[src*=astor]").addBack().css("border",'thick double red');//$("img").slice(0,3)和$("img").slice(0,3).filter("[src*=astor]")的合集//这里的选择器参数过滤的是原结果集，相当于$("img").slice(0,3).filter("[src*=daff]")，$("img").slice(0,3).filter("[src*=astor]").addBack("[src*=daff]").css("border",'thick double red'); children children是用来访问子元素的，形式有childern(),children(selector),其中第一个是用来得到结果集中所有的子元素，第二个是用来过滤得到的子元素，保留满足selector的子元素 实例： 123$("div.dcell").children().css("border",'thick double red');//得到所有div.dcell的子元素，包括其中的img和input元素$("div.dcell").children("img").css("border",'thick double red');//得到所有子元素中的img元素 find find是用来得到结果集中的所有的后代元素，这里是后代元素，并不是只有子元素，还包括孙子。。。，形式有find(),find(selector),find(htmlElement),find(jquery),find(htmlElment[])，这里会自动去掉含有重复的元素，因此可以用来过滤元素 实例 1234$("div.dcell").find("img"); //找到div.dcell的后代元素imgvar content=document.getElementsByTagName("input");$("div.dcell").find(content).filter(":first").css("font-size",'1.5em');//找到div.dcell后代元素中的input元素 parent 选取结果集中的父元素，这里表示一层关系就是父元素，并不是祖先元素，形式有parent(),parent(selector) 实例：123$("img").parent(); //选取img的父元素$("img").parent(":first"); //选取img父元素中的第一个元素 parents 选取祖先元素，包括父元素，形式有parents(),parents(selector) 实例：123456$("img").parents().each(function(index,elem)&#123; //选取所有的祖先元素 console.log(elem.TagName+" "+elem.id);&#125;)$("img").parents("div.dcell").css("border",'thick double red'); //选择所有的div.dcell元素 parentsUntil 选择祖先元素，知道找到这个当前祖先元素匹配参数选择器为止,parentsUntil(selector),parentsUntil(selector,selector)，其中带有两个参数选择器中的第二个参数是用来筛选所得到的结果集，第一个是用来定位直到这个元素为止 实例： 123$("img").parentsUntil("div.drow");//找img的祖先元素，直到div.drow为止，不包括div.drow $("img").parentsUntil("div.drow",":first").css("border",'thick double red'); //这里选择了结果集中的第一个元素应用了样式 closest 得到结果集中元素的祖先元素中匹配selector选择器最接近的那个祖先元素，形式为closest(selector),closest(selctor,context),closest(htmlElemtent),closest(jquery) 实例： 12345678910$("img").closest("div.drow").each(function (index,elem) &#123; //选择满足div.drow的祖先元素，这里的最接近就是辈分最接近，这里的两个class=drow的div都是最接近的，因为这俩个是同级的关系 console.log(elem.tagName+" "+elem.id); &#125;); var jq=$("#row1,#row2,form"); //传入jquery对象 $("img").filter("[src*=astor]").closest(jq).each(function (index,elem) &#123; //这里选取的是最接近第一张图的祖先元素，当然是&lt;div id="row1"&gt; console.log(elem.tagName+" "+elem.id); &#125;) offestParent 得到距离最近的祖先定位元素，使用fixed,absolute,relative定位的元素，形式为offestParent() siblings 得到所有的兄弟元素，可选的selector用来过滤结果，形式为siblings(),siblings(selector) 实例： 123$("img").siblings().css("font-size",'1.4em');// 得到img的所有兄弟元素，这里是input$("img").siblings(":last"); //得到img所有兄弟元素中的最后一个元素 prev 得到上一个兄弟元素，形式为prev(),prev(selector)，其中的selector是用来过滤结果的 实例： 1$("input").prev().css("border",'thick double red'); //这里得到input的上一个元素Label元素 prevAll 得到当前元素的所有的上面的兄弟元素，形式为prevALl(),prevAll(selector) 实例： 123$("input").prevAll().css("border",'thick double red'); //得到input上面的所有的兄弟元素$("input").prev("img").css("border",'thick double red'); //得到input上面的所有的img元素 prevUntil 这个和parentsUntil一样，直到匹配selector就结束了，不包括 实例： 1$("input").prevUntil("i").css("border",'thick double red'); next 选择当前元素下面的一个兄弟元素，和prev一样 nextAll 选择当前元素下面的所有兄弟元素，和prevAll一样 nextUntil 和prevUntil一样 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL干货篇三]]></title>
      <url>%2F2017%2F04%2F16%2FSQL%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B8%89%2F</url>
      <content type="text"><![CDATA[SQL干货篇三创建视图 create view &lt;视图名&gt;[(列名),(列名)...] as &lt;子查询&gt; [with check option] 子查询可以是select语句或者包含order by子句，具体情况而定，视图名是一定要有的，列名可以省略，如果省略的话则是由子查询中的目标列的相关字段组成，当然也可以自己指定，with check option表示如果视图或者参照表执行insert,update,delete时，那么视图或者参照表会随着变化，也就是两个绑定在一起的意思，当然也可以选择不用，那么视图的增删改就和参照表没有关系了实例建立在一个表上12create view IS_student as select Sno,Sname,Sage where Sdept='IS'with check option ; /*将所有的IS系的学生学号建立一个视图IS_student,其中的列名是Sno,Sname,Sage*/ 建立在多个表上123create view IS_Grade(Sno,Sname,Grade) as select student.Sno,Sname,Grade from student,SCwhere Sdept='IS' and student.Sno=SC.Sno; /*建立在两个表上的视图，可以看出这里已经指出指定的列名，但是这个列名并不是固定的，可以根据具体的含义来指定*/ 定义一个带有表达式的视图123create view BT_S(Sno,Sname,Sbirth) as select Sno,Sname,2014-Sage from student /*这里的2014-Sage是用来计算出生日期的*/with check option; 聚集函数的视图12create view BT(Sno,Gavg) as select Sno,AVG(Grade) from SC Group by Sno; /*这里的AVG(Grade)是用来计算平均成绩的，Group by是用来根据学号分组，这里就是求同一个人的多门学科的平均成绩*/ 删除视图 Drop view &lt;视图名&gt;&lt;CASCADE],这里的CASCADE表示如果还导出了其他的视图，那么加上CASCADE就会全部删除 实例 Drop view IS_Sdept; 删除视图 Drop view IS_Sdept CASCADE; 删除视图和其导出视图 查询视图 查询视图和查询表是一样的，请参照我前两章讲的SQL语法 更新视图 视图的更新包括insert,delete,update,这个和基本表的操作是一样的 注意： 并不是所有的视图都可以更新的,比如上面根据学生多科平均成绩建立的视图，这里如果将视图中的平均成绩更新了，那么参照表的数据就不能对应的更新了，这就会不允许更新，当然这是在添加了with check option语句的情况下 如果添加了with check option语句,那么对视图的更新就会对应转换成对基本表的更新 各个系统对视图的更新还有进一步的规定，比如DB2规定： 如果视图是由两个以上的基本表导出，那么就不可以更新 如果视图来自字段或者表达式，那么就不允许对此视图执行insert,update,但是可以执行delete 如果定义中有order by子句，那么不可以更新视图 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java连接mysql初探篇]]></title>
      <url>%2F2017%2F04%2F16%2Fjava%E8%BF%9E%E6%8E%A5mysql%E5%88%9D%E6%8E%A2%E7%AF%87%2F</url>
      <content type="text"><![CDATA[java连接mysql基本连接 加载驱动: Class.forName(com.mysql.jdbc.Driver) 建立连接:Connection conn=DriverManager.getConnection(url,user,password) 其中url=&quot;jdbc:mysql://localhost:3306/java_demo&quot;,这里的java_demo是自己创建的数据库的名字,user是mysql数据库的管理员，password是密码下面直接连接数据库，返回的是接口Connection对象 1234567891011121314151617181920212223242526import java.sql.*;public static Connection getConnection()&#123; Connection conn; String driver="com.mysql.jdbc.Driver"; //驱动名称 String url="jdbc:mysql://localhost:3306/java_demo"; //url String user="root"; String password="root"; //管理员和密码都是root try&#123; Class.forName(driver); //加载驱动，但是会有ClassNotFoundException异常，因此要避免异常 try&#123; conn = Dri verManager.getConnection(url, user, password); //获得数据库连接 return conn; //返回conn &#125;catch(SQLException e) &#123; e.printStackTrace(); &#125; &#125;catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return null; //如果出现异常就会返回null &#125; 查询数据 **首先根据所得的Connection对象创建Statement对象：Statement statement = connection.createStatement(); 写查询语句：String sql=&quot;select * from student;&quot;这里是查询所有student中的数据，详细内容请看我的SQL干货篇二 创建ResultSet对象存储查询结果:ResultSet res=statement.executeQuery(sql),详细的内容请看官方文档ResultSet详细用法 代码1234567891011String sql="select * from student";if(!conn.isClosed())&#123; Statement statement=conn.createStatement(); //这里的conn是上面连接数据库的返回的Connection对象 ResultSet res=statement.executeQuery(sql); //执行查询，注意这里只能是executeQuery，Statement还有一些执行mysql函数，但是都不适合查询，后面会详细说 while(res.next()) //如果res结果中还有元素，那么返回true，否则返回的是false,用来判断是否res中还有结果 &#123; int id=res.getInt("id"); //得到id,这里的id是student表中的属性名 对应的时int BigInt smallint..... String name=res.getString("name"); //得到姓名，对应的是mysql中的Char varChar类型 &#125;&#125; 当然上面只是对于基本的查询数据，在一些项目中根本用不到，因为不太灵活，上面的方法只适合全局查询，并不适合在项目中根据条件查询，下面介绍预编译sql语句的接口PrepareStatement 首先编写sql语句:sql=&quot;select * from student where id=?;&quot;;,这里的?表示一个占位，将条件在后面给出，但是这里一定要用? 创建对象：PrepareStatement pre=conn.preparestatement(sql);这里传入参数sql 设置sql中的条件语句，填补占位?的值:pre.setInt(1,1);这里的SetInt设置id值的为1，因为这的id是int类型的，第一个参数是表示prepareindex，就是表示第一个占位?,当然第二个就是2,其中还有SetString(prepareindex String var),用来给定表中的char后者varchar类型的值 代码：1234567891011121314if(!connection.isClosed()) &#123; String sql="select * from course where id=?,name=?"; PreparedStatement preparedStatement=connection.prepareStatement(sql); preparedStatement.setInt(1,1); //给定条件中的值 prepareStatement.setString(2,"jack"); //为第二个？赋值 ResultSet res=preparedStatement.executeQuery(); //执行查询，返回的仍然是ResultSet对象 while(res.next()) &#123; int id=res.getInt("id"); String name=res.getString("name"); System.out.println(id+"--"+name); &#125; &#125; 插入数据 插入数据和上面的两种方法基本是一样的，不同的是mysql语句不同，还有的就是执行语句改成了executeUpdate(sql)，下面的代码值给出了预编译对象的方法，另外一种的方法使用范围并不是很大，只要把上面的查询改为executeUpdate即可 代码：1234567891011121314151617181920212223242526272829303132public static int save(MemoBean memo) &#123; String sql = "insert into student (username, title, content, momotype, memotime) values (?, ?, ?, ?, ?);"; Connection conn = getConnection(); PreparedStatement ps = null; try &#123; ps = conn.prepareStatement(sql); ps.setString(1, memo.getUsername()); //设值value中的值 ps.setString(2, memo.getTitle()); ps.setString(3, memo.getContent()); ps.setString(4, memo.getMemotype()); ps.setString(5, memo.getMemotime()); return ps.executeUpdate(); //这里使用的是excuteUpdate &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; if (ps != null) &#123; try &#123; ps.close(); //关闭预编译对象 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); //关闭Connection对象 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return -1; //没有插入成功返回-1 &#125; 更新数据 这里是同样的思路，和插入的基本是一样，只需要改变sql语句即可 代码：1234567891011121314151617181920212223242526272829303132333435363738public static int update(MemoBean memo) &#123; String sql = "update student set username=?,title=?,content=?,momotype=?,memotime=? where id=?;";//查询语句 Connection connection = getConnection(); PreparedStatement ps = null; try &#123; ps = connection.prepareStatement(sql); ps.setString(1, memo.getUsername()); //设置条件语句中的值 ps.setString(2, memo.getTitle()); ps.setString(3, memo.getContent()); ps.setString(4, memo.getMemotype()); ps.setString(5, memo.getMemotime()); ps.setInt(6,memo.getId()); return ps.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; if(ps!=null) &#123; try &#123; ps.close(); &#125;catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(connection!=null) &#123; try &#123; connection.close(); &#125;catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return -1; &#125; 最后说 上面的代码是从自己项目中截取的一部分代码，这个是比较适用于面向对象的，也是最常用的对于目前来看 上面只是给出了查询，插入，更新，因为这是最常用到的方法，其中还有创建表，删除表，当然还有一些他的，这里的创建表直接用execute(sql)即可执行，删除表也是用execute(sql)即可执行，当然如果要按照指定的条件删除，那么可以使用预编译对象执行 其中executeUpdate(sql)适用于create,insert,update,delete,但是executeQuery(sql)适用于select,具体见官方文档 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux干货篇一]]></title>
      <url>%2F2017%2F04%2F13%2FLinux%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B8%80%2F</url>
      <content type="text"><![CDATA[Linux干货篇一虚拟机的安装(VMware) 选择文件-&gt;新建虚拟机 选择自定义 设置安装来源，选择稍后安装 选择安装的操作系统，选择Linux,然后选择自己安装的对应版本即可 设置虚拟机的安装路径，自己选择 指定磁盘容量，选择默认20G,然后选择将虚拟磁盘存储为单个文件 设置cpu数量，内存大小，默认即可 设置Linux安装镜像文件路径 点击开启虚拟机即可根据对应的设置安装 目录文件 /boot:存放系统引导时所需要的文件，包括Linux内核以及引导程序(BootLoader) /bin:存放可执行程序 /etc:存放系统配置文件 /home:普通用户的主目录所在位置 /lib:存放基本的共享文件和内核模块 /mnt(mount):用户为需要挂载的文件系统提供挂载点 /proc(process):存放与内核进程有关的信息 /root:根用户的主目录 /tmp(temporary):存放临时性文件 /usr(user):存放可共享的只读文件 /var(variable):存放各类的数据文件 ls重要选项 -a(all) 列出目录中的所有项，包括”.”开头的隐藏文件 -l(list) 以列表的方式显示文件 -R(recursive) 用于递归列出子目录中的内容，如果在选择的目录下还有子文件夹，那么可以列出子文件夹中的文件 -d仅仅列出目录本身的信息实例 ls -al /etc 以列表的方式列出ect目录下的所有文件 pwd 显示当前路径cd(切换目录) cd .. 跳闸到当前目录的上一级 cd ~ 跳转到当前用户的主目录 例子 cd /tmp/testdir 跳转到tmp文件下的testdir目录 stat 获取关于某文件的基本信息，包括创建的信息，大小，时间。。。。 实例 stat test 查看test文件的基本信息 touch 创建或者更新一个文件的访问和修改的时间，如果一个文件存在，那么更新这个文件的创建时间，但是文件的内容不会改变，如果文件不存在，那么就会在当前目录下创建一个文件 实例 touch /tmp/testdir/test 在指定路径下创建一个test文件，如果存在那么会更新创建的时间，可以使用stat命令查看创建时间 mkdir(创建目录) mkdir /tmp/testdir/test_file 在/tmp/testdir目录下创建一个test_file文件夹 mv 移动或者重命名文件或目录 重要选项 b(backup):若存在同名文件，覆盖前先备份原来的文件 f(force):强制覆盖同名的文件 实例12345mkdir /tmp/testdir //创建一个目录testdirtouch test1 test2 //创建两个文件test1 test2mv -b test1 test2 //移动test1为test2,这里会先备份原来的test2为test2~mv -b test1 /tmp/testdir1/test //移动文件到指定目录下 cp(copy) 复制文件和目录 选项 -b: 若存在同名文件，覆盖前先备份 -f :强制覆盖同名文件 -r : 以递归的方式复制文件，就是复制文件夹，如果不使用这个，那么文件夹就无法复制 实例 cp /tmp/testdir tmp/testdir1 复制文件夹，这里表示不能复制，因此要加上-r选项才能复制文件夹 -&gt; cp -r /tmp/testdir /tmp/testdir1 可以复制，复制到/tmp文件夹下命名为testdir1 cp -b /tmp/testdir/test1 /tmp/testdir1/test 将文件test1复制到testdir1文件夹下命名为test rm 删除命令 选项 -f 强制删除 -r 删除文件夹（递归删除） 实例 rm -rf /tmp/testdir 强制删除testdir目录 rmdir 删除目录，但是要求目录必须是空的，这里实用性不大，一般用rm -r cat 查看文件内容 重要选项 -n 显示行数 实例 cat -n /tmp/testdir/test 查看文件test的内容，显示行数 more 分屏显示文件内容，首先显示一屏后如果还有内容，按回车键在显示下一行，按Space显示下一屏的内容 实例 more /tmp/testdir/test tail 显示文本文件结尾的部分，默认显示最后10行 重要选项 -n 指定显示的行数 head 显示开头的内容，与tail类似 wc 一次显示文本文件的行数，单词数，字节数 重要选项 -c 显示文件字节数 -l(line) 显示文件行数 -w(word) 显示文件单词数 实例 wc -cl /tmp/testdir/test 查看文件的字数和文件的行数 date查看或者修改系统命令 实例 date 查看系统时间 date 09012017 修改系统时间为2017-09-01 who列出当前系统的登录用户 重要选项 -r 显示系统当前的运行级 -q 显示当前所有登录的用户名称和在线人数 shutdown关闭重启系统 重要选项 -r(reboot) 重启系统 -h(halt) 关闭系统 -P(poweroff) 关闭系统同时关闭电源 注意上面选项均可给出数字参数指定多少分钟之后执行操作 实例 shutdown -h 10 设置10分钟后关闭系统 clear清楚当前终端的屏幕内容 man显示命令的使用手册，按上下键移动光标，Q键退出 实例 man cat 快速查询cat命令的手册 histroy查看shell命令的历史记录 实例 histroy 5 显示最近的5条记录 vim调用vim编辑器，按i键插入，w键保存，q键退出，wq保存后退出 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL干货篇二]]></title>
      <url>%2F2017%2F04%2F09%2FSQL%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[SQL干货篇之查询数据单表查询 只在一个表中查询数据1SELECT * FROM student where Sno='13143'; //根据学号查询数据 多表查询 同时查询多个表12SELECT student.Sno,student.Sname,GradeFROM student,SC where Grade&gt;=90; 说明：这是在学生表student和成绩表SC中查询成绩大于90的学生姓名和学号,因为这里Sno,Sname在两个表中都存在，因此要指定查询哪一个表中的数据，而Grade只在SC表中出现，因此不用指明哪张表 模糊查找 说明：模糊查找用like和not like进行查找 SELECT * FROM student where Sname like &#39;刘%&#39;;查询所有姓刘的学生 SELECT * FROM student where Sname like &#39;%加%&#39;查询名字中含有加字的学生信息，不固定加字的位置，在任意位置都能查到，这里一般搜索引擎都用是用这种模糊查找的方法来匹配搜索项 SELECT * FROM student where Sname like &#39;欧阳_&#39;;查找以姓欧阳并且名字为三个字的学生信息 SELECT * FROM student WHERE Sname like &#39;_阳&#39;;查找所有姓名为两个字并且第二个字为阳的学生信息 SELECT * FROM student where Sname like &#39;_阳%&#39;;查询所有姓名中第二个字为阳的学生信息 SELECT * FROM Course where Cname like &#39;\_IS&#39; ESCAPE &#39;\&#39;;查询课程名字为_is的课程信息，这里如果要查询的字符串本省就含有通配符”%“或者”_“，这时就要使用ESCAPE&lt;转码字符&gt;来对字符进行转义了，这里的转码字符可以是任意的，但是我们通常都是用\,上面的查询语句中的\就是转码字符 空值查询 判断数据是否为空用is not null和is nullSELECT * FROM student where Sname is null;查询姓名为空的学生信息 多重条件的查询 多重条件的查询用AND和OR,其区别不用多说了SELECT Sname FROM student where Sdept=&#39;IS&#39; and Sage&gt;20;查找院系是IS并且年龄超过20岁的学生姓名 ORDER BY子句(排序) 用户可以使用ORDER BY子句对数据进行升序(ASC)或者降序(DESC)排列 SELECT * FROM student where Sage&gt;20 ORDER BY Sno DESC;查询年龄超过20岁的学生信息，并且按照降序排列输出 SELECT * FROM student ORDER BY Sdept,Sage DESC;查询全体学生情况，查询结果按照所在系的系号升序排列，同一系的按照年龄降序排列 聚集函数 COUNT(*) 统计元组个数 COUNT(DISTINCT|ALL &lt;列名&gt;) 计算一列中值的个数，其中DISTINCT表示去除重复的元素，ALL则保留所有的元素 SUM(DISTINCT|ALL &lt;列名&gt;) 计算一列值的总和 AVG(DISTINCT|ALL&lt;列名&gt;) 计算一列中的平均值 MAX(DISTINCT|ALL&lt;列名&gt; ) 求一列中的最大值 MIN(DISTINCT|ALL&lt;列名&gt; ) 求一列中的最小值 实例： select count(*) from student; 查询学生总数 select count(DISTINCT Sdept); 查询总共有多少系 select AVG(Grade) from SC; 查询学生的平均分 select SUM(Grade) from SC; 查询学生的总分 select MAX(Grade) from SC where Cno=&#39;1&#39;; 查询课程1的最高分 select MIN(Grade) from SC where Cno=&#39;1&#39;; 查询课程1的最低分 注意：where子句中不能用聚集函数，只有在select子句和Group by子句中才能使用聚集函数 GROUP BY子句 GROUP BY子句将查询结果按某一列或者多列的值分组，值相等的为一组。 对查询结果分组的目的是为了细化聚集函数的对象。如果未对查询结果进行分组，那么聚集函数将会作用于整个查询结果，分组后聚集函数将会作用于每一组，即每一组都有一个函数值 实例： select Cno,Count(Sno) from SC Group by Cno; 求各个课程号以及相应的选课人数 select Cno as &#39;课程号&#39;,count(Sno) as &#39;选课人数&#39; from sc group by Cno;求各个课程号以及相应的选课人数 select Cno,count(Sno),AVG(Grade) from sc group by Cno Having AVG(Grade)&gt;80; 查询课程平均分大于80分的课程号和所选学生人数,这里是先分组后然后对这些组进行筛选就用Having子句进行条件筛选，不能使用where子句进行筛选,当然这里的sleect子句中的AVG(Grade)可以去掉,可以写成select Cno,count(Sno) from sc group by Cno Having AVG(Grade)&gt;80; select Sno from sc Group by Sno having count(*)&gt;2; 查询选修了两门以上课程的学生学号 select Sno,AVG(Grade) from sc Group by Sno; 查询每一个学生选修课程的平均成绩,这里先按照学号进行分组，然后对每一个分组进行求平均成绩 注意：这里的如果使用了聚集函数，那么select子句中出现的选项一定要在聚集函数或者Group by子句中出现，否则就会出现错误，如：select Sno,count(Cno) from sc;这条语句就是错误的，因为Sno没有出现在聚集函数或者Group by子句中，如果改成select Sno,count(Cno) from SC Group by Sno;就正确了,因为Sno出现在了Group by子句中了 连接查询 如果一个查询涉及两个以上的表则称之为连接查询，连接查询包括等值连接查询，自然连接查询，自身连接查询，非等值连接查询，外连接查询，复合条件查询 等值和非等值连接查询当连接运算符为=时为等值连接查询，否则为非等值连接查询 实例： select student.*,SC.* from student,SC where student.Sno=SC.Sno;查询每个学生及其选修课程的情况 自然连接查询在等值连接的基础上去掉相等的属性组就是自然连接查询 实例：select student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade from student,SC where student.Sno=SC.Sno; 嵌套查询 在SQL语言中一个SELECT-FROM-WHERE语句称为一个查询块，将一个查询块嵌套在另外一个查询块的WHERE子句或HAVING短语的条件查询称之为嵌套查询实例：12SELECT SNAME FROM STUDENT WHERE SNO IN /*外层查询*/(SELECT SNO FROM SC WHERE CNO='2'); /*内层查询或者子查询*/ 注意: 这里的查询条件Sno只能有一个，并且外层查询的where子句中出现的Sno属性要和内层查询select语句中的Sno属性要对应。 子查询中不能使用ORDER BY子句，ORDER BY子句只能对最终的查询结果排序 带有IN谓词的嵌套查询 实例： 12345678910SELECT Sno,Sname,Sdept from student where Sdept IN(SELECT Sdept From student Where Sname='刘晨');``` **查询与刘晨在同一个系的学生信息,当然本例中也可以用自身连接查询来完成，如下：**```sqlselect first.Sno,first.Sname,first.Sdept from student first,student secondwhere first.Sdept=second.Sdept and second.Sname='刘晨'; 带有比较运算符的子查询12select Sno,Cno from sc x where Grade &gt;(select AVG(Grade) from sc y where x.Sno=y.Sno); 查询了所有学生成绩超过选修课程平均成绩的课程号 带有ANY或者ALL的谓词子查询 ANY表示查询条件只要满足其中一个即可，而ALL表示查询条件要满足所有的才行实例： SELECT SNAME,SAGE FROM STUDENT WHERE SAGE&lt;ANY(SELECT SAGE FROM STUDENT WHERE SDEPT=&#39;CS&#39;) AND SDEPT!=&#39;CS&#39;;查询非计算机系的比计算机系任意一个学生年龄小的学生姓名和年龄,这里只要满足比一个学生的年龄小即可 SELECT SNAME,SAGE FROM STUDENT WHERE SAGE&lt;ALL(SELECT SAGE FROM STUDENT WHERE SDEPT=&#39;CS&#39;) AND SDEPT!=&#39;CS&#39;;查询非计算机系的比计算机系的所有学生年龄小的学生信息，这里要满足比所有的学生信息都要小，就是比计算机系年龄最小的都要小 带有EXISTS谓词的子查询 EXISTS表示存在的意思，带有EXISTS的子查询步返回任何的数据，只产生逻辑真或者假 SELECT Sname From student where EXISTS (SELECT Sname from SC where Sno=student.Sno and Cno=&#39;2&#39;);查询选择课程2的学生姓名，这里只判断是否存在这样的学生，如果子查询中没有找到课程2这项，那么查到的就是空,子查询只判断是否为true or false,当然还有NOT EXISTS 集合查询 集合操作包括并操作UNION、交操作INTERSECT、差操作EXCEPT 实例： select * from student where Sdept= &#39;CS&#39; UNION select * from student where Sage&gt;19;查找计算机系的学生以及年龄不大于19岁的学生信息，这里UNION会自动去掉重复的元组，如果想要保留全部的数据需要用UNION ALL select Sno from SC where Cno=&#39;1&#39; UNION select Sno from SC where Cno=&#39;2&#39;;查询选修课程1或者选修课程2的学生学号，这里并集就是去掉重复的元组，使用UNION ALL 可以保留 select Sno from SC where Cno=&#39;1&#39; Intersect select Sno from SC where Cno=&#39;2&#39;;查询同时选修课程1和课程2的学生学号 基于派生表的查询123select Sno,Cno from SC,(select Sno,AVG(Grade) from SC Group by Sno) AS AVG_SC(avg_Sno,avg_grade)where SC.Sno=AVG_SC.avg_Sno and SC.Grade&gt;=AVG_SC.avg_grade; 这里的From子句中将会派生出一个AVG_SC表,该表由avg_Sno、avg_grade组成，主查询将SC表和AVG_SC表进行连接，选出修课成绩大于其平均成绩的课程号 注意：如果子查询中没有聚集函数，那么派生表不用指定属性列，子查询后面的列名为其属性，如下： select Sname from student,(select Sno From SC where Cno=&#39;1&#39;) AS SCI where student.Sno=SCI.Sno;这里的SCI默认的列属性名是Sno，AS关键词可以省略，但是必须要为派生表指定一个别名。 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java干货篇之文字特效]]></title>
      <url>%2F2017%2F04%2F09%2Fjava%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B9%8B%E6%96%87%E5%AD%97%E7%89%B9%E6%95%88%2F</url>
      <content type="text"><![CDATA[java干货篇文字特效立体效果的文字主要使用了Graphics类中的setFont和setColor的方法，绘制多层字然后加上平移一个坐标即可实现多重叠加的效果,让人看起来就像是立体一样,详情请见源码 阴影效果的文字和面一样，只是平移的方式有些不同，详情请见源码 倾斜效果的文字主要使用的时Graphics2D类的shear方法，使绘图上下文倾斜，详情见源码public abstract void shear(double shx,double shy)其中shx表示在正x轴方向移动坐标的乘数，可以作为其y坐标的函数 渐变效果的文字主要使用了Graphics2D中的setPaint的方法,详情请见源码public abstract void setPaint(Paint paint)paint封装了渐变颜色的Paint对象其中Paint对象的创建是由GradientPaint初始化的,其中的构造函数如下：GradientPaint(float x1, float y1, Color color1, float x2, float y2, Color color2) 会变色的文字这个主要使用了多线程的方式实现的，用多线程改变Color方法中的RGB的值,用Random在指定范围内任意取值然后组成了不同的颜色，详情请见源码 水印文字特效(源码)水印文字主要通过改变了文字的透明度实现的，将文字绘制在图片上，然后改变图片的透明度，主要使用了Graphaics2D中的setComposite方法，定义如下：public abstract void setComposite(Composite comp)，其中Comp是AlphaComposite对象，可以使用以下两种方式创建 AlphaComposite alpha=AlphaComposite.getInstance(AlphaComposite.SRC_OVER,0.3f)获得一个SRC_OVER规则的对象 AlphaComposite alpha=AlphaComposite.SC_OVER.driver(0.3f)同上 动态绘制文本(源码)主要使用BufferedReader缓冲流从指定文件中读取一个字符，然后使用线程一个一个的绘制在画板上，中间sleep了400ms，这样就能展示出动态的效果，还使用了System类的getProperty方法获得项目的路径,以下提供了两种方法读取文件，更多的读取方法请看我的博客文章 BufferedReader read=new BufferedReader(new FileReader(pathname)) BufferedReader read=new BufferedReader(new InputStreamReader(in)) 由于都是比较简单的代码，这里不再贴出来le，有想要看的朋友，请点击上面的源码 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[swing干货系列之JTextField]]></title>
      <url>%2F2017%2F04%2F08%2FSwing%E5%B9%B2%E8%B4%A7%E7%B3%BB%E5%88%97%E4%B9%8BJTextField%2F</url>
      <content type="text"><![CDATA[Swing系列之JTextField(单行文本框)介绍 JTextField是一个轻量级组件，它允许编辑单行文本。 JTextField 具有建立字符串的方法，此字符串用作针对被激发的操作事件的命令字符串。java.awt.TextField 把字段文本用作针对 ActionEvent 的命令字符串。如果通过 setActionCommand 方法设置的命令字符串不为 null，则 JTextField 将使用该字符串来保持与 java.awt.TextField 的兼容性，否则将使用字段文本来保持兼容性。 setEchoChar 和 getEchoChar 方法不是直接提供的，以避免可插入的外观的新实现意外公开密码字符。为了提供类似密码的服务，单独的类 JPasswordField 扩展了 JTextField，从而通过可插入外观独立地提供此服务。 JTextField 的水平对齐方式可以设置为左对齐、前端对齐、居中对齐、右对齐或尾部对齐。右对齐/尾部对齐在所需的字段文本尺寸小于为它分配的尺寸时使用。这是由 setHorizontalAlignment 和 getHorizontalAlignment 方法确定的。默认情况下为前端对齐。 文本字段如何使用 VK_ENTER 事件取决于文本字段是否具有任何操作侦听器。如果具有操作侦听器，则 VK_ENTER 导致侦听器获取一个 ActionEvent，并使用 VK_ENTER 事件。这与 AWT 文本字段处理 VK_ENTER 事件的方式是兼容的。如果文本字段没有操作侦听器，则从 1.3 版本开始不使用 VK_ENTER 事件。而是处理祖先组件的绑定，这将启用 JFC/Swing 的默认按钮特性。 Swing 不是线程安全的 构造函数 JTextField() 构造一个新的 TextField JTextField(Document doc, String text, int columns) 构造一个新的 JTextField，它使用给定文本存储模型和给定的列数。 JTextField(int columns) 构造一个具有指定列数的新的空 TextField。 JTextField(String text)构造一个用指定文本初始化的新 TextField。 JTextField(String text, int columns) 构造一个用指定文本和列初始化的新 TextField。 常用的函数 get/setHorizontalAlignment(int alignment) 设置/得到文本的水平对齐方式。其中水平的对齐方式有：JTextField.LEFT JTextField.CENTER JTextField.RIGHT JTextField.LEADING (the default) JTextField.TRAILING setFont(Font font) 设置字体 setScrollOffset(int scrollOffset) 获取滚动偏移量（以像素为单位）。 setDocument(Document doc) 将编辑器与一个文本文档关联，这里的意思就是将此文本框与一个文本文档关联，这将会保持内容一致，如果一个改变了，另外一个也会改变。 setInputVerifier(verifier) 设置验证方式，如果此文本不能通过验证那么就不能将焦点聚焦到下一个组件上，就会一直聚焦到这个文本框上 setDragEnabled(boolean x) 设置在文本框中是否能够拖放文本,为true则是能够，这里的意思就是能够将文本选中后能不能将文本拖走 addActionListener(ActionListener action) 添加监听机制，输入文本按回车即可触发，和按钮的监听机制相同 write(InfileWriter writer) 将文本框中的内容输入到文件中 addKeyListener(KeyListener event) 添加键盘监听，在文本框中输入内容时会触发键盘，其中有按下，释放，键入的动作，详情见官方文档 addCaretListener(CareListener event) 添加一个侦听文本组件插入符的位置更改的侦听器，只要鼠标指针的位置改变就会触发 一个简单的实例1234567891011121314151617181920212223242526272829303132333435363738394041import javax.swing.*;import java.awt.*;class text extends JFrame &#123; private JTextField textField1; private JTextField textField2; public static void main(String args[]) &#123; text my = new text(); my.setVisible(true); &#125; public text() &#123; //this.setBounds(100,100,300,200); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JPanel panel = new JPanel(new GridLayout(2, 1)); textField1 = new JTextField(10); textField2 = new JTextField(); panel.add(textField1); panel.add(textField2); this.getContentPane().add(panel, BorderLayout.CENTER); this.pack(); InputVerifier verifier = new InputVerifier() &#123; //添加验证方式 @Override public boolean verify(JComponent input) &#123; //重载函数 boolean value; textField1 = (JTextField) input; //将input组件强制转化为JTextField类型的单行文本框 return textField1.getText().equals("pass"); //判断是否输入的时pass,如果不是就会验证错误 &#125; &#125;; textField1.setInputVerifier(verifier); //设置验证方式 textField1.setHorizontalAlignment(JTextField.CENTER); //设置水平对齐方式 Font font = new Font("楷体", Font.BOLD + Font.ITALIC, 20); textField1.setFont(font); //设置字体 textField1.setDragEnabled(true); //设置在单行文本框中能够拖放文本，如果为false则不能够拖放文本 &#125;&#125; 关联文本文档123456789101112131415161718192021222324252627282930313233343536import java.awt.Container;import java.awt.GridLayout;/*from w ww.jav a 2s . co m*/import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JTextField;import javax.swing.text.Document;public class Main extends JFrame &#123; JLabel nameLabel = new JLabel("Name:"); JLabel mirroredNameLabel = new JLabel("Mirrored:"); JTextField name = new JTextField(20); JTextField mirroredName = new JTextField(20); public Main() &#123; this.setDefaultCloseOperation(EXIT_ON_CLOSE); this.setLayout(new GridLayout(2, 0)); Container contentPane = this.getContentPane(); contentPane.add(nameLabel); contentPane.add(name); contentPane.add(mirroredNameLabel); contentPane.add(mirroredName); Document nameModel = name.getDocument(); //得到文本框的文本文档，将之与第二个文本框关联 mirroredName.setDocument(nameModel); //两个文本框中的内容相互关联，这样只需要在一个里面输入文本，同时也会在另外一个文本框中显示 pack(); setVisible(true); &#125; public static void main(String[] args) &#123; Main frame = new Main(); &#125;&#125; 说明：这里是将两个文本框相关联，这样就能达到一个文本框输入的同时，另外一个也会同时更新内容 Action Listener(动作监听机制)输入文本后按回车即可触发123456789101112131415161718192021222324252627import java.awt.event.ActionEvent;//from w w w. ja va2s .c o mimport javax.swing.JFrame;import javax.swing.JTextField;public class Main &#123; public static void main(String[] a) &#123; JFrame frame = new JFrame(); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JTextField jTextField1 = new JTextField(); jTextField1.setText("jTextField1"); //添加监听机制 jTextField1.addActionListener(new java.awt.event.ActionListener() &#123; public void actionPerformed(ActionEvent e) &#123; System.out.println("action"); &#125; &#125;); frame.add(jTextField1); frame.setSize(300, 200); frame.setVisible(true); &#125;&#125; 验证文本内容使用InputVerifier)验证 12345678910111213141516171819202122232425262728293031import java.awt.BorderLayout;import javax.swing.InputVerifier;import javax.swing.JComponent;import javax.swing.JFrame;import javax.swing.JTextField;public class Main &#123; public static void main(String args[]) &#123; JFrame frame = new JFrame("Verifier Sample"); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JTextField textField1 = new JTextField(); JTextField textField2 = new JTextField(); InputVerifier verifier = new InputVerifier() &#123; //创建一个验证 public boolean verify(JComponent comp) &#123; boolean returnValue; JTextField textField = (JTextField) comp; //强制转换，将控件类型的comp转换成JTextFiled类型的 try &#123; Integer.parseInt(textField.getText()); //将输入的内容转化程int类型，如果输入的字符串不是十进制的话就会触发 //NumberFormateException错误 returnValue = true; &#125; catch (NumberFormatException e) &#123; returnValue = false; &#125; return returnValue; //如果返回false的话，那么指针就会一直聚焦在此文本框中，不能移动到其他的组件上 &#125; &#125;; textField1.setInputVerifier(verifier); frame.add(textField1, BorderLayout.NORTH); frame.add(textField2, BorderLayout.CENTER); frame.setSize(300, 100); frame.setVisible(true); &#125;&#125; 说明：如果返回false的话，那么指针就会一直聚焦在此文本框中，不能移动到其他的组件上 将文本框中的内容保存到文件中12345678910111213141516171819202122232425262728293031323334353637383940414243444546import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.io.File;import java.io.FileWriter;import java.io.IOException;class Main extends JFrame &#123; private JTextField textField; private FileWriter writer; public static void main(String args[]) &#123; Main my = new Main(); my.setVisible(true); &#125; public Main() &#123; this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JPanel panel = new JPanel(new BorderLayout()); JButton button = new JButton("运行"); JLabel label = new JLabel("name"); textField = new JTextField(); panel.add(label, BorderLayout.WEST); panel.add(textField, BorderLayout.CENTER); String filename = "text.txt"; button.addActionListener(new ActionListener() &#123; //添加一个按钮触发装置，这里只要点击一下anniu就会将文本框中的内容输入到文件中 @Override public void actionPerformed(ActionEvent e) &#123; try &#123; writer = new FileWriter(filename, false); //创建一个写入文件的对象，这里的false表示不在文件的末尾添加 textField.write(writer); //将单行文本中输入的内容写入到文件中 writer.close(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); System.out.println("false"); &#125; &#125; &#125;); panel.add(button, BorderLayout.SOUTH); this.getContentPane().add(panel, BorderLayout.CENTER); this.pack(); &#125;&#125; 说明：这里使用的是FileWriter类将内容写入到文件中，详情请看我的上一篇文章 复制、粘贴、剪切文本 这里使用的时copy()、paste()、cut()函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.awt.FlowLayout;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JTextField;import javax.swing.event.CaretEvent;import javax.swing.event.CaretListener;public class Main &#123; public static void main(String args[]) &#123; final JTextField textField = new JTextField(15); JButton buttonCut = new JButton("Cut"); JButton buttonPaste = new JButton("Paste"); JButton buttonCopy = new JButton("Copy"); JFrame jfrm = new JFrame("Cut, Copy, and Paste"); jfrm.setLayout(new FlowLayout()); jfrm.setSize(230, 150); jfrm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); buttonCut.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent le) &#123; textField.cut(); &#125; &#125;); buttonPaste.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent le) &#123; textField.paste(); &#125; &#125;); buttonCopy.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent le) &#123; textField.copy(); &#125; &#125;); textField.addCaretListener(new CaretListener() &#123; public void caretUpdate(CaretEvent ce) &#123; System.out.println("All text: " + textField.getText()); if (textField.getSelectedText() != null) System.out.println("Selected text: " + textField.getSelectedText()); else System.out.println("Selected text: "); &#125; &#125;); jfrm.add(textField); jfrm.add(buttonCut); jfrm.add(buttonPaste); jfrm.add(buttonCopy); jfrm.setVisible(true); &#125;&#125; 说明：这里使用的时用三个按钮监听操作，只需要按住对应的按钮就会触发机制 添加键盘监听机制12345678910111213141516171819202122232425262728293031323334353637383940import java.awt.Dimension;import java.awt.FlowLayout;import java.awt.HeadlessException;import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JTextField;public class Main extends JFrame &#123; public Main() throws HeadlessException &#123; setSize(200, 200); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setLayout(new FlowLayout(FlowLayout.LEFT)); JLabel usernameLabel = new JLabel("Username: "); JTextField usernameTextField = new JTextField(); usernameTextField.setPreferredSize(new Dimension(100, 20)); add(usernameLabel); add(usernameTextField); usernameTextField.addKeyListener(new KeyAdapter() &#123; //创建机制 public void keyReleased(KeyEvent e) &#123; //重载函数，释放按键触发 JTextField textField = (JTextField) e.getSource(); //得到最初发生event的组件对象,既是文本框对象 String text = textField.getText(); textField.setText(text.toUpperCase()); //将所有的小写字母转换成大写字母 &#125; public void keyTyped(KeyEvent e) &#123; //键入时触发 &#125; public void keyPressed(KeyEvent e) &#123; //释放按键时触发的函数 &#125; &#125;); &#125; public static void main(String[] args) &#123; new Main().setVisible(true); &#125;&#125; 添加插入符位置变化的监听机制使用的是CareListener类来实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.zzk;import java.awt.BorderLayout;import java.awt.Color;import java.awt.Font;import java.awt.Graphics;import java.awt.Graphics2D;import javax.swing.JFrame;import javax.swing.JPanel;import javax.swing.JTextField;import javax.swing.event.CaretEvent;import javax.swing.event.CaretListener;public class ClockwiseTextFrame extends JFrame &#123; private JTextField textField; ClockwiseTextPanel clockwiseTextPanel = new ClockwiseTextPanel(); // 创建面板类的实例 public static void main(String args[]) &#123; // 主方法 ClockwiseTextFrame frame = new ClockwiseTextFrame(); // 创建窗体类的实例 frame.setVisible(true); // 显示窗体 &#125; public ClockwiseTextFrame() &#123; super(); // 调用超类的构造方法 setTitle("顺时针旋转文字"); // 窗体标题 setBounds(100, 100, 340, 240); // 窗体的显示位置和大小 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 窗体关闭方式 add(clockwiseTextPanel); // 将面板类的实例添加到窗体容器中 textField = new JTextField(); textField.addCaretListener(new CaretListener() &#123; public void caretUpdate(CaretEvent arg0) &#123; String text = textField.getText();// 获取文本框字符串 clockwiseTextPanel.setText(text);// 为面板中的text变量赋值 &#125; &#125;); getContentPane().add(textField, BorderLayout.SOUTH); &#125; class ClockwiseTextPanel extends JPanel &#123; // 创建内部面板类 private String text; public ClockwiseTextPanel() &#123; setOpaque(false);// 设置面板为透明 setLayout(null);// 设置为绝对布局 &#125; public String getText() &#123; return text; // 获得成员变量的值 &#125; public void setText(String text) &#123; this.text = text;// 为成员变量赋值 repaint();// 调整paint()方法 &#125; public void paint(Graphics g) &#123;// 重写paint()方法 Graphics2D g2 = (Graphics2D) g;// 获得Graphics2D的实例 int width = getWidth();// 获得面板的宽度 int height = getHeight();// 获得面板的高度 if (text != null) &#123; char[] array = text.toCharArray();// 将文本转换为字符数组 int len = array.length * 5;// 定义圆的半径，同时可以调整文字的距离 Font font = new Font("宋体", Font.BOLD, 22);// 创建字体 g2.setFont(font);// 设置字体 double angle = 0;// 定义初始角度 for (int i = 0; i &lt; array.length; i++) &#123;// 遍历字符串中的字符 if (i == 0) &#123; g2.setColor(Color.BLUE);// 第一个字符用蓝色 &#125; else &#123; g2.setColor(Color.BLACK);// 其他字符用黑色 &#125; int x = (int) (len * Math.sin(Math.toRadians(angle + 270)));// 计算每个文字的横坐标位置 int y = (int) (len * Math.cos(Math.toRadians(angle + 270)));// 计算每个文字的纵坐标位置 g2.drawString(array[i] + "", width / 2 + x, height / 2 - y);// 绘制字符 angle = angle + 360d / array.length;// 改变角度 &#125; &#125; &#125; &#125;&#125; 参考文档 官方网站) 英文文档 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[scrapy爬取豆瓣全站]]></title>
      <url>%2F2017%2F04%2F08%2Fscrapy%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E5%85%A8%E7%AB%99%2F</url>
      <content type="text"><![CDATA[Scrapy爬取豆瓣读书全站分析网页 首先打开豆瓣读书中的分类浏览，可以看到其中有很多的分类 豆瓣应该是一个比较好爬的网站，所有的数据都不是ajax加载的，我们打开谷歌的F12或者是火狐的FireBug可以很轻松的找到每一个分类的链接 这里我们使用scrapy中的一个linkextractors库,这个库的作用是会根据提供的限制，自动爬取和深入每一个页面并且提取需要的链接，如果想要找到每一个分类的url,只需Rule(LinkExtractor(allow=&#39;/tag/&#39;,restrict_xpaths=&quot;//div[@class=&#39;article&#39;]&quot;),follow=True),这里的allow是一个正则表达式，用来筛选分类url,restrict_xpaths是限制在哪个结构中筛选url,这里限制的是在&lt;div class=&#39;article&#39;&gt;这个盒模型中，follow表示是否深入，这里当然是要深入,这里就能得到每一个分类url了，自己可以在回调函数中测试下，输入所得的url,可以使用respose.url 得到所有的分类url，就可以继续深入到每一步作品所在的页面了，如下图! 但是我们需要不止是这一页，我们要爬的时全站，因此这里必须实现翻页，我们可以看到页面底部清楚的写着下一页，我们通过解析页面同样可以得到url,如下图所示 可以看到所有的url的规则，我们就可以用正则表达式限制，以获取我们的需要，我们可以写出翻页的代码 1Rule(LinkExtractor(allow="\?start=\d+\&amp;type=",restrict_xpaths="//div[@class='pa&gt;ginator']"),follow=True), 最后一步就是打开每一部书的网页得到所需的信息了，我们就可以通过这里通过解析网页还是可以很清楚的知道url,这里就不再详细的说怎么解析了，这里可以看到所有的url都在li标签中，如下图 我们打开li标签可以很清楚的看大url的规律，因此这里还是用到上面说的库解析深入，连同上面的代码如下 123Rule(LinkExtractor(allow='/tag/',restrict_xpaths="/ /div[@class='article']"),follow=True),#第一步Rule(LinkExtractor(allow="\?start=\d+\&amp;type=",restrict_xpaths="//div[@class='pa&gt;ginator']"),follow=True), #第二步翻翻页Rule(LinkExtractor(allow="/subject/\d+/$",restrict_&gt;xpaths="//ul[@class='subject-list']"),callback='parse_item')#得到所需网页的url 到了这里总算是大功告成了，下面就需要解析自己的所需要的信息了,这里附上网页 下面就是写自己解析代码了，这里就不需要详细的说了，详细内容请看源码,值得注意的是爬取的网页速度不要太快，豆瓣会禁IP的，这里可以采用一些反爬虫措施,如请求头的更换，ip地址的更换，下一篇会详细解说。 参考文档： scrapy中文文档 最后附上本人的github地址,不要忘了给个star哦 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL干货篇一]]></title>
      <url>%2F2017%2F04%2F06%2FSQL%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[SQL系列之基本操作新建表 CREATE TABLE [&lt;列名&gt;&lt;数据类型&gt;[表级完整性约束条件]],[&lt;列名&gt;&lt;数据类型&gt;[表级完整性约束条件]]…… 实例 12345CREATE TABLE student(Sno CHAR(9) PRIMARY KEY,Sname CHAR(20) UNIQUE,Ssex CHAR(2),Sage SMALLINT,Sdept CHAR(20)); 其中student是表名，Sno,Sname,Ssex,Sage,Sdept都是列名，后面的CHAR都是数据类型,这里的PRIMARY KEY是将Sno定义为主键,UNIQUE是将Sname定义为唯一的也就是后面插入数据的时候不能有重复的名字 拓展：主键的定义是在多个候选码中找出那个能够唯一识别一组数据的列名，如果需要两个列名才能识别一组数据，那么可以将这两个列名都定义为主键：PRIMARY KEY(Sno,Sname) 删除表 DROP TABLE NAME;只能删除没有被其他表引用，或者没有建立视图的，这里的引用可以是作为被参照表或者作为参照表 DROP TABLE NAME CASCADE;将全部删除，包括基本表和视图 修改表 添加列 alter table 表名 add 列名 列数据类型 [after 插入位置] 例子 alter table student add grade smallint; //将grade插入到student表中的末尾一列，这里不加after默认的是在末尾添加 alter table studnet add grade smallint after Sname; //这里将grade插入到表中Sname列的后面 删除列alter table 表名 drop 列名 alter table student drop Sname; //输出Sname那一列 修改列alter table 表名 change 列名称 列新名称 新数据类型; 实例 alter table student change Sname name char(10) not null; //修改列名Sname为name,并且还可以修改其中的数据类型，如果想要保持不变，就保持原型。 重命名表alter table 表名 rename 新表名; 实例：alter table student rename STUDENT; //将表名改为STUDENT 插入数据 INSERT INTO table_name(列名,列名，列名....)VALUES(DATA); //这里的data一定要对应每一列的数据类型，当然如果要想要插入所有的数据，就不需要列出所有的列名了 例子: INSERT INTO student(Sno,Sname,Sage,Ssex)values(&#39;201215124&#39;,&#39;jack&#39;,34,&#39;男&#39;); //这里是插入表中的一些列的数据，并且对应了数据类型 INSERT INTO student values(&#39;201215124&#39;,&#39;男&#39;,&#39;jack&#39;,34,&#39;IS&#39;); //这里是按照表中的列名顺序插入数据的 更新数据 update 表名称 set 列名称=新值 where 更新条件; 实例： update student set Sage=Sage+1 where Sno=&#39;12134&#39;; //将Sno为12134的那一列数据的年龄加一 删除表中的数据 delete from 表名称 where 删除条件; 实例： delete from student where Sno=’121314125’; //删除Sno为121314125的那一行数据 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[swing布局管理器]]></title>
      <url>%2F2017%2F04%2F05%2Fjava%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8%2F</url>
      <content type="text"><![CDATA[Swing系列之布局管理器流布局(FlowLayout)默认的JApplet,JPanel,JScrollPane 流布局是相对比较简单的一种布局管理器，也是最常用的布局管理器。在流布局中放置控件时，将按照控件的添加顺序，依次将控件从左到右进行摆放，并且在一行的最后会进行自动换行放置 。在一行中，控件是默认居中放置的。 布局管理器也是通过构造器来创建的。流布局是通过FlowLayout 类来创建，FlowLayout类具有三种构造器。首先是无参构造器， 使用无参构造器能够创建一个默认的以居中对齐方式，控件间水 平和垂直间距为5个像素的流布局。 FlowLayout类还具有一个需要整型参数的构造器，使用该构造器能够创建一个指定对齐方式的流布局管理器，它的控件间水平和垂直间距仍然是默认的5个像素。流布局管理器的对齐方式如下所示。 LEFT 左对齐方式 CENTER 居中对齐方式 RIGHT 右对齐方式 LEADING 控件与容器开始边对齐 TRAILING 构造函数： FlowLayout(),生成一个默认的FlowLayout布局。默认情况下，组件居中，间隙为5个像素。 FlowLayout(int aligment),设定每珩的组件的对齐方式。alignment取值可以为FlowLayout.LEFT,FlowLayout.CENTER,FlowLayout.RIGHT。 FlowLayout(int aligment,int horz, int vert),设定对齐方式，并设定组件的水平间距horz和垂直间距vert，用超类Container的方法setLayout()为容器设定布局。例如，代码setLayout(new FlowLayout())为容器设定 FlowLayout布局。将组件加入容器的方法是add(组件名)。 常用的函数：getAlignment方法和setAlignment方法分别获取和设置流布局管理器的对齐方式。 getHgap方法和setHgap方法分别获取和设置流布局管理器中控件和控件之间的水平间距。getVgap方法和setVgap方法分别获取和 设置流布局管理器中控件和控件之间的垂直间距。12345678910111213141516171819202122232425262728293031import javax.swing.*;import java.awt.*;/** * Created by Chenjiabing on 2017/4/5. */public class BuJu &#123; public static void main(String args[]) &#123; JFrame frame=new JFrame(); FlowLayout flowLayout=new FlowLayout(FlowLayout.LEFT); JPanel panel=new JPanel(flowLayout); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setBounds(100,100,500,400); flowLayout.setHgap(20); //设置水平间距 flowLayout.setVgap(20); //控件之间的垂直间距 for(int i=0;i&lt;6;i++) &#123; JButton button=new JButton("按钮"); panel.add(button); &#125; frame.getContentPane().add(panel); frame.setVisible(true); &#125;&#125; 网格布局(GridLayout) 网络布局也是一种比较常见的布局管理器。使用网格布局管理器后，会将所有的控件尽量按照给出的行数和列数来排列，同时网格布局管理器也会对控件进行尺寸的调整，使所有的控件具有相同的尺寸。在网格布局中，也会尽量使使用的空间成矩形的形式来显示。当窗体发生大小变化时，所有的空间也将自动改变大小来填充窗体。 网格布局是通过GridLayout类来创建的。GridLayout类具有三个构造器，使用无参构造器将创建具有默认行和默认列的网格布局。在创建网格布局管理器时最常用的就是具有两个整型参数的构造器，第一个参数表示网格布局管理器的行数，第二个参数表示网格布局管理器的列数。还有一个具有四个参数的构造器，除了可以定义行数和列数外，还可以定义控件间水平间距和垂直间距。 GridLayout类中还定义了一些方法来对创建的网格布局进行操作 。getRows方法和setRows方法分别是获取和设置网格布局的行数。getColumns方法和setColumns方法分别是获取和设置网格布局 的列数。getHgap方法和setHgap方法分别是获取和设置网格布局 中控件间水平间距。getVgap方法和setVgap方法分别是获取和设 置网络布局中的控件间垂直间距。 构造函数： GridLayout(),生成一个单列的GridLayout布局。默认情况下，无间隙。1.GridLayout(int row,int col),设定一个有行row和列`col的GridLayout布局。 GridLayout(int row,int col,int horz,int vert),设定布局的行数和列数、组件的水平间距和垂直间距 代码大概和上面的设置一样，这里注意的是，网格布局是以行为基准的，如果定义的控件多了或者少了，不会改变行的数量，会根据情况改变列的数量 边框布局(BorderLayout)默认的是JWindow、JFrame,JDialog 上面学习的流布局和网格布局具有很多相似的地方，但是边框布局就和他们存在很大的不同。在使用边框布局时，通常都会由程序员来为控件指定在容器中的位置。边框布局将容器分为五个部分，包括东南西北中五部分。在每一个部分中只能放置一个控件 ，所以如果控件超过五个将不能完全显示。在使用边框布局时需 要注意的是，当容器的大小发生变化时，四周的控件是不会发生变化的，只有中间的控件将发生变化。 边框布局是通过BorderLayout类创建的。BorderLayout类具有两个构造器，一个是无参构造器，另一个是指定控件间间距的构造器，通常使用无参构造器来创建边框布局管理器。 在前面将控件添加到容器中都是通过add方法，将控件作为add方法的参 数来进行添加的。但是在向边框布局容器中添加控件时，这样是不完全 的。在向边框布局容器中添加控件是使用具有两个参数的add方法。其中 第一个参数表示要添加的控件，第二个参数表示要添加到边框布局中的 哪一个位置。边框布局的位置表示是通过常量来表示的，具体常量如下所示 NORTH 容器顶部 SOUTH 容器底部 WEST 容器左边 EAST 容器右边 CENTER 容器的中央 构造函数： BorderLayout(),生成一个默认的BorderLayout布局。默认情况下，没有间隙。 BorderLayout(int horz,int vert),设定组件之间的水平间距和垂直间距。 注意这里还有一些常用的方法，就是设置水平和垂直的间距，上面已经赘述过了，这里就不再详说了 空布局(null) 空布局就是没有使用布局管理器，在空布局的情况下将根据控件的自身信息来为控件指定位置。这就使得控件的布局更加灵活，与此同时给开发人员带来了更大的工作量。 空布局是不需要使用类来创建的，只需要在程序指定布局管理器 为null。将控件添加到空布局容器中时，仍然是使用add方法。因 为这里使用的是空布局管理器，所以在添加控件之前，要对控件 进行设置操作。设置操作是通过setBounds方法来完成的， setBounds方法的基本语法格式如下所示。 public void setBounds(int x,int y,int width,int height); 其中x和y表示的是控件最左上侧的坐标，从而也固定了该控件的 位置。width和height表示的是空间的宽度和高度，从而也指定了控件的大小。 示例代码：1234567&gt;frame.setLayout(null);//布局管理器设置为null JLabel label = new JLabel("First Name:"); label.setBounds(20, 20, 100, 20);//四个参数分别是x,y坐标和label的宽和高 JTextField textField = new JTextField(); textField.setBounds(124, 25, 100, 20); frame.add(label); frame.add(textField); BoxLayout BoxLayout是一种能够实现所有的控件水平放置和垂直放置，因为用到的不多，这里就简单的说一下构造函数：public BoxLayout(Container target,int axis):其中axis表示放置的样式，主要有两种常用到的: X_AXIS:指定组件应该从左到右放置。 Y_AXIS：指定组件从上到下放置 代码 12345678910111213141516171819202122232425262728import oracle.jrockit.jfr.JFR;import javax.swing.*;import java.awt.*;public class BuJu &#123; public static void main(String args[]) &#123; JFrame frame = new JFrame(); // frame.setLayout(new BorderLayout(frame.getComponentCount(),BoxLayout.Y_AXIS)); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JPanel panel = new JPanel(); BoxLayout boxLayout = new BoxLayout(panel, BoxLayout.X_AXIS); panel.setLayout(boxLayout); for (int i = 0; i &lt; 10; i++) &#123; JButton button = new JButton("cma"); panel.add(button); &#125; frame.getContentPane().add(panel, BorderLayout.CENTER); // System.out.println(boxLayout.getTarget()); frame.pack(); //frame.setSize(300,200); frame.setVisible(true); &#125;&#125; 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java图像处理干货篇一]]></title>
      <url>%2F2017%2F04%2F04%2Fjava%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%B9%B2%E8%B4%A7%E7%AF%87%2F</url>
      <content type="text"><![CDATA[java图像处理干货篇绘制图像 绘制图像主要用到的是Graphics类中drawImage方法，当然Graphics2D中也有相应的方法 主要的用法： public abstract boolean drawImage(Image img,x,y,ImageObserver observer):img是Image对象，x,y起始坐标,observer是观察对象 drawImage(Image img,int x,int y,int width,int height,Imageobersver observer):width和height是指定图像的宽度和高度，主要的作用是放大和缩小图像 drawImage(Image img,int dx1,int dy1,int dx2,int dx2,int sx1,int sy1,int sx2,int sy2,ImageObserver observer):主要用来翻转图形,通过互换源矩形的第一个和第二个角的x坐标可以实现水平翻转，通过互换源矩形的第一个和第二个角的y坐标可以实现垂直翻转 翻转图像12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.zzk;import java.awt.BorderLayout;import java.awt.Graphics;import java.awt.Image;import java.awt.Toolkit;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.net.URL;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JPanel;public class PartImageFrame extends JFrame &#123; private Image img = null; // 声明图像对象 private PartImagePanel imagePanel = null; // 声明图像面板对象 private int dx1, dy1, dx2, dy2; // 目标矩形第一个角与第二个角的X、Y坐标 private int sx1, sy1, sx2, sy2; // 源矩形第一个角与第二个角的X、Y坐标 public static void main(String args[]) &#123; PartImageFrame frame = new PartImageFrame(); frame.setVisible(true); &#125; public PartImageFrame() &#123; super(); URL imgUrl = PartImageFrame.class.getResource("/img/image.jpg");// 获取图片资源的路径 img = Toolkit.getDefaultToolkit().getImage(imgUrl); // 获取图像资源 dx2 = sx2 = 340; // 初始化图像大小 dy2 = sy2 = 200; // 初始化图像大小 imagePanel = new PartImagePanel(); // 创建图像面板对象 this.setBounds(200, 160, 355, 276); // 设置窗体大小和位置 this.add(imagePanel); // 在窗体中部位置添加图像面板对象 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置窗体关闭模式 this.setTitle("翻转图像"); // 设置窗体标题 final JPanel panel = new JPanel(); getContentPane().add(panel, BorderLayout.SOUTH); final JButton btn_h = new JButton(); btn_h.addActionListener(new ActionListener() &#123; public void actionPerformed(final ActionEvent e) &#123; // 下面3行代码用于交换sx1和sx2的值 int x = sx1; sx1 = sx2; sx2 = x; imagePanel.repaint(); // 重新调用面板类的paint()方法 &#125; &#125;); btn_h.setText("水平翻转"); panel.add(btn_h); final JButton btn_v = new JButton(); btn_v.addActionListener(new ActionListener() &#123; public void actionPerformed(final ActionEvent e) &#123; // 下面3行代码用于交换sy1和sy2的值 int y = sy1; sy1 = sy2; sy2 = y; imagePanel.repaint();// 重新调用面板类的paint()方法 &#125; &#125;); btn_v.setText("垂直翻转"); panel.add(btn_v); &#125; // 创建面板类 class PartImagePanel extends JPanel &#123; public void paint(Graphics g) &#123; g.clearRect(0, 0, this.getWidth(), this.getHeight());// 清除绘图上下文的内容 g.drawImage(img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, this);// 绘制图像 &#125; &#125;&#125; 旋转图像 主要用到的是Graphics2D类中的rotate函数，定义如下:public abstract void rotate(double theta): theta是角度，以弧度为单位代码如下 123456789101112131415161718192021222324252627282930package com.zzk;import java.awt.*;import java.net.URL;import javax.swing.*;public class RotateImageFrame extends JFrame &#123; private Image img = null; private RotatePanel rotatePanel = null; public RotateImageFrame() &#123; URL imgUrl = RotateImageFrame.class.getResource(&quot;/img/image.jpg&quot;);// 获取图片资源的路径 img = Toolkit.getDefaultToolkit().getImage(imgUrl); // 获取图片资源 rotatePanel = new RotatePanel(); // 创建旋转图像的面板对象 this.setBounds(150, 120, 380, 310); // 设置窗体大小和位置 add(rotatePanel);// 在窗体上放置图像面板 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置窗体关闭模式 this.setTitle(&quot;旋转图像&quot;); // 设置窗体标题 &#125; public static void main(String[] args) &#123; new RotateImageFrame().setVisible(true); &#125; class RotatePanel extends JPanel &#123; public void paint(Graphics g) &#123; Graphics2D g2 = (Graphics2D) g; // 获得Graphics2D对象 g2.drawImage(img, 80, 10, 260, 150, this); // 绘制指定大小的图片 g2.rotate(Math.toRadians(10)); // 将图片旋转10度 g2.drawImage(img, 80, 10, 260, 150, this); // 绘制指定大小的图片 g2.rotate(Math.toRadians(10)); // 将图片旋转10度 g2.drawImage(img, 80, 10, 260, 150, this); // 绘制指定大小的图片 &#125; &#125;&#125; 倾斜图像 主要用到的是Graphics2D中的shear函数定义如：public abstract void shear(doubel shx,double shy):shx是在正x轴上移动坐标的乘数，它可以作为其纵坐标的值,shy是在正y轴方形移动坐标的乘数，它可以作为其x坐标的函数。本人的理解：倾斜画布，如果shx&gt;0就是向正方向平移，平移的长度为shx*height(图形纵坐标的值，如果是矩形就是乘以矩形的高)相同的对于shy是乘以矩形宽123456789101112131415161718192021222324252627package com.zzk;import java.awt.*;import java.net.URL;import javax.swing.*;public class ShearImageFrame extends JFrame &#123; private Image img; private ShearImagePanel canvasPanel = null; public ShearImageFrame() &#123; URL imgUrl = ShearImageFrame.class.getResource("/img/image.jpg");// 获取图片资源的路径 img = Toolkit.getDefaultToolkit().getImage(imgUrl); // 获取图片资源 canvasPanel = new ShearImagePanel(); // 创建绘制倾斜图像的面板对象 this.setBounds(100, 100, 360, 240); // 设置窗体大小和位置 add(canvasPanel);// 在窗体上添加面板对象 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置窗体关闭模式 this.setTitle("倾斜图像"); // 设置窗体标题 &#125; public static void main(String[] args) &#123; new ShearImageFrame().setVisible(true); &#125; class ShearImagePanel extends JPanel &#123;// 绘制倾斜图像的面板类 public void paint(Graphics g) &#123; Graphics2D g2=(Graphics2D) g;// 获得Graphics2D对象 g2.shear(0, -0.5);// 倾斜图像 g2.drawImage(img, 10, 20, 220, 160, this); // 绘制指定大小的图片 &#125; &#125;&#125; 裁剪图片 public BufferedImage createScreenCapture(Rectangle screenRect):返回的是一个BufferedImage对象，参数是Rectangle对象，这个函数是Robot类中的，主要用于裁剪图形 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package com.zzk;import java.awt.AWTException;import java.awt.BasicStroke;import java.awt.BorderLayout;import java.awt.Color;import java.awt.Graphics;import java.awt.Graphics2D;import java.awt.Image;import java.awt.Rectangle;import java.awt.Robot;import java.awt.Toolkit;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import java.awt.event.MouseMotionAdapter;import java.awt.image.BufferedImage;import java.net.URL;import javax.swing.JFrame;import javax.swing.JPanel;import javax.swing.JSplitPane;public class CutImageFrame extends JFrame &#123; private Image img = null; // 声明图像对象 private OldImagePanel oldImagePanel = null; // 声明图像面板对象 private int pressPanelX = 0, pressPanelY = 0;// 鼠标按下点的X、Y坐标 private int pressX = 0, pressY = 0;// 鼠标按下点在屏幕上的X、Y坐标 private int releaseX = 0, releaseY = 0;// 鼠标释放点在屏幕上的X、Y坐标 private Robot robot = null; // 声明Robot对象 private BufferedImage buffImage = null; // 声明缓冲图像对象 private CutImagePanel cutImagePanel = new CutImagePanel(); // 创建绘制裁剪结果的面板 private boolean flag = false; // 声明标记变量，为true时显示选择区域的矩形，否则不显示 public static void main(String args[]) &#123; CutImageFrame frame = new CutImageFrame(); frame.setVisible(true); &#125; public CutImageFrame() &#123; super(); URL imgUrl = CutImageFrame.class.getResource("/img/image.jpg");// 获取图片资源的路径 img = Toolkit.getDefaultToolkit().getImage(imgUrl); // 获取图像资源 oldImagePanel = new OldImagePanel(); // 创建图像面板对象 this.setBounds(200, 160, 355, 276); // 设置窗体大小和位置 final JSplitPane splitPane = new JSplitPane(); splitPane.setDividerLocation((this.getWidth() / 2) - 10); getContentPane().add(splitPane, BorderLayout.CENTER); splitPane.setLeftComponent(oldImagePanel); splitPane.setRightComponent(cutImagePanel); oldImagePanel.addMouseListener(new MouseAdapter() &#123; public void mousePressed(final MouseEvent e) &#123; // 鼠标键按下事件 pressPanelX = e.getX(); // 获得鼠标按下点的X坐标 pressPanelY = e.getY();// 获得鼠标按下点的Y坐标 pressX = e.getXOnScreen() + 1;// 鼠标按下点在屏幕上的X坐标加1，即去除选择线 pressY = e.getYOnScreen() + 1;// 鼠标按下点在屏幕上的Y坐标加1，即去除选择线 flag = true;// 为标记变量赋值为true &#125; public void mouseReleased(final MouseEvent e) &#123; // 鼠标键释放事件 releaseX = e.getXOnScreen() - 1;// 鼠标释放点在屏幕上的X坐标减1，即去除选择线 releaseY = e.getYOnScreen() - 1;// 鼠标释放点在屏幕上的Y坐标减1，即去除选择线 try &#123; robot = new Robot();// 创建Robot对象 if (releaseX - pressX &gt; 0 &amp;&amp; releaseY - pressY &gt; 0) &#123; Rectangle rect = new Rectangle(pressX, pressY, releaseX - pressX, releaseY - pressY);// 创建Rectangle对象 buffImage = robot.createScreenCapture(rect);// 获得缓冲图像对象 cutImagePanel.repaint(); // 调用CutImagePanel面板的paint()方法 &#125; &#125; catch (AWTException e1) &#123; e1.printStackTrace(); &#125; flag = false;// 为标记变量赋值为false &#125; &#125;); oldImagePanel.addMouseMotionListener(new MouseMotionAdapter() &#123; public void mouseDragged(final MouseEvent e) &#123;// 鼠标拖动事件 if (flag) &#123; releaseX = e.getXOnScreen();// 获得鼠标释放点在屏幕上的X坐标 releaseY = e.getYOnScreen();// 获得鼠标释放点在屏幕上的Y坐标 oldImagePanel.repaint();// 调用OldImagePanel面板的paint()方法 &#125; &#125; &#125;); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置窗体关闭模式 this.setTitle("裁剪图片"); // 设置窗体标题 &#125; class OldImagePanel extends JPanel &#123;// 创建绘制原图像的面板类 public void paint(Graphics g) &#123; Graphics2D g2 = (Graphics2D) g; g2.drawImage(img, 0, 0, this.getWidth(), this.getHeight(), this);// 绘制图像 g2.setColor(Color.WHITE); if (flag) &#123; float[] arr = &#123;5.0f&#125;; // 创建虚线模式的数组 BasicStroke stroke = new BasicStroke(1, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 1.0f, arr, 0); // 创建宽度是1的平头虚线笔画对象 g2.setStroke(stroke);// 设置笔画对象 g2.drawRect(pressPanelX, pressPanelY, releaseX - pressX, releaseY - pressY);// 绘制矩形选区 &#125; &#125; &#125; class CutImagePanel extends JPanel &#123;// 创建绘制裁剪结果的面板类 public void paint(Graphics g) &#123; g.clearRect(0, 0, this.getWidth(), this.getHeight());// 清除绘图上下文的内容 g.drawImage(buffImage, 0, 0, releaseX - pressX, releaseY - pressY, this);// 绘制图像 &#125; &#125;&#125; 调整图片的亮度 RescaleOp类中的filter方法原缓冲图像进行重缩放，定义如下public abstract BufferedImage filter(BufferedImage src,BufferedImage dst):src是要过滤的源对象，dst是目标对象，或则为null 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.zzk;import java.awt.BorderLayout;import java.awt.Graphics;import java.awt.Image;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.image.BufferedImage;import java.awt.image.RescaleOp;import java.io.File;import java.io.IOException;import javax.imageio.ImageIO;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JPanel;public class ImageBrightenFrame extends JFrame &#123; private BufferedImage image;// 用于调整亮度的缓冲图像对象 private BufferedImage oldImage;// 用于存放调整亮度之前的原缓冲图像对象 private ImageBrightenPanel imageBrightenPanel = new ImageBrightenPanel(); public static void main(String args[]) &#123; ImageBrightenFrame frame = new ImageBrightenFrame(); frame.setVisible(true); &#125; public ImageBrightenFrame() &#123; super(); setBounds(100, 100, 357, 276); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setTitle("调整图片的亮度"); Image img = null; try &#123; img = ImageIO.read(new File("src/img/image.jpg")); // 创建图像对象 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; image = new BufferedImage(img.getWidth(this), img.getHeight(this), BufferedImage.TYPE_INT_RGB);// 创建缓冲图像对象 image.getGraphics().drawImage(img, 0, 0, null);// 在缓冲图像对象上绘制图像 oldImage = image;// 存储原来的图像对象，用于以后的恢复操作 getContentPane().add(imageBrightenPanel, BorderLayout.CENTER); final JPanel panel = new JPanel(); getContentPane().add(panel, BorderLayout.SOUTH); final JButton button = new JButton(); button.addActionListener(new ActionListener() &#123; public void actionPerformed(final ActionEvent e) &#123; float a = 1.0f;// 定义缩放因子 float b = 5.0f;// 定义偏移量 RescaleOp op = new RescaleOp(a,b,null);// 创建具有指定缩放因子和偏移量的 RescaleOp对象 image = op.filter(image, null);// 对源图像中的数据进行逐像素重缩放，达到变亮的效果 repaint();// 重新绘制图像 &#125; &#125;); button.setText("变 亮"); panel.add(button); final JButton button_3 = new JButton(); button_3.addActionListener(new ActionListener() &#123; public void actionPerformed(final ActionEvent e) &#123; float a = 1.0f;// 定义缩放因子 float b = -5.0f;// 定义偏移量 RescaleOp op = new RescaleOp(a,b,null);// 创建具有指定缩放因子和偏移量的 RescaleOp对象 image = op.filter(image, null);// 对源图像中的数据进行逐像素重缩放，达到变暗的效果 repaint();// 重新绘制图像 &#125; &#125;); button_3.setText("变 暗"); panel.add(button_3); final JButton button_2 = new JButton(); button_2.addActionListener(new ActionListener() &#123; public void actionPerformed(final ActionEvent e) &#123; image = oldImage; // 获得变亮前的图像 imageBrightenPanel.repaint();// 重新绘制原图像，即恢复为变亮前的图像 &#125; &#125;); button_2.setText("恢 复"); panel.add(button_2); final JButton button_1 = new JButton(); button_1.addActionListener(new ActionListener() &#123; public void actionPerformed(final ActionEvent e) &#123; System.exit(0); &#125; &#125;); button_1.setText("退 出"); panel.add(button_1); &#125; class ImageBrightenPanel extends JPanel &#123; public void paint(Graphics g) &#123; if (image != null) &#123; g.drawImage(image, 0, 0, null); // 将缓冲图像对象绘制到面板上 &#125; &#125; &#125;&#125; 补充说明：这里的RescaleOp类可以调整色数，其原理是每一个样本值乘以一个缩放因子然后加上偏移量就是缩放的数，如果要变亮的话就将偏移量为正，反之为负，这里将缩放因子设置为1.0f是因为不想那么快速的变亮，如果你设置的大一点，就会很快变得很亮，反之亦然 转换彩色图片为灰色图片 主要使用ColorConvertOp类，其构造函数如下public ColorConvertOp(ColorSpace src,ColorSpace dst,RenderingHints hints):src是原颜色空间对象，dst是目标颜色空间对象，hints是用于控制颜色转换的RenderingHints对象，可以为null使用ColorConvertOp类中的filter方法将彩色图像转换成灰色图像，定义如下：public final BufferedImage filter(BufferedImage src,BufferedImage dst):scr要过滤的对象，dst目标空间对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.zzk;import java.awt.BorderLayout;import java.awt.Graphics;import java.awt.Image;import java.awt.color.ColorSpace;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.image.BufferedImage;import java.awt.image.ColorConvertOp;import java.io.File;import java.io.IOException;import javax.imageio.ImageIO;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JPanel;public class MultiColorToGrayFrame extends JFrame &#123; private BufferedImage image; private ColorToGrayPanel colorToGrayPanel = new ColorToGrayPanel(); public static void main(String args[]) &#123; MultiColorToGrayFrame frame = new MultiColorToGrayFrame(); frame.setVisible(true); &#125; public MultiColorToGrayFrame() &#123; super(); setBounds(100, 100, 357, 276); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setTitle("彩色图像转换为灰度"); Image img = null; try &#123; img = ImageIO.read(new File("src/img/image.jpg")); // 创建图像对象 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; image = new BufferedImage(img.getWidth(this), img.getHeight(this), BufferedImage.TYPE_INT_RGB);// 创建缓冲图像对象 image.getGraphics().drawImage(img, 0, 0, null);// 在缓冲图像对象上绘制图像 getContentPane().add(colorToGrayPanel, BorderLayout.CENTER); final JPanel panel = new JPanel(); getContentPane().add(panel, BorderLayout.SOUTH); final JButton button = new JButton(); button.addActionListener(new ActionListener() &#123; public void actionPerformed(final ActionEvent e) &#123; ColorSpace colorSpace1 = ColorSpace.getInstance(ColorSpace.CS_GRAY);// 创建内置线性为灰度的颜色空间 ColorSpace colorSpace2 = ColorSpace.getInstance(ColorSpace.CS_LINEAR_RGB);// 创建内置线性为 RGB的颜色空间 ColorConvertOp op = new ColorConvertOp(colorSpace1,colorSpace2, null);// 创建进行颜色转换的对象 image = op.filter(image, null);// 对缓冲图像进行颜色转换 repaint();// 重新绘制图像 &#125; &#125;); button.setText("转换为灰度"); panel.add(button); final JButton button_1 = new JButton(); button_1.addActionListener(new ActionListener() &#123; public void actionPerformed(final ActionEvent e) &#123; System.exit(0); &#125; &#125;); button_1.setText("退 出"); panel.add(button_1); &#125; class ColorToGrayPanel extends JPanel &#123; public void paint(Graphics g) &#123; if (image != null) &#123; g.drawImage(image, 0, 0, null); // 将缓冲图像对象绘制到面板上 &#125; &#125; &#125;&#125; 补充说明：这里的image.getGraphics().drawImage(img, 0, 0, null)可以删除的，因为这里Graphics类中的drawImage可以直接绘制BufferedImage类型的缓冲图像，下面会给出一段代码做个示范 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import javax.imageio.ImageIO;import javax.swing.*;import java.awt.*;import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;/** * Created by Chenjiabing on 2017/4/5. */public class demo extends JFrame&#123; private BufferedImage image=null; private Graphics2D graphics2D=null; private draw my_draw=new draw(); public static void main(String args[]) &#123; demo my=new demo(); my.setVisible(true); &#125; public demo() &#123; this.setBounds(100,100,1000,1000); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); try&#123; image= ImageIO.read(new File("src/img/image.jpg")); //graphics2D=image.createGraphics(); //graphics2D.drawImage(image,0,0,null); // image.getGraphics().drawImage(image,0,0,null); &#125; catch (IOException e) &#123; e.printStackTrace(); System.out.println("error"); &#125; this.getContentPane().add(my_draw); &#125; class draw extends JPanel &#123; public void paint(Graphics g) &#123; g.drawImage(image,0,0,image.getWidth(),image.getHeight(),this); &#125; &#125;&#125; 总结： 从文件中读取图像的方法 URL imgUrl = CutImageFrame.class.getResource(“/img/image.jpg”);//得到的是URL img = Toolkit.getDefaultToolkit().getImage(imgUrl); //得到的是Image对象，同样的想要得到BufferedImage对象可以进行转 化 Image img=ImageIo(new File(&quot;path&quot;));这里得到的是Image对象，如果想要得到BufferedImage对象，可以用BufferedImage的构造方法BufferedImage(int width,int height,) 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[matplotlib绘制图形基础]]></title>
      <url>%2F2017%2F04%2F01%2Fmatplotlib%E7%BB%98%E5%88%B6%E5%9B%BE%E5%BD%A2%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[matplotlib绘制基本图形折线图12345678import matplotlib.pyplot as pltimport numpy as npx=np.arange(0,10,1) #创建一个0-10之间以1为间隔的numpy数组y=x+10 plt.plot(x,y,color='red',linestyle='--',marker='&gt;',linewidth=3,label='example one') #绘制图形plt.savefig('first.png',dpi=50) #保存图形，dpi表示plt.legend() #显示图例plt.show() #显示图形 图形展示说明plt.plot()可以直接绘制折线，其中marker是折线上的标记，linewidth是折线的宽度，label是图例，如果要想显示就要设置plt.legend(),linestyle是折线的风格，color是颜色 饼状图123456789101112131415import matplotlib.pyplot as pltslices = [2,3,4,9] #指定每一个切片的大小，这里就是每块的比例activities = ['sleeping','eating','working','playing'] #指定标签cols = ['c','m','r','b'] #y颜色plt.pie(slices, labels=activities, colors=cols, #指定每一个区块的颜色 startangle=90, #开始角度，默认是0度，从x轴开始，90度从y轴开始 shadow= True, #阴影效果 explode=(0,0.1,0,0), #拉出第二个切片，如果全为0就不拉出，这里的数字是相对与圆心的距离 autopct='%1.1f%%') #显示百分比plt.title('Interesting Graph\nCheck it out') #设置标题plt.show() 图片展示 散点图12345678import numpy as npimport matplotlib.pyplot as pltx=np.random.rand(1000)y=np.random.rand(len(x))plt.scatter(x,y,color='r',alpha=0.3,label='example one',marker='o') #绘图plt.legend()#plt.axis([0,2,0,2]) #设置坐标的范围plt.show() 图片展示 直方图123456789import matplotlib.pyplot as pltimport numpy as npx=np.random.randint(1,1000,200)axis=plt.gca() #得到当前的绘图对象axis.hist(x,bins=35,facecolor='r',normed=True,histtype='bar',alpha=0.5)#bins表示直方图的个数，histtype表示直方图的样式，normed如果为True就将直方归一化，显示概率密度，默认是Falseaxis.set_xlabel("Values") #设置x的标签axis.set_ylabel("Frequency") axis.set_title("HIST")plt.show() 图片展示 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swing干货系列之JSplitPane(分割面板)]]></title>
      <url>%2F2017%2F03%2F28%2FSwing%E4%B8%AD%E7%9A%84JSplitPane%2F</url>
      <content type="text"><![CDATA[Swing中的JSplitPane(分割面板)引言 JSplitPane 用于分隔两个（只能两个）Component。两个 Component 图形化分隔以外观实现为基础，并且这两个 Component 可以由用户交互式调整大小。有关如何使用 JSplitPane 的信息，请参阅 The Java Tutorial 中的 How to Use Split Panes 一节。 使用 JSplitPane.HORIZONTAL_SPLIT 可让分隔窗格中的两个 Component 从左到右排列，或者使用 JSplitPane.VERTICAL_SPLIT 使其从上到下排列。改变 Component 大小的首选方式是调用 setDividerLocation，其中 location 是新的 x 或 y 位置，具体取决于 JSplitPane 的方向。 要将 Component 调整到其首选大小，可调用 resetToPreferredSizes。 当用户调整 Component 的大小时，Component 的最小大小用于确定 Component 能够设置的最大/最小位置。如果两个组件的最小大小大于分隔窗格的大小，则分隔条将不允许您调整其大小。改变 JComponent 最小大小，请参阅 JComponent.setMinimumSize(java.awt.Dimension)。 当用户调整分隔窗格大小时，新的空间以 resizeWeight 为基础在两个组件之间分配。默认情况下，值为 0 表示右边/底部的组件获得所有空间，而值为 1 表示左边/顶部的组件获得所有空间。补充说明： 这里的JComponebt.SetMinimumSize(java.awt.Dimension):用于设置组件的最小值，这里的Dimension是一个封装组件的高度和宽度的一个类，其中的一个构造函数就是Dimension(int width,int height),详情见文档，当然有设置最小的就有设置最大的啊，详情看文档吧 构造函数 public JSplitPanel():创建一个配置为将其子组件水平排列、无连续布局、为组件使用两个按钮的新 JSplitPane public JSplitPanel(int newOrientation):创建一个指定方向的分割板，这里的newOrientation可以设置两个值， VERTICAL_SPLIT(设置分割板为上下布局),HORIZONTAL_SPLIT(设置分隔板左右布局) public JSplitPane(int newOrientation,Component newLeftComponent,Component newRightComponent):创建一个具有指定方向和不连续重绘的指定组件的新 JSplitPane。 public JSplitPane(int newOrientation,boolean newContinuousLayout,Component newLeftComponent,Component newRightComponent):创建一个具有指定方向、重绘方式和指定组件的新 JSplitPane。 常用方法 setContinuousLayout(boolean newContinuousLayout):设置是否连续重新显示组件，如果为false就会发现在调整面板的过程中会显示一道黑线，只有当停下的时候才能正常的显示，默认是false setDividerSize(int newSize):设置分割条的大小* setDividerLocation(double size):设置分隔条的位置,这里的size是小数，个人觉得官方文档好像这里有点对劲，相当于占整个面板的百分比 setLeftComponent(Componentcomp)/setTopComponent(Component comp): 将组件设置到分隔条的上面或者左边。 setRightComponent(Component comp)/setBottomComponent(Component comp):将组件设置到分隔条的下面或者右边。 setOneTouchExpandable(boolean newValue):设置 oneTouchExpandable 属性的值，要使 JSplitPane 在分隔条上提供一个 UI 小部件来快速展开/折叠分隔条，此属性必须为 true。 补充说明： 上面只是常用的几个函数，具体的请看官方文档，注意这里的setLeftComponent的四个设置组件的函数要根据分隔板的分布来确定 开始撸代码 初步实现(创建两个按钮实现分隔板的布局)12345678910111213141516171819202122232425262728import java.awt.BorderLayout;import javax.swing.JButton;import javax.swing.JComponent;import javax.swing.JFrame;import javax.swing.JSplitPane;public class Main &#123; public static void main(String[] a) &#123; JFrame horizontalFrame = new JFrame(); horizontalFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JComponent topButton = new JButton("Left"); JComponent bottomButton = new JButton("Right"); final JSplitPane splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT); splitPane.setTopComponent(topButton); splitPane.setBottomComponent(bottomButton); horizontalFrame.add(splitPane, BorderLayout.CENTER); horizontalFrame.setSize(150, 150); horizontalFrame.setVisible(true); splitPane.setDividerLocation(0.5); &#125;&#125; 更进一步(两种布局的操作)123456789101112131415161718192021222324import java.awt.BorderLayout;import javax.swing.JButton;import javax.swing.JComponent;import javax.swing.JFrame;import javax.swing.JSplitPane;public class Main &#123; public static void main(String[] a) &#123; JFrame horizontalFrame = new JFrame(); horizontalFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JComponent leftButton = new JButton("Left"); JComponent rightButton = new JButton("Right"); JSplitPane splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT); splitPane.setLeftComponent(leftButton); splitPane.setRightComponent(rightButton); horizontalFrame.add(splitPane, BorderLayout.CENTER); horizontalFrame.setSize(150, 150); horizontalFrame.setVisible(true); &#125;&#125; 嵌套分隔板12345678910111213141516171819202122232425262728293031323334import javax.swing.JApplet;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JSplitPane;public class Main&#123; public static void main(String[] a) &#123; int HORIZSPLIT = JSplitPane.HORIZONTAL_SPLIT; int VERTSPLIT = JSplitPane.VERTICAL_SPLIT; boolean continuousLayout = true; JLabel label1 = new JLabel("a"); JLabel label2 = new JLabel("b"); JLabel label3 = new JLabel("c"); JSplitPane splitPane1 = new JSplitPane(VERTSPLIT, continuousLayout, label1, label2); splitPane1.setOneTouchExpandable(true); splitPane1.setDividerSize(2); splitPane1.setDividerLocation(0.5); JSplitPane splitPane2 = new JSplitPane(HORIZSPLIT, splitPane1, label3);//将分隔板和一个label放在第二个分割板中实现嵌套 splitPane2.setOneTouchExpandable(true); splitPane2.setDividerLocation(0.4); splitPane2.setDividerSize(2); JFrame frame = new JFrame(); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.add(splitPane2); frame.pack(); frame.setVisible(true); &#125;&#125; 事件监听12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.awt.BorderLayout;import java.beans.PropertyChangeEvent;import java.beans.PropertyChangeListener;// w w w . j a va2s . co mimport javax.swing.JButton;import javax.swing.JComponent;import javax.swing.JFrame;import javax.swing.JSplitPane;public class Main &#123; public static void main(String args[]) &#123; JFrame frame = new JFrame("Property Split"); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JSplitPane splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT); splitPane.setContinuousLayout(true); splitPane.setOneTouchExpandable(true); JComponent topComponent = new JButton("A"); splitPane.setTopComponent(topComponent); JComponent bottomComponent = new JButton("B"); splitPane.setBottomComponent(bottomComponent); PropertyChangeListener propertyChangeListener = new PropertyChangeListener() &#123; public void propertyChange(PropertyChangeEvent changeEvent) &#123; JSplitPane sourceSplitPane = (JSplitPane) changeEvent.getSource(); String propertyName = changeEvent.getPropertyName(); if (propertyName.equals(JSplitPane.LAST_DIVIDER_LOCATION_PROPERTY)) &#123; int current = sourceSplitPane.getDividerLocation(); System.out.println("Current: " + current); Integer last = (Integer) changeEvent.getNewValue(); System.out.println("Last: " + last); Integer priorLast = (Integer) changeEvent.getOldValue(); System.out.println("Prior last: " + priorLast); &#125; &#125; &#125;; splitPane.addPropertyChangeListener(propertyChangeListener); frame.add(splitPane, BorderLayout.CENTER); frame.setSize(300, 150); frame.setVisible(true); &#125;&#125; 说明无论 bean 何时更改 bound 属性，都会激发一个 PropertyChange 事件。可以向源 bean 注册一个 PropertyChangeListener，以便获得所有绑定 (bound) 属性更改的通知。 类 PropertyChangeEvent无论 bean 何时更改 “bound” 或 “constrained” 属性，都会提交一个 “PropertyChange” 事件。PropertyChangeEvent 对象被作为参数发送给 PropertyChangeListener 和 VetoableChangeListener 方法。通常 PropertyChangeEvent 还附带名称和已更改属性的旧值和新值。如果新值是基本类型（比如 int 或 boolean），则必须将它包装为相应的 java.lang.* Object 类型（比如 Integer 或 Boolean）。如果旧值和新值的真实值是未知的，则可能为它们提供 null 值。事件源可能发送一个 null 对象作为名称，以指示其属性的任意事件集已更改。在这种情况下，旧值和新值应该仍然为 null。getSource():返回最初未变化的对象，未Object类型的,因此这里需要强制转换成JSplitPanel 参考文章 官方文档 英文Swing教程 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swing干货系列之JSlider(滑块)]]></title>
      <url>%2F2017%2F03%2F27%2FSwing-%E5%B9%B2%E8%B4%A7%E7%B3%BB%E5%88%97%E4%B9%8BJSlider%2F</url>
      <content type="text"><![CDATA[Swing干货系列之JSlider(滑块)引言 一个让用户以图形方式在有界区间内通过移动滑块来选择值的组件。 滑块可以显示主刻度标记以及主刻度之间的次刻度标记。刻度标记之间的值的个数由 setMajorTickSpacing和 setMinorTickSpacing 来控制。刻度标记的绘制由 setPaintTicks 控制。 滑块也可以在固定时间间隔（或在任意位置）沿滑块刻度打印文本标签。标签的绘制由 setLabelTable 和 setPaintLabels 控制。 构造函数 JSlider():创建一个空值的滑块组件，但是默认的刻度是100，其中如果获得其值的话可以很清楚的看见 JSlider(BoundedRangeModel brm):使用指定的 BoundedRangeModel 创建一个水平滑块 JSlider(int min,int max):创建一个带有最小值和最大值得滑块 JSlider(int min,int max,int value):创建一个带有最小值，最大值和当前值的滑块 常用的方法 getValue(int x)/setValue(int x):得到和设置当前值 getPaintsLabels():return boolean 告知是否绘制了签 SetFont(Font font):设置组件的字体，其中Font类的font对象是参数 setInverted(boolean b):反转滑块的刻度 setMaximum(int maximum) ：设置最大值 setMinimum(int min):设置最小值 setMinorTickSpacing(int n) :设置次刻度，就是主刻度中间不用标记数值的刻度 setMajorTickSpacing(int n):设置主刻度 setPaintTicks(boolean b):确定是否在滑块下面显示刻度线，如果为false表示不显示 setPaintLabels(boolean b):确定是否在刻度线下绘制数值，默认不绘制以上只是列了几个常用的函数，详情见官方文档 下面撸个代码试试身手12345678910111213141516171819202122232425262728293031323334353637383940package com;import javax.swing.*;import javax.swing.event.ChangeEvent;import javax.swing.event.ChangeListener;import java.awt.*;/** * Created by chenjiabing on 2017/3/27. */public class Java_swing extends JFrame &#123; public JSlider points = null; public Java_swing() &#123; super(); setTitle("记事本"); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setSize(300, 400);// points=new JSlider(); points = new JSlider(0, 50, 5); points.setMinorTickSpacing(5);//设置次要的间隔，每个一个间隔，这个显示时中间不标记数值 points.setMajorTickSpacing(10);//显示主要的刻度线，每个两个间隔，这个设置了，如果setPaintLabels为true就会显示数值 points.setPaintTicks(true); //确定是否显示刻度线 points.setPaintLabels(true); //确定是否显示刻度的值 //points.setInverted(true);//指定为true反转刻 度 points.setSnapToTicks(true); points.addChangeListener(new ChangeListener() &#123; @Override public void stateChanged(ChangeEvent e) &#123; int value = points.getValue(); System.out.println(value); &#125; &#125;); getContentPane().add(points, BorderLayout.CENTER); &#125; public static void main(String args[]) &#123; Java_swing my = new Java_swing(); my.setVisible(true); &#125;&#125; Change Listener(一个监听机制)1234567891011121314151617181920212223242526272829303132333435import java.awt.Dimension;/*from w ww . ja v a 2 s .c o m*/import javax.swing.JFrame;import javax.swing.JSlider;import javax.swing.event.ChangeEvent;import javax.swing.event.ChangeListener;public class Main &#123; public static void main(String[] args) &#123; JFrame f = new JFrame(); final JSlider slider = new JSlider(0, 150, 0); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); slider.setPreferredSize(new Dimension(150, 30)); //添加change Listener,当然这里的和JButton的也是一样，可以在一个类中实现 slider.addChangeListener(new ChangeListener() &#123; public void stateChanged(ChangeEvent event) &#123; int value = slider.getValue(); if (value == 0) &#123; System.out.println("0"); &#125; else if (value &gt; 0 &amp;&amp; value &lt;= 30) &#123; System.out.println("value &gt; 0 &amp;&amp; value &lt;= 30"); &#125; else if (value &gt; 30 &amp;&amp; value &lt; 80) &#123; System.out.println("value &gt; 30 &amp;&amp; value &lt; 80"); &#125; else &#123; System.out.println("max"); &#125; &#125; &#125;); f.add(slider); f.pack(); f.setLocationRelativeTo(null); f.setVisible(true); &#125;&#125; 当然以上只是JSlider的一部分内容，还有的后面会陆续更新本文参考的文章： 中文文档 英文文档 福利时间，博主写了一个小例子，想要的朋友可以参见github,不要忘了随手点个赞哦！！！ 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[scrapy设置请求池]]></title>
      <url>%2F2017%2F03%2F26%2Fscrapy%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E6%B1%A0%2F</url>
      <content type="text"><![CDATA[scrapy设置”请求池”引言 相信大家有时候爬虫发出请求的时候会被ban，返回的是403错误，这个就是请求头的问题，其实在python发出请求时，使用的是默认的自己的请求头，网站管理者肯定会不允许机器访问的，但是有些比较low的网站还是可以访问的，有时候网站管理者看到同一个请求头在一秒内请求多次，傻子都知道这是机器在访问，因此会被ban掉，这时就需要设置请求池了，这个和ip代理池是一个概念 爬虫请求常见的错误 200：请求成功 处理方式：获得响应的内容，进行处理201：请求完成，结果是创建了新资源。新创建资源的 URI 可在响应的实体中得到 处理方式：爬虫中不会遇到202：请求被接受，但处理尚未完成 处理方式：阻塞等待204：服务器端已经实现了请求，但是没有返回新的信 息。如果客户是用户代理，则无须为此更新自身的文档视图。 处理方式：丢弃300：该状态码不被 HTTP/1.0 的应用程序直接使用， 只是作为 3XX 类型回应的默认解释。存在多个可用的被请求资源。 处理方式：若程序中能够处理，则进行进一步处理，如果程序中不能处理，则丢弃301：请求到的资源都会分配一个永久的 URL，这样就可以在将来通过该 URL 来访问此资源 处理方式：重定向到分配的 URL302：请求到的资源在一个不同的 URL 处临时保存 处理方式：重定向到临时的 URL304 请求的资源未更新 处理方式：丢弃400 非法请求 处理方式：丢弃401 未授权 处理方式：丢弃403 禁止 处理方式：丢弃404 没有找到 处理方式：丢弃5XX 回应代码以“5”开头的状态码表示服务器端发现自己出现错误，不能继续执行请求 处理方式：丢弃 话不多说直接撸代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from scrapy import logimport randomfrom scrapy.downloadermiddlewares.useragent import UserAgentMiddlewareclass RotateUserAgentMiddleware(UserAgentMiddleware):# for more user agent strings,you can find it in http://www.useragentstring.com/pages/useragentstring.phpuser_agent_list = [ "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 " "(KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1", "Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 " "(KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11", "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 " "(KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6", "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.6 " "(KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6", "Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.1 " "(KHTML, like Gecko) Chrome/19.77.34.5 Safari/537.1", "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 " "(KHTML, like Gecko) Chrome/19.0.1084.9 Safari/536.5", "Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 " "(KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5", "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3", "Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3", "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3", "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3", "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3", "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3", "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3", "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1061.0 Safari/536.3", "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 " "(KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24", "Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 " "(KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24"]def process_request(self, request, spider): ua = random.choice(self.user_agent_list) if ua: # 显示当前使用的useragent print "********Current UserAgent:%s************" % ua # 记录 log.msg('Current UserAgent: ' + ua) request.headers.setdefault('User-Agent', ua) 说明 这里的思路就是在下载器中间件中对request设置请求，这里是使用request.headers.setdefault(&quot;User-Agent&quot;,user_agent)这个函数设置请求头，对于下载器中间件在我博客前面的文章已经有说明，想要了解的请点击 注意 这里还要说明的是设置了请求池还要在配置文件settins中设置一下，具体设置方法和设置代理ip一样，详情请看scrapy代理ip的设置 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Scrapy中使用cookie免于验证登录和模拟登录]]></title>
      <url>%2F2017%2F03%2F26%2FScrapy%E4%B8%AD%E4%BD%BF%E7%94%A8cookie%E5%85%8D%E4%BA%8E%E9%AA%8C%E8%AF%81%E7%99%BB%E5%BD%95%E5%92%8C%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%2F</url>
      <content type="text"><![CDATA[Scrapy中使用cookie免于验证登录和模拟登录引言 python爬虫我认为最困难的问题一个是ip代理，另外一个就是模拟登录了，更操蛋的就是模拟登录了之后还有验证码，真的是不让人省心，不过既然有了反爬虫，那么就有反反爬虫的策略，这里就先介绍一个cookie模拟登陆，后续还有seleminum+phantomjs模拟浏览器登录的文章。还不知道cookie是什么朋友们，可以点击这里 cookie提取方法： 打开谷歌浏览器或者火狐浏览器，如果是谷歌浏览器的按F12这个键就会跳出来浏览器控制台，然后点击Network，之后就是刷新网页开始抓包了，之后在抓到的页面中随便打开一个，就能看到cokie了，但是这里的cookie并不符合python中的格式，因此需要转换格式，下面提供了转换的代码 1234567891011121314151617181920212223# -*- coding: utf-8 -*-class transCookie:def __init__(self, cookie): self.cookie = cookiedef stringToDict(self): ''' 将从浏览器上Copy来的cookie字符串转化为Scrapy能使用的Dict :return: ''' itemDict = &#123;&#125; items = self.cookie.split(';') for item in items: key = item.split('=')[0].replace(' ', '') value = item.split('=')[1] itemDict[key] = value return itemDictif __name__ == "__main__":cookie = "你复制的cookie"trans = transCookie(cookie)print trans.stringToDict() 补充说明： 只需要将你网页上的cookie复制到上述代码中直接运行就可以了 使用cookie操作scrapy 直接撸代码 123456789101112131415161718# -*- coding: utf-8 -*-import scrapyfrom scrapy.conf import settings #从settings文件中导入Cookie，这里也可以室友from scrapy.conf import settings.COOKIEclass DemoSpider(scrapy.Spider):name = "demo"#allowed_domains = ["csdn.com"]start_urls = ["http://write.blog.csdn.net/postlist"]cookie = settings['COOKIE'] # 带着Cookie向网页发请求\headers = &#123; 'Connection': 'keep - alive', # 保持链接状态 'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.82 Safari/537.36'&#125;def start_requests(self): yield scrapy.Request(url=self.start_urls[0],headers=self.headers,cookies=self.cookie)# 这里带着cookie发出请求def parse(self, response): print response.body 说明 这里是scrapy工程目录下spiders目录下的主要的解析网页的py文件相信学过scrapy的应该不会陌生，上述代码中的cookie值是放在Settings文件中的，因此使用的时候需要导入，当然你也可以直接将cookie粘贴到这个文件中 注意 虽说这里使用直接使用cookie可以省去很多麻烦，但是cookie的生命周期特别的短，不过小型的项目足够使用了，向那些需要爬两三天甚至几个月的项目就不适用了，因此在隔一段时间就要重新换cookie的值，虽说有很多麻烦，但是我还是比较喜欢这种方法的，因为可以省去不少脑筋 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持。 最后欢迎大家看看我的其他scrapy文章 scrapy设置代理ip scrapy架构初探 scrapy初试 scrapy下载器中间件 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[scrapy设置代理ip]]></title>
      <url>%2F2017%2F03%2F26%2Fscrapy%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86ip%2F</url>
      <content type="text"><![CDATA[scrapy代理的设置 在我的上一篇文章介绍了scrapy下载器中间件的使用,这里的scrapyIP的代理就是用这个原理实现的，重写了下载器中间件的process_request(self,request,spider)这个函数,这个函数的主要作用就是对request进行处理。 话不多说直接撸代码 123456789101112131415161718192021222324import random import scrapyimport loggingclass proxMiddleware(object):#proxy_list=[&#123;'http': 'http://123.157.146.116:8123'&#125;, &#123;'http': 'http://116.55.16.233:8998'&#125;, &#123;'http': 'http://115.85.233.94:80'&#125;, &#123;'http': 'http://180.76.154.5:8888'&#125;, &#123;'http': 'http://139.213.135.81:80'&#125;, &#123;'http': 'http://124.88.67.14:80'&#125;, &#123;'http': 'http://106.46.136.90:808'&#125;, &#123;'http': 'http://106.46.136.226:808'&#125;, &#123;'http': 'http://124.88.67.21:843'&#125;, &#123;'http': 'http://113.245.84.253:8118'&#125;, &#123;'http': 'http://124.88.67.10:80'&#125;, &#123;'http': 'http://171.38.141.12:8123'&#125;, &#123;'http': 'http://124.88.67.52:843'&#125;, &#123;'http': 'http://106.46.136.237:808'&#125;, &#123;'http': 'http://106.46.136.105:808'&#125;, &#123;'http': 'http://106.46.136.190:808'&#125;, &#123;'http': 'http://106.46.136.186:808'&#125;, &#123;'http': 'http://101.81.120.58:8118'&#125;, &#123;'http': 'http://106.46.136.250:808'&#125;, &#123;'http': 'http://106.46.136.8:808'&#125;, &#123;'http': 'http://111.78.188.157:8998'&#125;, &#123;'http': 'http://106.46.136.139:808'&#125;, &#123;'http': 'http://101.53.101.172:9999'&#125;, &#123;'http': 'http://27.159.125.68:8118'&#125;, &#123;'http': 'http://183.32.88.133:808'&#125;, &#123;'http': 'http://171.38.37.193:8123'&#125;]proxy_list=[ "http://180.76.154.5:8888", "http://14.109.107.1:8998", "http://106.46.136.159:808", "http://175.155.24.107:808", "http://124.88.67.10:80", "http://124.88.67.14:80", "http://58.23.122.79:8118", "http://123.157.146.116:8123", "http://124.88.67.21:843", "http://106.46.136.226:808", "http://101.81.120.58:8118", "http://180.175.145.148:808"]def process_request(self,request,spider): # if not request.meta['proxies']: ip = random.choice(self.proxy_list) print ip #print 'ip=' %ip request.meta['proxy'] = ip 主要的原理： 给出一个代理列表，然后在这个列表中随机取出一个代理，设置在request中，其中request.meta[&#39;proxy&#39;]就是设置代理的格式 但是现在主要的问题就是没有代理ip可用，如果去买的话又太贵了，自己玩玩买代理不值当，所以只好自己写爬虫去爬取免费的代理了，但是免费的代理存活的时间是有限的，这是个非常麻烦的事情，我提供的方法就是实现自己的一个ip代理池，每天定时更新自己的代理池，具体的实现方法会在下一篇文章中介绍，现在提供一段代码用来爬取西刺网站的代理 直接撸代码，接招吧 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#coding:utf-8import requestsfrom bs4 import BeautifulSoupimport threadingimport Queueclass Get_ips():def __init__(self,page): self.ips=[] self.urls=[] for i in range(page): self.urls.append("http://www.xicidaili.com/nn/" + str(i)) self.header = &#123;"User-Agent": 'Mozilla/5.0 (Windows NT 6.3; WOW64; rv:43.0) Gecko/20100101 Firefox/43.0'&#125; #self.file=open("ips",'w') self.q=Queue.Queue() self.Lock=threading.Lock()def get_ips(self): for url in self.urls: res = requests.get(url, headers=self.header) soup = BeautifulSoup(res.text, 'lxml') ips = soup.find_all('tr') for i in range(1, len(ips)): ip = ips[i] tds = ip.find_all("td") ip_temp = "http://" + tds[1].contents[0] + ":" + tds[2].contents[0] # print str(ip_temp) self.q.put(str(ip_temp))def review_ips(self): while not self.q.empty(): ip=self.q.get() try: proxy=&#123;"http": ip&#125; #print proxy res = requests.get("http://www.baidu.com", proxies=proxy,timeout=5) self.Lock.acquire() if res.status_code == 200: self.ips.append(ip) print ip self.Lock.release() except Exception: pass #print 'error'def main(self): self.get_ips() threads=[] for i in range(40): threads.append(threading.Thread(target=self.review_ips,args=[])) for t in threads: t.start() for t in threads: t.join() return self.ipsdef get_ip():my=Get_ips(4)return my.main()get_ip() 实现的原理 这里用到了BeautifulSoup解析页面，然后将提取到的代理交给队列，然后再通过共享队列分配给线程，这里主要开启线程通过设置代理ip访问一个网站，因为访问网站的时间比较长，因此要开起多个线程，相信大家能够学习设置代理ip了应该都是比较上手的了，这里具体的代码就不一一解释了，如果代码有什么问题可以及时联系我，我的联系方式在关于我的一栏中有提到 补充 想要ip应用起来，还要在配置文件settings中添加DOWNLOADER_MIDDLEWARES = { &#39;demo.proxy.proxMiddleware&#39;:400 }这里的demo是工程的名字，proxy是py文件的名,proxMiddleware是类的名字 当然这里可能你觉得proxy_list写在这里有点冗余，你可以在配置文件中定义，然后将配置文件的内容import到py文件中 以上全是博主慢慢摸索出来的，可以说自学一门技术真的很难，学习python爬虫已经有两三个月了，可以说全是自己通过看项目，网上查资料才有了今天的成功，不过现在还有几个问题没有解决，就是分布式爬虫、移动端爬取，博主接下来就要主攻这两个方面，学好之后会在自己的博客上分享学习心得的，因为网上没有系统的学习教程，对于自学的人来说实在是太痛苦了 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[scrapy的下载器中间件]]></title>
      <url>%2F2017%2F03%2F25%2Fscrapy%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%99%A8%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[scrapy中的下载器中间件下载中间件 下载器中间件是介于Scrapy的request/response处理的钩子框架。 是用于全局修改Scrapy request和response的一个轻量、底层的系统。 编写下载器中间件 1. process_request(request, spider)当每个request通过下载中间件时，该方法被调用。process_request() 必须返回其中之一: 返回 None 、返回一个 Response 对象、返回一个 Request对象或raise IgnoreRequest 。 如果其返回 None ，Scrapy将继续处理该request，执行其他的中间件的相应方法，直到合适的下载器处理函数(download handler)被调用， 该request被执行(其response被下载)。 如果其返回 Response 对象，Scrapy将不会调用 任何 其他的 process_request() 或 process_exception() 方法，或相应地下载函数； 其将返回该response。 已安装的中间件的 process_response() 方法则会在每个response返回时被调用。 如果其返回 Request 对象，Scrapy则停止调用 process_request方法并重新调度返回的request。当新返回的request被执行后， 相应地中间件链将会根据下载的response被调用。 如果其raise一个 IgnoreRequest 异常，则安装的下载中间件的 process_exception() 方法会被调用。如果没有任何一个方法处理该异常， 则request的errback(Request.errback)方法会被调用。如果没有代码处理抛出的异常， 则该异常被忽略且不记录(不同于其他异常那样)。 参数: request (Request 对象) – 处理的request spider (Spider 对象) – 该request对应的spider 2. process_response(request, response, spider) process_response() 必须返回以下之一: 返回一个 Response对象、 返回一个Request 对象或raise一个 IgnoreRequest 异常。 如果其返回一个 Response (可以与传入的response相同，也可以是全新的对象)， 该response会被在链中的其他中间件的 process_response() 方法处理。 如果其返回一个 Request 对象，则中间件链停止， 返回的request会被重新调度下载。处理类似于 process_request() 返回request所做的那样。 如果其抛出一个 IgnoreRequest 异常，则调用request的errback(Request.errback)。 如果没有代码处理抛出的异常，则该异常被忽略且不记录(不同于其他异常那样)。 参数: request (Request对象) – response所对应的request response (Response 对象) – 被处理的response spider (Spider 对象) – response所对应的spider 3.process_exception(request, exception, spider) 当下载处理器(download handler)或 process_request() (下载中间件)抛出异常(包括 IgnoreRequest 异常)时， Scrapy调用 process_exception() 。 process_exception() 应该返回以下之一: 返回 None 、 一个 Response 对象、或者一个 Request 对象。 如果其返回 None ，Scrapy将会继续处理该异常，接着调用已安装的其他中间件的 process_exception() 方法，直到所有中间件都被调用完毕，则调用默认的异常处理。 如果其返回一个 Response 对象，则已安装的中间件链的 process_response() 方法被调用。Scrapy将不会调用任何其他中间件的 process_exception() 方法。 如果其返回一个 Request 对象， 则返回的request将会被重新调用下载。这将停止中间件的 process_exception() 方法执行，就如返回一个response的那样。 参数: request (是 Request 对象) – 产生异常的request exception (Exception 对象) – 抛出的异常 spider (Spider 对象) – request对应的spider 总结： 总的来说下载器中间件就是起到处理request请求并且返回response的作用，一切从网页爬取的url发起的请求会组成一个请求队列，然后一个一个排队经过下载器中间件，之后下载器中间件会对request做出相应的处理，比如添加请求头，添加代理等等，然后通过process_response返回一个response，之后就是用得到的response做出相应的分析，当然这里的内容页可以不实现，但是如果要爬取大型的网站，会遇到被ban的可能就要在下载器中间件这里着手，设置一些相应的请求头，ip代理等等内容。以上纯属个人逐渐摸索总结出来的内容，如果有什么错误欢迎指正 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[scrapy初试]]></title>
      <url>%2F2017%2F03%2F25%2Fscrapy%E5%88%9D%E8%AF%95%2F</url>
      <content type="text"><![CDATA[scrapy初试 创建项目 打开cmd，在终端输入scrapy startproject tutorial,这里将在指定的文件夹下创建一个scrapy工程 其中将会创建以下的文件： scrapy.cfg: 项目的配置文件 tutorial/: 该项目的python模块。之后您将在此加入代码。 tutorial/items.py: 项目中的item文件. tutorial/pipelines.py: 项目中的pipelines文件. tutorial/settings.py: 项目的设置文件. tutorial/spiders/: 放置spider代码的目录. 定义item Item是保存爬取到的数据的容器；其使用方法和python字典类似， 并且提供了额外保护机制来避免拼写错误导致的未定义字段错误。 类似在ORM中做的一样，您可以通过创建一个 scrapy.Item 类， 并且定义类型为 scrapy.Field的类属性来定义一个Item。 (如果不了解ORM, 不用担心，您会发现这个步骤非常简单) 首先根据需要从dmoz.org获取到的数据对item进行建模。 我们需要从dmoz中获取名字，url，以及网站的描述。 对此，在item中定义相应的字段。编辑 tutorial 目录中的 items.py 文件: 12345import scrapyclass DmozItem(scrapy.Item):title = scrapy.Field()link = scrapy.Field()desc = scrapy.Field() 一开始这看起来可能有点复杂，但是通过定义item， 您可以很方便的使用Scrapy的其他方法。而这些方法需要知道您的item的定义. 编写第一个爬虫 在工程的根目录下打开终端输入scrapy genspider demo douban.com这里的demo是spders文件下的主要py文件douban.com是要爬取的域名，会在demo.py中的 allowed_domains中显示，主要的功能就是限制爬取的url spider代码中内容解析 name: 用于区别Spider。 该名字必须是唯一的，您不可以为不同的Spider设定相同的名字。 start_urls: 包含了Spider在启动时进行爬取的url列表。 因此，第一个被获取到的页面将是其中之一。 后续的URL则从初始的URL获取到的数据中提取。 parse() 是spider的一个方法。 被调用时，每个初始URL完成下载后生成的 Response 对象将会作为唯一的参数传递给该函数。 该方法负责解析返回的数据(response data)，提取数据(生成item)以及生成需要进一步处理的URL的 Request对象。 以下是spider目录下的demo.py的代码 1234567891011121314import scrapyclass DmozSpider(scrapy.Spider):name = "dmoz"allowed_domains = ["dmoz.org"]start_urls = [ "http://www.dmoz.org/Computers/Programming/Languages/Python/Books/", "http://www.dmoz.org/Computers/Programming/Languages/Python/Resources/"]def parse(self, response): filename = response.url.split("/")[-2] with open(filename, 'wb') as f: f.write(response.body) spider的爬取 进入工程的根目录下打开终端输入：scrapy crawl dmoz spider中的数据存取 在工程的根目录下打开终端输入scrapy crawl dmoz -o items.json这里是将数据存储到json文件中]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java中的IO操作]]></title>
      <url>%2F2017%2F03%2F25%2Fjava%E4%B8%AD%E7%9A%84IO%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[java中IO操作读取文件中的内容 使用Scanner读取文本中的内容 相信大家都知道Scanner console=new Scanner(System.in)是用来读取控制台上输入的内容，但是这里是用来读取文件的内容，原理是一样的，只是对象不同罢了，这里用到的是File对象，用来创建一个文件对象 123456Scanner input=new Scanner(new File("hello.txt"));//创建一个对象inputwhile(input.hasNextLine()) //这里用来判断是否还有内容， 以免读到最后发生错误&#123;String content=input.nextLine();System.out.println(content);&#125; 这里顺便补充一下Scannner中的几个函数： nextLine():读取一行的内容，包括空格，换行 nextInt():读取一个整型内容 nexDouble():读取一个双精度的浮点数 next():读取下一个内容，无论什么类型，其中遇到空格和换行默认是一个标记（即是跳过）和nextLine()类似 hasNext():用来判断文件中的还有下一个内容，无论什么类型的 hasNextInt() hasNextDouble()://相似，不在赘述 使用FileReader读取 用来读取字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的。要自己指定这些值，可以先在 FileInputStream上构造一个 InputStreamReader。FileReader 用于读取字符流。要读取原始字节流，请考虑使用 FileInputStream。 //这里使用new File创建一个对象，同样的也可以直接将文件的绝对路径传入 FileReader file=new FileReader(new File(&quot;hello.txt&quot;)); while(file.ready()) //用来判断是否还有字符可读 { int content=file.read(); //这里的read是读取将单个字符 返回的是int，即是ascii码,这里官方文档说返回的是读取的字符数，但是我实验了一下返回的ascii码 System.out.println((char)content); //所以要将ascii码转换成字符 } file.close(); 常用的几个方法： read(): return int 上面介绍过 read(char[] cbuf,int int length):将内容读入到一个char类型的数组，length是读取的字符数，offest是偏移量 使用BufferedReader的类实现高效的读取文件 123456//传入一个reader创建一个对象 BufferedReader file= new BufferedReader(new FileReader("hello.txt")); System.out.println(file.skip(3));//实现将指针跳过3个字符 System.out.println((char)file.read()); //read的方法，和FileReader中的read一样 String line=file.readLine(); //读取一行 System.out.println(line); 常用的方法： readLine() read()：如果到了末尾返回-1 read(char [],int off,int length):和FileReader中的一样 ready():判断是否还可以读取，一般和read配对使用 skip(long n):跳过的字符数 close() 文件的写入 用FileWriter写入文件 12345/*创建将对象f传入FileWriter,其中Filewriter有两个参数，第一个是File对象后者是一个String(即是文件的路径），第二个参数是boolean类型的，表示是否在文件的末尾追加内容，默认的是false表示不用在末尾追加，如果想要在末尾追加要写入另外一个参数true,当然这里可以用更加简洁的方式创建：FileWriter file=new FileWriter("hello.txt",false);*/FileWriter file=new FileWriter(f,true);file.write("chenjiabing");//写入函数writefile.close(); //最后必须关闭文件的输入流，否则写入将会失败，这里不想c和c++ 其中Filewriter中的方法还有 flush：刷新缓存流 close append():当前的领会的就是写入数组:append(Arrays.toString(list)); getEncoding():返回此流使用的字符编码 用PrintStream写入文件 这里同样的是和System.out.println()一样的原理，System.out.println只是内部实现了PrintStream，这里是用来将指定的内容写入到文件中而已 12345PrintStream output=new PrintStream(new File("hello.txt"));//创建一个写入的对象outputoutput.print("flan");output.println("vmlkfamla");output.println("vmslfkmadvmfs;dm"); 这里是用BufferedWriter类写入文件(一个高效的写入方式) 简单介绍 将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。可以指定缓冲区的大小，或者接受默认的大小。在大多数情况下，默认值就足够大了。该类提供了 newLine() 方法，它使用平台自己的行分隔符概念，此概念由系统属性 line.separator 定义。并非所有平台都使用新行符 (‘\n’) 来终止各行。因此调用此方法来终止每个输出行要优于直接写入新行符。通常 Writer 将其输出立即发送到底层字符或字节流。除非要求提示输出，否则建议用 BufferedWriter 包装所有其 write() 操作可能开销很高的 Writer（如 FileWriters 和 OutputStreamWriters）。例如， PrintWriter out= new PrintWriter(new BufferedWriter(new FileWriter(&quot;foo.out&quot;))); 将缓冲 PrintWriter对文件的输出。如果没有缓冲，则每次调用 print() 方法会导致将字符转换为字节，然后立即入到文件，而这是极其低效的。 例子 12345BufferedWriter input=new BufferedWriter(new FileWriter("hello.txt")); input.write("这是一个文件读入的方法"); input.newLine(); input.write("一个高效的方法"); input.close(); 其他的方法 close() flush() newLine():写入一个换行，因为每一个操作系统上的换行符可能不一样，不能系统的都用”\n”表示 write() 详情参见API 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[scrapy架构初探]]></title>
      <url>%2F2017%2F03%2F25%2Fscrapy%E6%9E%B6%E6%9E%84%E5%88%9D%E6%8E%A2%2F</url>
      <content type="text"><![CDATA[scrapy架构初探引言 Python即时网络爬虫启动的目标是一起把互联网变成大数据库。单纯的开放源代码并不是开源的全部，开源的核心是“开放的思想”，聚合最好的想法、技术、人员，所以将会参照众多领先产品，比如，Scrapy，ScrapingHub，import io等。 本文简单讲解一下Scrapy的架构。没错，通用提取器gsExtractor就是要集成到Scrapy架构中。 请注意，本文不想复述原文内容，而是为了开源Python爬虫的发展方向找参照，而且以9年来开发网络爬虫经验作为对标，从而本文含有不少笔者主观评述，如果想读Scrapy官方原文，请点击Scrapy官网的Architecture。 scrapy数据流 Scrapy中的数据流由执行引擎控制，下面的原文摘自Scrapy官网，我根据猜测做了点评，为进一步开发GooSeeker开源爬虫指示方向： The Engine gets the first URLs to crawl from the Spider and schedules them in the Scheduler, as Requests. URL谁来准备呢？看样子是Spider自己来准备，那么可以猜测Scrapy架构部分（不包括Spider）主要做事件调度，不管网址的存储。看起来类似GooSeeker会员中心的爬虫罗盘，为目标网站准备一批网址，放在罗盘中准备执行爬虫调度操作。所以，这个开源项目的下一个目标是把URL的管理放在一个集中的调度库里面。 The Engine asks the Scheduler for the next URLs to crawl. 看到这里其实挺难理解的，要看一些其他文档才能理解透。接第1点，引擎从Spider中把网址拿到以后，封装成一个Request，交给了事件循环，会被Scheduler收来做调度管理的，暂且理解成对Request做排队。引擎现在就找Scheduler要接下来要下载的网页地址。 The Scheduler returns the next URLs to crawl to the Engine and the Engine sends them to the Downloader, passing through the Downloader Middleware (request direction). 从调度器申请任务，把申请到的任务交给下载器，在下载器和引擎之间有个下载器中间件，这是作为一个开发框架的必备亮点，开发者可以在这里进行一些定制化扩展。 Once the page finishes downloading the Downloader generates a Response (with that page) and sends it to the Engine, passing through the Downloader Middleware (response direction). 下载完成了，产生一个Response，通过下载器中间件交给引擎。注意，Response和前面的Request的首字母都是大写，虽然我还没有看其它Scrapy文档，但是我猜测这是Scrapy框架内部的事件对象，也可以推测出是一个异步的事件驱动的引擎，就像DS打数机的三级事件循环一样，对于高性能、低开销引擎来说，这是必须的。 The Engine receives the Response from the Downloader and sends it to the Spider for processing, passing through the Spider Middleware (input direction). 再次出现一个中间件，给开发者足够的发挥空间。 The Spider processes the Response and returns scraped items and new Requests (to follow) to the Engine. 每个Spider顺序抓取一个个网页，完成一个就构造另一个Request事件，开始另一个网页的抓取。 The Engine passes scraped items and new Requests returned by a spider through Spider Middleware (output direction), and then sends processed items to Item Pipelines and processed Requests to the Scheduler. 引擎作事件分发 The process repeats (from step 1) until there are no more requests from the Scheduler. 持续不断地运行。 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java图形与文本处理一]]></title>
      <url>%2F2017%2F03%2F25%2Fjava%E5%9B%BE%E5%BD%A2%E4%B8%8E%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%80%2F</url>
      <content type="text"><![CDATA[java绘制图形和文本&lt;一&gt;开篇介绍(官方文档) java.awt类 Graphicsjava.lang.Object继承者 java.awt.Graphics直接已知子类：DebugGraphics, Graphics2Dpublic abstract class Graphics extends Object Graphics 类是所有图形上下文的抽象基类，允许应用程序在组件（已经在各种设备上实现）以及闭屏图像上进行绘制。Graphics 对象封装了 Java 支持的基本呈现操作所需的状态信息。此状态信息包括以下属性：要在其上绘制的 Component 对象。呈现和剪贴坐标的转换原点。当前剪贴区。当前颜色。当前字体。当前逻辑像素操作函数（XOR 或 Paint）。当前 XOR 交替颜色（参见 setXORMode(java.awt.Color)）。坐标是无限细分的，并且位于输出设备的像素之间。绘制图形轮廓的操作是通过使用像素大小的画笔遍历像素间无限细分路径的操作，画笔从路径上的锚点向下和向右绘制。填充图形的操作是填充图形内部区域无限细分路径操作。呈现水平文本的操作是呈现字符字形完全位于基线坐标之上的上升部分。图形画笔从要遍历的路径向下和向右绘制。其含义如下：如果绘制一个覆盖给定矩形的图形，那么该图形与填充被相同矩形所限定的图形相比，在右侧和底边多占用一行像素。如果沿着与一行文本基线相同的 y 坐标绘制一条水平线，那么除了文字的所有下降部分外，该线完全画在文本的下面。所有作为此 Graphics 对象方法的参数而出现的坐标，都是相对于调用该方法前的此 Graphics 对象转换原点的。所有呈现操作仅修改当前剪贴区所限定区域内的像素，此剪贴区是由用户空间中的 Shape 指定的，并通过使用 Graphics 对象的程序来控制。此用户剪贴区 被转换到设备空间中，并与设备剪贴区 组合，后者是通过窗口可见性和设备范围定义的。用户剪贴区和设备剪贴区的组合定义复合剪贴区，复合剪贴区确定最终的剪贴区域。用户剪贴区不能由呈现系统修改，以反映得到的复合剪贴区。用户剪贴区只能通过 setClip 或 clipRect 方法更改。所有的绘制或写入都以当前的颜色、当前绘图模式和当前字体完成。 绘制直线主要用到的内容是Graphics类中的drawLine函数定义： public abstract void drawLine(int x1,int y1,int x2,int y2)x1,y1是起始点的坐标，x2,y2是尾点的坐标 拓展 SetColor(Color color) setColor是Graphics类中的一个函数，主要是设置颜色作用，其中参数是Color类中的一个对象，用于定义自己的颜色，里面的变量的是RGB,定义的方法：Color color=newe Color(R,G,B) 代码 123456789101112131415161718192021222324252627282930 import java.awt.Graphics; import javax.swing.JFrame; import javax.swing.JPanel; public class DrawLineFrame extends JFrame &#123; DrawLinePanel linePanel = new DrawLinePanel(); public static void main(String args[]) &#123; // 主函数 DrawLineFrame frame = new DrawLineFrame(); // 创建一个继承JFrame的一个类对象 frame.setVisible(true); // 设置窗体可见，true为可见，false为不可见 &#125; public DrawLineFrame() &#123; super(); setTitle("绘制直线"); // 设置窗体的标题 setBounds(100, 100, 273, 167); // 设置窗体的显示位置和大小 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置窗体的关闭方式，具体见官方文档 add(linePanel); // 将继承Jpanel类的容器对象添加在窗体中 &#125; class DrawLinePanel extends JPanel &#123; // 继承在JPanel类的一个内部类，用于定义直线 public void paint(Graphics g) &#123; // 重写JCommponent类中的paint方法，用来绘制直线 Color color=new Color(Color.Red);//这里用的是Color提供的颜色，当然读者也可以自己定义RGB颜色 g.setColor(Color);//将颜色作用于绘图上下文 g.drawLine(70, 50, 180, 50); // 调用方法 g.drawLine(70, 80, 180, 80); // 第二条直线 g.drawLine(110, 10, 140, 120); // 第三条 &#125; &#125;&#125; 绘制矩形主要用到的函数是：public abstract void drawRect(int x,int y,int width,int height)这里的x,y是矩形左上角的坐标，width，height是矩形的长和宽 拓展fillRect(int x,int y,int width,int height):绘制实心矩形 代码 1234567891011121314151617181920212223242526import java.awt.Graphics;import javax.swing.JFrame;import javax.swing.JPanel;public class DrawRectangleFrame extends JFrame &#123;DrawRectanglePanel rectPanel = new DrawRectanglePanel(); // 创建面板类的实例public static void main(String args[]) &#123; // 主方法 DrawRectangleFrame frame = new DrawRectangleFrame(); // 创建窗体类的实例 frame.setVisible(true); // 显示窗体&#125;public DrawRectangleFrame() &#123; super(); // 调用超类的构造方法 setTitle("绘制矩形"); // 窗体标题 setBounds(100, 100, 269, 184); // 窗体的显示位置和大小 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 窗体关闭方式 add(rectPanel); // 将面板类的实例添加到窗体容器中&#125;class DrawRectanglePanel extends JPanel &#123; // 创建内部面板类 public void paint(Graphics g) &#123; // 重写paint()方法 g.drawRect(30, 40, 80, 60); // 绘制空心矩形 g.fillRect(140, 40, 80, 60); // 绘制实心矩形 &#125;&#125;&#125; 绘制椭圆 函数：public abstract void drawOval(int x,int y,int width,int height),其中x,y是外切矩形的左上角的坐标，width，height是长宽 拓展 其中将令width=height，即是一个圆了，fillOval(int x,int y,int width,int height)用来绘制实心的椭圆 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 package com.zzk; import java.awt.Graphics; import javax.swing.JFrame; import javax.swing.JPanel; public class DrawEllipseFrame extends JFrame &#123; DrawEllipsePanel ellipsePanel = new DrawEllipsePanel(); // 创建面板类的实例 public static void main(String args[]) &#123; // 主方法 DrawEllipseFrame frame = new DrawEllipseFrame(); // 创建窗体类的实例 frame.setVisible(true); // 显示窗体 &#125; public DrawEllipseFrame() &#123; super(); // 调用超类的构造方法 setTitle("绘制椭圆"); // 窗体标题 setBounds(100, 100, 269, 222); // 窗体的显示位置和大小 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 窗体关闭方式 add(ellipsePanel); // 将面板类的实例添加到窗体容器中 &#125; class DrawEllipsePanel extends JPanel &#123; // 创建内部面板类 public void paint(Graphics g) &#123; // 重写paint()方法 g.drawOval(30, 20, 80, 50); // 绘制空心椭圆 g.drawOval(150, 10, 50, 80); // 绘制空心椭圆 g.fillOval(40, 90, 50, 80); // 绘制实心椭圆 g.fillOval(140, 110, 80, 50); // 绘制实心椭圆 &#125; &#125; &#125; ``` &gt;&gt;## 绘制圆弧&gt;&gt;&gt;主要用到的函数`public astract void drawArc(int x,int y,int width,int height,int startAngle,int arcAngle)`，其中x,y是要绘制圆弧的左上角的坐标，width，height是要绘制的长宽，startAngle是开始角度，arcAngle是相对于开始角度而言的，弧跨越的角度，&gt;&gt;&gt;&gt;### 拓展:&gt;&gt;&gt;&gt;&gt;fillArc(int x,int y,int width,int height,int startAngle,int arcAngle)用来绘制实心圆弧&gt;&gt;&gt;&gt;&gt;当然你也可以用这个来绘制扇形，用drawLine方法将圆弧的两端连起来就可以了，不过这个对坐标的精确度就要求很高了，暂时不想费那个脑筋来搞了&gt;&gt;&gt;&gt;### 代码```java package com.zzk; import java.awt.Graphics; import javax.swing.JFrame; import javax.swing.JPanel; public class DrawArcFrame extends JFrame &#123; DrawArcPanel arcPanel = new DrawArcPanel(); // 创建面板类的实例 public static void main(String args[]) &#123; // 主方法 DrawArcFrame frame = new DrawArcFrame(); // 创建窗体类的实例 frame.setVisible(true); // 显示窗体 &#125; public DrawArcFrame() &#123; super(); // 调用超类的构造方法 setTitle("绘制圆弧"); // 窗体标题 setBounds(100, 100, 269, 184); // 窗体的显示位置和大小 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 窗体关闭方式 add(arcPanel); // 将面板类的实例添加到窗体容器中 &#125; class DrawArcPanel extends JPanel &#123; // 创建内部面板类 public void paint(Graphics g) &#123; // 重写paint()方法 g.drawArc(20, 20, 80, 80, 0, 120); // 绘制圆弧 g.drawArc(20, 40, 80, 80, 0, -120); // 绘制圆弧 g.drawArc(150, 20, 80, 80, 180, -120);// 绘制圆弧 g.drawArc(150, 40, 80, 80, 180, 120); // 绘制圆弧 &#125; &#125; &#125; 绘制多边形 主要用到的函数是：public abstract void drawPolygon(int[] xpoints,int[] ypoints,int npoints)，其中xpoints：要绘制多边形的x坐标组，ypoints是要绘制多边形的y坐标组，npoints是多边形的n条边 拓展 fillPolygon(...)是绘制实心多边形的函数 代码 1234567891011121314151617181920212223242526package com.zzk;import java.awt.Graphics;import javax.swing.JFrame;import javax.swing.JPanel;public class DrawSectorFrame extends JFrame &#123;DrawSectorPanel sectorPanel = new DrawSectorPanel(); // 创建面板类的实例public static void main(String args[]) &#123; // 主方法 DrawSectorFrame frame = new DrawSectorFrame(); // 创建窗体类的实例 frame.setVisible(true); // 显示窗体&#125;public DrawSectorFrame() &#123; super(); // 调用超类的构造方法 setTitle("绘制填充扇形"); // 窗体标题 setBounds(100, 100, 278, 184); // 窗体的显示位置和大小 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 窗体关闭方式 add(sectorPanel); // 将面板类的实例添加到窗体容器中&#125;class DrawSectorPanel extends JPanel &#123; // 创建内部面板类 public void paint(Graphics g) &#123; // 重写paint()方法 g.fillArc(40, 20, 80, 80, 0, 150); // 绘制填充扇形 g.fillArc(140, 20, 80, 80, 180, -150);// 绘制填充扇形 g.fillArc(40, 40, 80, 80, 0, -110); // 绘制填充扇形 g.fillArc(140, 40, 80, 80, 180, 110); // 绘制填充扇形 &#125;&#125;&#125; 绘制文本 主要用到的函数是：public abstract void drawString(String value,int x,int y),其中value是要绘制的文本，x,y是第一个字的坐标 拓展 SetFont(Font font):这个函数是用来设置文本的字体大小，颜色的，其中参数font是Font类中的 代码 12345678910111213141516171819202122232425262728293031323334353637package com.zzk;import java.awt.Font;import java.awt.Graphics;import javax.swing.JFrame;import javax.swing.JPanel;public class TextFontFrame extends JFrame &#123;ChangeTextFontPanel changeTextFontPanel = new ChangeTextFontPanel(); // 创建面板类的实例public static void main(String args[]) &#123; // 主方法 TextFontFrame frame = new TextFontFrame(); // 创建窗体类的实例 frame.setVisible(true); // 显示窗体&#125;public TextFontFrame() &#123; super(); // 调用超类的构造方法 setTitle("设置文本的字体"); // 窗体标题 setBounds(100, 100, 333, 199); // 窗体的显示位置和大小 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 窗体关闭方式 add(changeTextFontPanel); // 将面板类的实例添加到窗体容器中&#125;class ChangeTextFontPanel extends JPanel &#123; // 创建内部面板类 public void paint(Graphics g) &#123; // 重写paint()方法 String value = "明日编程词典社区"; int x = 40; // 文本位置的横坐标 int y = 50; // 文本位置的纵坐标 Font font = new Font("华文行楷", Font.BOLD + Font.ITALIC, 26); // 创建字体对象 g.setFont(font); // 设置字体 g.drawString(value, x, y); // 绘制文本 value = "http://community.mrbccd.com"; x = 10; // 文本位置的横坐标 y = 100; // 文本位置的纵坐标 font = new Font("宋体", Font.BOLD, 20); // 创建字体对象 g.setFont(font); // 设置字体 g.drawString(value, x, y); // 绘制文本 &#125;&#125;&#125; 补充 字体样式包括Font.BLOD(粗体)，Font.ITALIC(斜体)，Font.PLAIN(普通字体)，其中如果要设置两种样式，可以用”+”连接，如：Font.BLOD+Font.ITALIC，这样就会同时设置了斜体和粗体样式 以上是本人的学习成果，通过不断的学习和探索，发现网上没有什么系统的学习java图形处理的文章，就下定决心准备好好写，于是前几天就花了一晚上的时间搭建了博客，以前都是在CSDN上写的，发现在那上面写，没有逼格，为了提高逼格，自己撸了一个博客，让我来自由发挥，另外喜欢编程的朋友可以加我的联系方式，我们可以一起探讨，在下面留言也是可以的哦,联系方式可以在我的关于我可以找到 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
  
  
</search>
