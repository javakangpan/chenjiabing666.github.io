<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo博客如何被百度收录？</title>
    <url>/2020/10/30/Hexo%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E8%A2%AB%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大部分人写博客都希望让别人访问到，但是<code>GitHub</code>和<code>Coding</code>都做了防爬虫的处理，因此我们托管在其上的博客就无法被搜索引擎收录，需要我们手动提交。</p>
<p>今天作者就来介绍下如何才能让度娘收录你的博客。作者的博客是<code>HEXO+GitHub</code>搭建的，主题是<code>NEXT</code>，虽说各种主题不一样，但是大致步骤相同，要学会举一反三。</p>
<p>当然觉得<code>NEXT</code>主题不错的朋友，可以切换主题，之前出过一篇<code>NEXT</code>主题优化的教程：<a href="https://mp.weixin.qq.com/s/Y0PyyBLck24ZPu2o6afsLw" target="_blank" rel="external">女朋友看了我的博客，说太LOW了，于是我折腾了一天~</a><br><a id="more"></a></p>
<h2 id="如何判断自己的博客被百度收录了？"><a href="#如何判断自己的博客被百度收录了？" class="headerlink" title="如何判断自己的博客被百度收录了？"></a>如何判断自己的博客被百度收录了？</h2><p>判断自己的博客有没被百度收录很简单，搜索<code>site:域名</code>，比如<code>site:www.baidu.com</code>。</p>
<p>如果搜索出结果，则表明被百度收录了，如下我的博客：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Hexo%E5%A6%82%E4%BD%95%E8%A2%AB%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95/1.png" alt=""></p>
<h2 id="如何操作？"><a href="#如何操作？" class="headerlink" title="如何操作？"></a>如何操作？</h2><p>操作步骤还是挺复杂的，但是跟着一步一步总能成功，下面将会逐一介绍。</p>
<h3 id="准备一个百度站长账号"><a href="#准备一个百度站长账号" class="headerlink" title="准备一个百度站长账号"></a>准备一个百度站长账号</h3><p>已经有的不用申请了，没有的注册一个，注册地址：<code>https://ziyuan.baidu.com</code></p>
<h3 id="验证网站所有权"><a href="#验证网站所有权" class="headerlink" title="验证网站所有权"></a>验证网站所有权</h3><p>网站所有权通过验证之后，百度会认为你是网站所有者，那么你能做自动推送，手动提交等等功能。</p>
<p>没有验证过的可以自己认证下，网址：<code>https://ziyuan.baidu.com/site/siteadd</code>。</p>
<p>打开之后输入你的博客首页地址，可以是<code>Github Pages</code>或者<code>Coding</code>的地址，然后点击下一步。</p>
<h3 id="HTML验证"><a href="#HTML验证" class="headerlink" title="HTML验证"></a>HTML验证</h3><p>这里的验证其实有三种方式，这里作者说下<code>HTML</code>验证的方式。</p>
<p>这里的方法需要根据不同的主题进行配置，作者使用的是<code>NEXT</code>主题，其他主题可以自己摸索。</p>
<blockquote>
<p>原理其实都是一样：都是将<code>HTML</code>验证标签加入到博客每个页面的<code>head</code>里面！注意是红框中完整的标签，而不是一部分！</p>
</blockquote>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Hexo%E5%A6%82%E4%BD%95%E8%A2%AB%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95/2.png" alt=""></p>
<p><strong>第一步</strong>：在主题配置文件<code>_config.yml</code>中添加如下一行配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><div class="line"><span class="attr">baidu_site_verification:</span> <span class="literal">true</span></div></pre></td></tr></table></figure>
<p><strong>第二步</strong>：修改<code>themes/next/layout/_partials/head.swig</code>，添加从百度获取的完整的<code>HTML</code>验证标签，注意名字的对应！</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Hexo%E5%A6%82%E4%BD%95%E8%A2%AB%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95/3.png" alt=""></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">&#123;% <span class="keyword">if</span> theme.baidu_site_verification %&#125;</div><div class="line">  &lt;meta name=<span class="string">"baidu-site-verification"</span> content=<span class="string">"你的token"</span> /&gt;</div><div class="line">&#123;% endif %&#125;</div></pre></td></tr></table></figure>
<p><strong>第三步</strong>：编译发布你的博客，在博客首页按<code>F12</code>，如果在<code>head</code>标签中看到了验证标签则成功了，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Hexo%E5%A6%82%E4%BD%95%E8%A2%AB%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95/4.png" alt=""></p>
<p><strong>第四步</strong>：点击验证按钮，如果没问题则已成功。</p>
<h3 id="生成站点地图"><a href="#生成站点地图" class="headerlink" title="生成站点地图"></a>生成站点地图</h3><p>通过构建网站地图能够让搜索引擎更好的抓取你的网站内容。</p>
<p><strong>第一步</strong>：安装插件，在博客根目录，直接CMD运行以下命令安装：<br><figure class="highlight cmd"><table><tr><td class="code"><pre><div class="line">npm install hexo-generator-sitemap --save</div><div class="line">npm install hexo-generator-baidu-sitemap --save</div></pre></td></tr></table></figure></p>
<p><strong>第二步</strong>：修改<strong>站点配置文件_config.yml</strong>中的<code>URL</code>为你的博客首页地址，这样是为了保证生成的<code>sitemap.xml</code>文件中地址正确。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Hexo%E5%A6%82%E4%BD%95%E8%A2%AB%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95/5.png" alt=""></p>
<p><strong>第三步</strong>：在<strong>站点配置文件_config.yml</strong>中指定生成的<code>sitemap</code>的文件名和地址，在配置文件末尾添加如下配置：<br><figure class="highlight yml"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 自动生成sitemap</span></div><div class="line"><span class="attr">sitemap:</span> </div><div class="line"><span class="attr">  path:</span> <span class="string">sitemap.xml</span></div><div class="line"><span class="attr">baidusitemap:</span> </div><div class="line"><span class="attr">  path:</span> <span class="string">baidusitemap.xml</span></div></pre></td></tr></table></figure></p>
<p><strong>第四步</strong>：执行<code>hexo g</code>，正常情况下会在根目录下的<code>public</code>目录下多出两个文件，分别是<code>sitemap.xml</code>和<code>baidusitemap.xml</code>。</p>
<blockquote>
<p>站点地图生成后，只需要<strong>等待百度自动抓取</strong>或者<strong>配置自动配送</strong>或者<strong>主动推送</strong>。</p>
</blockquote>
<p><strong>等待百度自动抓取</strong>：百度收录都有一个周期，估计十几天会抓取一次。</p>
<p><strong>主动推送</strong>：在百度站长内手动提交自己的<code>sitemap.xml</code>内容，如下位置：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Hexo%E5%A6%82%E4%BD%95%E8%A2%AB%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95/6.png" alt=""></p>
<p><strong>自动推送</strong>：这个是今天的重点，下面介绍。</p>
<h3 id="如何自动推送？"><a href="#如何自动推送？" class="headerlink" title="如何自动推送？"></a>如何自动推送？</h3><p><strong>第一步</strong>：修改主题配置文件，将<code>baidu_push</code>修改为<code>true</code>，如下：<br><figure class="highlight yml"><table><tr><td class="code"><pre><div class="line"><span class="attr">baidu_push:</span> <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p><strong>第二步</strong>：修改<code>themes\next\layout\_scripts\baidu_push.swig</code>（没有这个文件则创建），添加以下代码：<br><figure class="highlight js"><table><tr><td class="code"><pre><div class="line">&#123;% <span class="keyword">if</span> theme.baidu_push %&#125;</div><div class="line">&lt;script&gt;</div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> bp = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</div><div class="line">    <span class="keyword">var</span> curProtocol = <span class="built_in">window</span>.location.protocol.split(<span class="string">':'</span>)[<span class="number">0</span>];</div><div class="line">    <span class="keyword">if</span> (curProtocol === <span class="string">'https'</span>) &#123;</div><div class="line">        bp.src = <span class="string">'https://zz.bdstatic.com/linksubmit/push.js'</span>;        </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        bp.src = <span class="string">'http://push.zhanzhang.baidu.com/push.js'</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> s = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"script"</span>)[<span class="number">0</span>];</div><div class="line">    s.parentNode.insertBefore(bp, s);</div><div class="line">&#125;)();</div><div class="line">&lt;/script&gt;</div><div class="line">&#123;% endif %&#125;</div></pre></td></tr></table></figure></p>
<p>以上配置完成后，每次访问博客首页会自动向百度提交，不用再手动提交了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>百度收录操作虽然复杂，但是按照作者的步骤来搞还是非常简单的，对于有博客的朋友可以借鉴下。</p>
<p>另外作者为大家准备接近<code>10M</code>的面筋，涵盖后端的各个层面，老规矩，公众号内回复<code>Java面试宝典</code>即可获取。</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/8.png" alt=""></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png" alt=""></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA2020永久破解，亲测可用！！！</title>
    <url>/2020/05/08/IDEA2020%E6%B0%B8%E4%B9%85%E7%A0%B4%E8%A7%A3%EF%BC%8C%E4%BA%B2%E6%B5%8B%E5%8F%AF%E7%94%A8%EF%BC%81%EF%BC%81%EF%BC%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>随着 IDEA 的 2020 版本的发布，新增和优化了很多的功能，今天陈某不说新增的功能，来讲一讲如何永久破解。</li>
<li><p>不说别的，先上破解后的效果图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA%E7%A0%B4%E8%A7%A3/1.png" alt="永久破解效果图"></p>
<a id="more"></a>
<h2 id="如何破解？"><a href="#如何破解？" class="headerlink" title="如何破解？"></a>如何破解？</h2></li>
<li><p>破解过程很简单，基本是傻瓜式的，过程如下。</p>
</li>
</ul>
<h3 id="1-下载安装"><a href="#1-下载安装" class="headerlink" title="1. 下载安装"></a>1. 下载安装</h3><ul>
<li>官网下载<code>IDEA 2020.1</code>，下载地址自己动手百度吧。</li>
<li>安装成功后，启动 IDEA，选择<code>试用</code>启动 IDEA。</li>
</ul>
<h3 id="下载破解包"><a href="#下载破解包" class="headerlink" title="下载破解包"></a>下载破解包</h3><ul>
<li>公众号回复关键词<code>IDEA破解包</code>下载，其实就是一个 jar 包，如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA%E7%A0%B4%E8%A7%A3/2.png" alt="破解包"></li>
</ul>
<h3 id="开始破解"><a href="#开始破解" class="headerlink" title="开始破解"></a>开始破解</h3><ul>
<li><p>直接将<code>jetbrains-agent.jar</code>文件用鼠标<code>拖进</code>idea 界面，然后一路<code>重启</code>或者<code>确定</code>，中间出现什么拖放失败不用理会，直接点确定就好是正常现象。如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA%E7%A0%B4%E8%A7%A3/3.png" alt="破解"></p>
</li>
<li><p>重启成功后，会跳出如下界面，直接点击<code>为IDEA安装</code>，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA%E7%A0%B4%E8%A7%A3/4.png" alt=""></p>
</li>
<li>继续点击<code>是</code>安装，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA%E7%A0%B4%E8%A7%A3/7.png" alt=""></li>
</ul>
<h3 id="验证是否破解成功"><a href="#验证是否破解成功" class="headerlink" title="验证是否破解成功"></a>验证是否破解成功</h3><ul>
<li>根据上述的步骤 99%的可能破解成功，此时打开 IDEA，点击<code>help-&gt;Register</code>查看是否破解成功，出现下图将是破解成功，如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA%E7%A0%B4%E8%A7%A3/1.png" alt=""></li>
<li>里面的激活码是重启之上自动填入的，如果不行找到下载的压缩文件 lib 下的 ACTIVATION_CODE.txt 换一个激活码或者查看 README.pdf 帮助。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA%E7%A0%B4%E8%A7%A3/5.png" alt=""><br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA%E7%A0%B4%E8%A7%A3/6.png" alt=""></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>至此 IDEA 2020 已经破解成功了，按照陈某的步骤 99%的朋友保证能够破解成功，文中的破解文件在公众号回复<code>IDEA破解包</code>即可获取。</li>
<li>另外如果想要 IDEA 2020 的安装包，回复关键词<code>IDEA2020</code>即可获取。</li>
<li>关注我微信公众号【码猿技术专栏】</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E4%B8%83%E7%A7%92%E7%BC%96%E7%A8%8B.jpg" alt=""></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>破解</tag>
        <tag>优质资源</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA调试技巧</title>
    <url>/2020/03/23/IDEA%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>前天面试了一个985高校的实习生，问了他平时用什么开发工具，他想也没想的说IDEA，于是我抛砖引玉的问了一下IDEA的调试用过吧，你说说怎么设置断点条件？那孩子懵了，想了好一会对我说没用过，甚至都没听说过这个。</li>
<li>作为一名资深的老司机，IDEA调试可以说是家常便饭，如果不会debug，我都不信你读过源码，就别和我说原理了，直接pass掉。<a id="more"></a>
</li>
</ul>
<h2 id="基本界面"><a href="#基本界面" class="headerlink" title="基本界面"></a>基本界面</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODU2MTU0LzIwMTcwOS84NTYxNTQtMjAxNzA5MDUyMjE0MTgxNDctMTIwNTA0MzAyMC5wbmc" alt=""></p>
<p>① 以Debug模式启动服务，左边的一个按钮则是以Run模式启动。在开发中，我一般会直接启动Debug模式，方便随时调试代码。 </p>
<p>② 断点：在左边行号栏单击左键，或者快捷键Ctrl+F8 打上/取消断点，断点行的颜色可自己去设置。 </p>
<p>③ Debug窗口：访问请求到达第一个断点后，会自动激活Debug窗口。如果没有自动激活，可以去设置里设置。</p>
<p>④ 调试按钮：一共有8个按钮，调试的主要功能就对应着这几个按钮，鼠标悬停在按钮上可以查看对应的快捷键。</p>
<p>⑤ 服务按钮：可以在这里关闭/启动服务，设置断点等。 </p>
<p>⑥ 方法调用栈：这里显示了该线程调试所经过的所有方法，勾选右上角的[Show All Frames]按钮，就不会显示其它类库的方法了，否则这里会有一大堆的方法。 </p>
<p>⑦ Variables：在变量区可以查看当前断点之前的当前方法内的变量。 </p>
<p>⑧  Watches：查看变量，可以将Variables区中的变量拖到Watches中查看 。</p>
<h2 id="变量查看"><a href="#变量查看" class="headerlink" title="变量查看"></a>变量查看</h2><ul>
<li>在调试过程中往往需要观察变量的变化来判断业务逻辑，我们可以在以下的四个地方观察。</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032301.png" alt=""></p>
<p>① 最常用的变量的观察区域variables</p>
<p>② IDEA中最人性化的地方之一，会将变量的值阴影显示在变量的后面。</p>
<p>③ watch区域，眼镜的形状，一般不会展开。如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032302.png" alt=""></p>
<p>点击’+’号可以新增需要观察的变量，点击’-‘号可以删除。</p>
<p>④ 鼠标悬停在变量上也会出现变量的值，点击展开即可查看。</p>
<h2 id="计算表达式"><a href="#计算表达式" class="headerlink" title="计算表达式"></a>计算表达式</h2><ul>
<li>在调试业务逻辑的时候一般总会遇到某个条件或者某个变量的计算值的还不知道的情况下就需要判断下一行代码，那么此处就需要用到计算表达式的功能。计算表达式有两种方法，如下：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032303.png" alt=""></p>
<p>① 选择需要计算的代码，鼠标右键—-&gt;Evaluate Expression—&gt;Evaluate即可计算。</p>
<p>② 直接点击计算器形状控件即可弹出计算的窗口，将代码复制进去即可，注意复制进去的代码一定要符合逻辑，比如局部变量一定要是已经声明的。</p>
<h2 id="断点条件设置"><a href="#断点条件设置" class="headerlink" title="断点条件设置"></a>断点条件设置</h2><ul>
<li>对于新手要看Spring源码的话，再遇到调试UserService的doGetBean的方法时可能要崩溃，因为doGetBean在容器启动的时候可能会被调用几十次，你把断点打在doGetBean方法体中能让你生不如死。</li>
<li>设置断点条件有两种方式：<ul>
<li>①直接在断点上右键，添加condition条件即可。</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032304.png" alt=""></li>
<li>② view breakpoints(ctrl+shift+8)显示所有的断点，在condition中添加条件即可。</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032305.png" alt=""></li>
</ul>
</li>
</ul>
<ul>
<li>异常断点：设置了异常断点后，比如空指针异常，在程序出现需要拦截的异常时会自动定位到指定的行。如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032306.png" alt=""></p>
<p>① ctrl+shift+F8显示所有断点，点击+号添加<code>Java Exception Breakpoints</code>。</p>
<p>② debug运行，一旦有代码出现该异常，会自动定位到指定代码。</p>
<h2 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h2><ul>
<li>通常我们在调试的时候，一个请求过来被拦截了，此时想要发起另外一个请求是无法重新发的，因为另外一个请求被阻塞了，只有当前线程执行完成之后才会走其他的线程。在IDEA中可以改变一下阻塞级别，有两种方法：<ul>
<li>断点上右键—&gt;选择Thread—-&gt;Make Default，如下图：</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032307.png" alt=""></li>
<li>显示所有断点(crtl+shift+F8)，选中某一个断点，选择Thread，Make Default即可。如下图：</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032308.png" alt=""></li>
</ul>
</li>
<li>设置了阻塞级别，此时就可以在线程切换了，如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032309.png" alt=""></p>
<h2 id="强制抛异常"><a href="#强制抛异常" class="headerlink" title="强制抛异常"></a>强制抛异常</h2><p>这是IDEA 2018年加入的新功能，可以直接在调试中抛出指定的异常。使用方法跟上面的弃栈帧类似，右击栈帧并选择<strong>Throw Exception</strong>，然后输入抛异常的代码，比如<code>throw new NullPointerException</code>，操作如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032310.png" alt=""></p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032311.png" alt=""></p>
<h2 id="强制返回"><a href="#强制返回" class="headerlink" title="强制返回"></a>强制返回</h2><ul>
<li>这是IDEA2015版时增加的功能，类似上面的手动抛异常，只不过是返回一个指定值罢了。使用方法跟上面也都类似，右击栈帧并选择<strong>Force Return</strong>，然后输入要返回的值即可。如果是<code>void</code>的方法那就更简单了，连返回值都不用输。如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032312.png" alt=""></p>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg" alt=""></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis.动态SQL，你真的会了吗？</title>
    <url>/2020/04/20/Mybatis.%E5%8A%A8%E6%80%81SQL%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>通过前两篇的文章我们了解了Mybatis基本的CRUD操作、一些基本标签的属性以及如何映射结果，感兴趣的可以看我的前两篇文章，分别是<a href="https://mp.weixin.qq.com/s/KdrEvlShnVoYA8nr0qLSNw" target="_blank" rel="external">Mybatis入门之基础操作</a>和<a href="https://mp.weixin.qq.com/s/czICR6jv1yz6adi6G3xFgQ" target="_blank" rel="external">Mybatis结果映射，你射准了吗？</a>，如果有什么疑问的地方可以在文章下方留言，作者统一回复。</li>
<li>这篇文章就来聊一聊Mybatis的动态SQL，在实际的开发中Mybatis的这项功能是非常重要的，至于什么是动态SQL？如何实现动态SQL？下面文章将会详细介绍。<a id="more"></a>
<h2 id="什么是动态SQL？"><a href="#什么是动态SQL？" class="headerlink" title="什么是动态SQL？"></a>什么是动态SQL？</h2></li>
<li>动态 SQL 是 MyBatis 的强大特性之一。顾名思义，就是会动的SQL，即是能够灵活的根据某种条件拼接出完整的SQL语句。这种类似于MySQL中的<code>case when then else then end....</code>这种语法，能够根据某种条件动态的拼接出需要的SQL。</li>
<li>至于Mybatis如何实现动态SQL呢，Mybatis提供了非常多的标签，能够让我们在XML文件中灵活的运用这些标签达到拼接SQL的目的。</li>
</ul>
<h2 id="常用的标签"><a href="#常用的标签" class="headerlink" title="常用的标签"></a>常用的标签</h2><ul>
<li>Mybatis为了能够让开发者灵活的写SQL也是费了一番功夫，定义了很多的标签和语法，下面将会一一介绍。</li>
</ul>
<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><ul>
<li>虽然英文不太好，但是在这么简单的不会不知道是<code>如果</code>的意思吧，Java语法中也有，只有判断条件为<code>true</code>才会执行其中的SQL语句。</li>
<li>举个栗子：HIS系统中医护人员需要根据特定条件筛选患者，比如住院号，床位，性别等。当然这些条件并不是必填的，具体的功能截图如下:<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-%E5%8A%A8%E6%80%81SQL/1.png" alt=""></li>
<li><p>以上截图中的条件筛选并不是必填的，因此我们不能在SQL中固定，要根据前端是否传值来判断是否需要加上这个条件。那么此时查询语句如何写呢？如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span> =<span class="string">'selectPats'</span> <span class="attr">resultType</span>=<span class="string">'com.xxx.domain.PatientInfo'</span>&gt;</span></div><div class="line">  select * from patient_info </div><div class="line">  where status=1</div><div class="line">  <span class="comment">&lt;!--前端传来的住院号不为null，表示需要根据住院号筛选，此时Where语句就需要加上这个条件--&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"iptNum!=null"</span>&gt;</span></div><div class="line">      and ipt_num=#&#123;iptNum&#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></div><div class="line">  </div><div class="line">  <span class="comment">&lt;!--床位号筛选--&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"bedNum!=null"</span>&gt;</span></div><div class="line">      and bed_num=#&#123;bedNum&#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>&lt;if&gt;</code>标签中的属性<code>test</code>用来指定判断条件，那么问题来了，上面的例子中的<code>test</code>中判断条件都是一个条件，如果此时变成两个或者多个条件呢？和SQL的语法类似，<code>and</code>连接即可，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"bedNum!=null and bedNum!='' "</span>&gt;</span></div><div class="line">    and bed_num=#&#123;bedNum&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h3><ul>
<li>有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis 提供了 <code>choose</code> 元素，它有点像 Java 中的 <code>switch</code> 语句。</li>
<li><p>还是上面的例子改变一下：此时只能满足一个筛选条件，如果前端传来住院号就只按照住院号查找，如果传来床位号就只按照床位号筛选，如果什么都没传，就筛选所有在院的。此时的查询如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectPats"</span></span></div><div class="line">     <span class="attr">resultType</span>=<span class="string">"com.xxx.domain.PatientInfo"</span>&gt;</div><div class="line">  select * from patient_info where 1=1</div><div class="line">  <span class="tag">&lt;<span class="name">choose</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--住院号不为null时，根据住院号查找--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"iptNum != null"</span>&gt;</span></div><div class="line">      AND ipt_num=#&#123;iptNum&#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--床位号不是NUll--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"bedNum != null"</span>&gt;</span></div><div class="line">      AND bed_num = #&#123;bedNum&#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></div><div class="line">      AND status=1</div><div class="line">    <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>MyBatis 提供了 <code>choose</code> 元素，按顺序判断 <code>when</code> 中的条件出否成立，如果有一个成立，则 <code>choose</code> 结束。当 <code>choose</code> 中所有 <code>when</code> 的条件都不满则时，则执行 <code>otherwise</code> 中的 sql。类似于 Java 的 <code>switch</code> 语句，<code>choose</code> 为 <code>switch</code>，<code>when</code> 为 <code>case</code>，<code>otherwise</code> 则为<code>default</code>。</p>
</li>
</ul>
<h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><ul>
<li><p>举个栗子：对于<code>choose</code>标签的例子中的查询，如果去掉<code>where</code>后的<code>1=1</code>此时的SQL语句会变成什么样子，有三种可能的SQL，如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> patient_info <span class="keyword">where</span> <span class="keyword">AND</span> ipt_num=#&#123;iptNum&#125;;</div><div class="line"></div><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> patient_info <span class="keyword">where</span> <span class="keyword">AND</span> bed_num = #&#123;bedNum&#125;;</div><div class="line"></div><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> patient_info <span class="keyword">where</span> <span class="keyword">AND</span> <span class="keyword">status</span>=<span class="number">1</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>发生了什么，以上三条SQL语句对吗？很显然是不对的，显然<code>where</code>后面多了个<code>AND</code>。如何解决呢？此时就要用到<code>where</code>这个标签了。</p>
</li>
<li><code>where</code> 元素只会在子元素返回任何内容的情况下才插入 <code>WHERE</code> 子句。而且，若子句的开头为 <code>AND</code> 或 <code>OR</code>，<code>where</code> 元素也会将它们去除。</li>
<li>此时的查询改造如下：<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectPats"</span></span></div><div class="line">     <span class="attr">resultType</span>=<span class="string">"com.xxx.domain.PatientInfo"</span>&gt;</div><div class="line">  select * from patient_info</div><div class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span></div><div class="line">          <span class="comment">&lt;!--住院号不为null时，根据住院号查找--&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"iptNum != null"</span>&gt;</span></div><div class="line">            AND ipt_num=#&#123;iptNum&#125;</div><div class="line">          <span class="tag">&lt;/<span class="name">when</span>&gt;</span></div><div class="line">          <span class="comment">&lt;!--床位号不是NUll--&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"bedNum != null"</span>&gt;</span></div><div class="line">            AND bed_num = #&#123;bedNum&#125;</div><div class="line">          <span class="tag">&lt;/<span class="name">when</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></div><div class="line">            AND status=1</div><div class="line">          <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">where</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><ul>
<li><code>foreach</code>是用来对集合的遍历，这个和Java中的功能很类似。通常处理SQL中的<code>in</code>语句。</li>
<li><code>foreach</code> 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（<code>item</code>）和索引（<code>index</code>）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符</li>
<li>你可以将任何可迭代对象（如 <code>List</code>、<code>Set</code> 等）、<code>Map</code> 对象或者数组对象作为集合参数传递给 foreach。当使用可迭代对象或者数组时，<code>index</code> 是当前迭代的序号，<code>item</code> 的值是本次迭代获取到的元素。当使用 <code>Map</code> 对象（或者 <code>Map.Entry</code> 对象的集合）时，<code>index</code> 是键，<code>item</code> 是值。</li>
<li><p>例子如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectPats"</span> <span class="attr">resultType</span>=<span class="string">"com.xxx.domain.PatientInfo"</span>&gt;</span></div><div class="line">  SELECT *</div><div class="line">  FROM patient_info </div><div class="line">  WHERE ID in</div><div class="line">  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">collection</span>=<span class="string">"list"</span></span></div><div class="line">      <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">separator</span>=<span class="string">","</span> <span class="attr">close</span>=<span class="string">")"</span>&gt;</div><div class="line">        #&#123;item&#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>改标签中的各个属性的含义如下：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>item</td>
<td>表示在迭代过程中每一个元素的别名</td>
</tr>
<tr>
<td>index</td>
<td>表示在迭代过程中每次迭代到的位置（下标）</td>
</tr>
<tr>
<td>open</td>
<td>前缀</td>
</tr>
<tr>
<td>close</td>
<td>后缀</td>
</tr>
<tr>
<td>separator</td>
<td>分隔符，表示迭代时每个元素之间以什么分隔</td>
</tr>
</tbody>
</table>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><ul>
<li><p>讲这个标签之前，先看下面这个例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateStudent"</span> <span class="attr">parameterType</span>=<span class="string">"Object"</span>&gt;</span></div><div class="line">    UPDATE STUDENT</div><div class="line">    SET NAME = #&#123;name&#125;,</div><div class="line">    MAJOR = #&#123;major&#125;,</div><div class="line">    HOBBY = #&#123;hobby&#125;</div><div class="line">    WHERE ID = #&#123;id&#125;;</div><div class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateStudent"</span> <span class="attr">parameterType</span>=<span class="string">"Object"</span>&gt;</span></div><div class="line">    UPDATE STUDENT SET</div><div class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"name!=null and name!='' "</span>&gt;</span></div><div class="line">        NAME = #&#123;name&#125;,</div><div class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"hobby!=null and hobby!='' "</span>&gt;</span></div><div class="line">        MAJOR = #&#123;major&#125;,</div><div class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"hobby!=null and hobby!='' "</span>&gt;</span></div><div class="line">        HOBBY = #&#123;hobby&#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></div><div class="line">    WHERE ID = #&#123;id&#125;;</div><div class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>上面的例子中没有使用 <code>if</code> 标签时，如果有一个参数为 <code>null</code>，都会导致错误。当在 <code>update</code> 语句中使用 <code>if</code> 标签时，如果最后的 <code>if</code> 没有执行，则或导致逗号多余错误。使用 <code>set</code> 标签可以将动态的配置 <code>set</code> 关键字，和剔除追加到条件末尾的任何不相关的逗号。</p>
</li>
<li><p>使用 set+if 标签修改后，如果某项为 null 则不进行更新，而是保持数据库原值。此时的查询如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateStudent"</span> <span class="attr">parameterType</span>=<span class="string">"Object"</span>&gt;</span></div><div class="line">    UPDATE STUDENT</div><div class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"name!=null and name!='' "</span>&gt;</span></div><div class="line">            NAME = #&#123;name&#125;,</div><div class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"hobby!=null and hobby!='' "</span>&gt;</span></div><div class="line">            MAJOR = #&#123;major&#125;,</div><div class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"hobby!=null and hobby!='' "</span>&gt;</span></div><div class="line">            HOBBY = #&#123;hobby&#125;</div><div class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></div><div class="line">    WHERE ID = #&#123;id&#125;;</div><div class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h3><ul>
<li>在实际开发中会遇到许多相同的SQL，比如根据某个条件筛选，这个筛选很多地方都能用到，我们可以将其抽取出来成为一个公用的部分，这样修改也方便，一旦出现了错误，只需要改这一处便能处处生效了，此时就用到了<code>&lt;sql&gt;</code>这个标签了。</li>
<li>当多种类型的查询语句的查询字段或者查询条件相同时，可以将其定义为常量，方便调用。为求 <code>&lt;select&gt;</code> 结构清晰也可将 sql 语句分解。如下：<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 查询字段 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"Base_Column_List"</span>&gt;</span></div><div class="line">    ID,MAJOR,BIRTHDAY,AGE,NAME,HOBBY</div><div class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 查询条件 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"Example_Where_Clause"</span>&gt;</span></div><div class="line">    where 1=1</div><div class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">suffixOverrides</span>=<span class="string">","</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"id != null and id !=''"</span>&gt;</span></div><div class="line">            and id = #&#123;id&#125;</div><div class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"major != null and major != ''"</span>&gt;</span></div><div class="line">            and MAJOR = #&#123;major&#125;</div><div class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"birthday != null "</span>&gt;</span></div><div class="line">            and BIRTHDAY = #&#123;birthday&#125;</div><div class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"age != null "</span>&gt;</span></div><div class="line">            and AGE = #&#123;age&#125;</div><div class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"name != null and name != ''"</span>&gt;</span></div><div class="line">            and NAME = #&#123;name&#125;</div><div class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"hobby != null and hobby != ''"</span>&gt;</span></div><div class="line">            and HOBBY = #&#123;hobby&#125;</div><div class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="include"><a href="#include" class="headerlink" title="include"></a>include</h3><ul>
<li><p>这个标签和<code>&lt;sql&gt;</code>是天仙配，是共生的，<code>include</code>用于引用<code>sql</code>标签定义的常量。比如引用上面sql标签定义的常量，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectAll"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>&gt;</span></div><div class="line">    SELECT</div><div class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"Base_Column_List"</span> /&gt;</span></div><div class="line">    FROM student</div><div class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"Example_Where_Clause"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>refid</code>这个属性就是指定<code>&lt;sql&gt;</code>标签中的<code>id</code>值（唯一标识）。</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>至此，Mybatis动态SQL中常用的标签就已经介绍完了，这部分的内容在实际工作中是必须会用到的，除非你们公司不用Mybatis。</li>
</ul>
<h2 id="拓展一下"><a href="#拓展一下" class="headerlink" title="拓展一下"></a>拓展一下</h2><ul>
<li>前面介绍了动态SQL的一些标签以及属性，相信看完之后应该能够灵活的应用了，但是在实际开发中还是有一些奇技淫巧的，陈某今天简单的讲几个。</li>
</ul>
<h3 id="Mybatis中如何避免魔数"><a href="#Mybatis中如何避免魔数" class="headerlink" title="Mybatis中如何避免魔数"></a>Mybatis中如何避免魔数</h3><ul>
<li>开过阿里巴巴开发手册的大概都知道代码中是不允许出现<code>魔数</code>的，何为<code>魔数</code>？简单的说就是一个数字，一个只有你知道，别人不知道这个代表什么意思的数字。通常我们在Java代码中都会定义一个常量类专门定义这些数字。</li>
<li><p>比如获取医生和护士的权限，但是医生和护士的权限都不相同，在这条SQL中肯定需要根据登录的类型<code>type</code>来区分，比如<code>type=1</code>是医生，<code>type=2</code>是护士，估计一般人会这样写：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"type!=null and type==1"</span>&gt;</span></div><div class="line">    -- ....获取医生的权限</div><div class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"type!=null and type==2"</span>&gt;</span></div><div class="line">    -- ....获取护士的权限</div><div class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>这样写也没什么错，但是一旦这个<code>type</code>代表的含义变了，那你是不是涉及到的SQL都要改一遍。</p>
</li>
<li><p>开发中通常定义一个常量类，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> com.xxx.core.Constants;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonConstants</span></span>&#123;</div><div class="line">  <span class="comment">//医生</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> DOC_TYPE=<span class="number">1</span>;</div><div class="line">  </div><div class="line">  <span class="comment">//护士</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NUR_TYPE=<span class="number">2</span>;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>那么此时的SQL应该如何写呢？如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"type!=null and type==@com.xxx.core.Constants.CommonConstants@DOC_TYPE"</span>&gt;</span></div><div class="line">    -- ....获取医生的权限</div><div class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"type!=null and type==@com.xxx.core.Constants.CommonConstants@NUR_TYPE"</span>&gt;</span></div><div class="line">    -- ....获取护士的权限</div><div class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>就是这么简单，就是<code>@</code>+<code>全类名</code>+<code>@</code>+<code>常量</code>。</p>
</li>
<li>除了调用常量类中的常量，还可以类中的方法，很少用到，不再介绍了，感兴趣的可以问下度娘。</li>
</ul>
<h3 id="如何引用其他XML中的SQL片段"><a href="#如何引用其他XML中的SQL片段" class="headerlink" title="如何引用其他XML中的SQL片段"></a>如何引用其他XML中的SQL片段</h3><ul>
<li>实际开发中你可能遇到一个问题，比如这个<code>resultMap</code>或者这个<code>&lt;sql&gt;</code>片段已经在另外一个<code>xxxMapper.xml</code>中已经定义过了，此时当前的xml还需要用到，难不成我复制一份？小白什么也不问上来就复制了，好吧，后期修改来了，每个地方都需要修改了。难受不？</li>
<li><p>其实Mybatis中也是支持引用其他Mapper文件中的SQL片段的。其实很简单，比如你在<code>com.xxx.dao.xxMapper</code>这个Mapper的XML中定义了一个SQL片段如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"Base_Column_List"</span>&gt;</span></div><div class="line">    ID,MAJOR,BIRTHDAY,AGE,NAME,HOBBY</div><div class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>此时我在<code>com.xxx.dao.PatinetMapper</code>中的XML文件中需要引用，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"com.xxx.dao.xxMapper.Base_Column_List"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>如此简单，类似于Java中的全类名。</p>
</li>
<li><code>&lt;select&gt;</code>标签中的<code>resultMap</code>同样可以这么引用，和上面引用的方式一样，不再赘述了。</li>
</ul>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li>好了，Myabtis的动态SQL的内容已经介绍完了，你会了吗？每日来看看，下面会有更多精彩的内容！！！</li>
<li>如果 觉得写的不错的，点点在看，关注一波不迷路，每天都会有精彩内容分享。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E4%B8%83%E7%A7%92%E7%BC%96%E7%A8%8B.jpg" alt=""></li>
</ul>
]]></content>
      <categories>
        <category>Mybatis进阶</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis入门之基本操作！！！</title>
    <url>/2020/04/20/Mybatis%E5%85%A5%E9%97%A8%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%81%EF%BC%81%EF%BC%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><p>作为一个资深后端码农天天都要和数据库打交道，最早使用的是 Hiberate，一个封装性极强的持久性框架。自从接触到 Mybatis 就被它的灵活性所折服了，可以自己写 SQL，虽然轻量级，但是麻雀虽小，五脏俱全。这篇文章就来讲讲什么是 Mybatis，如何简单的使用 Mybatis。</p>
<a id="more"></a>
<h2 id="什么是-Mybatis"><a href="#什么是-Mybatis" class="headerlink" title="什么是 Mybatis"></a>什么是 Mybatis</h2></li>
<li><p>MyBatis 是一款优秀的<code>持久层</code>框架，它支持<code>自定义 SQL</code>、<code>存储过程</code>以及<code>高级映射</code>。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 <code>XML</code> 或注解来配置和映射原始类型、接口和 <code>Java POJO</code>（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>
</li>
</ul>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li>本篇文章使用的环境是<code>SpringBoot+Mybatis+Mysql</code></li>
</ul>
<h3 id="Maven-依赖"><a href="#Maven-依赖" class="headerlink" title="Maven 依赖"></a>Maven 依赖</h3><ul>
<li>MySQL 驱动依赖和 Druid 连接池的依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.40<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--druid连接池--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>Mybatis 启动包依赖，此处导入的是 SpringBoot 和 Mybatis 整合启动器的依赖，点击去可以看到，这个启动包依赖了<code>mybatis</code>和<code>mybatis-spring</code>（Mybatis 和 Spring 整合的 Jar 包），因此使用 SpringBoot 之后只需要导入这个启动器的依赖即可。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>以上两个依赖添加成功后，Maven 环境就已经配置完了。</li>
</ul>
<h3 id="数据库连接池配置（Druid）"><a href="#数据库连接池配置（Druid）" class="headerlink" title="数据库连接池配置（Druid）"></a>数据库连接池配置（Druid）</h3><ul>
<li>这个不是本文的重点，而且网上很多教程，我就简单的配置一下，在 SpringBoot 的<code>application.properties</code>中配置即可。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">##单一数据源</div><div class="line">spring.datasource.url=jdbc\:mysql\://127.0.0.1\:3306/vivachekcloud_pzhdermyy?useUnicode\=true&amp;characterEncoding\=UTF-8&amp;zeroDateTimeBehavior\=convertToNull&amp;useSSL\=false</div><div class="line">spring.datasource.username=root</div><div class="line">spring.datasource.password=123456</div><div class="line">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</div><div class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</div><div class="line">#初始化连接大小</div><div class="line">spring.datasource.druid.initial-size=0</div><div class="line">#连接池最大使用连接数量</div><div class="line">spring.datasource.druid.max-active=20</div><div class="line">#连接池最小空闲</div><div class="line">spring.datasource.druid.min-idle=0</div><div class="line">#获取连接最大等待时间</div><div class="line">spring.datasource.druid.max-wait=6000</div><div class="line">spring.datasource.druid.validation-query=SELECT 1</div><div class="line">#spring.datasource.druid.validation-query-timeout=6000</div><div class="line">spring.datasource.druid.test-on-borrow=false</div><div class="line">spring.datasource.druid.test-on-return=false</div><div class="line">spring.datasource.druid.test-while-idle=true</div><div class="line">#配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</div><div class="line">spring.datasource.druid.time-between-eviction-runs-millis=60000</div><div class="line">#置一个连接在池中最小生存的时间，单位是毫秒</div><div class="line">spring.datasource.druid.min-evictable-idle-time-millis=25200000</div><div class="line">#spring.datasource.druid.max-evictable-idle-time-millis=</div><div class="line">#打开removeAbandoned功能,多少时间内必须关闭连接</div><div class="line">spring.datasource.druid.removeAbandoned=true</div><div class="line">#1800秒，也就是30分钟</div><div class="line">spring.datasource.druid.remove-abandoned-timeout=1800</div><div class="line">#&lt;!-- 1800秒，也就是30分钟 --&gt;</div><div class="line">spring.datasource.druid.log-abandoned=true</div><div class="line">spring.datasource.druid.filters=mergeStat</div><div class="line">#spring.datasource.druid.verifyServerCertificate</div><div class="line">#spring.datasource.filters=stat,wall,log4j</div><div class="line"># 通过connectProperties属性来打开mergeSql功能；慢SQL记录</div><div class="line">spring.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000</div></pre></td></tr></table></figure>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul>
<li><code>dao</code>层：用于存放和数据库交互的文件，Mybatis 的<code>interface</code>都放在此层</li>
<li><code>service</code>层：用于存放业务逻辑的文件。</li>
</ul>
<h2 id="配置-xml-文件存放的位置"><a href="#配置-xml-文件存放的位置" class="headerlink" title="配置 xml 文件存放的位置"></a>配置 xml 文件存放的位置</h2><ul>
<li>Mybatis 中<code>xml</code>的文件默认是要和<code>interface</code>放在一个包下的，并且文件的名称要一样。</li>
<li>在和 SpringBoot 整合后有两种配置方式，下面详细介绍。</li>
</ul>
<h3 id="application-properties-中设置"><a href="#application-properties-中设置" class="headerlink" title="application.properties 中设置"></a>application.properties 中设置</h3><ul>
<li>既然是和 SpringBoot 整合，那么万变不离<code>xxxAutoConfiguration</code>这个配置类了，Mybatis 的配置类就是<code>MybatisAutoConfiguration</code>，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@org</span>.springframework.context.annotation.Configuration</div><div class="line"><span class="meta">@ConditionalOnClass</span>(&#123; SqlSessionFactory.class, SqlSessionFactoryBean.class &#125;)</div><div class="line"><span class="meta">@ConditionalOnSingleCandidate</span>(DataSource.class)</div><div class="line"><span class="meta">@EnableConfigurationProperties</span>(MybatisProperties.class)</div><div class="line"><span class="meta">@AutoConfigureAfter</span>(DataSourceAutoConfiguration.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisAutoConfiguration</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<ul>
<li>可以看到<code>@EnableConfigurationProperties(MybatisProperties.class)</code>这行代码，就是将 properties 中的属性映射到 MybatisProperties 这个成员属性中，因此设置的方式就要看其中的属性。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisProperties</span> </span>&#123;</div><div class="line">  <span class="comment">//前缀</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MYBATIS_PREFIX = <span class="string">"mybatis"</span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Mybatis配置文件的位置</div><div class="line">   */</div><div class="line">  <span class="keyword">private</span> String configLocation;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Mybatis的Mapper的xml文件的位置</div><div class="line">   */</div><div class="line">  <span class="keyword">private</span> String[] mapperLocations;</div></pre></td></tr></table></figure>
<ul>
<li>因此设置的方式很简单，如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">## xml文件放置在/src/main/resource/mapper/文件夹下</div><div class="line">mybatis.mapper-locations=classpath*:/mapper/**/*.xml</div></pre></td></tr></table></figure>
<h3 id="配置类中设置"><a href="#配置类中设置" class="headerlink" title="配置类中设置"></a>配置类中设置</h3><ul>
<li>不是本章重点，后面在讲 Mybatis 和 SpringBoot 整合的文章会涉及到该内容。</li>
</ul>
<h2 id="配置扫描-Mybatis-的-interface"><a href="#配置扫描-Mybatis-的-interface" class="headerlink" title="配置扫描 Mybatis 的 interface"></a>配置扫描 Mybatis 的 interface</h2><ul>
<li>在和 SpringBoot 整合后，扫描 Mybatis 的接口，生成代理对象是一件很简单的事，只需要一个注解即可。</li>
</ul>
<h3 id="Mapper"><a href="#Mapper" class="headerlink" title="@Mapper"></a>@Mapper</h3><ul>
<li>该注解标注在 Mybatis 的<code>interface</code>类上，SpringBoot 启动之后会扫描后会自动生成代理对象。实例如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Mapper</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserInfoMapper</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(UserInfo record)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertSelective</span><span class="params">(UserInfo record)</span></span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>缺点：每个<code>interface</code>都要标注一个，很鸡肋，一个项目中的 interface 少说也有上百个吧。</li>
</ul>
<h3 id="MapperScan"><a href="#MapperScan" class="headerlink" title="@MapperScan"></a>@MapperScan</h3><ul>
<li><code>@Mapper</code>注解的升级版，标注在配置类上，用于一键扫描 Mybatis 的<code>interface</code>。</li>
<li>使用也是很简单的，直接指定接口所在的包即可，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@MapperScan</span>(&#123;<span class="string">"com.xxx.dao"</span>&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiApplication</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>@MapperScan</code>和<code>@Mapper</code>这两个注解千万不要重复使用。</li>
<li>优点：一键扫描，不用每个 interface 配置。</li>
</ul>
<h2 id="基本的-crud"><a href="#基本的-crud" class="headerlink" title="基本的 crud"></a>基本的 crud</h2><ul>
<li>既然和数据库交互，避免不了 crud 操作，就安心做一个妥妥的<code>crud boy</code>吧。</li>
<li>针对 Mybatis 其实有两套方法映射，一个是 XML 文件的方式，一个是注解的方式。但是今天只讲 XML 文件的方式，原因很简单，注解的方式企业不用，谁用谁倒霉，哈哈。</li>
</ul>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li>查询语句是 MyBatis 中最常用的元素之一——光能把数据存到数据库中价值并不大，还要能重新取出来才有用，多数应用也都是查询比修改要频繁。 MyBatis 的基本原则之一是：在每个插入、更新或删除操作之间，通常会执行多个查询操作。因此，MyBatis 在查询和结果映射做了相当多的改进。一个简单查询的 select 元素是非常简单的。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectPersonById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"com.myjszl.domain.Person"</span>&gt;</span></div><div class="line">  SELECT name,age,id FROM PERSON WHERE ID = #&#123;id&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>对应的<code>interface</code>的方法如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function">Person <span class="title">selectPersonById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li><p><code>&lt;select&gt;</code>这个标签有很多属性，比较常用的属性如下：</p>
<ul>
<li><code>id</code>（必填）：在命名空间中唯一的标识符，可以被用来引用这条语句。和<code>interface</code>中的<code>方法名</code>要一致。</li>
<li><code>parameterType</code>（可选）：将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。</li>
<li><code>resultType</code>：期望从这条语句中返回结果的类全限定名或别名。 注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。 <code>resultType</code> 和 <code>resultMap</code> 之间只能同时使用一个。</li>
<li><code>resultMap</code>：对外部 <code>resultMap</code> 的命名引用。结果映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。 <code>resultType</code> 和 <code>resultMap</code> 之间只能同时使用一个。</li>
</ul>
</li>
</ul>
<h3 id="变更"><a href="#变更" class="headerlink" title="变更"></a>变更</h3><ul>
<li>数据变更语句 insert，update 和 delete 的实现非常接近。</li>
<li>下面是 insert，update 和 delete 语句的示例：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertAuthor"</span>&gt;</span></div><div class="line">  insert into Author (id,username,password,email,bio)</div><div class="line">  values (#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)</div><div class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateAuthor"</span>&gt;</span></div><div class="line">  update Author set</div><div class="line">    username = #&#123;username&#125;,</div><div class="line">    password = #&#123;password&#125;,</div><div class="line">    email = #&#123;email&#125;,</div><div class="line">    bio = #&#123;bio&#125;</div><div class="line">  where id = #&#123;id&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteAuthor"</span>&gt;</span></div><div class="line">  delete from Author where id = #&#123;id&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#{}和\${}的区别"></a>#{}和\${}的区别</h2><ul>
<li>上面的例子中我们可以看到使用的都是<code>#{}</code>，关于<code>#{}</code>和<code>${}</code>的区别也是在很多初级工程师的面试最常被问到的，现在只需要记住区别就是<code>#{}</code>使用了 JDBC 的预编译，可以防止 SQL 注入，提高了安全性，<code>${}</code>并没有预编译，安全性不够。在后面 Mybatis 的源码讲解中将会涉及到为什么一个用了预编译，一个没用。</li>
</ul>
<h2 id="自增-ID-的返回"><a href="#自增-ID-的返回" class="headerlink" title="自增 ID 的返回"></a>自增 ID 的返回</h2><ul>
<li>关于 Mysql 的文章中有提到，设计一个表最好要有一个自增 ID，无论这个 ID 你是否用到，具体原因不在解释，可以翻看之前的文章。</li>
<li>有了自增 ID，插入之后并不能自动返回，但是我们又需要这个 ID 值，那么如何返回呢？</li>
<li><code>&lt;insert&gt;</code>标签提供了两个属性用来解决这个问题，如下：<ul>
<li><code>useGeneratedKeys</code>：设置为 true，表示使用自增主键返回</li>
<li><code>keyProperty</code>：指定返回的自增主键映射到<code>parameterType</code>的哪个属性中。</li>
</ul>
</li>
<li>假设插入<code>Person</code>，并且 person 表中的自增主键 id 需要返回，XML 文件如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.xxx.dao.PersonMapper"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">'addPerson'</span> <span class="attr">parameterType</span>=<span class="string">'com.xxx.domain.Person'</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span></span></div><div class="line">    <span class="attr">keyProperty</span>=<span class="string">"id"</span> &gt;</div><div class="line">    insert into person(name,age)</div><div class="line">    values(#&#123;name&#125;,#&#123;age&#125;);</div><div class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="SQL-代码片段"><a href="#SQL-代码片段" class="headerlink" title="SQL 代码片段"></a>SQL 代码片段</h2><ul>
<li>这个元素可以用来定义可重用的 SQL 代码片段，以便在其它语句中使用。 参数可以静态地（在加载的时候）确定下来，并且可以在不同的 include 元素中定义不同的参数值。比如：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"userColumns"</span>&gt;</span> $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>这个 SQL 片段可以在其它语句中使用，例如：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUsers"</span> <span class="attr">resultType</span>=<span class="string">"map"</span>&gt;</span></div><div class="line">  select</div><div class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"userColumns"</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"alias"</span> <span class="attr">value</span>=<span class="string">"t1"</span>/&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span>,</div><div class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"userColumns"</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"alias"</span> <span class="attr">value</span>=<span class="string">"t2"</span>/&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></div><div class="line">  from some_table t1</div><div class="line">    cross join some_table t2</div><div class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="开启驼峰映射"><a href="#开启驼峰映射" class="headerlink" title="开启驼峰映射"></a>开启驼峰映射</h2><ul>
<li>DBA 在设计数据库的时候，往往使用的是下划线(<code>_</code>)的方式，比如<code>user_id</code>。但是 Java 是不规范的，我们通常将它转换为<code>userId</code>，这就是驼峰命名方法。</li>
<li>但是在使用 Mybatis 查询的时候，比如：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">'selectById'</span> <span class="attr">resultType</span>=<span class="string">'com.xxx.doamin.User'</span>&gt;</span></div><div class="line">  select user_id from user_info</div><div class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>上面的<code>user_id</code>和<code>User</code>中的<code>userId</code>根本不对应，也就映射不进去，此时查询的结果就是 userId 是 null，当然我们可以使用别名的方式，SQL 可以改写为<code>select user_id as userId from user_info</code></li>
<li>另外一种方式是不用别名，直接开启 Mybatis 的驼峰映射规则，会自动映射，开启的方式很简单，就是在<code>application.properties</code>文件配置一下，如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mybatis.configuration.map-underscore-to-camel-case=true</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>本文主要讲了 Mybatis 与 SpringBoot 的整合过程，基本的 crud，各种标签的属性等内容，属于一个入门级别的教程，后续的内容会逐渐深入。</li>
<li>另外，MySQL 进阶的教程已经写了五篇文章了，每一篇都是经典，已经出了一个专辑，感兴趣的可以收藏一下<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&amp;action=getalbum&amp;album_id=1493292455318847492&amp;scene=173#wechat_redirect&amp;scene=126&amp;subscene=0&amp;sessionid=1599046435&amp;enterid=1599046439" target="_blank" rel="external">MySQL 进阶</a>。</li>
<li>感谢你的阅读，作者会定时的更新原创文章，如果觉得写的不错的话，可以关注一下本公众号。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E4%B8%83%E7%A7%92%E7%BC%96%E7%A8%8B.jpg" alt=""></li>
</ul>
]]></content>
      <categories>
        <category>Mybatis进阶</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis入门之结果映射</title>
    <url>/2020/04/20/Mybatis%E5%85%A5%E9%97%A8%E4%B9%8B%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>上一篇文章介绍了Mybatis基础的CRUD操作、常用的标签、属性等内容，如果对部分不熟悉的朋友可以看<a href="https://mp.weixin.qq.com/s/KdrEvlShnVoYA8nr0qLSNw" target="_blank" rel="external">Mybatis入门之基本操作</a>。</li>
<li>本篇文章继续讲解Mybatis的结果映射的内容，想要在企业开发中灵活的使用Mybatis，这部分的内容是必须要精通的。<a id="more"></a>
</li>
</ul>
<h2 id="什么是结果映射？"><a href="#什么是结果映射？" class="headerlink" title="什么是结果映射？"></a>什么是结果映射？</h2><ul>
<li>简单的来说就是一条<code>SQL查询语句</code>返回的字段如何与<code>Java实体类</code>中的属性相对应。</li>
<li><p>如下一条SQL语句，查询患者的用户id，科室id，主治医生id：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">'selectPatientInfos'</span> <span class="attr">resultType</span>=<span class="string">'com.xxx.domain.PatientInfo'</span>&gt;</span></div><div class="line">  select user_id,dept_id,doc_id from patient_info;</div><div class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>Java实体类<code>PatientInfo</code>如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PatientInfo</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> String userId;</div><div class="line">  <span class="keyword">private</span> String deptId;</div><div class="line">  <span class="keyword">private</span> String docId;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>程序员写这条SQL的目的就是想查询出来的<code>user_id</code>,<code>dept_id</code>,<code>doc_id</code>分别赋值给实体类中的<code>userId</code>,<code>deptId</code>,<code>docId</code>。这就是简单的结果映射。</p>
</li>
</ul>
<h2 id="如何映射？"><a href="#如何映射？" class="headerlink" title="如何映射？"></a>如何映射？</h2><ul>
<li>Myabtis中的结果映射有很多种方式，下面会逐一介绍。</li>
</ul>
<h3 id="别名映射"><a href="#别名映射" class="headerlink" title="别名映射"></a>别名映射</h3><ul>
<li><p>这个简单，保持查询的SQL返回的字段和Java实体类一样即可，比如上面例子的SQL可以写成：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">'selectPatientInfos'</span> <span class="attr">resultType</span>=<span class="string">'com.xxx.domain.PatientInfo'</span>&gt;</span></div><div class="line">   select user_id as userId,</div><div class="line">   dept_id as deptId,</div><div class="line">   doc_id as docId</div><div class="line">   from patient_info; </div><div class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>这样就能和实体类中的属性映射成功了。</p>
</li>
</ul>
<h3 id="驼峰映射"><a href="#驼峰映射" class="headerlink" title="驼峰映射"></a>驼峰映射</h3><ul>
<li><p>Mybatis提供了驼峰命名映射的方式，比如数据库中的<code>user_id</code>这个字段，能够自动映射到<code>userId</code>属性。那么此时的查询的SQL变成如下即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">'selectPatientInfos'</span> <span class="attr">resultType</span>=<span class="string">'com.xxx.domain.PatientInfo'</span>&gt;</span></div><div class="line">    select user_id,dept_id,doc_id from patient_info;</div><div class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>如何开启呢？与SpringBoot整合后开启其实很简单，有两种方式，一个是配置文件中开启，一个是配置类开启。</p>
</li>
</ul>
<h4 id="配置文件开启驼峰映射"><a href="#配置文件开启驼峰映射" class="headerlink" title="配置文件开启驼峰映射"></a>配置文件开启驼峰映射</h4><ul>
<li>只需要在<code>application.properties</code>文件中添加如下一行代码即可：<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mybatis.configuration.map-underscore-to-camel-case=true</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="配置类中开启驼峰映射【简单了解，后续源码章节着重介绍】"><a href="#配置类中开启驼峰映射【简单了解，后续源码章节着重介绍】" class="headerlink" title="配置类中开启驼峰映射【简单了解，后续源码章节着重介绍】"></a>配置类中开启驼峰映射【简单了解，后续源码章节着重介绍】</h4><ul>
<li>这种方式需要你对源码有一定的了解，上一篇入门教程中有提到，Mybatis与Springboot整合后适配了一个starter，那么肯定会有自动配置类，Mybatis的自动配置类是<code>MybatisAutoConfiguration</code>，其中有这么一段代码，如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84/1.png" alt=""></li>
<li><p><code>@ConditionalOnMissingBean</code>这个注解的意思就是当IOC容器中没有<code>SqlSessionFactory</code>这个Bean对象这个配置才会生效;<code>applyConfiguration(factory)</code>这行代码就是创建一个<code>org.apache.ibatis.session.Configuration</code>赋值给<code>SqlSessionFactoryBean</code>。源码分析到这，应该很清楚了，无非就是自己在容器中创建一个<code>SqlSessionFactory</code>，然后设置属性即可，如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Bean</span>(<span class="string">"sqlSessionFactory"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</div><div class="line">    <span class="comment">//设置数据源</span></div><div class="line">    sqlSessionFactoryBean.setDataSource(dataSource);</div><div class="line">    <span class="comment">//设置xml文件的位置</span></div><div class="line">    sqlSessionFactoryBean.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver().getResources(MAPPER_LOCATOIN));</div><div class="line">    <span class="comment">//创建Configuration</span></div><div class="line">    org.apache.ibatis.session.Configuration configuration = <span class="keyword">new</span> org.apache.ibatis.session.Configuration();</div><div class="line">    <span class="comment">// 开启驼峰命名映射</span></div><div class="line">    configuration.setMapUnderscoreToCamelCase(<span class="keyword">true</span>);</div><div class="line">    configuration.setDefaultFetchSize(<span class="number">100</span>);</div><div class="line">    configuration.setDefaultStatementTimeout(<span class="number">30</span>);</div><div class="line">    sqlSessionFactoryBean.setConfiguration(configuration);</div><div class="line">    <span class="comment">//将typehandler注册到mybatis</span></div><div class="line">    sqlSessionFactoryBean.setTypeHandlers(typeHandlers());</div><div class="line">    <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>注意</strong>：如果对<code>SqlSessionFactory</code>没有特殊定制，不介意重写，因为这会自动覆盖自动配置类中的配置。</p>
</li>
</ul>
<h3 id="resultMap映射"><a href="#resultMap映射" class="headerlink" title="resultMap映射"></a>resultMap映射</h3><ul>
<li>什么是<code>resultMap</code>？简单的说就是一个类似Map的结构，将数据库中的字段和JavaBean中的属性字段对应起来，这样就能做到一一映射了。</li>
<li><p>上述的例子使用resultMap又会怎么写呢？如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">&lt;!--创建一个resultMap映射--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"patResultMap"</span> <span class="attr">type</span>=<span class="string">"com.xxx.domain.PatientInfo"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"userId"</span> <span class="attr">column</span>=<span class="string">"user_id"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"docId"</span> <span class="attr">column</span>=<span class="string">"doc_id"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"deptId"</span> <span class="attr">column</span>=<span class="string">"dept_id"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--使用resultMap映射结果到com.xxx.domain.PatientInfo这个Bean中--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">'selectPatientInfos'</span> <span class="attr">resultMap</span>=<span class="string">'patResultMap'</span>&gt;</span></div><div class="line">    select user_id,dept_id,doc_id from patient_info;</div><div class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>其实很简单，就是创建一个<code>&lt;resultMap&gt;</code>，然后<code>&lt;select&gt;</code>标签指定这个resultMap即可。</p>
</li>
<li><p><code>&lt;resultMap&gt;</code>的属性如下：</p>
<ul>
<li><code>id</code>：唯一标识这个resultMap，同一个Mapper.xml中不能重复</li>
<li><code>type</code>：指定JavaBean的类型，可以是全类名，也可以是别名</li>
</ul>
</li>
<li>子标签<code>&lt;result&gt;</code>的属性如下：<ul>
<li><code>column</code>：SQL返回的字段名称</li>
<li><code>property</code>：JavaBean中属性的名称</li>
<li><code>javaType</code>：一个 Java 类的全限定名，或一个类型别名（关于内置的类型别名，可以参考上面的表格）。 如果你映射到一个 JavaBean，MyBatis 通常可以推断类型。然而，如果你映射到的是 HashMap，那么你应该明确地指定 javaType 来保证行为与期望的相一致。</li>
<li><code>jdbcType</code>：JDBC 类型，所支持的 JDBC 类型参见这个表格之后的“支持的 JDBC 类型”。 只需要在可能执行插入、更新和删除的且允许空值的列上指定 JDBC 类型。这是 JDBC 的要求而非 MyBatis 的要求。如果你直接面向 JDBC 编程，你需要对可以为空值的列指定这个类型。</li>
<li><code>typeHandler</code>： 这个属性值是一个类型处理器实现类的全限定名，或者是类型别名。</li>
<li><code>resultMap</code>：结果映射的 ID，可以将此关联的嵌套结果集映射到一个合适的对象树中。 它可以作为使用额外 select 语句的替代方案。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>以上列举了三种映射的方式，分别是<strong>别名映射</strong>，<strong>驼峰映射</strong>、<strong><code>resultMap</code>映射</strong>。</li>
<li>你以为这就结束了？要是世界这么简单多好，做梦吧，哈哈！！！<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84/2.jpg" alt=""></li>
</ul>
<h2 id="高级结果映射"><a href="#高级结果映射" class="headerlink" title="高级结果映射"></a>高级结果映射</h2><ul>
<li>MyBatis 创建时的一个思想是：数据库不可能永远是你所想或所需的那个样子。 我们希望每个数据库都具备良好的第三范式或 BCNF 范式，可惜它们并不都是那样。 如果能有一种数据库映射模式，完美适配所有的应用程序，那就太好了，但可惜也没有。 而 ResultMap 就是 MyBatis 对这个问题的答案。</li>
<li>我们知道在数据库的关系中一对一，多对一，一对多，多对多的关系，那么这种关系如何在Mybatis中体现并映射成功呢？</li>
</ul>
<h3 id="关联-association"><a href="#关联-association" class="headerlink" title="关联(association)"></a>关联(association)</h3><ul>
<li>关联（association）元素处理<strong>有一个</strong>类型的关系。 比如，在我们的示例中，一个员工属于一个部门。关联结果映射和其它类型的映射工作方式差不多。 你需要指定目标属性名以及属性的<code>javaType</code>（很多时候 MyBatis 可以自己推断出来），在必要的情况下你还可以设置 <code>JDBC</code> 类型，如果你想覆盖获取结果值的过程，还可以设置类型处理器。</li>
<li>关联的不同之处是，你需要告诉 MyBatis 如何加载关联。MyBatis 有两种不同的方式加载关联：<ul>
<li><code>嵌套 Select 查询</code>：通过执行另外一个 SQL 映射语句来加载期望的复杂类型。</li>
<li><code>嵌套结果映射</code>：使用嵌套的结果映射来处理连接结果的重复子集。</li>
</ul>
</li>
<li>首先，先让我们来看看这个元素的属性。你将会发现，和普通的结果映射相比，它只在 <code>select</code> 和 <code>resultMap</code> 属性上有所不同。<ul>
<li><code>property</code>：    映射到列结果的字段或属性。如果用来匹配的 JavaBean 存在给定名字的属性，那么它将会被使用。</li>
<li><code>javaType</code>：一个 Java 类的完全限定名，或一个类型别名（关于内置的类型别名，可以参考上面的表格）<br> <code>jdbcType</code>：    JDBC 类型， 只需要在可能执行插入、更新和删除的且允许空值的列上指定 JDBC 类型</li>
<li><code>typeHandler</code>：使用这个属性，你可以覆盖默认的类型处理器。 这个属性值是一个类型处理器实现类的完全限定名，或者是类型别名。<br> <code>column</code>：    数据库中的列名，或者是列的别名。一般情况下，这和传递给 <code>resultSet.getString(columnName)</code> 方法的参数一样。 注意：在使用复合主键的时候，你可以使用 <code>column=&quot;{prop1=col1,prop2=col2}&quot;</code> 这样的语法来指定多个传递给嵌套 Select 查询语句的列名。这会使得<code>prop1</code>和 <code>prop2</code> 作为参数对象，被设置为对应嵌套 Select 语句的参数。</li>
<li><code>select</code>：用于加载复杂类型属性的映射语句的 ID，它会从 column 属性指定的列中检索数据，作为参数传递给目标 select 语句。 具体请参考下面的例子。注意：在使用复合主键的时候，你可以使用<code>column=&quot;{prop1=col1,prop2=col2}&quot;</code> 这样的语法来指定多个传递给嵌套 Select 查询语句的列名。这会使得 prop1 和 prop2 作为参数对象，被设置为对应嵌套 Select 语句的参数。</li>
<li><code>fetchType</code>：可选的。有效值为 <code>lazy</code> 和 <code>eager</code>。 指定属性后，将在映射中忽略全局配置参数 <code>lazyLoadingEnabled</code>，使用属性的值。</li>
</ul>
</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul>
<li>一对一的关系比如：一个员工属于一个部门，那么数据库表就会在员工表中加一个部门的id作为逻辑外键。</li>
<li><p>创建员工JavaBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> Integer id;</div><div class="line">	<span class="keyword">private</span> String username;</div><div class="line">	<span class="keyword">private</span> String password;</div><div class="line">	<span class="keyword">private</span> Integer age;</div><div class="line">  <span class="keyword">private</span> Integer deptId;</div><div class="line">  <span class="comment">//部门</span></div><div class="line">	<span class="keyword">private</span> Department department;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>部门JavaBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> Integer id;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>那么我们想要查询所有的用户信息和其所在的部门信息，此时的sql语句为:<code>select * from user u left join department d on u.department_id=d.id</code>;。但是我们在mybaits中如果使用这条语句查询，那么返回的结果类型是什么呢？如果是User类型的，那么查询结果返回的还有<code>Department</code>类型的数据，那么肯定会对应不上的。此时<code>&lt;resultMap&gt;</code>来了，它来了!!!</p>
</li>
</ul>
<h4 id="关联的嵌套-Select-查询【可以忽略】"><a href="#关联的嵌套-Select-查询【可以忽略】" class="headerlink" title="关联的嵌套 Select 查询【可以忽略】"></a>关联的嵌套 Select 查询【可以忽略】</h4><ul>
<li><p>查询员工和所在的部门在Mybatis如何写呢？代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userResult"</span> <span class="attr">type</span>=<span class="string">"com.xxx.domain.User"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"password"</span> <span class="attr">property</span>=<span class="string">"password"</span>/&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"age"</span> <span class="attr">property</span>=<span class="string">"age"</span>/&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"username"</span> <span class="attr">property</span>=<span class="string">"username"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"dept_id"</span> <span class="attr">property</span>=<span class="string">"deptId"</span>/&gt;</span></div><div class="line">  <span class="comment">&lt;!--关联查询，select嵌套查询--&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"department"</span> <span class="attr">column</span>=<span class="string">"dept_id"</span> <span class="attr">javaType</span>=<span class="string">"com.xxx.domain.Department"</span> <span class="attr">select</span>=<span class="string">"selectDept"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--查询员工--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUser"</span> <span class="attr">resultMap</span>=<span class="string">"userResult"</span>&gt;</span></div><div class="line">  SELECT * FROM user WHERE id = #&#123;id&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--查询部门--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectDept"</span> <span class="attr">resultType</span>=<span class="string">"com.xxx.domain.Department "</span>&gt;</span></div><div class="line">  SELECT * FROM department WHERE ID = #&#123;id&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>就是这么简单，两个select语句，一个用来加载员工，一个用来加载部门。</p>
</li>
<li>这种方式虽然很简单，但在大型数据集或大型数据表上表现不佳。这个问题被称为<code>N+1</code> 查询问题。 概括地讲，N+1 查询问题是这样子的：<ul>
<li>你执行了一个单独的 SQL 语句来获取结果的一个列表（就是<code>+1</code>）。</li>
<li>对列表返回的每条记录，你执行一个 <code>select</code> 查询语句来为每条记录加载详细信息（就是<code>N</code>）。</li>
</ul>
</li>
<li>这个问题会导致成百上千的 SQL 语句被执行。有时候，我们不希望产生这样的后果。</li>
</ul>
<h4 id="关联的嵌套结果映射【重点】"><a href="#关联的嵌套结果映射【重点】" class="headerlink" title="关联的嵌套结果映射【重点】"></a>关联的嵌套结果映射【重点】</h4><ul>
<li><code>&lt;association &gt;</code>标签中还可以直接嵌套结果映射，此时的Mybatis的查询如下：<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 定义resultMap --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"UserDepartment"</span> <span class="attr">type</span>=<span class="string">"com.xxx.domain.User"</span> &gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"user_id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"password"</span> <span class="attr">property</span>=<span class="string">"password"</span>/&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"age"</span> <span class="attr">property</span>=<span class="string">"age"</span>/&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"username"</span> <span class="attr">property</span>=<span class="string">"username"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"dept_id"</span> <span class="attr">property</span>=<span class="string">"deptId"</span>/&gt;</span></div><div class="line">	</div><div class="line">	<span class="comment">&lt;!--</span></div><div class="line">		property: 指定User中对应的部门属性名称</div><div class="line">		javaType: 指定类型，可以是全类名或者别名</div><div class="line">	 --&gt;</div><div class="line">	<span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"department"</span> <span class="attr">javaType</span>=<span class="string">"com.xx.domain.Department"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--指定Department中的属性映射，这里也可以使用单独拎出来，然后使用association中的resultMap属性指定--&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"dept_name"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">association</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- </span></div><div class="line">	resultMap: 指定上面resultMap的id的值</div><div class="line"> --&gt;</div><div class="line"> <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserAndDepartment"</span> <span class="attr">resultMap</span>=<span class="string">"UserDepartment"</span>&gt;</span></div><div class="line"> 	select </div><div class="line">   u.id as user_id,</div><div class="line">   u.dept_id,</div><div class="line">   u.name,</div><div class="line">   u.password,</div><div class="line">   u.age,</div><div class="line">   d.id,</div><div class="line">   d.name as dept_name</div><div class="line">   from user u left join department d on u.department_id=d.id</div><div class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul>
<li>至此<code>有一个</code>类型的关联已经完成了，学会一个<code>&lt;association&gt;</code>使用即能完成。</li>
<li><strong>注意</strong>： 关联的嵌套 Select 查询不建议使用，<code>N+1</code>是个重大问题，虽说Mybatis提供了延迟加载的功能，但是仍然不建议使用，企业开发中也是不常用的。</li>
</ul>
<h3 id="集合collection"><a href="#集合collection" class="headerlink" title="集合collection"></a>集合collection</h3><ul>
<li>集合，顾名思义，就是处理<code>有很多个</code>类型的关联。</li>
<li>其中的属性和<code>association</code>中的属性类似，不再重复了。</li>
<li><p>比如这样一个例子：查询一个部门中的全部员工，查询SQL如何写呢？如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> department d <span class="keyword">left</span> <span class="keyword">join</span> <span class="keyword">user</span> u <span class="keyword">on</span> u.department_id=d.id;</div></pre></td></tr></table></figure>
</li>
<li><p>此时的<code>User</code>实体类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line"> <span class="keyword">private</span> Integer id;</div><div class="line"> <span class="keyword">private</span> String username;</div><div class="line"> <span class="keyword">private</span> String password;</div><div class="line"> <span class="keyword">private</span> Integer age;</div><div class="line"> <span class="keyword">private</span> Integer deptId; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>此时的<code>Department</code>实体类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</div><div class="line"> <span class="keyword">private</span> Integer id;</div><div class="line"> <span class="keyword">private</span> String name;</div><div class="line"> <span class="keyword">private</span> List&lt;User&gt; users;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>和<code>association</code>类似，同样有两种方式，我们可以使用嵌套 Select 查询，或基于连接的嵌套结果映射集合。</p>
</li>
</ul>
<h3 id="集合的嵌套-Select-查询【可以忽略】"><a href="#集合的嵌套-Select-查询【可以忽略】" class="headerlink" title="集合的嵌套 Select 查询【可以忽略】"></a>集合的嵌套 Select 查询【可以忽略】</h3><ul>
<li><p>不太重要，查询如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"deptResult"</span> <span class="attr">type</span>=<span class="string">"com.xxx.domain.Department"</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!--指定Department中的属性映射，这里也可以使用单独拎出来，然后使用association中的resultMap属性指定--&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></div><div class="line">  <span class="comment">&lt;!--</span></div><div class="line">  ofType：指定实际的JavaBean的全类型或者别名</div><div class="line">  select：指定嵌套的select查询</div><div class="line">  javaType：集合的类型，可以不写，Mybatis可以推测出来</div><div class="line">--&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"users"</span> <span class="attr">javaType</span>=<span class="string">"java.util.ArrayList"</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">ofType</span>=<span class="string">"com.xxx.doamin.User"</span> <span class="attr">select</span>=<span class="string">"selectByDeptId"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectDept"</span> <span class="attr">resultMap</span>=<span class="string">"deptResult"</span>&gt;</span></div><div class="line">  SELECT * FROM department  WHERE ID = #&#123;id&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectByDeptId"</span> <span class="attr">resultType</span>=<span class="string">"com.xxx.domain.User"</span>&gt;</span></div><div class="line">  SELECT * FROM user WHERE dept_id = #&#123;id&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>注意</strong>：这里出现了一个不同于<code>association</code>的属性<code>ofType</code>，这个属性非常重要，它用来将 JavaBean（或字段）属性的类型和集合存储的类型区分开来。</p>
</li>
</ul>
<h3 id="集合的嵌套结果映射【重点】"><a href="#集合的嵌套结果映射【重点】" class="headerlink" title="集合的嵌套结果映射【重点】"></a>集合的嵌套结果映射【重点】</h3><ul>
<li>现在你可能已经猜到了集合的嵌套结果映射是怎样工作的——除了新增的 <code>ofType</code> 属性，它和关联的完全相同。</li>
<li>此时的Mybatis查询如下：<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">&lt;!--部门的resultMap--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"deptResult"</span> <span class="attr">type</span>=<span class="string">"com.xxx.domain.Department"</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!--指定Department中的属性映射，这里也可以使用单独拎出来，然后使用association中的resultMap属性指定--&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"dept_id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"dept_name"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></div><div class="line">  <span class="comment">&lt;!--</span></div><div class="line">  ofType：指定实际的JavaBean的全类型或者别名</div><div class="line">  resultMap：指定员工的resultMap</div><div class="line">--&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"users"</span> <span class="attr">ofType</span>=<span class="string">"com.xxx.doamin.User"</span> <span class="attr">resultMap</span>=<span class="string">'userResult'</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--员工的resultMap--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userResult"</span> <span class="attr">type</span>=<span class="string">"com.xxx.domain.User"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"user_id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"password"</span> <span class="attr">property</span>=<span class="string">"password"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"age"</span> <span class="attr">property</span>=<span class="string">"age"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"username"</span> <span class="attr">property</span>=<span class="string">"username"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectDeptById"</span> <span class="attr">resultType</span>=<span class="string">"com.xxx.domain.Department"</span>&gt;</span></div><div class="line">  select </div><div class="line">  d.id as dept_id,</div><div class="line">  d.name as dept_name,</div><div class="line">  u.id as user_id,</div><div class="line">  u.password,</div><div class="line">  u.name</div><div class="line">  from department d left join user u on u.department_id=d.id</div><div class="line">  where d.id=#&#123;id&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ul>
<li>至此Mybatis第二弹之结果映射已经写完了，如果觉得作者写的不错，给个在看关注一波，后续还有更多精彩内容推出。</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E4%B8%83%E7%A7%92%E7%BC%96%E7%A8%8B.jpg" alt=""></li>
</ul>
]]></content>
      <categories>
        <category>Mybatis进阶</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis如何执行Select语句，你真的知道吗？</title>
    <url>/2020/04/20/Mybatis%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8CSelect%E8%AF%AD%E5%8F%A5%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>本篇文章是Myabtis源码分析的第三篇，前两篇分别介绍了Mybatis的重要组件和围绕着Mybatis中的重要组件教大家如何阅读源码的一些方法，有了前面两篇文章的基础，来看这篇文章的才不会觉得吃力，如果没有看过的朋友，陈某建议去看看，两篇文章分别是<a href="https://mp.weixin.qq.com/s/lnJx0h_4Kk6fKuhptN1cdg" target="_blank" rel="external">Mybatis源码解析之六剑客</a>和<a href="https://mp.weixin.qq.com/s/B9e-4y_jokLHtDnS0o6-7g" target="_blank" rel="external">Mybatis源码如何阅读，教你一招！！！</a>。</li>
<li>今天接上一篇，围绕Mybatis中的<code>selectList()</code>来看一看Mybatis底层到底做了什么，有什么高级的地方。</li>
</ul>
<a id="more"></a>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul>
<li>本篇文章讲的一切内容都是基于<code>Mybatis3.5</code>和<code>SpringBoot-2.3.3.RELEASE</code>。</li>
<li>由于此篇文章是基于前两篇文章的基础之上，因此重复的内容不再详细赘述了。</li>
</ul>
<h2 id="撸起袖子就是干"><a href="#撸起袖子就是干" class="headerlink" title="撸起袖子就是干"></a>撸起袖子就是干</h2><ul>
<li>二话不说，先来一张流程图，Mybatis六剑客，如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-%E5%85%AD%E5%89%91%E5%AE%A2/3.png" alt="六剑客执行流程图"></li>
<li>上图中的这六剑客在前面两篇文章中已经介绍的非常清楚了，此处略过。为什么源码解析的每一篇文章中都要放一张这个流程图呢？因为Mybatis底层就是围绕着这六剑客展开的，我们需要从全局掌握Mybatis的源码究竟如何执行的。</li>
</ul>
<h3 id="测试环境搭建"><a href="#测试环境搭建" class="headerlink" title="测试环境搭建"></a>测试环境搭建</h3><ul>
<li><p>举个栗子：根据用户id查询用户信息，Mapper定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function">List&lt;UserInfo&gt; <span class="title">selectList</span><span class="params">(@Param(<span class="string">"userIds"</span>)</span> List&lt;String&gt; userIds)</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>对应XML配置如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">&lt;mapper namespace="cn.cb.demo.dao.UserMapper"&gt;</div><div class="line">    &lt;!--开启二级缓存--&gt;</div><div class="line">    &lt;cache/&gt;</div><div class="line">    &lt;select id="selectList" resultType="cn.cb.demo.domain.UserInfo"&gt;</div><div class="line">        select * from user_info where status=1</div><div class="line">        and user_id in</div><div class="line">        &lt;foreach collection="userIds" item="item" open="(" separator="," close=")" &gt;</div><div class="line">            #&#123;item&#125;</div><div class="line">        &lt;/foreach&gt;</div><div class="line">    &lt;/select&gt;</div><div class="line">&lt;/mapper&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>单元测试如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</div><div class="line">    List&lt;UserInfo&gt; userInfos = userMapper.selectList(Arrays.asList(<span class="string">"192"</span>,<span class="string">"198"</span>));</div><div class="line">    System.out.println(userInfos);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="DEBUG走起"><a href="#DEBUG走起" class="headerlink" title="DEBUG走起"></a>DEBUG走起</h3><ul>
<li>具体在哪里打上断点，上篇文章已经讲过了，不再赘述了。</li>
<li>由于SpringBoot与Mybatis整合之后，自动注入的是<code>SqlSessionTemplate</code>，因此代码执行到<code>org.mybatis.spring.SqlSessionTemplate#selectList(java.lang.String, java.lang.Object)</code>，如<code>图1</code>：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E6%BA%90%E7%A0%81-3/1.png" alt=""></li>
<li>从源码可以看到，实际调用的还是<code>DefaultSqlSession</code>中的<code>selectList</code>方法。如下<code>图2</code>：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E6%BA%90%E7%A0%81-3/2.png" alt=""></li>
<li><p><strong>具体的逻辑如下</strong>：</p>
<ol>
<li>根据Mapper方法的<code>全类名</code>从Mybatis的配置中获取到这条SQL的详细信息，比如<code>paramterType</code>,<code>resultMap</code>等等。</li>
<li>既然开启了二级缓存，肯定先要判断这条SQL是否缓存过，因此实际调用的是<code>CachingExecutor</code>这个缓存执行器。</li>
</ol>
</li>
<li><p><code>DefaultSqlSession</code>只是简单的获取SQL的详细配置，最终还是把任务交给了<code>Executor</code>（当然这里走的是二级缓存，因此交给了缓存执行器）。下面DEBUG走到<code>CachingExecutor#query(MappedStatement, java.lang.Object, RowBounds,ResultHandler)</code>，源码如下<code>图3</code>：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E6%BA%90%E7%A0%81-3/3.png" alt=""></p>
</li>
<li>上图中的<code>query</code>方法实际做了两件事，实际执行的查询还是其中重载的方法<code>List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</code>，如下<code>图4</code>：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E6%BA%90%E7%A0%81-3/4.png" alt=""></li>
<li><p>根据上图源码的分析，其实CachingExecutor执行的逻辑并不是很难，反倒很容易理解，<strong>具体的逻辑如下</strong>：</p>
<ol>
<li>如果开启了二级缓存，先根据<code>cacheKey</code>从二级缓存中查询，如果查询到了直接返回</li>
<li>如果未开启二级缓存，再执行<code>BaseExecutor</code>中的query方法从一级缓存中查询。</li>
<li>如果二级缓存中未查询到数据，再执行<code>BaseExecutor</code>中的query方法从一级缓存中查询。</li>
<li>将查询到的结果存入到二级缓存中。</li>
</ol>
</li>
<li><p><code>BaseExecutor</code>中的<code>query</code>方法无非就是从一级缓存中取数据，没查到再从数据库中取数据，一级缓存实际就是一个Map结构，这里不再细说，真正执行SQL从数据库中取数据的是<code>SimpleExecutor</code>中的<code>public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</code>方法，源码如下<code>图5</code>：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E6%BA%90%E7%A0%81-3/5.png" alt=""></p>
</li>
<li>从上面的源码也是可以知道，在真正执行SQL之前，是要调用<code>prepareStatement(handler, ms.getStatementLog())</code>方法做一些参数的预处理的，其中涉及到了六大剑客的另外两位，分别是<code>ParameterHandler</code>和<code>TypeHandler</code>，源码如<code>图6</code>：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E6%BA%90%E7%A0%81-3/6.png" alt=""></li>
<li><p>从上图可以知道设置SQL参数的真正方法是<code>handler.parameterize(stmt)</code>，真正执行的是<code>DefaultParameterHandler</code>中的<code>setParameters</code>方法，由于篇幅较长，简单的说一下思路：</p>
<ol>
<li>获取所有参数的映射</li>
<li>循环遍历，获取参数的值，使用对应的<code>TypeHandler</code>将其转换成相应类型的参数。</li>
<li>真正的设置参数的方法是<code>TypeHandler</code>中<code>setParameter</code>方法</li>
</ol>
</li>
<li><p>继续<code>图6</code>的逻辑，参数已经设置完了，此时就该执行SQL了，真正执行SQL的是<code>PreparedStatementHandler</code>中的<code>&lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler)</code>方法，源码如下<code>图7</code>：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E6%BA%90%E7%A0%81-3/7.png" alt=""></p>
</li>
<li>上图的逻辑其实很简单，一个是JDBC执行SQL语句，一个是调用六剑客之一的<code>ResultSetHandler</code>对结果进行处理。</li>
<li>真正对结果进行处理的是<code>DefaultResultSetHandler</code>中的<code>handleResultSets</code>方法，源码比较复杂，这里就不再展示了，具体的逻辑如下：<ol>
<li>获取结果映射(<code>resultMap</code>)，如果没有指定，使用内置的结果映射</li>
<li>遍历结果集，对SQL返回的每个结果通过结果集和<code>TypeHandler</code>进行结果映射。</li>
<li>返回结果</li>
</ol>
</li>
<li>ResultSetHandler对结果处理结束之后就会返回。至此一条<code>selectList()</code>如何执行的大概心里已经有了把握，其他的更新，删除都是大同小异。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Mybatis的源码算是几种常用框架中比较简单的，都是围绕六大组件进行的，只要搞懂了每个组件是什么角色，有什么作用，一切都会很简单。</li>
<li><p>一条select语句简单执行的逻辑总结如下（前提：<strong>默认配置</strong>）：</p>
<ol>
<li><strong>SqlSesion</strong>：<code>#SqlSessionTemplate.selectList()</code>实际调用<code>#DefaultSqlSession.selectList()</code></li>
<li><strong>Executor</strong>：<code>#DefaultSqlSession.quer()</code>实际调用的是<code>#CachingExecutor().query()</code>，如果二级缓存中存在直接返回，不存在调用<code>#BaseExecutor.quer()</code>查询一级缓存，如果一级缓存中存在直接返回。不存在调用<code>#SimpleExecutor.doQuery()</code>方法查询数据库。</li>
<li><strong>StatementHandler</strong>：<code>#SimpleExecutor.doQuery()</code>生成<code>StatementHandler</code>实例，执行<code>#PreparedStatementHandler.parameterize()</code>方法设置参数，实际调用的是<code>#ParamterHandler.setParameters()</code>方法，该方法内部调用<code>TypeHandler.setParameter()</code>方法进行类型转换;参数设置成功后，调用<code>#PreparedStatementHandler.parameterize().query()</code>方法执行SQL，返回结果</li>
<li><strong>ResultSetHandler</strong>：<code>#DefaultResultSetHandler.handleResultSets()</code>对返回的结果进行处理，内部调用<code>#TypeHandler.getResult()</code>对结果进行类型转换。全部映射完成，返回结果。</li>
</ol>
</li>
<li><p>以上就是六剑客在Select的执行流程，如果有错误之处欢迎指正，如果觉得陈某写得不错，有所收获，关注分享一波。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E4%B8%83%E7%A7%92%E7%BC%96%E7%A8%8B.jpg" alt=""></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Mybatis进阶</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis如何阅读源码，教你一招？</title>
    <url>/2020/04/20/Mybatis%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81%EF%BC%8C%E6%95%99%E4%BD%A0%E4%B8%80%E6%8B%9B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>前一篇文章简单的介绍了Mybatis的六个重要组件，这六剑客占据了Mybatis的半壁江山，和六剑客搞了基友，那么Mybatis就是囊中之物了。对六剑客感兴趣的朋友，可以看看这篇文章：<a href="https://mp.weixin.qq.com/s/lnJx0h_4Kk6fKuhptN1cdg" target="_blank" rel="external">Mybatis源码解析篇之六剑客</a></li>
<li>有些初入门的朋友可能很害怕阅读源码，不知道如何阅读源码，与其我一篇文章按照自己的思路写完Mybatis的源码，但是你们又能理解多少呢？不如教会你们思路，让你们能够自己知道如何阅读源码。</li>
</ul>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ul>
<li>本篇文章讲的一切内容都是基于<code>Mybatis3.5</code>和<code>SpringBoot-2.3.3.RELEASE</code>。</li>
</ul>
<h2 id="从哪入手？"><a href="#从哪入手？" class="headerlink" title="从哪入手？"></a>从哪入手？</h2><ul>
<li><p>还是要说一说六剑客的故事，既然是Mybatis的重要组件，当然要从六剑客下手了，沿用上篇文章的一张图，此图记录了六剑客先后执行的顺序，如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-%E5%85%AD%E5%89%91%E5%AE%A2/3.png" alt="六剑客执行流程图"></p>
</li>
<li><p>阅读源码最重要的一点不能忘了，就是开启<code>DEBUG</code>模式，重要方法打上断点，重要语句打上断点，先把握整体，再研究细节，基本就不难了。</p>
</li>
<li><p>下面就以Myabtis的查询语句<code>selectList()</code>来具体分析下如何阅读。</p>
</li>
</ul>
<h2 id="总体把握六剑客"><a href="#总体把握六剑客" class="headerlink" title="总体把握六剑客"></a>总体把握六剑客</h2><ul>
<li><p>从六剑客开整，既然是重要组件，源码执行流程肯定都是围绕着六剑客，下面来对六剑客一一分析，如何打断点。</p>
</li>
<li><p>下面只是简单的教你如何打断点，对于六剑客是什么不再介绍，请看上篇文章。</p>
</li>
</ul>
<h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><ul>
<li><p>既然是接口，肯定不能在接口方法上打断点，上文介绍有两个实现类，分别是<code>DefaultSqlSession</code>、<code>SqlSessionTemplate</code>。那么SpringBoot在初始化的时候到底注入的是哪一个呢？这个就要看Mybatis的启动器的自动配置类了，其中有一段这样的代码，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//如果容器中没有SqlSessionTemplate这个Bean，则注入</span></div><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="meta">@ConditionalOnMissingBean</span></div><div class="line"><span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">sqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</div><div class="line">  ExecutorType executorType = <span class="keyword">this</span>.properties.getExecutorType();</div><div class="line">  <span class="keyword">if</span> (executorType != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory, executorType);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>从上面的代码可以知道，SpringBoot启动时注入了<code>SqlSessionTemplate</code>，此时就肯定从<code>SqlSessionTemplate</code>入手了。它的一些方法如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E6%95%99%E5%AD%A6/1.png" alt="SqlSessionTemplate方法"></p>
</li>
<li><p>从上图的标记可以知道，首当其冲的就是<code>构造方法</code>了;既然是分析<code>selectList()</code>的查询流程，当然全部的<code>selectList()</code>方法要打上断点了;上篇文章也讲了Mapper的接口最终是走的动态代理生成的实例，因此此处的<code>getMapper()</code>也打上断点。</p>
</li>
<li><p>对于初入门的来说，上面三处打上断点已经足够了，但是如果你仔细看一眼<code>selectList()</code>方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement)</span> </span>&#123;</div><div class="line">  <span class="comment">//此处的sqlSessionProxy是什么，也是SqlSession类型的，此处断点运行到这里可以知道，就是DefaultSqlSession实例</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.sqlSessionProxy.selectList(statement);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>sqlSessionProxy</code>是什么，没关系，这个不能靠猜，那么此时断点走一波，走到<code>selectList()</code>方法内部，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E6%95%99%E5%AD%A6/2.png" alt=""></p>
</li>
<li>从上图可以很清楚的看到了，其实就是<code>DefaultSqlSession</code>。哦，明白了，原来SqlSessionTemplate把过甩给了<code>DefaultSqlSession</code>了，太狡诈了。</li>
<li><code>DefaultSqlSession</code>如何打断点就不用说了吧，自己搞搞吧。</li>
</ul>
<h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><ul>
<li>上面文章讲过执行器是什么作用，也讲过Mybatis内部是根据什么创建执行器的。此处不再赘述了。</li>
<li>SpringBoot整合各种框架有个特点，万变不离自动配置类，框架的一些初始化动作基本全是在自动配置类中完成，于是我们在配置类找一找在哪里注入了<code>Executor</code>的Bean，于是找到了如下的一段代码：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E6%95%99%E5%AD%A6/3.png" alt=""></li>
<li>从上面的代码可以知道默认创建了<code>CachingExecutor</code>，二级缓存的执行器，别管那么多，看看它重写了<code>Executor</code>的哪些接口，与<code>selectList()</code>相关的方法打上断点，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E6%95%99%E5%AD%A6/4.png" alt=""></li>
<li><p>从上图也知道哪些方法和<code>selectList()</code>相关了，显然的<code>query</code>是查询的意思，别管那么多，先打上断点。</p>
</li>
<li><p>此时再仔细瞅一眼<code>query()</code>的方法怎么执行的，哦？发现了什么，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span></div><div class="line">      <span class="keyword">throws</span> SQLException &#123;</div><div class="line">      <span class="comment">//先尝试从缓存中获取</span></div><div class="line">    Cache cache = ms.getCache();</div><div class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</div><div class="line">      flushCacheIfRequired(ms);</div><div class="line">      <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</div><div class="line">        ensureNoOutParams(ms, boundSql);</div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">        List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</div><div class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</div><div class="line">          list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</div><div class="line">          tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//没有缓存，直接调用delegate的query方法</span></div><div class="line">    <span class="keyword">return</span> delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>从上面的代码知道，有缓存了，直接返回了，没有缓存，调用了<code>delegate</code>中的<code>query</code>方法，那么这个<code>delegate</code>是哪个类的对象呢？参照sqlSession的分析的方法，调试走起，可以知道是<code>SimpleExecutor</code>的实例，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E6%95%99%E5%AD%A6/5.png" alt=""></p>
</li>
<li>后面的<code>SimpleExecutor</code>如何打断点就不再说了，自己尝试找找。</li>
</ul>
<h3 id="StatementHandler"><a href="#StatementHandler" class="headerlink" title="StatementHandler"></a>StatementHandler</h3><ul>
<li>很熟悉的一个接口，在学JDBC的时候就接触过类似的，执行语句和设置参数的作用。</li>
<li>这个接口很简单，大佬写的代码，看到方法名就知道这个方法是干什么的，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E6%95%99%E5%AD%A6/6.png" alt=""></li>
<li>最重要的实现类是什么？当然是<code>PreparedStatementHandler</code>，因此在对应的方法上打上断点即可。</li>
</ul>
<h3 id="ParameterHandler"><a href="#ParameterHandler" class="headerlink" title="ParameterHandler"></a>ParameterHandler</h3><ul>
<li>这个接口很简单，也别选择了，总共两个方法，一个设置，一个获取，在实现类<code>DefaultParameterHandler</code>中对应的方法上打上断点即可。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E6%95%99%E5%AD%A6/7.png" alt=""></li>
</ul>
<h3 id="TypeHandler"><a href="#TypeHandler" class="headerlink" title="TypeHandler"></a>TypeHandler</h3><ul>
<li>类型处理器，也是一个简单的接口，总共’两个’方法，一个设置参数的转换，一个对结果的转换，啥也别说了，自己找到对应参数类型的处理器，在其中的方法打上断点。</li>
</ul>
<h3 id="ResultSetHandler"><a href="#ResultSetHandler" class="headerlink" title="ResultSetHandler"></a>ResultSetHandler</h3><ul>
<li>结果处理器，负责对结果的处理，总共三个方法，一个实现类<code>DefaultResultSetHandler</code>，全部安排断点。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>授人以鱼不授人以渔，与其都分析了给你看，不如教会你阅读源码的方式，先自己去研究，不仅仅是阅读Mybatis的源码是这样，阅读任何框架的源码都是如此，比如Spring的源码，只要找到其中重要的组件，比如前置处理器，后置处理器，事件触发器等等，一切都迎刃而解。</li>
<li>如果你觉得作者写的不错，有所收获，不妨关注分享一波，后续更多精彩内容更新。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E4%B8%83%E7%A7%92%E7%BC%96%E7%A8%8B.jpg" alt=""></li>
</ul>
]]></content>
      <categories>
        <category>Mybatis进阶</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis的Mapper中的方法为什么不能重载？</title>
    <url>/2020/04/20/Mybatis%E7%9A%84Mapper%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>在初入门<code>Mybatis</code>的时候可能都犯过一个错误，那就是在写<code>Mapper</code>接口的时候都重载过其中的方法，但是运行起来总是报错，那时候真的挺郁闷的，但是自己也查不出来原因，只能默默的改了方法名，哈哈，多么卑微的操作。</li>
<li>今天就写一篇文章从源码角度为大家解惑为什么<code>Mybatis</code>中的方法不能重载？<a id="more"></a>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2></li>
<li>本篇文章讲的一切内容都是基于<code>Mybatis3.5</code>和<code>SpringBoot-2.3.3.RELEASE</code>。</li>
</ul>
<h2 id="错误示范"><a href="#错误示范" class="headerlink" title="错误示范"></a>错误示范</h2><ul>
<li><p>举个栗子：假设现在有两个需求，一个是根据用户的id筛选用户，一个是根据用户的性别筛选，此时在Mapper中重载的方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</div><div class="line">    <span class="function">List&lt;UserInfo&gt; <span class="title">selectList</span><span class="params">(@Param(<span class="string">"userIds"</span>)</span> List&lt;String&gt; userIds)</span>;</div><div class="line"></div><div class="line">    <span class="function">List&lt;UserInfo&gt; <span class="title">selectList</span><span class="params">(Integer gender)</span></span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>这个并没有什么错误，但是启动项目，报出如下的错误：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'sqlSessionFactory' defined in class path resource [org/mybatis/spring/boot/autoconfigure/MybatisAutoConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.apache.ibatis.session.SqlSessionFactory]: Factory method 'sqlSessionFactory' threw exception; nested exception is org.springframework.core.NestedIOException: Failed to parse mapping resource: 'file [H:\work_project\demo\target\classes\mapper\UserInfoMapper.xml]'; nested exception is org.apache.ibatis.builder.BuilderException: Error parsing Mapper XML. The XML location is 'file [H:\work_project\demo\target\classes\mapper\UserInfoMapper.xml]'. Cause: java.lang.IllegalArgumentException: Mapped Statements collection already contains value for cn.cb.demo.dao.UserMapper.selectList. please check file [H:\work_project\demo\target\classes\mapper\UserInfoMapper.xml] and file [H:\work_project\demo\target\classes\mapper\UserInfoMapper.xml]</div><div class="line">	at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:655)</div><div class="line">	at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:635)</div><div class="line">	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1336)</div><div class="line">	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1176)</div><div class="line">	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:556)</div><div class="line">	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:516)</div><div class="line">	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:324)</div><div class="line">	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:226)</div><div class="line">	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:322)</div><div class="line">	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202)</div><div class="line">	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276)</div><div class="line">	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1307)</div><div class="line">	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1227)</div><div class="line">	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireByType(AbstractAutowireCapableBeanFactory.java:1509)</div><div class="line">	... 81 more</div></pre></td></tr></table></figure>
</li>
<li><p>这么一大串什么意思？懵逼了~<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybaits%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E9%87%8D%E8%BD%BD%EF%BC%9F/1.jpg" alt=""></p>
</li>
<li><p>大致的意思：<code>cn.cb.demo.dao.UserMapper.selectList</code>这个<code>id</code>已经存在了，导致创建<code>sqlSessionFactory</code>失败。</p>
</li>
</ul>
<h2 id="为什么不能重载？"><a href="#为什么不能重载？" class="headerlink" title="为什么不能重载？"></a>为什么不能重载？</h2><ul>
<li>通过上面的异常提示可以知道创建<code>sqlSessionFactory</code>失败了，这个想必已经不陌生吧，顾名思义，就是创建<code>SqlSession</code>的工厂。</li>
<li>Springboot与Mybatis会有一个启动器的自动配置类<code>MybatisAutoConfiguration</code>，其中有一段代码就是创建<code>sqlSessionFactory</code>，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybaits%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E9%87%8D%E8%BD%BD%EF%BC%9F/2.png" alt=""></li>
<li>既然是创建失败，那么肯定是这里出现异常了，这里的<strong>大致思路</strong>就是：<blockquote>
<p>解析<code>XML</code>文件和<code>Mapper</code>接口，将Mapper中的方法与XML文件中<code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>等标签一一对应，那么Mapper中的方法如何与XML中<code>&lt;select&gt;</code>这些标签对应了，当然是唯一的<code>id</code>对应了，具体如何这个<code>id</code>的值是什么，如何对应？下面一一讲解。</p>
</blockquote>
</li>
<li>如上图的<code>SqlSessionFactory</code>的创建过程中，前面的部分代码都是设置一些配置，并没有涉及到解析XML的内容，因此答案肯定是在最后一行<code>return factory.getObject();</code>，于是此处打上断点，一点点看。于是一直到了<code>org.mybatis.spring.SqlSessionFactoryBean#buildSqlSessionFactory</code>这个方法中，其中一段代码如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybaits%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E9%87%8D%E8%BD%BD%EF%BC%9F/3.png" alt=""></li>
<li>这里的<code>xmlMapperBuilder.parse();</code>就是解析XML文件与Mapper接口，继续向下看。</li>
<li>略过不重要的代码，在<code>org.apache.ibatis.builder.xml.XMLMapperBuilder#configurationElement</code>这个方法中有一行重要的代码，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybaits%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E9%87%8D%E8%BD%BD%EF%BC%9F/4.png" alt=""></li>
<li>此处就是根据XML文件中的<code>select|insert|update|delete</code>这些标签开始构建<code>MappedStatement</code>了。继续跟进去看。</li>
<li>略过不重要的代码，此时看到<code>org.apache.ibatis.builder.MapperBuilderAssistant#addMappedStatement</code>这个方法返回值就是<code>MappedStatement</code>，不用多说，肯定是这个方法了，仔细一看，很清楚的看到了构建<code>id</code>的代码，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybaits%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E9%87%8D%E8%BD%BD%EF%BC%9F/5.png" alt=""></li>
<li><p>从上图可以知道，创建<code>id</code>的代码就是<code>id = applyCurrentNamespace(id, false);</code>，具体实现如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybaits%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E9%87%8D%E8%BD%BD%EF%BC%9F/6.png" alt=""></p>
<blockquote>
<p>上图的代码已经很清楚了，<code>MappedStatement</code>中的<code>id=Mapper的全类名+&#39;.&#39;+方法名</code>。如果重载话，肯定会存在<code>id</code>相同的<code>MappedStatement</code>。</p>
</blockquote>
</li>
<li><p>到了这其实并不能说明方法不能重载啊，重复就重复呗，并没有冲突啊。这里需要看一个结构，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, MappedStatement&gt; mappedStatements = <span class="keyword">new</span> StrictMap&lt;MappedStatement&gt;(<span class="string">"Mapped Statements collection"</span>)</div><div class="line">      .conflictMessageProducer((savedValue, targetValue) -&gt;</div><div class="line">          <span class="string">". please check "</span> + savedValue.getResource() + <span class="string">" and "</span> + targetValue.getResource());</div></pre></td></tr></table></figure>
</li>
<li><p>构建好的<code>MappedStatement</code>都会存入<code>mappedStatements</code>中，如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMappedStatement</span><span class="params">(MappedStatement ms)</span> </span>&#123;</div><div class="line">    <span class="comment">//key 是id </span></div><div class="line">    mappedStatements.put(ms.getId(), ms);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>StrictMap</code>的<code>put(k,v)</code>方法如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybaits%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E9%87%8D%E8%BD%BD%EF%BC%9F/7.png" alt=""></p>
</li>
</ul>
<blockquote>
<p>到了这里应该理解了吧，这下抛出的异常和上面的<code>异常信息</code>对应起来了吧。这个<code>StrictMap</code>不允许有重复的<code>key</code>，而存入的<code>key</code>就是<code>id</code>。因此Mapper中的方法不能重载。</p>
</blockquote>
<h2 id="如何找到XML中对应的SQL？"><a href="#如何找到XML中对应的SQL？" class="headerlink" title="如何找到XML中对应的SQL？"></a>如何找到XML中对应的SQL？</h2><ul>
<li>在使用Mybatis的时候只是简单的调用Mapper中的方法就可以执行SQL，如下代码：<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">List&lt;UserInfo&gt; userInfos = userMapper.selectList(Arrays.asList(<span class="string">"192"</span>,<span class="string">"198"</span>));</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>一行简单的调用到底如何找到对应的SQL呢？其实就是根据<code>id</code>从<code>Map&lt;String, MappedStatement&gt; mappedStatements</code>中查找对应的<code>MappedStatement</code>。</p>
</blockquote>
<ul>
<li>在<code>org.apache.ibatis.session.defaults.DefaultSqlSession#selectList</code>方法有这一行代码如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybaits%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E9%87%8D%E8%BD%BD%EF%BC%9F/8.png" alt=""></li>
<li><code>MappedStatement ms = configuration.getMappedStatement(statement);</code>这行代码就是根据<code>id</code>从<code>mappedStatements</code>获取对应的<code>MappedStatement</code>，源码如下:<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> MappedStatement <span class="title">getMappedStatement</span><span class="params">(String id)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getMappedStatement(id, <span class="keyword">true</span>);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>文章写到这，想必已经很清楚Mapper中的方法为什么不能重载了，归根到底就是因为这个这个<code>id=Mapper的全类名+&#39;.&#39;+方法名</code>。</li>
<li>如果觉得作者写的不错，有所收获的话，点点关注，分享一波，关注微信公众号<code>码猿技术专栏</code>第一手文章推送！！！<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E4%B8%83%E7%A7%92%E7%BC%96%E7%A8%8B.jpg" alt=""></li>
</ul>
]]></content>
      <categories>
        <category>Mybatis进阶</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis源码阅读之六剑客</title>
    <url>/2020/04/20/Mybatis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8B%E5%85%AD%E5%89%91%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>Mybatis的专题文章写到这里已经是第四篇了，前三篇讲了Mybatis的基本使用，相信只要认真看了的朋友，在实际开发中正常使用应该不是问题。没有看过的朋友，作者建议去看一看，三篇文章分别是<a href="https://mp.weixin.qq.com/s/KdrEvlShnVoYA8nr0qLSNw" target="_blank" rel="external">Mybatis入门之基本操作</a>、<a href="https://mp.weixin.qq.com/s/czICR6jv1yz6adi6G3xFgQ" target="_blank" rel="external">Mybatis结果映射，你射准了吗？</a>、<a href="https://mp.weixin.qq.com/s/yuYAEXY_OGRsr0Eb3xZkog" target="_blank" rel="external">Mybatis动态SQL，你真的会了吗？</a>。</li>
<li>当然，任何一个技术都不能浅藏辄止，今天作者就带大家深入底层源码看一看Mybatis的基础架构。此篇文章只是源码的入门篇，讲一些Mybatis中重要的组件，作者称之为<code>六剑客</code>。<a id="more"></a>
<h2 id="环境版本"><a href="#环境版本" class="headerlink" title="环境版本"></a>环境版本</h2></li>
<li>本篇文章讲的一切内容都是基于<code>Mybatis3.5</code>和<code>SpringBoot-2.3.3.RELEASE</code>。</li>
</ul>
<h2 id="Myabtis的六剑客"><a href="#Myabtis的六剑客" class="headerlink" title="Myabtis的六剑客"></a>Myabtis的六剑客</h2><ul>
<li>其实Mybatis的底层源码和Spring比起来还是非常容易读懂的，作者将其中六个重要的接口抽离出来称之为<code>Mybatis的六剑客</code>，分别是<code>SqlSession</code>、<code>Executor</code>、<code>StatementHandler</code>、<code>ParameterHandler</code>、<code>ResultSetHandler</code>、<code>TypeHandler</code>。</li>
<li>六剑客在Mybatis中分别承担着什么角色？下面将会逐一介绍。</li>
<li>介绍六剑客之前，先来一张六剑客执行的流程图，如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-%E5%85%AD%E5%89%91%E5%AE%A2/3.png" alt=""></li>
</ul>
<h2 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h2><ul>
<li>SqlSession是Myabtis中的核心API，主要用来执行命令，获取映射，管理事务。它包含了所有执行语句、提交或回滚事务以及获取映射器实例的方法。</li>
</ul>
<h3 id="有何方法"><a href="#有何方法" class="headerlink" title="有何方法"></a>有何方法</h3><ul>
<li>其中定义了将近20个方法，其中涉及的到语句执行，事务提交回滚等方法。下面对于这些方法进行分类总结。</li>
</ul>
<h4 id="语句执行方法"><a href="#语句执行方法" class="headerlink" title="语句执行方法"></a>语句执行方法</h4><ul>
<li><p>这些方法被用来执行定义在 SQL 映射 XML 文件中的 SELECT、INSERT、UPDATE 和 DELETE 语句。你可以通过名字快速了解它们的作用，每一方法都接受语句的 ID 以及参数对象，参数可以是原始类型（支持自动装箱或包装类）、JavaBean、POJO 或 Map。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">&lt;T&gt; <span class="function">T <span class="title">selectOne</span><span class="params">(String statement, Object parameter)</span></span></div><div class="line">&lt;E&gt; List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter)</span></div><div class="line">&lt;T&gt; Cursor&lt;T&gt; <span class="title">selectCursor</span><span class="params">(String statement, Object parameter)</span></div><div class="line">&lt;K,V&gt; Map&lt;K,V&gt; <span class="title">selectMap</span><span class="params">(String statement, Object parameter, String mapKey)</span></div><div class="line"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(String statement, Object parameter)</span></div><div class="line"><span class="keyword">int</span> <span class="title">update</span><span class="params">(String statement, Object parameter)</span></div><div class="line"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(String statement, Object parameter)</span></div></pre></td></tr></table></figure>
</li>
<li><p>其中的最容易误解的就是<code>selectOne</code>和<code>selectList</code>，从方法名称就很容易知道区别，一个是查询单个，一个是查询多个。如果你对自己的SQL无法确定返回一个还是多个结果的时候，建议使用<code>selectList</code>。</p>
</li>
<li><code>insert</code>，<code>update</code>，<code>delete</code>方法返值是受影响的行数。</li>
<li><p>select还有几个重用的方法，用于限制返回行数，在Mysql中对应的就是<code>limit</code>，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">&lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span> <span class="params">(String statement, Object parameter, RowBounds rowBounds)</span></span></div><div class="line">&lt;T&gt; Cursor&lt;T&gt; <span class="title">selectCursor</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span></div><div class="line">&lt;K,V&gt; Map&lt;K,V&gt; <span class="title">selectMap</span><span class="params">(String statement, Object parameter, String mapKey, RowBounds rowbounds)</span></div><div class="line"><span class="keyword">void</span> <span class="title">select</span> <span class="params">(String statement, Object parameter, ResultHandler&lt;T&gt; handler)</span></div><div class="line"><span class="keyword">void</span> <span class="title">select</span> <span class="params">(String statement, Object parameter, RowBounds rowBounds, ResultHandler&lt;T&gt; handler)</span></div></pre></td></tr></table></figure>
</li>
<li><p>其中的<code>RowBounds</code>参数中保存了限制的行数，起始行数。</p>
</li>
</ul>
<h4 id="立即批量更新方法"><a href="#立即批量更新方法" class="headerlink" title="立即批量更新方法"></a>立即批量更新方法</h4><ul>
<li>当你将 ExecutorType 设置为 ExecutorType.BATCH 时，可以使用这个方法清除（执行）缓存在 JDBC 驱动类中的批量更新语句。<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function">List&lt;BatchResult&gt; <span class="title">flushStatements</span><span class="params">()</span></span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="事务控制方法"><a href="#事务控制方法" class="headerlink" title="事务控制方法"></a>事务控制方法</h4><ul>
<li><p>有四个方法用来控制事务作用域。当然，如果你已经设置了自动提交或你使用了外部事务管理器，这些方法就没什么作用了。然而，如果你正在使用由 Connection 实例控制的 JDBC 事务管理器，那么这四个方法就会派上用场：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span></span></div><div class="line"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> force)</span></div><div class="line"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span></div><div class="line"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(<span class="keyword">boolean</span> force)</span></div></pre></td></tr></table></figure>
</li>
<li><p>默认情况下 MyBatis 不会自动提交事务，除非它侦测到调用了插入、更新或删除方法改变了数据库。如果你没有使用这些方法提交修改，那么你可以在<code>commit</code> 和 <code>rollback</code> 方法参数中传入 true 值，来保证事务被正常提交（注意，在自动提交模式或者使用了外部事务管理器的情况下，设置 <code>force</code> 值对 <code>session</code> 无效）。大部分情况下你无需调用 <code>rollback()</code>，因为 MyBatis 会在你没有调用 <code>commit</code> 时替你完成回滚操作。不过，当你要在一个可能多次提交或回滚的 session 中详细控制事务，回滚操作就派上用场了。</p>
</li>
</ul>
<h4 id="本地缓存方法"><a href="#本地缓存方法" class="headerlink" title="本地缓存方法"></a>本地缓存方法</h4><ul>
<li>Mybatis 使用到了两种缓存：本地缓存（local cache）和二级缓存（second level cache）。</li>
<li>默认情况下，本地缓存数据的生命周期等同于整个 session 的周期。由于缓存会被用来解决循环引用问题和加快重复嵌套查询的速度，所以无法将其完全禁用。但是你可以通过设置 <code>localCacheScope=STATEMENT</code> 来只在语句执行时使用缓存。</li>
<li>可以调用以下方法清除本地缓存。<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span></span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="获取映射器"><a href="#获取映射器" class="headerlink" title="获取映射器"></a>获取映射器</h4><ul>
<li><p>在SqlSession中你也可以获取自己的映射器，直接使用下面的方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">&lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type)</span></span></div></pre></td></tr></table></figure>
</li>
<li><p>比如你需要获取一个<code>UserMapper</code>，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">UserMapper mapper = sqlSessionTemplate.getMapper(UserMapper.class);</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="有何实现类"><a href="#有何实现类" class="headerlink" title="有何实现类"></a>有何实现类</h3><ul>
<li>在Mybatis中有三个实现类，分别是<code>DefaultSqlSession</code>，<code>SqlSessionManager</code>、<code>SqlSessionTemplate</code>，其中重要的就是<code>DefaultSqlSession</code>，这个后面讲到Mybatis执行源码的时候会一一分析。</li>
<li>在与SpringBoot整合时，Mybatis的启动器配置类会默认注入一个<code>SqlSessionTemplate</code>，源码如下：<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line">  <span class="meta">@ConditionalOnMissingBean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">sqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span></div><div class="line">    <span class="comment">//根据执行器的类型创建不同的执行器，默认CachingExecutor</span></div><div class="line">    ExecutorType executorType = <span class="keyword">this</span>.properties.getExecutorType();</div><div class="line">    <span class="keyword">if</span> (executorType != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory, executorType);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><ul>
<li>Mybatis的执行器，是Mybatis的调度核心，负责SQL语句的生成和缓存的维护，SqlSession中的crud方法实际上都是调用执行器中的对应方法执行。</li>
<li>继承结构如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-%E5%85%AD%E5%89%91%E5%AE%A2/1.png" alt="继承结构"></li>
</ul>
<h3 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h3><ul>
<li>下面我们来看看都有哪些实现类，分别有什么作用。</li>
</ul>
<h4 id="BaseExecutor"><a href="#BaseExecutor" class="headerlink" title="BaseExecutor"></a>BaseExecutor</h4><ul>
<li>这是一个抽象类，采用模板方法的模式，有意思的是这个老弟模仿Spring的方式，真正的执行的方法都是<code>doxxx()</code>。</li>
<li>其中有一个方法值得注意，查询的时候走的<code>一级缓存</code>，因此这里注意下，既然这是个模板类，那么Mybatis执行select的时候默认都会走一级缓存。代码如下：<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    List&lt;E&gt; list;</div><div class="line">    <span class="comment">//此处的localCache即是一级缓存，是一个Map的结构</span></div><div class="line">    localCache.putObject(key, EXECUTION_PLACEHOLDER);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">//执行真正的查询</span></div><div class="line">      list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      localCache.removeObject(key);</div><div class="line">    &#125;</div><div class="line">    localCache.putObject(key, list);</div><div class="line">    <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</div><div class="line">      localOutputParameterCache.putObject(key, parameter);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> list;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="CachingExecutor"><a href="#CachingExecutor" class="headerlink" title="CachingExecutor"></a>CachingExecutor</h4><ul>
<li><p>这个比较有名了，二级缓存的维护类，与SpringBoot整合默认创建的就是这个家伙。下面来看一下如何走的二级缓存，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span></div><div class="line">      <span class="keyword">throws</span> SQLException &#123;</div><div class="line">    <span class="comment">//查看当前Sql是否使用了二级缓存</span></div><div class="line">    Cache cache = ms.getCache();</div><div class="line">    <span class="comment">//使用缓存了，直接从缓存中取</span></div><div class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</div><div class="line">      flushCacheIfRequired(ms);</div><div class="line">      <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</div><div class="line">        ensureNoOutParams(ms, boundSql);</div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">        <span class="comment">//从缓存中取数据</span></div><div class="line">        List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</div><div class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="comment">//没取到数据，则执行SQL从数据库查询</span></div><div class="line">          list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</div><div class="line">          <span class="comment">//查到了，放入缓存中</span></div><div class="line">          tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//直接返回</span></div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//没使用二级缓存，直接执行SQL从数据库查询</span></div><div class="line">    <span class="keyword">return</span> delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>这玩意就是走个二级缓存，其他没什么。</p>
</li>
</ul>
<h4 id="SimpleExecutor"><a href="#SimpleExecutor" class="headerlink" title="SimpleExecutor"></a>SimpleExecutor</h4><ul>
<li>这个类像个直男，最简单的一个执行器，就是根据对应的SQL执行，不会做一些额外的操作。</li>
</ul>
<h4 id="BatchExecutor"><a href="#BatchExecutor" class="headerlink" title="BatchExecutor"></a>BatchExecutor</h4><ul>
<li>通过批量操作来优化性能。通常需要注意的是<code>批量更新</code>操作，由于内部有缓存的实现，使用完成后记得调用<code>flushStatements</code>来清除缓存。</li>
</ul>
<h4 id="ReuseExecutor"><a href="#ReuseExecutor" class="headerlink" title="ReuseExecutor"></a>ReuseExecutor</h4><ul>
<li>　可重用的执行器，重用的对象是Statement，也就是说该执行器会缓存同一个sql的<code>Statement</code>，省去Statement的重新创建，优化性能。</li>
<li>内部的实现是通过一个<code>HashMap</code>来维护Statement对象的。由于当前Map只在该session中有效，所以使用完成后记得调用<code>flushStatements</code>来清除Map。</li>
</ul>
<h3 id="SpringBoot中如何创建"><a href="#SpringBoot中如何创建" class="headerlink" title="SpringBoot中如何创建"></a>SpringBoot中如何创建</h3><ul>
<li><p>在SpringBoot到底创建的是哪个执行器呢？其实只要阅读一下源码可以很清楚的知道，答案就在<code>org.apache.ibatis.session.Configuration</code>类中，其中创建执行器的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</div><div class="line">    <span class="comment">//没有指定执行器的类型，创建默认的，即是SimpleExecutor</span></div><div class="line">    executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</div><div class="line">    executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</div><div class="line">    Executor executor;</div><div class="line">    <span class="comment">//类型是BATCH，创建BatchExecutor</span></div><div class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</div><div class="line">      executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</div><div class="line">      <span class="comment">//类型为REUSE，创建ReuseExecutor</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</div><div class="line">      executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">//除了上面两种，创建的都是SimpleExecutor</span></div><div class="line">      executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果全局配置了二级缓存，则创建CachingExecutor，SpringBoot中这个参数默认是true，可以自己设置为false</span></div><div class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</div><div class="line">    <span class="comment">//创建CachingExecutor</span></div><div class="line">      executor = <span class="keyword">new</span> CachingExecutor(executor);</div><div class="line">    &#125;</div><div class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</div><div class="line">    <span class="keyword">return</span> executor;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>显而易见，SpringBoot中默认创建的是<code>CachingExecutor</code>，因为默认的<code>cacheEnabled</code>的值为<code>true</code>。</p>
</li>
</ul>
<h2 id="StatementHandler"><a href="#StatementHandler" class="headerlink" title="StatementHandler"></a>StatementHandler</h2><ul>
<li>熟悉JDBC的朋友应该都能猜到这个接口是干嘛的，很显然，这个是对SQL语句进行处理和参数赋值的。</li>
</ul>
<h3 id="实现类-1"><a href="#实现类-1" class="headerlink" title="实现类"></a>实现类</h3><ul>
<li>该接口也是有很多的实现类，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-%E5%85%AD%E5%89%91%E5%AE%A2/2.png" alt=""></li>
</ul>
<h4 id="SimpleStatementHandler"><a href="#SimpleStatementHandler" class="headerlink" title="SimpleStatementHandler"></a>SimpleStatementHandler</h4><ul>
<li>这个很简单了，就是对应我们JDBC中常用的Statement接口，用于简单SQL的处理</li>
</ul>
<h4 id="PreparedStatementHandler"><a href="#PreparedStatementHandler" class="headerlink" title="PreparedStatementHandler"></a>PreparedStatementHandler</h4><ul>
<li>这个对应JDBC中的PreparedStatement，预编译SQL的接口。</li>
</ul>
<h4 id="CallableStatementHandler"><a href="#CallableStatementHandler" class="headerlink" title="CallableStatementHandler"></a>CallableStatementHandler</h4><ul>
<li>这个对应JDBC中CallableStatement，用于执行存储过程相关的接口。</li>
</ul>
<h4 id="RoutingStatementHandler"><a href="#RoutingStatementHandler" class="headerlink" title="RoutingStatementHandler"></a>RoutingStatementHandler</h4><ul>
<li>这个接口是以上三个接口的路由，没有实际操作，只是负责上面三个StatementHandler的创建及调用。</li>
</ul>
<h2 id="ParameterHandler"><a href="#ParameterHandler" class="headerlink" title="ParameterHandler"></a>ParameterHandler</h2><ul>
<li><code>ParameterHandler</code>在Mybatis中负责将sql中的占位符替换为真正的参数，它是一个接口，有且只有一个实现类<code>DefaultParameterHandler</code>。</li>
<li><code>setParameters</code>是处理参数最核心的方法。这里不再详细的讲，后面会讲到。</li>
</ul>
<h2 id="TypeHandler"><a href="#TypeHandler" class="headerlink" title="TypeHandler"></a>TypeHandler</h2><ul>
<li>这位大神应该都听说过，也都自定义过吧，简单的说就是在预编译设置参数和取出结果的时候将Java类型和JDBC的类型进行相应的转换。当然，Mybatis内置了很多默认的类型处理器，基本够用，除非有特殊的定制，我们才会去自定义，比如需要将Java对象以<code>JSON</code>字符串的形式存入数据库，此时就可以自定义一个类型处理器。</li>
<li>很简单的东西，此处就不再详细的讲了，后面会单独出一篇如何自定义类型处理器的文章。</li>
</ul>
<h2 id="ResultSetHandler"><a href="#ResultSetHandler" class="headerlink" title="ResultSetHandler"></a>ResultSetHandler</h2><ul>
<li>结果处理器，负责将JDBC返回的ResultSet结果集对象转换成List类型的集合或者<code>Cursor</code>。</li>
<li>具体实现类就是<code>DefaultResultSetHandler</code>，其实现的步骤就是将Statement执行后的结果集，按照Mapper文件中配置的ResultType或ResultMap来封装成对应的对象，最后将封装的对象返回。</li>
<li>源码及其复杂，尤其是其中对嵌套查询的解析，这里只做个了解，后续会专门写一篇文章介绍。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>至此，Mybatis源码第一篇就已经讲完了，本篇文章对Mybatis中的重要组件做了初步的了解，为后面更深入的源码阅读做了铺垫，如果觉得作者写的不错，在看分享一波，谢谢支持。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E4%B8%83%E7%A7%92%E7%BC%96%E7%A8%8B.jpg" alt=""></li>
</ul>
]]></content>
      <categories>
        <category>Mybatis进阶</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis的几种传参方式，你了解吗？</title>
    <url>/2020/04/20/Mybatis%E7%9A%84%E5%87%A0%E7%A7%8D%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>前几天恰好面试一个应届生，问了一个很简单的问题：你了解过Mybatis中有几种传参方式吗？</li>
<li>没想到其他问题回答的很好，唯独这个问题一知半解，勉强回答了其中两种方式。</li>
<li>于是这篇文章就来说一说Mybatis传参的几种常见方式，给正在面试或者准备面试的朋友巩固一下。<a id="more"></a>
</li>
</ul>
<h2 id="单个参数"><a href="#单个参数" class="headerlink" title="单个参数"></a>单个参数</h2><ul>
<li>单个参数的传参比较简单，可以是任意形式的，比如<code>#{a}</code>、<code>#{b}</code>或者<code>#{param1}</code>，<strong>但是为了开发规范，尽量使用和入参时一样</strong>。</li>
<li><p>Mapper如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function">UserInfo <span class="title">selectByUserId</span><span class="params">(String userId)</span></span>;</div></pre></td></tr></table></figure>
</li>
<li><p>XML如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectByUserId"</span> <span class="attr">resultType</span>=<span class="string">"cn.cb.demo.domain.UserInfo"</span>&gt;</span></div><div class="line">        select * from user_info where user_id=#&#123;userId&#125; and status=1</div><div class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="多个参数"><a href="#多个参数" class="headerlink" title="多个参数"></a>多个参数</h2><ul>
<li>多个参数的情况下有很多种传参的方式，下面一一介绍。</li>
</ul>
<h3 id="使用索引【不推荐】"><a href="#使用索引【不推荐】" class="headerlink" title="使用索引【不推荐】"></a>使用索引【不推荐】</h3><ul>
<li>多个参数可以使用类似于索引的方式传值，比如<code>#{param1}</code>对应第一个参数，<code>#{param2}</code>对应第二个参数…….</li>
<li><p>Mapper方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function">UserInfo <span class="title">selectByUserIdAndStatus</span><span class="params">(String userId,Integer status)</span></span>;</div></pre></td></tr></table></figure>
</li>
<li><p>XML如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectByUserIdAndStatus"</span> <span class="attr">resultType</span>=<span class="string">"cn.cb.demo.domain.UserInfo"</span>&gt;</span></div><div class="line">        select * from user_info where user_id=#&#123;param1&#125; and status=#&#123;param2&#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>注意</strong>：由于开发规范，此种方式不推荐开发中使用。</p>
</li>
</ul>
<h3 id="使用-Param"><a href="#使用-Param" class="headerlink" title="使用@Param"></a>使用@Param</h3><ul>
<li><code>@Param</code>这个注解用于指定key，一旦指定了key，在SQL中即可对应的key入参。</li>
<li><p>Mapper方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function">UserInfo <span class="title">selectByUserIdAndStatus</span><span class="params">(@Param(<span class="string">"userId"</span>)</span> String userId,@<span class="title">Param</span><span class="params">(<span class="string">"status"</span>)</span> Integer status)</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>XML如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectByUserIdAndStatus"</span> <span class="attr">resultType</span>=<span class="string">"cn.cb.demo.domain.UserInfo"</span>&gt;</span></div><div class="line">        select * from user_info where user_id=#&#123;userId&#125; and status=#&#123;status&#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="使用Map"><a href="#使用Map" class="headerlink" title="使用Map"></a>使用Map</h3><ul>
<li>Mybatis底层就是将入参转换成<code>Map</code>，入参传Map当然也行，此时<code>#{key}</code>中的<code>key</code>就对应Map中的<code>key</code>。</li>
<li><p>Mapper中的方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function">UserInfo <span class="title">selectByUserIdAndStatusMap</span><span class="params">(Map&lt;String,Object&gt; map)</span></span>;</div></pre></td></tr></table></figure>
</li>
<li><p>XML如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">&lt;select id="selectByUserIdAndStatusMap" resultType="cn.cb.demo.domain.UserInfo"&gt;</div><div class="line">        select * from user_info where user_id=#&#123;userId&#125; and status=#&#123;status&#125;</div><div class="line">    &lt;/select&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>测试如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</div><div class="line">        Map&lt;String,Object&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        map.put(<span class="string">"userId"</span>,<span class="string">"1222"</span>);</div><div class="line">        map.put(<span class="string">"status"</span>,<span class="number">1</span>);</div><div class="line">        UserInfo userInfo = userMapper.selectByUserIdAndStatusMap(map);</div><div class="line">        System.out.println(userInfo);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="POJO【推荐】"><a href="#POJO【推荐】" class="headerlink" title="POJO【推荐】"></a>POJO【推荐】</h3><ul>
<li>多个参数可以使用实体类封装，此时对应的<code>key</code>就是属性名称，注意一定要有<code>get</code>方法。</li>
<li><p>Mapper方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function">UserInfo <span class="title">selectByEntity</span><span class="params">(UserInfoReq userInfoReq)</span></span>;</div></pre></td></tr></table></figure>
</li>
<li><p>XML如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectByEntity"</span> <span class="attr">resultType</span>=<span class="string">"cn.cb.demo.domain.UserInfo"</span>&gt;</span></div><div class="line">        select * from user_info where user_id=#&#123;userId&#125; and status=#&#123;status&#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>实体类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoReq</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String userId;</div><div class="line">    <span class="keyword">private</span> Integer status;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="List传参"><a href="#List传参" class="headerlink" title="List传参"></a>List传参</h2><ul>
<li>List传参也是比较常见的，通常是SQL中的<code>in</code>。</li>
<li><p>Mapper方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function">List&lt;UserInfo&gt; <span class="title">selectList</span><span class="params">( List&lt;String&gt; userIds)</span></span>;</div></pre></td></tr></table></figure>
</li>
<li><p>XML如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectList"</span> <span class="attr">resultMap</span>=<span class="string">"userResultMap"</span>&gt;</span></div><div class="line">        select * from user_info where status=1</div><div class="line">        and user_id in</div><div class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">separator</span>=<span class="string">","</span> <span class="attr">close</span>=<span class="string">")"</span> &gt;</span></div><div class="line">            #&#123;item&#125;</div><div class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="数组传参"><a href="#数组传参" class="headerlink" title="数组传参"></a>数组传参</h2><ul>
<li>这种方式类似List传参，依旧使用<code>foreach</code>语法。</li>
<li><p>Mapper方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function">List&lt;UserInfo&gt; <span class="title">selectList</span><span class="params">( String[] userIds)</span></span>;</div></pre></td></tr></table></figure>
</li>
<li><p>XML如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectList"</span> <span class="attr">resultMap</span>=<span class="string">"userResultMap"</span>&gt;</span></div><div class="line">        select * from user_info where status=1</div><div class="line">        and user_id in</div><div class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"array"</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">separator</span>=<span class="string">","</span> <span class="attr">close</span>=<span class="string">")"</span> &gt;</span></div><div class="line">            #&#123;item&#125;</div><div class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>以上几种传参的方式在面试或者工作中都会用到，不了解的朋友可以收藏下。</li>
<li>Mybatis专题文章写到这里也算是到了尾声，后期准备再写写Mybatis的面经，如果觉得作者写的不错，欢迎关注分享。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/myjszl_log.png" alt=""></li>
</ul>
]]></content>
      <categories>
        <category>Mybatis进阶</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql中orderby底层执行流程</title>
    <url>/2020/04/19/Mysql%E4%B8%ADorderby%E5%BA%95%E5%B1%82%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>在实际的开发中一定会碰到根据某个字段进行排序后来显示结果的需求，但是你真的理解<code>order by</code>在 Mysql 底层是如何执行的吗？</li>
<li>假设你要查询城市是<code>苏州</code>的所有人名字，并且按照姓名进行排序返回前 1000 个人的姓名、年龄，这条 sql 语句应该如何写？</li>
<li>首先创建一张用户表，sql 语句如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> (</div><div class="line">  <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  city <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  age <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</div><div class="line">  <span class="keyword">KEY</span> city (city)</div><div class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</div></pre></td></tr></table></figure>
<ul>
<li>则上述需求的 sql 查询语句如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">select</span> city,<span class="keyword">name</span>,age <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> city=<span class="string">'苏州'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">1000</span>;</div></pre></td></tr></table></figure>
<ul>
<li>这条 sql 查询语句相信大家都能写出来，但是你了解它在 Mysql 底层的执行流程吗？今天陈某来大家聊一聊这条 sql 语句是如何执行的以及有什么参数会影响执行的流程。</li>
<li>本篇文章分为如下几个部分进行详细的阐述：<ol>
<li><strong>全字段排序</strong></li>
<li><strong>rowid 排序</strong></li>
<li><strong>全字段排序 VS rowid 排序</strong></li>
<li><strong>如何避免排序</strong></li>
</ol>
</li>
</ul>
<h2 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h2><ul>
<li>前面聊过索引能够避免全表扫描，因此我们给<code>city</code>这个字段上添加了索引，当然城市的字段很小，不用考虑字符串的索引问题，之前有写过一篇关于如何给字符串的加索引的文章，有不了解朋友看一下这篇文章:<a href="https://mp.weixin.qq.com/s/xaa8ge7LsHWYROOy4qiRJA" target="_blank" rel="external">Mysql 性能优化：如何给字符串加索引？</a></li>
<li>此时用<code>Explain</code>来分析一下的这条查询语句的执行情况，结果如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/1.png" alt="Explain分析结果"></li>
<li><code>Extra</code>这个字段中的<code>Using filesort</code>表示的就是需要排序，MySQL 会给每个线程分配一块内存用于排序，称为<code>sort_buffer</code>。</li>
<li>既然使用了索引进行查询，我们来简单的画一下<code>city</code>这棵索引树的结构，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/2-1.png" alt="city索引树"></li>
<li>从上图可以看出，满足<code>city=&#39;苏州&#39;</code>是从<code>ID3</code>到<code>IDX</code>这些记录。</li>
<li>通常情况下，此条 sql 语句执行流程如下：<ol>
<li>初始化 sort_buffer，确定放入 name、city、age 这三个字段。</li>
<li>从索引 city 找到第一个满足<code>city=&#39;苏州&#39;</code>条件的<code>主键id</code>，也就是图中的<code>ID3</code>。</li>
<li>到<code>主键id索引</code>取出整行，取<code>name</code>、<code>city</code>、<code>age</code>三个字段的值，存入<code>sort_buffer</code>中。</li>
<li>从索引<code>city</code>取下一个记录的主键 id。</li>
<li>重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的<code>IDX</code>。</li>
<li>对<code>sort_buffer</code>中的数据按照字段<code>name</code>做快速排序。</li>
<li>按照排序结果取前 1000 行返回给客户端。</li>
</ol>
</li>
<li>我们称这个排序过程为<code>全字段排序</code>，执行的流程图如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/3.png" alt="全字段排序"></li>
<li>图中<code>按name排序</code>这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数<code>sort_buffer_size</code>。</li>
<li><code>sort_buffer_size</code>：就是 MySQL 为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用<code>磁盘临时文件</code>辅助排序。</li>
</ul>
<h2 id="rowid-排序"><a href="#rowid-排序" class="headerlink" title="rowid 排序"></a>rowid 排序</h2><ul>
<li>在上面这个算法过程里面，只对原表的数据读了一遍，剩下的操作都是在<code>sort_buffer</code>和<code>临时文件</code>中执行的。<strong>但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么<code>sort_buffer</code>里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差</strong>。</li>
<li>所以如果单行很大，这个方法效率不够好。</li>
<li>我们可以修改一个<code>max_length_for_sort_data</code>这个参数使其使用另外一种算法。max_length_for_sort_data，是 MySQL 中专门控制用于排序的行数据的长度的一个参数。它的意思是，如果单行的长度超过这个值，MySQL 就认为单行太大，要换一个算法。</li>
<li><code>city</code>、<code>name</code>、<code>age</code> 这三个字段的定义总长度是<code>36</code>，我把<code>max_length_for_sort_data</code>设置为 16，我们再来看看计算过程有什么改变。设置的 sql 语句如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">SET</span> max_length_for_sort_data = <span class="number">16</span>;</div></pre></td></tr></table></figure>
<ul>
<li><p>新的算法放入 sort_buffer 的字段，只有要排序的列（即 name 字段）和主键 id。</p>
</li>
<li><p>但这时，排序的结果就因为少了 city 和 age 字段的值，不能直接返回了，整个执行流程就变成如下所示的样子：</p>
<ol>
<li>初始化<code>sort_buffer</code>，确定放入两个字段，即<code>name</code>和<code>id</code>。</li>
<li>从索引 city 找到第一个满足<code>city=&#39;苏州&#39;</code>条件的<code>主键id</code>，也就是图中的<code>ID3</code>。</li>
<li>到<code>主键id索引</code>取出整行，取 name、id 这两个字段，存入 sort_buffer 中。</li>
<li>从索引<code>city</code>取下一个记录的主键 id。</li>
<li>重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的<code>IDX</code>。</li>
<li>对<code>sort_buffer</code>中的数据按照字段<code>name</code>做快速排序。</li>
<li>遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端。</li>
</ol>
</li>
<li>这个执行流程的示意图如下，我把它称为<code>rowid排序</code>。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/4.png" alt="rowid排序"></li>
<li><strong>对比<code>全字段排序</code>，<code>rowid排序</code>多了一次<code>回表查询</code>，即是多了<code>第7步</code>的查询主键索引树。</strong></li>
</ul>
<h2 id="全字段排序-VS-rowid-排序"><a href="#全字段排序-VS-rowid-排序" class="headerlink" title="全字段排序 VS rowid 排序"></a>全字段排序 VS rowid 排序</h2><ul>
<li>如果 MySQL 实在是担心排序内存太小，会影响排序效率，才会采用 rowid 排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。</li>
<li>如果 MySQL 认为内存足够大，会优先选择全字段排序，把需要的字段都放到 sort_buffer 中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。</li>
<li>这也就体现了 MySQL 的一个设计思想：<strong>如果内存够，就要多利用内存，尽量减少磁盘访问</strong>。</li>
<li><strong>对于 InnoDB 表来说，rowid 排序会要求回表多造成磁盘读，因此不会被优先选择。</strong></li>
</ul>
<h2 id="如何避免排序"><a href="#如何避免排序" class="headerlink" title="如何避免排序"></a>如何避免排序</h2><ul>
<li>其实，并不是所有的<code>order by</code>语句，都需要排序操作的。从上面分析的执行过程，我们可以看到，MySQL 之所以需要生成临时表，并且在临时表上做排序操作，其原因是<strong>原来的数据都是无序的</strong>。</li>
<li>如果能够保证从<code>city</code>这个索引上取出来的行，天然就是按照 name 递增排序的话，是不是就可以不用再排序了呢？</li>
<li>因此想到了联合索引，创建<code>(city,name)</code>联合索引，sql 语句如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">user</span> <span class="keyword">add</span> <span class="keyword">index</span> city_user(city, <span class="keyword">name</span>);</div></pre></td></tr></table></figure>
<ul>
<li>此时的索引树如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/5-1.png" alt="city,name索引树"></li>
<li>在这个索引里面，我们依然可以用树搜索的方式定位到第一个满足<code>city=&#39;苏州&#39;</code>的记录，并且额外确保了，接下来按顺序取“下一条记录”的遍历过程中，只要 city 的值是苏州，name 的值就一定是有序的。</li>
<li>按照上图，整个查询的流程如下：<ol>
<li>从索引(city,name)找到第一个满足 city=’苏州’条件的主键 id。</li>
<li>到主键 id 索引取出整行，取 name、city、age 三个字段的值，作为结果集的一部分直接返回。</li>
<li>从索引(city,name)取下一个记录主键 id。</li>
<li>重复步骤 2、3，直到查到第 1000 条记录，或者是不满足 city=’苏州’条件时循环结束。</li>
</ol>
</li>
<li>对应的流程图如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/6.png" alt="city，name联合索引的执行流程"></li>
<li>可以看到，这个查询过程不需要临时表，也不需要排序。接下来，我们用 explain 的结果来印证一下。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/7.png" alt=""></li>
<li>从图中可以看到，<code>Extra</code>字段中没有<code>Using filesort</code>了，也就是不需要排序了。而且由于<code>(city,name)</code>这个联合索引本身有序，<strong>所以这个查询也不用把 4000 行全都读一遍，只要找到满足条件的前 1000 条记录就可以退出了</strong>。也就是说，在我们这个例子里，只需要扫描 1000 次。</li>
<li>难道仅仅这样就能满足了？此条查询语句是否能再优化呢？<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/8.jpg" alt=""></li>
<li>朋友们还记得覆盖索引吗？覆盖索引的好处就是能够避免再次回表查询，不了解的朋友们可以看一下陈某之前写的文章：<a href="https://mp.weixin.qq.com/s/-IRhK4KyDCkTd_lojeEolw" target="_blank" rel="external">Mysql 性能优化：如何使用覆盖索引？</a>。</li>
<li>我们创建<code>(city,name,age)</code>联合索引，这样在执行上面的查询语句就能使用覆盖索引了，避免了回表查询了，sql 语句如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">user</span> <span class="keyword">add</span> <span class="keyword">index</span> city_user_age(city, <span class="keyword">name</span>, age);</div></pre></td></tr></table></figure>
<ul>
<li>此时执行流程图如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/9-1.png" alt="覆盖索引使用执行流程"></li>
<li><strong>当然，覆盖索引能够提升效率，但是维护索引也是需要代价的，因此还需要权衡使用。</strong></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>今天这篇文章，我和你介绍了 MySQL 里面<code>order by</code>语句的几种算法流程。</li>
<li>在开发系统的时候，你总是不可避免地会使用到 order by 语句。心里要清楚每个语句的排序逻辑是怎么实现的，还要能够分析出在最坏情况下，每个语句的执行对系统资源的消耗，这样才能做到下笔如有神，不犯低级错误。</li>
</ul>
]]></content>
      <categories>
        <category>数据库干货篇</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql中的三类锁，你知道吗？</title>
    <url>/2020/04/01/Mysql%E4%B8%AD%E7%9A%84%E4%B8%89%E7%B1%BB%E9%94%81%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li><p>正所谓有人(锁)的地方就有江湖(事务)，人在江湖飘，怎能一无所知？</p>
</li>
<li><p>今天来细说一下Mysql中的三类锁，分别是全局锁、表级锁、行级锁。</p>
<a id="more"></a>
</li>
</ul>
<h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><ul>
<li>全局锁简单的说就是锁住整个数据库实例，命令是<code>Flush tables with read lock</code>。当你需要为整个数据库处于只读的状态的时候，可以使用这个命令。</li>
<li>一旦使用全局锁，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。 </li>
<li>全局锁的使用场景大部分都是用来<strong>数据库备份</strong>。</li>
</ul>
<h3 id="为什么备份要加全局锁？"><a href="#为什么备份要加全局锁？" class="headerlink" title="为什么备份要加全局锁？"></a>为什么备份要加全局锁？</h3><ul>
<li>用户买东西，首先会从余额里扣除金额，然后在订单里添加商品。如果备份数据库，不加锁，并且备份顺序为先备份用余额，再备份订单商品，有可能备份了用户余额后，用户下订单买东西提交事务，然后再备份订单商品表， 此时订单商品已存在。最后备份出来的数据为。最后用户余额为买东西前的余额，没有减少，但是订单商品却多了。演示如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/1.png" alt=""></p>
<ul>
<li>这种情况可能用户会觉得赚了，但是如果备份顺序反过来，先备份商品表再备份余额表，用户就会发现我付了钱，但是商品没有加，这中结果就会更加的严重。 </li>
<li>因此保证备份数据的一致性很重要，必要的手段就是加锁。</li>
</ul>
<h3 id="全局锁有什么坏处？"><a href="#全局锁有什么坏处？" class="headerlink" title="全局锁有什么坏处？"></a>全局锁有什么坏处？</h3><ul>
<li>全局锁是个啥？介绍完了读者心里已经有数了，让这个库只读？这是多么可怕的操作，简单列举几个危险之处：<ul>
<li>如果在主库备份，备份期间不能执行任何更新操作，会导致整个业务停摆，高并发情况下更甚。</li>
<li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。</li>
</ul>
</li>
</ul>
<h3 id="全局备份比较好的解决方案"><a href="#全局备份比较好的解决方案" class="headerlink" title="全局备份比较好的解决方案"></a>全局备份比较好的解决方案</h3><ul>
<li>全局锁远瞅不错，近瞅吓一跳，陈某在此不推荐使用。</li>
<li>其实 官方自带的逻辑备份工具是mysqldump。当<strong>mysqldump</strong>使用参数<strong>–single-transaction</strong>的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。 </li>
<li>一致性备份是好，但前提是存储引擎支持事务，这也是MyISAM被InnoDB取代的原因之一。</li>
</ul>
<h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><ul>
<li>MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。 </li>
<li>表锁一般是在数据库引擎不支持行锁的时候才会被用到的 。</li>
<li>MDL会直到事务提交才释放，在做<strong>表结构变更</strong>的时候，你一定要小心不要导致锁住线上查询和更新 。</li>
</ul>
<h3 id="如何加表锁"><a href="#如何加表锁" class="headerlink" title="如何加表锁"></a>如何加表锁</h3><ul>
<li>显式加表锁和解锁的语句很简单，如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">lock</span> <span class="keyword">tables</span> tb_name <span class="keyword">read</span>/write;</div><div class="line"></div><div class="line"><span class="keyword">unlock</span> <span class="keyword">tables</span>;</div></pre></td></tr></table></figure>
<ul>
<li>需要注意，lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。 </li>
<li>举个例子, 如果在某个线程A中执行<strong>lock tables t1 read, t2 write;</strong> 这个语句，则其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行<strong>unlock tables</strong>之前，也只能执行读t1、读写t2的操作。连写t1都不允许，自然也不能访问其他表。 </li>
</ul>
<h3 id="MDL"><a href="#MDL" class="headerlink" title="MDL"></a>MDL</h3><ul>
<li>MDL不需要显式使用，在访问一个表的时候会被自动加上。 </li>
<li>当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。 </li>
<li><strong>读锁</strong>之间不互斥，因此你可以有多个线程同时对一张表增删改查。 </li>
<li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。 </li>
</ul>
<h3 id="查询表级锁争用"><a href="#查询表级锁争用" class="headerlink" title="查询表级锁争用"></a>查询表级锁争用</h3><ul>
<li>查询表级锁的争用可以通过以下参数分析获得：<ul>
<li><code>Table_locks_immediate</code>：能够立即获得表级锁的次数 </li>
<li><code>Table_locks_waited</code>： 不能立即获取表级锁而需要等待的次数 </li>
</ul>
</li>
<li>查询语句如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'table_locks_waited'</span></div></pre></td></tr></table></figure>
<ul>
<li>如果<code>Table_locks_waited</code>的值比较大，则说明存在着较严重的表级锁争用情况。 </li>
</ul>
<h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><ul>
<li>MySQL的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如MyISAM引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB是支持行锁的，这也是MyISAM被InnoDB替代的重要原因之一。 </li>
<li><strong>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁</strong>。 </li>
<li><strong>在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。</strong> </li>
<li>行级锁分为排它锁（写锁）、共享锁（读锁）、间隙锁。</li>
</ul>
<h3 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h3><ul>
<li>排他锁，也称写锁，独占锁，当前写操作没有完成前，它会阻断其他写锁和读锁。 </li>
<li>Mysql中的更新语句(update/delete/insert)会自动加上排它锁。</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/2.png" alt=""></p>
<ul>
<li>如上图，事务B中的update语句被阻塞了，直到事务A提交才能执行更新操作。</li>
<li>排他锁也可以手动添加，如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</div></pre></td></tr></table></figure>
<ul>
<li>注意以下两点：<ul>
<li>行锁是针对索引加锁的，上述例子中id是主键索引。</li>
<li><strong>加了排他锁并不是其他的事务不能读取这行的数据，而是不能再在这行上面加锁了。</strong></li>
</ul>
</li>
</ul>
<h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><ul>
<li>当我们用范围条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但<strong>并不存在</strong>的记录，叫做”间隙(GAP)”。InnoDB也会对这个”间隙”加锁，这种锁机制就是所谓的间隙锁(Next-Key锁)。 </li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/3.png" alt=""></p>
<ul>
<li>如上图，给id&gt;5中并不存在的数据加上了间隙锁，当插入id=6的数据时被阻塞了。</li>
<li>这是一个坑：<strong>若执行的条件是范围过大，则InnoDB会将整个范围内所有的索引键值全部锁定，很容易对性能造成影响</strong> </li>
</ul>
<h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3><ul>
<li>共享锁，也称读锁，多用于判断数据是否存在，多个读操作可以同时进行而不会互相影响。当如果事务对读锁进行修改操作，很可能会造成死锁。如下图所示。 </li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/4.png" alt=""></p>
<h3 id="分析行锁定"><a href="#分析行锁定" class="headerlink" title="分析行锁定"></a>分析行锁定</h3><ul>
<li>通过检查InnoDB_row_lock 状态变量分析系统上的行锁的争夺情况 。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'innodb_row_lock%'</span></div></pre></td></tr></table></figure>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/5.png" alt=""></p>
<ul>
<li>innodb_row_lock_current_waits: 当前正在等待锁定的数量。</li>
<li>innodb_row_lock_time: 从系统启动到现在锁定总时间长度；非常重要的参数</li>
<li>innodb_row_lock_time_avg: 每次等待所花平均时间；非常重要的参数。</li>
<li>innodb_row_lock_time_max: 从系统启动到现在等待最常的一次所花的时间； </li>
<li>innodb_row_lock_waits: 系统启动后到现在总共等待的次数；非常重要的参数。直接决定优化的方向和策略。 </li>
</ul>
<h3 id="死锁解决方案"><a href="#死锁解决方案" class="headerlink" title="死锁解决方案"></a>死锁解决方案</h3><p>1、直接进入等待，直到超时。这个超时时间可以通过参数<strong>innodb_lock_wait_timeout</strong>来设置，默认50秒。注意超时时间不能设置太短，如果仅仅是短暂的等待，一旦设置时间很短，很快便解锁了，会出现误伤。</p>
<p>2、发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数<strong>innodb_deadlock_detect</strong>设置为on，表示开启这个逻辑，默认开启。 主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。 当并发很高的时候，检测死锁将会消耗大量的资源，因此控制并发也是很重要的一种策略。</p>
]]></content>
      <categories>
        <category>数据库干货篇</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql性能优化：为什么count(*)这么慢？</title>
    <url>/2020/04/05/Mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88count%E8%BF%99%E4%B9%88%E6%85%A2/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>在开发中一定会用到统计一张表的行数，比如一个交易系统，老板会让你每天生成一个报表，这些统计信息少不了sql中的<code>count</code>函数。</li>
<li>但是随着记录越来越多，查询的速度会越来越慢，为什么会这样呢？Mysql内部到底是怎么处理的？</li>
<li>今天这篇文章将从Mysql内部对于<code>count</code>函数是怎样处理的？</li>
</ul>
<h2 id="count的实现方式"><a href="#count的实现方式" class="headerlink" title="count的实现方式"></a>count的实现方式</h2><ul>
<li>在Mysql中的不同的存储引擎对<code>count</code>函数有不同的实现方式。</li>
<li><code>MyISAM</code>引擎把一个表的总行数存在了磁盘上，因此执行<code>count(*)</code>的时候会直接返回这个数，效率很高（没有<code>where</code>查询条件）。</li>
<li><code>InnoDB</code>引擎并没有直接将总数存在磁盘上，在执行<code>count(*)</code>函数的时候需要一行一行的将数据读出来，然后累计总数。</li>
</ul>
<h2 id="为什么InnoDB不将总数存起来？"><a href="#为什么InnoDB不将总数存起来？" class="headerlink" title="为什么InnoDB不将总数存起来？"></a>为什么InnoDB不将总数存起来？</h2><ul>
<li><p>说道InnoDB相信读者总会想到其支持事务的特性，事务具有隔离性，如果将总数存起来，怎么保证各个事务之间的总数的一致性呢？不明白的看下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/count/1.png" alt=""></p>
</li>
<li><p><code>事务A</code>和<code>事务B</code>中的<code>count(*)</code>的执行结果是不同的，因此InnoDB引擎在每个事务中返回多少行是不确定的，只能一行一行的读出来用来判断总数。</p>
</li>
</ul>
<h2 id="如何提升count效率"><a href="#如何提升count效率" class="headerlink" title="如何提升count效率"></a>如何提升count效率</h2><ul>
<li>在<code>InnoDB</code>对于如何提升<code>count(*)</code>的查询效率，网上有多种解决办法，这里主要介绍三种，并分析可行性。</li>
</ul>
<h3 id="show-table-status"><a href="#show-table-status" class="headerlink" title="show table status"></a>show table status</h3><ul>
<li><code>show table status</code>这个命令能够很快的查询出数据库中每个表的行数，但是真的能够替代<code>count(*)</code>吗？</li>
<li>答案是不能。原因很简单，这个命令统计出来的值是一个<strong>估值</strong>，因此是不准确的，官方文档说误差大概在<code>40%-50%</code>。</li>
<li>因此这种方法直接pass，不准确还用它干嘛。</li>
</ul>
<h3 id="缓存系统存储总数"><a href="#缓存系统存储总数" class="headerlink" title="缓存系统存储总数"></a>缓存系统存储总数</h3><ul>
<li>这种方法也是最容易想到的，增加一行就<code>+1</code>，删除一行就<code>-1</code>，并且缓存系统读取也是很快，既简单又方便的为什么不用？</li>
<li><p>缓存系统和Mysql是两个系统，比如<code>redis</code>和<code>Mysql</code>这两个是典型的比较。两个系统最难的就是在高并发下无法保证数据的一致性。通过以下两图我们来理解一下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/count/2.png" alt=""><br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/count/3.png" alt=""></p>
</li>
<li><p>通过上面两张图，无论是<code>redis计数+1</code>还是<code>insert into user</code>先执行，最终都会导致数据在逻辑上的不一致。第一张图会出现<code>redis计数</code>少了，第二张图虽然计数正确了但是并没有查询出插入的那一行数据。</p>
</li>
<li>在并发系统里面，我们是无法精确控制不同线程的执行时刻的，因为存在图中的这种操作序列，所以，我们说即使Redis正常工作，这个计数值还是逻辑上不精确的。</li>
</ul>
<h3 id="在数据库保存计数"><a href="#在数据库保存计数" class="headerlink" title="在数据库保存计数"></a>在数据库保存计数</h3><ul>
<li>通过缓存系统保存的分析得知了使用缓存无法保证数据在逻辑上的一致性，因此我们想到了直接使用数据库来保存，有了<strong>事务</strong>的支持，也就保证了数据的一致性了。</li>
<li>如何使用呢？很简单，直接将计数保存在一张表中<code>（table_name,total）</code>。</li>
<li><p>至于执行的逻辑只需要将缓存系统中<code>redis计数+1</code>改成<code>total</code>字段+1即可，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/count/4.png" alt=""></p>
</li>
<li><p>由于在同一个事务中，保证了数据在逻辑上的一致性。</p>
</li>
</ul>
<h2 id="不同count的用法"><a href="#不同count的用法" class="headerlink" title="不同count的用法"></a>不同count的用法</h2><ul>
<li><code>count()</code>是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL，累计值就加1，否则不加。最后返回累计值。</li>
<li><code>count</code>的用法有多种，分别是<code>count(*)</code>、<code>count(字段)</code>、<code>count(1)</code>、<code>count(主键id)</code>。那么多种用法，到底有什么差别呢？当然，<strong>前提是没有<code>where</code>条件语句</strong>。</li>
<li><code>count(id)</code>：InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空的，就按行累加。</li>
<li><code>count(1)</code>：InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字<code>1</code>进去，判断是不可能为空的，按行累加。</li>
<li><code>count(字段)</code>：<ul>
<li>如果这个“字段”是定义为<code>not null</code>的话，一行行地从记录里面读出这个字段，判断不能为null，按行累加；</li>
<li>如果这个字段定义允许为<code>null</code>，那么执行的时候，判断到有可能是null，还要把值取出来再判断一下，不是null才累加。</li>
</ul>
</li>
<li><code>count(*)</code>：不会把全部字段取出来，而是专门做了优化，不取值。<code>count(*)</code>肯定不是null，按行累加。</li>
<li>所以结论很简单：<strong>按照效率排序的话，<code>count(字段)</code>&lt;<code>count(主键id)</code>&lt;<code>count(1)</code>≈<code>count(*)</code>，所以建议读者，尽量使用<code>count(*)</code>。</strong></li>
<li><strong>注意</strong>：这里肯定有人会问，<code>count(id)</code>不是走的索引吗，为什么查询效率和其他的差不多呢？陈某在这里解释一下，虽然走的索引，但是还是要一行一行的扫描才能统计出来总数。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>MyISAM</code>表虽然<code>count(*)</code>很快，但是不支持事务；</li>
<li><code>show table status</code>命令虽然返回很快，但是不准确；</li>
<li><code>InnoDB</code>直接<code>count(*)</code>会遍历全表(没有where条件)，虽然结果准确，但会导致性能问题。</li>
<li>缓存系统的存储计数虽然简单效率高，但是无法保证数据的一致性。</li>
<li>数据库保存计数很简单，也能保证数据的一致性，建议使用。</li>
<li><strong>思考题，读者留言区讨论</strong>：在系统高并发的情况下，使用数据库保存计数，是先<code>更新计数+1</code>,还是先<code>插入数据</code>。即是先<code>update total+=1</code>还是先<code>insert into</code>。</li>
</ul>
]]></content>
      <categories>
        <category>数据库干货篇</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql性能优化：为什么使用覆盖索引?</title>
    <url>/2020/04/01/Mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li><p>相信读者看过很多MYSQL索引优化的文章，其中有很多优化的方法，比如最佳左前缀，覆盖索引等方法，但是你真正理解为什么要使用最佳左前缀，为什么使用覆盖索引会提升查询的效率吗？</p>
</li>
<li><p>本篇文章将从MYSQL内部结构上讲一下为什么覆盖索引能够提升效率。</p>
</li>
</ul>
<a id="more"></a>
<h2 id="InnoDB索引模型"><a href="#InnoDB索引模型" class="headerlink" title="InnoDB索引模型"></a>InnoDB索引模型</h2><ul>
<li>在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。</li>
<li>每一个索引在InnoDB里面对应一棵B+树。</li>
</ul>
<h2 id="主键索引和非主键索引的区别"><a href="#主键索引和非主键索引的区别" class="headerlink" title="主键索引和非主键索引的区别"></a>主键索引和非主键索引的区别</h2><ul>
<li>主键索引又叫聚簇索引 ，非主键索引又叫普通索引，那么这两种索引有什么区别呢？</li>
<li>主键索引的叶子节点存放的是整行数据，非主键索引的叶子节点存放的是主键的值。</li>
<li>假设有一张User表（id,age,name,address），其中有id和age两个字段，其中id是主键，age是普通索引，有几行数据u1-u5的(id,age)的值是(100,1)、(200,2)、(300,3)、(500,5)和(600,6) ，此时的两棵树的示例如下：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95/1.png" alt=""></p>
<ul>
<li>从上图可以看出来，基于主键索引的树的叶子节点存放的是整行User数据，基于普通索引age的叶子节点存放的是id（主键）的值。</li>
</ul>
<h2 id="什么是回表？"><a href="#什么是回表？" class="headerlink" title="什么是回表？"></a>什么是回表？</h2><ul>
<li>假设有一条查询语句如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age=<span class="number">3</span>;</div></pre></td></tr></table></figure>
<ul>
<li><p>上面这条sql语句执行的过程如下：</p>
<p>1、根据age这个普通索引在age索引树上搜索，得到主键id的值为300。</p>
<p>2、因为age索引树并没有存储User的全部数据，因此需要根据在age索引树上查询到的主键id的值300再到id索引树搜索一次，查询到了u3。</p>
<p>3、返回结果。</p>
</li>
<li><p>上述执行的过程中，从age索引树再到id索引树的查询的过程叫做回表（回到主键索引树搜索的过程）。</p>
</li>
<li><p>也就是说通过非主键索引的查询需要多扫描一棵索引树，因此需要尽量使用主键索引查询。</p>
</li>
</ul>
<h2 id="为什么使用覆盖索引？"><a href="#为什么使用覆盖索引？" class="headerlink" title="为什么使用覆盖索引？"></a>为什么使用覆盖索引？</h2><ul>
<li>有了上述提及到的几个概念，便能很清楚的理解为什么覆盖索引能够提升查询效率了，因为少了一次回表的过程。</li>
<li>假设我们使用覆盖索引查询，语句如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">select id from user where age=3;</div></pre></td></tr></table></figure>
<ul>
<li>这条语句执行过程很简单，直接在age索引树中就能查询到id的值，不用再去id索引树中查找其他的数据，避免了回表。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>覆盖索引的使用能够减少树的搜索次数，避免了回表，显著提升了查询性能，因此覆盖索引是一个常用的性能优化手段。</li>
<li>留给读者一个问题：身份证是一个人的唯一识别凭证，如果有根据身份证号查询市民信息的需求，我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？ </li>
</ul>
]]></content>
      <categories>
        <category>数据库干货篇</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql性能优化：什么是索引下推？</title>
    <url>/2020/04/01/Mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>索引下推（index condition pushdown ）简称ICP，在Mysql5.6的版本上推出，用于优化查询。</li>
<li>在不使用ICP的情况下，在使用非主键索引（又叫普通索引或者二级索引）进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件 。</li>
<li>在使用ICP的情况下，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。</li>
<li>索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。 <a id="more"></a>
</li>
</ul>
<h2 id="开撸"><a href="#开撸" class="headerlink" title="开撸"></a>开撸</h2><ul>
<li>在开始之前先先准备一张用户表(user)，其中主要几个字段有：id、name、age、address。建立联合索引（name，age）。</li>
<li>假设有一个需求，要求匹配姓名第一个为陈的所有用户，sql语句如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span>  <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'陈%'</span></div></pre></td></tr></table></figure>
<ul>
<li>根据 “最佳左前缀” 的原则，这里使用了联合索引（name，age）进行了查询，性能要比全表扫描肯定要高。</li>
<li>问题来了，如果有其他的条件呢？假设又有一个需求，要求匹配姓名第一个字为陈，年龄为20岁的用户，此时的sql语句如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span>  <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'陈%'</span> <span class="keyword">and</span> age=<span class="number">20</span></div></pre></td></tr></table></figure>
<ul>
<li>这条sql语句应该如何执行呢？下面对Mysql5.6之前版本和之后版本进行分析。</li>
</ul>
<h3 id="Mysql5-6之前的版本"><a href="#Mysql5-6之前的版本" class="headerlink" title="Mysql5.6之前的版本"></a>Mysql5.6之前的版本</h3><ul>
<li>5.6之前的版本是没有索引下推这个优化的，因此执行的过程如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/1.png" alt=""></p>
<ul>
<li>会忽略age这个字段，直接通过name进行查询，在(name,age)这课树上查找到了两个结果，id分别为2,1，然后拿着取到的id值一次次的回表查询，因此这个过程需要<strong>回表两次</strong>。</li>
</ul>
<h3 id="Mysql5-6及之后版本"><a href="#Mysql5-6及之后版本" class="headerlink" title="Mysql5.6及之后版本"></a>Mysql5.6及之后版本</h3><ul>
<li>5.6版本添加了索引下推这个优化，执行的过程如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/2.png" alt=""></p>
<ul>
<li>InnoDB并没有忽略age这个字段，而是在索引内部就判断了age是否等于20，对于不等于20的记录直接跳过，因此在(name,age)这棵索引树中只匹配到了一个记录，此时拿着这个id去主键索引树中回表查询全部数据，这个过程只需要回表一次。</li>
</ul>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><ul>
<li>当然上述的分析只是原理上的，我们可以实战分析一下，因此陈某装了Mysql5.6版本的Mysql，解析了上述的语句，如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/3.png" alt=""></p>
<ul>
<li>根据explain解析结果可以看出Extra的值为<strong>Using index condition</strong>，表示已经使用了索引下推。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>索引下推在<strong>非主键索引</strong>上的优化，可以有效减少回表的次数，大大提升了查询的效率。</li>
<li>关闭索引下推可以使用如下命令，配置文件的修改不再讲述了，毕竟这么优秀的功能干嘛关闭呢：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">set</span> optimizer_switch=<span class="string">'index_condition_pushdown=off'</span>;</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库干货篇</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql最全面试指南</title>
    <url>/2020/04/20/Mysql%E6%9C%80%E5%85%A8%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>前几天有读者找到我，说想要一套全面的Mysql面试题，今天陈某特地为她写了一篇。</li>
<li>由于篇幅较长，陈某已经将此文章转换为PDF，公众号回复关键词<code>Mysql面试题</code>即可获取。</li>
</ul>
<h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><h3 id="什么是SQL？"><a href="#什么是SQL？" class="headerlink" title="什么是SQL？"></a>什么是SQL？</h3><ul>
<li>结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询语言。</li>
<li>作用：用于存取数据、查询、更新和管理关系数据库系统。</li>
</ul>
<h3 id="什么是MySQL"><a href="#什么是MySQL" class="headerlink" title="什么是MySQL?"></a>什么是MySQL?</h3><ul>
<li>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。</li>
</ul>
<h3 id="数据库三大范式是什么？"><a href="#数据库三大范式是什么？" class="headerlink" title="数据库三大范式是什么？"></a>数据库三大范式是什么？</h3><ul>
<li><code>第一范式</code>：每个列都不可以再拆分。</li>
<li><code>第二范式</code>：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</li>
<li><code>第三范式</code>：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</li>
<li>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</li>
</ul>
<h3 id="mysql有关权限的表都有哪几个？"><a href="#mysql有关权限的表都有哪几个？" class="headerlink" title="mysql有关权限的表都有哪几个？"></a>mysql有关权限的表都有哪几个？</h3><ul>
<li>MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：<ol>
<li><code>user权限表</code>：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</li>
<li><code>db权限表</code>：记录各个帐号在各个数据库上的操作权限。</li>
<li><code>table_priv权限表</code>：记录数据表级的操作权限。</li>
<li><code>columns_priv权限表</code>：记录数据列级的操作权限。</li>
<li><code>host权限表</code>：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</li>
</ol>
</li>
</ul>
<h3 id="MySQL的binlog有有几种录入格式？分别有什么区别？"><a href="#MySQL的binlog有有几种录入格式？分别有什么区别？" class="headerlink" title="MySQL的binlog有有几种录入格式？分别有什么区别？"></a>MySQL的binlog有有几种录入格式？分别有什么区别？</h3><ul>
<li>有三种格式，statement，row和mixed。<ul>
<li>statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</li>
<li>row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。</li>
<li>mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。</li>
</ul>
</li>
<li>此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。</li>
</ul>
<h3 id="mysql有哪些数据类型？"><a href="#mysql有哪些数据类型？" class="headerlink" title="mysql有哪些数据类型？"></a>mysql有哪些数据类型？</h3><ul>
<li>1、整数类型，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。<ul>
<li>长度：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。</li>
<li>例子：假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。</li>
</ul>
</li>
<li>2、实数类型，包括FLOAT、DOUBLE、DECIMAL。DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。</li>
<li>3、字符串类型，包括VARCHAR、CHAR、TEXT、BLOB<ul>
<li>VARCHAR用于存储可变长字符串，它比定长类型更节省空间。</li>
<li>VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。</li>
<li>VARCHAR存储的内容超出设置的长度时，内容会被截断。</li>
<li>CHAR是定长的，根据定义的字符串长度分配足够的空间。</li>
<li>CHAR会根据需要使用空格进行填充方便比较。</li>
<li>CHAR适合存储很短的字符串，或者所有值都接近同一个长度。</li>
<li>CHAR存储的内容超出设置的长度时，内容同样会被截断。</li>
</ul>
</li>
<li>4、枚举类型（ENUM），把不重复的数据存储为一个预定义的集合。<ul>
<li>有时可以使用ENUM代替常用的字符串类型。</li>
<li>ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。</li>
<li>ENUM在内部存储时，其实存的是整数。</li>
<li>尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。</li>
<li>排序是按照内部存储的整数</li>
</ul>
</li>
<li>5、日期和时间类型，尽量使用timestamp，空间效率高于datetime，<ul>
<li>用整数保存时间戳通常不方便处理。</li>
<li>如果需要存储微妙，可以使用bigint存储。</li>
<li>看到这里，这道真题是不是就比较容易回答了。</li>
</ul>
</li>
</ul>
<h3 id="MyISAM索引与InnoDB索引的区别？"><a href="#MyISAM索引与InnoDB索引的区别？" class="headerlink" title="MyISAM索引与InnoDB索引的区别？"></a>MyISAM索引与InnoDB索引的区别？</h3><ul>
<li>InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。</li>
<li>InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。</li>
<li>MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</li>
<li>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</li>
</ul>
<h3 id="InnoDB引擎的4大特性"><a href="#InnoDB引擎的4大特性" class="headerlink" title="InnoDB引擎的4大特性"></a>InnoDB引擎的4大特性</h3><ul>
<li>插入缓冲（insert buffer)</li>
<li>二次写(double write)</li>
<li>自适应哈希索引(ahi)</li>
<li>预读(read ahead)</li>
</ul>
<h3 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h3><ul>
<li>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</li>
<li>索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</li>
<li>更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。</li>
</ul>
<h3 id="索引有哪些优缺点？"><a href="#索引有哪些优缺点？" class="headerlink" title="索引有哪些优缺点？"></a>索引有哪些优缺点？</h3><ul>
<li>索引的优点： <ul>
<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li>
</ul>
</li>
<li>索引的缺点：<ul>
<li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；</li>
<li>空间方面：索引需要占物理空间。</li>
</ul>
</li>
</ul>
<h3 id="索引有哪几种类型？"><a href="#索引有哪几种类型？" class="headerlink" title="索引有哪几种类型？"></a>索引有哪几种类型？</h3><ul>
<li><code>主键索引</code>: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。</li>
<li><code>唯一索引</code>: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。<ul>
<li>可以通过 <code>ALTER TABLE table_name ADD UNIQUE (column);</code> 创建唯一索引</li>
<li>可以通过 <code>ALTER TABLE table_name ADD UNIQUE (column1,column2);</code> 创建唯一组合索引</li>
</ul>
</li>
<li><code>普通索引</code>: 基本的索引类型，没有唯一性的限制，允许为NULL值。<ul>
<li>可以通过<code>ALTER TABLE table_name ADD INDEX index_name (column);</code>创建普通索引</li>
<li>可以通过<code>ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);</code>创建组合索引。</li>
</ul>
</li>
<li><code>全文索引</code>： 是目前搜索引擎使用的一种关键技术。<ul>
<li>可以通过<code>ALTER TABLE table_name ADD FULLTEXT (column);</code>创建全文索引</li>
</ul>
</li>
</ul>
<h3 id="索引的数据结构（b树，hash）"><a href="#索引的数据结构（b树，hash）" class="headerlink" title="索引的数据结构（b树，hash）"></a>索引的数据结构（b树，hash）</h3><ul>
<li>索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有Hash索引，B+树索引等，而我们经常使用的InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</li>
</ul>
<p><strong>1. B树索引</strong></p>
<ul>
<li>mysql通过存储引擎取数据，基本上90%的人用的就是InnoDB了，按照实现方式分，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。B树索引是Mysql数据库中使用最频繁的索引类型，基本所有存储引擎都支持BTree索引。通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/1.jpg" alt="B树索引"></li>
</ul>
<p><strong>2. B+tree性质</strong></p>
<ul>
<li>n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</li>
<li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li>
<li>所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</li>
<li>B+ 树中，数据对象的插入和删除仅在叶节点上进行。</li>
<li>B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</li>
</ul>
<p><strong>3. 哈希索引</strong></p>
<ul>
<li>简要说下，类似于数据结构中简单实现的HASH表（散列表）一样，当我们在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。当然这只是简略模拟图。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/2.jpg" alt="哈希索引"></li>
</ul>
<h3 id="索引的基本原理"><a href="#索引的基本原理" class="headerlink" title="索引的基本原理"></a>索引的基本原理</h3><ul>
<li>索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</li>
<li>索引的原理很简单，就是把无序的数据变成有序的查询<ol>
<li>把创建了索引的列的内容进行排序</li>
<li>对排序结果生成倒排表</li>
<li>在倒排表内容上拼上数据地址链</li>
<li>在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</li>
</ol>
</li>
</ul>
<h3 id="索引算法有哪些？"><a href="#索引算法有哪些？" class="headerlink" title="索引算法有哪些？"></a>索引算法有哪些？</h3><ul>
<li>索引算法有 BTree算法和Hash算法</li>
</ul>
<p><strong>1. BTree算法</strong></p>
<ul>
<li>BTree是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,&gt;,&gt;=,&lt;,&lt;=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量。</li>
</ul>
<p><strong>2. Hash算法</strong></p>
<ul>
<li>Hash Hash索引只能用于对等比较，例如=,&lt;=&gt;（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。</li>
</ul>
<h3 id="索引设计的原则？"><a href="#索引设计的原则？" class="headerlink" title="索引设计的原则？"></a>索引设计的原则？</h3><ul>
<li>适合索引的列是出现在where子句中的列，或者连接子句中指定的列。</li>
<li>基数较小的类，索引效果较差，没有必要在此列建立索引</li>
<li>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</li>
<li>不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</li>
</ul>
<h3 id="创建索引的原则"><a href="#创建索引的原则" class="headerlink" title="创建索引的原则"></a>创建索引的原则</h3><ul>
<li>索引虽好，但也不是无限制的使用，最好符合一下几个原则<ul>
<li>最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li>
<li>较频繁作为查询条件的字段才去创建索引</li>
<li>更新频繁字段不适合创建索引</li>
<li>若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</li>
<li>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</li>
<li>定义有外键的数据列一定要建立索引。</li>
<li>对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</li>
<li>对于定义为text、image和bit的数据类型的列不要建立索引。</li>
</ul>
</li>
</ul>
<h3 id="创建索引时需要注意什么？"><a href="#创建索引时需要注意什么？" class="headerlink" title="创建索引时需要注意什么？"></a>创建索引时需要注意什么？</h3><ul>
<li>非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</li>
<li>取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</li>
<li>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</li>
</ul>
<h3 id="使用索引查询一定能提高查询的性能吗？"><a href="#使用索引查询一定能提高查询的性能吗？" class="headerlink" title="使用索引查询一定能提高查询的性能吗？"></a>使用索引查询一定能提高查询的性能吗？</h3><ul>
<li>通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。</li>
<li>索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:</li>
<li>基于一个范围的检索，一般查询返回结果集小于表中记录数的30%</li>
<li>基于非唯一性索引的检索</li>
</ul>
<h3 id="百万级别或以上的数据如何删除？"><a href="#百万级别或以上的数据如何删除？" class="headerlink" title="百万级别或以上的数据如何删除？"></a>百万级别或以上的数据如何删除？</h3><ul>
<li>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。<ol>
<li>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li>
<li>然后删除其中无用数据（此过程需要不到两分钟）</li>
<li>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li>
<li>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li>
</ol>
</li>
</ul>
<h3 id="什么是最左前缀原则？什么是最左匹配原则？"><a href="#什么是最左前缀原则？什么是最左匹配原则？" class="headerlink" title="什么是最左前缀原则？什么是最左匹配原则？"></a>什么是最左前缀原则？什么是最左匹配原则？</h3><ul>
<li>顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</li>
<li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li>
<li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li>
</ul>
<h3 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h3><ul>
<li>在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。</li>
<li>B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/3.jpg" alt="B树和B+树的区别"></li>
</ul>
<h3 id="使用B树的好处"><a href="#使用B树的好处" class="headerlink" title="使用B树的好处"></a>使用B树的好处</h3><ul>
<li>B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</li>
</ul>
<h3 id="使用B-树的好处"><a href="#使用B-树的好处" class="headerlink" title="使用B+树的好处"></a>使用B+树的好处</h3><ul>
<li>由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。 B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间</li>
</ul>
<h3 id="什么是聚簇索引？何时使用聚簇索引与非聚簇索引？"><a href="#什么是聚簇索引？何时使用聚簇索引与非聚簇索引？" class="headerlink" title="什么是聚簇索引？何时使用聚簇索引与非聚簇索引？"></a>什么是聚簇索引？何时使用聚簇索引与非聚簇索引？</h3><ul>
<li>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</li>
<li>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因。</li>
</ul>
<h3 id="非聚簇索引一定会回表查询吗？"><a href="#非聚簇索引一定会回表查询吗？" class="headerlink" title="非聚簇索引一定会回表查询吗？"></a>非聚簇索引一定会回表查询吗？</h3><ul>
<li>不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。</li>
<li>举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行select age from employee where age &lt; 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。</li>
</ul>
<h3 id="联合索引是什么？为什么需要注意联合索引中的顺序？"><a href="#联合索引是什么？为什么需要注意联合索引中的顺序？" class="headerlink" title="联合索引是什么？为什么需要注意联合索引中的顺序？"></a>联合索引是什么？为什么需要注意联合索引中的顺序？</h3><ul>
<li>MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</li>
<li>MySQL使用索引时需要索引有序，假设现在建立了”name，age，school”的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。</li>
<li>当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</li>
</ul>
<h3 id="什么是数据库事务？"><a href="#什么是数据库事务？" class="headerlink" title="什么是数据库事务？"></a>什么是数据库事务？</h3><ul>
<li>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</li>
</ul>
<h3 id="事物的四大特性-ACID-介绍一下"><a href="#事物的四大特性-ACID-介绍一下" class="headerlink" title="事物的四大特性(ACID)介绍一下?"></a>事物的四大特性(ACID)介绍一下?</h3><ul>
<li><code>原子性</code>： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><code>一致性</code>： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
<li><code>隔离性</code>： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><code>持久性</code>： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ul>
<h3 id="什么是脏读？幻读？不可重复读？"><a href="#什么是脏读？幻读？不可重复读？" class="headerlink" title="什么是脏读？幻读？不可重复读？"></a>什么是脏读？幻读？不可重复读？</h3><ul>
<li><code>脏读</code>(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</li>
<li><code>不可重复读</code>(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</li>
<li><code>幻读</code>(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</li>
</ul>
<h3 id="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"><a href="#什么是事务的隔离级别？MySQL的默认隔离级别是什么？" class="headerlink" title="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"></a>什么是事务的隔离级别？MySQL的默认隔离级别是什么？</h3><ul>
<li>为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</li>
<li>SQL 标准定义了四个隔离级别：<ul>
<li><code>READ-UNCOMMITTED</code>(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
<li><code>READ-COMMITTED</code>(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>
<li><code>REPEATABLE-READ</code>(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li><code>SERIALIZABLE</code>(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li>
</ul>
</li>
<li><strong>Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别</strong></li>
</ul>
<h3 id="隔离级别与锁的关系"><a href="#隔离级别与锁的关系" class="headerlink" title="隔离级别与锁的关系"></a>隔离级别与锁的关系</h3><ul>
<li>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</li>
<li>在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</li>
<li>在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</li>
<li>SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。</li>
</ul>
<h3 id="按照锁的粒度分数据库锁有哪些？"><a href="#按照锁的粒度分数据库锁有哪些？" class="headerlink" title="按照锁的粒度分数据库锁有哪些？"></a>按照锁的粒度分数据库锁有哪些？</h3><ul>
<li><code>行级锁</code>:行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li>
<li><code>表级锁</code>: 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</li>
<li><code>页级锁</code>:页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</li>
</ul>
<h3 id="从锁的类别上分MySQL都有哪些锁呢？"><a href="#从锁的类别上分MySQL都有哪些锁呢？" class="headerlink" title="从锁的类别上分MySQL都有哪些锁呢？"></a>从锁的类别上分MySQL都有哪些锁呢？</h3><ul>
<li>从锁的类别上来讲，有共享锁和排他锁。<ul>
<li>共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</li>
<li>排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</li>
</ul>
</li>
</ul>
<h3 id="InnoDB存储引擎的锁的算法有哪三种？"><a href="#InnoDB存储引擎的锁的算法有哪三种？" class="headerlink" title="InnoDB存储引擎的锁的算法有哪三种？"></a>InnoDB存储引擎的锁的算法有哪三种？</h3><ul>
<li>Record lock：单个行记录上的锁</li>
<li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li>
<li>Next-key lock：record+gap 锁定一个范围，包含记录本身</li>
</ul>
<h3 id="什么是死锁？怎么解决？"><a href="#什么是死锁？怎么解决？" class="headerlink" title="什么是死锁？怎么解决？"></a>什么是死锁？怎么解决？</h3><ul>
<li>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</li>
<li>常见的解决死锁的方法<ol>
<li>如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</li>
<li>在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</li>
<li>对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</li>
</ol>
</li>
<li>如果业务处理不好可以用分布式事务锁或者使用乐观锁</li>
</ul>
<h3 id="数据库的乐观锁和悲观锁是什么？怎么实现的？"><a href="#数据库的乐观锁和悲观锁是什么？怎么实现的？" class="headerlink" title="数据库的乐观锁和悲观锁是什么？怎么实现的？"></a>数据库的乐观锁和悲观锁是什么？怎么实现的？</h3><ul>
<li>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</li>
<li><code>悲观锁</code>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</li>
<li><code>乐观锁</code>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。</li>
</ul>
<h3 id="大表数据查询，怎么优化？"><a href="#大表数据查询，怎么优化？" class="headerlink" title="大表数据查询，怎么优化？"></a>大表数据查询，怎么优化？</h3><ul>
<li>优化shema、sql语句+索引；</li>
<li>第二加缓存，memcached, redis；</li>
<li>主从复制，读写分离；</li>
<li>垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统</li>
<li>水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表</li>
</ul>
<h3 id="超大分页怎么处理？"><a href="#超大分页怎么处理？" class="headerlink" title="超大分页怎么处理？"></a>超大分页怎么处理？</h3><ul>
<li>超大的分页一般从两个方向上来解决:<ul>
<li>数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于select <em> from table where age &gt; 20 limit 1000000,10这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为select </em> from table where id in (select id from table where age &gt; 20 limit 1000000,10).这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以select * from table where id &gt; 1000000 limit 10,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据</li>
<li>从需求的角度减少这种请求…主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击</li>
</ul>
</li>
</ul>
<h3 id="为什么要尽量设定一个主键？"><a href="#为什么要尽量设定一个主键？" class="headerlink" title="为什么要尽量设定一个主键？"></a>为什么要尽量设定一个主键？</h3><ul>
<li>主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。</li>
</ul>
<h3 id="主键使用自增ID还是UUID？"><a href="#主键使用自增ID还是UUID？" class="headerlink" title="主键使用自增ID还是UUID？"></a>主键使用自增ID还是UUID？</h3><ul>
<li>推荐使用自增ID，不要使用UUID。</li>
<li>因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。</li>
<li>总之，在数据量大一些的情况下，用自增主键性能会好一些。</li>
<li>关于主键是聚簇索引，如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。</li>
</ul>
<h3 id="字段为什么要求定义为not-null？"><a href="#字段为什么要求定义为not-null？" class="headerlink" title="字段为什么要求定义为not null？"></a>字段为什么要求定义为not null？</h3><ul>
<li>null值会占用更多的字节，且会在程序中造成很多与预期不符的情况。</li>
</ul>
<h3 id="如果要存储用户的密码散列，应该使用什么字段进行存储？"><a href="#如果要存储用户的密码散列，应该使用什么字段进行存储？" class="headerlink" title="如果要存储用户的密码散列，应该使用什么字段进行存储？"></a>如果要存储用户的密码散列，应该使用什么字段进行存储？</h3><ul>
<li>密码散列，盐，用户身份证号等固定长度的字符串应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。</li>
</ul>
<h3 id="数据库结构优化？"><a href="#数据库结构优化？" class="headerlink" title="数据库结构优化？"></a>数据库结构优化？</h3><ul>
<li>一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。</li>
<li>需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</li>
<li><strong>将字段很多的表分解成多个表</strong>：对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</li>
<li><strong>增加中间表</strong>：对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。</li>
<li><strong>增加冗余字段</strong>：设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。</li>
</ul>
<h3 id="MySQL数据库cpu飙升到500-的话他怎么处理？"><a href="#MySQL数据库cpu飙升到500-的话他怎么处理？" class="headerlink" title="MySQL数据库cpu飙升到500%的话他怎么处理？"></a>MySQL数据库cpu飙升到500%的话他怎么处理？</h3><ul>
<li>当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。</li>
<li>如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。</li>
<li>一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。</li>
<li>也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等。</li>
</ul>
<h3 id="主从复制的作用？"><a href="#主从复制的作用？" class="headerlink" title="主从复制的作用？"></a>主从复制的作用？</h3><ul>
<li>主数据库出现问题，可以切换到从数据库。</li>
<li>可以进行数据库层面的读写分离。</li>
<li>可以在从数据库上进行日常备份。</li>
</ul>
<h3 id="MySQL主从复制解决的问题？"><a href="#MySQL主从复制解决的问题？" class="headerlink" title="MySQL主从复制解决的问题？"></a>MySQL主从复制解决的问题？</h3><ul>
<li>数据分布：随意开始或停止复制，并在不同地理位置分布数据备份</li>
<li>负载均衡：降低单个服务器的压力</li>
<li>高可用和故障切换：帮助应用程序避免单点失败</li>
<li>升级测试：可以用更高版本的MySQL作为从库</li>
</ul>
<h3 id="MySQL主从复制工作原理？"><a href="#MySQL主从复制工作原理？" class="headerlink" title="MySQL主从复制工作原理？"></a>MySQL主从复制工作原理？</h3><ul>
<li>在主库上把数据更高记录到二进制日志</li>
<li>从库将主库的日志复制到自己的中继日志</li>
<li>从库读取中继日志的事件，将其重放到从库数据中。</li>
</ul>
<h2 id="小福利"><a href="#小福利" class="headerlink" title="小福利"></a>小福利</h2><ul>
<li>由于文章篇幅较长，陈某将其转换为PDF文档，老规矩，回复关键词<code>Mysql面试题</code>即可获取。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/4.png" alt=""></li>
</ul>
<h2 id="巨人的肩膀"><a href="#巨人的肩膀" class="headerlink" title="巨人的肩膀"></a>巨人的肩膀</h2><ul>
<li><a href="https://www.cnblogs.com/hsmwlyl/p/10719152.html" target="_blank" rel="external">https://www.cnblogs.com/hsmwlyl/p/10719152.html</a></li>
<li><a href="https://www.cnblogs.com/caomusheng/p/12586895.html" target="_blank" rel="external">https://www.cnblogs.com/caomusheng/p/12586895.html</a></li>
<li><a href="https://article.itxueyuan.com/eoJEMj" target="_blank" rel="external">https://article.itxueyuan.com/eoJEMj</a></li>
<li><a href="https://blog.csdn.net/thinkwon/article/details/104778621#comments" target="_blank" rel="external">https://blog.csdn.net/thinkwon/article/details/104778621#comments</a></li>
</ul>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>Navicat Premium 12破解版安装</title>
    <url>/2020/08/27/Navicat%20Premium%2012%E5%85%8D%E8%B4%B9%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>这几年的工作过程中使用了很多的数据库工具，比如Sqlyog，DBeaver,sqlplus等工具，但是个人觉得很好用的还是Navicat。</li>
<li>不如人意的就是目前Navicat都在收费，今天就来分享下如何安装免费的Navicat。</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-Log-plugin/6.jpg" alt=""><a id="more"></a>
</li>
</ul>
<h2 id="免费版本安装"><a href="#免费版本安装" class="headerlink" title="免费版本安装"></a>免费版本安装</h2><ol>
<li>首先去官网下载Navicat_12的安装包，根据自己电脑的配置下载合适的。</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/navicat12/1.png" alt=""></p>
<ol>
<li>下载成功之后，直接<code>安装</code>，<code>启动</code>即可</li>
<li>启动时选择<code>试用</code>版本。</li>
<li>打开<strong>神秘的包包</strong>，找到匹配的，如下：</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/navicat12/2.png" alt=""></p>
<ol>
<li>将其中的文件全部复制到<code>Navicat_12</code>的根目录，文件如下：</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/navicat12/3.png" alt=""></p>
<ol>
<li>重新启动Navicat，出现以下界面，表示安装成功，如下：</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/navicat12/4.png" alt=""></p>
<h2 id="如何连接Oracle"><a href="#如何连接Oracle" class="headerlink" title="如何连接Oracle"></a>如何连接Oracle</h2><ul>
<li>如果本地未安装过Oracle数据库，新安装的Navicat默认是连接不上oracle的，需要配置一下<code>oci.dll</code>。</li>
<li>选择<code>工具</code>-&gt;<code>选项</code></li>
<li><img src="https://images2018.cnblogs.com/blog/1023171/201808/1023171-20180819144807854-2077107245.png" alt=""></li>
<li>指定<code>oci.dll</code>的路径，如下：</li>
<li><img src="https://images2018.cnblogs.com/blog/1023171/201808/1023171-20180819144833188-1560669113.png" alt=""></li>
<li>重新启动，即可连接。</li>
<li><strong>注意</strong>：Navicat_12自带的oci.dll如果版本不合适，可以去官网下载对应的版本。</li>
</ul>
<h2 id="如何连接Sql-server"><a href="#如何连接Sql-server" class="headerlink" title="如何连接Sql server"></a>如何连接Sql server</h2><ul>
<li>如果本地未安装过SQL Server数据库，Navicat是不能连接上数据库的，具体解决方案如下：</li>
<li>在Navicat的根目录下找到<code>sqlncli_x64.msi</code>双击安装即可，当然如果版本不合适，可以自己去官网下载。</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/navicat12/5.png" alt=""></li>
<li>安装成功后，重启启动，即可连接。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>安装免费版的Navicat很简单，只需要一个神秘的包包，哈哈。</li>
<li>老规矩，关注公众号【码猿技术专栏】回复关键词<code>Navicat12</code>即可获取。</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E4%B8%83%E7%A7%92%E7%BC%96%E7%A8%8B.jpg" alt=""></li>
</ul>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot整合多点套路，少走点弯路！！！</title>
    <url>/2020/10/15/Spring%20Boot%20%E7%AC%AC%20%E5%8D%81%E4%BA%8C%E5%BC%B9%EF%BC%8CSpring%20Boot%E6%95%B4%E5%90%88%E5%A4%9A%E7%82%B9%E5%A5%97%E8%B7%AF%EF%BC%8C%E5%B0%91%E8%B5%B0%E7%82%B9%E5%BC%AF%E8%B7%AF%EF%BC%81%EF%BC%81%EF%BC%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>网上有很多文章都在说<code>Spring Boot 如何整合 xxx</code>，有文章教你为什么这么整合吗？整合了千万个框架，其实套路就那么几个，干嘛要学千万个，不如来这学习几个套路轻松整合，它不香吗？？？</p>
<p>今天写这篇文章的目的就是想从思想上教给大家几个套路，不用提到整合什么就去百度了，自己尝试去亲手整合一个。</p>
<a id="more"></a>
<h2 id="Spring-Boot-版本"><a href="#Spring-Boot-版本" class="headerlink" title="Spring Boot 版本"></a>Spring Boot 版本</h2><p>本文基于的Spring Boot的版本是<code>2.3.4.RELEASE</code>。</p>
<h2 id="1-找到自动配置类"><a href="#1-找到自动配置类" class="headerlink" title="1. 找到自动配置类"></a>1. 找到自动配置类</h2><p>Spring Boot 在整合任何一个组件的时候都会先添加一个依赖<code>starter</code>，比如整合的Mybatis有一个<code>mybatis-spring-boot-starter</code>，依赖如下：<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>每一个<code>starter</code>基本都会有一个自动配置类，命名方式也是类似的，格式为：<code>xxxAutoConfiguration</code>，比如Mybatis的自动配置类就是<code>MybatisAutoConfiguration</code>，<code>Redis</code>的自动配置类是<code>RedisAutoConfiguration</code>，<code>WEB</code>模块的自动配置类是<code>WebMvcAutoConfiguration</code>。</p>
<h2 id="2-注意-Conditionalxxx注解"><a href="#2-注意-Conditionalxxx注解" class="headerlink" title="2. 注意@Conditionalxxx注解"></a>2. 注意@Conditionalxxx注解</h2><p><code>@Conditionalxxx</code>标注在配置类上或者结合<code>@Bean</code>标注在方法上，究竟是什么意思，在上一篇文章<a href="https://mp.weixin.qq.com/s/BoujdCIHPK79jT9RKAmyug" target="_blank" rel="external">这类注解都不知道，还好意思说会Spring Boot</a>已经从表层到底层深入的讲了一遍，不理解的可以查阅一下。</p>
<blockquote>
<p>首先需要注意自动配置类上的<code>@Conditionalxxx</code>注解，这个是自动配置类生效的条件。</p>
</blockquote>
<p>比如<code>WebMvcAutoConfiguration</code>类上标了一个如下注解：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@ConditionalOnMissingBean</span>(WebMvcConfigurationSupport.class)</div></pre></td></tr></table></figure></p>
<p>以上这行代码的意思就是当前IOC容器中没有<code>WebMvcConfigurationSupport</code>这个类的实例时自动配置类才会生效，这也就是在配置类上标注<code>@EnableWebMvc</code>会导致自动配置类<code>WebMvcAutoConfiguration</code>失效的原因。</p>
<blockquote>
<p>其次需要注意方法上的<code>@Conditionalxxx</code>注解，Spring Boot会在自动配置类中结合<code>@Bean</code>和<code>@Conditionalxxx</code>注解提供一些组件运行的默认配置，但是利用<code>@Conditionalxxx</code>（在特定条件下生效）注解的<code>条件性</code>，方便开发者覆盖这些配置。</p>
</blockquote>
<p>比如在Mybatis的自动配置类<code>MybatisAutoConfiguration</code>中有如下一个方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="meta">@ConditionalOnMissingBean</span></div><div class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>以上这个方法不用看方法体的内容，只看方法上的注解。<code>@Bean</code>这个注解的意思是注入一个<code>Bean</code>到<code>IOC容器</code>中，<code>@ConditionalOnMissingBean</code>这个注解就是一个条件判断了，表示当<code>SqlSessionFactory</code>类型的对象在<code>IOC容器</code>中不存在才会注入。</p>
<p>哦？领悟到了吧，<strong>言外之意就是如果开发者需要定制<code>SqlSessionFactory</code>，则可以自己的创建一个<code>SqlSessionFactory</code>类型的对象并且注入到IOC容器中即能覆盖自动配置类中的</strong>。比如在Mybatis配置多数据源的时候就需要定制一个<code>SqlSessionFactory</code>而不是使用自动配置类中的。</p>
<blockquote>
<p>总之，一定要注意自动配置类上或者方法上的<code>@Conditionalxxx</code>注解，这个注解表示某种特定条件。</p>
</blockquote>
<p>下面列出了常用的几种注解，如下：</p>
<ol>
<li><code>@ConditionalOnBean</code>：当容器中有指定Bean的条件下进行实例化。</li>
<li><code>@ConditionalOnMissingBean</code>：当容器里没有指定Bean的条件下进行实例化。</li>
<li><code>@ConditionalOnClass</code>：当classpath类路径下有指定类的条件下进行实例化。</li>
<li><code>@ConditionalOnMissingClass</code>：当类路径下没有指定类的条件下进行实例化。</li>
<li><code>@ConditionalOnWebApplication</code>：当项目是一个Web项目时进行实例化。</li>
<li><code>@ConditionalOnNotWebApplication</code>：当项目不是一个Web项目时进行实例化。</li>
<li><code>@ConditionalOnProperty</code>：当指定的属性有指定的值时进行实例化。</li>
<li><code>@ConditionalOnExpression</code>：基于SpEL表达式的条件判断。</li>
<li><code>@ConditionalOnJava</code>：当JVM版本为指定的版本范围时触发实例化。</li>
<li><code>@ConditionalOnResource</code>：当类路径下有指定的资源时触发实例化。</li>
<li><code>@ConditionalOnJndi</code>：在JNDI存在的条件下触发实例化。</li>
<li><code>@ConditionalOnSingleCandidate</code>：当指定的Bean在容器中只有一个，或者有多个但是指定了首选的Bean时触发实例化。</li>
</ol>
<h2 id="3-注意EnableConfigurationProperties注解"><a href="#3-注意EnableConfigurationProperties注解" class="headerlink" title="3. 注意EnableConfigurationProperties注解"></a>3. 注意EnableConfigurationProperties注解</h2><p><code>EnableConfigurationProperties</code>这个注解常标注在配置类上，使得<code>@ConfigurationProperties</code>标注的配置文件生效，这样就可以在全局配置文件（<code>application.xxx</code>）配置指定前缀的属性了。</p>
<p>在Redis的自动配置类<code>RedisAutoConfiguration</code>上方标注如下一行代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@EnableConfigurationProperties</span>(RedisProperties.class)</div></pre></td></tr></table></figure></p>
<p>这行代码有意思了，我们可以看看<code>RedisProperties</code>的源码，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.redis"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisProperties</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> database = <span class="number">0</span>;</div><div class="line">	<span class="keyword">private</span> String url;</div><div class="line">	<span class="keyword">private</span> String host = <span class="string">"localhost"</span>;</div><div class="line">	<span class="keyword">private</span> String password;</div><div class="line">  .....</div></pre></td></tr></table></figure></p>
<p><code>@ConfigurationProperties</code>这个注解指定了全局配置文件中以<code>spring.redis.xxx</code>为前缀的配置都会映射到<code>RedisProperties</code>的指定属性中，其实<code>RedisProperties</code>这个类中定义了Redis的一些所需属性，比如<code>host</code>，<code>IP地址</code>，<code>密码</code>等等。</p>
<p><strong><code>@EnableConfigurationProperties</code>注解就是使得指定的配置生效，能够将全局配置文件中配置的属性映射到相关类的属性中。</strong></p>
<p><strong>为什么要注意<code>@EnableConfigurationProperties</code>这个注解呢？</strong></p>
<blockquote>
<p>引入一个组件后往往需要改些配置，我们都知道在全局配置文件中可以修改，但是不知道前缀是什么，可以改哪些属性，因此找到<code>@EnableConfigurationProperties</code>这个注解后就能找到对应的配置前缀以及可以修改的属性了。</p>
</blockquote>
<h2 id="4-注意-Import注解"><a href="#4-注意-Import注解" class="headerlink" title="4. 注意@Import注解"></a>4. 注意@Import注解</h2><p>这个注解有点牛逼了，<code>Spring 3.x</code>中就已经有的一个注解，大致的意思的就是快速导入一个Bean或者配置类到IOC容器中。这个注解有很多妙用，后续会单独写篇文章介绍下。</p>
<blockquote>
<p><code>@Import</code>这个注解通常标注在自动配置类上方，并且一般都是导入一个或者多个配置类。</p>
</blockquote>
<p>比如<code>RabbitMQ</code>的自动配置类<code>RabbitAutoConfiguration</code>上有如下一行代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Import</span>(RabbitAnnotationDrivenConfiguration.class)</div></pre></td></tr></table></figure></p>
<p>这行代码的作用就是添加了<code>RabbitAnnotationDrivenConfiguration</code>这个配置类，使得Spring Boot在加载到自动配置类的时候能够一起加载。</p>
<p>比如Redis的自动配置类<code>RedisAutoConfiguration</code>上有如下一行代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Import</span>(&#123; LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class &#125;)</div></pre></td></tr></table></figure></p>
<p>这个<code>@Import</code>同时引入了<code>Lettuce</code>和<code>Jedis</code>两个配置类了，因此如果你的Redis需要使用Jedis作为连接池的话，想要知道Jedis都要配置什么，此时就应该看看<code>JedisConnectionConfiguration</code>这个配置类了。</p>
<blockquote>
<p><strong>总结</strong>：<code>@Import</code>标注在自动配置类上方，一般都是快速导入一个或者多个配置类，因此如果自动配置类没有配置一些东西时，一定要看看<code>@Import</code>这个注解导入的配置类。</p>
</blockquote>
<h2 id="5-注意-AutoConfigurexxx注解"><a href="#5-注意-AutoConfigurexxx注解" class="headerlink" title="5. 注意@AutoConfigurexxx注解"></a>5. 注意@AutoConfigurexxx注解</h2><p><code>@AutoConfigurexxx</code>这类注解决定了自动配置类的加载顺序，比如<code>AutoConfigureAfter</code>（在指定自动配置类之后）、<code>AutoConfigureBefore</code>（在指定自动配置类之前）、<code>AutoConfigureOrder</code>（指定自动配置类的优先级）。</p>
<blockquote>
<p>为什么要注意顺序呢？因为某些组件往往之间是相互依赖的，比如<code>Mybatis</code>和<code>DataSource</code>，肯定要先将数据源相关的东西配置成功才能配置<code>Mybatis</code>吧。<code>@AutoConfigurexxx</code>这类注解正是解决了组件之间相互依赖的问题。</p>
</blockquote>
<p>比如<code>MybatisAutoConfiguration</code>上方标注了如下一行代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@AutoConfigureAfter</span>(DataSourceAutoConfiguration.class)</div></pre></td></tr></table></figure></p>
<p>这个行代码意思很简单，就是<code>MybatisAutoConfiguration</code>这个自动配置在<code>DataSourceAutoConfiguration</code>这个之后加载，因为你需要我，多么简单的理由。</p>
<p>好了，这下明白了吧，以后别犯傻问：<strong>为什么Mybatis配置好了，启动会报错</strong>？这个问题先看看数据源有没有配置成功吧。</p>
<h2 id="6-注意内部静态配置类"><a href="#6-注意内部静态配置类" class="headerlink" title="6. 注意内部静态配置类"></a>6. 注意内部静态配置类</h2><p>有些自动配置类比较简单没那么多套路，比如<code>RedisAutoConfiguration</code>这个自动配置类中就定义了两个注入Bean的方法，其他的没了。</p>
<p>但是有些自动配置类就没那么单纯了，中间能嵌套<code>n</code>个静态配置类，比如<code>WebMvcAutoConfiguration</code>，类中还嵌套了<code>WebMvcAutoConfigurationAdapter</code>、<code>EnableWebMvcConfiguration</code>、<code>ResourceChainCustomizerConfiguration</code>这三个配置类。如果你光看<code>WebMvcAutoConfiguration</code>这个自动配置类好像没配置什么，但是其内部却是大有乾坤啊。</p>
<blockquote>
<p><strong>总结</strong>：一定要自动配置类的内部嵌套的配置类，真是大有乾坤啊。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上总结了六条整合的套路，希望能够帮助读者摆脱百度，自己也能独立整合组件。</p>
<p>总之，Spring Boot整合xxx组件的文章很多，相信大家也看的比较懵，其实套路都是一样，学会陈某分享的套路，让你少走弯路！！！</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png" alt=""></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 第一弹，问候一下世界！！！</title>
    <url>/2020/10/14/Spring%20Boot%20%E7%AC%AC%E4%B8%80%E5%BC%B9%EF%BC%8C%E9%97%AE%E5%80%99%E4%B8%80%E4%B8%8B%E4%B8%96%E7%95%8C%EF%BC%81%EF%BC%81%EF%BC%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相信从事Java开发的朋友都听说过<code>SSM</code>框架，这还算年轻的，老点的甚至经历过<code>SSH</code>，说起来有点恐怖，哈哈。比如我就是经历过<code>SSH</code>那个时代末流，没办法，很无奈。</p>
<p>当然无论是SSM还是SSH都不是今天的重点，今天要说的是<code>Spring Boot</code>，一个令人眼前一亮的框架，从大的说，Spring Boot取代了<code>SSM</code> 中的<code>SS</code>的角色。</p>
<p>今天这篇文章就来谈谈Spring Boot，这个我第一次使用直呼<code>爽</code>的框架。<br><a id="more"></a></p>
<h2 id="什么是Spring-Boot？"><a href="#什么是Spring-Boot？" class="headerlink" title="什么是Spring Boot？"></a>什么是Spring Boot？</h2><p><code>Spring Boot</code> 是由 Pivotal 团队提供的全新框架。<code>Spring Boot</code> 是所有基于 <code>Spring Framework 5.0</code> 开发的项目的起点。<code>Spring Boot</code> 的设计是为了让你尽可能快的跑起来<code>Spring</code> 应用程序并且尽可能减少你的配置文件。</p>
<p><strong>Spring Boot 的设计目的简单一句话：简化Spring应用的初始搭建以及开发过程。</strong></p>
<p>从最根本上来讲，Spring Boot 就是一些库的集合，它能够被任意项目的构建系统所使用。它使用 “<strong>约定大于配置</strong>” （项目中存在大量的配置，此外还内置一个习惯性的配置）的理念让你的项目快速运行起来。</p>
<p><strong>约定大于配置</strong>这个如何理解？其实简单的来说就是Spring Boot在搭建之初就内置了许多实际开发中的常用配置，只有少部分的配置需要开发人员自己去配置。</p>
<h2 id="如何搭建一个Spring-Boot项目？"><a href="#如何搭建一个Spring-Boot项目？" class="headerlink" title="如何搭建一个Spring Boot项目？"></a>如何搭建一个Spring Boot项目？</h2><p>其实搭建一个SpringBoot项目有很多种方式，最常见的两种方式如下：</p>
<pre><code>1. 创建Maven项目，自己引入依赖，创建启动类和配置文件。
2. 直接IDEA中的` Spring Initializr`创建项目。
</code></pre><p><strong>第一种方式不适合入门的朋友玩，今天演示第二种方式搭建一个Spring Boot项目。</strong></p>
<p>第一步在IDEA中选择<code>File--&gt;NEW--&gt;Project</code>，选择<code>Spring Initializr</code>，指定<code>JDK</code>版本<code>1.8</code>，然后<code>Next</code>。如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/SpringBoot%E7%AC%AC%E4%B8%80%E5%BC%B9/1.png" alt=""></p>
<p>第二步指定Maven坐标、包名、JDK版等信息，然后<code>Next</code>，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/SpringBoot%E7%AC%AC%E4%B8%80%E5%BC%B9/2.png" alt=""></p>
<p>第三步选择自己所需要的依赖、Spring Boot的版本，Spring Boot与各个框架适配都是以<code>starter</code>方式，这里我们选择WEB开发的所需的<code>starter</code>即可，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/SpringBoot%E7%AC%AC%E4%B8%80%E5%BC%B9/3.png" alt=""></p>
<p>第四步指定项目的名称，路径即可完成，点击<code>Finish</code>等待创建成功，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/SpringBoot%E7%AC%AC%E4%B8%80%E5%BC%B9/4.png" alt=""></p>
<p>创建成功的项目如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/SpringBoot%E7%AC%AC%E4%B8%80%E5%BC%B9/5.png" alt="5"></p>
<p>其中的<code>DemoApplication</code>是项目的启动类，里面有一个<code>main()</code>方法就是用来启动Spring Boot。<code>application.properties</code>是Spring Boot的配置文件。</p>
<p>此时可以启动项目，在<code>DemoApplication</code>运行<code>main</code>方法即可启动，启动成功如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/SpringBoot%E7%AC%AC%E4%B8%80%E5%BC%B9/6.png" alt=""></p>
<p>由于SpringBoot默认内置了Tomcat，因此启动的默认端口就是<code>8080</code>。</p>
<h2 id="第一个程序-Hello-World"><a href="#第一个程序-Hello-World" class="headerlink" title="第一个程序 Hello World"></a>第一个程序 Hello World</h2><p>学习任何一种技术总是要问候一下世界，哈哈……….</p>
<p>既然是WEB开发，就写个接口吧，前面创建的时候已经引用了<code>WEB</code>的<code>starter</code>，如果没有引用，则可以在<code>pom.xml</code>引入以下依赖：<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>
<ul>
<li>下面写一个<code>HelloWorldController</code>如下：<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> com.example.demo.controller;</div><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldController</span> </span>&#123;</div><div class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloWorld</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hello World"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><code>@RestController</code>：标记这是一个<code>controller</code>，是<code>@Controller</code>和<br><code>@ResponseBody</code>这两个注解的集合。</p>
<p><code>@RequestMapping</code>：指定一个映射</p>
<p><strong>以上两个注解都是Spring中的，这里就不再细说了。</strong></p>
<p>由于内置的Tomcat默认端口是<code>8080</code>，所以启动项目，访问<code>http://127.0.0.1:8080/hello</code>即可。</p>
<h2 id="依赖解读"><a href="#依赖解读" class="headerlink" title="依赖解读"></a>依赖解读</h2><p>Spring Boot项目中的<code>pom.xml</code>中有这么一个依赖，如下：<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><code>&lt;parent&gt;</code>这个标签都知道什么意思，<code>父亲</code>是吧，这么个标签主要的作用就是用于版本控制。这也就是引入的<code>WEB</code>模块<code>starter</code>的时候不用指定版本号<code>&lt;version&gt;</code>标签的原因，因为在<code>spring-boot-starter-parent</code>中已经指定了，类似于一种继承的关系，父亲已经为你提供了，你只需要选择用不用就行。</p>
<p><strong>为什么引入<code>spring-boot-starter-web</code>就能使用<code>Spring mvc</code>的功能呢？</strong></p>
<p>这确实是个难以理解的问题，为了理解这个问题，我们不妨看一下<code>spring-boot-starter-web</code>这个启动器都依赖了什么？如下：<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>看到这应该明白了吧，<code>spring-boot-starter-web</code>这个<code>starter</code>中其实内部引入了<code>Spring</code>、<code>springmvc</code>、<code>tomcat</code>的相关依赖，当然能够直接使用Spring MVC相关的功能了。</p>
<h2 id="什么是配置文件？"><a href="#什么是配置文件？" class="headerlink" title="什么是配置文件？"></a>什么是配置文件？</h2><p>前面说过<code>application.properties</code>是Spring Boot的配置文件，那么这个配置文件究竟是配置什么的呢？</p>
<p>其实Spring Boot为了能够适配每一个组件，都会提供一个<code>starter</code>，但是这些启动器的一些信息不能在内部写死啊，比如数据库的用户名、密码等，肯定要由开发人员指定啊，于是就统一写在了一个<code>Properties</code>类中，在Spring Boot启动的时候根据<code>前缀名+属性名称</code>从配置文件中读取，比如<code>WebMvcProperties</code>，其中定义了一些Spring Mvc相关的配置，前缀是<code>spring.mvc</code>。如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.mvc"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcProperties</span> </span>&#123;</div></pre></td></tr></table></figure></p>
<p>那么我们需要修改Spring Mvc相关的配置，只需要在<code>application.properties</code>文件中指定<code>spring.mvc.xxxx=xxxx</code>即可。</p>
<p><strong>其实配置文件这块还是有许多道道儿的，后面文章会详细介绍。</strong></p>
<h2 id="什么是启动类？"><a href="#什么是启动类？" class="headerlink" title="什么是启动类？"></a>什么是启动类？</h2><p>前面说过启动类是<code>DemoApplication</code>，源码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        SpringApplication.run(DemoApplication.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>@SpringBootApplication</code>是什么？其实一眼看上去，这个类在平常不过了，唯一显眼的就是<code>@SpringBootApplication</code>这个注解了，当然主要的作用还真是它。这个注解的源码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Inherited</span></div><div class="line"><span class="meta">@SpringBootConfiguration</span></div><div class="line"><span class="meta">@EnableAutoConfiguration</span></div><div class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123; <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</div><div class="line">		<span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;&#125;</div></pre></td></tr></table></figure></p>
<p>我滴乖乖儿，注解叠加啊，完全是由<code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code>这三个注解叠加而来。</p>
<p><strong><code>ComponentScan</code></strong>：这个注解并不陌生，Spring中的注解，包扫描的注解，这个注解的作用就是在项目启动的时候扫描<strong>启动类的同类级以及下级包中的Bean</strong>。</p>
<p><strong><code>@SpringBootConfiguration</code></strong>：这个注解使Spring Boot的注解，源码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</div><div class="line">    <span class="meta">@AliasFor</span>(</div><div class="line">        annotation = Configuration.class</div><div class="line">    )</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从源码可以看出，<code>@SpringBootConfiguration</code>完全就是的<code>@Configuration</code>注解，<code>@Configuration</code>是Spring中的注解，表示该类是一个配置类，因此我们可以在启动类中做一些配置类可以做的事，比如注入一个<code>Bean</code>。</p>
<p><strong><code>@EnableAutoConfiguration</code></strong>：这个注解看到这个名字就知道怎么回事了，直接翻译码，<strong>开启自动配置</strong>，真如其名，源码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Inherited</span></div><div class="line"><span class="meta">@AutoConfigurationPackage</span></div><div class="line"><span class="meta">@Import</span>(AutoConfigurationImportSelector.class)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</div></pre></td></tr></table></figure></p>
<p>又是一个熟悉的注解<code>@Import</code>，什么功能呢？<strong>快速导入Bean到IOC容器中</strong>，有三种方式，这里用的是其中一种<code>ImportSelector</code>方式。不是本文重点，不再细说。</p>
<p><code>@EnableAutoConfiguration</code>这个注解的作用也就一目了然了，无非就是<code>@Import</code>的一种形式而已，在项目启动的时候向IOC容器中快速注入<code>Bean</code>而已。</p>
<p><strong>好了，启动类就先介绍到这，后续讲到源码文章才能更清楚的了解到这个类的强大之处。</strong></p>
<h2 id="如何进行单元测试？"><a href="#如何进行单元测试？" class="headerlink" title="如何进行单元测试？"></a>如何进行单元测试？</h2><p>Spring Boot项目创建之处为我们提供了一个单元测试的类，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@SpringBootTest</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>@SpringBootTest</code>：这个注解指定这个类是单元测试的类。</p>
<p>在这个类中能够自动的获取IOC容器中的Bean，比如：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@SpringBootTest</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> HelloWorldController helloWorldController;</div></pre></td></tr></table></figure></p>
<p>简单的介绍下而已，实际开发中用不到，随着项目越来越大，启动的时间越来越长，谁会傻到启动一个测试方法来检验代码，纯粹浪费时间。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>作为Spring Boot的第一弹，写到这儿就结束了，没什么的深入的内容，只是简单的对Spring Boot做了初步的了解。</p>
<p>本文使用的开发工具是<code>IDEA</code>，有需要<code>2020</code>版本的公众号回复关键词<code>IDEA2020</code>，有需要IDEA破解包的回复关键词<code>IDEA破解包</code></p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/myjszl_log.png" alt=""></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 配置文件怎么造？</title>
    <url>/2020/10/14/Spring%20Boot%20%E7%AC%AC%E4%BA%8C%E5%BC%B9%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%80%8E%E4%B9%88%E9%80%A0%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自从用了Spring Boot，个人最喜欢的就是Spring Boot的配置文件了，和Spring比起，Spring Boot更加灵活，修改的某些配置也是更加得心应手。</p>
<p>Spring Boot 官方提供了两种常用的配置文件格式，分别是<code>properties</code>、<code>YML</code>格式。相比于<code>properties</code>来说，<code>YML</code>更加年轻，层级也是更加分明。</p>
<p>今天这篇文章就来介绍一下Spring Boot的配置文件的语法以及如何从配置文件中取值。<br><a id="more"></a></p>
<h2 id="properties格式简介"><a href="#properties格式简介" class="headerlink" title="properties格式简介"></a>properties格式简介</h2><p>常见的一种配置文件格式，Spring中也是用这种格式，语法结构很简单，结构为：<code>key=value</code>。具体如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">userinfo.name=myjszl</div><div class="line">userinfo.age=25</div><div class="line">userinfo.active=true</div><div class="line">userinfo.created-date=2018/03/31 16:54:30</div><div class="line">userinfo.map.k1=v1</div><div class="line">userinfo.map.k2=v2</div></pre></td></tr></table></figure></p>
<p>上述配置文件中对应的实体类如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="meta">@ToString</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> Integer age;</div><div class="line">    <span class="keyword">private</span> Boolean active;</div><div class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; map;</div><div class="line">    <span class="keyword">private</span> Date createdDate;</div><div class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbies;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结构很简单，无非就是<code>key=value</code>这种形式，也是在开发中用的比较多的一种格式。</p>
<h2 id="YML格式简介"><a href="#YML格式简介" class="headerlink" title="YML格式简介"></a>YML格式简介</h2><p>以空格的缩进程度来控制层级关系。空格的个数并不重要，只要左边空格对齐则视为同一个层级。注意不能用<code>tab</code>代替空格。且大小写敏感。支持字面值，对象，数组三种数据结构，也支持复合结构。</p>
<p><strong>字面值</strong>：字符串，布尔类型，数值，日期。字符串默认不加引号，单引号会转义特殊字符。日期格式支持<code>yyyy/MM/dd HH:mm:ss</code></p>
<p><strong>对象</strong>：由键值对组成，形如 key:(空格)value 的数据组成。冒号后面的空格是必须要有的，每组键值对占用一行，且缩进的程度要一致，也可以使用行内写法：<code>{k1: v1, ....kn: vn}</code></p>
<p><strong>数组</strong>：由形如 -(空格)value 的数据组成。短横线后面的空格是必须要有的，每组数据占用一行，且缩进的程度要一致，也可以使用行内写法：<code>[1,2,...n]</code></p>
<p><strong>复合结构</strong>：上面三种数据结构任意组合</p>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>在<code>src/resources</code>文件夹下创建一个<code>application.yml</code>文件。支持的类型主要有字符串，带特殊字符的字符串，布尔类型，数值，集合，行内集合，行内对象，集合对象这几种常用的数据格式。</p>
<p>具体的示例如下：<br><figure class="highlight yml"><table><tr><td class="code"><pre><div class="line"><span class="attr">userinfo:</span></div><div class="line"><span class="attr">    age:</span> <span class="number">25</span></div><div class="line"><span class="attr">    name:</span> <span class="string">myjszl</span></div><div class="line"><span class="attr">    active:</span> <span class="literal">true</span></div><div class="line"><span class="attr">    created-date:</span> <span class="number">2018</span><span class="string">/03/31</span> <span class="number">16</span><span class="string">:54:30</span></div><div class="line"><span class="attr">    map:</span> <span class="string">&#123;k1:</span> <span class="string">v1,k2:</span> <span class="string">v2&#125;</span></div><div class="line"><span class="attr">    hobbies:</span></div><div class="line"><span class="bullet">      -</span> <span class="string">one</span></div><div class="line"><span class="bullet">      -</span> <span class="string">two</span></div><div class="line"><span class="bullet">      -</span> <span class="string">three</span></div></pre></td></tr></table></figure></p>
<p>上述配置文件对应的实体类如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="meta">@ToString</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> Integer age;</div><div class="line">    <span class="keyword">private</span> Boolean active;</div><div class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; map;</div><div class="line">    <span class="keyword">private</span> Date createdDate;</div><div class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbies;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>YML是一种新式的格式，层级鲜明，个人比较喜欢使用的一种格式，注意如下：</p>
<ol>
<li><strong>字符串可以不加引号，若加双引号则输出特殊字符，若不加或加单引号则转义特殊字符</strong></li>
<li><strong>数组类型，短横线后面要有空格；对象类型，冒号后面要有空格</strong></li>
<li><strong>YAML是以空格缩进的程度来控制层级关系，但不能用tab键代替空格，大小写敏感</strong></li>
</ol>
<h2 id="如何从配置文件取值？"><a href="#如何从配置文件取值？" class="headerlink" title="如何从配置文件取值？"></a>如何从配置文件取值？</h2><p>一切的配置都是为了取值，Spring Boot也是提供了几种取值的方式，下面一一介绍。</p>
<h3 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h3><p>这个注解用于从配置文件中取值，支持复杂的数据类型，但是不支持<code>SPEL</code>表达式。</p>
<p>该注解中有一个属性<code>prefix</code>，用于指定获配置的前缀，毕竟配置文件中的属性很多，也有很多重名的，必须用一个前缀来区分下。</p>
<p><strong>该注解可以标注在类上也可以标注在方法上，这也注定了它有两种获取值的方式。</strong></p>
<h4 id="1-标注在实体类上"><a href="#1-标注在实体类上" class="headerlink" title="1. 标注在实体类上"></a>1. 标注在实体类上</h4><p>这种方式用于从实体类上取值，并且赋值到对应的属性。使用如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Component</span> ：注入到IOC容器中</div><div class="line"> * <span class="doctag">@ConfigurationProperties</span>：从配置文件中读取文件</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"userinfo"</span>)</div><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="meta">@ToString</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> Integer age;</div><div class="line">    <span class="keyword">private</span> Boolean active;</div><div class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; map;</div><div class="line">    <span class="keyword">private</span> Date createdDate;</div><div class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbies;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="标注在配置类中的方法上"><a href="#标注在配置类中的方法上" class="headerlink" title="标注在配置类中的方法上"></a>标注在配置类中的方法上</h4><p>标注在配置类上的方法上，同样是从配置文件中取值赋值到返回值的属性中。使用如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Bean</span> : 将返回的结果注入到IOC容器中</div><div class="line"> * <span class="doctag">@ConfigurationProperties</span> ：从配置文件中取值</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"userinfo"</span>)</div><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> UserInfo <span class="title">userInfo</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UserInfo();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><code>@ConfigurationProperties</code>注解能够很轻松的从配置文件中取值，优点如下：</p>
<ol>
<li>支持批量的注入属性，只需要指定一个前缀<code>prefix</code></li>
<li>支持复杂的数据类型，比如<code>List</code>、<code>Map</code></li>
<li>对属性名匹配的要求较低，比如<code>user-name</code>，<code>user_name</code>，<code>userName</code>，<code>USER_NAME</code>都可以取值</li>
<li>支持JAVA的JSR303数据校验</li>
</ol>
<p><strong>注意：<code>@ConfigurationProperties</code>这个注解仅仅是支持从Spring Boot的默认配置文件中取值，比如<code>application.properties</code>、<code>application.yml</code>。</strong></p>
<h3 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h3><p><code>@Value</code>这个注解估计很熟悉了，Spring中从属性取值的注解，支持<code>SPEL</code>表达式，不支持复杂的数据类型，比如<code>List</code>。使用如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;userinfo.name&#125;"</span>)</div><div class="line"><span class="keyword">private</span> String UserName;</div></pre></td></tr></table></figure></p>
<h2 id="如何从自定义配置文件中取值？"><a href="#如何从自定义配置文件中取值？" class="headerlink" title="如何从自定义配置文件中取值？"></a>如何从自定义配置文件中取值？</h2><p>Spring Boot在启动的时候会自动加载<code>application.xxx</code>和<code>bootsrap.xxx</code>，但是为了区分，有时候需要自定义一个配置文件，那么如何从自定义的配置文件中取值呢？此时就需要配合<code>@PropertySource</code>这个注解使用了。</p>
<p>只需要在配置类上标注<code>@PropertySource</code>并指定你自定义的配置文件即可完成。如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="meta">@PropertySource</span>(value = &#123;<span class="string">"classpath:custom.properties"</span>&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</div></pre></td></tr></table></figure></p>
<p><strong><code>value</code>属性是一个数组，可以指定多个配置文件同时引入。</strong></p>
<p><strong><code>@PropertySource</code>默认加载<code>xxx.properties</code>类型的配置文件，不能加载<code>YML</code>格式的配置文件，怎么破？？？</strong></p>
<h3 id="如何加载自定义YML格式的配置文件？"><a href="#如何加载自定义YML格式的配置文件？" class="headerlink" title="如何加载自定义YML格式的配置文件？"></a>如何加载自定义YML格式的配置文件？</h3><p><code>@PropertySource</code>注解有一个属性<code>factory</code>，默认值是<code>PropertySourceFactory.class</code>，这个就是用来加载<code>properties</code>格式的配置文件，我们可以自定义一个用来加载<code>YML</code>格式的配置文件，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.YamlPropertiesFactoryBean;</div><div class="line"><span class="keyword">import</span> org.springframework.core.env.PropertiesPropertySource;</div><div class="line"><span class="keyword">import</span> org.springframework.core.env.PropertySource;</div><div class="line"><span class="keyword">import</span> org.springframework.core.io.support.DefaultPropertySourceFactory;</div><div class="line"><span class="keyword">import</span> org.springframework.core.io.support.EncodedResource;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.Properties;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YmlConfigFactory</span> <span class="keyword">extends</span> <span class="title">DefaultPropertySourceFactory</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) <span class="keyword">throws</span> IOException &#123;</div><div class="line">        String sourceName = name != <span class="keyword">null</span> ? name : resource.getResource().getFilename();</div><div class="line">        <span class="keyword">if</span> (!resource.getResource().exists()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PropertiesPropertySource(sourceName, <span class="keyword">new</span> Properties());</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sourceName.endsWith(<span class="string">".yml"</span>) || sourceName.endsWith(<span class="string">".yaml"</span>)) &#123;</div><div class="line">            Properties propertiesFromYaml = loadYml(resource);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PropertiesPropertySource(sourceName, propertiesFromYaml);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.createPropertySource(name, resource);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> Properties <span class="title">loadYml</span><span class="params">(EncodedResource resource)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        YamlPropertiesFactoryBean factory = <span class="keyword">new</span> YamlPropertiesFactoryBean();</div><div class="line">        factory.setResources(resource.getResource());</div><div class="line">        factory.afterPropertiesSet();</div><div class="line">        <span class="keyword">return</span> factory.getObject();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此时只需要将<code>factory</code>属性指定为<code>YmlConfigFactory</code>即可，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="meta">@PropertySource</span>(value = &#123;<span class="string">"classpath:custom.yml"</span>&#125;,factory = YmlConfigFactory.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</div></pre></td></tr></table></figure></p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><code>@PropertySource</code>指定加载自定义的配置文件，默认只能加载<code>properties</code>格式，但是可以指定<code>factory</code>属性来加载<code>YML</code>格式的配置文件。</p>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>以上内容介绍了Spring Boot中的配置文件的语法以及如何从配置文件中取值，这个内容很重要，作者也是尽可能讲的通俗易懂，希望读者能够有所收获。</p>
<p>好了，肝了两个多小时，每一篇文章都是作者精心原创制作，读者朋友们的每一个点赞分享都是对我莫大的支持，谢谢！！！<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/myjszl_log.png" alt=""></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>优质资源分享 ! Spring Boot 入门到放弃！！！</title>
    <url>/2020/10/14/Spring%20Boot%20%E7%AC%AC%E5%8D%81%E5%BC%B9%EF%BC%8C%E4%BC%98%E8%B4%A8%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB%20!%20Spring%20Boot%20%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%81%EF%BC%81%EF%BC%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近不知不觉写Spring Boot专栏已经写了九篇文章了，从最底层的项目搭建到源码解析以及高级整合的部分，作者一直在精心准备文章，定时更新，有兴趣的可以看我的专栏<a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;album_id=1532834475389288449&amp;__biz=MzU3MDAzNDg1MA==#wechat_redirect" target="_blank" rel="external">Spring Boot进阶</a>。</p>
<p>有些读者反映文章更新的有点慢，想要尽快的入门Spring Boot，想我推荐一个Spring Boot的视频教程，最好能够和我的文章大纲有契合的地方。于是作者回家找了一套个人觉得很好的视频教程，今天在这里免费分享给大家。</p>
<a id="more"></a>
<h2 id="视频目录"><a href="#视频目录" class="headerlink" title="视频目录"></a>视频目录</h2><p>整个教程分为<code>基础</code>和<code>高级整合</code>两个部分，每套教程都有完整的<code>代码</code>和上课的<code>课件</code>，可以说是非常完整的。</p>
<p><strong>基础的部分目录如下</strong>：</p>
<ol>
<li>入门-课程简介</li>
<li>入门-Spring Boot简介</li>
<li>入门-微服务简介</li>
<li>入门-环境准备</li>
<li>入门-springboot-helloworld</li>
<li>入门-HelloWorld细节-场景启动器（starter）</li>
<li>入门-HelloWorld细节-自动配置</li>
<li>入门-使用向导快速创建Spring Boot应用</li>
<li>配置-yaml简介</li>
<li>配置-yaml语法</li>
<li>配置-yaml配置文件值获取</li>
<li>配置-properties配置文件编码问题</li>
<li>配置-@ConfigurationProperties与@Value区别</li>
<li>配置-@PropertySource.@ImportResource.@Bean</li>
<li>配置-配置文件占位符</li>
<li>配置-Profile多环境支持</li>
<li>配置-配置文件的加载位置</li>
<li>配置-外部配置加载顺序</li>
<li>配置-自动配置原理</li>
<li>配置-@Conditional&amp;自动配置报告</li>
<li>日志-日志框架分类和选择</li>
<li>日志-slf4j使用原理</li>
<li>日志-其他日志框架统一转换为slf4j</li>
<li>日志-SpringBoot日志关系</li>
<li>日志-SpringBoot默认配置</li>
<li>日志-指定日志文件和日志Profile功能</li>
<li>日志-切换日志框架</li>
<li>web开发-简介</li>
<li>web开发-webjars&amp;静态资源映射规则</li>
<li>web开发-引入thymeleaf</li>
<li>web开发-thymeleaf语法</li>
<li>web开发-SpringMVC自动配置原理</li>
<li>web开发-扩展与全面接管SpringMVC</li>
<li>web开发-【实验】-引入资源</li>
<li>web开发-【实验】-国际化</li>
<li>web开发-【实验】-登陆&amp;拦截器</li>
<li>web开发-【实验】-Restful实验要求</li>
<li>web开发-【实验】-员工列表-公共页抽取</li>
<li>web开发-【实验】-员工列表-链接高亮&amp;列表完成</li>
<li>web开发-【实验】-员工添加-来到添加页面</li>
<li>web开发-【实验】-员工添加-添加完成</li>
<li>web开发-【实验】-员工修改-重用页面&amp;修改完成</li>
<li>web开发-【实验】-员工删除-删除完成</li>
<li>web开发-错误处理原理&amp;定制错误页面</li>
<li>web开发-定制错误数据</li>
<li>web开发-嵌入式Servlet容器配置修改</li>
<li>web开发-注册servlet三大组件</li>
<li>web开发-切换其他嵌入式Servlet容器</li>
<li>web开发-嵌入式Servlet容器自动配置原理</li>
<li>web开发-嵌入式Servlet容器启动原理</li>
<li>web开发-使用外部Servlet容器&amp;JSP支持</li>
<li>web开发-外部Servlet容器启动SpringBoot应用原理</li>
<li>Docker-简介</li>
<li>Docker-核心概念</li>
<li>Docker-linux环境准备</li>
<li>Docker-docker安装&amp;启动&amp;停止</li>
<li>Docker-docker镜像操作常用命令</li>
<li>Docker-docker容器操作常用命令</li>
<li>Docker-docker安装MySQL</li>
<li>数据访问-简介</li>
<li>数据访问-JDBC&amp;自动配置原理</li>
<li>数据访问-整合Druid&amp;配置数据源监控</li>
<li>数据访问-整合MyBatis（一）-基础环境搭建</li>
<li>数据访问-整合MyBatis（二）-注解版MyBatis</li>
<li>数据访问-整合MyBatis（二）-配置版MyBatis</li>
<li>数据访问-SpringData JPA简介</li>
<li>数据访问-整合JPA</li>
<li>原理-第一步：创建SpringApplication</li>
<li>原理-第二步：启动应用</li>
<li>原理-事件监听机制相关测试</li>
<li>原理-自定义starter</li>
<li>结束语</li>
</ol>
<p><strong>高级整合的部分目录如下</strong>：</p>
<ol>
<li>尚硅谷<em>SpringBoot高级</em>源码.课件</li>
<li>缓存-JSR107简介</li>
<li>缓存-Spring缓存抽象简介</li>
<li>缓存-基本环境搭建</li>
<li>缓存-@Cacheable初体验</li>
<li>缓存-缓存工作原理&amp;@Cacheable运行流程</li>
<li>缓存-@Cacheable其他属性</li>
<li>缓存-@CachePut</li>
<li>缓存-@CacheEvict</li>
<li>缓存-@Caching&amp;@CacheConfig</li>
<li>缓存-搭建redis环境&amp;测试</li>
<li>缓存-RedisTemplate&amp;序列化机制</li>
<li>缓存-自定义CacheManager</li>
<li>消息-JMS&amp;AMQP简介</li>
<li>消息-RabbitMQ基本概念简介</li>
<li>消息-RabbitMQ运行机制</li>
<li>消息-RabbitMQ安装测试</li>
<li>消息-RabbitTemplate发送接受消息&amp;序列化机制</li>
<li>消息-@RabbitListener&amp;@EnableRabbit</li>
<li>消息-AmqpAdmin管理组件的使用</li>
<li>检索-Elasticsearch简介&amp;安装</li>
<li>检索-Elasticsearch快速入门</li>
<li>检索-SpringBoot整合Jest操作ES</li>
<li>检索-整合SpringDataElasticsearch</li>
<li>任务-异步任务</li>
<li>任务-定时任务</li>
<li>任务-邮件任务</li>
<li>安全-测试环境搭建</li>
<li>安全-登录&amp;认证&amp;授权</li>
<li>安全-权限控制&amp;注销</li>
<li>安全-记住我&amp;定制登陆页</li>
<li>分布式-dubbo简介</li>
<li>分布式-docker安装zookeeper</li>
<li>分布式-SpringBoot.Dubbo.Zookeeper整合</li>
<li>分布式-SpringCloud-Eureka注册中心</li>
<li>分布式-服务注册</li>
<li>分布式-服务发现&amp;消费</li>
<li>热部署-devtools开发热部署</li>
<li>监管-监管端点测试</li>
<li>监管-定制端点</li>
<li>监管-自定义HealthIndicator</li>
</ol>
<h2 id="如何获取"><a href="#如何获取" class="headerlink" title="如何获取"></a>如何获取</h2><p>分别回复关键词<code>Spring Boot初级</code>和<code>Spring Boot高级</code>即可获取两套视频教程。</p>
<p><strong>纯属个人分享，如果有侵权立即删除。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>作者的专栏文章大致和这个视频教程的大纲相同，有兴趣的可以结合着视频学习一波。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png" alt=""></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>优质资源</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>过滤器如何配置，一波梭哈~</title>
    <url>/2020/10/14/Spring%20Boot%E7%AC%AC%E4%B8%83%E5%BC%B9%EF%BC%8C%E8%BF%87%E6%BB%A4%E5%99%A8%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%EF%BC%8C%E4%B8%80%E6%B3%A2%E6%A2%AD%E5%93%88~/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上篇文章介绍了Spring Boot中如何配置拦截器，今天这篇文章就来讲讲类似于拦截器的一个组件：过滤器。</p>
<p>其实在实际开发中过滤器真的接触的不多，但是在应用中却是不可或缺的角色，值得花费一个章节专门介绍一下。</p>
<a id="more"></a>
<h2 id="Spring-Boot-版本"><a href="#Spring-Boot-版本" class="headerlink" title="Spring Boot 版本"></a>Spring Boot 版本</h2><p>本文基于的Spring Boot的版本是<code>2.3.4.RELEASE</code>。</p>
<h2 id="什么是过滤器？"><a href="#什么是过滤器？" class="headerlink" title="什么是过滤器？"></a>什么是过滤器？</h2><p><code>Filter</code>也称之为过滤器，它是Servlet技术中最实用的技术，WEB开发人员通过Filter技术，对web服务器管理的所有web资源：例如JSP，Servlet，静态图片文件或静态HTML文件进行拦截，从而实现一些特殊功能。例如实现<code>URL级别的权限控制</code>、<code>过滤敏感词汇</code>、<code>压缩响应信息</code>等一些高级功能。</p>
<h2 id="Filter的执行原理"><a href="#Filter的执行原理" class="headerlink" title="Filter的执行原理"></a>Filter的执行原理</h2><p>当客户端发出Web资源的请求时，Web服务器根据应用程序配置文件设置的过滤规则进行检查，若客户请求满足过滤规则，则对客户请求／响应进行拦截，对请求头和请求数据进行检查或改动，并依次通过过滤器链，最后把请求／响应交给请求的Web资源处理。请求信息在过滤器链中可以被修改，也可以根据条件让请求不发往资源处理器，并直接向客户机发回一个响应。当资源处理器完成了对资源的处理后，响应信息将逐级逆向返回。同样在这个过程中，用户可以修改响应信息，从而完成一定的任务，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%E7%AC%AC%E4%B8%83%E5%BC%B9%EF%BC%8C%E8%BF%87%E6%BB%A4%E5%99%A8%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE/1.png" alt=""></p>
<p>服务器会按照过滤器定义的先后循序组装成<code>一条链</code>，然后一次执行其中的<code>doFilter()</code>方法。（注：这一点<code>Filter</code>和<code>Servlet</code>是不一样的）执行的顺序就如下图所示，执行第一个过滤器的<code>chain.doFilter()</code>之前的代码，第二个过滤器的<code>chain.doFilter()</code>之前的代码，请求的资源，第二个过滤器的<code>chain.doFilter()</code>之后的代码，第一个过滤器的<code>chain.doFilter()</code>之后的代码，最后返回响应。</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%E7%AC%AC%E4%B8%83%E5%BC%B9%EF%BC%8C%E8%BF%87%E6%BB%A4%E5%99%A8%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE/2.jpg" alt=""></p>
<h2 id="如何自定义一个Filter？"><a href="#如何自定义一个Filter？" class="headerlink" title="如何自定义一个Filter？"></a>如何自定义一个Filter？</h2><p>这个问题其实不是Spring Boot这个章节应该介绍的了，在Spring MVC中就应该会的内容，只需要实现<code>javax.servlet.Filter</code>这个接口，重写其中的方法。实例如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrosFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//重写其中的doFilter方法</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</div><div class="line">        <span class="comment">//继续执行下一个过滤器</span></div><div class="line">        chain.doFilter(req, response);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="Spring-Boot如何配置Filter？"><a href="#Spring-Boot如何配置Filter？" class="headerlink" title="Spring Boot如何配置Filter？"></a>Spring Boot如何配置Filter？</h2><p>自定义好了过滤器当然要使其在Spring Boot中生效了，Spring Boot配置Filter有两种方式，其实都很简单，下面一一介绍。</p>
<h3 id="配置类中使用-Bean注入【推荐使用】"><a href="#配置类中使用-Bean注入【推荐使用】" class="headerlink" title="配置类中使用@Bean注入【推荐使用】"></a>配置类中使用@Bean注入【推荐使用】</h3><p>其实很简单，只需要将<code>FilterRegistrationBean</code>这个实例注入到IOC容器中即可，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterConfig</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> Filter1 filter1;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> Filter2 filter2;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 注入Filter1</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">filter1</span><span class="params">()</span> </span>&#123;</div><div class="line">        FilterRegistrationBean registration = <span class="keyword">new</span> FilterRegistrationBean();</div><div class="line">        registration.setFilter(filter1);</div><div class="line">        registration.addUrlPatterns(<span class="string">"/*"</span>);</div><div class="line">        registration.setName(<span class="string">"filter1"</span>);</div><div class="line">        <span class="comment">//设置优先级别</span></div><div class="line">        registration.setOrder(<span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> registration;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 注入Filter2</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">filter2</span><span class="params">()</span> </span>&#123;</div><div class="line">        FilterRegistrationBean registration = <span class="keyword">new</span> FilterRegistrationBean();</div><div class="line">        registration.setFilter(filter2);</div><div class="line">        registration.addUrlPatterns(<span class="string">"/*"</span>);</div><div class="line">        registration.setName(<span class="string">"filter2"</span>);</div><div class="line">        <span class="comment">//设置优先级别</span></div><div class="line">        registration.setOrder(<span class="number">2</span>);</div><div class="line">        <span class="keyword">return</span> registration;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>注意：设置的优先级别决定了过滤器的执行顺序。</strong></p>
<h3 id="使用-WebFilter"><a href="#使用-WebFilter" class="headerlink" title="使用@WebFilter"></a>使用@WebFilter</h3><p><code>@WebFilter</code>是Servlet3.0的一个注解，用于标注一个Filter，Spring Boot也是支持这种方式，只需要在自定义的Filter上标注该注解即可，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@WebFilter</span>(filterName = <span class="string">"crosFilter"</span>,urlPatterns = &#123;<span class="string">"/*"</span>&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrosFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//重写其中的doFilter方法</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</div><div class="line">        <span class="comment">//继续执行下一个过滤器</span></div><div class="line">        chain.doFilter(req, response);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>要想<code>@WebFilter</code>注解生效，需要在配置类上标注另外一个注解<code>@ServletComponentScan</code>用于扫描使其生效</strong>，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="meta">@ServletComponentScan</span>(value = &#123;<span class="string">"com.example.springbootintercept.filter"</span>&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootApplication</span> </span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>至此，配置就完成了，启动项目，即可正常运行。</p>
<h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>对于前后端分离的项目来说跨域是一个难题，什么是跨域问题？如何造成的？这个不是本章的重点。</p>
<p>对于跨域问题有多中解决方案，比如JSONP，网关支持等等。<strong>关于跨域的问题以及Spring Boot如何优雅的解决跨域问题？将会在后续文章中介绍</strong>。今天主要介绍如何使用过滤器来解决跨域问题。</p>
<p>其实原理很简单，只需要在请求头中添加相应支持跨域的内容即可，如下代码仅仅是简单的演示下，针对细致的内容还需自己完善，比如白名单等等。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrosFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//重写其中的doFilter方法</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</div><div class="line">        HttpServletResponse response = (HttpServletResponse) res;</div><div class="line">        response.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</div><div class="line">        response.setHeader(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="string">"true"</span>);</div><div class="line">        response.setHeader(<span class="string">"Access-Control-Allow-Methods"</span>, <span class="string">"POST, GET, OPTIONS, DELETE"</span>);</div><div class="line">        response.setHeader(<span class="string">"Access-Control-Max-Age"</span>, <span class="string">"3600"</span>);</div><div class="line">        response.setHeader(<span class="string">"Access-Control-Allow-Headers"</span>,<span class="string">" Origin, X-Requested-With, Content-Type, Accept"</span>);</div><div class="line">        <span class="comment">//继续执行下一个过滤器</span></div><div class="line">        chain.doFilter(req, response);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>配置类中注入<code>FilterRegistrationBean</code>，如下代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterConfig</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> CrosFilter crosFilter;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 注入crosFilter</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">crosFilter</span><span class="params">()</span> </span>&#123;</div><div class="line">        FilterRegistrationBean registration = <span class="keyword">new</span> FilterRegistrationBean();</div><div class="line">        registration.setFilter(crosFilter);</div><div class="line">        registration.addUrlPatterns(<span class="string">"/*"</span>);</div><div class="line">        registration.setName(<span class="string">"crosFilter"</span>);</div><div class="line">        <span class="comment">//设置优先级别</span></div><div class="line">        registration.setOrder(Ordered.HIGHEST_PRECEDENCE);</div><div class="line">        <span class="keyword">return</span> registration;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>至此，配置完成，相关细致功能还需自己润色。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>过滤器内容相对简单些，但是在实际开发中不可或缺，比如常用的权限控制框架<code>Shiro</code>，<code>Spring Security</code>，内部都是使用过滤器，了解一下对以后的深入学习有着固本的作用。</p>
<p><strong>另外作者的第一本PDF书籍已经整理好了，由浅入深的详细介绍了Mybatis基础以及底层源码，有需要的朋友公众号回复关键词<code>Mybatis进阶</code>即可获取，目录如下：</strong></p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E8%BF%9B%E9%98%B6PDF/2.png" alt=""></p>
<p>如果有所收获，不妨关注在看支持一下，持续连载中…..</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/myjszl_log.png" alt=""></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>一文带你搞懂日志如何配置？</title>
    <url>/2020/10/14/Spring%20Boot%E7%AC%AC%E4%B8%89%E5%BC%B9%EF%BC%8C%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E6%90%9E%E6%87%82%E6%97%A5%E5%BF%97%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>日志通常不会在需求阶段作为一个功能单独提出来，也不会在产品方案中看到它的细节。但是，这丝毫不影响它在任何一个系统中的重要的地位。</p>
<p>今天就来介绍一下Spring Boot中的日志如何配置。<br><a id="more"></a></p>
<h2 id="Spring-Boot-版本"><a href="#Spring-Boot-版本" class="headerlink" title="Spring Boot 版本"></a>Spring Boot 版本</h2><p>本文基于的Spring Boot的版本是<code>2.3.4.RELEASE</code>。</p>
<h2 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h2><p>几种常见的日志级别由低到高分为：<code>TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL</code>。</p>
<p>如何理解这个日志级别呢？很简单，如果项目中的日志级别设置为<code>INFO</code>，那么比它更低级别的日志信息就看不到了，即是<code>TRACE</code>、<code>DEBUG</code>日志将会不显示。</p>
<h2 id="日志框架有哪些？"><a href="#日志框架有哪些？" class="headerlink" title="日志框架有哪些？"></a>日志框架有哪些？</h2><p>常见的日志框架有<code>log4j</code>、<code>logback</code>、<code>log4j2</code>。</p>
<p><code>log4j</code>这个日志框架显示是耳熟能详了，在Spring开发中是经常使用，但是据说log4j官方已经不再更新了，而且在性能上比<code>logback</code>、<code>log4j2</code>差了很多。</p>
<p><code>logback</code>是由<code>log4j</code>创始人设计的另外一个开源日志框架，logback相比之于log4j性能提升了10以上，初始化内存加载也更小了。作为的Spring Boot默认的日志框架肯定是有着不小的优势。</p>
<p><code>log4j2</code>晚于<code>logback</code>推出，官网介绍性能比<code>logback</code>高，但谁知道是不是王婆卖瓜自卖自夸，坊间流传，log4j2在很多思想理念上都是照抄logback，因此即便log4j2是Apache官方项目，Spring等许多框架项目没有将它纳入主流。<strong>此处完全是作者道听途说，不必当真，题外话而已</strong>。</p>
<p>日志框架很多，究竟如何选择能够适应现在的项目开发，当然不是普通程序员考虑的，但是为了更高的追求，至少应该了解一下，哈哈。</p>
<h2 id="Spring-Boot-日志框架"><a href="#Spring-Boot-日志框架" class="headerlink" title="Spring Boot 日志框架"></a>Spring Boot 日志框架</h2><p>Spring Boot默认的日志框架是<code>logback</code>，既然Spring Boot能够将其纳入的默认的日志系统，肯定是有一定的考量的，因此实际开发过程中还是不要更换。</p>
<p>原则上需要使用logback,需要添加以下依赖，但是既然是默认的日志框架，当然不用重新引入依赖了。<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>Spring Boot中默认的日志级别是<code>INFO</code>，启动项目日志打印如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%20%E7%AC%AC%E4%B8%89%E5%BC%B9%EF%BC%8C%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/1.png" alt=""></p>
<p>从上图可以看出，输出的日志的默认元素如下：</p>
<ol>
<li>时间日期：精确到毫秒</li>
<li>日志级别：ERROR, WARN, INFO, DEBUG , TRACE</li>
<li>进程ID</li>
<li>分隔符：— 标识实际日志的开始</li>
<li>线程名：方括号括起来（可能会截断控制台输出）</li>
<li>Logger名：通常使用源代码的类名</li>
<li>日志内容</li>
</ol>
<h3 id="代码中如何使用日志？"><a href="#代码中如何使用日志？" class="headerlink" title="代码中如何使用日志？"></a>代码中如何使用日志？</h3><p>在业务中肯定需要追溯日志，那么如何在自己的业务中输出日志呢？其实常用的有两种方式，下面一一介绍。</p>
<p>第一种其实也是很早之前常用的一种方式，只需要在代码添加如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Logger logger= LoggerFactory.getLogger(DemoApplicationTests.class);</div></pre></td></tr></table></figure></p>
<p>这种方式显然比较鸡肋，如果每个类中都添加一下岂不是很low。别着急，lombok为我们解决了这个难题。</p>
<p>要想使用lombok，需要添加如下依赖：<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>使用也是很简单，只需要在类上标注一个注解<code>@Slf4j</code>即可，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Slf</span>4j</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">    log.debug(<span class="string">"输出DEBUG日志......."</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="如何定制日志级别？"><a href="#如何定制日志级别？" class="headerlink" title="如何定制日志级别？"></a>如何定制日志级别？</h3><p>Spring Boot中默认的日志级别是INFO，但是可以自己定制日志级别，如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">logging.level.root=DEBUG</div></pre></td></tr></table></figure></p>
<p>上面是将所有的日志的级别都改成了<code>DEBUG</code>，Spring Boot还支持<code>package</code>级别的日志级别调整，格式为：<code>logging.level.xxx=xxx</code>，如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">logging.level.com.example.demo=INFO</div></pre></td></tr></table></figure></p>
<p>那么完整的配置如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">logging.level.root=DEBUG</div><div class="line">logging.level.com.example.demo=INFO</div></pre></td></tr></table></figure></p>
<h3 id="日志如何输出到文件中？"><a href="#日志如何输出到文件中？" class="headerlink" title="日志如何输出到文件中？"></a>日志如何输出到文件中？</h3><p>Spring Boot中日志默认是输出到控制台的，但是在生产环境中显示不可行的，因此需要配置日志输出到日志文件中。</p>
<p>其中有两个重要配置如下：</p>
<ol>
<li><code>logging.file.path</code>：指定日志文件的路径</li>
<li><code>logging.file.name</code>：日志的文件名，默认为<code>spring.log</code></li>
</ol>
<p>注意：官方文档说这两个属性不能同时配置，否则不生效，因此只需要配置一个即可。</p>
<p>指定输出的文件为当前项目路径的<code>logs</code>文件下，默认生成的日志文件为<code>spring.log</code>，如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">logging.file.path=./logs</div></pre></td></tr></table></figure></p>
<p><strong>日志文件中还有一些其他的属性，比如日志文件的最大size，保留几天的日志等等，下面会介绍到。</strong></p>
<h3 id="如何定制日志格式？"><a href="#如何定制日志格式？" class="headerlink" title="如何定制日志格式？"></a>如何定制日志格式？</h3><p>默认的日志格式在第一张图已经看到了，有时我们需要定制自己需要的日志输出格式，这样在排查日志的时候能够一目了然。</p>
<p>定制日志格式有两个配置，分别是控制台的输出格式和文件中的日志输出格式，如下：</p>
<ol>
<li><code>logging.pattern.console</code>：控制台的输出格式</li>
<li><code>logging.pattern.file</code>：日志文件的输出格式</li>
</ol>
<p>例如配置如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">logging.pattern.console=%d&#123;yyyy/MM/dd-HH:mm:ss&#125; [%thread] %-5level %logger- %msg%n</div><div class="line">logging.pattern.file=%d&#123;yyyy/MM/dd-HH:mm&#125; [%thread] %-5level %logger- %msg%n</div></pre></td></tr></table></figure></p>
<p>上面的配置编码的含义如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">%d&#123;HH:mm:ss.SSS&#125;——日志输出时间</div><div class="line"></div><div class="line">%thread——输出日志的进程名字，这在Web应用以及异步任务处理中很有用</div><div class="line"></div><div class="line">%-<span class="number">5l</span>evel——日志级别，并且使用<span class="number">5</span>个字符靠左对齐</div><div class="line"></div><div class="line">%logger- ——日志输出者的名字</div><div class="line"></div><div class="line">%msg——日志消息</div><div class="line"></div><div class="line">%n——平台的换行符</div></pre></td></tr></table></figure></p>
<h2 id="如何自定义日志配置？"><a href="#如何自定义日志配置？" class="headerlink" title="如何自定义日志配置？"></a>如何自定义日志配置？</h2><p>Spring Boot官方文档指出，根据不同的日志系统，可以按照如下的日志配置文件名就能够被正确加载，如下：</p>
<ol>
<li><strong><code>Logback</code></strong>：logback-spring.xml, logback-spring.groovy, logback.xml, logback.groovy</li>
<li><strong><code>Log4j</code></strong>：log4j-spring.properties, log4j-spring.xml, log4j.properties, log4j.xml</li>
<li><strong><code>Log4j2</code></strong>：log4j2-spring.xml, log4j2.xml</li>
<li><strong><code>JDK (Java Util Logging)</code></strong>：logging.properties</li>
</ol>
<p>Spring Boot官方推荐优先使用带有-spring的文件名作为你的日志配置。因此只需要在<code>src/resources</code>文件夹下创建<code>logback-spring.xml</code>即可，配置文件内容如下：<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">"true"</span> <span class="attr">scanPeriod</span>=<span class="string">"60 seconds"</span> <span class="attr">debug</span>=<span class="string">"false"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 定义日志存放目录 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"logPath"</span> <span class="attr">value</span>=<span class="string">"logs"</span>/&gt;</span></div><div class="line">    <span class="comment">&lt;!--    日志输出的格式--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"PATTERN"</span> <span class="attr">value</span>=<span class="string">"%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t-%L] %-5level %logger&#123;36&#125; %L %M - %msg%xEx%n"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">contextName</span>&gt;</span>logback<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!--输出到控制台 ConsoleAppender--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"consoleLog"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!--展示格式 layout--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!--过滤器，只有过滤到指定级别的日志信息才会输出，如果level为ERROR，那么控制台只会输出ERROR日志--&gt;</span></div><div class="line"><span class="comment">&lt;!--        &lt;filter class="ch.qos.logback.classic.filter.ThresholdFilter"&gt;--&gt;</span></div><div class="line"><span class="comment">&lt;!--            &lt;level&gt;ERROR&lt;/level&gt;--&gt;</span></div><div class="line"><span class="comment">&lt;!--        &lt;/filter&gt;--&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!--正常的日志文件，输出到文件中--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"fileDEBUGLog"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!--如果只是想要 Info 级别的日志，只是过滤 info 还是会输出 Error 日志，因为 Error 的级别高，</span></div><div class="line">        所以我们使用下面的策略，可以避免输出 Error 的日志--&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!--过滤 Error--&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>Error<span class="tag">&lt;/<span class="name">level</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!--匹配到就禁止--&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!--没有匹配到就允许--&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="comment">&lt;!--日志名称，如果没有File 属性，那么只会使用FileNamePattern的文件路径规则</span></div><div class="line">            如果同时有&lt;File&gt;和&lt;FileNamePattern&gt;，那么当天日志是&lt;File&gt;，明天会自动把今天</div><div class="line">            的日志改名为今天的日期。即，&lt;File&gt; 的日志都是当天的。</div><div class="line">        --&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">File</span>&gt;</span>$&#123;logPath&#125;/log_demo.log<span class="tag">&lt;/<span class="name">File</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!--滚动策略，按照时间滚动 TimeBasedRollingPolicy--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!--文件路径,定义了日志的切分方式——把每一天的日志归档到一个文件中,以防止日志填满整个磁盘空间--&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">FileNamePattern</span>&gt;</span>$&#123;logPath&#125;/log_demo_%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">FileNamePattern</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!--只保留最近90天的日志--&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>90<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!--用来指定日志文件的上限大小，那么到了这个值，就会删除旧的日志--&gt;</span></div><div class="line">            <span class="comment">&lt;!--&lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt;--&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!--日志输出编码格式化--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!--输出ERROR日志到指定的文件中--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"fileErrorLog"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!--如果只是想要 Error 级别的日志，那么需要过滤一下，默认是 info 级别的，ThresholdFilter--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>Error<span class="tag">&lt;/<span class="name">level</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!--日志名称，如果没有File 属性，那么只会使用FileNamePattern的文件路径规则</span></div><div class="line">            如果同时有&lt;File&gt;和&lt;FileNamePattern&gt;，那么当天日志是&lt;File&gt;，明天会自动把今天</div><div class="line">            的日志改名为今天的日期。即，&lt;File&gt; 的日志都是当天的。</div><div class="line">        --&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">File</span>&gt;</span>$&#123;logPath&#125;/error.log<span class="tag">&lt;/<span class="name">File</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!--滚动策略，按照时间滚动 TimeBasedRollingPolicy--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!--文件路径,定义了日志的切分方式——把每一天的日志归档到一个文件中,以防止日志填满整个磁盘空间--&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">FileNamePattern</span>&gt;</span>$&#123;logPath&#125;/error_%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">FileNamePattern</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!--只保留最近90天的日志--&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>90<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!--用来指定日志文件的上限大小，那么到了这个值，就会删除旧的日志--&gt;</span></div><div class="line">            <span class="comment">&lt;!--&lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt;--&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!--日志输出编码格式化--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">&lt;!--指定最基础的日志输出级别--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!--appender将会添加到这个loger--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"consoleLog"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"fileDEBUGLog"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"fileErrorLog"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!--    定义指定package的日志级别--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"org.springframework"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"org.mybatis"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"java.sql.Connection"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"java.sql.Statement"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"java.sql.PreparedStatement"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"io.lettuce.*"</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"io.netty.*"</span> <span class="attr">level</span>=<span class="string">"ERROR"</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.rabbitmq.*"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"org.springframework.amqp.*"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"org.springframework.scheduling.*"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--定义com.xxx..xx..xx包下的日志信息不上传，直接输出到fileDEBUGLog和fileErrorLog这个两个appender中，日志级别为DEBUG--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.xxx.xxx.xx"</span>  <span class="attr">additivity</span>=<span class="string">"false"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"fileDEBUGLog"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"fileErrorLog"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>当然，如果就不想用Spring Boot推荐的名字，想自己定制也行，只需要在配置文件中指定配置文件名即可，如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">logging.config=classpath:logging-config.xml</div></pre></td></tr></table></figure></p>
<p><strong>懵逼了，一堆配置什么意思？别着急，下面一一介绍。</strong></p>
<h3 id="configuration节点"><a href="#configuration节点" class="headerlink" title="configuration节点"></a>configuration节点</h3><p>这是一个根节点，其中的各个属性如下：</p>
<ol>
<li><code>scan</code>：当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。</li>
<li><code>scanPeriod</code>：设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。</li>
<li><code>debug</code>：当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。</li>
</ol>
<h3 id="root节点"><a href="#root节点" class="headerlink" title="root节点"></a>root节点</h3><p>这是一个必须节点，用来指定基础的日志级别，只有一个<code>level</code>属性，默认值是<code>DEBUG</code>。<br>该节点可以包含零个或者多个元素，子节点是<code>appender-ref</code>，标记这个<code>appender</code>将会添加到这个logger中。</p>
<h3 id="contextName节点"><a href="#contextName节点" class="headerlink" title="contextName节点"></a>contextName节点</h3><p>标识一个上下文名称，默认为default，一般用不到</p>
<h3 id="property节点"><a href="#property节点" class="headerlink" title="property节点"></a>property节点</h3><p>标记一个上下文变量，属性有name和value，定义变量之后可以使用<code>${}</code>来获取。</p>
<h3 id="appender节点"><a href="#appender节点" class="headerlink" title="appender节点"></a>appender节点</h3><p>用来格式化日志输出节点，有两个属性<code>name</code>和<code>class</code>，class用来指定哪种输出策略，常用就是<strong>控制台输出策略</strong>和<strong>文件输出策略</strong>。</p>
<p>这个节点很重要，通常的日志文件需要定义三个appender，分别是控制台输出，常规日志文件输出，异常日志文件输出。</p>
<p>该节点有几个重要的子节点，如下：</p>
<ol>
<li><code>filter</code>：日志输出拦截器，没有特殊定制一般使用系统自带的即可，但是如果要将日志分开，比如将ERROR级别的日志输出到一个文件中，将除了<code>ERROR</code>级别的日志输出到另外一个文件中，此时就要拦截<code>ERROR</code>级别的日志了。</li>
<li><code>encoder</code>： 和pattern节点组合用于具体输出的日志格式和编码方式。</li>
<li><code>file</code>: 节点用来指明日志文件的输出位置，可以是绝对路径也可以是相对路径</li>
<li><code>rollingPolicy</code>: 日志回滚策略，在这里我们用了TimeBasedRollingPolicy，基于时间的回滚策略,有以下子节点fileNamePattern，必要节点，可以用来设置指定时间的日志归档。</li>
<li><code>maxHistory</code> : 可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件,，例如设置为30的话，则30天之后，旧的日志就会被删除</li>
<li><code>totalSizeCap</code>: 可选节点，用来指定日志文件的上限大小，例如设置为3GB的话，那么到了这个值，就会删除旧的日志</li>
</ol>
<h3 id="logger节点"><a href="#logger节点" class="headerlink" title="logger节点"></a>logger节点</h3><p>可选节点，用来具体指明包的日志输出级别，它将会覆盖root的输出级别。<br>该节点有几个重要的属性如下：</p>
<ol>
<li><code>name</code>：指定的包名</li>
<li><code>level</code>：可选，日志的级别</li>
<li><code>addtivity</code>：可选，默认为true，将此logger的信息向上级传递，将有root节点定义日志打印。如果设置为false，将不会上传，此时需要定义一个<code>appender-ref</code>节点才会输出。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Spring Boot的日志选型以及如何自定义日志配置就介绍到这里，如果觉得有所收获，不妨点个关注，分享一波，将是对作者最大的鼓励！！！</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/myjszl_log.png" alt=""></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>满屏的try-catch，你不瘆得慌？</title>
    <url>/2020/10/14/Spring%20Boot%E7%AC%AC%E4%B9%9D%E5%BC%B9%EF%BC%8C%E6%BB%A1%E5%B1%8F%E7%9A%84try-catch%EF%BC%8C%E4%BD%A0%E4%B8%8D%E7%98%86%E5%BE%97%E6%85%8C%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>软件开发过程中难免遇到各种的BUG，各种的异常，一直就是在解决异常的路上永不停歇，如果你的代码中再出现<code>try(){...}catch(){...}finally{...}</code>代码块，你还有心情看下去吗？自己不觉得恶心吗？</p>
<p>冗余的代码往往回丧失写代码的动力，每天搬砖似的写代码，真的很难受。今天这篇文章教你如何去掉满屏的<code>try(){...}catch(){...}finally{...}</code>，解放你的双手。</p>
<a id="more"></a>
<h2 id="Spring-Boot-版本"><a href="#Spring-Boot-版本" class="headerlink" title="Spring Boot 版本"></a>Spring Boot 版本</h2><p>本文基于的Spring Boot的版本是<code>2.3.4.RELEASE</code>。</p>
<h2 id="全局统一异常处理的前世今生"><a href="#全局统一异常处理的前世今生" class="headerlink" title="全局统一异常处理的前世今生"></a>全局统一异常处理的前世今生</h2><p>早在<code>Spring 3.x</code>就已经提出了<code>@ControllerAdvice</code>，可以与<code>@ExceptionHandler</code>、<code>@InitBinder</code>、<code>@ModelAttribute</code> 等注解注解配套使用，这几个此处就不再详细解释了。</p>
<p>这几个注解小眼一瞟只有<code>@ExceptionHandler</code>与异常有关啊，翻译过来就是<code>异常处理器</code>。<strong>其实异常的处理可以分为两类，分别是<code>局部异常处理</code>和<code>全局异常处理</code></strong>。</p>
<p><strong><code>局部异常处理</code></strong>：<code>@ExceptionHandler</code>和<code>@Controller</code>注解搭配使用，只有指定的controller层出现了异常才会被<code>@ExceptionHandler</code>捕获到，实际生产中怕是有成百上千个controller了吧，显然这种方式不合适。</p>
<p><strong><code>全局异常处理</code></strong>：既然局部异常处理不合适了，自然有人站出来解决问题了，于是就有了<code>@ControllerAdvice</code>这个注解的横空出世了，<code>@ControllerAdvice</code>搭配<code>@ExceptionHandler</code>彻底解决了全局统一异常处理。当然后面还出现了<code>@RestControllerAdvice</code>这个注解，其实就是<code>@ControllerAdvice</code>和<code>@ResponseBody</code>结晶。</p>
<h2 id="Spring-Boot的异常如何分类？"><a href="#Spring-Boot的异常如何分类？" class="headerlink" title="Spring Boot的异常如何分类？"></a>Spring Boot的异常如何分类？</h2><p>Java中的异常就很多，更别说Spring Boot中的异常了，这里不再根据传统意义上Java的异常进行分类了，而是按照<code>controller</code>进行分类，分为<code>进入controller前的异常</code>和<code>业务层的异常</code>，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%E7%AC%AC%E5%85%AB%E5%BC%B9%EF%BC%8C%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8/1.png" alt=""></p>
<p>进入controller之前异常一般是<code>javax.servlet.ServletException</code>类型的异常，因此在全局异常处理的时候需要统一处理。几个常见的异常如下：</p>
<ol>
<li><code>NoHandlerFoundException</code>：客户端的请求没有找到对应的controller，将会抛出<code>404</code>异常。</li>
<li><code>HttpRequestMethodNotSupportedException</code>：若匹配到了（匹配结果是一个列表，不同的是http方法不同，如：Get、Post等），则尝试将请求的http方法与列表的控制器做匹配，若没有对应http方法的控制器，则抛该异常</li>
<li><code>HttpMediaTypeNotSupportedException</code>：然后再对请求头与控制器支持的做比较，比如<code>content-type</code>请求头，若控制器的参数签名包含注解<code>@RequestBody</code>，但是请求的<code>content-type</code>请求头的值没有包含<code>application/json</code>，那么会抛该异常（当然，不止这种情况会抛这个异常）</li>
<li><code>MissingPathVariableException</code>：未检测到路径参数。比如url为：/user/{userId}，参数签名包含<code>@PathVariable(&quot;userId&quot;)</code>，当请求的url为/user，在没有明确定义url为/user的情况下，会被判定为：缺少路径参数</li>
</ol>
<h2 id="如何统一异常处理？"><a href="#如何统一异常处理？" class="headerlink" title="如何统一异常处理？"></a>如何统一异常处理？</h2><p>在统一异常处理之前其实还有许多东西需要优化的，比如统一结果返回的形式。当然这里不再细说了，不属于本文范畴。</p>
<p><strong>统一异常处理很简单，这里以前后端分离的项目为例，步骤如下</strong>：</p>
<ol>
<li>新建一个统一异常处理的一个类</li>
<li>类上标注<code>@RestControllerAdvice</code>这一个注解，或者同时标注<code>@ControllerAdvice</code>和<code>@ResponseBody</code>这两个注解。</li>
<li>在方法上标注<code>@ExceptionHandler</code>注解，并且指定需要捕获的异常，可以同时捕获多个。</li>
</ol>
<p>下面是作者随便配置一个demo，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 全局统一的异常处理，简单的配置下，根据自己的业务要求详细配置</div><div class="line"> */</div><div class="line"><span class="meta">@RestControllerAdvice</span></div><div class="line"><span class="meta">@Slf</span>4j</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 重复请求的异常</div><div class="line">     * <span class="doctag">@param</span> ex</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@ExceptionHandler</span>(RepeatSubmitException.class)</div><div class="line">    <span class="function"><span class="keyword">public</span> ResultResponse <span class="title">onException</span><span class="params">(RepeatSubmitException ex)</span></span>&#123;</div><div class="line">        <span class="comment">//打印日志</span></div><div class="line">        log.error(ex.getMessage());</div><div class="line">        <span class="comment">//todo 日志入库等等操作</span></div><div class="line"></div><div class="line">        <span class="comment">//统一结果返回</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultResponse(ResultCodeEnum.CODE_NOT_REPEAT_SUBMIT);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 自定义的业务上的异常</div><div class="line">     */</div><div class="line">    <span class="meta">@ExceptionHandler</span>(ServiceException.class)</div><div class="line">    <span class="function"><span class="keyword">public</span> ResultResponse <span class="title">onException</span><span class="params">(ServiceException ex)</span></span>&#123;</div><div class="line">        <span class="comment">//打印日志</span></div><div class="line">        log.error(ex.getMessage());</div><div class="line">        <span class="comment">//todo 日志入库等等操作</span></div><div class="line"></div><div class="line">        <span class="comment">//统一结果返回</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultResponse(ResultCodeEnum.CODE_SERVICE_FAIL);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 捕获一些进入controller之前的异常，有些4xx的状态码统一设置为200</div><div class="line">     * <span class="doctag">@param</span> ex</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@ExceptionHandler</span>(&#123;HttpRequestMethodNotSupportedException.class,</div><div class="line">            HttpMediaTypeNotSupportedException.class, HttpMediaTypeNotAcceptableException.class,</div><div class="line">            MissingPathVariableException.class, MissingServletRequestParameterException.class,</div><div class="line">            ServletRequestBindingException.class, ConversionNotSupportedException.class,</div><div class="line">            TypeMismatchException.class, HttpMessageNotReadableException.class,</div><div class="line">            HttpMessageNotWritableException.class,</div><div class="line">            MissingServletRequestPartException.class, BindException.class,</div><div class="line">            NoHandlerFoundException.class, AsyncRequestTimeoutException.class&#125;)</div><div class="line">    <span class="function"><span class="keyword">public</span> ResultResponse <span class="title">onException</span><span class="params">(Exception ex)</span></span>&#123;</div><div class="line">        <span class="comment">//打印日志</span></div><div class="line">        log.error(ex.getMessage());</div><div class="line">        <span class="comment">//todo 日志入库等等操作</span></div><div class="line"></div><div class="line">        <span class="comment">//统一结果返回</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultResponse(ResultCodeEnum.CODE_FAIL);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：<strong>上面的只是一个例子，实际开发中还有许多的异常需要捕获，比如<code>TOKEN失效</code>、<code>过期</code>等等异常，如果整合了其他的框架，还要注意这些框架抛出的异常，比如<code>Shiro</code>，<code>Spring Security</code>等等框架。</strong></p>
<h2 id="异常匹配的顺序是什么？"><a href="#异常匹配的顺序是什么？" class="headerlink" title="异常匹配的顺序是什么？"></a>异常匹配的顺序是什么？</h2><p>有些朋友可能疑惑了，如果我同时捕获了父类和子类，那么到底能够被那个异常处理器捕获呢？比如<code>Exception</code>和<code>ServiceException</code>。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%E7%AC%AC%E5%85%AB%E5%BC%B9%EF%BC%8C%E5%A6%82%E4%BD%95%E6%89%A9%E5%B1%95%E5%85%A8%E9%9D%A2%E6%8E%A5%E5%8F%A3MVC/1.jpg" alt=""></p>
<p>此时可能就疑惑了，<strong>这里先揭晓一下答案，当然是<code>ServiceException</code>的异常处理器捕获了，精确匹配，如果没有<code>ServiceException</code>的异常处理器才会轮到它的<code>父亲</code>，<code>父亲</code>没有才会到<code>祖父</code>。总之一句话，精准匹配，找那个关系最近的。</strong></p>
<p>为什么呢？这可不是凭空瞎说的，源码为证，出处<code>org.springframework.web.method.annotation.ExceptionHandlerMethodResolver#getMappedMethod</code>，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Nullable</span></div><div class="line">	<span class="function"><span class="keyword">private</span> Method <span class="title">getMappedMethod</span><span class="params">(Class&lt;? extends Throwable&gt; exceptionType)</span> </span>&#123;</div><div class="line">		List&lt;Class&lt;? extends Throwable&gt;&gt; matches = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="comment">//遍历异常处理器中定义的异常类型</span></div><div class="line">		<span class="keyword">for</span> (Class&lt;? extends Throwable&gt; mappedException : <span class="keyword">this</span>.mappedMethods.keySet()) &#123;</div><div class="line">      <span class="comment">//是否是抛出异常的父类，如果是添加到集合中</span></div><div class="line">			<span class="keyword">if</span> (mappedException.isAssignableFrom(exceptionType)) &#123;    </div><div class="line">        <span class="comment">//添加到集合中</span></div><div class="line">				matches.add(mappedException);  </div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">    <span class="comment">//如果集合不为空，则按照规则进行排序</span></div><div class="line">		<span class="keyword">if</span> (!matches.isEmpty()) &#123;</div><div class="line">			matches.sort(<span class="keyword">new</span> ExceptionDepthComparator(exceptionType));</div><div class="line">      <span class="comment">//取第一个</span></div><div class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.mappedMethods.get(matches.get(<span class="number">0</span>));</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p><strong>在初次异常处理的时候会执行上述的代码找到最匹配的那个异常处理器方法，后续都是直接从缓存中（一个<code>Map</code>结构，<code>key</code>是异常类型，<code>value</code>是异常处理器方法）。</strong></p>
<p>别着急，上面代码最精华的地方就是对<code>matches</code>进行排序的代码了，我们来看看<code>ExceptionDepthComparator</code>这个比较器的关键代码，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//递归调用，获取深度，depth值越小越精准匹配</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(Class&lt;?&gt; declaredException, Class&lt;?&gt; exceptionToMatch, <span class="keyword">int</span> depth)</span> </span>&#123;</div><div class="line">    <span class="comment">//如果匹配了，返回</span></div><div class="line">		<span class="keyword">if</span> (exceptionToMatch.equals(declaredException)) &#123;</div><div class="line">			<span class="comment">// Found it!</span></div><div class="line">			<span class="keyword">return</span> depth;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 递归结束的条件，最大限度了</span></div><div class="line">		<span class="keyword">if</span> (exceptionToMatch == Throwable.class) &#123;</div><div class="line">			<span class="keyword">return</span> Integer.MAX_VALUE;</div><div class="line">		&#125;</div><div class="line">    <span class="comment">//继续匹配父类</span></div><div class="line">		<span class="keyword">return</span> getDepth(declaredException, exceptionToMatch.getSuperclass(), depth + <span class="number">1</span>);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p><strong>精髓全在这里了，一个递归搞定，计算深度，<code>depth</code>初始值为0。值越小，匹配度越高越精准。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>全局异常的文章万万千，能够讲清楚的能有几篇呢？<strong>只出最精的文章，做最野的程序员</strong>，如果觉得不错的，关注分享走一波，谢谢支持！！！</p>
<p><strong>另外作者的第一本PDF书籍已经整理好了，由浅入深的详细介绍了Mybatis基础以及底层源码，有需要的朋友公众号回复关键词<code>Mybatis进阶</code>即可获取，目录如下：</strong></p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E8%BF%9B%E9%98%B6PDF/2.png" alt=""></p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/myjszl_log.png" alt=""></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot WEB开发初了解~</title>
    <url>/2020/10/14/Spring%20Boot%E7%AC%AC%E4%BA%94%E5%BC%B9%EF%BC%8CWEB%E5%BC%80%E5%8F%91%E5%88%9D%E4%BA%86%E8%A7%A3~/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天是Spring Boot专栏的第五篇文章，相信大家看了前四篇文章对Spring Boot已经有了初步的了解，今天这篇文章就来介绍一下Spring Boot的重要功能WEB开发。<br><a id="more"></a></p>
<h2 id="Spring-Boot-版本"><a href="#Spring-Boot-版本" class="headerlink" title="Spring Boot 版本"></a>Spring Boot 版本</h2><p>本文基于的Spring Boot的版本是<code>2.3.4.RELEASE</code>。</p>
<h2 id="前提条件（必须注意）"><a href="#前提条件（必须注意）" class="headerlink" title="前提条件（必须注意）"></a>前提条件（必须注意）</h2><p>Spring Boot的WEB开发有自己的启动器和自动配置，最好采用Spring Boot的一套配置，这里千万不要在任何一个配置类上添加<code>@EnableWebMvc</code>这个注解，具体原因会单独一篇文章讲述。</p>
<p><strong>此篇文章所有的内容都是在没有标注<code>@EnableWebMvc</code>这个注解的前提下。</strong></p>
<h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>Spring Boot对web模块有一个启动器，只需要在pom.xml中引入即可，如下：<br><figure class="highlight"><table><tr><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">   &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p>
<p><strong>这个依赖看似只是引入了一个依赖，其实内部引入了Spring,Spring MVC的相关依赖，Spring Boot的启动器就是这么神奇，后面的文章会介绍启动器的原理和如何自定义启动器。</strong></p>
<h2 id="第一个接口开发"><a href="#第一个接口开发" class="headerlink" title="第一个接口开发"></a>第一个接口开发</h2><p>假设这么一个需求，需要根据用户的ID获取用户信息，我们应该如何写接口呢？</p>
<p>其实和Spring MVC开发步骤一样，写一个controller，各种注解骚操作搞起，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> String id)</span>&#123;</div><div class="line">        <span class="keyword">return</span> User.builder()</div><div class="line">                .id(id)</div><div class="line">                .name(<span class="string">"不才陈某"</span>)</div><div class="line">                .age(<span class="number">18</span>)</div><div class="line">                .birthday(<span class="keyword">new</span> Date())</div><div class="line">                .build();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样一个接口就已经完成了，启动项目访问<code>http://localhost:8080/user/1</code>即可得到如下的结果：<br><figure class="highlight json"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line"><span class="attr">"id"</span>: <span class="number">1</span>,</div><div class="line"><span class="attr">"age"</span>: <span class="number">18</span>,</div><div class="line"><span class="attr">"birthday"</span>: <span class="number">1601454650860</span>,</div><div class="line"><span class="attr">"name"</span>: <span class="string">"不才陈某"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="如何自定义tomcat的端口？"><a href="#如何自定义tomcat的端口？" class="headerlink" title="如何自定义tomcat的端口？"></a>如何自定义tomcat的端口？</h3><p>Spring Boot其实默认内嵌了Tomcat，当然默认的端口号也是<code>8080</code>，如果需要修改的话，只需要在配置文件中添加如下一行配置即可:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">server.port=9090</div></pre></td></tr></table></figure></p>
<h3 id="如何自定义项目路径？"><a href="#如何自定义项目路径？" class="headerlink" title="如何自定义项目路径？"></a>如何自定义项目路径？</h3><p>在配置文件中添加如下配置即可：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">server.servlet.context-path=/springboot01</div></pre></td></tr></table></figure></p>
<p>以上的端口和项目路径改了之后，只需要访问<code>http://localhost:9090/springboot01/user/1</code>即可。</p>
<h2 id="JSON格式化"><a href="#JSON格式化" class="headerlink" title="JSON格式化"></a>JSON格式化</h2><p>在前后端分离的项目中大部分的接口基本都是返回JSON字符串，因此对返回的JSON也是需要定制一下，比如<strong>日期的格式</strong>，<strong>NULL值是否返回</strong>等等内容。</p>
<p>Spring Boot默认是使用Jackson对返回结果进行处理，在引入WEB启动器的时候会引入相关的依赖，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%E7%AC%AC%E4%BA%94%E5%BC%B9%EF%BC%8Cweb%E5%88%9D%E5%85%A5%E9%97%A8/1.png" alt=""></p>
<p><strong>同样是引入了一个启动器，则意味着我们既可以在配置文件中修改配置，也可以在配置类中重写其中的配置。JackSon的自动配置类是<code>JacksonAutoConfiguration</code></strong></p>
<h3 id="日期格式的设置"><a href="#日期格式的设置" class="headerlink" title="日期格式的设置"></a>日期格式的设置</h3><p>上面的例子中日期的返回结果其实是一个时间戳，那么我们需要返回格式为<code>yyyy-MM-dd HH:mm:ss</code>。</p>
<p>可以在配置文件<code>application.properties</code>中设置指定的格式，这属于<strong>全局配置</strong>，如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">spring.jackson.date-format= yyyy-MM-dd HH:mm:ss</div><div class="line">spring.jackson.time-zone= GMT+8</div></pre></td></tr></table></figure></p>
<p>也可以在实体属性中标注<code>@JsonFormat</code>这个注解，属于局部配置，会覆盖全局配置，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@JsonFormat</span>(pattern = <span class="string">"yyyy-MM-dd HH:mm"</span>,timezone = <span class="string">"GMT+8"</span>)</div><div class="line">    <span class="keyword">private</span> Date birthday;</div></pre></td></tr></table></figure></p>
<p>上述日期格式配置完成之后返回的就是指定格式的日期，如下：<br><figure class="highlight json"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line"><span class="attr">"id"</span>: <span class="string">"1"</span>,</div><div class="line"><span class="attr">"age"</span>: <span class="number">18</span>,</div><div class="line"><span class="attr">"birthday"</span>: <span class="string">"2020-09-30 17:21"</span>,</div><div class="line"><span class="attr">"name"</span>: <span class="string">"不才陈某"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="其他属性的配置"><a href="#其他属性的配置" class="headerlink" title="其他属性的配置"></a>其他属性的配置</h3><p>Jackson还有很多的属性可以配置，这里就不再一一介绍了，所有的配置前缀都是<code>spring.jackson</code>。</p>
<h3 id="如何在配置类配置？"><a href="#如何在配置类配置？" class="headerlink" title="如何在配置类配置？"></a>如何在配置类配置？</h3><p>前面说过在引入WEB模块的时候还引入了JackSon的启动器，这是个好东西，这也是Spring Boot的好处之一，自动配置类中所需的一些配置既可以在全局配置文件<code>application.properties</code>中配置也可以在配置类中重新注入某个Bean而达到修改默认配置的效果。</p>
<p>在JackSon自动配置类<code>JacksonAutoConfiguration</code>中有如下一段代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">  <span class="meta">@Bean</span></div><div class="line"><span class="meta">@Primary</span></div><div class="line"><span class="meta">@ConditionalOnMissingBean</span></div><div class="line"><span class="function">ObjectMapper <span class="title">jacksonObjectMapper</span><span class="params">(Jackson2ObjectMapperBuilder builder)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> builder.createXmlMapper(<span class="keyword">false</span>).build();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这一段代码可能初学者比较懵逼了，什么意思呢？别着急，<code>@Bean</code>这个注解无非就是注入一个Bean到IOC容器中，<code>@Primary</code>这个注解自不用说了，剩下的就是<code>@ConditionalOnMissingBean</code>这个注解了，什么意思呢？</p>
<p><strong>其实仔细研究过Spring Boot的源码的朋友都知道，类似这种<code>@Conditionalxxx</code>的注解还有很多，这里就不再深入讲了，后期的文章会介绍。</strong></p>
<p><code>@ConditionalOnMissingBean</code>这个注解的意思很简单，就是当IOC容器中没有指定Bean的时候才会注入，言下之意就是当容器中不存在<code>ObjectMapper</code>这个Bean会使用这里生成的，类似于一种生效的条件。</p>
<p>言外之意就是只需要自定义一个<code>ObjectMapper</code>然后注入到IOC容器中，那么这个自动配置类<code>JacksonAutoConfiguration</code>中注入的将会失效，也就达到了覆盖的作用了。</p>
<p>因此只需要定义一个配置类，注入<code>ObjectMapper</code>即可，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义jackson序列化与反序列规则，增加相关格式（全局配置）</div><div class="line"> */</div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JacksonConfig</span> </span>&#123;</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="meta">@Primary</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ObjectMapper <span class="title">jacksonObjectMapper</span><span class="params">(Jackson2ObjectMapperBuilder builder)</span> </span>&#123;</div><div class="line">        builder.locale(Locale.CHINA);</div><div class="line">        builder.timeZone(TimeZone.getTimeZone(ZoneId.systemDefault()));</div><div class="line">        builder.simpleDateFormat(DatePattern.NORM_DATETIME_PATTERN);</div><div class="line">        builder.modules(<span class="keyword">new</span> CustomTimeModule());</div><div class="line"></div><div class="line">        ObjectMapper objectMapper = builder.createXmlMapper(<span class="keyword">false</span>).build();</div><div class="line"></div><div class="line">        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);</div><div class="line"></div><div class="line">        <span class="comment">//遇到未知属性的时候抛出异常，//为true 会抛出异常</span></div><div class="line">        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="keyword">false</span>);</div><div class="line">        <span class="comment">// 允许出现特殊字符和转义符</span></div><div class="line">        objectMapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS, <span class="keyword">true</span>);</div><div class="line">        <span class="comment">// 允许出现单引号</span></div><div class="line">        objectMapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, <span class="keyword">true</span>);</div><div class="line"></div><div class="line"></div><div class="line">        objectMapper.registerModule(<span class="keyword">new</span> CustomTimeModule());</div><div class="line"></div><div class="line">        <span class="keyword">return</span> objectMapper;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面只是个例子，关于<code>ObjectMapper</code>中的一些内容感兴趣的可以自己查查相关资料。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章算是WEB开发的入门，介绍了如何定义接口，返回JSON如何定制等内容，如果觉得有所收获点点关注在看分享一波！！！</p>
<p><strong>作者的上个Mybatis专栏已经结束了，作者特意将全部文章整理成册，关注公众号【码猿技术专栏】回复关键词Mybatis进阶即可领取此册。</strong></p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/myjszl_log.png" alt=""></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>一波带走，教你Spring Boot如何扩展、接管MVC？</title>
    <url>/2020/10/14/Spring%20Boot%E7%AC%AC%E5%85%AB%E5%BC%B9%EF%BC%8C%E4%B8%80%E6%B3%A2%E5%B8%A6%E8%B5%B0%EF%BC%8C%E6%95%99%E4%BD%A0Spring%20Boot%E5%A6%82%E4%BD%95%E6%89%A9%E5%B1%95%E3%80%81%E6%8E%A5%E7%AE%A1MVC%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自从用了Spring Boot是否有一个感觉，以前MVC的配置都很少用到了，比如视图解析器，拦截器，过滤器等等，这也正是Spring Boot好处之一。</p>
<p>但是往往Spring Boot提供默认的配置不一定适合实际的需求，因此需要能够定制MVC的相关功能，这篇文章就介绍一下如何扩展和全面接管MVC。</p>
<a id="more"></a>
<h2 id="Spring-Boot-版本"><a href="#Spring-Boot-版本" class="headerlink" title="Spring Boot 版本"></a>Spring Boot 版本</h2><p>本文基于的Spring Boot的版本是<code>2.3.4.RELEASE</code>。</p>
<h2 id="如何扩展MVC？"><a href="#如何扩展MVC？" class="headerlink" title="如何扩展MVC？"></a>如何扩展MVC？</h2><p>在这里需要声明一个前提：<strong>配置类上没有标注<code>@EnableWebMvc</code>并且没有任何一个配置类继承了<code>WebMvcConfigurationSupport</code></strong>。至于具体原因，下文会详细解释。</p>
<p><strong>扩展MVC其实很简单，只需要以下步骤</strong>：</p>
<ol>
<li>创建一个MVC的配置类，并且标注<code>@Configuration</code>注解。</li>
<li>实现<code>WebMvcConfigurer</code>这个接口，并且实现需要的方法。</li>
</ol>
<p><code>WebMvcConfigurer</code>这个接口中定义了MVC相关的各种组件，比如拦截器，视图解析器等等的定制方法，需要定制什么功能，只需要实现即可。</p>
<p>在Spring Boot之前的版本还可以继承一个抽象类<code>WebMvcConfigurerAdapter</code>，不过在<code>2.3.4.RELEASE</code>这个版本中被废弃了，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Deprecated</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfigurerAdapter</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p><strong>举个栗子</strong>：现在要添加一个拦截器，使其在Spring Boot中生效，此时就可以在MVC的配置类重写<code>addInterceptors()</code>方法，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * MVC扩展的配置类，实现WebMvcConfigurer接口</div><div class="line"> */</div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> RepeatSubmitInterceptor repeatSubmitInterceptor;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 重写addInterceptors方法，注入自定义的拦截器</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</div><div class="line">        registry.addInterceptor(repeatSubmitInterceptor).excludePathPatterns(<span class="string">"/error"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>操作很简单，除了拦截器，还可以定制视图解析，资源映射处理器等等相关的功能，和Spring MVC很类似，只不过Spring MVC是在<code>XML</code>文件中配置，Spring Boot是在配置类中配置而已。</p>
<h2 id="什么都不配置为什么依然能运行MVC相关的功能？"><a href="#什么都不配置为什么依然能运行MVC相关的功能？" class="headerlink" title="什么都不配置为什么依然能运行MVC相关的功能？"></a>什么都不配置为什么依然能运行MVC相关的功能？</h2><p>早期的SSM架构中想要搭建一个MVC其实挺复杂的，需要配置视图解析器，资源映射处理器，<code>DispatcherServlet</code>等等才能正常运行，但是为什么Spring Boot仅仅是添加一个<code>WEB</code>模块依赖即能正常运行呢？依赖如下：<br><figure class="highlight"><table><tr><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">   &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p>
<p>其实这已经涉及到了Spring Boot高级的知识点了，在这里就简单的说一下，Spring Boot的每一个<code>starter</code>都会有一个自动配置类，什么是自动配置类呢？<strong>自动配置类就是在Spring Boot项目启动的时候会自动加载的类，能够在启动期间就配置一些默认的配置</strong>。<code>WEB</code>模块的自动配置类是<code>WebMvcAutoConfiguration</code>。</p>
<p><code>WebMvcAutoConfiguration</code>这个配置类中还含有如下一个子配置类<code>WebMvcAutoConfigurationAdapter</code>，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</div><div class="line">	<span class="meta">@Import</span>(EnableWebMvcConfiguration.class)</div><div class="line">	<span class="meta">@EnableConfigurationProperties</span>(&#123; WebMvcProperties.class, ResourceProperties.class &#125;)</div><div class="line">	<span class="meta">@Order</span>(<span class="number">0</span>)</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcAutoConfigurationAdapter</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p><code>WebMvcAutoConfigurationAdapter</code>这个子配置类实现了<code>WebMvcConfigurer</code>这个接口，这个正是MVC扩展接口，这个就很清楚了。<strong>自动配置类是在项目启动的时候就加载的，因此Spring Boot会在项目启动时加载<code>WebMvcAutoConfigurationAdapter</code>这个MVC扩展配置类，提前完成一些默认的配置（比如内置了默认的视图解析器，资源映射处理器等等），这也就是为什么没有配置什么MVC相关的东西依然能够运行</strong>。</p>
<h2 id="如何全面接管MVC？【不推荐】"><a href="#如何全面接管MVC？【不推荐】" class="headerlink" title="如何全面接管MVC？【不推荐】"></a>如何全面接管MVC？【不推荐】</h2><p>全面接管MVC是什么意思呢？全面接管的意思就是不需要Spring Boot自动配置，而是全部使用自定义的配置。</p>
<p><strong>全面接管MVC其实很简单，只需要在配置类上添加一个<code>@EnableWebMvc</code>注解即可</strong>。还是添加拦截器，例子如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@EnableWebMvc</span>：全面接管MVC，导致自动配置类失效</div><div class="line"> */</div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableWebMvc</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> RepeatSubmitInterceptor repeatSubmitInterceptor;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</div><div class="line">        <span class="comment">//添加拦截器</span></div><div class="line">        registry.addInterceptor(repeatSubmitInterceptor).excludePathPatterns(<span class="string">"/error"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一个注解就能全面接口MVC，是不是很爽，不过，不建议使用。</p>
<h2 id="为什么-EnableWebMvc一个注解就能够全面接管MVC？"><a href="#为什么-EnableWebMvc一个注解就能够全面接管MVC？" class="headerlink" title="为什么@EnableWebMvc一个注解就能够全面接管MVC？"></a>为什么@EnableWebMvc一个注解就能够全面接管MVC？</h2><p>what？？？为什么呢？上面刚说过自动配置类<code>WebMvcAutoConfiguration</code>会在项目启动期间加载一些默认的配置，这会怎么添加一个<code>@EnableWebMvc</code>注解就不行了呢？<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%E7%AC%AC%E5%85%AB%E5%BC%B9%EF%BC%8C%E5%A6%82%E4%BD%95%E6%89%A9%E5%B1%95%E5%85%A8%E9%9D%A2%E6%8E%A5%E5%8F%A3MVC/1.jpg" alt=""></p>
<p>其实很简单，<code>@EnableWebMvc</code>源码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Import</span>(DelegatingWebMvcConfiguration.class)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableWebMvc &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其实重要的就是这个<code>@Import(DelegatingWebMvcConfiguration.class)</code>注解了，Spring中的注解，快速导入一个配置类<code>DelegatingWebMvcConfiguration</code>，源码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p><strong>明白了，<code>@EnableWebMvc</code>这个注解实际上就是导入了一个<code>WebMvcConfigurationSupport</code>子类型的配置类而已</strong>。</p>
<p>而WEB模块的自动配置类有这么一行注解<code>@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</code>，源码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</div><div class="line"><span class="meta">@ConditionalOnWebApplication</span>(type = Type.SERVLET)</div><div class="line"><span class="meta">@ConditionalOnClass</span>(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)</div><div class="line"><span class="meta">@ConditionalOnMissingBean</span>(WebMvcConfigurationSupport.class)</div><div class="line"><span class="meta">@AutoConfigureOrder</span>(Ordered.HIGHEST_PRECEDENCE + <span class="number">10</span>)</div><div class="line"><span class="meta">@AutoConfigureAfter</span>(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,</div><div class="line">		ValidationAutoConfiguration.class &#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcAutoConfiguration</span> </span>&#123;</div></pre></td></tr></table></figure></p>
<p>这个注解<code>@ConditionalOnMissingBean</code>什么意思呢？简单的说就是IOC容器中没有指定的<code>Bean</code>这个配置才会生效。</p>
<p><strong>一切都已经揭晓了，<code>@EnableWebMvc</code>导入了一个<code>WebMvcConfigurationSupport</code>类型的配置类，导致了自动配置类<code>WebMvcAutoConfiguration</code>标注的<code>@@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</code>判断为<code>false</code>了，从而自动配置类失效了。</strong></p>
<h2 id="Spring-Boot相关资料"><a href="#Spring-Boot相关资料" class="headerlink" title="Spring Boot相关资料"></a>Spring Boot相关资料</h2><p>前期有很多的小伙伴私信我，觉得看文章太枯燥了，有些东西也不能理解的透彻，有没有好的视频课程分享，前几天特意回家找了找资源，总算找到了适合入门学习的完整视频教程，从Spring Boot初级入门到高级整合，讲解的非常全面，一些目录如下：</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%E7%AC%AC%E5%85%AB%E5%BC%B9%EF%BC%8C%E5%A6%82%E4%BD%95%E6%89%A9%E5%B1%95%E5%85%A8%E9%9D%A2%E6%8E%A5%E5%8F%A3MVC/3.png" alt=""></p>
<p>这些资料全部免费提供，我的文章也是尽量跟着视频大纲匹配，希望小伙伴能够系统完整的学习Spring Boot。<strong>公众号【码猿技术专栏】回复关键词<code>Spring Boot初级</code>和<code>Spring Boot高级</code>分别获取初级和高级的视频教程。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>扩展和全面接管MVC都很简单，但是不推荐全面接管MVC，一旦全面接管了，WEb模块的这个<code>starter</code>将没有任何意义，一些全局配置文件中与MVC相关的配置也将会失效。</p>
<p><strong>另外作者的第一本PDF书籍已经整理好了，由浅入深的详细介绍了Mybatis基础以及底层源码，有需要的朋友公众号回复关键词<code>Mybatis进阶</code>即可获取，目录如下：</strong></p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E8%BF%9B%E9%98%B6PDF/2.png" alt=""></p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/myjszl_log.png" alt=""></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>拦截器如何配置，看这儿~</title>
    <url>/2020/10/14/Spring%20Boot%E7%AC%AC%E5%85%AD%E5%BC%B9%EF%BC%8C%E6%8B%A6%E6%88%AA%E5%99%A8%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%EF%BC%8C%E7%9C%8B%E8%BF%99%E5%84%BF~/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上篇文章讲了Spring Boot的WEB开发基础内容，相信读者朋友们已经有了初步的了解，知道如何写一个接口。</p>
<p>今天这篇文章来介绍一下拦截器在Spring Boot中如何自定义以及配置。</p>
<a id="more"></a>
<h2 id="Spring-Boot-版本"><a href="#Spring-Boot-版本" class="headerlink" title="Spring Boot 版本"></a>Spring Boot 版本</h2><p>本文基于的Spring Boot的版本是<code>2.3.4.RELEASE</code>。</p>
<h2 id="什么是拦截器？"><a href="#什么是拦截器？" class="headerlink" title="什么是拦截器？"></a>什么是拦截器？</h2><p>Spring MVC中的拦截器（<code>Interceptor</code>）类似于Servlet中的过滤器（<code>Filter</code>），它主要用于拦截用户请求并作相应的处理。例如通过拦截器可以进行权限验证、记录请求信息的日志、判断用户是否登录等。</p>
<h2 id="如何自定义一个拦截器？"><a href="#如何自定义一个拦截器？" class="headerlink" title="如何自定义一个拦截器？"></a>如何自定义一个拦截器？</h2><p>自定义一个拦截器非常简单，只需要实现<code>HandlerInterceptor</code>这个接口即可，该接口有三个可以实现的方法，如下：</p>
<ol>
<li><code>preHandle()</code>方法：该方法会在控制器方法前执行，其返回值表示是否知道如何写一个接口。中断后续操作。当其返回值为<code>true</code>时，表示继续向下执行；当其返回值为<code>false</code>时，会中断后续的所有操作（包括调用下一个拦截器和控制器类中的方法执行等）。</li>
<li><code>postHandle()</code>方法：该方法会在控制器方法调用之后，且解析视图之前执行。可以通过此方法对请求域中的模型和视图做出进一步的修改。</li>
<li><code>afterCompletion()</code>方法：该方法会在整个请求完成，即视图渲染结束之后执行。可以通过此方法实现一些资源清理、记录日志信息等工作。</li>
</ol>
<h2 id="如何使其在Spring-Boot中生效？"><a href="#如何使其在Spring-Boot中生效？" class="headerlink" title="如何使其在Spring Boot中生效？"></a>如何使其在Spring Boot中生效？</h2><p>其实想要在Spring Boot生效其实很简单，只需要定义一个配置类，实现<code>WebMvcConfigurer</code>这个接口，并且实现其中的<code>addInterceptors()</code>方法即可，代码演示如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> XXX xxx;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</div><div class="line">        <span class="comment">//不拦截的uri</span></div><div class="line">        <span class="keyword">final</span> String[] commonExclude = &#123;&#125;&#125;;</div><div class="line">        registry.addInterceptor(xxx).excludePathPatterns(commonExclude);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>开发中可能会经常遇到短时间内由于用户的重复点击导致几秒之内重复的请求，可能就是在这几秒之内由于各种问题，比如<code>网络</code>，<code>事务的隔离性</code>等等问题导致了数据的重复等问题，因此在日常开发中必须规避这类的重复请求操作，今天就用拦截器简单的处理一下这个问题。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在接口执行之前先对指定接口（比如标注某个<code>注解</code>的接口）进行判断，如果在指定的时间内（比如<code>5秒</code>）已经请求过一次了，则返回重复提交的信息给调用者。</p>
<h3 id="根据什么判断这个接口已经请求了？"><a href="#根据什么判断这个接口已经请求了？" class="headerlink" title="根据什么判断这个接口已经请求了？"></a>根据什么判断这个接口已经请求了？</h3><p>根据项目的架构可能判断的条件也是不同的，比如<code>IP地址</code>，<code>用户唯一标识</code>、<code>请求参数</code>、<code>请求URI</code>等等其中的某一个或者多个的组合。</p>
<h3 id="这个具体的信息存放在哪里？"><a href="#这个具体的信息存放在哪里？" class="headerlink" title="这个具体的信息存放在哪里？"></a>这个具体的信息存放在哪里？</h3><p>由于是<code>短时间</code>内甚至是瞬间并且要保证<code>定时失效</code>，肯定不能存在事务性数据库中了，因此常用的几种数据库中只有<code>Redis</code>比较合适了。</p>
<h3 id="如何实现？"><a href="#如何实现？" class="headerlink" title="如何实现？"></a>如何实现？</h3><p>第一步，先自定义一个注解，可以标注在类或者方法上，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RepeatSubmit &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 默认失效时间5秒</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">long</span> <span class="title">seconds</span><span class="params">()</span> <span class="keyword">default</span> 5</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第二步，创建一个拦截器，<strong>注入到IOC容器中</strong>，实现的思路很简单，判断controller的类或者方法上是否标注了<code>@RepeatSubmit</code>这个注解，如果标注了，则拦截判断，否则跳过，代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 重复请求的拦截器</div><div class="line"> * <span class="doctag">@Component</span>：该注解将其注入到IOC容器中</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepeatSubmitInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Redis的API</div><div class="line">     */</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * preHandler方法，在controller方法之前执行</div><div class="line">     * </div><div class="line">     * 判断条件仅仅是用了uri，实际开发中根据实际情况组合一个唯一识别的条件。</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> HandlerMethod)&#123;</div><div class="line">            <span class="comment">//只拦截标注了@RepeatSubmit该注解</span></div><div class="line">            HandlerMethod method=(HandlerMethod)handler;</div><div class="line">            <span class="comment">//标注在方法上的@RepeatSubmit</span></div><div class="line">            RepeatSubmit repeatSubmitByMethod = AnnotationUtils.findAnnotation(method.getMethod(),RepeatSubmit.class);</div><div class="line">            <span class="comment">//标注在controler类上的@RepeatSubmit</span></div><div class="line">            RepeatSubmit repeatSubmitByCls = AnnotationUtils.findAnnotation(method.getMethod().getDeclaringClass(), RepeatSubmit.class);</div><div class="line">            <span class="comment">//没有限制重复提交，直接跳过</span></div><div class="line">            <span class="keyword">if</span> (Objects.isNull(repeatSubmitByMethod)&amp;&amp;Objects.isNull(repeatSubmitByCls))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">            <span class="comment">// todo: 组合判断条件，这里仅仅是演示，实际项目中根据架构组合条件</span></div><div class="line">            <span class="comment">//请求的URI</span></div><div class="line">            String uri = request.getRequestURI();</div><div class="line"></div><div class="line">            <span class="comment">//存在即返回false，不存在即返回true</span></div><div class="line">            Boolean ifAbsent = stringRedisTemplate.opsForValue().setIfAbsent(uri, <span class="string">""</span>, Objects.nonNull(repeatSubmitByMethod)?repeatSubmitByMethod.seconds():repeatSubmitByCls.seconds(), TimeUnit.SECONDS);</div><div class="line"></div><div class="line">            <span class="comment">//如果存在，表示已经请求过了，直接抛出异常，由全局异常进行处理返回指定信息</span></div><div class="line">            <span class="keyword">if</span> (ifAbsent!=<span class="keyword">null</span>&amp;&amp;!ifAbsent)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RepeatSubmitException();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第三步，在Spring Boot中配置这个拦截器，代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> RepeatSubmitInterceptor repeatSubmitInterceptor;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</div><div class="line">        <span class="comment">//不拦截的uri</span></div><div class="line">        <span class="keyword">final</span> String[] commonExclude = &#123;<span class="string">"/error"</span>, <span class="string">"/files/**"</span>&#125;;</div><div class="line">        registry.addInterceptor(repeatSubmitInterceptor).excludePathPatterns(commonExclude);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>OK，拦截器已经配置完成，只需要在需要拦截的接口上标注<code>@RepeatSubmit</code>这个注解即可，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</div><div class="line"><span class="comment">//标注了@RepeatSubmit注解，全部的接口都需要拦截</span></div><div class="line"><span class="meta">@RepeatSubmit</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/login"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"login success"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此时，请求这个URI:<code>http://localhost:8080/springboot-demo/user/login</code>在5秒之内只能请求一次。</p>
<p><strong>注意</strong>：标注在方法上的超时时间会覆盖掉类上的时间，因为如下一段代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Boolean ifAbsent = stringRedisTemplate.opsForValue().setIfAbsent(uri, <span class="string">""</span>, Objects.nonNull(repeatSubmitByMethod)?repeatSubmitByMethod.seconds():repeatSubmitByCls.seconds(), TimeUnit.SECONDS);</div></pre></td></tr></table></figure></p>
<p>这段代码的失效时间先取值<code>repeatSubmitByMethod</code>中配置的，如果为null，则取值<code>repeatSubmitByCls</code>配置的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，拦截器的内容就介绍完了，其实配置起来很简单，没什么重要的内容。</p>
<p><strong>上述例子中的<code>源代码</code>有需要的朋友公众号<code>码猿技术专栏</code>内回复关键词<code>拦截器</code>即可获取。</strong></p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/myjszl_log.png" alt=""></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>一文带你搞懂日志框架如何切换？</title>
    <url>/2020/10/14/Spring%20Boot%E7%AC%AC%E5%9B%9B%E5%BC%B9%EF%BC%8C%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E6%90%9E%E6%87%82%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先要感谢一下读者朋友们的支持，你们每一个的赞都是对陈某最大的肯定，陈某也会一如既往的加油，奥利给！！！</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%E7%AC%AC%E5%9B%9B%E5%BC%B9%EF%BC%8C%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%EF%BC%9F/1.png" alt=""><br>言归正传，上一篇文章写了Spring Boot的默认日志框架Logback的基本配置，有兴趣的可以看看：<a href="https://mp.weixin.qq.com/s/5hyGi6X6BhfCC5kTEvUyFg" target="_blank" rel="external">Spring Boot第三弹，一文带你搞懂日志如何配置？</a>。</p>
<p>今天就来介绍一下Spring Boot如何无感的切换日志框架？</p>
<a id="more"></a>
<h2 id="Spring-Boot-版本"><a href="#Spring-Boot-版本" class="headerlink" title="Spring Boot 版本"></a>Spring Boot 版本</h2><p>本文基于的Spring Boot的版本是<code>2.3.4.RELEASE</code>。</p>
<h2 id="什么是日志门面？"><a href="#什么是日志门面？" class="headerlink" title="什么是日志门面？"></a>什么是日志门面？</h2><p>前面介绍的日志框架都是基于日志门面<code>SLF4j</code>即简单日志门面（Simple Logging Facade for Java），SLF4j并不是一个真正的日志实现，而是一个抽象层，它允许你在后台使用任意一个日志实现。</p>
<p>使用了slf4j后，对于应用程序来说，无论底层的日志框架如何变，应用程序不需要修改任意一行代码，就可以直接上线了。</p>
<p>如果对SLF4j比较感兴趣的可以去官网看看：SLF4j官网</p>
<h2 id="如何做到无感知切换？"><a href="#如何做到无感知切换？" class="headerlink" title="如何做到无感知切换？"></a>如何做到无感知切换？</h2><p>SLF4j是日志门面，无论什么日志框架都是基于SLF4j的API实现，<strong>因此无论是代码打印日志还是Lombok注解形式打印日志，都要使用的SLF4j的API，而不是日志框架的API</strong>，这样才能解耦，做到无感知。因为最终切换的框架只是对于SLF4j的实现，并不是切换SLF4j。</p>
<p>其实这一条在阿里开发手册中也是明确指出了，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%E7%AC%AC%E5%9B%9B%E5%BC%B9%EF%BC%8C%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%EF%BC%9F/5.png" alt=""></p>
<h2 id="如何切换？"><a href="#如何切换？" class="headerlink" title="如何切换？"></a>如何切换？</h2><p>Spring Boot默认是<code>Logback</code>日志框架，如果需要切换到其他的日志框架应该如何做？</p>
<p>首先我们先看官网的一张图，一切都在图中，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%E7%AC%AC%E5%9B%9B%E5%BC%B9%EF%BC%8C%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%EF%BC%9F/2.png" alt=""></p>
<p><strong>SLF4j只是一个门面，共有两大特性。一是静态绑定、二是桥接。</strong></p>
<p><strong>什么是静态绑定？</strong>：我们以<code>log4j</code>为例。首先我们的application中会使用slf4j的api进行日志记录。我们引入适配层的jar包<code>slf4j-log412.jar</code>及底层日志框架实现<code>log4j.jar</code>。简单的说适配层做的事情就是把<code>slf4j</code>的api转化成<code>log4j</code>的api。通过这样的方式来屏蔽底层框架实现细节。</p>
<p><strong>什么是桥接？</strong>：比如你的application中使用了<code>slf4j</code>，并绑定了<code>logback</code>。但是项目中引入了一个<code>A.jar</code>，<code>A.jar</code>使用的日志框架是<code>log4j</code>。那么有没有方法让<code>slf4j</code>来接管这个<code>A.jar</code>包中使用<code>log4j</code>输出的日志呢？这就用到了桥接包。你只需要引入<code>log4j-over-slf4j.jar</code>并删除<code>log4j.jar</code>就可以实现<code>slf4j</code>对<code>A.jar</code>中<code>log4j</code>的接管.听起来有些不可思议。你可能会想如果删除<code>log4j.jar</code>那<code>A.jar</code>不会报编译错误嘛？答案是不会。因为<code>log4j-over-slf4j.jar</code>实现了<code>log4j</code>几乎所有<code>public</code>的<code>API</code>。但关键方法都被改写了。不再是简单的输出日志，而是将日志输出指令委托给<code>slf4j</code>。</p>
<p><strong>下面就以<code>log4j2</code>为例，切换Spring Boot的日志框架为<code>Log4j2</code>。</strong></p>
<h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>Spring Boot 默认是Logback日志框架，如果想要切换<code>log4j2</code>肯定是要将<code>Logback</code>的依赖移除，只需要排除<code>web</code>模块中的<code>日志启动器</code>即可，如下：<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!-- 去掉springboot默认日志框架logback --&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>排除了默认的logback依赖，肯定是需要引入<code>log4j2</code>的依赖，其实<code>log4j2</code>为了与Spring Boot适配也做了个启动器，不需要在引入其他的jar包了，只需要添加如下依赖即可：<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 引入log4j2依赖 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="指定配置文件"><a href="#指定配置文件" class="headerlink" title="指定配置文件"></a>指定配置文件</h3><p>Spring Boot官方文档已经给出了默认两个log4j2的配置的名称，分别为：<code>log4j2-spring.xml</code>, <code>log4j2.xml</code>，但是建议使用<code>log4j2-spring.xml</code>，因为Spring Boot会做一些扩展，行吧，就整这个放在<code>src/resources</code>文件夹下即可。</p>
<p>另外上篇文章也说过，如果不使用默认的配置名称，则需要在<code>application.properties</code>指定配置文件，如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">logging.config=classpath:logging-config.xml</div></pre></td></tr></table></figure></p>
<h3 id="日志如何配置？"><a href="#日志如何配置？" class="headerlink" title="日志如何配置？"></a>日志如何配置？</h3><p>其实<code>log4j2</code>的一些配置和logback很相似，这里就不再一一介绍，有兴趣的可以去官网查查，直接贴出一些即用的配置，如下：<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="comment">&lt;!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出--&gt;</span></div><div class="line"><span class="comment">&lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">monitorInterval</span>=<span class="string">"5"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!--变量配置--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 格式化输出：%date表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度 %msg：日志消息，%n是换行符--&gt;</span></div><div class="line">        <span class="comment">&lt;!-- %logger&#123;36&#125; 表示 Logger 名字最长36个字符 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"LOG_PATTERN"</span> <span class="attr">value</span>=<span class="string">"%date&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n"</span> /&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 定义日志存储的路径 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"FILE_PATH"</span> <span class="attr">value</span>=<span class="string">"更换为你的日志路径"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"FILE_NAME"</span> <span class="attr">value</span>=<span class="string">"更换为你的项目名"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">appenders</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!--输出日志的格式--&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"$&#123;LOG_PATTERN&#125;"</span>/&gt;</span></div><div class="line">            <span class="comment">&lt;!--控制台只输出level及其以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"info"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">console</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="comment">&lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，适合临时测试用--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">File</span> <span class="attr">name</span>=<span class="string">"Filelog"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;FILE_PATH&#125;/test.log"</span> <span class="attr">append</span>=<span class="string">"false"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"$&#123;LOG_PATTERN&#125;"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">File</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="comment">&lt;!-- 这个会打印出所有的info及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"RollingFileInfo"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;FILE_PATH&#125;/info.log"</span> <span class="attr">filePattern</span>=<span class="string">"$&#123;FILE_PATH&#125;/$&#123;FILE_NAME&#125;-INFO-%d&#123;yyyy-MM-dd&#125;_%i.log.gz"</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"info"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"$&#123;LOG_PATTERN&#125;"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></div><div class="line">                <span class="comment">&lt;!--interval属性用来指定多久滚动一次，默认是1 hour--&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span> <span class="attr">interval</span>=<span class="string">"1"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"10MB"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件开始覆盖--&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">"15"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="comment">&lt;!-- 这个会打印出所有的warn及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"RollingFileWarn"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;FILE_PATH&#125;/warn.log"</span> <span class="attr">filePattern</span>=<span class="string">"$&#123;FILE_PATH&#125;/$&#123;FILE_NAME&#125;-WARN-%d&#123;yyyy-MM-dd&#125;_%i.log.gz"</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"warn"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"$&#123;LOG_PATTERN&#125;"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></div><div class="line">                <span class="comment">&lt;!--interval属性用来指定多久滚动一次，默认是1 hour--&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span> <span class="attr">interval</span>=<span class="string">"1"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"10MB"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件开始覆盖--&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">"15"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="comment">&lt;!-- 这个会打印出所有的error及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"RollingFileError"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;FILE_PATH&#125;/error.log"</span> <span class="attr">filePattern</span>=<span class="string">"$&#123;FILE_PATH&#125;/$&#123;FILE_NAME&#125;-ERROR-%d&#123;yyyy-MM-dd&#125;_%i.log.gz"</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"error"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"$&#123;LOG_PATTERN&#125;"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></div><div class="line">                <span class="comment">&lt;!--interval属性用来指定多久滚动一次，默认是1 hour--&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span> <span class="attr">interval</span>=<span class="string">"1"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"10MB"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件开始覆盖--&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">"15"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;/<span class="name">appenders</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!--Logger节点用来单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等。--&gt;</span></div><div class="line">    <span class="comment">&lt;!--然后定义loggers，只有定义了logger并引入的appender，appender才会生效--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">loggers</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="comment">&lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"org.mybatis"</span> <span class="attr">level</span>=<span class="string">"info"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!--监控系统信息--&gt;</span></div><div class="line">        <span class="comment">&lt;!--若是additivity设为false，则 子Logger 只会在自己的appender里输出，而不会在 父Logger 的appender里输出。--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">Logger</span> <span class="attr">name</span>=<span class="string">"org.springframework"</span> <span class="attr">level</span>=<span class="string">"info"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">Logger</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"Filelog"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"RollingFileInfo"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"RollingFileWarn"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"RollingFileError"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">loggers</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>上面的配置中如果需要使用的话，需要改掉全局变量中的日志路径和项目名称，如下部分：<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"FILE_PATH"</span> <span class="attr">value</span>=<span class="string">"更换为你的日志路径"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"FILE_NAME"</span> <span class="attr">value</span>=<span class="string">"更换为你的项目名"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章介绍了Spring Boot如何切换日志框架以及SLF4j一些内容，如果有所收点点在看关注分享一波，谢谢！！！</p>
<p><strong>作者的上个<code>Mybatis</code>专栏已经结束了，作者特意将全部文章整理成册，关注公众号【码猿技术专栏】回复关键词<code>Mybatis进阶</code>即可领取此册。</strong></p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/myjszl_log.png" alt=""></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 与多数据源的那点事儿~</title>
    <url>/2020/10/21/SpringBoot%E4%B8%8E%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大约在19年的这个时候，老同事公司在做医疗系统，需要和<code>HIS</code>系统对接一些信息，比如患者、医护、医嘱、科室等信息。但是起初并不知道如何与HIS无缝对接，于是向我取经。</p>
<p>最终经过讨论采用了<code>视图对接</code>的方式，大致就是HIS系统提供视图，他们进行对接。</p>
<a id="more"></a>
<h2 id="写这篇文章的目的"><a href="#写这篇文章的目的" class="headerlink" title="写这篇文章的目的"></a>写这篇文章的目的</h2><p>这篇文章将会涉及到Spring Boot 与Mybatis、数据库整合，类似于整合Mybatis与数据库的文章其实网上很多，作者此前也写过一篇文章详细的介绍了一些整合的套路：<a href="https://mp.weixin.qq.com/s/USXciK7mWB2-sud3-g19PA" target="_blank" rel="external">Spring Boot 整合多点套路，少走点弯路~</a>，有兴趣的可以看看。</p>
<h2 id="什么是多数据源？"><a href="#什么是多数据源？" class="headerlink" title="什么是多数据源？"></a>什么是多数据源？</h2><p>最常见的单一应用中最多涉及到一个数据库，即是一个数据源（<code>Datasource</code>）。那么顾名思义，多数据源就是在一个单一应用中涉及到了两个及以上的数据库了。</p>
<p>其实在配置数据源的时候就已经很明确这个定义了，如以下代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Bean</span>(name = <span class="string">"dataSource"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</div><div class="line">    DruidDataSource druidDataSource = <span class="keyword">new</span> DruidDataSource();</div><div class="line">    druidDataSource.setUrl(url);</div><div class="line">    druidDataSource.setUsername(username);</div><div class="line">    druidDataSource.setDriverClassName(driverClassName);</div><div class="line">    druidDataSource.setPassword(password);</div><div class="line">    <span class="keyword">return</span> druidDataSource;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p><code>url</code>、<code>username</code>、<code>password</code>这三个属性已经唯一确定了一个数据库了，<code>DataSource</code>则是依赖这三个创建出来的。则多数据源即是配置多个<code>DataSource</code>（暂且这么理解）。</p>
</blockquote>
<h2 id="何时用到多数据源？"><a href="#何时用到多数据源？" class="headerlink" title="何时用到多数据源？"></a>何时用到多数据源？</h2><p>正如前言介绍到的一个场景，相信大多数做过医疗系统的都会和<code>HIS</code>打交道，为了简化护士以及医生的操作流程，必须要将必要的信息从<code>HIS</code>系统对接过来，据我了解的大致有两种方案如下：</p>
<ol>
<li><code>HIS</code>提供视图，比如医护视图、患者视图等，而此时其他系统只需要定时的从<code>HIS</code>视图中读取数据同步到自己数据库中即可。</li>
<li><code>HIS</code>提供接口，无论是<code>webService</code>还是<code>HTTP</code>形式都是可行的，此时其他系统只需要按照要求调接口即可。</li>
</ol>
<blockquote>
<p>很明显第一种方案涉及到了至少两个数据库了，一个是<code>HIS</code>数据库，一个自己系统的数据库，在单一应用中必然需要用到<strong>多数据源的切换</strong>才能达到目的。</p>
</blockquote>
<p>当然多数据源的使用场景还是有很多的，以上只是简单的一个场景。</p>
<h2 id="整合单一的数据源"><a href="#整合单一的数据源" class="headerlink" title="整合单一的数据源"></a>整合单一的数据源</h2><p>本文使用阿里的数据库连接池<code>druid</code>，添加依赖如下：<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!--druid连接池--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>阿里的数据库连接池非常强大，比如<code>数据监控</code>、<code>数据库加密</code>等等内容，本文仅仅演示与Spring Boot整合的过程，一些其他的功能后续可以自己研究添加。</p>
<p>Druid连接池的<code>starter</code>的自动配置类是<code>DruidDataSourceAutoConfigure</code>，类上标注如下一行注解：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;DruidStatProperties.class, DataSourceProperties.class&#125;)</div></pre></td></tr></table></figure></p>
<blockquote>
<p><code>@EnableConfigurationProperties</code>这个注解使得配置文件中的配置生效并且映射到指定类的属性。</p>
</blockquote>
<p><code>DruidStatProperties</code>中指定的前缀是<code>spring.datasource.druid</code>，这个配置主要是用来设置连接池的一些参数。</p>
<p><code>DataSourceProperties</code>中指定的前缀是<code>spring.datasource</code>，这个主要是用来设置数据库的<code>url</code>、<code>username</code>、<code>password</code>等信息。</p>
<p>因此我们只需要在全局配置文件中指定<strong>数据库的一些配置</strong>以及<strong>连接池的一些配置</strong>信息即可，前缀分别是<code>spring.datasource.druid</code>、<code>spring.datasource</code>，以下是个人随便配置的(<code>application.properties</code>)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">spring.datasource.url=jdbc\:mysql\://120.26.101.xxx\:3306/xxx?useUnicode\=true&amp;characterEncoding\=UTF-8&amp;zeroDateTimeBehavior\=convertToNull&amp;useSSL\=false&amp;allowMultiQueries\=true&amp;serverTimezone=Asia/Shanghai</div><div class="line">spring.datasource.username=root</div><div class="line">spring.datasource.password=xxxx</div><div class="line">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</div><div class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</div><div class="line">#初始化连接大小</div><div class="line">spring.datasource.druid.initial-size=0</div><div class="line">#连接池最大使用连接数量</div><div class="line">spring.datasource.druid.max-active=20</div><div class="line">#连接池最小空闲</div><div class="line">spring.datasource.druid.min-idle=0</div><div class="line">#获取连接最大等待时间</div><div class="line">spring.datasource.druid.max-wait=6000</div><div class="line">spring.datasource.druid.validation-query=SELECT 1</div><div class="line">#spring.datasource.druid.validation-query-timeout=6000</div><div class="line">spring.datasource.druid.test-on-borrow=false</div><div class="line">spring.datasource.druid.test-on-return=false</div><div class="line">spring.datasource.druid.test-while-idle=true</div><div class="line">#配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</div><div class="line">spring.datasource.druid.time-between-eviction-runs-millis=60000</div><div class="line">#置一个连接在池中最小生存的时间，单位是毫秒</div><div class="line">spring.datasource.druid.min-evictable-idle-time-millis=25200000</div><div class="line">#spring.datasource.druid.max-evictable-idle-time-millis=</div><div class="line">#打开removeAbandoned功能,多少时间内必须关闭连接</div><div class="line">spring.datasource.druid.removeAbandoned=true</div><div class="line">#1800秒，也就是30分钟</div><div class="line">spring.datasource.druid.remove-abandoned-timeout=1800</div><div class="line">#&lt;!-- 1800秒，也就是30分钟 --&gt;</div><div class="line">spring.datasource.druid.log-abandoned=true</div><div class="line">spring.datasource.druid.filters=mergeStat</div></pre></td></tr></table></figure>
<blockquote>
<p>在全局配置文件<code>application.properties</code>文件中配置以上的信息即可注入一个数据源到Spring Boot中。其实这仅仅是一种方式，下面介绍另外一种方式。</p>
</blockquote>
<p>在自动配置类中<code>DruidDataSourceAutoConfigure</code>中有如下一段代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>)</div><div class="line">  <span class="meta">@ConditionalOnMissingBean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</div><div class="line">      LOGGER.info(<span class="string">"Init DruidDataSource"</span>);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSourceWrapper();</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p><code>@ConditionalOnMissingBean</code>和<code>@Bean</code>这两个注解的结合，意味着我们可以覆盖，只需要提前在<code>IOC</code>中注入一个<code>DataSource</code>类型的<code>Bean</code>即可。</p>
</blockquote>
<p>因此我们在自定义的配置类中定义如下配置即可：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * <span class="doctag">@Bean</span>：向IOC容器中注入一个Bean</div><div class="line">     * <span class="doctag">@ConfigurationProperties</span>：使得配置文件中以spring.datasource为前缀的属性映射到Bean的属性中</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource"</span>)</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//做一些其他的自定义配置，比如密码加密等......</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>以上介绍了两种数据源的配置方式，第一种比较简单，第二种适合扩展，按需选择。</p>
</blockquote>
<h2 id="整合Mybatis"><a href="#整合Mybatis" class="headerlink" title="整合Mybatis"></a>整合Mybatis</h2><p>Spring Boot 整合Mybatis其实很简单，简单的几步就搞定，首先添加依赖：<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>第二步找到自动配置类<code>MybatisAutoConfiguration</code>，有如下一行代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@EnableConfigurationProperties</span>(MybatisProperties.class)</div></pre></td></tr></table></figure></p>
<blockquote>
<p>老套路了，全局配置文件中配置前缀为<code>mybatis</code>的配置将会映射到该类中的属性。</p>
</blockquote>
<p>可配置的东西很多，比如<code>XML文件的位置</code>、<code>类型处理器</code>等等，如下简单的配置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mybatis.type-handlers-package=com.demo.typehandler</div><div class="line">mybatis.configuration.map-underscore-to-camel-case=true</div></pre></td></tr></table></figure></p>
<p>如果需要通过包扫描的方式注入Mapper，则需要在配置类上加入一个注解：<code>@MapperScan</code>，其中的value属性指定需要扫描的包。</p>
<blockquote>
<p>直接在全局配置文件配置各种属性是一种比较简单的方式，其实的任何组件的整合都有不少于两种的配置方式，下面来介绍下配置类如何配置。</p>
</blockquote>
<p><code>MybatisAutoConfiguration</code>自动配置类有如下一断代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="meta">@ConditionalOnMissingBean</span></div><div class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p><code>@ConditionalOnMissingBean</code>和<code>@Bean</code>真是老搭档了，意味着我们又可以覆盖，只需要在IOC容器中注入<code>SqlSessionFactory（Mybatis六剑客之一生产者）</code>。</p>
</blockquote>
<p>在自定义配置类中注入即可，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * 注入SqlSessionFactory</div><div class="line">    */</div><div class="line">   <span class="meta">@Bean</span>(<span class="string">"sqlSessionFactory1"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">       SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</div><div class="line">       sqlSessionFactoryBean.setDataSource(dataSource);</div><div class="line">       sqlSessionFactoryBean.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver().getResources(<span class="string">"classpath*:/mapper/**/*.xml"</span>));</div><div class="line">       org.apache.ibatis.session.Configuration configuration = <span class="keyword">new</span> org.apache.ibatis.session.Configuration();</div><div class="line">       <span class="comment">// 自动将数据库中的下划线转换为驼峰格式</span></div><div class="line">       configuration.setMapUnderscoreToCamelCase(<span class="keyword">true</span>);</div><div class="line">       configuration.setDefaultFetchSize(<span class="number">100</span>);</div><div class="line">       configuration.setDefaultStatementTimeout(<span class="number">30</span>);</div><div class="line">       sqlSessionFactoryBean.setConfiguration(configuration);</div><div class="line">       <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>以上介绍了配置Mybatis的两种方式，其实在大多数场景中使用第一种已经够用了，至于为什么介绍第二种呢？当然是为了多数据源的整合而做准备了。</p>
</blockquote>
<p>在<code>MybatisAutoConfiguration</code>中有一行很重要的代码，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@ConditionalOnSingleCandidate</span>(DataSource.class)</div></pre></td></tr></table></figure></p>
<blockquote>
<p><code>@ConditionalOnSingleCandidate</code>这个注解的意思是当IOC容器中只有一个候选Bean的实例才会生效。</p>
</blockquote>
<p>这行代码标注在Mybatis的自动配置类中有何含义呢？下面介绍，哈哈哈~<br><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%E7%AC%AC%E5%8D%81%E4%B8%89%E5%BC%B9%EF%BC%8C%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E6%95%B4%E5%90%88/1.jpg" alt=""></p>
<h2 id="多数据源如何整合？"><a href="#多数据源如何整合？" class="headerlink" title="多数据源如何整合？"></a>多数据源如何整合？</h2><p>上文留下的问题：为什么的Mybatis自动配置上标注如下一行代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@ConditionalOnSingleCandidate</span>(DataSource.class)</div></pre></td></tr></table></figure></p>
<blockquote>
<p>以上这行代码的言外之意：当IOC容器中只有一个数据源DataSource，这个自动配置类才会生效。</p>
</blockquote>
<p><strong>哦？照这样搞，多数据源是不能用Mybatis吗？</strong></p>
<p>可能大家会有一个误解，认为多数据源就是多个的<code>DataSource</code>并存的，当然这样说也不是不正确。</p>
<blockquote>
<p>多数据源的情况下并不是多个数据源并存的，Spring提供了<code>AbstractRoutingDataSource</code>这样一个抽象类，使得能够在多数据源的情况下任意切换，相当于一个<strong>动态路由</strong>的作用，作者称之为<code>动态数据源</code>。因此Mybatis只需要配置这个动态数据源即可。</p>
</blockquote>
<h3 id="什么是动态数据源？"><a href="#什么是动态数据源？" class="headerlink" title="什么是动态数据源？"></a>什么是动态数据源？</h3><p>动态数据源简单的说就是能够自由切换的数据源，类似于一个动态路由的感觉，Spring 提供了一个抽象类<code>AbstractRoutingDataSource</code>，这个抽象类中哟一个属性，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> Map&lt;Object, Object&gt; targetDataSources;</div></pre></td></tr></table></figure></p>
<blockquote>
<p><code>targetDataSources</code>是一个<code>Map</code>结构，所有需要切换的数据源都存放在其中，根据指定的<code>KEY</code>进行切换。当然还有一个默认的数据源。</p>
</blockquote>
<p><code>AbstractRoutingDataSource</code>这个抽象类中有一个抽象方法需要子类实现，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure></p>
<blockquote>
<p><code>determineCurrentLookupKey()</code>这个方法的返回值决定了需要切换的数据源的<code>KEY</code>，就是根据这个<code>KEY</code>从<code>targetDataSources</code>取值（数据源）。</p>
</blockquote>
<h3 id="数据源切换如何保证线程隔离？"><a href="#数据源切换如何保证线程隔离？" class="headerlink" title="数据源切换如何保证线程隔离？"></a>数据源切换如何保证线程隔离？</h3><p>数据源属于一个公共的资源，在多线程的情况下如何保证线程隔离呢？不能我这边切换了影响其他线程的执行。</p>
<blockquote>
<p>说到线程隔离，自然会想到<code>ThreadLocal</code>了，将切换数据源的<code>KEY</code>（用于从<code>targetDataSources</code>中取值）存储在<code>ThreadLocal</code>中，执行结束之后清除即可。</p>
</blockquote>
<p>单独封装了一个<code>DataSourceHolder</code>，内部使用<code>ThreadLocal</code>隔离线程，代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 使用ThreadLocal存储切换数据源后的KEY</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceHolder</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//线程  本地环境</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; dataSources = <span class="keyword">new</span> InheritableThreadLocal();</div><div class="line"></div><div class="line">    <span class="comment">//设置数据源</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(String datasource)</span> </span>&#123;</div><div class="line">        dataSources.set(datasource);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//获取数据源</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDataSource</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> dataSources.get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//清除数据源</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearDataSource</span><span class="params">()</span> </span>&#123;</div><div class="line">        dataSources.remove();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="如何构造一个动态数据源？"><a href="#如何构造一个动态数据源？" class="headerlink" title="如何构造一个动态数据源？"></a>如何构造一个动态数据源？</h3><p>上文说过只需继承一个抽象类<code>AbstractRoutingDataSource</code>，重写其中的一个方法<code>determineCurrentLookupKey()</code>即可。代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 动态数据源，继承AbstractRoutingDataSource</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractRoutingDataSource</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 返回需要使用的数据源的key，将会按照这个KEY从Map获取对应的数据源（切换）</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//从ThreadLocal中取出KEY</span></div><div class="line">        <span class="keyword">return</span> DataSourceHolder.getDataSource();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造方法填充Map，构建多数据源</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicDataSource</span><span class="params">(DataSource defaultTargetDataSource, Map&lt;Object, Object&gt; targetDataSources)</span> </span>&#123;</div><div class="line">        <span class="comment">//默认的数据源，可以作为主数据源</span></div><div class="line">        <span class="keyword">super</span>.setDefaultTargetDataSource(defaultTargetDataSource);</div><div class="line">        <span class="comment">//目标数据源</span></div><div class="line">        <span class="keyword">super</span>.setTargetDataSources(targetDataSources);</div><div class="line">        <span class="comment">//执行afterPropertiesSet方法，完成属性的设置</span></div><div class="line">        <span class="keyword">super</span>.afterPropertiesSet();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码很简单，分析如下：</p>
<ol>
<li>一个多参的构造方法，指定了默认的数据源和目标数据源。</li>
<li>重写<code>determineCurrentLookupKey()</code>方法，返回数据源对应的<code>KEY</code>，这里是直接从<code>ThreadLocal</code>中取值，就是上文封装的<code>DataSourceHolder</code>。</li>
</ol>
<h3 id="定义一个注解"><a href="#定义一个注解" class="headerlink" title="定义一个注解"></a>定义一个注解</h3><p>为了操作方便且低耦合，不能每次需要切换的数据源的时候都要手动调一下接口吧，可以定义一个切换数据源的注解，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 切换数据源的注解</div><div class="line"> */</div><div class="line"><span class="meta">@Target</span>(value = ElementType.METHOD)</div><div class="line"><span class="meta">@Retention</span>(value = RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SwitchSource &#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 默认切换的数据源KEY</div><div class="line">     */</div><div class="line">    String DEFAULT_NAME = <span class="string">"hisDataSource"</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 需要切换到数据的KEY</div><div class="line">     */</div><div class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> DEFAULT_NAME</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注解中只有一个<code>value</code>属性，指定了需要切换数据源的<code>KEY</code>。</p>
<p>有注解还不行，当然还要有切面，代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Aspect</span></div><div class="line"><span class="comment">//优先级设置到最高</span></div><div class="line"><span class="meta">@Order</span>(Ordered.HIGHEST_PRECEDENCE)</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="meta">@Slf</span>4j</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceAspect</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@annotation(SwitchSource)"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 在方法执行之前切换到指定的数据源</div><div class="line">     * <span class="doctag">@param</span> joinPoint</div><div class="line">     */</div><div class="line">    <span class="meta">@Before</span>(value = <span class="string">"pointcut()"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeOpt</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</div><div class="line">        <span class="comment">/*因为是对注解进行切面，所以这边无需做过多判定，直接获取注解的值，进行环绕，将数据源设置成远方，然后结束后，清楚当前线程数据源*/</span></div><div class="line">        Method method = ((MethodSignature) joinPoint.getSignature()).getMethod();</div><div class="line">        SwitchSource switchSource = method.getAnnotation(SwitchSource.class);</div><div class="line">        log.info(<span class="string">"[Switch DataSource]:"</span> + switchSource.value());</div><div class="line">        DataSourceHolder.setDataSource(switchSource.value());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 方法执行之后清除掉ThreadLocal中存储的KEY，这样动态数据源会使用默认的数据源</div><div class="line">     */</div><div class="line">    <span class="meta">@After</span>(value = <span class="string">"pointcut()"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterOpt</span><span class="params">()</span> </span>&#123;</div><div class="line">        DataSourceHolder.clearDataSource();</div><div class="line">        log.info(<span class="string">"[Switch Default DataSource]"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个<code>ASPECT</code>很容易理解，<code>beforeOpt()</code>在方法之前执行，取值<code>@SwitchSource</code>中value属性设置到<code>ThreadLocal</code>中;<code>afterOpt()</code>方法在方法执行之后执行，清除掉<code>ThreadLocal</code>中的<code>KEY</code>，保证了如果不切换数据源，则用默认的数据源。</p>
<h3 id="如何与Mybatis整合？"><a href="#如何与Mybatis整合？" class="headerlink" title="如何与Mybatis整合？"></a>如何与Mybatis整合？</h3><p>单一数据源与Mybatis整合上文已经详细讲解了，数据源<code>DataSource</code>作为参数构建了<code>SqlSessionFactory</code>，同样的思想，只需要把这个数据源换成动态数据源即可。注入的代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * 创建动态数据源的SqlSessionFactory，传入的是动态数据源</div><div class="line">     * <span class="doctag">@Primary</span>这个注解很重要，如果项目中存在多个SqlSessionFactory，这个注解一定要加上</div><div class="line">     */</div><div class="line">    <span class="meta">@Primary</span></div><div class="line">    <span class="meta">@Bean</span>(<span class="string">"sqlSessionFactory2"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactoryBean</span><span class="params">(DynamicDataSource dynamicDataSource)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</div><div class="line">        sqlSessionFactoryBean.setDataSource(dynamicDataSource);</div><div class="line">        org.apache.ibatis.session.Configuration configuration = <span class="keyword">new</span> org.apache.ibatis.session.Configuration();</div><div class="line">        configuration.setMapUnderscoreToCamelCase(<span class="keyword">true</span>);</div><div class="line">        configuration.setDefaultFetchSize(<span class="number">100</span>);</div><div class="line">        configuration.setDefaultStatementTimeout(<span class="number">30</span>);</div><div class="line">        sqlSessionFactoryBean.setConfiguration(configuration);</div><div class="line">        <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>与Mybatis整合很简单，只需要把数据源替换成自定义的动态数据源<code>DynamicDataSource</code>。</p>
</blockquote>
<p>那么动态数据源如何注入到IOC容器中呢？看上文自定义的<code>DynamicDataSource</code>构造方法，肯定需要两个数据源了，因此必须先注入两个或者多个数据源到IOC容器中，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * <span class="doctag">@Bean</span>：向IOC容器中注入一个Bean</div><div class="line">    * <span class="doctag">@ConfigurationProperties</span>：使得配置文件中以spring.datasource为前缀的属性映射到Bean的属性中</div><div class="line">    */</div><div class="line">   <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource"</span>)</div><div class="line">   <span class="meta">@Bean</span>(<span class="string">"dataSource"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span></span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 向IOC容器中注入另外一个数据源</div><div class="line">    * 全局配置文件中前缀是spring.datasource.his</div><div class="line">    */</div><div class="line">   <span class="meta">@Bean</span>(name = SwitchSource.DEFAULT_NAME)</div><div class="line">   <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource.his"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> DataSource <span class="title">hisDataSource</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> DataSourceBuilder.create().build();</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>以上构建的两个数据源，一个是<strong>默认的数据源</strong>，一个是需要<strong>切换到的数据源（<code>targetDataSources</code>）</strong>，这样就组成了动态数据源了。数据源的一些信息，比如<code>url</code>，<code>username</code>需要自己在全局配置文件中根据指定的前缀配置即可，代码不再贴出。</p>
</blockquote>
<p>动态数据源的注入代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * 创建动态数据源的SqlSessionFactory，传入的是动态数据源</div><div class="line">     * <span class="doctag">@Primary</span>这个注解很重要，如果项目中存在多个SqlSessionFactory，这个注解一定要加上</div><div class="line">     */</div><div class="line">    <span class="meta">@Primary</span></div><div class="line">    <span class="meta">@Bean</span>(<span class="string">"sqlSessionFactory2"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactoryBean</span><span class="params">(DynamicDataSource dynamicDataSource)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</div><div class="line">        sqlSessionFactoryBean.setDataSource(dynamicDataSource);</div><div class="line">        org.apache.ibatis.session.Configuration configuration = <span class="keyword">new</span> org.apache.ibatis.session.Configuration();</div><div class="line">        configuration.setMapUnderscoreToCamelCase(<span class="keyword">true</span>);</div><div class="line">        configuration.setDefaultFetchSize(<span class="number">100</span>);</div><div class="line">        configuration.setDefaultStatementTimeout(<span class="number">30</span>);</div><div class="line">        sqlSessionFactoryBean.setConfiguration(configuration);</div><div class="line">        <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>这里还有一个问题：IOC中存在多个数据源了，那么事务管理器怎么办呢？它也懵逼了，到底选择哪个数据源呢？因此事务管理器肯定还是要重新配置的。</p>
</blockquote>
<p>事务管理器此时管理的数据源将是动态数据源<code>DynamicDataSource</code>，配置如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * 重写事务管理器，管理动态数据源</div><div class="line">  */</div><div class="line"> <span class="meta">@Primary</span></div><div class="line"> <span class="meta">@Bean</span>(value = <span class="string">"transactionManager2"</span>)</div><div class="line"> <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">annotationDrivenTransactionManager</span><span class="params">(DynamicDataSource dataSource)</span> </span>&#123;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>至此，Mybatis与多数据源的整合就完成了。</p>
<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>使用也是很简单，在需要切换数据源的方法上方标注<code>@SwitchSource</code>切换到指定的数据源即可，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//不开启事务</span></div><div class="line"><span class="meta">@Transactional</span>(propagation = Propagation.NOT_SUPPORTED)</div><div class="line"><span class="comment">//切换到HIS的数据源</span></div><div class="line"><span class="meta">@SwitchSource</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;DeptInfo&gt; <span class="title">list</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> hisDeptInfoMapper.listDept();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样只要执行到这方法将会切换到<code>HIS</code>的数据源，方法执行结束之后将会清除，执行默认的数据源。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章讲了Spring Boot与单数据源、Mybatis、多数据源之间的整合，希望这篇文章能够帮助读者理解多数据源的整合，虽说用的不多，但是在有些领域仍然是比较重要的。</p>
<p>原创不易，点点赞分享一波，谢谢支持~</p>
<blockquote>
<p><strong>源码已经上传，需要源码的朋友公众号回复关键词<code>多数据源</code>。</strong></p>
</blockquote>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png" alt=""></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot整合JSR303实现参数校验~</title>
    <url>/2020/10/27/SpringBoot%E6%95%B4%E5%90%88JSR303/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不知不觉<code>Spring Boot</code>专栏文章已经写到第十四章了，无论写的好与不好，作者都在尽力写的详细，写的与其它的文章不同，每一章都不是浅尝辄止。如果前面的文章没有看过的朋友，<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&amp;action=getalbum&amp;album_id=1532834475389288449&amp;scene=173&amp;from_msgid=2247485200&amp;from_itemidx=1&amp;count=10#wechat_redirect&amp;scene=126&amp;subscene=0&amp;sessionid=1603793746&amp;enterid=1603793755" target="_blank" rel="external">点击这里前往</a>。</p>
<p>今天介绍一下 Spring Boot 如何优雅的整合<code>JSR-303</code>进行参数校验，说到参数校验可能都用过，但是你真的会用吗？网上的教程很多，大多是简单的介绍。</p>
<a id="more"></a>
<h2 id="什么是-JSR-303？"><a href="#什么是-JSR-303？" class="headerlink" title="什么是 JSR-303？"></a>什么是 JSR-303？</h2><p><code>JSR-303</code> 是 <code>JAVA EE 6</code> 中的一项子规范，叫做 <code>Bean Validation</code>。</p>
<p><code>Bean Validation</code> 为 <code>JavaBean</code> 验证定义了相应的<code>元数据模型</code>和<code>API</code>。缺省的元数据是<code>Java Annotations</code>，通过使用 <code>XML</code> 可以对原有的元数据信息进行覆盖和扩展。在应用程序中，通过使用<code>Bean Validation</code> 或是你自己定义的 <code>constraint</code>，例如 <code>@NotNull</code>, <code>@Max</code>, <code>@ZipCode</code> ， 就可以确保数据模型（<code>JavaBean</code>）的正确性。<code>constraint</code> 可以附加到字段，<code>getter</code> 方法，类或者接口上面。对于一些特定的需求，用户可以很容易的开发定制化的 <code>constraint</code>。<code>Bean Validation</code> 是一个运行时的数据验证框架，在验证之后验证的错误信息会被马上返回。</p>
<h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>Spring Boot整合JSR-303只需要添加一个<code>starter</code>即可，如下：<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="内嵌的注解有哪些？"><a href="#内嵌的注解有哪些？" class="headerlink" title="内嵌的注解有哪些？"></a>内嵌的注解有哪些？</h2><p><code>Bean Validation</code> 内嵌的注解很多，基本实际开发中已经够用了，注解如下：</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>详细信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Null</td>
<td>被注释的元素必须为 null</td>
</tr>
<tr>
<td>@NotNull</td>
<td>被注释的元素必须不为 null</td>
</tr>
<tr>
<td>@AssertTrue</td>
<td>被注释的元素必须为 true</td>
</tr>
<tr>
<td>@AssertFalse</td>
<td>被注释的元素必须为 false</td>
</tr>
<tr>
<td>@Min(value)</td>
<td>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</td>
</tr>
<tr>
<td>@Max(value)</td>
<td>被注释的元素必须是一个数字，其值必须小于等于指定的最大值</td>
</tr>
<tr>
<td>@DecimalMin(value)</td>
<td>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</td>
</tr>
<tr>
<td>@DecimalMax(value)</td>
<td>被注释的元素必须是一个数字，其值必须小于等于指定的最大值</td>
</tr>
<tr>
<td>@Size(max, min)</td>
<td>被注释的元素的大小必须在指定的范围内</td>
</tr>
<tr>
<td>@Digits (integer, fraction)</td>
<td>被注释的元素必须是一个数字，其值必须在可接受的范围内</td>
</tr>
<tr>
<td>@Past</td>
<td>被注释的元素必须是一个过去的日期</td>
</tr>
<tr>
<td>@Future</td>
<td>被注释的元素必须是一个将来的日期</td>
</tr>
<tr>
<td>@Pattern(value)</td>
<td>被注释的元素必须符合指定的正则表达式</td>
</tr>
</tbody>
</table>
<blockquote>
<p>以上是<code>Bean Validation</code>的内嵌的注解，但是<code>Hibernate Validator</code>在原有的基础上也内嵌了几个注解，如下。</p>
</blockquote>
<table>
<thead>
<tr>
<th>注解</th>
<th>详细信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Email</td>
<td>被注释的元素必须是电子邮箱地址</td>
</tr>
<tr>
<td>@Length</td>
<td>被注释的字符串的大小必须在指定的范围内</td>
</tr>
<tr>
<td>@NotEmpty</td>
<td>被注释的字符串的必须非空</td>
</tr>
<tr>
<td>@Range</td>
<td>被注释的元素必须在合适的范围内</td>
</tr>
</tbody>
</table>
<h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><p>参数校验分为<strong>简单校验</strong>、<strong>嵌套校验</strong>、<strong>分组校验</strong>。</p>
<h3 id="简单校验"><a href="#简单校验" class="headerlink" title="简单校验"></a>简单校验</h3><p>简单的校验即是没有嵌套属性，直接在需要的元素上标注约束注解即可。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleDTO</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"文章id不能为空"</span>)</div><div class="line">    <span class="meta">@Min</span>(value = <span class="number">1</span>,message = <span class="string">"文章ID不能为负数"</span>)</div><div class="line">    <span class="keyword">private</span> Integer id;</div><div class="line"></div><div class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"文章内容不能为空"</span>)</div><div class="line">    <span class="keyword">private</span> String content;</div><div class="line"></div><div class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"作者Id不能为空"</span>)</div><div class="line">    <span class="keyword">private</span> String authorId;</div><div class="line"></div><div class="line">    <span class="meta">@Future</span>(message = <span class="string">"提交时间不能为过去时间"</span>)</div><div class="line">    <span class="keyword">private</span> Date submitTime;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>同一个属性可以指定多个约束，比如<code>@NotNull</code>和<code>@MAX</code>,其中的<code>message</code>属性指定了约束条件不满足时的提示信息。</p>
</blockquote>
<p>以上约束标记完成之后，要想完成校验，需要在<code>controller</code>层的接口标注<code>@Valid</code>注解以及声明一个<code>BindingResult</code>类型的参数来接收校验的结果。</p>
<p>下面简单的演示下添加文章的接口，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * 添加文章</div><div class="line">     */</div><div class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/add"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(@Valid @RequestBody ArticleDTO articleDTO, BindingResult bindingResult)</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</div><div class="line">        <span class="comment">//如果有错误提示信息</span></div><div class="line">        <span class="keyword">if</span> (bindingResult.hasErrors()) &#123;</div><div class="line">            Map&lt;String , String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">            bindingResult.getFieldErrors().forEach( (item) -&gt; &#123;</div><div class="line">                String message = item.getDefaultMessage();</div><div class="line">                String field = item.getField();</div><div class="line">                map.put( field , message );</div><div class="line">            &#125; );</div><div class="line">            <span class="comment">//返回提示信息</span></div><div class="line">            <span class="keyword">return</span> objectMapper.writeValueAsString(map);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>仅仅在属性上添加了约束注解还不行，还需在接口参数上标注<code>@Valid</code>注解并且声明一个<code>BindingResult</code>类型的参数来接收校验结果。</p>
</blockquote>
<h3 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h3><p>举个栗子：上传文章不需要传文章<code>ID</code>，但是修改文章需要上传文章<code>ID</code>，并且用的都是同一个<code>DTO</code>接收参数，此时的约束条件该如何写呢？</p>
<p>此时就需要对这个文章<code>ID</code>进行分组校验，上传文章接口是一个分组，不需要执行<code>@NotNull</code>校验，修改文章的接口是一个分组，需要执行<code>@NotNull</code>的校验。</p>
<blockquote>
<p>所有的校验注解都有一个<code>groups</code>属性用来指定分组，<code>Class&lt;?&gt;[]</code>类型，没有实际意义，因此只需要定义一个或者多个接口用来区分即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleDTO</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 文章ID只在修改的时候需要检验，因此指定groups为修改的分组</div><div class="line">     */</div><div class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"文章id不能为空"</span>,groups = UpdateArticleDTO.class )</div><div class="line">    <span class="meta">@Min</span>(value = <span class="number">1</span>,message = <span class="string">"文章ID不能为负数"</span>,groups = UpdateArticleDTO.class)</div><div class="line">    <span class="keyword">private</span> Integer id;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 文章内容添加和修改都是必须校验的，groups需要指定两个分组</div><div class="line">     */</div><div class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"文章内容不能为空"</span>,groups = &#123;AddArticleDTO.class,UpdateArticleDTO.class&#125;)</div><div class="line">    <span class="keyword">private</span> String content;</div><div class="line"></div><div class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"作者Id不能为空"</span>,groups = AddArticleDTO.class)</div><div class="line">    <span class="keyword">private</span> String authorId;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 提交时间是添加和修改都需要校验的，因此指定groups两个</div><div class="line">     */</div><div class="line">    <span class="meta">@Future</span>(message = <span class="string">"提交时间不能为过去时间"</span>,groups = &#123;AddArticleDTO.class,UpdateArticleDTO.class&#125;)</div><div class="line">    <span class="keyword">private</span> Date submitTime;</div><div class="line">    </div><div class="line">    <span class="comment">//修改文章的分组</span></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UpdateArticleDTO</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">//添加文章的分组</span></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AddArticleDTO</span></span>&#123;&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>JSR303本身的<code>@Valid</code>并不支持分组校验，但是Spring在其基础提供了一个注解<code>@Validated</code>支持分组校验。<code>@Validated</code>这个注解<code>value</code>属性指定需要校验的分组。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * 添加文章</div><div class="line">     * <span class="doctag">@Validated</span>：这个注解指定校验的分组信息</div><div class="line">     */</div><div class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/add"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(@Validated(value = ArticleDTO.AddArticleDTO.class)</span> @RequestBody ArticleDTO articleDTO, BindingResult bindingResult) <span class="keyword">throws</span> JsonProcessingException </span>&#123;</div><div class="line">        <span class="comment">//如果有错误提示信息</span></div><div class="line">        <span class="keyword">if</span> (bindingResult.hasErrors()) &#123;</div><div class="line">            Map&lt;String , String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">            bindingResult.getFieldErrors().forEach( (item) -&gt; &#123;</div><div class="line">                String message = item.getDefaultMessage();</div><div class="line">                String field = item.getField();</div><div class="line">                map.put( field , message );</div><div class="line">            &#125; );</div><div class="line">            <span class="comment">//返回提示信息</span></div><div class="line">            <span class="keyword">return</span> objectMapper.writeValueAsString(map);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="嵌套校验"><a href="#嵌套校验" class="headerlink" title="嵌套校验"></a>嵌套校验</h3><p>嵌套校验简单的解释就是一个实体中包含另外一个实体，并且这两个或者多个实体都需要校验。</p>
<p>举个栗子：文章可以有一个或者多个分类，作者在提交文章的时候必须指定文章分类，而分类是单独一个实体，有<code>分类ID</code>、<code>名称</code>等等。大致的结构如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleDTO</span></span>&#123;</div><div class="line">  ...文章的一些属性.....</div><div class="line">  </div><div class="line">  <span class="comment">//分类的信息</span></div><div class="line">  <span class="keyword">private</span> CategoryDTO categoryDTO;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此时文章和分类的属性都需要校验，这种就叫做嵌套校验。</p>
<blockquote>
<p>嵌套校验很简单，只需要在嵌套的实体属性标注<code>@Valid</code>注解，则其中的属性也将会得到校验，否则不会校验。</p>
</blockquote>
<p>如下<strong>文章分类实体类校验</strong>：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 文章分类</div><div class="line"> */</div><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CategoryDTO</span> </span>&#123;</div><div class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"分类ID不能为空"</span>)</div><div class="line">    <span class="meta">@Min</span>(value = <span class="number">1</span>,message = <span class="string">"分类ID不能为负数"</span>)</div><div class="line">    <span class="keyword">private</span> Integer id;</div><div class="line"></div><div class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"分类名称不能为空"</span>)</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>文章的实体类中有个嵌套的文章分类<code>CategoryDTO</code>属性，需要使用<code>@Valid</code>标注才能嵌套校验，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleDTO</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"文章内容不能为空"</span>)</div><div class="line">    <span class="keyword">private</span> String content;</div><div class="line"></div><div class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"作者Id不能为空"</span>)</div><div class="line">    <span class="keyword">private</span> String authorId;</div><div class="line"></div><div class="line">    <span class="meta">@Future</span>(message = <span class="string">"提交时间不能为过去时间"</span>)</div><div class="line">    <span class="keyword">private</span> Date submitTime;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@Valid</span>这个注解指定CategoryDTO中的属性也需要校验</div><div class="line">     */</div><div class="line">    <span class="meta">@Valid</span></div><div class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"分类不能为空"</span>)</div><div class="line">    <span class="keyword">private</span> CategoryDTO categoryDTO;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p><code>Controller</code>层的添加文章的接口同上，需要使用<code>@Valid</code>或者<code>@Validated</code>标注入参，同时需要定义一个<code>BindingResult</code>的参数接收校验结果。</p>
<blockquote>
<p>嵌套校验针对<strong>分组查询</strong>仍然生效，如果嵌套的实体类（比如<code>CategoryDTO</code>）中的校验的属性和接口中<code>@Validated</code>注解指定的分组不同，则不会校验。</p>
</blockquote>
<p><code>JSR-303</code>针对<code>集合</code>的嵌套校验也是可行的，比如<code>List</code>的嵌套校验，同样需要在属性上标注一个<code>@Valid</code>注解才会生效，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleDTO</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@Valid</span>这个注解标注在集合上，将会针对集合中每个元素进行校验</div><div class="line">     */</div><div class="line">    <span class="meta">@Valid</span></div><div class="line">    <span class="meta">@Size</span>(min = <span class="number">1</span>,message = <span class="string">"至少一个分类"</span>)</div><div class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"分类不能为空"</span>)</div><div class="line">    <span class="keyword">private</span> List&lt;CategoryDTO&gt; categoryDTOS;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>总结：嵌套校验只需要在需要校验的元素（单个或者集合）上添加<code>@Valid</code>注解，接口层需要使用<code>@Valid</code>或者<code>@Validated</code>注解标注入参。</p>
</blockquote>
<h2 id="如何接收校验结果？"><a href="#如何接收校验结果？" class="headerlink" title="如何接收校验结果？"></a>如何接收校验结果？</h2><p>接收校验的结果的方式很多，不过实际开发中最好选择一个优雅的方式，下面介绍常见的两种方式。</p>
<h3 id="BindingResult-接收"><a href="#BindingResult-接收" class="headerlink" title="BindingResult 接收"></a>BindingResult 接收</h3><p>这种方式需要在<code>Controller</code>层的每个接口方法参数中指定，Validator会将校验的信息自动封装到其中。这也是上面例子中一直用的方式。如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@PostMapping</span>(<span class="string">"/add"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(@Valid @RequestBody ArticleDTO articleDTO, BindingResult bindingResult)</span></span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>这种方式的弊端很明显，每个接口方法参数都要声明，同时每个方法都要处理校验信息，显然不现实，舍弃。</p>
<blockquote>
<p>此种方式还有一个优化的方案：使用<code>AOP</code>，在<code>Controller</code>接口方法执行之前处理<code>BindingResult</code>的消息提示，不过这种方案仍然<strong>不推荐使用</strong>。</p>
</blockquote>
<h3 id="全局异常捕捉"><a href="#全局异常捕捉" class="headerlink" title="全局异常捕捉"></a>全局异常捕捉</h3><p>参数在校验失败的时候会抛出的<code>MethodArgumentNotValidException</code>或者<code>BindException</code>两种异常，可以在全局的异常处理器中捕捉到这两种异常，将提示信息或者自定义信息返回给客户端。</p>
<p>全局异常捕捉之前有单独写过一篇文章，不理解的可以看<a href="https://mp.weixin.qq.com/s/EMmqcdPPfWqHuKRHbct7WA" target="_blank" rel="external">满屏的try-catch，你不瘆得慌？</a>。</p>
<p>作者这里就不再详细的贴出其他的异常捕获了，仅仅贴一下参数校验的异常捕获（<strong>仅仅举个例子，具体的返回信息需要自己封装</strong>），如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@RestControllerAdvice</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionRsHandler</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 参数校验异常步骤</div><div class="line">     */</div><div class="line">    <span class="meta">@ExceptionHandler</span>(value= &#123;MethodArgumentNotValidException.class , BindException.class&#125;)</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">onException</span><span class="params">(Exception e)</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</div><div class="line">        BindingResult bindingResult = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> MethodArgumentNotValidException) &#123;</div><div class="line">            bindingResult = ((MethodArgumentNotValidException)e).getBindingResult();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> BindException) &#123;</div><div class="line">            bindingResult = ((BindException)e).getBindingResult();</div><div class="line">        &#125;</div><div class="line">        Map&lt;String,String&gt; errorMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</div><div class="line">        bindingResult.getFieldErrors().forEach((fieldError)-&gt;</div><div class="line">                errorMap.put(fieldError.getField(),fieldError.getDefaultMessage())</div><div class="line">        );</div><div class="line">        <span class="keyword">return</span> objectMapper.writeValueAsString(errorMap);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="spring-boot-starter-validation做了什么？"><a href="#spring-boot-starter-validation做了什么？" class="headerlink" title="spring-boot-starter-validation做了什么？"></a>spring-boot-starter-validation做了什么？</h2><p>这个启动器的自动配置类是<code>ValidationAutoConfiguration</code>，最重要的代码就是注入了一个<code>Validator</code>（校验器）的实现类，代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line">	<span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</div><div class="line">	<span class="meta">@ConditionalOnMissingBean</span>(Validator.class)</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalValidatorFactoryBean <span class="title">defaultValidator</span><span class="params">()</span> </span>&#123;</div><div class="line">		LocalValidatorFactoryBean factoryBean = <span class="keyword">new</span> LocalValidatorFactoryBean();</div><div class="line">		MessageInterpolatorFactory interpolatorFactory = <span class="keyword">new</span> MessageInterpolatorFactory();</div><div class="line">		factoryBean.setMessageInterpolator(interpolatorFactory.getObject());</div><div class="line">		<span class="keyword">return</span> factoryBean;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>这个有什么用呢？<code>Validator</code>这个接口定义了校验的方法，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line">&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validate(T object, Class&lt;?&gt;... groups);</div><div class="line"></div><div class="line"></div><div class="line">&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateProperty(T object,</div><div class="line">													 String propertyName,</div><div class="line">													 Class&lt;?&gt;... groups);</div><div class="line">                           </div><div class="line">&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateValue(Class&lt;T&gt; beanType,</div><div class="line">												  String propertyName,</div><div class="line">												  Object value,</div><div class="line">												  Class&lt;?&gt;... groups);</div><div class="line">......</div></pre></td></tr></table></figure></p>
<blockquote>
<p>这个<code>Validator</code>可以用来自定义实现自己的校验逻辑，有些大公司完全不用JSR-303提供的<code>@Valid</code>注解，而是有一套自己的实现，其实本质就是利用<code>Validator</code>这个接口的实现。</p>
</blockquote>
<h2 id="如何自定义校验？"><a href="#如何自定义校验？" class="headerlink" title="如何自定义校验？"></a>如何自定义校验？</h2><p>虽说在日常的开发中内置的约束注解已经够用了，但是仍然有些时候不能满足需求，需要自定义一些校验约束。</p>
<p><strong>举个栗子：有这样一个例子，传入的数字要在列举的值范围中，否则校验失败。</strong></p>
<h3 id="自定义校验注解"><a href="#自定义校验注解" class="headerlink" title="自定义校验注解"></a>自定义校验注解</h3><p>首先需要自定义一个校验注解，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Constraint</span>(validatedBy = &#123; EnumValuesConstraintValidator.class&#125;)</div><div class="line"><span class="meta">@Target</span>(&#123; METHOD, FIELD, ANNOTATION_TYPE &#125;)</div><div class="line"><span class="meta">@Retention</span>(RUNTIME)</div><div class="line"><span class="meta">@NotNull</span>(message = <span class="string">"不能为空"</span>)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnumValues &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 提示消息</div><div class="line">     */</div><div class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "传入的值不在范围内"</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 分组</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123; &#125;;</div><div class="line"></div><div class="line">    Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123; &#125;;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 可以传入的值</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="keyword">int</span>[] values() <span class="keyword">default</span> &#123; &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据<code>Bean Validation API</code> 规范的要求有如下三个属性是必须的：</p>
<ol>
<li><code>message</code>：定义消息模板，校验失败时输出</li>
<li><code>groups</code>：用于校验分组</li>
<li><code>payload</code>：<code>Bean Validation API</code> 的使用者可以通过此属性来给约束条件指定严重级别. 这个属性并不被API自身所使用。</li>
</ol>
<p>除了以上三个必须要的属性，添加了一个<code>values</code>属性用来接收限制的范围。</p>
<p>该校验注解头上标注的如下一行代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Constraint</span>(validatedBy = &#123; EnumValuesConstraintValidator.class&#125;)</div></pre></td></tr></table></figure></p>
<p>这个<code>@Constraint</code>注解指定了通过哪个校验器去校验。</p>
<blockquote>
<p>自定义校验注解可以复用内嵌的注解，比如<code>@EnumValues</code>注解头上标注了一个<code>@NotNull</code>注解，这样<code>@EnumValues</code>就兼具了<code>@NotNull</code>的功能。</p>
</blockquote>
<h3 id="自定义校验器"><a href="#自定义校验器" class="headerlink" title="自定义校验器"></a>自定义校验器</h3><p><code>@Constraint</code>注解指定了校验器为<code>EnumValuesConstraintValidator</code>，因此需要自定义一个。</p>
<p>自定义校验器需要实现<code>ConstraintValidator&lt;A extends Annotation, T&gt;</code>这个接口，第一个泛型是<code>校验注解</code>，第二个是<code>参数类型</code>。代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 校验器</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumValuesConstraintValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">EnumValues</span>,<span class="title">Integer</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 存储枚举的值</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span>  Set&lt;Integer&gt; ints=<span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 初始化方法</div><div class="line">     * <span class="doctag">@param</span> enumValues 校验的注解</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(EnumValues enumValues)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : enumValues.values()) &#123;</div><div class="line">            ints.add(value);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> value  入参传的值</div><div class="line">     * <span class="doctag">@param</span> context</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(Integer value, ConstraintValidatorContext context)</span> </span>&#123;</div><div class="line">        <span class="comment">//判断是否包含这个值</span></div><div class="line">        <span class="keyword">return</span> ints.contains(value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>如果约束注解需要对其他数据类型进行校验，则可以的自定义对应数据类型的校验器，然后在约束注解头上的<code>@Constraint</code>注解中指定其他的校验器。</p>
</blockquote>
<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>校验注解和校验器自定义成功之后即可使用，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorDTO</span> </span>&#123;</div><div class="line">    <span class="meta">@EnumValues</span>(values = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,message = <span class="string">"性别只能传入1或者2"</span>)</div><div class="line">    <span class="keyword">private</span> Integer gender;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数据校验作为客户端和服务端的一道屏障，有着重要的作用，通过这篇文章希望能够对<code>JSR-303</code>数据校验有着全面的认识。</p>
<p><strong>另外作者的第一本PDF书籍已经整理好了，由浅入深的详细介绍了Mybatis基础以及底层源码，有需要的朋友公众号回复关键词<code>Mybatis进阶</code>即可获取，目录如下：</strong></p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E8%BF%9B%E9%98%B6PDF/2.png" alt=""></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png" alt=""></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 整合 Swagger3.0</title>
    <url>/2020/11/05/SpringBoot%E6%95%B4%E5%90%88Swagger3-0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近频繁被<code>Swagger 3.0</code>刷屏，官方表示这是一个突破性的变更，有很多的亮点，我还真不太相信，今天来带大家尝尝鲜，看看这碗汤到底鲜不鲜….</p>
<h2 id="官方文档如何说？"><a href="#官方文档如何说？" class="headerlink" title="官方文档如何说？"></a>官方文档如何说？</h2><p>该项目开源在<code>Github</code>上，地址：<a href="https://github.com/springfox/springfox" target="_blank" rel="external">https://github.com/springfox/springfox</a>。</p>
<p><code>Swagger 3.0</code>有何改动？官方文档总结如下几点：</p>
<ol>
<li>删除了对<code>springfox-swagger2</code>的依赖</li>
<li>删除所有<code>@EnableSwagger2...</code>注解</li>
<li>添加了<code>springfox-boot-starter</code>依赖项</li>
<li>移除了<code>guava</code>等第三方依赖</li>
<li>文档访问地址改变了，改成了<code>http://ip:port/project/swagger-ui/index.html</code>。</li>
</ol>
<blockquote>
<p>姑且看到这里，各位初始感觉如何？</p>
</blockquote>
<a id="more"></a>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E7%AC%AC%E5%8D%81%E5%85%AD%E5%BC%B9%EF%BC%8C%E6%95%B4%E5%90%88Swagger3.0/1.png" alt=""></p>
<p>既然人家更新出来了，咱不能不捧场，下面就介绍下<code>Spring Boot</code>如何整合<code>Swagger 3.0</code>吧。</p>
<h2 id="Spring-Boot版本说明"><a href="#Spring-Boot版本说明" class="headerlink" title="Spring Boot版本说明"></a>Spring Boot版本说明</h2><p>作者使用<code>Spring Boot</code>的版本是<code>2.3.5.RELEASE</code></p>
<h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p><code>Swagger 3.0</code>已经有了与Spring Boot整合的启动器，只需要添加以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="springfox-boot-starter做了什么？"><a href="#springfox-boot-starter做了什么？" class="headerlink" title="springfox-boot-starter做了什么？"></a>springfox-boot-starter做了什么？</h2><p><code>Swagger 3.0</code>主推的一大特色就是这个启动器，那么这个启动器做了什么呢？</p>
<blockquote>
<p><strong>记住</strong>：启动器的一切逻辑都在自动配置类中。</p>
</blockquote>
<p>找到<code>springfox-boot-starter</code>的自动配置类，在<code>/META-INF/spring.factories</code>文件中，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E7%AC%AC%E5%8D%81%E5%85%AD%E5%BC%B9%EF%BC%8C%E6%95%B4%E5%90%88Swagger3.0/2.png" alt=""></p>
<p>从上图可以知道，自动配置类就是<code>OpenApiAutoConfiguration</code>，源码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableConfigurationProperties</span>(SpringfoxConfigurationProperties.class)</div><div class="line"><span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"springfox.documentation.enabled"</span>, havingValue = <span class="string">"true"</span>, matchIfMissing = <span class="keyword">true</span>)</div><div class="line"><span class="meta">@Import</span>(&#123;</div><div class="line">    OpenApiDocumentationConfiguration.class,</div><div class="line">    SpringDataRestConfiguration.class,</div><div class="line">    BeanValidatorPluginsConfiguration.class,</div><div class="line">    Swagger2DocumentationConfiguration.class,</div><div class="line">    SwaggerUiWebFluxConfiguration.class,</div><div class="line">    SwaggerUiWebMvcConfiguration.class</div><div class="line">&#125;)</div><div class="line"><span class="meta">@AutoConfigureAfter</span>(&#123; WebMvcAutoConfiguration.class, JacksonAutoConfiguration.class,</div><div class="line">    HttpMessageConvertersAutoConfiguration.class, RepositoryRestMvcAutoConfiguration.class &#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenApiAutoConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>敢情这个自动配置类啥也没干，就光导入了几个配置类(<code>@Import</code>)以及开启了属性配置(<code>@EnableConfigurationProperties</code>)。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E7%AC%AC%E5%8D%81%E5%85%AD%E5%BC%B9%EF%BC%8C%E6%95%B4%E5%90%88Swagger3.0/3.jpg" alt="3"></p>
<blockquote>
<p><strong>重点</strong>：记住<code>OpenApiDocumentationConfiguration</code>这个配置类，初步看来这是个BUG，本人也不想深入，里面的代码写的实在拙劣，注释都不写。</p>
</blockquote>
<h2 id="撸起袖子就是干？"><a href="#撸起袖子就是干？" class="headerlink" title="撸起袖子就是干？"></a>撸起袖子就是干？</h2><p>说真的，还是和以前一样，真的没什么太大的改变，按照文档的步骤一步步来。</p>
<h3 id="定制一个基本的文档示例"><a href="#定制一个基本的文档示例" class="headerlink" title="定制一个基本的文档示例"></a>定制一个基本的文档示例</h3><p>一切的东西还是需要配置类手动配置，说真的，我以为会在全局配置文件中自己配置就行了。哎，想多了。配置类如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@EnableOpenApi</span></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableConfigurationProperties</span>(value = &#123;SwaggerProperties.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">     * 配置属性</div><div class="line">     */</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> SwaggerProperties properties;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">frontApi</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.OAS_30)</div><div class="line">                <span class="comment">//是否开启，根据环境配置</span></div><div class="line">                .enable(properties.getFront().getEnable())</div><div class="line">                .groupName(properties.getFront().getGroupName())</div><div class="line">                .apiInfo(frontApiInfo())</div><div class="line">                .select()</div><div class="line">                <span class="comment">//指定扫描的包</span></div><div class="line">                .apis(RequestHandlerSelectors.basePackage(properties.getFront().getBasePackage()))</div><div class="line">                .paths(PathSelectors.any())</div><div class="line">                .build();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 前台API信息</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">frontApiInfo</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</div><div class="line">                .title(properties.getFront().getTitle())</div><div class="line">                .description(properties.getFront().getDescription())</div><div class="line">                .version(properties.getFront().getVersion())</div><div class="line">                .contact(    <span class="comment">//添加开发者的一些信息</span></div><div class="line">                        <span class="keyword">new</span> Contact(properties.getFront().getContactName(), properties.getFront().getContactUrl(),</div><div class="line">                                properties.getFront().getContactEmail()))</div><div class="line">                .build();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>@EnableOpenApi</code>这个注解文档解释如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Indicates that Swagger support should be enabled.</div><div class="line">This should be applied to a Spring java config and should have an accompanying &apos;@Configuration&apos; annotation.</div><div class="line">Loads all required beans defined in @see SpringSwaggerConfig</div></pre></td></tr></table></figure></p>
<p>什么意思呢？大致意思就是<strong>只有在配置类标注了<code>@EnableOpenApi</code>这个注解才会生成Swagger文档</strong>。</p>
<p><code>@EnableConfigurationProperties</code>这个注解使开启自定义的属性配置，这是作者自定义的<code>Swagger</code>配置。</p>
<blockquote>
<p>总之还是和之前一样配置，根据官方文档要求，需要在配置类上加一个<code>@EnableOpenApi</code>注解。</p>
</blockquote>
<h3 id="文档如何分组？"><a href="#文档如何分组？" class="headerlink" title="文档如何分组？"></a>文档如何分组？</h3><p>我们都知道，一个项目可能分为<code>前台</code>，<code>后台</code>，<code>APP端</code>，<code>小程序端</code>…..每个端的接口可能还相同，不可能全部放在一起吧，肯定是要区分开的。</p>
<p>因此，实际开发中文档肯定是要分组的。</p>
<p>分组其实很简单，<code>Swagger</code>向<code>IOC</code>中注入一个<code>Docket</code>即为一个组的文档，其中有个<code>groupName()</code>方法指定分组的名称。</p>
<p>因此只需要注入多个<code>Docket</code>指定不同的组名即可，当然，这些文档的标题、描述、扫描的路径都是可以不同定制的。</p>
<p>如下配置两个<code>Docket</code>，分为前台和后台，配置类如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@EnableOpenApi</span></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableConfigurationProperties</span>(value = &#123;SwaggerProperties.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">     * 配置属性</div><div class="line">     */</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> SwaggerProperties properties;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">frontApi</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.OAS_30)</div><div class="line">                <span class="comment">//是否开启，根据环境配置</span></div><div class="line">                .enable(properties.getFront().getEnable())</div><div class="line">                .groupName(properties.getFront().getGroupName())</div><div class="line">                .apiInfo(frontApiInfo())</div><div class="line">                .select()</div><div class="line">                <span class="comment">//指定扫描的包</span></div><div class="line">                .apis(RequestHandlerSelectors.basePackage(properties.getFront().getBasePackage()))</div><div class="line">                .paths(PathSelectors.any())</div><div class="line">                .build();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 前台API信息</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">frontApiInfo</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</div><div class="line">                .title(properties.getFront().getTitle())</div><div class="line">                .description(properties.getFront().getDescription())</div><div class="line">                .version(properties.getFront().getVersion())</div><div class="line">                .contact(    <span class="comment">//添加开发者的一些信息</span></div><div class="line">                        <span class="keyword">new</span> Contact(properties.getFront().getContactName(), properties.getFront().getContactUrl(),</div><div class="line">                                properties.getFront().getContactEmail()))</div><div class="line">                .build();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 后台API</div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">backApi</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.OAS_30)</div><div class="line">                <span class="comment">//是否开启，根据环境配置</span></div><div class="line">                .enable(properties.getBack().getEnable())</div><div class="line">                .groupName(<span class="string">"后台管理"</span>)</div><div class="line">                .apiInfo(backApiInfo())</div><div class="line">                .select()</div><div class="line">                .apis(RequestHandlerSelectors.basePackage(properties.getBack().getBasePackage()))</div><div class="line">                .paths(PathSelectors.any())</div><div class="line">                .build();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 后台API信息</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">backApiInfo</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</div><div class="line">                .title(properties.getBack().getTitle())</div><div class="line">                .description(properties.getBack().getDescription())</div><div class="line">                .version(properties.getBack().getVersion())</div><div class="line">                .contact(    <span class="comment">//添加开发者的一些信息</span></div><div class="line">                        <span class="keyword">new</span> Contact(properties.getBack().getContactName(), properties.getBack().getContactUrl(),</div><div class="line">                                properties.getBack().getContactEmail()))</div><div class="line">                .build();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>属性配置文件<code>SwaggerProperties</code>如下，分为前台和后台两个不同属性的配置：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * swagger的属性配置类</div><div class="line"> */</div><div class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.swagger"</span>)</div><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerProperties</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 前台接口配置</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> SwaggerEntity front;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 后台接口配置</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> SwaggerEntity back;</div><div class="line"></div><div class="line">    <span class="meta">@Data</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerEntity</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> String groupName;</div><div class="line">        <span class="keyword">private</span> String basePackage;</div><div class="line">        <span class="keyword">private</span> String title;</div><div class="line">        <span class="keyword">private</span> String description;</div><div class="line">        <span class="keyword">private</span> String contactName;</div><div class="line">        <span class="keyword">private</span> String contactEmail;</div><div class="line">        <span class="keyword">private</span> String contactUrl;</div><div class="line">        <span class="keyword">private</span> String version;</div><div class="line">        <span class="keyword">private</span> Boolean enable;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此时的文档截图如下，可以看到有了两个不同的分组：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E7%AC%AC%E5%8D%81%E5%85%AD%E5%BC%B9%EF%BC%8C%E6%95%B4%E5%90%88Swagger3.0/4.png" alt=""></p>
<h3 id="如何添加授权信息？"><a href="#如何添加授权信息？" class="headerlink" title="如何添加授权信息？"></a>如何添加授权信息？</h3><p>现在项目API肯定都需要权限认证，否则不能访问，比如请求携带一个<code>TOKEN</code>。</p>
<p>在Swagger中也是可以配置认证信息，这样在每次请求将会默认携带上。</p>
<p>在<code>Docket</code>中有如下两个方法指定授权信息，分别是<code>securitySchemes()</code>和<code>securityContexts()</code>。在配置类中的配置如下，在构建Docket的时候设置进去即可：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">frontApi</span><span class="params">()</span> </span>&#123;</div><div class="line">    RequestParameter parameter = <span class="keyword">new</span> RequestParameterBuilder()</div><div class="line">            .name(<span class="string">"platform"</span>)</div><div class="line">            .description(<span class="string">"请求头"</span>)</div><div class="line">            .in(ParameterType.HEADER)</div><div class="line">            .required(<span class="keyword">true</span>)</div><div class="line">            .build();</div><div class="line">    List&lt;RequestParameter&gt; parameters = Collections.singletonList(parameter);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.OAS_30)</div><div class="line">            <span class="comment">//是否开启，根据环境配置</span></div><div class="line">            .enable(properties.getFront().getEnable())</div><div class="line">            .groupName(properties.getFront().getGroupName())</div><div class="line">            .apiInfo(frontApiInfo())</div><div class="line">            .select()</div><div class="line">            <span class="comment">//指定扫描的包</span></div><div class="line">            .apis(RequestHandlerSelectors.basePackage(properties.getFront().getBasePackage()))</div><div class="line">            .paths(PathSelectors.any())</div><div class="line">            .build()</div><div class="line">            .securitySchemes(securitySchemes())</div><div class="line">            .securityContexts(securityContexts());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 设置授权信息</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> List&lt;SecurityScheme&gt; <span class="title">securitySchemes</span><span class="params">()</span> </span>&#123;</div><div class="line">    ApiKey apiKey = <span class="keyword">new</span> ApiKey(<span class="string">"BASE_TOKEN"</span>, <span class="string">"token"</span>, In.HEADER.toValue());</div><div class="line">    <span class="keyword">return</span> Collections.singletonList(apiKey);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 授权信息全局应用</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> List&lt;SecurityContext&gt; <span class="title">securityContexts</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Collections.singletonList(</div><div class="line">            SecurityContext.builder()</div><div class="line">                    .securityReferences(Collections.singletonList(<span class="keyword">new</span> SecurityReference(<span class="string">"BASE_TOKEN"</span>, <span class="keyword">new</span> AuthorizationScope[]&#123;<span class="keyword">new</span> AuthorizationScope(<span class="string">"global"</span>, <span class="string">""</span>)&#125;)))</div><div class="line">                    .build()</div><div class="line">    );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上配置成功后，在Swagger文档的页面中将会有<code>Authorize</code>按钮，只需要将请求头添加进去即可。如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E7%AC%AC%E5%8D%81%E5%85%AD%E5%BC%B9%EF%BC%8C%E6%95%B4%E5%90%88Swagger3.0/5.png" alt=""></p>
<h3 id="如何携带公共的请求参数？"><a href="#如何携带公共的请求参数？" class="headerlink" title="如何携带公共的请求参数？"></a>如何携带公共的请求参数？</h3><p>不同的架构可能发请求的时候除了携带<code>TOKEN</code>，还会携带不同的参数，比如请求的平台，版本等等，这些每个请求都要携带的参数称之为公共参数。</p>
<p>那么如何在<code>Swagger</code>中定义公共的参数呢？比如在请求头中携带。</p>
<p>在<code>Docket</code>中的方法<code>globalRequestParameters()</code>可以设置公共的请求参数，接收的参数是一个<code>List&lt;RequestParameter&gt;</code>，因此只需要构建一个<code>RequestParameter</code>集合即可，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">frontApi</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">//构建一个公共请求参数platform，放在在header</span></div><div class="line">   RequestParameter parameter = <span class="keyword">new</span> RequestParameterBuilder()</div><div class="line">      <span class="comment">//参数名称</span></div><div class="line">      .name(<span class="string">"platform"</span>)</div><div class="line">      <span class="comment">//描述</span></div><div class="line">      .description(<span class="string">"请求的平台"</span>)</div><div class="line">      <span class="comment">//放在header中</span></div><div class="line">      .in(ParameterType.HEADER)</div><div class="line">      <span class="comment">//是否必传</span></div><div class="line">      .required(<span class="keyword">true</span>)</div><div class="line">      .build();</div><div class="line">      <span class="comment">//构建一个请求参数集合</span></div><div class="line">      List&lt;RequestParameter&gt; parameters = Collections.singletonList(parameter);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.OAS_30)</div><div class="line">                .....</div><div class="line">                .build()</div><div class="line">                .globalRequestParameters(parameters);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>以上配置完成，将会在每个接口中看到一个请求头，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E7%AC%AC%E5%8D%81%E5%85%AD%E5%BC%B9%EF%BC%8C%E6%95%B4%E5%90%88Swagger3.0/6.png" alt=""></p>
<h2 id="粗略是一个BUG"><a href="#粗略是一个BUG" class="headerlink" title="粗略是一个BUG"></a>粗略是一个BUG</h2><p>作者在介绍自动配置类的时候提到了一嘴，现在来简单分析下。</p>
<p><code>OpenApiAutoConfiguration</code>这个自动配置类中已经导入<code>OpenApiDocumentationConfiguration</code>这个配置类，如下一段代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Import</span>(&#123;</div><div class="line">    OpenApiDocumentationConfiguration.class,</div><div class="line">    ......</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p><code>@EnableOpenApi</code>的源码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Retention</span>(value = java.lang.annotation.RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Target</span>(value = &#123;java.lang.annotation.ElementType.TYPE&#125;)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Import</span>(OpenApiDocumentationConfiguration.class)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableOpenApi &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从源码可以看出：<code>@EnableOpenApi</code>这个注解的作用就是导入<code>OpenApiDocumentationConfiguration</code>这个配置类，纳尼？？？</p>
<p>既然已经在自动配置类<code>OpenApiAutoConfiguration</code>导入了，那么无论需不需要在配置类上标注<code>@EnableOpenApi</code>注解不都会开启<code>Swagger</code>支持吗？</p>
<p><strong>测试一下</strong>：不在配置类上标注<code>@EnableOpenApi</code>这个注解，看看是否<code>Swagger</code>运行正常。结果在意料之中，还是能够正常运行。</p>
<blockquote>
<p><strong>总结</strong>：作者只是大致分析了下，这可能是个<code>BUG</code>亦或是后续有其他的目的，至于结果如此，不想验证了，没什么意思。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章也是尝了个鲜，个人感觉不太香，有点失望。你喜欢吗？</p>
<blockquote>
<p><code>Spring Boot</code> 整合的源码已经上传，需要的朋友回复关键词<strong>Swagger3.0</strong>获取。</p>
</blockquote>
<p>另外作者的第一本<code>PDF</code>书籍已经整理好了，由浅入深的详细介绍了Mybatis基础以及底层源码，有需要的朋友公众号回复关键词<strong>Mybatis进阶</strong>即可获取，目录如下：</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E8%BF%9B%E9%98%B6PDF/2.png" alt=""></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png" alt=""></p>
]]></content>
      <categories>
        <category>Spring Boot进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 使用JRebel实现热部署~</title>
    <url>/2020/11/02/SpringBoot%E7%83%AD%E9%83%A8%E7%BD%B2%E6%8F%92%E4%BB%B6JRebel/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Spring Boot</code>中的热部署相信大家用的最多的就是<code>devtools</code>，没办法，官推的。</p>
<p><code>JRebel</code>相对于<code>devtools</code>，个人觉得无论是加载速度还是使用便捷，<code>JRebel</code>完胜。</p>
<p>作为<strong>前辈级别</strong>的开发利器，<code>JRebel</code>真的值得开一章节来好好介绍下。</p>
<a id="more"></a>
<h2 id="JRebel收费怎么破？"><a href="#JRebel收费怎么破？" class="headerlink" title="JRebel收费怎么破？"></a>JRebel收费怎么破？</h2><p>前面作者单独写过一篇激活<code>JRebel</code>的文章教程，没钱的可以去看看：<a href="https://mp.weixin.qq.com/s/VBGoGMz0y2Y-y6NcdMcaLg" target="_blank" rel="external">撸了个反向代理工具，搞一搞JRebel</a>。</p>
<blockquote>
<p><strong>特此声明</strong>：作者支持原版，不差钱的建议装个原版的，毕竟这么好的工具值得。</p>
</blockquote>
<h2 id="什么是本地热部署？"><a href="#什么是本地热部署？" class="headerlink" title="什么是本地热部署？"></a>什么是本地热部署？</h2><p>传统的开发中，项目在启动过程中代码有所改动是不会重新编译运行的，而是要关闭项目重新启动后修改的代码才会生效。</p>
<blockquote>
<p><strong>本地热部署</strong>则是能够在项目运行中感知到特定文件代码的修改而使项目不重新启动就能生效。</p>
</blockquote>
<h2 id="什么是远程热部署？"><a href="#什么是远程热部署？" class="headerlink" title="什么是远程热部署？"></a>什么是远程热部署？</h2><p>远程热部署的<code>远程</code>两字指的是<strong>远程服务器</strong>，平时开发中，只要本地代码改动了，必须要重新打包上传服务器重新启动之后才会生效，<strong>你这样干过吗？…….</strong></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%E4%BD%BF%E7%94%A8JRebel%E7%83%AD%E9%83%A8%E7%BD%B2/2.jpg" alt="嗯？好像干过"></p>
<blockquote>
<p><strong>远程热部署</strong>则是本地代码改变之后，不用重新打包上传服务器重启项目就能生效，本地改变之后能够自动改变服务器上的项目代码。</p>
</blockquote>
<p>有些人听到这里懵逼了，这是什么鬼？还有这么神奇的东西………..</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%E4%BD%BF%E7%94%A8JRebel%E7%83%AD%E9%83%A8%E7%BD%B2/3.jpg" alt="别惊讶，就是这么神奇"></p>
<h2 id="JRebel和devtools的区别"><a href="#JRebel和devtools的区别" class="headerlink" title="JRebel和devtools的区别"></a>JRebel和devtools的区别</h2><p>前辈和后辈的比较其实没什么可比性，如果不是JRebel<strong>收费</strong>了，绝对是所有程序员的首选。但还是要说说他们之间的区别，如下：</p>
<ol>
<li><code>JRebel</code>加载的速度优于<code>devtools</code></li>
<li>JRebel不仅仅局限于Spring Boot项目，可以用在任何的Java项目中。</li>
<li><code>devtools</code> 方式的热部署在功能上有限制，方法内的修改可以实现热部署，但新增的方法或者修改方法参数之后热部署是不生效的。</li>
</ol>
<h2 id="如何安装JRebel？"><a href="#如何安装JRebel？" class="headerlink" title="如何安装JRebel？"></a>如何安装JRebel？</h2><p>本地热部署只需要在<code>IDEA</code>中装一个JRebel的插件，远程热部署需要在服务器上装一个JRebel，这两种方式在上一篇文章都介绍过，不会的可以去看看：<a href="https://mp.weixin.qq.com/s/VBGoGMz0y2Y-y6NcdMcaLg" target="_blank" rel="external">撸了个反向代理工具，搞一搞JRebel</a>。</p>
<h2 id="如何本地热部署？"><a href="#如何本地热部署？" class="headerlink" title="如何本地热部署？"></a>如何本地热部署？</h2><p><code>JRebel</code>插件安装完成之后，将<code>IDEA</code>中的<code>自动编译</code>开启，然后找到<code>IDEA</code>中的<code>JRebel</code>的工具面板，将所需要热部署的项目或者模块勾选上即可，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%E4%BD%BF%E7%94%A8JRebel%E7%83%AD%E9%83%A8%E7%BD%B2/4.png" alt=""></p>
<blockquote>
<p>勾选成功之后将会在项目或者模块的<code>src/resource</code>下生成一个<code>rebel.xml</code>文件。</p>
</blockquote>
<p>此时在<code>Spring Boot</code>的主启动类上右键，将会出现以<code>JRebel</code>启动的选项，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%E4%BD%BF%E7%94%A8JRebel%E7%83%AD%E9%83%A8%E7%BD%B2/5.png" alt=""></p>
<p>当然在<code>IDEA</code>的右上角也存在启动的按钮，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%E4%BD%BF%E7%94%A8JRebel%E7%83%AD%E9%83%A8%E7%BD%B2/6.png" alt=""></p>
<blockquote>
<p><code>①</code>是本地启动和<code>DEBUG</code>模式启动，<code>②</code>是远程热部署的时候更新按钮。</p>
</blockquote>
<p>此时就已经配置成功了，如果勾选的项目或者模块出现了改变，按<code>CRTL+SHIFT+F9</code>则会自动重新编译加载改变的部分，不用再重新启动项目了。</p>
<h2 id="如何远程热部署？"><a href="#如何远程热部署？" class="headerlink" title="如何远程热部署？"></a>如何远程热部署？</h2><p>远程热部署需要在服务器上安装并激活<code>JRebel</code>，参照上篇文章：<a href="https://mp.weixin.qq.com/s/VBGoGMz0y2Y-y6NcdMcaLg" target="_blank" rel="external">撸了个反向代理工具，搞一搞JRebel</a>。</p>
<p>激活成功后需要设置远程连接的密码，在<code>JRebel</code>的根目录下执行以下命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">java -jar jrebel.jar -set-remote-password 123456789</div></pre></td></tr></table></figure></p>
<blockquote>
<p>此处设置的<code>123456789</code>则是远程的密码，在<code>IDEA</code>连接服务器的时候需要。</p>
</blockquote>
<p>服务器配置成功后，在IDEA中JRebel的面板中设置远程热部署的模块，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%E4%BD%BF%E7%94%A8JRebel%E7%83%AD%E9%83%A8%E7%BD%B2/4.png" alt=""></p>
<blockquote>
<p>勾选成功后，将会在<code>src/resource</code>下生成一个<code>rebel-remote.xml</code>文件。</p>
</blockquote>
<p>此时将<code>Spring Boot</code>项目打包成一个<code>Jar</code>，上传到服务器，执行以下命令启动项目：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">nohup java -agentpath:/usr/local/jrebel/lib/libjrebel64.so  -Drebel.remoting_plugin=true -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=9083 -jar xxx.jar &amp;</div></pre></td></tr></table></figure></p>
<p><code>libjrebel64.so</code>这个文件是<code>JRebel</code>的<code>lib</code>目录下的文件。</p>
<p><code>-Xdebug</code>之后，<code>-jar</code>之前的命令是开启远程调试的，如果不需要的可以去掉，不知道远程调试的，可以看：<a href="https://mp.weixin.qq.com/s/EoJ8OaJWoXZSrP3Lvexd9Q" target="_blank" rel="external">惊呆了！Spring Boot还能开启远程调试~</a>。</p>
<blockquote>
<p>项目启动成功后，服务器上的配置就完成了。</p>
</blockquote>
<p>此时在IDEA中需要设置连接到刚才启动的项目，打开<code>File-&gt;setting-&gt;JRbel&amp;XRebel-&gt;JRbel Remote Servers</code>，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%E4%BD%BF%E7%94%A8JRebel%E7%83%AD%E9%83%A8%E7%BD%B2/7.png" alt=""></p>
<p>步骤如下：</p>
<ol>
<li>点击<code>+</code>号添加一个服务</li>
<li>填写信息<ul>
<li><code>server name</code>随便起个服务的名字</li>
<li><code>server URL</code>格式：<code>http://ip:port</code>，这里的<code>ip</code>是服务器的IP，<code>port</code>是项目端口号。</li>
<li>远程密码则是上文设置的<code>JRebel</code>的密码<code>123456789</code>。</li>
</ul>
</li>
<li>点击<code>OK</code>，即可添加成功。</li>
</ol>
<p>以上设置成功后，点击右上角的远程部署按钮，下图中的<code>②</code>号按钮，则会自动更新服务器上已启动项目的代码使之本地修改在服务端自动生效：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%E4%BD%BF%E7%94%A8JRebel%E7%83%AD%E9%83%A8%E7%BD%B2/6.png" alt=""></p>
<p>在<code>JRebel Console</code>这个面板中将会打印出远程热部署更新的日志信息，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%E4%BD%BF%E7%94%A8JRebel%E7%83%AD%E9%83%A8%E7%BD%B2/8.png" alt=""></p>
<blockquote>
<p>只要本地有了更改，点击远程热部署按钮，则会自动上传代码到服务器端并实时更新，不用重新启动项目。</p>
</blockquote>
<h2 id="多模块开发的一个坑"><a href="#多模块开发的一个坑" class="headerlink" title="多模块开发的一个坑"></a>多模块开发的一个坑</h2><p>如果是多模块开发，比如分为<code>api</code>（最终的<code>Jar</code>包），<code>core</code>（核心包），<code>service</code>（业务层的包），最终打包运行在服务器端的是<code>api</code>这个模块，其余两个模块都是属于依赖模块，虽然在<code>JRebel</code>远程热部署选项中都勾选了，但是它们的代码更改并不会在服务端生效。</p>
<p>这个如何解决呢？很简单，在<code>api</code>项目下的<code>rebel-remote.xml</code>文件中将其余两个模块添加进去，默认的如下：<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">rebel-remote</span> <span class="attr">xmlns</span>=<span class="string">"http://www.zeroturnaround.com/rebel/remote"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>xx.xx.xx.api<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">rebel-remote</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>添加之后的代码如下：<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">rebel-remote</span> <span class="attr">xmlns</span>=<span class="string">"http://www.zeroturnaround.com/rebel/remote"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>xx.xxx.xx.api<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>xx.xx.xx.service<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>xx.xx.xx.core<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">rebel-remote</span>&gt;</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>以上的<code>&lt;id&gt;</code>标签中指定的是模块的包名（package）。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>作为热部署界的前辈，<code>JRebel</code>依然是敌得过后浪，果然是姜还是老的辣……</p>
<p>希望这篇文章介绍的<code>JRebel</code>能够提高读者们的开发效率，反正我是提高了，哈哈~</p>
<p>另外作者为大家准备接近<code>10M</code>的面筋，涵盖后端的各个层面，老规矩，公众号内回复<code>Java面试宝典</code>即可获取。</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/8.png" alt=""></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png" alt=""></p>
]]></content>
      <categories>
        <category>Spring Boot进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot整合多数据源的巨坑</title>
    <url>/2020/03/18/SpringBoot%E6%95%B4%E5%90%88%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E5%B7%A8%E5%9D%91/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>本篇文章接上篇<a href="https://chenjiabing666.github.io/2020/03/12/SpringBoot%E6%95%B4%E5%90%88%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%EF%BC%8C%E4%BD%A0%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/">SpringBoot整合多数据源，你会了吗？</a>，前面文章最后留了几个问题供大家思考，今天一一揭晓。<a id="more"></a>
</li>
</ul>
<h2 id="配置如何优化"><a href="#配置如何优化" class="headerlink" title="配置如何优化"></a>配置如何优化</h2><ul>
<li>上文整合的过程中的还顺带整合Mybatis和TransactionManager，为什么还要重新定义他们呢？SpringBoot不是给我们都配置好了吗？注意，此处优化就是这两个配置去掉，直接用SpringBoot的自动配置，顿时高级了，别人一看你的代码如此简单就实现了多数据源的切换，牛叉不？</li>
<li>如何去掉？SpringBoot万变不离自动配置类，且看MybatisAutoConfiguration，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@org</span>.springframework.context.annotation.Configuration</div><div class="line"><span class="meta">@ConditionalOnClass</span>(&#123; SqlSessionFactory.class, SqlSessionFactoryBean.class &#125;)</div><div class="line"><span class="meta">@ConditionalOnSingleCandidate</span>(DataSource.class)</div><div class="line"><span class="meta">@EnableConfigurationProperties</span>(MybatisProperties.class)</div><div class="line"><span class="meta">@AutoConfigureAfter</span>(DataSourceAutoConfiguration.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisAutoConfiguration</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</div></pre></td></tr></table></figure>
<ul>
<li>不多帖了，都是废话，看前几行就行了，醒目的一行啊，<code>@ConditionalOnSingleCandidate(DataSource.class)</code>，什么鬼？该注解的意思就是IOC容器中只有一个指定的候选对象才起作用，但是我们注入了几个DataSource，足足三个啊，这还起作用吗？那不废话嘛。</li>
<li>事务管理器也是一样，且看<code>DataSourceTransactionManagerAutoConfiguration</code>，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceTransactionManagerAutoConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Configuration</span></div><div class="line">	<span class="meta">@ConditionalOnSingleCandidate</span>(DataSource.class)</div><div class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceTransactionManagerConfiguration</span> </span>&#123;</div></pre></td></tr></table></figure>
<ul>
<li>又看到了什么，<code>@ConditionalOnSingleCandidate(DataSource.class)</code>同样的醒目，mmp，这不玩我呢吗。这怎么搞？</li>
<li>咦，不着急，此时就要看看<code>@ConditionalOnSingleCandidate</code>注解搞了什么，进去看看，有如下的介绍：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">The condition will also match <span class="keyword">if</span> multiple matching bean instances are already contained in the BeanFactory but a primary candidate has been defined; essentially, the condition match <span class="keyword">if</span> auto-wiring a bean with the defined type will succeed.</div></pre></td></tr></table></figure>
<ul>
<li>什么鬼，看不懂，英语太差了吧，不着急，陈某给大家推荐一个IDEA插件，文档翻译更加专注于程序员的专业术语，不像xx度翻译，如下：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/transac1.png" alt=""></p>
<ul>
<li>好了，翻译准确了就知道了，大致意思就是IOC容器中允许你有多个候选对象，但是你必须有一个主（primary）候选对象，顿时灵光一现，这不就是@Primary注解吗，艹，我这也太优秀了吧。</li>
<li>二话不说，直接开撸，轻轻松松一个注解搞定，此时的数据源配置变得简单多了，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Description</span> 数据源的配置</div><div class="line"> * <span class="doctag">@Author</span> CJB</div><div class="line"> * <span class="doctag">@Date</span> 2020/3/9 13:45</div><div class="line"> */</div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@MapperScan</span>(basePackages = &#123;<span class="string">"com.vivachek.service.dao"</span>,<span class="string">"com.vivachek.service.dao2"</span>&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatasourceConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 注入数据源1</div><div class="line">     */</div><div class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource1"</span>)</div><div class="line">    <span class="meta">@Bean</span>(value = <span class="string">"dataSource1"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource1</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 第二个数据源</div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span>(name = <span class="string">"dataSource2"</span>)</div><div class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource2"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 动态数据源</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="meta">@Primary</span></div><div class="line">    <span class="function"><span class="keyword">public</span> DynamicDataSource <span class="title">dynamicDataSource</span><span class="params">()</span> </span>&#123;</div><div class="line">        DynamicDataSource dataSource = <span class="keyword">new</span> DynamicDataSource();</div><div class="line">        <span class="comment">//默认数据源，在没有切换数据源的时候使用该数据源</span></div><div class="line">        dataSource.setDefaultTargetDataSource(dataSource2());</div><div class="line">        HashMap&lt;Object, Object&gt; map = Maps.newHashMap();</div><div class="line">        map.put(<span class="string">"dataSource1"</span>, dataSource1());</div><div class="line">        map.put(<span class="string">"dataSource2"</span>, dataSource2());</div><div class="line">        <span class="comment">//设置数据源Map，动态切换就是根据key从map中获取</span></div><div class="line">        dataSource.setTargetDataSources(map);</div><div class="line">        <span class="keyword">return</span> dataSource;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>直接在<code>DynamicDataSource</code>添加了一个@Primary就省去了SqlSessionFactory和TransactionManager的手动配置，是不是很easy并且显得自己很牛叉，太有成就感了…..</li>
<li>好了，牛也吹了，运行一下吧，满怀期待等待30秒…….，what？什么鬼？失败了，抛出了异常，如下：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/circleex.png" alt=""></p>
<ul>
<li>什么鬼，循环依赖异常，搞什么飞机，一万个草泥马在奔腾在横无际涯的草原上。。。。。。。。</li>
<li>别急，还有后续，关注我，将会定时更新后续文章。另外需要源码的联系我，微信联系方式在<a href="https://chenjiabing666.github.io/">个人独立博客</a>【关于我】中，加我注明来意，谢谢。</li>
<li>别忘了点赞哟，多来走动走动呗……….</li>
</ul>
<h2 id="动态路由数据源添加-Primary报循环依赖异常"><a href="#动态路由数据源添加-Primary报循环依赖异常" class="headerlink" title="动态路由数据源添加@Primary报循环依赖异常"></a>动态路由数据源添加@Primary报循环依赖异常</h2><ul>
<li>前面文章<a href="https://chenjiabing666.github.io/2019/07/17/Spring%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/">Spring解决循环依赖</a>有说过Spring对于循环依赖是完全能够解决的，没有读过的小伙伴建议看一下，里面详细的讲述了Spring是如何解决循环依赖的，此处就不再赘述了。</li>
<li>既然Spring能够解决循环依赖，为什么这里又会报循环依赖的异常呢？我们不妨跟着代码看看是怎样的循环依赖，如下：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/circleex.png" alt=""></p>
<ul>
<li>上面两个数据源都是自己定义的，先不用看，那么肯定是<code>DataSourceInitializerInvoker</code>造成的循环依赖了，果不其然，其中确实依赖了DataSource，源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">DataSourceInitializerInvoker(ObjectProvider&lt;DataSource&gt; dataSource, DataSourceProperties properties,</div><div class="line">			ApplicationContext applicationContext) &#123;</div><div class="line">		<span class="keyword">this</span>.dataSource = dataSource;</div><div class="line">		<span class="keyword">this</span>.properties = properties;</div><div class="line">		<span class="keyword">this</span>.applicationContext = applicationContext;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ul>
<li>what？即使依赖了又怎样？Spring不是可以解决循环依赖吗？别着急下面分析</li>
<li>ObjectProvider应该不陌生吧，其实内部就是从IOC容器中获取Bean而已，但是，转折来了……… ，这是什么，这是构造器，Spring能解决构造器的循环依赖吗？答案是不能，所以原因找到了，这里不再细说了，欲知原因请读<a href="https://chenjiabing666.github.io/2019/07/17/Spring%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/">Spring解循环依赖</a></li>
<li><p>问题找到了，如何解决？此时心中一万个草泥马奔腾，怎么解决呢？</p>
</li>
<li><p>哈哈，此时插播一条广告，本人的独立博客已经发布了很多文章，感兴趣的可以收藏一下，【关于我】中有我的微信联系方式，欢迎交流。</p>
</li>
<li>回到正题，如何解决？很简单，找到这个<code>DataSourceInitializerInvoker</code>是什么时候注入到IOC容器中的，因此我们找到了<code>DataSourceAutoConfiguration</code>，继而找到了<code>DataSourceInitializationConfiguration</code>这个配置类，源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ConditionalOnClass</span>(&#123; DataSource.class, EmbeddedDatabaseType.class &#125;)</div><div class="line"><span class="meta">@EnableConfigurationProperties</span>(DataSourceProperties.class)</div><div class="line"><span class="meta">@Import</span>(&#123; DataSourcePoolMetadataProvidersConfiguration.class, DataSourceInitializationConfiguration.class &#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceAutoConfiguration</span> </span>&#123;</div><div class="line">    <span class="meta">@Configuration</span></div><div class="line">	<span class="meta">@Conditional</span>(EmbeddedDatabaseCondition.class)</div><div class="line">	<span class="meta">@ConditionalOnMissingBean</span>(&#123; DataSource.class, XADataSource.class &#125;)</div><div class="line">	<span class="meta">@Import</span>(EmbeddedDataSourceConfiguration.class)</div><div class="line">	<span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedDatabaseConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Configuration</span></div><div class="line">	<span class="meta">@Conditional</span>(PooledDataSourceCondition.class)</div><div class="line">	<span class="meta">@ConditionalOnMissingBean</span>(&#123; DataSource.class, XADataSource.class &#125;)</div><div class="line">	<span class="meta">@Import</span>(&#123; DataSourceConfiguration.Hikari.class, DataSourceConfiguration.Tomcat.class,</div><div class="line">			DataSourceConfiguration.Dbcp2.class, DataSourceConfiguration.Generic.class,</div><div class="line">			DataSourceJmxConfiguration.class &#125;)</div><div class="line">	<span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledDataSourceConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line">	&#125;   </div><div class="line">&#125;</div><div class="line">    </div><div class="line">    </div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@Import</span>(&#123; DataSourceInitializerInvoker.class, DataSourceInitializationConfiguration.Registrar.class &#125;)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataSourceInitializationConfiguration</span> </span>&#123;</div></pre></td></tr></table></figure>
<ul>
<li>贴了那么多代码谁看的懂？草泥马又奔腾了，可以看到源码中出现了两次<code>@ConditionalOnMissingBean({ DataSource.class, XADataSource.class })</code>，这什么鬼，不多说了，相信读过SpringBoot源码的都知道，这个配置类根本不起作用啊，那还要它干嘛，直接搞掉不就完事了。好了，分析到这里终于知道解决的方案了，搞掉<code>DataSourceAutoConfiguration</code>，怎么搞呢？一个注解搞定。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//排除配置类</span></div><div class="line"><span class="meta">@SpringBootApplication</span>(exclude = &#123;DataSourceAutoConfiguration.class&#125;)</div></pre></td></tr></table></figure>
<ul>
<li>问题迎刃而解了，简单不，惊喜不，不好，又奔腾了。。。。</li>
</ul>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg" alt=""></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring生命周期</title>
    <url>/2020/03/23/Spring%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>Spring中Bean的生命周期从容器的启动到停止，涉及到的源码主要是在<code>org.springframework.context.support.AbstractApplicationContext.refresh</code>方法中，下面也是围绕其中的逻辑进行讲解。<a id="more"></a>
<h2 id="开撸"><a href="#开撸" class="headerlink" title="开撸"></a>开撸</h2></li>
</ul>
<p>【1】 prepareRefresh()</p>
<p> 内部其实很简单，就是设置一些标志，比如开始时间，激活的状态等。</p>
<p>【2】prepareBeanFactory(beanFactory)</p>
<p>做一些简单的准备工作，此处不再赘述！！！</p>
<p>【3】postProcessBeanFactory(beanFactory)</p>
<p>主要的作用就是添加了一个后置处理器<code>ServletContextAwareProcessor</code></p>
<p>【4】invokeBeanFactoryPostProcessors(beanFactory)</p>
<p>调用容器中的所有的<strong>BeanFactoryPostProcessor</strong>中的<strong>postProcessBeanFactory</strong>方法，按照优先级调用，主要实现逻辑在org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List<org.springframework.beans.factory.config.beanfactorypostprocessor>)<br>    (1) 执行所有BeanDefinitionRegistryPostProcessor(对BeanFactoryPostProcessor的扩展，运行在普通的实现类之前注册bean)的方法，同样是内部按照优先级进行排序调用<br>    (2) 对剩余的进行按照优先级排序调用，同样是内部进行排序执行</org.springframework.beans.factory.config.beanfactorypostprocessor></p>
<p>【5】<strong>registerBeanPostProcessors(beanFactory)</strong></p>
<p>注册所有的<strong>BeanPostProcessor</strong>（后置处理器），按照优先级注册，分别是PriorityOrdered，Ordered，普通的，内部的。主要的实现逻辑在PostProcessorRegistrationDelegate.registerBeanPostProcessors()</p>
<p>【6】initMessageSource()<br>注册MessageSource,提供消息国际化等功能</p>
<p>【7】initApplicationEventMulticaster();</p>
<p>注册事件广播器ApplicationEventMulticaster，用于spring事件的广播和事件监听器的处理</p>
<p>【8】registerListeners()</p>
<p>注册事件监听器ApplicationListener，并且广播一些早期的事件，主要的逻辑在org.springframework.context.support.AbstractApplicationContext.registerListeners</p>
<p>【9】finishBeanFactoryInitialization(beanFactory)</p>
<p>实例化所有非懒加载的Bean，spring生命周期中的主要方法，主要逻辑在org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons，深入进去其实就是getBean()方法创建，详情向下看。</p>
<p>【10】finishRefresh()</p>
<p>主要的功能是发布事件ContextRefreshedEvent</p>
<p>【11】destroyBeans()</p>
<p>容器启动出现异常时销毁Bean</p>
<p>以上就是Spring容器启动的过程，主要的逻辑都在org.springframework.context.support.AbstractApplicationContext#refresh中，其他的都很容易理解，现在我们着重分析一下单例Bean的创建过程，入口是第9步。</p>
<h2 id="实例化单例Bean"><a href="#实例化单例Bean" class="headerlink" title="实例化单例Bean"></a>实例化单例Bean</h2><p>【1】debug进入，实际主要的逻辑都在org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons方法中，逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//获取所有注入到ioc容器中的bean定义信息</span></div><div class="line">List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</div><div class="line">		<span class="comment">//循环创建</span></div><div class="line">		<span class="keyword">for</span> (String beanName : beanNames) &#123;</div><div class="line">			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</div><div class="line">            <span class="comment">//非抽象，单例，非懒加载的bean初始化</span></div><div class="line">			<span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</div><div class="line">                <span class="comment">//如果是FactoryBean</span></div><div class="line">				<span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</div><div class="line">                    <span class="comment">//getBean</span></div><div class="line">					Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</div><div class="line">                    <span class="comment">//非FactoryBean，getBean</span></div><div class="line">				<span class="keyword">else</span> &#123;</div><div class="line">					getBean(beanName);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<p>以上源码总结得知，最终实例化Bean的方法肯定在getBean中的，debug进入，得知doGetBean是大boss，spring源码有趣的是最终的实现都是在doxxxx()。</p>
<p>【2】AbstractBeanFactory#doGetBean，由于篇幅太短，就不贴源码了，只贴关键代码</p>
<p>实例化的主要流程全部都在这里，下面一一解析即可。</p>
<p>(1) Object sharedInstance = getSingleton(beanName)</p>
<p>从早期的缓存中获取，如果存在返回Bean，实例化</p>
<p>（2）BeanFactory parentBeanFactory = getParentBeanFactory()</p>
<p>从父工厂的中获取Bean</p>
<p>（3）if (mbd.isSingleton()) </p>
<p>分单例和多例进行分开创建Bean，这里只分析单例Bean的创建</p>
<p>（4）sharedInstance = getSingleton(beanName, () -&gt; {   try {      return createBean(beanName, mbd, args);   }</p>
<p>createBean方法创建Bean，进入createBean(）</p>
<p>​    a. Object bean = resolveBeforeInstantiation(beanName, mbdToUse)：执行所有的InstantiationAwareBeanPostProcessor中的<strong>postProcessBeforeInstantiation</strong>，在实例化之前调用，返回null继续下一步，返回一个bean，那么bean实例化完成，将调用其中的<strong>postProcessAfterInstantiation</strong>方法</p>
<p>​       b. Object beanInstance = doCreateBean(beanName, mbdToUse, args)：创建Bean的完成过程</p>
<p>​    c. 进入<strong>doCreateBean</strong>，instanceWrapper = createBeanInstance(beanName, mbd, args)：创建Bean的实例</p>
<p>​    d. populateBean(beanName, mbd, instanceWrapper)：属性装配，执行InstantiationAwareBeanPostProcessor的<strong>postProcessAfterInstantiation</strong>，再执行<strong>postProcessProperties</strong>方法。</p>
<p>​    e. exposedObject = initializeBean(beanName, exposedObject, mbd)：初始化Bean，debug进入</p>
<p>​    f. invokeAwareMethods(beanName, bean)：调用<strong>BeanNameAware</strong>，<strong>BeanClassLoaderAware</strong>，<strong>BeanFactoryAware</strong>中的对应方法</p>
<p>​    g. wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName)：调用BeanPostProcessord中的<strong>postProcessBeforeInitialization</strong>方法</p>
<p>​    h. invokeInitMethods(beanName, wrappedBean, mbd)：执行<strong>InitializingBean</strong>中的<strong>afterPropertiesSet</strong></p>
<p>​    i. wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName)：调用<strong>BeanPostProcessor</strong>中的<strong>postProcessAfterInitialization</strong>方法</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上是spring容器从启动到销毁的全部过程，根据源码陈某画了一张生命周期的图，仅供参考，请勿转载！！！</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/lifecy.png" alt=""></p>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg" alt=""></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring解决循环依赖</title>
    <url>/2019/07/17/Spring%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>前几天发表的文章<a href="https://chenjiabing666.github.io/2020/03/12/SpringBoot%E6%95%B4%E5%90%88%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%EF%BC%8C%E4%BD%A0%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/">SpringBoot多数据源动态切换</a>和<a href="https://chenjiabing666.github.io/2020/03/18/SpringBoot%E6%95%B4%E5%90%88%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E5%B7%A8%E5%9D%91/">SpringBoot整合多数据源的巨坑</a>中，提到了一个坑就是动态数据源添加@Primary接口就会造成循环依赖异常，如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/circleex.png" alt="微信所有码猿技术专栏"></p>
<ul>
<li>这个就是典型的构造器依赖，详情请看上面两篇文章，这里不再详细赘述了。本篇文章将会从源码深入解析Spring是如何解决循环依赖的？为什么不能解决构造器的循环依赖？</li>
</ul>
<a id="more"></a>
<h2 id="什么是循环依赖"><a href="#什么是循环依赖" class="headerlink" title="什么是循环依赖"></a>什么是循环依赖</h2><ul>
<li>简单的说就是A依赖B，B依赖C，C依赖A这样就构成了循环依赖。</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/15282870029143.jpg" alt="微信搜索码猿技术专栏"></p>
<ul>
<li>循环依赖分为构造器依赖和属性依赖，众所周知的是Spring能够解决属性的循环依赖（set注入）。下文将从源码角度分析Spring是如何解决属性的循环依赖。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li>如何解决循环依赖，Spring主要的思路就是依据三级缓存，在实例化A时调用doGetBean，发现A依赖的B的实例，此时调用doGetBean去实例B，实例化的B的时候发现又依赖A，如果不解决这个循环依赖的话此时的doGetBean将会无限循环下去，导致内存溢出，程序奔溃。spring引用了一个早期对象，并且把这个”早期引用”并将其注入到容器中，让B先完成实例化，此时A就获取B的引用，完成实例化。</li>
</ul>
<h2 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h2><ul>
<li>Spring能够轻松的解决属性的循环依赖正式用到了三级缓存，在AbstractBeanFactory中有详细的注释。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**一级缓存，用于存放完全初始化好的 bean，从该缓存中取出的 bean 可以直接使用*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</div><div class="line"></div><div class="line"><span class="comment">/**三级缓存 存放 bean 工厂对象，用于解决循环依赖*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</div><div class="line"></div><div class="line"><span class="comment">/**二级缓存 存放原始的 bean 对象（尚未填充属性），用于解决循环依赖*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</div></pre></td></tr></table></figure>
<ul>
<li>一级缓存：singletonObjects，存放完全实例化属性赋值完成的Bean，直接可以使用。</li>
<li>二级缓存：earlySingletonObjects，存放早期Bean的引用，尚未属性装配的Bean</li>
<li>三级缓存：singletonFactories，三级缓存，存放实例化完成的Bean工厂。</li>
</ul>
<h2 id="开撸"><a href="#开撸" class="headerlink" title="开撸"></a>开撸</h2><ul>
<li>先上一张流程图看看Spring是如何解决循环依赖的</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/spring-fix-cirdependence.png" alt="微信搜索码猿技术专栏"></p>
<ul>
<li>上图标记蓝色的部分都是涉及到三级缓存的操作，下面我们一个一个方法解析</li>
</ul>
<p>【1】 getSingleton(beanName)：源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">		<span class="comment">//查询缓存</span></div><div class="line">		Object sharedInstance = getSingleton(beanName);</div><div class="line">		<span class="comment">//缓存中存在并且args是null</span></div><div class="line">		<span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="comment">//.......省略部分代码</span></div><div class="line">            </div><div class="line">     		<span class="comment">//直接获取Bean实例</span></div><div class="line">			bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	<span class="comment">//getSingleton源码，DefaultSingletonBeanRegistry#getSingleton</span></div><div class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</div><div class="line">    	<span class="comment">//先从一级缓存中获取已经实例化属性赋值完成的Bean</span></div><div class="line">		Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</div><div class="line">    	<span class="comment">//一级缓存不存在，并且Bean正处于创建的过程中</span></div><div class="line">		<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</div><div class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</div><div class="line">                <span class="comment">//从二级缓存中查询，获取Bean的早期引用，实例化完成但是未赋值完成的Bean</span></div><div class="line">				singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</div><div class="line">                <span class="comment">//二级缓存中不存在，并且允许创建早期引用（二级缓存中添加）</span></div><div class="line">				<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</div><div class="line">                    <span class="comment">//从三级缓存中查询，实例化完成，属性未装配完成</span></div><div class="line">					ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</div><div class="line">					<span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</div><div class="line">						singletonObject = singletonFactory.getObject();</div><div class="line">                        	<span class="comment">//二级缓存中添加</span></div><div class="line">						<span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</div><div class="line">                        <span class="comment">//从三级缓存中移除</span></div><div class="line">						<span class="keyword">this</span>.singletonFactories.remove(beanName);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> singletonObject;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ul>
<li>从源码可以得知，doGetBean最初是查询缓存，一二三级缓存全部查询，如果三级缓存存在则将Bean早期引用存放在二级缓存中并移除三级缓存。（升级为二级缓存）</li>
</ul>
<p>【2】addSingletonFactory：源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line">		<span class="comment">//中间省略部分代码。。。。。</span></div><div class="line">		<span class="comment">//创建Bean的源码，在AbstractAutowireCapableBeanFactory#doCreateBean方法中</span></div><div class="line">		<span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//实例化Bean</span></div><div class="line">			instanceWrapper = createBeanInstance(beanName, mbd, args);</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//允许提前暴露</span></div><div class="line">		<span class="keyword">if</span> (earlySingletonExposure) &#123;</div><div class="line">            <span class="comment">//添加到三级缓存中</span></div><div class="line">			addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//属性装配，属性赋值的时候，如果有发现属性引用了另外一个Bean，则调用getBean方法</span></div><div class="line">			populateBean(beanName, mbd, instanceWrapper);</div><div class="line">            <span class="comment">//初始化Bean，调用init-method，afterproperties方法等操作</span></div><div class="line">			exposedObject = initializeBean(beanName, exposedObject, mbd);</div><div class="line">		&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line"><span class="comment">//添加到三级缓存的源码，在DefaultSingletonBeanRegistry#addSingletonFactory</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</div><div class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</div><div class="line">            <span class="comment">//一级缓存中不存在</span></div><div class="line">			<span class="keyword">if</span> (!<span class="keyword">this</span>.singletonObjects.containsKey(beanName)) &#123;</div><div class="line">                <span class="comment">//放入三级缓存</span></div><div class="line">				<span class="keyword">this</span>.singletonFactories.put(beanName, singletonFactory);</div><div class="line">                <span class="comment">//从二级缓存中移除，</span></div><div class="line">				<span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</div><div class="line">				<span class="keyword">this</span>.registeredSingletons.add(beanName);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ul>
<li>从源码得知，Bean在实例化完成之后会直接将未装配的Bean工厂存放在<strong>三级缓存</strong>中，并且<strong>移除二级缓存</strong></li>
</ul>
<p>【3】addSingleton：源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//获取单例对象的方法，DefaultSingletonBeanRegistry#getSingleton</span></div><div class="line"><span class="comment">//调用createBean实例化Bean</span></div><div class="line">singletonObject = singletonFactory.getObject();</div><div class="line"></div><div class="line"><span class="comment">//。。。。中间省略部分代码	</span></div><div class="line"></div><div class="line"><span class="comment">//doCreateBean之后才调用，实例化，属性赋值完成的Bean装入一级缓存，可以直接使用的Bean</span></div><div class="line">addSingleton(beanName, singletonObject);</div><div class="line"></div><div class="line"><span class="comment">//addSingleton源码，在DefaultSingletonBeanRegistry#addSingleton方法中</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</div><div class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</div><div class="line">            <span class="comment">//一级缓存中添加</span></div><div class="line">			<span class="keyword">this</span>.singletonObjects.put(beanName, singletonObject);</div><div class="line">            <span class="comment">//移除三级缓存</span></div><div class="line">			<span class="keyword">this</span>.singletonFactories.remove(beanName);</div><div class="line">            <span class="comment">//移除二级缓存</span></div><div class="line">			<span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</div><div class="line">			<span class="keyword">this</span>.registeredSingletons.add(beanName);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ul>
<li>总之一句话，Bean添加到一级缓存，移除二三级缓存。</li>
</ul>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p> 【1】为什么Spring不能解决构造器的循环依赖？</p>
<ul>
<li>从流程图应该不难看出来，在Bean调用构造器实例化之前，一二三级缓存并没有Bean的任何相关信息，在实例化之后才放入三级缓存中，因此当getBean的时候缓存并没有命中，这样就抛出了循环依赖的异常了。</li>
</ul>
<p>【2】为什么多实例Bean不能解决循环依赖？</p>
<ul>
<li>多实例Bean是每次创建都会调用doGetBean方法，根本没有使用一二三级缓存，肯定不能解决循环依赖。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>根据以上的分析，大概清楚了Spring是如何解决循环依赖的。假设A依赖B，B依赖A（注意：这里是set属性依赖）分以下步骤执行：</li>
</ul>
<ol>
<li>A依次执行<strong>doGetBean</strong>、查询缓存、<strong>createBean</strong>创建实例，实例化完成放入三级缓存singletonFactories中，接着执行<strong>populateBean</strong>方法装配属性，但是发现有一个属性是B的对象。</li>
<li>因此再次调用doGetBean方法创建B的实例，依次执行doGetBean、查询缓存、createBean创建实例，实例化完成之后放入三级缓存singletonFactories中，执行populateBean装配属性，但是此时发现有一个属性是A对象。</li>
<li>因此再次调用doGetBean创建A的实例，但是执行到getSingleton查询缓存的时候，从三级缓存中查询到了A的实例(早期引用，未完成属性装配)，此时直接返回A，不用执行后续的流程创建A了，那么B就完成了属性装配，此时是一个完整的对象放入到一级缓存singletonObjects中。</li>
<li>B创建完成了，则A自然完成了属性装配，也创建完成放入了一级缓存singletonObjects中。</li>
</ol>
<ul>
<li>Spring三级缓存的应用完美的解决了循环依赖的问题，下面是循环依赖的解决流程图。</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/cirdependece.PNG" alt="微信搜索码猿技术专栏"></p>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg" alt=""></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper入门</title>
    <url>/2020/04/19/Zookeeper%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>Zookeeper 相信大家都听说过，最典型的使用就是作为服务注册中心。今天陈某带大家从零基础入门 Zookeeper，看了本文，你将会对 Zookeeper 有了初步的了解和认识。</li>
<li>注意：本文基于 Zookeeper 的版本是 3.4.14，最新版本的在使用上会有一些出入，但是企业现在使用的大部分都是 3.4x 版本的。</li>
</ul>
<h2 id="Zookeeper-概述"><a href="#Zookeeper-概述" class="headerlink" title="Zookeeper 概述"></a>Zookeeper 概述</h2><ul>
<li>Zookeeper 是一个分布式协调服务的开源框架。主要用来解决分布式集群中应用系统的一致性问题，例如怎样避免同时操作同一数据造成脏读的问题。</li>
<li>ZooKeeper 本质上是一个分布式的小文件存储系统。提供基于类似于文件系 统的目录树方式的数据存储，并且可以对树中的节点进行有效管理。从而用来维护和监控你存储的数据的状态变化。通过监控这些数据状态的变化，从而可以达 到基于数据的集群管理。诸如：<code>统一命名服务</code>、<code>分布式配置管理</code>、<code>分布式消息队列</code>、<code>分布式锁</code>、<code>分布式协调</code>等功能。</li>
</ul>
<h2 id="Zookeeper-特性"><a href="#Zookeeper-特性" class="headerlink" title="Zookeeper 特性"></a>Zookeeper 特性</h2><ol>
<li><p><code>全局数据一致</code>：每个 server 保存一份相同的数据副本，client 无论连 接到哪个 server，展示的数据都是一致的，这是最重要的特征；</p>
</li>
<li><p><code>可靠性</code>：如果消息被其中一台服务器接受，那么将被所有的服务器接受。</p>
</li>
<li><p><code>顺序性</code>：包括全局有序和偏序两种：全局有序是指如果在一台服务器上 消息 a 在消息 b 前发布，则在所有 Server 上消息 a 都将在消息 b 前被 发布；偏序是指如果一个消息 b 在消息 a 后被同一个发送者发布，a 必将排在 b 前面。</p>
</li>
<li><p><code>数据更新原子性</code>：一次数据更新要么成功（半数以上节点成功），要么失 败，不存在中间状态；</p>
</li>
<li><p><code>实时性</code>：Zookeeper 保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。</p>
</li>
</ol>
<h2 id="Zookeeper-节点类型"><a href="#Zookeeper-节点类型" class="headerlink" title="Zookeeper 节点类型"></a>Zookeeper 节点类型</h2><ul>
<li>Znode 有两种，分别为临时节点和永久节点。<ul>
<li><code>临时节点</code>：该节点的生命周期依赖于创建它们的会话。一旦会话结束，临时节点将被自动删除，当然可以也可以手动删除。临时节点不允许拥有子节点。</li>
<li><code>永久节点</code>：该节点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，他们才能被删除。</li>
</ul>
</li>
<li>节点的类型在创建时即被确定，并且不能改变。</li>
<li>Znode 还有一个序列化的特性，如果创建的时候指定的话，该 Znode 的名字后面会自动追加一个不断增加的序列号。序列号对于此节点的父节点来说是唯一的，这样便会记录每个子节点创建的先后顺序。它的格式为<code>&quot;%10d&quot;</code>(10 位数字,没有数值的数位用 0 补充，例如“0000000001”)。</li>
<li>这样便会存在四种类型的 Znode 节点，分类如下：<ul>
<li><code>PERSISTENT</code>：永久节点</li>
<li><code>EPHEMERAL</code>：临时节点</li>
<li><code>PERSISTENT_SEQUENTIAL</code>：永久节点、序列化</li>
<li><code>EPHEMERAL_SEQUENTIAL</code>：临时节点、序列化</li>
</ul>
</li>
</ul>
<h2 id="ZooKeeper-Watcher"><a href="#ZooKeeper-Watcher" class="headerlink" title="ZooKeeper Watcher"></a>ZooKeeper Watcher</h2><ul>
<li>ZooKeeper 提供了分布式数据发布/订阅功能，一个典型的发布/订阅模型系统定义了一种一对多的订阅关系，能让多个订阅者同时监听某一个主题对象，当这个主题对象自身状态变化时，会通知所有订阅者，使他们能够做出相应的处理。</li>
<li>触发事件种类很多，如：节点创建，节点删除，节点改变，子节点改变等。</li>
<li>总的来说可以概括 Watcher 为以下三个过程：客户端向服务端注册 Watcher、服务端事件发生触发 Watcher、客户端回调 Watcher 得到触发事件情况。</li>
</ul>
<h2 id="Watcher-机制特点"><a href="#Watcher-机制特点" class="headerlink" title="Watcher 机制特点"></a>Watcher 机制特点</h2><ul>
<li><p><code>一次性触发</code> ：事件发生触发监听，一个 watcher event 就会被发送到设置监听的客户端，这种效果是一次性的，后续再次发生同样的事件，不会再次触发。</p>
</li>
<li><p><code>事件封装</code> ：ZooKeeper 使用 WatchedEvent 对象来封装服务端事件并传递。WatchedEvent 包含了每一个事件的三个基本属性： <code>通知状态</code>（keeperState），<code>事件类型</code>（EventType）和<code>节点路径</code>（path）。</p>
</li>
<li><p><code>event 异步发送</code> ：watcher 的通知事件从服务端发送到客户端是异步的。</p>
</li>
<li><p><code>先注册再触发</code> ：Zookeeper 中的 watch 机制，必须客户端先去服务端注册监听，这样事件发送才会触发监听，通知给客户端。</p>
</li>
</ul>
<h2 id="常用-Shell-命令"><a href="#常用-Shell-命令" class="headerlink" title="常用 Shell 命令"></a>常用 Shell 命令</h2><h3 id="新增节点"><a href="#新增节点" class="headerlink" title="新增节点"></a>新增节点</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">create [<span class="_">-s</span>] [<span class="_">-e</span>] path data</div></pre></td></tr></table></figure>
<ul>
<li><code>-s</code>：表示创建有序节点</li>
<li><code>-e</code>：表示创建临时节点</li>
<li>创建持久化节点：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">create /<span class="built_in">test</span> 1234</div><div class="line"></div><div class="line"><span class="comment">## 子节点</span></div><div class="line">create /<span class="built_in">test</span>/node1 node1</div></pre></td></tr></table></figure>
<ul>
<li>创建持久化有序节点：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment">## 完整的节点名称是a0000000001</span></div><div class="line">create /a a</div><div class="line">Created /a0000000001</div><div class="line"></div><div class="line"><span class="comment">## 完整的节点名称是b0000000002</span></div><div class="line">create /b b</div><div class="line">Created /b0000000002</div></pre></td></tr></table></figure>
<ul>
<li>创建临时节点：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">create <span class="_">-e</span> /a a</div></pre></td></tr></table></figure>
<ul>
<li>创建临时有序节点：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment">## 完整的节点名称是a0000000001</span></div><div class="line">create <span class="_">-e</span> <span class="_">-s</span> /a a</div><div class="line">Created /a0000000001</div></pre></td></tr></table></figure>
<h3 id="更新节点"><a href="#更新节点" class="headerlink" title="更新节点"></a>更新节点</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="built_in">set</span> [path] [data] [version]</div></pre></td></tr></table></figure>
<ul>
<li><code>path</code>：节点路径</li>
<li><code>data</code>：数据</li>
<li><code>version</code>：版本号</li>
<li>修改节点数据：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="built_in">set</span> /<span class="built_in">test</span> aaa</div><div class="line"></div><div class="line"><span class="comment">## 修改子节点</span></div><div class="line"><span class="built_in">set</span> /<span class="built_in">test</span>/node1 bbb</div></pre></td></tr></table></figure>
<ul>
<li>基于数据版本号修改，如果修改的节点的版本号(<code>dataVersion</code>)不正确，拒绝修改</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="built_in">set</span> /<span class="built_in">test</span> aaa 1</div></pre></td></tr></table></figure>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">delete [path] [version]</div></pre></td></tr></table></figure>
<ul>
<li><code>path</code>：节点路径</li>
<li><code>version</code>：版本号，版本号不正确拒绝删除</li>
<li>删除节点</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">delete /<span class="built_in">test</span></div><div class="line"></div><div class="line"><span class="comment">## 版本号删除</span></div><div class="line">delete /<span class="built_in">test</span> 2</div></pre></td></tr></table></figure>
<ul>
<li>递归删除，删除某个节点及后代</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">rmr /<span class="built_in">test</span></div></pre></td></tr></table></figure>
<h3 id="查看节点数据和状态"><a href="#查看节点数据和状态" class="headerlink" title="查看节点数据和状态"></a>查看节点数据和状态</h3><ul>
<li>命令格式如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">get path</div></pre></td></tr></table></figure>
<ul>
<li>获取节点详情：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment">## 获取节点详情</span></div><div class="line">get /node1</div><div class="line"></div><div class="line"><span class="comment">## 节点内容</span></div><div class="line">aaa</div><div class="line">cZxid = 0x6</div><div class="line">ctime = Sun Apr 05 14:50:10 CST 2020</div><div class="line">mZxid = 0x6</div><div class="line">mtime = Sun Apr 05 14:50:10 CST 2020</div><div class="line">pZxid = 0x7</div><div class="line">cversion = 1</div><div class="line">dataVersion = 0</div><div class="line">aclVersion = 0</div><div class="line">ephemeralOwner = 0x0</div><div class="line">dataLength = 3</div><div class="line">numChildren = 1</div></pre></td></tr></table></figure>
<ul>
<li>节点各个属性对应的含义如下：<ul>
<li><code>cZxid</code>：数据节点创建时的事务 ID。</li>
<li><code>ctime</code>：数据节点创建时间。</li>
<li><code>mZxid</code>：数据节点最后一次更新时的事务 ID。</li>
<li><code>mtime</code>：数据节点最后一次更新的时间。</li>
<li><code>pZxid</code>：数据节点的子节点最后一次被修改时的事务 ID。</li>
<li><code>cversion</code>：子节点的更改次数。</li>
<li><code>dataVersion</code>：节点数据的更改次数。</li>
<li><code>aclVersion</code>  ：节点 ACL 的更改次数。</li>
<li><code>ephemeralOwner</code>：如果节点是临时节点，则表示创建该节点的会话的 SessionID。如果节点是持久化节点，值为 0。</li>
<li><code>dataLength</code>  ：节点数据内容的长度。</li>
<li><code>numChildren</code>：数据节点当前的子节点的个数。</li>
</ul>
</li>
</ul>
<h3 id="查看节点状态"><a href="#查看节点状态" class="headerlink" title="查看节点状态"></a>查看节点状态</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="built_in">stat</span> path</div></pre></td></tr></table></figure>
<ul>
<li><code>stat</code>命令和<code>get</code>命令相似，不过这个命令不会返回节点的数据，只返回节点的状态属性。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="built_in">stat</span> /node1</div><div class="line"></div><div class="line"><span class="comment">## 节点状态信息，没有节点数据</span></div><div class="line">cZxid = 0x6</div><div class="line">ctime = Sun Apr 05 14:50:10 CST 2020</div><div class="line">mZxid = 0x6</div><div class="line">mtime = Sun Apr 05 14:50:10 CST 2020</div><div class="line">pZxid = 0x7</div><div class="line">cversion = 1</div><div class="line">dataVersion = 0</div><div class="line">aclVersion = 0</div><div class="line">ephemeralOwner = 0x0</div><div class="line">dataLength = 3</div><div class="line">numChildren = 1</div></pre></td></tr></table></figure>
<h3 id="查看节点列表"><a href="#查看节点列表" class="headerlink" title="查看节点列表"></a>查看节点列表</h3><ul>
<li>查看节点列表有<code>ls path</code>和<code>ls2 path</code>两个命令。后者是前者的增强，不仅会返回节点列表还会返回当前节点的状态信息。</li>
<li><code>ls path</code>：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">ls /</div><div class="line"></div><div class="line"><span class="comment">## 仅仅返回节点列表</span></div><div class="line">[zookeeper, node1]</div></pre></td></tr></table></figure>
<ul>
<li><code>ls2 path</code>：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">ls2 /</div><div class="line"></div><div class="line"><span class="comment">## 返回节点列表和当前节点的状态信息</span></div><div class="line">[zookeeper, node1]</div><div class="line">cZxid = 0x0</div><div class="line">ctime = Thu Jan 01 08:00:00 CST 1970</div><div class="line">mZxid = 0x0</div><div class="line">mtime = Thu Jan 01 08:00:00 CST 1970</div><div class="line">pZxid = 0x6</div><div class="line">cversion = 2</div><div class="line">dataVersion = 0</div><div class="line">aclVersion = 0</div><div class="line">ephemeralOwner = 0x0</div><div class="line">dataLength = 0</div><div class="line">numChildren = 2</div></pre></td></tr></table></figure>
<h3 id="监听器-get-path-watch"><a href="#监听器-get-path-watch" class="headerlink" title="监听器 get path watch"></a>监听器 get path watch</h3><ul>
<li>使用<code>get path watch</code>注册的监听器在<code>节点内容</code>发生改变时，向客户端发送通知，注意 Zookeeper 的触发器是一次性的，触发一次后会立即生效。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">get /node1 watch</div><div class="line"></div><div class="line"><span class="comment">## 改变节点数据</span></div><div class="line"><span class="built_in">set</span> /node1 bbb</div><div class="line"></div><div class="line"><span class="comment">## 监听到节点内容改变了</span></div><div class="line">WATCHER::</div><div class="line">WatchedEvent state:SyncConnected <span class="built_in">type</span>:NodeDataChanged path:/node1</div></pre></td></tr></table></figure>
<h3 id="监听器-stat-path-watch"><a href="#监听器-stat-path-watch" class="headerlink" title="监听器 stat path watch"></a>监听器 stat path watch</h3><ul>
<li><code>stat path watch</code>注册的监听器能够在<code>节点状态</code>发生改变时向客户端发出通知。比如节点数据改变、节点被删除等。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="built_in">stat</span> /node2 watch</div><div class="line"></div><div class="line"><span class="comment">## 删除节点node2</span></div><div class="line">delete /node2</div><div class="line"></div><div class="line"><span class="comment">## 监听器监听到了节点删除</span></div><div class="line">WATCHER::</div><div class="line">WatchedEvent state:SyncConnected <span class="built_in">type</span>:NodeDeleted path:/node2</div></pre></td></tr></table></figure>
<h3 id="监听器-ls-ls2-path-watch"><a href="#监听器-ls-ls2-path-watch" class="headerlink" title="监听器 ls/ls2 path watch"></a>监听器 ls/ls2 path watch</h3><ul>
<li>使用<code>ls path watch</code>或者<code>ls2 path watch</code>注册的监听器，能够监听到该节点下的子节点的<code>增加</code>和<code>删除</code>操作。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">ls /node1 watch</div><div class="line"></div><div class="line"><span class="comment">## 创建子节点</span></div><div class="line">create /node1/b b</div><div class="line"></div><div class="line"><span class="comment">## 监听到了子节点的新增</span></div><div class="line">WATCHER::</div><div class="line">WatchedEvent state:SyncConnected <span class="built_in">type</span>:NodeChildrenChanged path:/node1</div></pre></td></tr></table></figure>
<h2 id="Zookeeper-的-ACL-权限控制"><a href="#Zookeeper-的-ACL-权限控制" class="headerlink" title="Zookeeper 的 ACL 权限控制"></a>Zookeeper 的 ACL 权限控制</h2><ul>
<li>zookeeper 类似文件控制系统，client 可以创建，删除，修改，查看节点，那么如何做到权限控制的呢？zookeeper 的<code>access control list</code> 访问控制列表可以做到这一点。</li>
<li>ACL 权限控制，使用<code>scheme:id:permission</code>来标识。<ul>
<li><code>权限模式(scheme)</code>：授权的策略</li>
<li><code>授权对象(id)</code>：授权的对象</li>
<li><code>权限(permission)</code>：授予的权限</li>
</ul>
</li>
<li>权限控制是基于每个节点的，需要对每个节点设置权限。</li>
<li>每个节点支持设置多种权限控制方案和多个权限。</li>
<li>子节点不会继承父节点的权限，客户端无权访问某节点，但可能可以访问它的子节点。</li>
<li>例如：根据 IP 地址进行授权，命令如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="built_in">set</span>ACl /node1 ip:192.168.10.1:crdwa</div></pre></td></tr></table></figure>
<h3 id="权限模式"><a href="#权限模式" class="headerlink" title="权限模式"></a>权限模式</h3><ul>
<li>权限模式即是采用何种方式授权。</li>
<li><code>world</code>：只有一个用户，anyone，表示登录 zookeeper 所有人（默认的模式）。</li>
<li><code>ip</code>：对客户端使用 IP 地址认证。</li>
<li><code>auth</code>：使用已添加认证的用户认证。</li>
<li><code>digest</code>：使用<code>用户名:密码</code>方式认证。</li>
</ul>
<h3 id="授权对象"><a href="#授权对象" class="headerlink" title="授权对象"></a>授权对象</h3><ul>
<li>给谁授权，授权对象的 ID 指的是权限赋予的实体，例如 IP 地址或用户。</li>
</ul>
<h3 id="授予的权限"><a href="#授予的权限" class="headerlink" title="授予的权限"></a>授予的权限</h3><ul>
<li>授予的权限包括<code>create</code>、<code>delete</code>、<code>read</code>、<code>writer</code>、<code>admin</code>。也就是增、删、改、查、管理的权限，简写<code>cdrwa</code>。</li>
<li><strong>注意</strong>：以上 5 种权限中，<code>delete</code>是指对子节点的删除权限，其他 4 种权限是对自身节点的操作权限。</li>
<li><code>create</code>：简写<code>c</code>，可以创建子节点。</li>
<li><code>delete</code>：简写<code>d</code>，可以删除子节点（仅下一级节点）。</li>
<li><code>read</code>：简写<code>r</code>，可以读取节点数据以及显示子节点列表。</li>
<li><code>write</code>：简写<code>w</code>，可以更改节点数据。</li>
<li><code>admin</code>：简写<code>a</code>，可以设置节点访问控制列表权限。</li>
</ul>
<h3 id="授权相关命令"><a href="#授权相关命令" class="headerlink" title="授权相关命令"></a>授权相关命令</h3><ul>
<li><code>getAcl [path]</code>：读取指定节点的 ACL 权限。</li>
<li><code>setAcl [path] [acl]</code>：设置 ACL</li>
<li><code>addauth &lt;scheme&gt; &lt;auth&gt;</code>：添加认证用户，和 auth，digest 授权模式相关。</li>
</ul>
<h3 id="world-授权模式案例"><a href="#world-授权模式案例" class="headerlink" title="world 授权模式案例"></a>world 授权模式案例</h3><ul>
<li>zookeeper 中默认的授权模式，针对登录 zookeeper 的任何用户授予指定的权限。命令如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="built_in">set</span>Acl [path] world:anyone:[permission]</div></pre></td></tr></table></figure>
<ul>
<li><code>path</code>：节点</li>
<li><code>permission</code>：授予的权限，比如<code>cdrwa</code></li>
<li>去掉不能读取节点数据的权限：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment">## 获取权限列表（默认的）</span></div><div class="line">getAcl /node2</div><div class="line"></div><div class="line"><span class="string">'world,'</span>anyone</div><div class="line">: cdrwa</div><div class="line"></div><div class="line"><span class="comment">## 去掉读取节点数据的的权限，去掉r</span></div><div class="line"><span class="built_in">set</span>Acl /node2 world:anyone:cdwa</div><div class="line"></div><div class="line"><span class="comment">## 再次获取权限列表</span></div><div class="line">getAcl /node2</div><div class="line"></div><div class="line"><span class="string">'world,'</span>anyone</div><div class="line">: cdwa</div><div class="line"></div><div class="line"><span class="comment">## 获取节点数据，没有权限，失败</span></div><div class="line">get /node2</div><div class="line"></div><div class="line">Authentication is not valid : /node2</div></pre></td></tr></table></figure>
<h3 id="IP-授权模式案例"><a href="#IP-授权模式案例" class="headerlink" title="IP 授权模式案例"></a>IP 授权模式案例</h3><ul>
<li>针对登录用户的 ip 进行限制权限。命令如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="built_in">set</span>Acl [path] ip:[ip]:[acl]</div></pre></td></tr></table></figure>
<ul>
<li>远程登录 zookeeper 的命令如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">./zkCli.sh -server ip</div></pre></td></tr></table></figure>
<ul>
<li>设置<code>192.168.10.1</code>这个 ip 的增删改查管理的权限。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="built_in">set</span>Acl /node2 ip:192.168.10.1:crdwa</div></pre></td></tr></table></figure>
<h3 id="Auth-授权模式案例"><a href="#Auth-授权模式案例" class="headerlink" title="Auth 授权模式案例"></a>Auth 授权模式案例</h3><ul>
<li>auth 授权模式需要有一个认证用户，添加命令如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">addauth digest [username]:[password]</div></pre></td></tr></table></figure>
<ul>
<li>设置 auth 授权模式命令如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="built_in">set</span>Acl [path] auth:[user]:[acl]</div></pre></td></tr></table></figure>
<ul>
<li>为<code>chenmou</code>这个账户添加 cdrwa 权限：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment">## 添加一个认证账户</span></div><div class="line">addauth digest chenmou:123456</div><div class="line"></div><div class="line"><span class="comment">## 添加权限</span></div><div class="line"><span class="built_in">set</span>Acl /node2 auth:chenmou:crdwa</div></pre></td></tr></table></figure>
<h3 id="多种模式授权"><a href="#多种模式授权" class="headerlink" title="多种模式授权"></a>多种模式授权</h3><ul>
<li>zookeeper 中同一个节点可以使用多种授权模式，多种授权模式用<code>,</code>分隔。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment">## 创建节点</span></div><div class="line">create /node3</div><div class="line"></div><div class="line"><span class="comment">## 添加认证用户</span></div><div class="line">addauth chenmou:123456</div><div class="line"></div><div class="line"><span class="comment">## 添加多种授权模式</span></div><div class="line"><span class="built_in">set</span>Acl /node3 ip:192.178.10.1:crdwa,auth:chenmou:crdwa</div></pre></td></tr></table></figure>
<h3 id="ACL-超级管理员"><a href="#ACL-超级管理员" class="headerlink" title="ACL 超级管理员"></a>ACL 超级管理员</h3><ul>
<li>zookeeper 的权限管理模式有一种叫做<code>super</code>，该模式提供一个超管可以方便的访问任何权限的节点。</li>
<li>假设这个超管是<code>super:admin</code>，需要先为超管生成密码的密文：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="built_in">echo</span> -n super:admin | openssl dgst  -binary -sha1 |openssl base64</div><div class="line"></div><div class="line"><span class="comment">## 执行完生成了秘钥</span></div><div class="line">xQJmxLMiHGwaqBvst5y6rkB6HQs=</div></pre></td></tr></table></figure>
<ul>
<li>打开<code>zookeeper</code>目录下<code>/bin/zkServer.sh</code>，找到如下一行：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">nohup JAVA&amp;quot;−Dzookeeper.log.dir=JAVA<span class="string">"−Dzookeeper.log.dir=&#123;ZOO_LOG_DIR&#125;"</span> <span class="string">"-Dzookeeper.root.logger=<span class="variable">$&#123;ZOO_LOG4J_PROP&#125;</span>"</span></div></pre></td></tr></table></figure>
<ul>
<li>在后面添加一行脚本，如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="string">"-Dzookeeper.DigestAuthenticationProvider.superDigest=super:xQJmxLMiHGwaqBvst5y6rkB6HQs="</span></div></pre></td></tr></table></figure>
<ul>
<li>此时完整的脚本如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">nohup <span class="string">"<span class="variable">$JAVA</span>"</span> <span class="string">"-Dzookeeper.log.dir=<span class="variable">$&#123;ZOO_LOG_DIR&#125;</span>"</span> <span class="string">"-Dzookeeper.root.logger=<span class="variable">$&#123;ZOO_LOG4J_PROP&#125;</span>"</span> <span class="string">"-Dzookeeper.DigestAuthenticationProvider.superDigest=super:xQJmxLMiHGwaqBvst5y6rkB6HQs="</span> \</div><div class="line">    -cp <span class="string">"<span class="variable">$CLASSPATH</span>"</span> <span class="variable">$JVMFLAGS</span> <span class="variable">$ZOOMAIN</span> <span class="string">"<span class="variable">$ZOOCFG</span>"</span> &gt; <span class="string">"<span class="variable">$_ZOO_DAEMON_OUT</span>"</span> 2&gt;&amp;1 &lt; /dev/null &amp;</div></pre></td></tr></table></figure>
<ul>
<li>重启 zookeeper</li>
<li>重启完成之后此时超管即配置完成，如果需要使用，则使用如下命令：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">addauth digest super:admin</div></pre></td></tr></table></figure>
<h2 id="Curator-客户端"><a href="#Curator-客户端" class="headerlink" title="Curator 客户端"></a>Curator 客户端</h2><ul>
<li>Curator 是 Netflix 公司开源的一个 Zookeeper 客户端，与 Zookeeper 提供的原生客户端相比，Curator 的抽象层次更高，简化了 Zookeeper 客户端的开发量。</li>
</ul>
<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></div><div class="line">                   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">                   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">               <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></div><div class="line">           <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><ul>
<li>客户端建立与 Zookeeper 的连接，这里仅仅演示单机版本的连接，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//创建CuratorFramework，用来操作api</span></div><div class="line">CuratorFramework  client = CuratorFrameworkFactory.builder()</div><div class="line">    <span class="comment">//ip地址+端口号，如果是集群，逗号分隔</span></div><div class="line">    .connectString(<span class="string">"120.26.101.207:2181"</span>)</div><div class="line">    <span class="comment">//会话超时时间</span></div><div class="line">    .sessionTimeoutMs(<span class="number">5000</span>)</div><div class="line">    <span class="comment">//超时重试策略,RetryOneTime：超时重连仅仅一次</span></div><div class="line">    .retryPolicy(<span class="keyword">new</span> RetryOneTime(<span class="number">3000</span>))</div><div class="line">    <span class="comment">//命名空间，父节点，如果不指定是在根节点下</span></div><div class="line">    .namespace(<span class="string">"node4"</span>)</div><div class="line">    .build();</div><div class="line"><span class="comment">//启动</span></div><div class="line">client.start();</div></pre></td></tr></table></figure>
<h3 id="重连策略"><a href="#重连策略" class="headerlink" title="重连策略"></a>重连策略</h3><ul>
<li>会话连接策略，即是当客户端与 Zookeeper 断开连接之后，客户端重新连接 Zookeeper 时使用的策略，比如重新连接一次。</li>
<li><code>RetryOneTime：</code>N 秒后重连一次，仅仅一次，演示如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">.retryPolicy(<span class="keyword">new</span> RetryOneTime(<span class="number">3000</span>))</div></pre></td></tr></table></figure>
<ul>
<li><code>RetryNTimes</code>：每 n 秒重连一次，重连 m 次。演示如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//每三秒重连一次，重连3次。arg1：多长时间后重连，单位毫秒，arg2：总共重连几次</span></div><div class="line">.retryPolicy(<span class="keyword">new</span> RetryNTimes(<span class="number">3000</span>,<span class="number">3</span>))</div></pre></td></tr></table></figure>
<ul>
<li><code>RetryUntilElapsed</code>：设置了最大等待时间，如果超过这个最大等待时间将会不再连接。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//每三秒重连一次，等待时间超过10秒不再重连。arg1：总等待时间，arg2：多长时间重连，单位毫秒</span></div><div class="line">.retryPolicy(<span class="keyword">new</span> RetryUntilElapsed(<span class="number">10000</span>,<span class="number">3000</span>))</div></pre></td></tr></table></figure>
<h3 id="新增节点-1"><a href="#新增节点-1" class="headerlink" title="新增节点"></a>新增节点</h3><ul>
<li>新增节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">client.create()</div><div class="line">    <span class="comment">//指定节点的类型。PERSISTENT：持久化节点，PERSISTENT_SEQUENTIAL：持久化有序节点，EPHEMERAL：临时节点，EPHEMERAL_SEQUENTIAL临时有序节点</span></div><div class="line">    .withMode(CreateMode.PERSISTENT)</div><div class="line">    <span class="comment">//指定权限列表，OPEN_ACL_UNSAFE：world:anyone:crdwa</span></div><div class="line">    .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)</div><div class="line">    <span class="comment">//写入节点数据，arg1:节点名称 arg2:节点数据</span></div><div class="line">    .forPath(<span class="string">"/a"</span>, <span class="string">"a"</span>.getBytes());</div></pre></td></tr></table></figure>
<ul>
<li>自定义权限列表：<code>withACL(acls)</code>方法中可以设置自定义的权限列表，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//自定义权限列表</span></div><div class="line">List&lt;ACL&gt; acls=<span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="comment">//指定授权模式和授权对象 arg1:授权模式，arg2授权对象</span></div><div class="line">Id id=<span class="keyword">new</span> Id(<span class="string">"ip"</span>,<span class="string">"127.0.0.1"</span>);</div><div class="line"><span class="comment">//指定授予的权限，ZooDefs.Perms.ALL:crdwa</span></div><div class="line">acls.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.ALL,id));</div><div class="line">client.create()</div><div class="line">    .withMode(CreateMode.PERSISTENT)</div><div class="line">    <span class="comment">//指定自定义权限列表</span></div><div class="line">    .withACL(acls)</div><div class="line">    .forPath(<span class="string">"/b"</span>, <span class="string">"b"</span>.getBytes());</div></pre></td></tr></table></figure>
<ul>
<li>递归创建节点：<code>creatingParentsIfNeeded()</code>方法对于创建多层节点，如果其中一个节点不存在的话会自动创建</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//递归创建节点</span></div><div class="line">client.create()</div><div class="line">    <span class="comment">//递归方法，如果节点不存在，那么创建该节点</span></div><div class="line">    .creatingParentsIfNeeded()</div><div class="line">    .withMode(CreateMode.PERSISTENT)</div><div class="line">    .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)</div><div class="line">    <span class="comment">//test节点和b节点不存在，递归创建出来</span></div><div class="line">    .forPath(<span class="string">"/test/a"</span>, <span class="string">"a"</span>.getBytes());</div></pre></td></tr></table></figure>
<ul>
<li>异步创建节点：<code>inBackground()</code>方法可以异步回调创建节点，创建完成后会自动回调实现的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="comment">//异步创建节点</span></div><div class="line">client.create()</div><div class="line">    .withMode(CreateMode.PERSISTENT)</div><div class="line">    .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)</div><div class="line">    <span class="comment">//异步创建</span></div><div class="line">    .inBackground(<span class="keyword">new</span> BackgroundCallback() &#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">        * <span class="doctag">@param</span> curatorFramework 客户端对象</div><div class="line">        * <span class="doctag">@param</span> curatorEvent 事件对象</div><div class="line">        */</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(CuratorFramework curatorFramework, CuratorEvent curatorEvent)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            <span class="comment">//打印事件类型</span></div><div class="line">            System.out.println(curatorEvent.getType());</div><div class="line">            &#125;</div><div class="line">    &#125;)</div><div class="line">    .forPath(<span class="string">"/test1"</span>, <span class="string">"a"</span>.getBytes());</div></pre></td></tr></table></figure>
<h3 id="更新节点数据"><a href="#更新节点数据" class="headerlink" title="更新节点数据"></a>更新节点数据</h3><ul>
<li>更新节点，当节点不存在会报错，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">client.setData()</div><div class="line">      .forPath(<span class="string">"/a"</span>,<span class="string">"a"</span>.getBytes());</div></pre></td></tr></table></figure>
<ul>
<li>携带版本号更新节点，当版本错误拒绝更新</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">client.setData()</div><div class="line">    <span class="comment">//指定版本号更新，如果版本号错误则拒绝更新</span></div><div class="line">    .withVersion(<span class="number">1</span>)</div><div class="line">    .forPath(<span class="string">"/a"</span>,<span class="string">"a"</span>.getBytes());</div></pre></td></tr></table></figure>
<ul>
<li>异步更新节点数据：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">client.setData()</div><div class="line">        <span class="comment">//异步更新</span></div><div class="line">        .inBackground(<span class="keyword">new</span> BackgroundCallback() &#123;</div><div class="line">        <span class="comment">//回调方法</span></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(CuratorFramework curatorFramework, CuratorEvent curatorEvent)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                   &#125;</div><div class="line">        &#125;)</div><div class="line">		.forPath(<span class="string">"/a"</span>,<span class="string">"a"</span>.getBytes());</div></pre></td></tr></table></figure>
<h3 id="删除节点-1"><a href="#删除节点-1" class="headerlink" title="删除节点"></a>删除节点</h3><ul>
<li>删除当前节点，如果有子节点则拒绝删除</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">client.delete()</div><div class="line">    <span class="comment">//删除节点，如果是该节点包含子节点，那么不能删除</span></div><div class="line">    .forPath(<span class="string">"/a"</span>);</div></pre></td></tr></table></figure>
<ul>
<li>指定版本号删除，如果版本错误则拒绝删除</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">client.delete()</div><div class="line">    <span class="comment">//指定版本号删除</span></div><div class="line">    .withVersion(<span class="number">1</span>)</div><div class="line">    <span class="comment">//删除节点，如果是该节点包含子节点，那么不能删除</span></div><div class="line">    .forPath(<span class="string">"/a"</span>);</div></pre></td></tr></table></figure>
<ul>
<li>如果当前节点包含子节点则一并删除，使用<code>deletingChildrenIfNeeded()</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">client.delete()</div><div class="line">    <span class="comment">//如果删除的节点包含子节点则一起删除</span></div><div class="line">    .deletingChildrenIfNeeded()</div><div class="line">    <span class="comment">//删除节点，如果是该节点包含子节点，那么不能删除</span></div><div class="line">    .forPath(<span class="string">"/a"</span>);</div></pre></td></tr></table></figure>
<ul>
<li>异步删除节点，使用<code>inBackground()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">client.delete()</div><div class="line">	.deletingChildrenIfNeeded()</div><div class="line">	<span class="comment">//异步删除节点</span></div><div class="line">    .inBackground(<span class="keyword">new</span> BackgroundCallback() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(CuratorFramework curatorFramework, CuratorEvent curatorEvent)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//回调监听</span></div><div class="line">        &#125;</div><div class="line">       &#125;)</div><div class="line">    <span class="comment">//删除节点，如果是该节点包含子节点，那么不能删除</span></div><div class="line">    .forPath(<span class="string">"/a"</span>);</div></pre></td></tr></table></figure>
<h3 id="获取节点数据"><a href="#获取节点数据" class="headerlink" title="获取节点数据"></a>获取节点数据</h3><ul>
<li>同步获取节点数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">byte</span>[] bytes = client.getData().forPath(<span class="string">"/node1"</span>);</div><div class="line">System.out.println(<span class="keyword">new</span> String(bytes));</div></pre></td></tr></table></figure>
<ul>
<li>获取节点状态和数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//保存节点状态</span></div><div class="line">Stat stat=<span class="keyword">new</span> Stat();</div><div class="line"><span class="keyword">byte</span>[] bytes = client.getData()</div><div class="line">	<span class="comment">//获取节点状态存储在stat对象中</span></div><div class="line">    .storingStatIn(stat)</div><div class="line">    .forPath(<span class="string">"/node1"</span>);</div><div class="line">System.out.println(<span class="keyword">new</span> String(bytes));</div><div class="line"><span class="comment">//获取节点数据的长度</span></div><div class="line">System.out.println(stat.getDataLength());</div></pre></td></tr></table></figure>
<ul>
<li>异步获取节点数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">client.getData()</div><div class="line">    <span class="comment">//异步获取节点数据，回调监听</span></div><div class="line">     .inBackground((curatorFramework, curatorEvent) -&gt; &#123;</div><div class="line">          <span class="comment">//节点数据</span></div><div class="line">          System.out.println(<span class="keyword">new</span> String(curatorEvent.getData()));</div><div class="line">      &#125;)</div><div class="line">     .forPath(<span class="string">"/node1"</span>);</div></pre></td></tr></table></figure>
<h3 id="获取子节点"><a href="#获取子节点" class="headerlink" title="获取子节点"></a>获取子节点</h3><ul>
<li>同步获取全部子节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">List&lt;String&gt; strs = client.getChildren().forPath(<span class="string">"/"</span>);</div><div class="line">       <span class="keyword">for</span> (String str:strs) &#123;</div><div class="line">           System.out.println(str);</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<ul>
<li>异步获取全部子节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">client.getChildren()</div><div class="line"><span class="comment">//异步获取</span></div><div class="line">.inBackground((curatorFramework, curatorEvent) -&gt; &#123;</div><div class="line">        List&lt;String&gt; strs = curatorEvent.getChildren();</div><div class="line">        <span class="keyword">for</span> (String str:strs) &#123;</div><div class="line">              System.out.println(str);</div><div class="line">        &#125;</div><div class="line">  &#125;)</div><div class="line">.forPath(<span class="string">"/"</span>);</div></pre></td></tr></table></figure>
<h3 id="查看节点是否存在"><a href="#查看节点是否存在" class="headerlink" title="查看节点是否存在"></a>查看节点是否存在</h3><ul>
<li>同步查看</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//如果节点不存在，stat为null</span></div><div class="line">Stat stat = client.checkExists().forPath(<span class="string">"/node"</span>);</div></pre></td></tr></table></figure>
<ul>
<li>异步查看</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//如果节点不存在，stat为null</span></div><div class="line">client.checkExists()</div><div class="line">    .inBackground((curatorFramework, curatorEvent) -&gt; &#123;</div><div class="line">    <span class="comment">//如果为null则不存在</span></div><div class="line">    System.out.println(curatorEvent.getStat());</div><div class="line">    &#125;)</div><div class="line">    .forPath(<span class="string">"/node"</span>);</div></pre></td></tr></table></figure>
<h3 id="Watcher-API"><a href="#Watcher-API" class="headerlink" title="Watcher API"></a>Watcher API</h3><ul>
<li>curator 提供了两种 watcher 来监听节点的变化<ul>
<li><code>NodeCache</code>：监听一个特定的节点，监听新增和修改</li>
<li><code>PathChildrenCache</code>：监听一个节点的子节点，当一个子节点增加、删除、更新时，path Cache 会改变他的状态，会包含最新的子节点的数据和状态。</li>
</ul>
</li>
<li>NodeCache 演示：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//arg1:连接对象 arg2:监听的节点路径,/namespace/path</span></div><div class="line"><span class="keyword">final</span> NodeCache nodeCache = <span class="keyword">new</span> NodeCache(client, <span class="string">"/w1"</span>);</div><div class="line"><span class="comment">//启动监听</span></div><div class="line">nodeCache.start();</div><div class="line"><span class="comment">//添加监听器</span></div><div class="line">nodeCache.getListenable().addListener(() -&gt; &#123;</div><div class="line">    <span class="comment">//节点路径</span></div><div class="line">    System.out.println(nodeCache.getCurrentData().getPath());</div><div class="line">    <span class="comment">//节点数据</span></div><div class="line">    System.out.println(<span class="keyword">new</span> String(nodeCache.getCurrentData().getData()));</div><div class="line">&#125;);</div><div class="line"><span class="comment">//睡眠100秒</span></div><div class="line">Thread.sleep(<span class="number">1000000</span>);</div><div class="line"><span class="comment">//关闭监听</span></div><div class="line">nodeCache.close();</div></pre></td></tr></table></figure>
<ul>
<li><code>PathChildrenCache</code>演示：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//arg1：连接对象 arg2：节点路径  arg3:是否能够获取节点数据</span></div><div class="line">PathChildrenCache cache=<span class="keyword">new</span> PathChildrenCache(client,<span class="string">"/w1"</span>, <span class="keyword">true</span>);</div><div class="line">cache.start();</div><div class="line">cache.getListenable().addListener((curatorFramework, pathChildrenCacheEvent) -&gt; &#123;</div><div class="line">	<span class="comment">//节点路径</span></div><div class="line">	System.out.println(pathChildrenCacheEvent.getData().getPath());</div><div class="line">	<span class="comment">//节点状态</span></div><div class="line">	System.out.println(pathChildrenCacheEvent.getData().getStat());</div><div class="line">	<span class="comment">//节点数据</span></div><div class="line">	System.out.println(<span class="keyword">new</span> String(pathChildrenCacheEvent.getData().getData()));</div><div class="line">&#125;);</div><div class="line">cache.close();</div></pre></td></tr></table></figure>
<h2 id="小福利"><a href="#小福利" class="headerlink" title="小福利"></a>小福利</h2><ul>
<li>是不是觉得文章太长看得头晕脑胀，为此陈某特地将本篇文章制作成 PDF 文本，需要回去仔细研究的朋友，老规矩，回复关键词<code>ZK入门指南</code>。</li>
</ul>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot如何远程调试？</title>
    <url>/2020/10/28/SpringBoot%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上周末一个朋友庆生，无意间听他说起了近况，说公司项目太多了，每天一堆BUG需要修复，项目来回切换启动，真是挺烦的。</p>
<p>随着项目越来越多，特别是身处外包公司的朋友，每天可能需要切换两三个项目，难道一有问题就本地启动项目调试？</p>
<p>今天这篇文章就来介绍一下什么是远程调试，<code>Spring Boot</code>如何开启远程调试？<br><a id="more"></a></p>
<h2 id="什么是远程调试？"><a href="#什么是远程调试？" class="headerlink" title="什么是远程调试？"></a>什么是远程调试？</h2><p>所谓的远程调试就是服务端程序运行在一台远程服务器上，我们可以在本地服务端的代码（<strong>前提是本地的代码必须和远程服务器运行的代码一致</strong>）中设置断点，每当有请求到远程服务器时时能够在本地知道远程服务端的此时的内部状态。</p>
<blockquote>
<p>简单的意思：本地无需启动项目的状态下能够实时调试服务端的代码。</p>
</blockquote>
<h2 id="为什么要远程调试？"><a href="#为什么要远程调试？" class="headerlink" title="为什么要远程调试？"></a>为什么要远程调试？</h2><p>随着项目的体量越来越大，启动的时间的也是随之增长，何必为了调试一个BUG花费十分钟的时间去启动项目呢？你不怕老大骂你啊？</p>
<h2 id="什么是JPDA？"><a href="#什么是JPDA？" class="headerlink" title="什么是JPDA？"></a>什么是JPDA？</h2><p><code>JPDA</code>(<code>Java Platform Debugger Architecture</code>)，即 Java 平台调试体系，具体结构图如下图所示：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%E7%AC%AC%E5%8D%81%E4%BA%94%E5%BC%B9%EF%BC%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/1.png" alt=""></p>
<p>其中实现调试功能的主要协议是<code>JDWP</code>协议，在 <code>Java SE 5</code> 以前版本，JVM 端的实现接口是 <code>JVMPI</code>(Java Virtual Machine Profiler Interface)，而在<code>Java SE 5</code>及以后版本，使用 <code>JVMTI</code>(Java Virtual Machine Tool Interface) 来替代 JVMPI。</p>
<p>因此，如果你使用的是<code>Java SE 5</code>之前的版本，则使用的调试命令格式如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">java -Xdebug -Xrunjdwp:...</div></pre></td></tr></table></figure></p>
<p>如果你使用的是<code>Java SE 5</code>之后的版本，则使用的命令格式如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">java -agentlib:jdwp=...</div></pre></td></tr></table></figure></p>
<h2 id="如何开启调试？"><a href="#如何开启调试？" class="headerlink" title="如何开启调试？"></a>如何开启调试？</h2><p>由于现在使用的大多数都是<code>Java SE 5</code>之后的版本，则之前的就忽略了。</p>
<p>日常开发中最常见的开启远程调试的命令如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=<span class="number">9093</span> -jar xxx.jar</div></pre></td></tr></table></figure>
<p>前面的<code>java -agentlib:jdwp=</code>是基础命令，后面的跟着的一串命令则是可选的参数，具体什么意思呢？下面详细介绍。</p>
<h3 id="transport"><a href="#transport" class="headerlink" title="transport"></a>transport</h3><p>指定运行的被调试应用和调试者之间的通信协议，有如下可选值：</p>
<ol>
<li><code>dt_socket</code>： 采用<code>socket</code>方式连接（常用）</li>
<li><code>dt_shmem</code>：采用共享内存的方式连接，支持有限，仅仅支持windows平台</li>
</ol>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>指定当前应用作为调试服务端还是客户端，默认的值为<code>n</code>（客户端）。</p>
<p>如果你想将当前应用作为被调试应用，设置该值为<code>y</code>;如果你想将当前应用作为客户端，作为调试的发起者，设置该值为<code>n</code>。</p>
<h3 id="suspend"><a href="#suspend" class="headerlink" title="suspend"></a>suspend</h3><p>当前应用启动后，是否阻塞应用直到被连接，默认值为<code>y</code>（阻塞）。</p>
<p>大部分情况下这个值应该为<code>n</code>，即不需要阻塞等待连接。一个可能为<code>y</code>的应用场景是，你的程序在启动时出现了一个故障，为了调试，必须等到调试方连接上来后程序再启动。</p>
<h3 id="address"><a href="#address" class="headerlink" title="address"></a>address</h3><p>对外暴露的端口，默认值是<code>8000</code></p>
<p><strong>注意</strong>：此端口不能和项目同一个端口，且未被占用以及对外开放。</p>
<h3 id="onthrow"><a href="#onthrow" class="headerlink" title="onthrow"></a>onthrow</h3><p>这个参数的意思是当程序抛出指定异常时，则中断调试。</p>
<h3 id="onuncaught"><a href="#onuncaught" class="headerlink" title="onuncaught"></a>onuncaught</h3><p>当程序抛出未捕获异常时，是否中断调试，默认值为<code>n</code>。</p>
<h3 id="launch"><a href="#launch" class="headerlink" title="launch"></a>launch</h3><p>当调试中断时，执行的程序。</p>
<h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><p>超时时间，单位<code>ms</code>（毫秒）</p>
<p>当 <code>suspend = y</code> 时，该值表示等待连接的超时；当 <code>suspend = n</code> 时，该值表示连接后的使用超时。</p>
<h2 id="常用的命令"><a href="#常用的命令" class="headerlink" title="常用的命令"></a>常用的命令</h2><p>下面列举几个常用的参考命令，这样更加方便理解。</p>
<ol>
<li>以<code>Socket</code> 方式监听 <code>8000</code> 端口，程序启动阻塞（<code>suspend</code> 的默认值为 <code>y</code>）直到被连接，命令如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">-agentlib:jdwp=transport=dt_socket,server=y,address=<span class="number">8000</span></div></pre></td></tr></table></figure>
<ol>
<li>以 <code>Socket</code> 方式监听 <code>8000</code> 端口，当程序启动后 <code>5</code> 秒无调试者连接的话终止，程序启动阻塞（<code>suspend</code> 的默认值为 <code>y</code>）直到被连接。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">-agentlib:jdwp=transport=dt_socket,server=y,address=localhost:<span class="number">8000</span>,timeout=<span class="number">5000</span></div></pre></td></tr></table></figure>
<ol>
<li>选择可用的共享内存连接地址并使用 <code>stdout</code> 打印，程序启动不阻塞。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">-agentlib:jdwp=transport=dt_shmem,server=y,suspend=n</div></pre></td></tr></table></figure>
<ol>
<li>以 <code>socket</code> 方式连接到 <code>myhost:8000</code>上的调试程序，在连接成功前启动阻塞。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">-agentlib:jdwp=transport=dt_socket,address=myhost:<span class="number">8000</span></div></pre></td></tr></table></figure>
<ol>
<li>以 <code>Socket</code> 方式监听 <code>8000</code> 端口，程序启动阻塞（<code>suspend</code> 的默认值为 <code>y</code>）直到被连接。当抛出 <code>IOException</code> 时中断调试，转而执行 <code>usr/local/bin/debugstub</code>程序。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">-agentlib:jdwp=transport=dt_socket,server=y,address=<span class="number">8000</span>,onthrow=java.io.IOException,launch=/usr/local/bin/debugstub</div></pre></td></tr></table></figure>
<h2 id="IDEA如何开启远程调试？"><a href="#IDEA如何开启远程调试？" class="headerlink" title="IDEA如何开启远程调试？"></a>IDEA如何开启远程调试？</h2><p>首先的将打包后的<code>Spring Boot</code>项目在服务器上运行，执行如下命令（各种参数根据实际情况自己配置）：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=<span class="number">9193</span> -jar debug-demo.jar</div></pre></td></tr></table></figure></p>
<p>项目启动成功后，点击 <code>Edit Configurations</code>，在弹框中点击 <code>+</code> 号，然后选择<code>Remote</code>。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%E7%AC%AC%E5%8D%81%E4%BA%94%E5%BC%B9%EF%BC%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/2.png" alt=""></p>
<p>然后填写服务器的地址及端口，点击 <code>OK</code> 即可。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%E7%AC%AC%E5%8D%81%E4%BA%94%E5%BC%B9%EF%BC%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/3.png" alt=""></p>
<p>以上步骤配置完成后，点击DEBUG调试运行即可。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%E7%AC%AC%E5%8D%81%E4%BA%94%E5%BC%B9%EF%BC%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/4.png" alt=""></p>
<p>配置完毕后点击保存即可，因为我配置的 <code>suspend=n</code>，因此服务端程序无需阻塞等待我们的连接。我们点击 <code>IDEA</code> 调试按钮，当我访问某一接口时，能够正常调试。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%E7%AC%AC%E5%8D%81%E4%BA%94%E5%BC%B9%EF%BC%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/5.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>每天一个小知识，今天你学到了吗？</p>
<p>另外作者为大家准备接近<code>10M</code>的面筋，涵盖后端的各个层面，老规矩，公众号内回复<code>Java面试宝典</code>即可获取。</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/8.png" alt=""></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png" alt=""></p>
]]></content>
      <categories>
        <category>Spring Boot进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper实现分布式锁</title>
    <url>/2020/04/19/Zookeeper%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>真是有人(<code>锁</code>)的地方就有江湖(<code>事务</code>)，今天不谈江湖，来撩撩人。</li>
<li>分布式锁的概念、为什么使用分布式锁，想必大家已经很清楚了。前段时间作者写过Redis是如何实现分布式锁，今天这篇文章来谈谈Zookeeper是如何实现分布式锁的。</li>
<li>陈某今天分别从如下几个方面来详细讲讲ZK如何实现分布式锁：<ol>
<li><strong>ZK的四种节点</strong></li>
<li><strong>排它锁的实现</strong></li>
<li><strong>读写锁的实现</strong></li>
<li><strong>Curator实现分步式锁</strong></li>
</ol>
</li>
</ul>
<h2 id="ZK的四种节点"><a href="#ZK的四种节点" class="headerlink" title="ZK的四种节点"></a>ZK的四种节点</h2><ul>
<li>持久性节点：节点创建后将会一直存在</li>
<li>临时节点：临时节点的生命周期和当前会话绑定，一旦当前会话断开临时节点也会删除，当然可以主动删除。</li>
<li>持久有序节点：节点创建一直存在，并且zk会自动为节点加上一个自增的后缀作为新的节点名称。</li>
<li>临时有序节点：保留临时节点的特性，并且zk会自动为节点加上一个自增的后缀作为新的节点名称。</li>
</ul>
<h2 id="排它锁的实现"><a href="#排它锁的实现" class="headerlink" title="排它锁的实现"></a>排它锁的实现</h2><ul>
<li>排他锁的实现相对简单一点，利用了<strong>zk的创建节点不能重名的特性</strong>。如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/ZK%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/zk%E6%8E%92%E4%BB%96%E9%94%81.png" alt=""></p>
<ul>
<li>根据上图分析大致分为如下步骤：<ol>
<li>尝试获取锁：创建<code>临时节点</code>，zk会保证只有一个客户端创建成功。</li>
<li>创建临时节点成功，获取锁成功，执行业务逻辑，业务执行完成后删除锁。</li>
<li>创建临时节点失败，阻塞等待。</li>
<li>监听删除事件，一旦临时节点删除了，表示互斥操作完成了，可以再次尝试获取锁。</li>
<li>递归：获取锁的过程是一个递归的操作，<code>获取锁-&gt;监听-&gt;获取锁</code>。</li>
</ol>
</li>
<li><strong>如何避免死锁</strong>：创建的是临时节点，当服务宕机会话关闭后临时节点将会被删除，锁自动释放。</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul>
<li>作者参照JDK锁的实现方式加上模板方法模式的封装，封装接口如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Description</span> ZK分布式锁的接口</div><div class="line"> * <span class="doctag">@Author</span> 陈某</div><div class="line"> * <span class="doctag">@Date</span> 2020/4/7 22:52</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ZKLock</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取锁</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 解锁</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>模板抽象类如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Description</span> 排他锁，模板类</div><div class="line"> * <span class="doctag">@Author</span> 陈某</div><div class="line"> * <span class="doctag">@Date</span> 2020/4/7 22:55</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractZKLockMutex</span> <span class="keyword">implements</span> <span class="title">ZKLock</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 节点路径</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> String lockPath;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * zk客户端</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> CuratorFramework zkClient;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AbstractZKLockMutex</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractZKLockMutex</span><span class="params">(String lockPath,CuratorFramework client)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.lockPath=lockPath;</div><div class="line">        <span class="keyword">this</span>.zkClient=client;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 模板方法，搭建的获取锁的框架，具体逻辑交于子类实现</div><div class="line">     * <span class="doctag">@throws</span> Exception</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//获取锁成功</span></div><div class="line">        <span class="keyword">if</span> (tryLock())&#123;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"获取锁成功"</span>);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">//获取锁失败</span></div><div class="line">            <span class="comment">//阻塞一直等待</span></div><div class="line">            waitLock();</div><div class="line">            <span class="comment">//递归，再次获取锁</span></div><div class="line">            lock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 尝试获取锁，子类实现</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 等待获取锁，子类实现</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">waitLock</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 解锁：删除节点或者直接断开连接</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>排他锁的具体实现类如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Description</span> 排他锁的实现类，继承模板类 AbstractZKLockMutex</div><div class="line"> * <span class="doctag">@Author</span> 陈某</div><div class="line"> * <span class="doctag">@Date</span> 2020/4/7 23:23</div><div class="line"> */</div><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKLockMutex</span> <span class="keyword">extends</span> <span class="title">AbstractZKLockMutex</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 用于实现线程阻塞</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZKLockMutex</span><span class="params">(String lockPath,CuratorFramework zkClient)</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>(lockPath,zkClient);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 尝试获取锁：直接创建一个临时节点，如果这个节点存在创建失败抛出异常，表示已经互斥了，</div><div class="line">     * 反之创建成功</div><div class="line">     * <span class="doctag">@throws</span> Exception</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            zkClient.create()</div><div class="line">                    <span class="comment">//临时节点</span></div><div class="line">                    .withMode(CreateMode.EPHEMERAL)</div><div class="line">                    <span class="comment">//权限列表 world:anyone:crdwa</span></div><div class="line">                    .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)</div><div class="line">                    .forPath(lockPath,<span class="string">"lock"</span>.getBytes());</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;<span class="keyword">catch</span> (Exception ex)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 等待锁，一直阻塞监听</div><div class="line">     * <span class="doctag">@return</span>  成功获取锁返回true，反之返回false</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">waitLock</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//监听节点的新增、更新、删除</span></div><div class="line">        <span class="keyword">final</span> NodeCache nodeCache = <span class="keyword">new</span> NodeCache(zkClient, lockPath);</div><div class="line">        <span class="comment">//启动监听</span></div><div class="line">        nodeCache.start();</div><div class="line">        ListenerContainer&lt;NodeCacheListener&gt; listenable = nodeCache.getListenable();</div><div class="line"></div><div class="line">        <span class="comment">//监听器</span></div><div class="line">        NodeCacheListener listener=()-&gt; &#123;</div><div class="line">            <span class="comment">//节点被删除，此时获取锁</span></div><div class="line">            <span class="keyword">if</span> (nodeCache.getCurrentData() == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">//countDownLatch不为null，表示节点存在，此时监听到节点删除了，因此-1</span></div><div class="line">                <span class="keyword">if</span> (countDownLatch != <span class="keyword">null</span>)</div><div class="line">                    countDownLatch.countDown();</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        <span class="comment">//添加监听器</span></div><div class="line">        listenable.addListener(listener);</div><div class="line"></div><div class="line">        <span class="comment">//判断节点是否存在</span></div><div class="line">        Stat stat = zkClient.checkExists().forPath(lockPath);</div><div class="line">        <span class="comment">//节点存在</span></div><div class="line">        <span class="keyword">if</span> (stat!=<span class="keyword">null</span>)&#123;</div><div class="line">            countDownLatch=<span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line">            <span class="comment">//阻塞主线程，监听</span></div><div class="line">            countDownLatch.await();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//移除监听器</span></div><div class="line">        listenable.removeListener(listener);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 解锁，直接删除节点</div><div class="line">     * <span class="doctag">@throws</span> Exception</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        zkClient.delete().forPath(lockPath);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="可重入性排他锁如何设计"><a href="#可重入性排他锁如何设计" class="headerlink" title="可重入性排他锁如何设计"></a>可重入性排他锁如何设计</h3><ul>
<li>可重入的逻辑很简单，在本地保存一个<code>ConcurrentMap</code>，<code>key</code>是当前线程，<code>value</code>是定义的数据，结构如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Thread, LockData&gt; threadData = Maps.newConcurrentMap();</div></pre></td></tr></table></figure>
<ul>
<li>重入的伪代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//判断当前线程是否在threadData保存过</span></div><div class="line">    <span class="comment">//存在，直接return true</span></div><div class="line">    <span class="comment">//不存在执行获取锁的逻辑</span></div><div class="line">    <span class="comment">//获取成功保存在threadData中</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="读写锁的实现"><a href="#读写锁的实现" class="headerlink" title="读写锁的实现"></a>读写锁的实现</h2><ul>
<li>读写锁分为读锁和写锁，区别如下：<ul>
<li>读锁允许多个线程同时读数据，但是在读的同时不允许写线程修改。</li>
<li>写锁在获取后，不允许多个线程同时写或者读。</li>
</ul>
</li>
<li>如何实现读写锁？ZK中有一类节点叫临时有序节点，上文有介绍。下面我们来利用临时有序节点来实现读写锁的功能。</li>
</ul>
<h3 id="读锁的设计"><a href="#读锁的设计" class="headerlink" title="读锁的设计"></a>读锁的设计</h3><ul>
<li>读锁允许多个线程同时进行读，并且在读的同时不允许线程进行写操作，实现原理如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/ZK%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/%E8%AF%BB%E9%94%81.png" alt=""></p>
<ul>
<li>根据上图，获取一个读锁分为以下步骤：<ol>
<li>创建临时有序节点（当前线程拥有的<code>读锁</code>或称作<code>读节点</code>）。</li>
<li>获取路径下所有的子节点，并进行<code>从小到大</code>排序</li>
<li>获取当前节点前的临近写节点(写锁)。</li>
<li>如果不存在的临近写节点，则成功获取读锁。</li>
<li>如果存在临近写节点，对其监听删除事件。</li>
<li>一旦监听到删除事件，<strong>重复2,3,4,5的步骤(递归)</strong>。</li>
</ol>
</li>
</ul>
<h3 id="写锁的设计"><a href="#写锁的设计" class="headerlink" title="写锁的设计"></a>写锁的设计</h3><ul>
<li>线程一旦获取了写锁，不允许其他线程读和写。实现原理如下：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/ZK%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/%E5%86%99%E9%94%81.png" alt=""></p>
<ul>
<li>从上图可以看出唯一和写锁不同的就是监听的节点，这里是监听临近节点(读节点或者写节点)，读锁只需要监听写节点，步骤如下：<ol>
<li>创建临时有序节点（当前线程拥有的<code>写锁</code>或称作<code>写节点</code>）。</li>
<li>获取路径下的所有子节点，并进行<code>从小到大</code>排序。</li>
<li>获取当前节点的临近节点(读节点和写节点)。</li>
<li>如果不存在临近节点，则成功获取锁。</li>
<li>如果存在临近节点，对其进行监听删除事件。</li>
<li>一旦监听到删除事件，<strong>重复2,3,4,5的步骤(递归)</strong>。</li>
</ol>
</li>
</ul>
<h3 id="如何监听"><a href="#如何监听" class="headerlink" title="如何监听"></a>如何监听</h3><ul>
<li>无论是写锁还是读锁都需要监听前面的节点，不同的是读锁只监听临近的写节点，写锁是监听临近的所有节点，抽象出来看其实是一种链式的监听，如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/ZK%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/%E9%93%BE%E5%BC%8F.png" alt=""></p>
<ul>
<li>每一个节点都在监听前面的临近节点，一旦前面一个节点删除了，再从新排序后监听前面的节点，这样递归下去。</li>
</ul>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><ul>
<li>作者简单的写了读写锁的实现，先造出来再优化，不建议用在生产环境。代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKLockRW</span>  </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 节点路径</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> String lockPath;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * zk客户端</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> CuratorFramework zkClient;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 用于阻塞线程</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch=<span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String WRITE_NAME=<span class="string">"_W_LOCK"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String READ_NAME=<span class="string">"_R_LOCK"</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZKLockRW</span><span class="params">(String lockPath, CuratorFramework client)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.lockPath=lockPath;</div><div class="line">        <span class="keyword">this</span>.zkClient=client;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取锁，如果获取失败一直阻塞</div><div class="line">     * <span class="doctag">@throws</span> Exception</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//创建节点</span></div><div class="line">        String node = createNode();</div><div class="line">        <span class="comment">//阻塞等待获取锁</span></div><div class="line">        tryLock(node);</div><div class="line">        countDownLatch.await();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建临时有序节点</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     * <span class="doctag">@throws</span> Exception</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">createNode</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//创建临时有序节点</span></div><div class="line">       <span class="keyword">return</span> zkClient.create()</div><div class="line">                .withMode(CreateMode.EPHEMERAL_SEQUENTIAL)</div><div class="line">                .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)</div><div class="line">                .forPath(lockPath);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取写锁</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span>  ZKLockRW <span class="title">writeLock</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ZKLockRW(lockPath+WRITE_NAME,zkClient);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取读锁</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span>  ZKLockRW <span class="title">readLock</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ZKLockRW(lockPath+READ_NAME,zkClient);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryLock</span><span class="params">(String nodePath)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//获取所有的子节点</span></div><div class="line">        List&lt;String&gt; childPaths = zkClient.getChildren()</div><div class="line">                .forPath(<span class="string">"/"</span>)</div><div class="line">                .stream().sorted().map(o-&gt;<span class="string">"/"</span>+o).collect(Collectors.toList());</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">//第一个节点就是当前的锁，直接获取锁。递归结束的条件</span></div><div class="line">        <span class="keyword">if</span> (nodePath.equals(childPaths.get(<span class="number">0</span>)))&#123;</div><div class="line">            countDownLatch.countDown();</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//1. 读锁：监听最前面的写锁，写锁释放了，自然能够读了</span></div><div class="line">        <span class="keyword">if</span> (nodePath.contains(READ_NAME))&#123;</div><div class="line">            <span class="comment">//查找临近的写锁</span></div><div class="line">            String preNode = getNearWriteNode(childPaths, childPaths.indexOf(nodePath));</div><div class="line">            <span class="keyword">if</span> (preNode==<span class="keyword">null</span>)&#123;</div><div class="line">                countDownLatch.countDown();</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            NodeCache nodeCache=<span class="keyword">new</span> NodeCache(zkClient,preNode);</div><div class="line">            nodeCache.start();</div><div class="line">            ListenerContainer&lt;NodeCacheListener&gt; listenable = nodeCache.getListenable();</div><div class="line">            listenable.addListener(() -&gt; &#123;</div><div class="line">                <span class="comment">//节点删除事件</span></div><div class="line">                <span class="keyword">if</span> (nodeCache.getCurrentData()==<span class="keyword">null</span>)&#123;</div><div class="line">                    <span class="comment">//继续监听前一个节点</span></div><div class="line">                    String nearWriteNode = getNearWriteNode(childPaths, childPaths.indexOf(preNode));</div><div class="line">                    <span class="keyword">if</span> (nearWriteNode==<span class="keyword">null</span>)&#123;</div><div class="line">                        countDownLatch.countDown();</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line">                    tryLock(nearWriteNode);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//如果是写锁，前面无论是什么锁都不能读，直接循环监听上一个节点即可，直到前面无锁</span></div><div class="line">        <span class="keyword">if</span> (nodePath.contains(WRITE_NAME))&#123;</div><div class="line">            String preNode = childPaths.get(childPaths.indexOf(nodePath) - <span class="number">1</span>);</div><div class="line">            NodeCache nodeCache=<span class="keyword">new</span> NodeCache(zkClient,preNode);</div><div class="line">            nodeCache.start();</div><div class="line">            ListenerContainer&lt;NodeCacheListener&gt; listenable = nodeCache.getListenable();</div><div class="line">            listenable.addListener(() -&gt; &#123;</div><div class="line">                <span class="comment">//节点删除事件</span></div><div class="line">                <span class="keyword">if</span> (nodeCache.getCurrentData()==<span class="keyword">null</span>)&#123;</div><div class="line">                    <span class="comment">//继续监听前一个节点</span></div><div class="line">                    tryLock(childPaths.get(childPaths.indexOf(preNode) - <span class="number">1</span>&lt;<span class="number">0</span>?<span class="number">0</span>:childPaths.indexOf(preNode) - <span class="number">1</span>));</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 查找临近的写节点</div><div class="line">     * <span class="doctag">@param</span> childPath 全部的子节点</div><div class="line">     * <span class="doctag">@param</span> index 右边界</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> String  <span class="title">getNearWriteNode</span><span class="params">(List&lt;String&gt; childPath,Integer index)</span></span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</div><div class="line">            String node = childPath.get(i);</div><div class="line">            <span class="keyword">if</span> (node.contains(WRITE_NAME))</div><div class="line">                <span class="keyword">return</span> node;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Curator实现分步式锁"><a href="#Curator实现分步式锁" class="headerlink" title="Curator实现分步式锁"></a>Curator实现分步式锁</h2><ul>
<li>Curator是Netflix公司开源的一个Zookeeper客户端，与Zookeeper提供的原生客户端相比，Curator的抽象层次更高，简化了Zookeeper客户端的开发量。 </li>
<li>Curator在分布式锁方面已经为我们封装好了，大致实现的思路就是按照作者上述的思路实现的。中小型互联网公司还是建议直接使用框架封装好的，毕竟稳定，有些大型的互联公司都是手写的，牛逼啊。</li>
<li>创建一个排他锁很简单，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//arg1：CuratorFramework连接对象，arg2：节点路径</span></div><div class="line">lock=<span class="keyword">new</span> InterProcessMutex(client,path);</div><div class="line"><span class="comment">//获取锁</span></div><div class="line">lock.acquire();</div><div class="line"><span class="comment">//释放锁</span></div><div class="line">lock.release();</div></pre></td></tr></table></figure>
<ul>
<li><p>更多的API请参照官方文档，不是此篇文章重点。</p>
</li>
<li><p><strong>至此ZK实现分布式锁就介绍完了，如有想要源码的朋友，老规矩，回复关键词<code>分布式锁</code>获取。</strong></p>
</li>
</ul>
<h2 id="一点小福利"><a href="#一点小福利" class="headerlink" title="一点小福利"></a>一点小福利</h2><ul>
<li>对于Zookeeper不太熟悉的朋友，陈某特地花费两天时间总结了ZK的常用知识点，包括ZK常用shell命令、ZK权限控制、Curator的基本操作API。目录如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/ZK%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/5.png" alt=""></li>
<li><strong>需要上面PDF文件的朋友，老规矩，回复关键词<code>ZK总结</code>。</strong></li>
</ul>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis Log plugin破解，亲测可用！！！</title>
    <url>/2020/08/26/plugin%E7%A0%B4%E8%A7%A3%EF%BC%8C%E4%BA%B2%E6%B5%8B%E5%8F%AF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><p>今天重新装了IDEA2020，顺带重装了一些插件，毕竟这些插件都是习惯一直在用，其中一款就是Mybatis  Log plugin，按照往常的思路，在IDEA插件市场搜索安装，艹，眼睛一瞟，竟然收费了，对于我这种支持盗版的人来说太难了，于是自己开始捣鼓各种尝试破解，下文分享自己的破解方式。</p>
<a id="more"></a>
<h2 id="什么是Mybatis-Log-plugin"><a href="#什么是Mybatis-Log-plugin" class="headerlink" title="什么是Mybatis Log plugin"></a>什么是Mybatis Log plugin</h2></li>
<li><p>举个栗子，通常在找bug的时候都会查看执行了什么SQL，想把这条SQL拼接出来执行调试，可能有些小白还在傻傻的把各个参数复制出来，补到<code>?</code>占位符中，哈哈。</p>
</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-Log-plugin/6.jpg" alt=""></li>
</ul>
<ul>
<li>简单的说就是能根据log4j的打印的sql日志一键生成执行的<code>sql</code>语句。</li>
<li>类似如下一个日志信息：</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-Log-plugin/1.png" alt="日志信息"></li>
<li>如果使用Log plugin这个插件，将会很容易的把参数添加到sql语句中得到一条完整的sql，效果如下：</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-Log-plugin/4.png" alt="完整sql"></li>
<li>一旦开启了<code>Mybatis Log plugin</code>这个插件，在程序运行过程中只要是有SQL语句都会自动生成在<code>Mybatis Log</code>这个界面，当然也可以自己关掉。</li>
</ul>
<h2 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h2><ul>
<li><code>Setting-&gt;plugin-&gt;Marketplace</code>搜索框输入<code>Mybatis Log plugin</code>，如下：</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-Log-plugin/2.png" alt="搜索输入"></li>
<li>很遗憾的是， IDEA2020中已经开始收费了，艹，对于一向支持盗版的我来说，很不爽~</li>
</ul>
<h2 id="如何破解"><a href="#如何破解" class="headerlink" title="如何破解"></a>如何破解</h2><ul>
<li>下载jar包<code>plugin.intellij.assistant.mybaitslog-2020.1-1.0.3.jar</code>，文末附有下载方式。</li>
<li><code>setting-&gt;plguin-&gt;设置-&gt; install plugin from Disk...</code></li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-Log-plugin/3.png" alt="破解步骤"></p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><ul>
<li>日志中从<code>Preparing</code>到<code>Parameters</code>这两行的参数选中，右键选择<code>restore sql from Selection</code></li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-Log-plugin/5.png" alt=""></li>
<li>此时将会在<code>Mybatis Log</code>界面出现完整的SQL语句。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>对于复杂的SQL语句来说，Mybatis Log plugin这款插件简直是太爱了，能够自动拼接参数生成执行的SQL语句。</li>
<li>老规矩，关注公众号【码猿技术专栏】，公众号回复<code>mybatis log</code>获取破解包。</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E4%B8%83%E7%A7%92%E7%BC%96%E7%A8%8B.jpg" alt=""></li>
</ul>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>破解</tag>
        <tag>优质资源</tag>
      </tags>
  </entry>
  <entry>
    <title>explain执行计划</title>
    <url>/2020/04/20/explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<section id="nice" data-tool="mdnice编辑器" data-website="https://www.mdnice.com" style="padding: 0 10px; word-spacing: 0px; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif; line-height: 1.6; letter-spacing: .034em; color: rgb(63, 63, 63); font-size: 16px; word-break: all;"><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">前言</span><span class="suffix"></span></h2><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如何写出效率高的SQL语句，提到这必然离不开<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Explain</code>执行计划的分析，至于什么是执行计划，如何写出高效率的SQL，本篇文章将会一一介绍。</section></li></ul><br><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">执行计划</span><span class="suffix"></span></h2><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">执行计划是数据库根据 SQL 语句和相关表的统计信息作出的一个查询方案，这个方案是由查询优化器自动分析产生的。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">explain</code>关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的，分析你的 select 语句或是表结构的性能瓶颈，让我们知道 select 效率低下的原因，从而改进我们的查询。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">explain 的结果如下：<br><img src="https://img-blog.csdnimg.cn/2018112215033993.png" alt="" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></p><br></section></li></ul><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">下面是有关各列的详细介绍，重要的有<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">id</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">type</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">key</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">rows</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">extra</code>。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">id</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">id 列的编号就是 select 的序列号，也可以理解为 SQL 执行顺序的标识，有几个 select 就有几个 id。<br><ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">id 值不同：如果是只查询，id 的序号会递增，id 值越大优先级越高，越先被执行；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">id 值相同：从上往下依次执行；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">id 列为 null：表示这是一个结果集，不需要使用它来进行查询。</section></li></ul><br></section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">select_type</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">查询的类型，主要用于区分普通查询、联合查询、子查询等复杂的查询；</p><br><ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">simple：表示查询中不包括 union 操作或者子查询，位于最外层的查询的 select_type 即为 simple，且只有一个；</section></li></ul><br><pre class="custom" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; display: block; -webkit-overflow-scrolling: touch; font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">  <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">explain</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> <em> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> t3 <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">id</span>=<span class="hljs-number" style="color: #008080; line-height: 26px;">3952602</span>;<br><span></span></em></code></pre><br><ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">primary：需要 union 操作或者含有子查询的 select，位于最外层的查询的 select_type 即为 primary，且只有一个；</section></li></ul><br><pre class="custom" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; display: block; -webkit-overflow-scrolling: touch; font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">explain</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span>  <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> (<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> <em> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> t3 <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">id</span>=<span class="hljs-number" style="color: #008080; line-height: 26px;">3952602</span>) a ;<br><span></span></em></code></pre><br><ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">derived：from 列表中出现的子查询，也叫做衍生表；mysql 或者递归执行这些子查询，把结果放在临时表里。</section></li></ul><br><pre class="custom" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; display: block; -webkit-overflow-scrolling: touch; font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">  <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">explain</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span>  <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> (<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> <em> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> t3 <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">id</span>=<span class="hljs-number" style="color: #008080; line-height: 26px;">3952602</span>) a ;<br><span></span></em></code></pre><br><ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">subquery：除了 from 子句中包含的子查询外，其他地方出现的子查询都可能是 subquery。</section></li></ul><br><pre class="custom" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; display: block; -webkit-overflow-scrolling: touch; font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">explain</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span>  <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> t3 <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">id</span> = (<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">id</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> t3 whereid=<span class="hljs-number" style="color: #008080; line-height: 26px;">3952602</span> ) ;<br><span></span></code></pre><br></section></li></ul><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">union：若第二个 select 出现在 union 之后，则被标记为 union；若 union 包含在 from 子句的子查询中，外层 select 将被标记为 derived。<pre class="custom" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; display: block; -webkit-overflow-scrolling: touch; font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">explain</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> <em> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> t3 <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">id</span>=<span class="hljs-number" style="color: #008080; line-height: 26px;">3952602</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">union</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">all</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> </em> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> t3;<br><span></span></code></pre><br><ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">union result：从 union 表获取结果的 select ，因为它不需要参与查询，所以 id 字段为 null。</section></li></ul><br><pre class="custom" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; display: block; -webkit-overflow-scrolling: touch; font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">  <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">explain</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> <em> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> t3 <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">id</span>=<span class="hljs-number" style="color: #008080; line-height: 26px;">3952602</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">union</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">all</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> </em> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> t3;<br><span></span></code></pre><br></section></li></ul><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">dependent union：与 union 一样，出现在 union 或 union all 语句中，但是这个查询要受到外部查询的影响；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">dependent subquery：与 dependent union 类似，子查询中的第一个 SELECT，这个 subquery 的查询要受到外部表查询的影响。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">table</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">表示 explain 的一行正在访问哪个表。<br><ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如果查询使用了别名，那么这里显示的是别名;</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如果不涉及对数据表的操作，那么这显示为 null;</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如果显示为尖括号括起来的<derived n="">就表示这个是临时表，后边的 N 就是执行计划中的 id，表示结果来自于这个查询产生;</derived></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如果是尖括号括起来的&lt;union M,N&gt;，与<derived n="">类似，也是一个临时表，表示这个结果来自于 union 查询的 id 为 M,N 的结果集。</derived></section></li></ul><br></section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">type</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">访问类型，即 MySQL 决定如何查找表中的行。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">依次从好到差：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL，除了 all 之外，其他的 type 都可以使用到索引，除了 index_merge 之外，其他的 type 只可以用到一个索引。一般来说，得保证查询至少达到 range 级别，最好能达到 ref。</p><br><ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">system：表中只有一行数据（等于系统表），这是 const 类型的特例，平时不会出现，可以忽略不计。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">const：使用唯一索引或者主键，表示通过索引一次就找到了，const 用于比较 primary key 或者 unique 索引。因为只需匹配一行数据，所有很快。如果将主键置于 where 列表中，mysql 就能将该查询转换为一个 const。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">eq_ref：唯一性索引扫描，对于每个索引键，表中只有一行数据与之匹配。常见于主键或唯一索引扫描。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">ref：非唯一性索引扫描，返回匹配某个单独值的所有行。本质也是一种索引。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">fulltext：全文索引检索，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql 不管代价，优先选择使用全文索引。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">ref_or_null：与 ref 方法类似，只是增加了 null 值的比较。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">index_merge：表示查询使用了两个以上的索引，索引合并的优化方法，最后取交集或者并集，常见 and ，or 的条件使用了不同的索引。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">unique_subquery：用于 where 中的 in 形式子查询，子查询返回不重复值唯一值；</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">index_subquery：用于 in 形式子查询使用到了辅助索引或者 in 常数列表，子查询可能返回重复值，可以使用索引将子查询去重。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">range：索引范围扫描，常见于使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">&gt;</code>,<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">&lt;</code>,<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">between</code> ,<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">in</code> ,<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">like</code>等运算符的查询中。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">index：索引全表扫描，把索引树从头到尾扫一遍；</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">all：遍历全表以找到匹配的行（Index 与 ALL 虽然都是读全表，但 index 是从索引中读取，而 ALL 是从硬盘读取）</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">NULL: MySQL 在优化过程中分解语句，执行时甚至不用访问表或索引。</p><br></section></li></ol><br></section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">possible_keys</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">显示查询可能使用到的索引。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">key</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">显示查询实际使用哪个索引来优化对该表的访问；</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">select_type 为 index_merge 时，这里可能出现两个以上的索引，其他的 select_type 这里只会出现一个。</p><br></section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">key_len</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">用于处理查询的索引长度，表示索引中使用的字节数。通过这个值，可以得出一个多列索引里实际使用了哪一部分。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">注：key_len 显示的值为索引字段的最大可能长度，并非实际使用长度，即 key_len 是根据表定义计算而得，不是通过表内检索出的。另外，key_len 只计算 where 条件用到的索引长度，而排序和分组就算用到了索引，也不会计算到 key_len 中。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">ref</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">显示哪个字段或者常数与 key 一起被使用。</p><br><ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">如果是使用的常数等值查询，这里会显示 const。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为 func。</p><br></section></li></ol><br></section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">rows</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">表示 MySQL 根据表统计信息及索引选用情况，大致估算的找到所需的目标记录所需要读取的行数，不是精确值。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">extra</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">不适合在其他列中显示但十分重要的额外信息。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">这个列可以显示的信息非常多，有几十种，常用的有：</p><br></section></li></ul><br><section class="table-container" data-tool="mdnice编辑器" style="overflow-x: auto;"><table style="display: table; text-align: left;"><br><thead><br><tr style="border: 0; border-top: 1px solid #ccc; background-color: white;"><br><th style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-weight: bold; background-color: #f0f0f0; font-size: 14px; min-width: 85px;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">类型</strong></th><br><th style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-weight: bold; background-color: #f0f0f0; font-size: 14px; min-width: 85px;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">说明</strong></th><br></tr><br></thead><br><tbody style="border: 0;"><br><tr style="border: 0; border-top: 1px solid #ccc; background-color: white;"><br><td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">Using filesort</td><br><td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">MySQL 有两种方式可以生成有序的结果，通过排序操作或者使用索引，当 Extra 中出现了 Using filesort 说明 MySQL 使用了后者，但注意虽然叫 filesort 但并不是说明就是用了文件来进行排序，只要可能排序都是在内存里完成的。大部分情况下利用索引排序更快，所以一般这时也要考虑优化查询了。使用文件完成排序操作，这是可能是 ordery by，group by 语句的结果，这可能是一个 CPU 密集型的过程，可以通过选择合适的索引来改进性能，用索引来为查询结果排序。</td><br></tr><br><tr style="border: 0; border-top: 1px solid #ccc; background-color: #F8F8F8;"><br><td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">Using temporary</td><br><td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">用临时表保存中间结果，常用于 GROUP BY 和 ORDER BY 操作中，一般看到它说明查询需要优化了，就算避免不了临时表的使用也要尽量避免硬盘临时表的使用。</td><br></tr><br><tr style="border: 0; border-top: 1px solid #ccc; background-color: white;"><br><td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">Not exists</td><br><td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">MYSQL 优化了 LEFT JOIN，一旦它找到了匹配 LEFT JOIN 标准的行， 就不再搜索了。</td><br></tr><br><tr style="border: 0; border-top: 1px solid #ccc; background-color: #F8F8F8;"><br><td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">Using index</td><br><td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">说明查询是覆盖了索引的，不需要读取数据文件，从索引树（索引文件）中即可获得信息。如果同时出现 using where，表明索引被用来执行索引键值的查找，没有 using where，表明索引用来读取数据而非执行查找动作。这是 MySQL 服务层完成的，但无需再回表查询记录。</td><br></tr><br><tr style="border: 0; border-top: 1px solid #ccc; background-color: white;"><br><td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">Using index condition</td><br><td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">这是 MySQL 5.6 出来的新特性，叫做“索引条件推送”。简单说一点就是 MySQL 原来在索引上是不能执行如 like 这样的操作的，但是现在可以了，这样减少了不必要的 IO 操作，但是只能用在二级索引上。</td><br></tr><br><tr style="border: 0; border-top: 1px solid #ccc; background-color: #F8F8F8;"><br><td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">Using where</td><br><td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">使用了 WHERE 从句来限制哪些行将与下一张表匹配或者是返回给用户。<strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">注意</strong>：Extra 列出现 Using where 表示 MySQL 服务器将存储引擎返回服务层以后再应用 WHERE 条件过滤。</td><br></tr><br><tr style="border: 0; border-top: 1px solid #ccc; background-color: white;"><br><td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">Using join buffer</td><br><td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">使用了连接缓存：<strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">Block Nested Loop</strong>，连接算法是块嵌套循环连接;<strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">Batched Key Access</strong>，连接算法是批量索引连接</td><br></tr><br><tr style="border: 0; border-top: 1px solid #ccc; background-color: #F8F8F8;"><br><td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">impossible where</td><br><td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">where 子句的值总是 false，不能用来获取任何元组</td><br></tr><br><tr style="border: 0; border-top: 1px solid #ccc; background-color: white;"><br><td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">select tables optimized away</td><br><td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">在没有 GROUP BY 子句的情况下，基于索引优化 MIN/MAX 操作，或者对于 MyISAM 存储引擎优化 COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。</td><br></tr><br><tr style="border: 0; border-top: 1px solid #ccc; background-color: #F8F8F8;"><br><td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">distinct</td><br><td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">优化 distinct 操作，在找到第一匹配的元组后即停止找同样值的动作</td><br></tr><br></tbody><br></table><br></section><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">filtered</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">使用 explain extended 时会出现这个列，5.7 之后的版本默认就有这个字段，不需要使用 explain extended 了。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">这个字段表示存储引擎返回的数据在 server 层过滤后，剩下多少满足查询的记录数量的比例，注意是百分比，不是具体记录数。</section></li></ul><br><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">关于 MySQL 执行计划的局限性</span><span class="suffix"></span></h2><br><ol data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">EXPLAIN 不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">EXPLAIN 不考虑各种 Cache；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">EXPLAIN 不能显示 MySQL 在执行查询时所作的优化工作；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">部分统计信息是估算的，并非精确值；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">EXPALIN 只能解释 SELECT 操作，其他操作要重写为 SELECT 后查看。</section></li></ol><br><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">查询计划案例分析</span><span class="suffix"></span></h2><br><figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://img-blog.csdnimg.cn/20181122151128635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3NDUyMzM3MDA=,size_16,color_FFFFFF,t_70" alt="" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></figure><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">执行顺序</span><span class="suffix" style="display: none;"></span></h3><br><ol data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">（id = 4）：【select id, name from t2】：select_type 为 union，说明 id=4 的 select 是 union 里面的第二个 select。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">（id = 3）：【select id, name from t1 where address = ‘11’】：因为是在 from 语句中包含的子查询所以被标记为 DERIVED（衍生），where address = ‘11’ 通过复合索引 idx_name_email_address 就能检索到，所以 type 为 index。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">（id = 2）：【select id from t3】：因为是在 select 中包含的子查询所以被标记为 SUBQUERY。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">（id = 1）：【select d1.name, … d2 from … d1】：select_type 为 PRIMARY 表示该查询为最外层查询，table 列被标记为 “derived3”表示查询结果来自于一个衍生表（id = 3 的 select 结果）。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">（id = NULL）：【 … union … 】：代表从 union 的临时表中读取行的阶段，table 列的 “union 1, 4”表示用 id=1 和 id=4 的 select 结果进行 union 操作。</p><br></section></li></ol><br><p id="nice-suffix-juejin-container" class="nice-suffix-juejin-container" data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em; margin-top: 20px !important;">本文使用 <a href="https://mdnice.com/?from=juejin" style="word-wrap: break-word; font-weight: bold; color: #48b378; text-decoration: none; border-bottom: 1px solid #48b378;" target="_blank" rel="external">mdnice</a> 排版</p></section>]]></content>
      <categories>
        <category>数据库干货篇</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>select语句做了什么？</title>
    <url>/2020/05/08/select%E8%AF%AD%E5%8F%A5%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<p><section id="nice" data-tool="mdnice编辑器" data-website="https://www.mdnice.com" style="padding: 0 10px; word-spacing: 0px; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif; line-height: 1.6; letter-spacing: .034em; color: rgb(63, 63, 63); font-size: 16px; word-break: all;"><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">导读</span><span class="suffix"></span></h2></section></p>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">Mysql在中小型企业中是个香饽饽，目前主流的数据库之一，几乎没有一个后端开发者不会使用的，但是作为一个老司机，仅仅会用真的不够。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">今天陈某透过一个简单的查询语句来讲述在Mysql内部的执行过程。</p><br></section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">select <em> from table where id=10;<br></em></code></pre><br><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">撸它</span><span class="suffix"></span></h2><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">首先通过一张图片来了解一下Mysql的基础架构，如下：</p><br><figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/MYSQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/1.png" alt="" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></figure><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">从上图可以看出，Mysql大致分为Server层和存储引擎层两部分。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">Server层包括连接器、查询缓存、分析器、优化器等，其中包含了Mysql的大多数核心功能以及所有的内置函数（如日期，时间函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">存储引擎层负责数据的存储和提取。它的架构是可插拔式的，支持InnoDB、MyISAM等多个存储引擎。Mysql中主流的存储引擎是InnoDB，由于它对事务的支持让它从Mysql5.5.5版本开始成为了默认的存储引擎。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">大致了解了整体架构，现在说说每一个基础的模块都承担着怎样的责任。</p><br></section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">1. 连接器</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">顾名思义，是客户端和Mysql之间连接的媒介，负责登录、获取权限、维持连接和管理连接。连接命令一般如下：</section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">mysql [-h] ip [- P] port -u [user] -p<br></code></pre><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">在完成经典的TCP握手后，连接器会开始认证身份，要求输入密码。</p><br><ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">密码认证通过，连接器会查询出拥有的权限，即使管理员修改了权限，也不会影响你这次的连接，只有重新连接才会生效。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">密码认证失败，会收到提示信息Access denied for user。</section></li></ul><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">连接完成后，没有后续动作的连接将会变成空闲连接，你可以输入<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">show processlist</code>命令看到它。如下图，其中的Command这一列显示为sleep的这一行表示在系统里面有一个空闲连接。</p><br><figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/MYSQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/2.png" alt="" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></figure><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">客户端如果太长时间没有执行动作，连接器将会自动断开，这个时间由参数<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">wait_timeout</code>控制，默认值是8小时。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p><br></section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">2. 查询缓存【废材，8.0 版本完全删除】</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">连接建立完成后，你就可以select语句了，执行之前会查询缓存。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">查询缓存在Mysql中的是默认关闭的，因为缓存命中率非常低，只要有对表执行一个更新操作，这个表的所有查询缓存都将被清空。怎么样？一句废材足以形容了！！！</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">废材的东西不必多讲，主流的Redis的缓存你不用，别再搞这废材了。</p><br></section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">3. 分析器</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">如果没有命中查询缓存，就要执行查询了，但是在执行查询之前，需要对SQL语句做解析，判断你这条语句有没有语法错误。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">分析器会做 ‘词法分析’ ，你输入的无非可就是多个字符串和空格组成的SQL语句，MYSQL需要识别出里面的字符串是什么，代表什么，有没有关键词等。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">MYSQL会从你输入的select 这个关键字识别出来是一个查询语句，table是表名，id是列名。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">做完这些会做 ‘语法分析’ ，根据MYSQL定义的规则来判断你的SQL语句有没有语法错误，如果你的语法不对，就会收到类似如下的提醒：</p><br></section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘elect  from t where ID=1’ at line 1<br></code></pre><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">4. 优化器</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">经过分析器词法和语法的分析，此时就能知道这条SQL语句是干什么的。但是在开始执行之前，MYSQL底层还要使用优化器对这条SQL语句进行优化处理。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">MYSQL内部会对这条SQL进行评估，比如涉及到多个索引会比较使用哪个索引代价更小、多表join的时候会考虑决定各个表的连接顺序。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">优化器的作用一句话总结：根据MYSQL内部的算法决定如何执行这条SQL语句来达到MYSQL认为代价最小目的。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">优化器阶段完成后，这个语句的执行方案就确定了，接下来就交给执行器执行了。</p><br></section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">5. 执行器</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">MYSQL通过分析器知道了要做什么，通过优化器知道了如何做，于是就进入了执行器阶段。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">执行器开始执行之前，需要检查一下用户对表table有没有执行的权限，没有返回权限不足的错误，有的话就执行。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">执行也是分类的，如果Id不是索引则全表扫描，一行一行的查找，如果是索引则在索引组织表中查询，索引的查询很复杂，其中涉及到B+树等算法，这里不再详细介绍。</p><br></section></li></ul><br><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">总结</span><span class="suffix"></span></h2><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">一条SQL语句在MYSQL内部执行的过程涉及到的内部模块有：连接器、查询缓存、分析器、优化器、执行器、存储引擎。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">至此，MYSQL的基础架构已经讲完了。</p><br></section></li></ul>










]]></content>
      <categories>
        <category>数据库干货篇</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>order by 如何工作</title>
    <url>/2020/04/20/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/</url>
    <content><![CDATA[<section id="nice" data-tool="mdnice编辑器" data-website="https://www.mdnice.com" style="padding: 0 10px; word-spacing: 0px; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif; line-height: 1.6; letter-spacing: .034em; color: rgb(63, 63, 63); font-size: 16px; word-break: all;"><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">前言</span><span class="suffix"></span></h2><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在实际的开发中一定会碰到根据某个字段进行排序后来显示结果的需求，但是你真的理解<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">order by</code>在 Mysql 底层是如何执行的吗？</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">假设你要查询城市是<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">苏州</code>的所有人名字，并且按照姓名进行排序返回前 1000 个人的姓名、年龄，这条 sql 语句应该如何写？</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">首先创建一张用户表，sql 语句如下：</section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">CREATE</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">TABLE</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">user</span> (<br><span>  <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">id</span> <span class="hljs-built_in" style="color: #0086b3; line-height: 26px;">int</span>(<span class="hljs-number" style="color: #008080; line-height: 26px;">11</span>) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">NOT</span> <span class="hljs-literal" style="color: #008080; line-height: 26px;">NULL</span>,<br><span>  city <span class="hljs-built_in" style="color: #0086b3; line-height: 26px;">varchar</span>(<span class="hljs-number" style="color: #008080; line-height: 26px;">16</span>) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">NOT</span> <span class="hljs-literal" style="color: #008080; line-height: 26px;">NULL</span>,<br><span>  <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">name</span> <span class="hljs-built_in" style="color: #0086b3; line-height: 26px;">varchar</span>(<span class="hljs-number" style="color: #008080; line-height: 26px;">16</span>) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">NOT</span> <span class="hljs-literal" style="color: #008080; line-height: 26px;">NULL</span>,<br><span>  age <span class="hljs-built_in" style="color: #0086b3; line-height: 26px;">int</span>(<span class="hljs-number" style="color: #008080; line-height: 26px;">11</span>) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">NOT</span> <span class="hljs-literal" style="color: #008080; line-height: 26px;">NULL</span>,<br><span>  PRIMARY <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">KEY</span> (<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">id</span>),<br><span>  <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">KEY</span> city (city)<br><span>) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">ENGINE</span>=<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">InnoDB</span>;<br><span></span></span></span></span></span></span></span></span></code></pre><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">则上述需求的 sql 查询语句如下：</section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> city,<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">name</span>,age <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">user</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> city=<span class="hljs-string" style="color: #d14; line-height: 26px;">‘苏州’</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">order</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">by</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">name</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">limit</span> <span class="hljs-number" style="color: #008080; line-height: 26px;">1000</span>;<br><span></span></code></pre><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">这条 sql 查询语句相信大家都能写出来，但是你了解它在 Mysql 底层的执行流程吗？今天陈某来大家聊一聊这条 sql 语句是如何执行的以及有什么参数会影响执行的流程。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">本篇文章分为如下几个部分进行详细的阐述：<br><ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">全字段排序</strong></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">rowid 排序</strong></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">全字段排序 VS rowid 排序</strong></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">如何避免排序</strong></section></li></ol><br></section></li></ul><br><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">全字段排序</span><span class="suffix"></span></h2><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">前面聊过索引能够避免全表扫描，因此我们给<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">city</code>这个字段上添加了索引，当然城市的字段很小，不用考虑字符串的索引问题，之前有写过一篇关于如何给字符串的加索引的文章，有不了解朋友看一下这篇文章:<a href="https://mp.weixin.qq.com/s/xaa8ge7LsHWYROOy4qiRJA" style="word-wrap: break-word; font-weight: bold; color: #48b378; text-decoration: none; border-bottom: 1px solid #48b378;" target="_blank" rel="external">Mysql 性能优化：如何给字符串加索引？</a></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">此时用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Explain</code>来分析一下的这条查询语句的执行情况，结果如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/1.png" alt="Explain分析结果" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Extra</code>这个字段中的<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Using filesort</code>表示的就是需要排序，MySQL 会给每个线程分配一块内存用于排序，称为<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">sort_buffer</code>。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">既然使用了索引进行查询，我们来简单的画一下<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">city</code>这棵索引树的结构，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/2-1.png" alt="city索引树" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">从上图可以看出，满足<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">city=’苏州’</code>是从<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">ID3</code>到<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">IDX</code>这些记录。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">通常情况下，此条 sql 语句执行流程如下：<br><ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">初始化 sort_buffer，确定放入 name、city、age 这三个字段。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">从索引 city 找到第一个满足<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">city=’苏州’</code>条件的<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">主键id</code>，也就是图中的<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">ID3</code>。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">到<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">主键id索引</code>取出整行，取<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">name</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">city</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">age</code>三个字段的值，存入<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">sort_buffer</code>中。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">从索引<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">city</code>取下一个记录的主键 id。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">IDX</code>。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">对<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">sort_buffer</code>中的数据按照字段<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">name</code>做快速排序。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">按照排序结果取前 1000 行返回给客户端。</section></li></ol><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">我们称这个排序过程为<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">全字段排序</code>，执行的流程图如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/3.png" alt="全字段排序" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">图中<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">按name排序</code>这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">sort_buffer_size</code>。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">sort_buffer_size</code>：就是 MySQL 为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">磁盘临时文件</code>辅助排序。</section></li></ul><br><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">rowid 排序</span><span class="suffix"></span></h2><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在上面这个算法过程里面，只对原表的数据读了一遍，剩下的操作都是在<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">sort_buffer</code>和<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">临时文件</code>中执行的。<strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">sort_buffer</code>里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差</strong>。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">所以如果单行很大，这个方法效率不够好。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">我们可以修改一个<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">max_length_for_sort_data</code>这个参数使其使用另外一种算法。max_length_for_sort_data，是 MySQL 中专门控制用于排序的行数据的长度的一个参数。它的意思是，如果单行的长度超过这个值，MySQL 就认为单行太大，要换一个算法。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">city</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">name</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">age</code> 这三个字段的定义总长度是<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">36</code>，我把<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">max_length_for_sort_data</code>设置为 16，我们再来看看计算过程有什么改变。设置的 sql 语句如下：</section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">SET</span> max_length_for_sort_data = <span class="hljs-number" style="color: #008080; line-height: 26px;">16</span>;<br><span></span></code></pre><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">新的算法放入 sort_buffer 的字段，只有要排序的列（即 name 字段）和主键 id。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">但这时，排序的结果就因为少了 city 和 age 字段的值，不能直接返回了，整个执行流程就变成如下所示的样子：</p><br><ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">初始化<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">sort_buffer</code>，确定放入两个字段，即<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">name</code>和<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">id</code>。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">从索引 city 找到第一个满足<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">city=’苏州’</code>条件的<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">主键id</code>，也就是图中的<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">ID3</code>。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">到<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">主键id索引</code>取出整行，取 name、id 这两个字段，存入 sort_buffer 中。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">从索引<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">city</code>取下一个记录的主键 id。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">IDX</code>。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">对<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">sort_buffer</code>中的数据按照字段<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">name</code>做快速排序。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端。</section></li></ol><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">这个执行流程的示意图如下，我把它称为<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">rowid排序</code>。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/4.png" alt="rowid排序" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">对比<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">全字段排序</code>，<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">rowid排序</code>多了一次<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">回表查询</code>，即是多了<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">第7步</code>的查询主键索引树。</strong></p><br></section></li></ul><br><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">全字段排序 VS rowid 排序</span><span class="suffix"></span></h2><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如果 MySQL 实在是担心排序内存太小，会影响排序效率，才会采用 rowid 排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如果 MySQL 认为内存足够大，会优先选择全字段排序，把需要的字段都放到 sort_buffer 中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">这也就体现了 MySQL 的一个设计思想：<strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">如果内存够，就要多利用内存，尽量减少磁盘访问</strong>。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">对于 InnoDB 表来说，rowid 排序会要求回表多造成磁盘读，因此不会被优先选择。</strong></section></li></ul><br><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">如何避免排序</span><span class="suffix"></span></h2><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">其实，并不是所有的<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">order by</code>语句，都需要排序操作的。从上面分析的执行过程，我们可以看到，MySQL 之所以需要生成临时表，并且在临时表上做排序操作，其原因是<strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">原来的数据都是无序的</strong>。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如果能够保证从<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">city</code>这个索引上取出来的行，天然就是按照 name 递增排序的话，是不是就可以不用再排序了呢？</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">因此想到了联合索引，创建<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">(city,name)</code>联合索引，sql 语句如下：</section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">alter</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">table</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">user</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">add</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">index</span> city_user(city, <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">name</span>);<br><span></span></code></pre><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">此时的索引树如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/5-1.png" alt="city,name索引树" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在这个索引里面，我们依然可以用树搜索的方式定位到第一个满足<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">city=’苏州’</code>的记录，并且额外确保了，接下来按顺序取“下一条记录”的遍历过程中，只要 city 的值是苏州，name 的值就一定是有序的。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">按照上图，整个查询的流程如下：<br><ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">从索引(city,name)找到第一个满足 city=’苏州’条件的主键 id。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">到主键 id 索引取出整行，取 name、city、age 三个字段的值，作为结果集的一部分直接返回。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">从索引(city,name)取下一个记录主键 id。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">重复步骤 2、3，直到查到第 1000 条记录，或者是不满足 city=’苏州’条件时循环结束。</section></li></ol><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">对应的流程图如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/6.png" alt="city，name联合索引的执行流程" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以看到，这个查询过程不需要临时表，也不需要排序。接下来，我们用 explain 的结果来印证一下。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/7.png" alt="" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">从图中可以看到，<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Extra</code>字段中没有<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Using filesort</code>了，也就是不需要排序了。而且由于<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">(city,name)</code>这个联合索引本身有序，<strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">所以这个查询也不用把 4000 行全都读一遍，只要找到满足条件的前 1000 条记录就可以退出了</strong>。也就是说，在我们这个例子里，只需要扫描 1000 次。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">难道仅仅这样就能满足了？此条查询语句是否能再优化呢？<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/8.jpg" alt="" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">朋友们还记得覆盖索引吗？覆盖索引的好处就是能够避免再次回表查询，不了解的朋友们可以看一下陈某之前写的文章：<a href="https://mp.weixin.qq.com/s/-IRhK4KyDCkTd_lojeEolw" style="word-wrap: break-word; font-weight: bold; color: #48b378; text-decoration: none; border-bottom: 1px solid #48b378;" target="_blank" rel="external">Mysql 性能优化：如何使用覆盖索引？</a>。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">我们创建<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">(city,name,age)</code>联合索引，这样在执行上面的查询语句就能使用覆盖索引了，避免了回表查询了，sql 语句如下：</section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">alter</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">table</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">user</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">add</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">index</span> city_user_age(city, <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">name</span>, age);<br><span></span></code></pre><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">此时执行流程图如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/9-1.png" alt="覆盖索引使用执行流程" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">当然，覆盖索引能够提升效率，但是维护索引也是需要代价的，因此还需要权衡使用。</strong></section></li></ul><br><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">总结</span><span class="suffix"></span></h2><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">今天这篇文章，我和你介绍了 MySQL 里面<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">order by</code>语句的几种算法流程。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在开发系统的时候，你总是不可避免地会使用到 order by 语句。心里要清楚每个语句的排序逻辑是怎么实现的，还要能够分析出在最坏情况下，每个语句的执行对系统资源的消耗，这样才能做到下笔如有神，不犯低级错误。</section></li></ul><br><p id="nice-suffix-juejin-container" class="nice-suffix-juejin-container" data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em; margin-top: 20px !important;">本文使用 <a href="https://mdnice.com/?from=juejin" style="word-wrap: break-word; font-weight: bold; color: #48b378; text-decoration: none; border-bottom: 1px solid #48b378;" target="_blank" rel="external">mdnice</a> 排版</p></section>]]></content>
      <categories>
        <category>数据库干货篇</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>《Mybatis进阶》肝了30天专栏文章，整理成册！！！</title>
    <url>/2020/04/20/%E3%80%8AMybatis%E8%BF%9B%E9%98%B6%E3%80%8B%E8%82%9D%E4%BA%8630%E5%A4%A9%E4%B8%93%E6%A0%8F%E6%96%87%E7%AB%A0%EF%BC%8C%E6%95%B4%E7%90%86%E6%88%90%E5%86%8C%EF%BC%81%EF%BC%81%EF%BC%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><p>Mybatis专栏文章写到至今已经有一个月了，从基础到源码详细的介绍了每个知识点，没什么多余的废话，全是工作、面试中常用到的姿势。有读者建议将文章汇总，这样方便阅读，于是特意花费了一天时间整理成册。</p>
</li>
<li><p><strong>全册总计92页，总计想3万多字，耗时30多天完成。</strong></p>
</li>
<li><p><strong>由于作者水平有限</strong>，如果书中有不理解和错误的内容，感谢及时把疑惑或意见提交给我，作者会及时修正。</p>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E8%BF%9B%E9%98%B6PDF/2.png" alt=""></p>
</li>
<li><p>Mybatis作为一个与数据库交互的轻量级的框架，深受大众喜爱，目前也是主流的框架之一，在平时开发中会经常使用。</p>
</li>
<li><p>可能有些朋友已经用了几年了，在此之前也看过许多的书籍，但是真正的讲讲细化的知识点可能并没有那么容易。</p>
</li>
<li><p><strong>本册文章页面美观，图文并茂，阅读起来很享受，不像市面上文档形式的书籍</strong>。</p>
</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E8%BF%9B%E9%98%B6PDF/3.png" alt=""></p>
<ul>
<li><strong>本册纯属个人总结，其中有多地方需要校正，不喜勿喷！！！</strong></li>
</ul>
<h2 id="适合人群"><a href="#适合人群" class="headerlink" title="适合人群"></a>适合人群</h2><ol>
<li><p>具有一定专业基础的程序员，想要系统学习Mybatis。</p>
</li>
<li><p>对于Mybatis只是停留在会用的基础，想深入学习的程序员。</p>
</li>
<li><p>学习过Mybatis，但是没找到一本合适的书籍系统学习的程序员。</p>
</li>
</ol>
<h2 id="如何获取"><a href="#如何获取" class="headerlink" title="如何获取"></a>如何获取</h2><ul>
<li>扫描下方二维码，添加作者微信注明来意，或者关注公众号【码猿技术专栏】回复关键词<code>Mybatis进阶</code>即可免费获取。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E8%BF%9B%E9%98%B6PDF/4.png" alt=""></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>至此Mybatis的专栏就结束了，下个征程即将开始，喜欢的朋友关注分享一波。</li>
</ul>
]]></content>
      <categories>
        <category>Mybatis进阶</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>个人专著</tag>
      </tags>
  </entry>
  <entry>
    <title>一文搞懂Redis持久化</title>
    <url>/2020/04/20/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82Redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>Redis目前已经成为主流的内存数据库了，但是大部分人仅仅是停留在会用的阶段，你真的了解Redis内部的工作原理吗？</li>
<li>今天这篇文章将为大家介绍Redis持久化的两种方案，文章将会从以下五个方面介绍：<ol>
<li><strong>什么是RDB，RDB如何实现持久化？</strong></li>
<li><strong>什么是AOF，AOF如何实现持久化？</strong></li>
<li><strong>AOF和RDB的区别。</strong></li>
<li><strong>如何重启恢复数据？</strong></li>
<li><strong>持久化性能问题和解决方案</strong><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2></li>
</ol>
</li>
<li>RDB持久化是把当前进程数据生成快照保存到硬盘的过程， 触发RDB持久化过程分为手动触发和自动触发。</li>
<li>RDB完成后会自动生成一个文件，保存在<code>dir</code>配置的指定目录下，文件名是<code>dbfileName</code>指定。</li>
<li>Redis默认会采用LZF算法对生成的RDB文件做压缩处理，压缩后的文件远远小于内存大小，默认开启。</li>
</ul>
<h3 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h3><ul>
<li>手动触发的命令有<code>save</code>和<code>bgsave</code>。</li>
<li><code>save</code>：该命令会阻塞Redis服务器，直到RDB的过程完成，已经被废弃，因此线上不建议使用。</li>
<li><code>bgsave</code>：每次进行RDB过程都会fork一个子进程，由子进程完成RDB的操作，因此阻塞只会发生在fork阶段，一般时间很短。</li>
</ul>
<h3 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h3><ul>
<li>除了手动触发RDB，Redis服务器内部还有如下几个场景能够自动触发RDB：<ol>
<li>根据我们的 <code>save m n</code> 配置规则自动触发。</li>
<li>如果从节点执行全量复制操作， 主节点自动执行bgsave生成RDB文件并发送给从节点。</li>
<li>执行<code>debug reload</code>命令重新加载Redis时， 也会自动触发save操作。</li>
<li>默认情况下执行shutdown命令时， 如果没有开启AOF持久化功能则自动执行<code>bgsave</code>。</li>
</ol>
</li>
</ul>
<h3 id="RDB执行流程"><a href="#RDB执行流程" class="headerlink" title="RDB执行流程"></a>RDB执行流程</h3><ul>
<li>RDB的主流方式就是bgsave，通过下图我们来看看RDB的执行流程：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Redis%E6%8C%81%E4%B9%85%E5%8C%96/RDB%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="RDB执行流程"></li>
<li>通过上图可以很清楚RDB的执行流程，如下：<ol>
<li>执行bgsave命令后，会先判断是否存在AOF或者RDB的子进程，如果存在，直接返回。</li>
<li>父进程fork操作创建一个子进程，fork操作中父进程会被阻塞。</li>
<li>fork完成后，子进程开始根据父进程的内存生成临时快照文件，完成后对原有的RDB文件进行替换。执行<code>lastsave</code>命令可以查看最近一次的RDB时间。</li>
<li>子进程完成后发送信号给父进程，父进程更新统计信息。</li>
</ol>
</li>
</ul>
<h3 id="RDB的优点"><a href="#RDB的优点" class="headerlink" title="RDB的优点"></a>RDB的优点</h3><ul>
<li>RDB是一个紧凑压缩的二进制文件， 代表Redis在某个时间点上的数据快照。 非常适用于备份， 全量复制等场景。 比如每6小时执行<code>bgsave</code>备份，并把RDB文件拷贝到远程机器或者文件系统中，用于灾难恢复。</li>
<li>Redis加载<code>RDB</code>恢复数据远远快于<code>AOF</code>的方式。</li>
</ul>
<h3 id="RDB的缺点"><a href="#RDB的缺点" class="headerlink" title="RDB的缺点"></a>RDB的缺点</h3><ul>
<li>RDB方式数据没办法做到<code>实时持久化</code>/<code>秒级持久化</code>。 因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。</li>
<li>RDB文件使用特定二进制格式保存， Redis版本演进过程中有多个格式的RDB版本， 存在老版本Redis服务无法兼容新版RDB格式的问题。</li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><ul>
<li><code>AOF</code>（append only file） 持久化： 以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中的命令达到恢复数据的目的。 AOF的主要作用是解决了数据持久化的实时性， 目前已经是Redis持久化的<code>主流方式</code>。</li>
</ul>
<h3 id="如何开启AOF"><a href="#如何开启AOF" class="headerlink" title="如何开启AOF"></a>如何开启AOF</h3><ul>
<li>开启AOF功能需要设置配置：<code>appendonly yes</code>， 默认不开启。 AOF文件名通过<code>appendfilename</code>配置设置， 默认文件名是<code>appendonly.aof</code>。 保存路径同RDB持久化方式一致，通过<code>dir</code>配置指定。 </li>
</ul>
<h3 id="AOF整体的执行流程"><a href="#AOF整体的执行流程" class="headerlink" title="AOF整体的执行流程"></a>AOF整体的执行流程</h3><ul>
<li>AOF执行的流程大致分为<code>命令写入</code>、<code>文件同步</code>、<code>文件重写</code>、<code>重启加载</code>四个步骤，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Redis%E6%8C%81%E4%B9%85%E5%8C%96/AOF%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="AOF执行流程"></li>
<li>从上图大致了解了AOF的执行流程，下面一一分析上述的四个步骤。</li>
</ul>
<h3 id="命令写入"><a href="#命令写入" class="headerlink" title="命令写入"></a>命令写入</h3><ul>
<li><p>AOF命令写入的内容直接是文本协议格式。 例如<code>set hello world</code>这条命<br>令， 在AOF缓冲区会追加如下文本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">*<span class="number">3</span>\r\n$<span class="number">3</span>\r\nset\r\n$<span class="number">5</span>\r\nhello\r\n$<span class="number">5</span>\r\nworld\r\n</div></pre></td></tr></table></figure>
</li>
<li><p>命令写入是直接写入到AOF的缓冲区中，至于为什么？原因很简单，Redis使用单线程响应命令，如果每次写AOF文件命令都直接追加到硬盘， 那么性能完全取决于当前硬盘负载。先写入缓冲区<code>aof_buf</code>中， 还有另一个好处， Redis可以提供多种缓冲区<br>同步硬盘的策略，在性能和安全性方面做出平衡。</p>
</li>
</ul>
<h3 id="文件同步"><a href="#文件同步" class="headerlink" title="文件同步"></a>文件同步</h3><ul>
<li>Redis提供了多种AOF缓冲区同步文件策略， 由参数<code>appendfsync</code>控制，如下：<ul>
<li>配置为<code>always</code>时， 每次写入都要同步AOF文件， 在一般的SATA硬盘上，Redis只能支持大约几百TPS写入， 显然跟Redis高性能特性背道而驰，不建议配置。</li>
<li>配置为<code>no</code>，由于操作系统每次同步AOF文件的周期不可控，而且会加大每次同步硬盘的数据量，虽然提升了性能，但数据安全性无法保证。</li>
<li>配置为<code>everysec</code>（默认的配置），是<strong>建议的同步策略</strong>， 也是默认配置，做到兼顾性能和数据安全性。理论上只有在系统突然宕机的情况下丢失1秒的数据（当然，这是不太准确的）。</li>
</ul>
</li>
</ul>
<h3 id="文件重写机制"><a href="#文件重写机制" class="headerlink" title="文件重写机制"></a>文件重写机制</h3><ul>
<li>随着命令不断写入AOF， 文件会越来越大， 为了解决这个问题， Redis引入AOF重写机制压缩文件体积。 AOF文件重写是把Redis进程内的数据转化为写命令同步到新AOF文件的过程。</li>
<li><strong>为什么要文件重写呢？</strong> 因为文件重写能够使得AOF文件的体积变得更小，从而使得可以更快的被Redis加载。</li>
<li>重写过程分为手动触发和自动触发。<ul>
<li>手动触发直接使用<code>bgrewriteaof</code>命令。</li>
<li>根据<code>auto-aof-rewrite-min-size</code>和<code>auto-aof-rewrite-percentage</code>参数确定自动触发时机。</li>
</ul>
</li>
<li><code>auto-aof-rewrite-min-size</code>：表示运行AOF重写时文件最小体积， 默认为64MB。</li>
<li><code>auto-aof-rewrite-percentage</code>：代表当前AOF文件空间（<code>aof_current_size</code>） 和上一次重写后AOF文件空间（<code>aof_base_size</code>） 的比值。</li>
<li>自动触发时机相当于<strong>aof_current_size&gt;auto-aof-rewrite-minsize&amp;&amp;（aof_current_size-aof_base_size） /aof_base_size&gt;=auto-aof-rewritepercentage</strong>。其中<code>aof_current_size</code>和<code>aof_base_size</code>可以在<code>info Persistence</code>统计信息中查看。</li>
<li><strong>那么文件重写后的AOF文件为什么会变小呢？</strong> 有如下几个原因：<ol>
<li>进程内已经超时的数据将不会再次写入AOF文件中。</li>
<li>旧的AOF文件含有无效命令，如<code>del key1</code>、 <code>hdel key2</code>等。重写使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令。</li>
<li>多条写命令可以合并为一个， 如：<code>lpush list a</code>、 <code>lpush list b</code>、<code>lpush listc</code>可以转化为：<code>lpush list a b c</code>。为了防止单条命令过大造成客户端缓冲区溢出，对于<code>list</code>、 <code>set</code>、 <code>hash</code>、 <code>zset</code>等类型操作，以64个元素为界拆分为多条。</li>
</ol>
</li>
<li>介绍了文件重写的系列知识，下面来看看Redis内部是如何进行文件重写的，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Redis%E6%8C%81%E4%B9%85%E5%8C%96/%E6%96%87%E4%BB%B6%E9%87%8D%E5%86%99%E6%B5%81%E7%A8%8B.png" alt="文件重写"></li>
<li>看完上图，大致了解了文件重写的流程，对于重写的流程，补充如下：<ol>
<li>重写期间，主线程并没有阻塞，而是在执行其他的操作命令，依然会向旧的AOF文件写入数据，这样能够保证备份的最终完整性，如果数据重写失败，也能保证数据不会丢失。</li>
<li>为了把重写期间响应的写入信息也写入到新的文件中，因此也会为子进程保留一个缓冲区，防止新写的文件丢失数据。</li>
<li>重写是直接把当前内存的数据生成对应命令，并不需要读取老的AOF文件进行分析、命令合并。</li>
<li>AOF文件直接采用的<code>文本协议</code>，主要是兼容性好、追加方便、可读性高可认为修改修复。</li>
<li>无论是<code>RDB</code>还是<code>AOF</code>都是先写入一个临时文件，然后通过<code>重命名</code>完成文件的替换。</li>
</ol>
</li>
</ul>
<h3 id="AOF的优点"><a href="#AOF的优点" class="headerlink" title="AOF的优点"></a>AOF的优点</h3><ul>
<li>使用 AOF 持久化会让 Redis 变得非常耐久：你可以设置不同的 fsync 策略，比如无 fsync ，每秒钟一次 fsync ，或者每次执行写入命令时 fsync 。 AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。</li>
</ul>
<h3 id="AOF的缺点"><a href="#AOF的缺点" class="headerlink" title="AOF的缺点"></a>AOF的缺点</h3><ul>
<li>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间。</li>
<li>数据恢复速度相对于RDB比较慢。</li>
</ul>
<h2 id="AOF和RDB的区别"><a href="#AOF和RDB的区别" class="headerlink" title="AOF和RDB的区别"></a>AOF和RDB的区别</h2><ul>
<li>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</li>
<li>AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</li>
</ul>
<h2 id="重启加载"><a href="#重启加载" class="headerlink" title="重启加载"></a>重启加载</h2><ul>
<li>无论是RDB还是AOF都可用于服务器重启时的数据恢复，执行流程如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Redis%E6%8C%81%E4%B9%85%E5%8C%96/%E5%90%AF%E5%8A%A8%E6%81%A2%E5%A4%8D.png" alt="重启加载流程"></li>
<li>上图很清晰的分析了Redis启动恢复数据的流程，先检查AOF文件是否开启，文件是否存在，再检查RDB是否开启，文件是否存在。</li>
</ul>
<h2 id="性能问题与解决方案"><a href="#性能问题与解决方案" class="headerlink" title="性能问题与解决方案"></a>性能问题与解决方案</h2><ul>
<li>通过上面的分析，我们都知道RDB的快照、AOF的重写都需要fork，这是一个重量级操作，会对Redis造成阻塞。因此为了不影响Redis主进程响应，我们需要尽可能降低阻塞。</li>
<li>那么如何减少fork操作的阻塞呢？<ol>
<li>优先使用物理机或者高效支持fork操作的虚拟化技术。</li>
<li>控制Redis实例最大可用内存， fork耗时跟内存量成正比， 线上建议每个Redis实例内存控制在10GB以内。</li>
<li>合理配置Linux内存分配策略，避免物理内存不足导致fork失败。</li>
<li>降低fork操作的频率，如适度放宽AOF自动触发时机，避免不必要的全量复制等。</li>
</ol>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>本文介绍了Redis持久化的两种不同的策略，大部分内容是运维人员需要掌握的，当然作为后端人员也是需要了解一下，毕竟小公司都是一人搞全栈，哈哈。</li>
<li><strong>如果觉得陈某写的不错，有所收获的话，关注分享一波，你的关注将是陈某写作的最大动力，谢谢支持！！！</strong></li>
</ul>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>一条查询语句到底是如何执行的?</title>
    <url>/2020/04/01/%E4%B8%80%E6%9D%A1%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li><p>Mysql在中小型企业中是个香饽饽，目前主流的数据库之一，几乎没有一个后端开发者不会使用的，但是作为一个老司机，仅仅会用真的不够。</p>
</li>
<li><p>今天陈某透过一个简单的查询语句来讲述在Mysql内部的执行过程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">select * from table where id=10;</div></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<h2 id="撸它"><a href="#撸它" class="headerlink" title="撸它"></a>撸它</h2><ul>
<li>首先通过一张图片来了解一下Mysql的基础架构，如下：</li>
</ul>
<p>  <img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/MYSQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/1.png" alt=""></p>
<ul>
<li>从上图可以看出，Mysql大致分为Server层和存储引擎层两部分。</li>
<li>Server层包括连接器、查询缓存、分析器、优化器等，其中包含了Mysql的大多数核心功能以及所有的内置函数（如日期，时间函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</li>
<li>存储引擎层负责数据的存储和提取。它的架构是可插拔式的，支持InnoDB、MyISAM等多个存储引擎。Mysql中主流的存储引擎是InnoDB，由于它对事务的支持让它从Mysql5.5.5版本开始成为了默认的存储引擎。</li>
<li>大致了解了整体架构，现在说说每一个基础的模块都承担着怎样的责任。</li>
</ul>
<h3 id="1-连接器"><a href="#1-连接器" class="headerlink" title="1. 连接器"></a>1. 连接器</h3><ul>
<li><p>顾名思义，是客户端和Mysql之间连接的媒介，负责登录、获取权限、维持连接和管理连接。连接命令一般如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mysql [-h] ip [- P] port -u [user] -p</div></pre></td></tr></table></figure>
</li>
<li><p>在完成经典的TCP握手后，连接器会开始认证身份，要求输入密码。</p>
<ul>
<li>密码认证通过，连接器会查询出拥有的权限，即使管理员修改了权限，也不会影响你这次的连接，只有重新连接才会生效。</li>
<li>密码认证失败，会收到提示信息Access denied for user。</li>
</ul>
</li>
<li><p>连接完成后，没有后续动作的连接将会变成空闲连接，你可以输入<code>show processlist</code>命令看到它。如下图，其中的Command这一列显示为sleep的这一行表示在系统里面有一个空闲连接。</p>
</li>
</ul>
<p>  <img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/MYSQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/2.png" alt=""></p>
<ul>
<li><p>客户端如果太长时间没有执行动作，连接器将会自动断开，这个时间由参数<code>wait_timeout</code>控制，默认值是8小时。</p>
</li>
<li><p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p>
</li>
</ul>
<h3 id="2-查询缓存【废材，8-0-版本完全删除】"><a href="#2-查询缓存【废材，8-0-版本完全删除】" class="headerlink" title="2. 查询缓存【废材，8.0 版本完全删除】"></a>2. 查询缓存【废材，8.0 版本完全删除】</h3><ul>
<li><p>连接建立完成后，你就可以select语句了，执行之前会查询缓存。</p>
</li>
<li><p>查询缓存在Mysql中的是默认关闭的，因为缓存命中率非常低，只要有对表执行一个更新操作，这个表的所有查询缓存都将被清空。怎么样？一句废材足以形容了！！！</p>
</li>
<li><p>废材的东西不必多讲，主流的Redis的缓存你不用，别再搞这废材了。</p>
</li>
</ul>
<h3 id="3-分析器"><a href="#3-分析器" class="headerlink" title="3. 分析器"></a>3. 分析器</h3><ul>
<li><p>如果没有命中查询缓存，就要执行查询了，但是在执行查询之前，需要对SQL语句做解析，判断你这条语句有没有语法错误。</p>
</li>
<li><p>分析器会做 ‘词法分析’ ，你输入的无非可就是多个字符串和空格组成的SQL语句，MYSQL需要识别出里面的字符串是什么，代表什么，有没有关键词等。</p>
</li>
<li><p>MYSQL会从你输入的select 这个关键字识别出来是一个查询语句，table是表名，id是列名。</p>
</li>
<li><p>做完这些会做 ‘语法分析’ ，根据MYSQL定义的规则来判断你的SQL语句有没有语法错误，如果你的语法不对，就会收到类似如下的提醒：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;elect * from t where ID=1&apos; at line 1</div></pre></td></tr></table></figure>
</li>
<li><p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。</p>
</li>
</ul>
<h3 id="4-优化器"><a href="#4-优化器" class="headerlink" title="4. 优化器"></a>4. 优化器</h3><ul>
<li><p>经过分析器词法和语法的分析，此时就能知道这条SQL语句是干什么的。但是在开始执行之前，MYSQL底层还要使用优化器对这条SQL语句进行优化处理。</p>
</li>
<li><p>MYSQL内部会对这条SQL进行评估，比如涉及到多个索引会比较使用哪个索引代价更小、多表join的时候会考虑决定各个表的连接顺序。</p>
</li>
<li><p>优化器的作用一句话总结：根据MYSQL内部的算法决定如何执行这条SQL语句来达到MYSQL认为代价最小目的。</p>
</li>
<li><p>优化器阶段完成后，这个语句的执行方案就确定了，接下来就交给执行器执行了。</p>
</li>
</ul>
<h3 id="5-执行器"><a href="#5-执行器" class="headerlink" title="5. 执行器"></a>5. 执行器</h3><ul>
<li><p>MYSQL通过分析器知道了要做什么，通过优化器知道了如何做，于是就进入了执行器阶段。</p>
</li>
<li><p>执行器开始执行之前，需要检查一下用户对表table有没有执行的权限，没有返回权限不足的错误，有的话就执行。</p>
</li>
<li><p>执行也是分类的，如果Id不是索引则全表扫描，一行一行的查找，如果是索引则在索引组织表中查询，索引的查询很复杂，其中涉及到B+树等算法，这里不再详细介绍。</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>一条SQL语句在MYSQL内部执行的过程涉及到的内部模块有：连接器、查询缓存、分析器、优化器、执行器、存储引擎。</p>
</li>
<li><p>至此，MYSQL的基础架构已经讲完了。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库干货篇</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>大白话布隆过滤器，又能和面试官扯皮了！！！</title>
    <url>/2020/04/26/%E5%A4%A7%E7%99%BD%E8%AF%9D%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%8C%E5%8F%88%E8%83%BD%E5%92%8C%E9%9D%A2%E8%AF%95%E5%AE%98%E6%89%AF%E7%9A%AE%E4%BA%86%EF%BC%81%EF%BC%81%EF%BC%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>文章首发于微信公众号<a href="https://mp.weixin.qq.com/s/Vo935pCXH0aPgG20f1ppEg" target="_blank" rel="external">大白话布隆过滤器，又能和面试官扯皮了~</a></li>
<li>近期在做推荐系统中已读内容去重的相关内容，刚好用到了布隆过滤器，于是写了一篇文章记录分享一下。</li>
<li>文章的篇幅不是很长，主要讲了布隆过滤器的核心思想，目录如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.png" alt=""></li>
</ul>
<h2 id="什么是布隆过滤器？"><a href="#什么是布隆过滤器？" class="headerlink" title="什么是布隆过滤器？"></a>什么是布隆过滤器？</h2><ul>
<li>布隆过滤器是由一个长度为<code>m</code>比特的位<strong>数组</strong>与<code>k</code>个<strong>哈希函数</strong>组成的数据结构。比特数组均初始化为<code>0</code>，所有哈希函数都可以分别把输入数据尽量均匀地散列。</li>
<li>当<strong>插入</strong>一个元素时，将其数据通过<code>k</code>个哈希函数转换成<code>k</code>个哈希值，这<code>k</code>个哈希值将作为比特数组的<code>下标</code>，并将数组中的对应下标的值置为<code>1</code>。</li>
<li>当<strong>查询</strong>一个元素时，同样会将其数据通过<code>k</code>个哈希函数转换成<code>k</code>个哈希值（数组下标），查询数组中对应下标的值，如果有一个下标的值为<code>0</code>表明该元素一定不在集合中，如果全部下标的值都为<code>1</code>，表明该元素有<code>可能</code>在集合中。<strong>至于为什么有可能在集合中？</strong> 因为有可能某个或者多个下标的值为 1 是受到其他元素的影响，这就是所谓的<code>假阳性</code>，下文会详细讲述。</li>
<li><strong>无法删除一个元素</strong>，为什么呢？因为你删除的元素的哈希值可能和集合中的某个元素的哈希值有相同的，一旦删除了这个元素会导致其他的元素也被删除。</li>
<li>下图示出一个<code>m=18</code>, <code>k=3</code>的布隆过滤器示例。集合中的 x、y、z 三个元素通过 3 个不同的哈希函数散列到位数组中。当查询元素 w 时，因为有一个比特为 0，因此 w 不在该集合中。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/1.png" alt=""></li>
</ul>
<h2 id="假阳性概率的计算"><a href="#假阳性概率的计算" class="headerlink" title="假阳性概率的计算"></a>假阳性概率的计算</h2><ul>
<li>假阳性是布隆过滤器的一个痛点，因此需要不择一切手段来使假阳性的概率降低，此时就需要计算一下假阳性的概率了。</li>
<li>假设我们的哈希函数选择位数组中的比特时，都是等概率的。当然在设计哈希函数时，也应该尽量满足均匀分布。</li>
<li>在位数组长度<code>m</code>的布隆过滤器中插入一个元素，它的其中一个哈希函数会将某个特定的比特置为<code>1</code>。因此，在插入元素后，该比特仍然为 0 的概率是：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/2.png" alt=""></li>
<li>现有<code>k</code>个哈希函数，并插入<code>n</code>个元素，自然就可以得到该比特仍然为 0 的概率是：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/3.png" alt=""></li>
<li>反过来讲，它已经被置为<code>1</code>的概率就是：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/4.png" alt=""></li>
<li>也就是说，如果在插入<code>n</code>个元素后，我们用一个不在集合中的元素来检测，那么被误报为存在于集合中的概率（也就是所有哈希函数对应的比特都为<code>1</code>的概率）为：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/5.png" alt=""></li>
<li>当<code>n</code>比较大时，根据极限公式，可以近似得出假阳性率：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/6.png" alt=""></li>
<li>所以，在哈希函数个数<code>k</code>一定的情况下有如下结论：<ol>
<li>位数组长度 m 越大，假阳性率越低。</li>
<li>已插入元素的个数 n 越大，假阳性率越高。</li>
</ol>
</li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>用比特数组表示，不用存储数据本身，对空间的节省相比于传统方式占据绝对的优势。</li>
<li>时间效率很高，无论是插入还是查询，只需要简单的经过哈希函数转换，时间复杂度均为<code>O(k)</code>。</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>存在<code>假阳性</code>的概率，准确率要求高的场景不太适用。</li>
<li>只能插入和查询，不能删除了元素。</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>布隆过滤器的用途很多，但是主要的作用就是去重，这里列举几个使用场景。</li>
</ul>
<h3 id="爬虫重复-URL-检测"><a href="#爬虫重复-URL-检测" class="headerlink" title="爬虫重复 URL 检测"></a>爬虫重复 URL 检测</h3><ul>
<li>试想一下，百度是一个爬虫，它会定时搜集各大网站的信息，文章，那么它是如何保证爬取到文章信息不重复，它会将 URL 存放到布隆过滤器中，每次爬取之前先从布隆过滤器中判断这个 URL 是否存在，这样就避免了重复爬取。当然这种存在假阳性的可能，但是只要你的比特数组足够大，<code>假阳性</code>的概率会很低，另一方面，你认为百度会在意这种的误差吗，你的一篇文章可能因为假阳性概率没有收录到，对百度有影响吗？</li>
</ul>
<h3 id="抖音推荐功能"><a href="#抖音推荐功能" class="headerlink" title="抖音推荐功能"></a>抖音推荐功能</h3><ul>
<li>读者朋友们应该没人没刷过抖音吧，每次刷的时候抖音给你的视频有重复的吗？他是如何保证推荐的内容不重复的呢？</li>
<li>最容易想到的就是抖音会记录用户的历史观看记录，然后从历史记录中排除。这是一种解决办法，但是性能呢？不用多说了，有点常识的都知道这不可能。</li>
<li>解决这种重复的问题，布隆过滤器有着绝对的优势，能够很轻松的解决。</li>
</ul>
<h3 id="防止缓存穿透"><a href="#防止缓存穿透" class="headerlink" title="防止缓存穿透"></a>防止缓存穿透</h3><ul>
<li>缓存穿透是指查询一条数据库和缓存都没有的一条数据，就会一直查询数据库，对数据库的访问压力会一直增大。</li>
<li>布隆过滤器在解决缓存穿透的问题效果也是很好，这里不再细说，后续文章会写。</li>
</ul>
<h2 id="如何实现布隆过滤器？"><a href="#如何实现布隆过滤器？" class="headerlink" title="如何实现布隆过滤器？"></a>如何实现布隆过滤器？</h2><ul>
<li>了解布隆过滤器的设计思想之后，想要实现一个布隆过滤器其实很简单，陈某这里就不再搬门弄斧了，介绍一下现成的实现方式吧。</li>
</ul>
<h3 id="Redis-实现"><a href="#Redis-实现" class="headerlink" title="Redis 实现"></a>Redis 实现</h3><ul>
<li>Redis4.0 之后推出了插件的功能，下面用 docker 安装：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">docker pull redislabs/rebloom</div><div class="line">docker run -p6379:<span class="number">6379</span> redislabs/rebloom</div></pre></td></tr></table></figure>
<ul>
<li>安装完成后连接 redis 即可，运行命令：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">redis-cli</div></pre></td></tr></table></figure>
<ul>
<li>至于具体的使用这里不再演示了，直接看官方文档和教程，使用起来还是很简单的。</li>
</ul>
<h3 id="Guava-实现"><a href="#Guava-实现" class="headerlink" title="Guava 实现"></a>Guava 实现</h3><ul>
<li>guava 对应布隆过滤器的实现做出了支持，使用 guava 可以很轻松的实现一个布隆过滤器。</li>
</ul>
<p><strong>1. 创建布隆过滤器</strong></p>
<ul>
<li>创建布隆过滤器，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">BloomFilter&lt;Integer&gt; filter = BloomFilter.create(</div><div class="line">                    Funnels.integerFunnel(),</div><div class="line">                    <span class="number">5000</span>,</div><div class="line">                    <span class="number">0.01</span>);</div><div class="line"><span class="comment">//插入</span></div><div class="line">IntStream.range(<span class="number">0</span>, <span class="number">100_000</span>).forEach(filter::put);</div><div class="line"><span class="comment">//判断是否存在</span></div><div class="line"><span class="keyword">boolean</span> b = filter.mightContain(<span class="number">1</span>);</div></pre></td></tr></table></figure>
<ul>
<li><code>arg1</code>：用于将任意类型 T 的输入数据转化为 Java 基本类型的数据，这里转换为 byte</li>
<li><code>arg2</code>：byte 字节数组的基数</li>
<li><code>arg3</code>：期望的假阳性概率</li>
</ul>
<p><strong>2.估计最优 m 值和 k 值</strong></p>
<ul>
<li>guava 在底层对 byte 数组的基数(m)和哈希函数的个数 k 做了自己的算法，源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//m值的计算</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">optimalNumOfBits</span><span class="params">(<span class="keyword">long</span> n, <span class="keyword">double</span> p)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (p == <span class="number">0</span>) &#123;</div><div class="line">    p = Double.MIN_VALUE;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> (<span class="keyword">long</span>) (-n * Math.log(p) / (Math.log(<span class="number">2</span>) * Math.log(<span class="number">2</span>)));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//k值的计算</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">optimalNumOfHashFunctions</span><span class="params">(<span class="keyword">long</span> n, <span class="keyword">long</span> m)</span> </span>&#123;</div><div class="line">  <span class="comment">// (m / n) * log(2), but avoid truncation due to division!</span></div><div class="line">  <span class="keyword">return</span> Math.max(<span class="number">1</span>, (<span class="keyword">int</span>) Math.round((<span class="keyword">double</span>) m / n * Math.log(<span class="number">2</span>)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>想要理解 guava 的计算原理，还要从的上面推导的过程继续。</li>
<li>由假阳性率的近似计算方法可知，如果要使假阳性率尽量小，在 m 和 n 给定的情况下，<code>k</code>值应为：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/7.png" alt=""></li>
<li>将 k 代入上一节的式子并化简，我们可以整理出期望假阳性率 p 与 m、n 的关系：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/8,.png" alt=""></li>
<li>换算而得：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/9.png" alt=""></li>
<li>根据以上分析得出以下的结论：<ol>
<li>如果指定期望假阳性率 p，那么最优的 m 值与期望元素数 n 呈线性关系。</li>
<li>最优的 k 值实际上只与 p 有关，与 m 和 n 都无关，即：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/10.png" alt=""></li>
<li>综上两个结论，在创建布隆过滤器的时候，确定<code>p</code>值和<code>m</code>值很重要。</li>
</ol>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>至此，布隆过滤器的知识介绍到这里，如果觉得陈某写得不错的，转发在看点一波，读者的一份支持将会是我莫大的鼓励。</li>
<li><strong>另外想和陈某私聊或者想要加交流群的朋友，公众号回复关键词<code>加群</code>加陈某微信，陈某会第一时间拉你进群。</strong></li>
</ul>
<h2 id="巨人的肩膀"><a href="#巨人的肩膀" class="headerlink" title="巨人的肩膀"></a>巨人的肩膀</h2><ul>
<li><a href="https://blog.csdn.net/u012422440/article/details/94088166" target="_blank" rel="external">https://blog.csdn.net/u012422440/article/details/94088166</a></li>
<li><a href="https://blog.csdn.net/Revivedsun/article/details/94992323" target="_blank" rel="external">https://blog.csdn.net/Revivedsun/article/details/94992323</a></li>
</ul>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo的Next主题优化教程</title>
    <url>/2020/10/26/%E5%A5%B3%E6%9C%8B%E5%8F%8B%E7%9C%8B%E4%BA%86%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%8C%E8%AF%B4%E5%A4%AALOW%E4%BA%86%EF%BC%8C%E4%BA%8E%E6%98%AF%E6%88%91%E6%8A%98%E8%85%BE%E4%BA%86%E4%B8%80%E5%A4%A9/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>陈某的独立博客搭建已经有三年多时间了，使用<code>Hexo</code>+<code>Git</code>，一直使用的主题是<code>jacman</code>，前几天女票看到说太LOW了，这哪能忍，必须换一个逼格高点的。</p>
<p>其实的三年前看到<code>jacman</code>这个主题还是挺喜欢的，但是现在的看看确实不怎地，哎，老了….</p>
<p>今天这篇文章来介绍下一款简洁的主题<code>NEXT</code>以及配置方式。先来上一张个人的博客的截图，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/1.png" alt=""></p>
<a id="more"></a>
<h2 id="如何下载？"><a href="#如何下载？" class="headerlink" title="如何下载？"></a>如何下载？</h2><p><code>NEXT</code>这款主题源码都直接托管在GitHub上，可以直接搜索，下载地址：<code>https://github.com/theme-next/hexo-theme-next.git</code>。</p>
<p>下载源码之后，直接解压到博客的<code>themes</code>的目录下，比如我的主题目录就是<code>G:\hexo\themes\next</code>。</p>
<h2 id="配置文件的分类"><a href="#配置文件的分类" class="headerlink" title="配置文件的分类"></a>配置文件的分类</h2><p>hexo搭建的博客有两个<code>yml</code>配置文件，一个称之为<code>站点配置文件</code>，是根目录下的<code>_config.yml</code>，另一个是<code>主题配置文件</code>，是主题目录下的<code>_config.yml</code>文件。</p>
<h2 id="基本信息配置"><a href="#基本信息配置" class="headerlink" title="基本信息配置"></a>基本信息配置</h2><p>基本信息包括：博客标题、作者、描述、语言等等。这些基本信息的配置都在站点配置文件中。如下：<br><figure class="highlight yml"><table><tr><td class="code"><pre><div class="line"><span class="attr">title:</span> <span class="string">标题</span></div><div class="line"><span class="attr">subtitle:</span> <span class="string">副标题</span></div><div class="line"><span class="attr">description:</span> <span class="string">描述</span></div><div class="line"><span class="attr">author:</span> <span class="string">作者</span></div><div class="line"><span class="attr">language:</span> <span class="string">语言（简体中文是zh-Hans）</span></div><div class="line"><span class="attr">timezone:</span> <span class="string">网站时区（Hexo</span> <span class="string">默认使用您电脑的时区，不用写）</span></div></pre></td></tr></table></figure></p>
<p>比如我的站点配置文件以上的配置如下：<br><figure class="highlight yml"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Site</span></div><div class="line"><span class="attr">title:</span> <span class="string">不才陈某技术博客</span></div><div class="line"><span class="attr">subtitle:</span> <span class="string">微信公众号：码猿技术专栏</span></div><div class="line"><span class="attr">description:</span> <span class="string">本站是不才陈某的技术分享博客。内容涵盖Java后端技术、Spring</span> <span class="string">Boot、微服务架构、系统安全、前端、系统监控等相关的研究与知识分享。</span></div><div class="line"><span class="attr">author:</span> <span class="string">不才陈某</span></div><div class="line"><span class="attr">language:</span> <span class="string">zh-Hans</span></div><div class="line"><span class="attr">timezone:</span></div></pre></td></tr></table></figure></p>
<h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><p>hexo博客的主题很多，想要切换也是很简单，直接在<code>站点配置文件</code>中设置即可，如下：<br><figure class="highlight yml"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 切换next主题</span></div><div class="line"><span class="attr">theme:</span> <span class="string">next</span></div></pre></td></tr></table></figure></p>
<h2 id="Next主题样式设置"><a href="#Next主题样式设置" class="headerlink" title="Next主题样式设置"></a>Next主题样式设置</h2><p>Next主题提供了4种风格供我们选择，分别为<code>Muse</code>、<code>Mist</code>、<code>Pisces</code>、<code>Gemini</code>。</p>
<p>以上4种风格大同小异，作者博客的风格是<code>Gemini</code>，大家可以根据自己的喜好任意切换，在<code>主题配置文件</code>中找到<code>Scheme Settings</code>，如下：<br><figure class="highlight yml"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 设置自己喜欢的风格</span></div><div class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></div></pre></td></tr></table></figure></p>
<h2 id="添加动态背景"><a href="#添加动态背景" class="headerlink" title="添加动态背景"></a>添加动态背景</h2><p>动态背景能瞬间提升博客的逼格，实现的效果如下：<br><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/2.gif" alt=""></p>
<p>配置起来也是很简单，在<code>主题配置文件</code>中，修改如下：<br><figure class="highlight yml"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 设置为true</span></div><div class="line"><span class="attr">canvas_nest:</span> <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<h2 id="修改链接的样式"><a href="#修改链接的样式" class="headerlink" title="修改链接的样式"></a>修改链接的样式</h2><p>默认的超链接的样式是灰色的，可以修改成如下效果：<br><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/3.gif" alt=""></p>
<p>修改文件 <code>themes\next\source\css\_common\components\post\post.styl</code> ，在末尾添加如下css样式：<br><figure class="highlight"><table><tr><td class="code"><pre><div class="line">// 文章内链接文本样式</div><div class="line">.post-body p a&#123;</div><div class="line">  color: #0593d3;</div><div class="line">  border-bottom: none;</div><div class="line">  border-bottom: 1px solid #0593d3;</div><div class="line">  &amp;:hover &#123;</div><div class="line">    color: #fc6423;</div><div class="line">    border-bottom: none;</div><div class="line">    border-bottom: 1px solid #fc6423;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中选择<code>.post-body</code> 是为了不影响标题，选择<code>p</code> 是为了不影响首页<code>阅读全文</code>的显示样式,颜色可以自己定义。</p>
<h2 id="添加文章搜索功能"><a href="#添加文章搜索功能" class="headerlink" title="添加文章搜索功能"></a>添加文章搜索功能</h2><p>搜索这个功能是很非常重要的，文章很多的情况下怎样才能快速筛选想要的文章呢？搜索的功能是少不了的。实现的效果如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/4.png" alt="4"></p>
<p>Next主题添加搜索的功能很简单，首先安装搜索插件：<br><figure class="highlight cmd"><table><tr><td class="code"><pre><div class="line">npm install hexo-generator-searchdb --save</div></pre></td></tr></table></figure></p>
<p>插件安装完成之后在<code>站点配置文件</code>中找到<code>Extensions</code>，在其下面添加如下内容：<br><figure class="highlight yml"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 搜索</span></div><div class="line"><span class="attr">search:</span></div><div class="line"><span class="attr">  path:</span> <span class="string">search.xml</span></div><div class="line"><span class="attr">  field:</span> <span class="string">post</span></div><div class="line"><span class="attr">  format:</span> <span class="string">html</span></div><div class="line"><span class="attr">  limit:</span> <span class="number">10000</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>搜索功能很强大，但是第一次加载可能有点慢，大概十几秒的时间才能出来搜索框，没办法，毕竟是静态的。</p>
</blockquote>
<h2 id="修改文章底部标签的-的样式"><a href="#修改文章底部标签的-的样式" class="headerlink" title="修改文章底部标签的#的样式"></a>修改文章底部标签的<code>#</code>的样式</h2><p>默认的文章标签的样式是带有<code>#</code>这个符号的，比如<code>#Spring Boot</code>，但是可以将<code>#</code>修改成标签的<code>icon</code>，效果如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/5.png" alt="5"></p>
<p>实现方法很简单，修改模板<code>/themes/next/layout/_macro/post.swig</code>，搜索<code>rel=&quot;tag&quot;&gt;#</code>，将<code>#</code>换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code>。</p>
<h2 id="修改作者头像并旋转"><a href="#修改作者头像并旋转" class="headerlink" title="修改作者头像并旋转"></a>修改作者头像并旋转</h2><p>修改头像很简单，找一张尺寸合适、自己喜欢的图片，放在<code>themes\next\source\images</code>下，随后修改<code>主题配置文件</code>，将头像重新设置即可，配置如下：<br><figure class="highlight yml"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 设置自己的头像</span></div><div class="line"><span class="attr">avatar:</span> <span class="string">/images/header.jpg</span></div></pre></td></tr></table></figure></p>
<p>头像默认是不带旋转的，想要实现鼠标放在头像上方会自动旋转，只需要在<code>\themes\next\source\css\_common\components\sidebar\sidebar-author.styl</code>文件下添加如下一段代码：<br><figure class="highlight"><table><tr><td class="code"><pre><div class="line">.site-author-image &#123;</div><div class="line">  display: block;</div><div class="line">  margin: 0 auto;</div><div class="line">  padding: $site-author-image-padding;</div><div class="line">  max-width: $site-author-image-width;</div><div class="line">  height: $site-author-image-height;</div><div class="line">  border: $site-author-image-border-width solid $site-author-image-border-color;</div><div class="line"></div><div class="line">  /* 头像圆形 */</div><div class="line">  border-radius: 80px;</div><div class="line">  -webkit-border-radius: 80px;</div><div class="line">  -moz-border-radius: 80px;</div><div class="line">  box-shadow: inset 0 -1px 0 #333sf;</div><div class="line"></div><div class="line">  /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 </div><div class="line">    (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/</div><div class="line"> </div><div class="line"></div><div class="line">  /* 鼠标经过头像旋转360度 */</div><div class="line">  -webkit-transition: -webkit-transform 1.0s ease-out;</div><div class="line">  -moz-transition: -moz-transform 1.0s ease-out;</div><div class="line">  transition: transform 1.0s ease-out;</div><div class="line">&#125;</div><div class="line"></div><div class="line">img:hover &#123;</div><div class="line">  /* 鼠标经过停止头像旋转 </div><div class="line">  -webkit-animation-play-state:paused;</div><div class="line">  animation-play-state:paused;*/</div><div class="line"></div><div class="line">  /* 鼠标经过头像旋转360度 */</div><div class="line">  -webkit-transform: rotateZ(360deg);</div><div class="line">  -moz-transform: rotateZ(360deg);</div><div class="line">  transform: rotateZ(360deg);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Z 轴旋转动画 */</div><div class="line">@-webkit-keyframes play &#123;</div><div class="line">  0% &#123;</div><div class="line">    -webkit-transform: rotateZ(0deg);</div><div class="line">  &#125;</div><div class="line">  100% &#123;</div><div class="line">    -webkit-transform: rotateZ(-360deg);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">@-moz-keyframes play &#123;</div><div class="line">  0% &#123;</div><div class="line">    -moz-transform: rotateZ(0deg);</div><div class="line">  &#125;</div><div class="line">  100% &#123;</div><div class="line">    -moz-transform: rotateZ(-360deg);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">@keyframes play &#123;</div><div class="line">  0% &#123;</div><div class="line">    transform: rotateZ(0deg);</div><div class="line">  &#125;</div><div class="line">  100% &#123;</div><div class="line">    transform: rotateZ(-360deg);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上配置完成之后，将鼠标悬停在头像上方将会自动旋转起来。</p>
<h2 id="修改-的样式"><a href="#修改-的样式" class="headerlink" title="修改``的样式"></a>修改``的样式</h2><p>Next默认的主题样式是灰色的，不太显眼，颜色也不太好看，可以将其设置成自己喜欢的颜色，效果如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/6.png" alt=""></p>
<p>配置起来也是很简单，只需要在<code>\themes\next\source\css\_custom\custom.styl</code>文件中添加如下代码：<br><figure class="highlight"><table><tr><td class="code"><pre><div class="line">// Custom styles.</div><div class="line">code &#123;</div><div class="line">    color: #ff7600;</div><div class="line">    background: #fbf7f8;</div><div class="line">    margin: 2px;</div><div class="line">&#125;</div><div class="line">// 大代码块的自定义样式</div><div class="line">.highlight, pre &#123;</div><div class="line">    margin: 5px 0;</div><div class="line">    padding: 5px;</div><div class="line">    border-radius: 3px;</div><div class="line">&#125;</div><div class="line">.highlight, code, pre &#123;</div><div class="line">    border: 1px solid #d6d6d6;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>以上的颜色可以配置自己喜欢的，比如效果图中的颜色是我个人比较喜欢的。</p>
</blockquote>
<h2 id="添加全文阅读的按钮"><a href="#添加全文阅读的按钮" class="headerlink" title="添加全文阅读的按钮"></a>添加全文阅读的按钮</h2><p>Next主题默认是没有全文阅读按钮的，文章是全部展开形式的，但是可以设置成如下效果：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/7.png" alt=""></p>
<p>共有两种配置方法，分别如下：</p>
<ol>
<li>在<code>md</code>文件中需要折叠的地方添加<code>&lt;!--more--&gt;</code>，则在其下方的内容都将会折叠起来，只有点击<code>阅读全文</code>按钮才会显示出来。</li>
<li>在<code>主题配置文件</code>中找到<code>auto_excerpt</code>，这个属性可以设置为自动折叠，比如设置成只显示<code>300</code>个字，这样的后面的内容就会折叠起来，配置如下：<figure class="highlight yml"><table><tr><td class="code"><pre><div class="line"><span class="attr">auto_excerpt:</span></div><div class="line"><span class="attr">  enable:</span> <span class="literal">true</span></div><div class="line"><span class="attr">  length:</span> <span class="number">300</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="添加站点访问人数计数"><a href="#添加站点访问人数计数" class="headerlink" title="添加站点访问人数计数"></a>添加站点访问人数计数</h2><p>站点访问计数有名的就是<code>不蒜子</code>，使用起来非常方便，安装步骤也是很简单。</p>
<p>将如下的代码添加到<code>themes/next/layout/_partial/footer.swig</code>文件中：<br><figure class="highlight"><table><tr><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">&lt;script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;</div><div class="line">&lt;span id="busuanzi_container_site_pv" style='display:none'&gt;</div><div class="line">    本站总访问量 &lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt; 次</div><div class="line">    &lt;span class="post-meta-divider"&gt;|&lt;/span&gt;</div><div class="line">&lt;/span&gt;</div><div class="line">&lt;span id="busuanzi_container_site_uv" style='display:none'&gt;</div><div class="line">    有&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;人看过我的博客啦</div><div class="line">&lt;/span&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>添加的位置如下图，可自行根据个人喜好更换位置：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/8.png" alt=""></p>
<p>以上设置完毕后只是显示整个站点的次数，并没有显示每篇文章的访问次数，效果如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/9.png" alt=""></p>
<p>如果想要显示每篇文章的访问次数，在<code>themes/next/layout/_macro/post.swig</code>文件第一行增加<code>is_pv</code>字段，如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><div class="line">&#123;% macro render(post, is_index, is_pv, post_extra_class) %&#125;</div></pre></td></tr></table></figure></p>
<p>然后将这段代码插入到其中：<br><figure class="highlight js"><table><tr><td class="code"><pre><div class="line">&#123;% <span class="keyword">if</span> is_pv %&#125;</div><div class="line">  &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"post-meta-divider"</span>&gt;|<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></div><div class="line">  &lt;span id=<span class="string">"busuanzi_value_page_pv"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>次阅读</div><div class="line">&#123;% endif %&#125;</div></pre></td></tr></table></figure></p>
<p>插入的位置如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/10.png" alt=""></p>
<p>然后再打开 <code>themes/next/layout/post.swig</code>，这个文件是文章的模板，给<code>render</code>方法传入参数（对应刚才添加的<code>is_pv</code>字段），如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/11.png" alt=""></p>
<p>最后再打开<code>themes/next/layout/index.swig</code>，这个文件是首页的模板，给<code>render</code>方法传入参数（对应刚才添加的<code>is_pv</code>字段），如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/12.png" alt=""></p>
<p>至此即可配置成功，效果如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/13.png" alt=""></p>
<h2 id="去掉文章目录标题的自动编号"><a href="#去掉文章目录标题的自动编号" class="headerlink" title="去掉文章目录标题的自动编号"></a>去掉文章目录标题的自动编号</h2><p>我们自己写文章的时候一般都会自己带上标题编号，但是默认的主题会给我们带上编号，很是别扭，如何去掉呢？</p>
<p>在<code>主题配置文件</code>中找到<code>toc</code>属性，将其中的<code>number</code>属性设置成<code>false</code>，如下：<br><figure class="highlight yml"><table><tr><td class="code"><pre><div class="line"><span class="attr">toc:</span></div><div class="line"><span class="attr">  enable:</span> <span class="literal">true</span></div><div class="line"><span class="attr">  number:</span> <span class="literal">false</span></div><div class="line"><span class="attr">  wrap:</span> <span class="literal">false</span></div></pre></td></tr></table></figure></p>
<p>最终实现的效果如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/14.png" alt=""></p>
<h2 id="主页文章添加阴影卡片效果"><a href="#主页文章添加阴影卡片效果" class="headerlink" title="主页文章添加阴影卡片效果"></a>主页文章添加阴影卡片效果</h2><p>添加阴影卡片效果的效果图如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/15.png" alt=""></p>
<p>实现方法只需要在<code>\themes\next\source\css\_custom\custom.styl</code>文件中添加如下内容即可：<br><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 主页文章添加阴影效果</span></div><div class="line"> .post &#123;</div><div class="line">   margin-top: <span class="number">60</span>px;</div><div class="line">   margin-bottom: <span class="number">60</span>px;</div><div class="line">   padding: <span class="number">25</span>px;</div><div class="line">   -webkit-box-shadow: <span class="number">0</span> <span class="number">0</span> <span class="number">5</span>px rgba(<span class="number">202</span>, <span class="number">203</span>, <span class="number">203</span>, <span class="number">.5</span>);</div><div class="line">   -moz-box-shadow: <span class="number">0</span> <span class="number">0</span> <span class="number">5</span>px rgba(<span class="number">202</span>, <span class="number">203</span>, <span class="number">204</span>, <span class="number">.5</span>);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h2 id="网站底部字数统计"><a href="#网站底部字数统计" class="headerlink" title="网站底部字数统计"></a>网站底部字数统计</h2><p>实现的效果如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/16.png" alt=""></p>
<p>首先切换到根目录，安装插件，命令如下：<br><figure class="highlight cmd"><table><tr><td class="code"><pre><div class="line">npm install hexo-wordcount --save</div></pre></td></tr></table></figure></p>
<p>然后在<code>/themes/next/layout/_partials/footer.swig</code>文件尾部加上：<br><figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"theme-info"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"powered-by"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-count"</span>&gt;</span>博客全站共&#123;&#123; totalcount(site) &#125;&#125;字<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="设置网站的图标Favicon"><a href="#设置网站的图标Favicon" class="headerlink" title="设置网站的图标Favicon"></a>设置网站的图标Favicon</h2><p>Next会有一个默认的网站图标，但是的我们可以替换成自己喜欢的，效果如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/17.png" alt=""></p>
<p>实现方法很简单，自己设计一张喜欢的logo，并将图标名称改为<code>favicon.ico</code>，然后把图标放在<code>/themes/next/source/images</code>里，并且修改<code>主题配置文件</code>：<br><figure class="highlight yml"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Put your favicon.ico into `hexo-site/source/` directory.</span></div><div class="line"><span class="attr">favicon:</span> <span class="string">/favicon.ico</span></div></pre></td></tr></table></figure></p>
<h2 id="添加文章字数统计功能"><a href="#添加文章字数统计功能" class="headerlink" title="添加文章字数统计功能"></a>添加文章字数统计功能</h2><p>该功能能够为每篇文章计算字数以及阅读大致需要的时间，效果如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/18.png" alt=""></p>
<p>在根目录下安装<code>hexo-wordcount</code>,执行命令如下：<br><figure class="highlight cmd"><table><tr><td class="code"><pre><div class="line">npm install hexo-wordcount --save</div></pre></td></tr></table></figure></p>
<p>安装完成后在<code>主题配置文件</code>中的配置参数如下：<br><figure class="highlight yml"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Post wordcount display settings</span></div><div class="line"><span class="comment"># Dependencies: https://github.com/willin/hexo-wordcount</span></div><div class="line"><span class="attr">post_wordcount:</span></div><div class="line"><span class="attr">  item_text:</span> <span class="literal">true</span></div><div class="line"><span class="attr">  wordcount:</span> <span class="literal">true</span></div><div class="line"><span class="attr">  min2read:</span> <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<h2 id="添加顶部动态加载条"><a href="#添加顶部动态加载条" class="headerlink" title="添加顶部动态加载条"></a>添加顶部动态加载条</h2><p>实现的效果如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/19.gif" alt=""></p>
<p>配置很简单，只需要在<code>主题配置文件</code>中修改<code>pace</code>属性为<code>true</code>，如下：<br><figure class="highlight yml"><table><tr><td class="code"><pre><div class="line"><span class="attr">pace:</span> <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<h2 id="文章设置置顶"><a href="#文章设置置顶" class="headerlink" title="文章设置置顶"></a>文章设置置顶</h2><p>修改<code>hero-generator-index</code> 插件，把文件：<code>node_modules/hexo-generator-index/lib/generator.js</code> 内的代码替换为：<br><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">'hexo-pagination'</span>);</div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">locals</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> config = <span class="keyword">this</span>.config;</div><div class="line">  <span class="keyword">var</span> posts = locals.posts;</div><div class="line">    posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span>(a.top &amp;&amp; b.top) &#123; <span class="comment">// 两篇文章top都有定义</span></div><div class="line">            <span class="keyword">if</span>(a.top == b.top) <span class="keyword">return</span> b.date - a.date; <span class="comment">// 若top值一样则按照文章日期降序排</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">return</span> b.top - a.top; <span class="comment">// 否则按照top值降序排</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a.top &amp;&amp; !b.top) &#123; <span class="comment">// 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span></div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!a.top &amp;&amp; b.top) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> b.date - a.date; <span class="comment">// 都没定义按照文章日期降序排</span></div><div class="line">    &#125;);</div><div class="line">  <span class="keyword">var</span> paginationDir = config.pagination_dir || <span class="string">'page'</span>;</div><div class="line">  <span class="keyword">return</span> pagination(<span class="string">''</span>, posts, &#123;</div><div class="line">    <span class="attr">perPage</span>: config.index_generator.per_page,</div><div class="line">    <span class="attr">layout</span>: [<span class="string">'index'</span>, <span class="string">'archive'</span>],</div><div class="line">    <span class="attr">format</span>: paginationDir + <span class="string">'/%d/'</span>,</div><div class="line">    <span class="attr">data</span>: &#123;</div><div class="line">      <span class="attr">__index</span>: <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在文章中添加 <code>top</code> 值，数值越大文章越靠前，如：<br><figure class="highlight md"><table><tr><td class="code"><pre><div class="line">---</div><div class="line">title: Spring Boot 与多数据源的那点事儿~</div><div class="line">date: 2020-05-22 22:45:48</div><div class="line">tags: Spring Boot进阶</div><div class="line">categories: Spring Boot</div><div class="line"><span class="section">top: 100</span></div><div class="line">---</div></pre></td></tr></table></figure></p>
<h2 id="文章加密访问"><a href="#文章加密访问" class="headerlink" title="文章加密访问"></a>文章加密访问</h2><p>有些文章涉及到隐私可能需要密码才能访问，此时就可以设置加密，效果如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/20.gif" alt=""></p>
<p>在<code>themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig</code>文件中的<code>&lt;meta&gt;</code>标签之后插入以下代码：<br><figure class="highlight js"><table><tr><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="string">'&#123;&#123; page.password &#125;&#125;'</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (prompt(<span class="string">'请输入文章密码'</span>) !== <span class="string">'&#123;&#123; page.password &#125;&#125;'</span>) &#123;</div><div class="line">                alert(<span class="string">'密码错误！'</span>);</div><div class="line">                <span class="keyword">if</span> (history.length === <span class="number">1</span>) &#123;</div><div class="line">                    location.replace(<span class="string">"https://chenjiabing666.github.io/"</span>); <span class="comment">// 这里替换成你的首页</span></div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    history.back();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;)();</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>然后在文章的的<code>MD</code>文件上方添加一个<code>password</code>，如下：<br><figure class="highlight md"><table><tr><td class="code"><pre><div class="line">---</div><div class="line">title: Spring Boot 与多数据源的那点事儿~</div><div class="line">date: 2020-05-22 22:45:48</div><div class="line">tags: Spring Boot进阶</div><div class="line">categories: Spring Boot</div><div class="line">top: 100</div><div class="line"><span class="section">password: 123456</span></div><div class="line">---</div></pre></td></tr></table></figure></p>
<p>全部配置完成后，这篇文章必须输入密码<code>123456</code>才能访问。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了<code>Next</code>主题美化的一些方法，关于Hexo博客搭建的教程网上很多，有不会的可以去网上搜搜教程。</p>
<p>作者的博客并没有设置单独的域名，完全是搭建的在<code>Github</code>上的，个人觉得没必要一个单独的域名，完全是自己的学习以及工作心得，因此没搞这些，不喜勿喷，哈哈………</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png" alt=""></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>接口幂等性如何设计？</title>
    <url>/2020/04/01/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>现在这个时代大家可能最关心的就是钱了，那么有没有想过你银行转账给你没有一次是转多的，要么失败，要么成功，为什么不能失误一下多转一笔呢？醒醒吧年轻人，别做梦了，做银行的能那么傻x吗？</li>
<li>今天我们就来谈一谈为什么银行转账不能多给我转一笔？关乎到钱的问题，小伙伴们打起精神！！！</li>
<li>要想要理解上述的疑惑，不得不提的一个概念就是幂等性，至于什么是幂等性，如何通过代码实现幂等性，下面将会详细讲述。</li>
</ul>
<h2 id="什么是幂等性"><a href="#什么是幂等性" class="headerlink" title="什么是幂等性"></a>什么是幂等性</h2><ul>
<li>所谓幂等性通俗的将就是一次请求和多次请求同一个资源产生相同的副作用。用数学语言表达就是<code>f(x)=f(f(x))</code>。</li>
<li>维基百科的幂等性定义如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。</div><div class="line">在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“setTrue()”函数就是一个幂等函数,无论多次执行，其结果都是一样的，更复杂的操作幂等保证是利用唯一交易号(流水号)实现.</div></pre></td></tr></table></figure>
<h2 id="为什么需要幂等性"><a href="#为什么需要幂等性" class="headerlink" title="为什么需要幂等性"></a>为什么需要幂等性</h2><ul>
<li>在系统高并发的环境下，很有可能因为网络，阻塞等等问题导致客户端或者调用方并不能及时的收到服务端的反馈甚至是调用超时的问题。总之，就是请求方调用了你的服务，但是没有收到任何的信息，完全懵逼的状态。比如订单的问题，可能会遇到如下的几个问题：</li>
</ul>
<ol>
<li>创建订单时，第一次调用服务超时，再次调用是否产生两笔订单？</li>
<li>订单创建成功去减库存时，第一次减库存超时，是否会多扣一次？</li>
<li>订单支付时，服务端扣钱成功，但是接口反馈超时，此时再次调用支付，是否会多扣一笔呢？</li>
</ol>
<ul>
<li>作为消费者，前两种能接受，第三种情况就MMP了，哈哈哈！！！这种情况一般有如下两种解决方式</li>
</ul>
<ol>
<li>服务方提供一个查询操作是否成功的api，第一次超时之后，调用方调用查询接口，如果查到了就走成功的流程，失败了就走失败的流程。</li>
<li>另一种就是服务方需要使用幂等的方式保证一次和多次的请求结果一致。</li>
</ol>
<h2 id="HTTP的幂等性"><a href="#HTTP的幂等性" class="headerlink" title="HTTP的幂等性"></a>HTTP的幂等性</h2><ul>
<li>GET：只是获取资源，对资源本身没有任何副作用，天然的幂等性。</li>
<li>HEAD：本质上和GET一样，获取头信息，主要是探活的作用，具有幂等性。</li>
<li>OPTIONS：获取当前URL所支持的方法，因此也是具有幂等性的。</li>
<li>DELETE：用于删除资源，有副作用，但是它应该满足幂等性，比如根据id删除某一个资源，调用方可以调用N次而不用担心引起的错误（根据业务需求而变）。</li>
<li>PUT：用于更新资源，有副作用，但是它应该满足幂等性，比如根据id更新数据，调用多次和N次的作用是相同的（根据业务需求而变）。</li>
<li>POST：用于添加资源，多次提交很可能产生副作用，比如订单提交，多次提交很可能产生多笔订单。</li>
</ul>
<h2 id="幂等性的实现方式"><a href="#幂等性的实现方式" class="headerlink" title="幂等性的实现方式"></a>幂等性的实现方式</h2><ul>
<li>对于客户端交互的接口，可以在前端拦截一部分，例如防止表单重复提交，按钮置灰，隐藏，不可点击等方式。但是前端进行拦截器显然是针对普通用户，懂点技术的都可以模拟请求调用接口，所以后端幂等性很重要。</li>
<li>后端的幂等性如何实现？将会从以下几个方面介绍。</li>
</ul>
<h3 id="数据库去重表"><a href="#数据库去重表" class="headerlink" title="数据库去重表"></a>数据库去重表</h3><ul>
<li>在往数据库中插入数据的时候，利用数据库唯一索引特性，保证数据唯一。比如订单的流水号，也可以是多个字段的组合。</li>
<li>实现比较简单，读者可以自己实现看看，这里不再提供demo了。</li>
</ul>
<h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><ul>
<li>很多业务中多有多个状态，比如订单的状态有提交、待支付、已支付、取消、退款等等状态。后端可以根据不同的状态去保证幂等性，比如在退款的时候，一定要保证这笔订单是已支付的状态。</li>
<li>业务中常常出现，读者可以自己实现看看，不再提供demo。</li>
</ul>
<h3 id="TOKEN机制"><a href="#TOKEN机制" class="headerlink" title="TOKEN机制"></a>TOKEN机制</h3><ul>
<li>针对客户端连续点击或者调用方的超时重试等情况，例如提交订单，此种操作就可以用Token的机制实现防止重复提交。</li>
<li>TOKEN机制如何实现？简单的说就是调用方在调用接口的时候先向后端请求一个全局ID（TOKEN），请求的时候携带这个全局ID一起请求，后端需要对这个全局ID校验来保证幂等操作，流程如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/repeat/1.png" alt=""></p>
<ul>
<li>主要的流程步骤如下：<ul>
<li>客户端先发送获取token的请求，服务端会生成一个全局唯一的ID保存在redis中，同时把这个ID返回给客户端。</li>
<li>客户端调用业务请求的时候必须携带这个token，一般放在请求头上。</li>
<li>服务端会校验这个Token，如果校验成功，则执行业务。</li>
<li>如果校验失败，则表示重复操作，直接返回指定的结果给客户端。</li>
</ul>
</li>
<li>通过以上的流程分析，唯一的重点就是这个全局唯一ID如何生成，在分布式服务中往往都会有一个生成全局ID的服务来保证ID的唯一性，但是工程量和实现难度比较大，UUID的数据量相对有些大，此处陈某选择的是雪花算法生成全局唯一ID，不了解雪花算法的读者下一篇文章会着重介绍。</li>
</ul>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul>
<li>陈某选择的环境是SpringBoot+Redis单机环境+注解+拦截器的方式实现，只是演示一下思想，具体的代码可以参照实现。</li>
<li>redis如何实现，获取Token接口将全局唯一Id存入Redis（一定要设置失效时间，根据业务需求），业务请求的时候直接从redis中删除，根据delete的返回值判断，返回true表示第一次请求，返回false表示重复请求。代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenServiceImpl</span> <span class="keyword">implements</span> <span class="title">TokenService</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getToken</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//获取全局唯一id</span></div><div class="line">        <span class="keyword">long</span> nextId = SnowflakeUtil.nextId();</div><div class="line">        <span class="comment">//存入redis，设置10分钟失效</span></div><div class="line">        stringRedisTemplate.opsForValue().set(String.valueOf(nextId), UUID.randomUUID().toString(),<span class="number">10</span>, TimeUnit.MINUTES);</div><div class="line">        <span class="keyword">return</span> String.valueOf(nextId);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">    * 删除记录，true表示第一次提交，false重复提交</div><div class="line">    */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">checkToken</span><span class="params">(String token)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> stringRedisTemplate.delete(token);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>注解的实现如下，标注在controller类上表示当前类上全部接口都做幂等，标注单个方法上，表示单个接口做幂等操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Description</span> 幂等操作的注解</div><div class="line"> * <span class="doctag">@Author</span> CJB</div><div class="line"> * <span class="doctag">@Date</span> 2020/3/25 10:19</div><div class="line"> */</div><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RepeatLimiter &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>请求头的拦截器，用于提取请求头和校验请求头，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Description</span> 获取请求头的信息，具体校验逻辑读者自己实现</div><div class="line"> * <span class="doctag">@Author</span> CJB</div><div class="line"> * <span class="doctag">@Date</span> 2020/3/25 11:09</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderIntercept</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//获取token</span></div><div class="line">        String token = request.getHeader(HeaderConstant.TOKEN);</div><div class="line">        <span class="comment">//校验逻辑</span></div><div class="line">        <span class="keyword">if</span> (!validToken(token))</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TokenInvalidException(<span class="string">"TOKEN失效"</span>);</div><div class="line">        <span class="comment">//获取其他的参数.....</span></div><div class="line">        RequestHeader header = RequestHeader.builder()</div><div class="line">                .token(token)</div><div class="line">                .build();</div><div class="line">        <span class="comment">//放入request中</span></div><div class="line">        request.setAttribute(HeaderConstant.HEADER_INFO,header);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 校验token，逻辑自己实现</div><div class="line">     * <span class="doctag">@param</span> token</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validToken</span><span class="params">(String token)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> Boolean.TRUE;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>保证幂等性的拦截器，直接从redis中删除token，成功则第一次提交，不成功则重复提交。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepeatIntercept</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> TokenService tokenService;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> HandlerMethod)&#123;</div><div class="line">            <span class="comment">//获取方法上的参数</span></div><div class="line">            RepeatLimiter repeatLimiter = AnnotationUtils.findAnnotation(((HandlerMethod) handler).getMethod(), RepeatLimiter.class);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (Objects.isNull(repeatLimiter))&#123;</div><div class="line">                <span class="comment">//获取controller类上注解</span></div><div class="line">                repeatLimiter=AnnotationUtils.findAnnotation(((HandlerMethod) handler).getBean().getClass(),RepeatLimiter.class);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//使用注解，需要拦截验证</span></div><div class="line">            <span class="keyword">if</span> (Objects.nonNull(repeatLimiter))&#123;</div><div class="line">                <span class="comment">//获取全局token，表单提交的唯一id</span></div><div class="line">                RequestHeader info = RequestContextUtils.getHeaderInfo();</div><div class="line"></div><div class="line">                <span class="comment">//没有携带token，抛异常，这里的异常需要全局捕获</span></div><div class="line">                <span class="keyword">if</span> (StringUtils.isEmpty(info.getToken()))</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RepeatException();</div><div class="line"></div><div class="line">                <span class="comment">//校验token</span></div><div class="line">                Boolean flag = tokenService.checkToken(info.getToken());</div><div class="line"></div><div class="line">                <span class="comment">//删除失败，表示</span></div><div class="line">                <span class="keyword">if</span> (Boolean.FALSE.equals(flag))</div><div class="line">                    <span class="comment">//抛出重复提交的异常</span></div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RepeatException();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>接口幂等实现，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/order"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> OrderService orderService;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 下单</div><div class="line">     * <span class="doctag">@param</span> order</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@PostMapping</span></div><div class="line">    <span class="meta">@RepeatLimiter</span>  <span class="comment">//幂等性保证</span></div><div class="line">    <span class="function"><span class="keyword">public</span> CommenResult <span class="title">add</span><span class="params">(@RequestBody Order order)</span></span>&#123;</div><div class="line">        orderService.save(order);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommenResult(<span class="string">"200"</span>,<span class="string">"下单成功"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><ul>
<li>发送getToken的请求获取Token</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/repeat/2.png" alt=""></p>
<ul>
<li>携带Token下单第一次：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/repeat/3.png" alt=""></p>
<ul>
<li>第二次下单：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/repeat/4.png" alt=""></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐三款插件，让你玩转Github</title>
    <url>/2020/11/03/%E6%8E%A8%E8%8D%90%E4%B8%89%E6%AC%BE%E6%8F%92%E4%BB%B6%EF%BC%8C%E8%AE%A9%E4%BD%A0%E7%8E%A9%E8%BD%ACGithub/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为<code>Github</code>的常客，真的是无法忍受那个速度，加载慢，下载慢，<code>clone</code>慢，总之慢慢慢……</p>
<p>除了慢，还有很多文件夹，层层包裹，你不觉得难受吗？</p>
<p>今天，作者推荐三个<code>Chrome</code>插件，让你喜欢上<code>Github</code>。</p>
<a id="more"></a>
<h2 id="Octotree"><a href="#Octotree" class="headerlink" title="Octotree"></a>Octotree</h2><p><code>Octotree</code>这个插件能够为Github生成一个文件菜单树，类似IDEA目录结构，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Github%E6%8F%92%E4%BB%B6/1.png" alt="1"></p>
<p>那么这个插件如何安装呢？其实很简单，如果你的电脑可以翻墙，只需要在谷歌的应用商店下载即可。</p>
<p>但是，很多朋友没办法翻墙，只需要下载一个离线的插件包（<code>octotree-chrome插件.crx</code>），然后拖到谷歌的<code>扩展程序</code>中（<code>chrome://extensions/</code>）。</p>
<blockquote>
<p>离线下载地址：<a href="https://gitee.com/chenjiabing666/BlogImage/raw/master/Github%E6%8F%92%E4%BB%B6/Github%E5%8A%A0%E9%80%9F.crx" target="_blank" rel="external">Octotree下载</a></p>
</blockquote>
<p>安装完成之后，在Github页面按住<code>CRTL+SHITF+S</code>快捷键则会出现文档菜单。</p>
<h2 id="Github加速"><a href="#Github加速" class="headerlink" title="Github加速"></a>Github加速</h2><p>Github加速这款插件能够显著提高<code>git clone</code>和下载打包文件的速度：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Github%E6%8F%92%E4%BB%B6/2.png" alt=""></p>
<p>安装成功后，会在Github页面出现以下界面：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Github%E6%8F%92%E4%BB%B6/3.png" alt=""></p>
<p>可以直接点击<code>加速克隆和下载</code>按钮，选择加速之后的<code>URL</code>进行下载。</p>
<p>安装方式同样有两种，一种是谷歌应用商店搜索安装（需要翻墙），另外一种则是下载离线安装包。</p>
<blockquote>
<p>离线下载地址：<a href="https://gitee.com/chenjiabing666/BlogImage/raw/master/Github%E6%8F%92%E4%BB%B6/octotree-chrome%E6%8F%92%E4%BB%B6.crx" target="_blank" rel="external">Github加速下载</a></p>
</blockquote>
<h2 id="Github-Downloader"><a href="#Github-Downloader" class="headerlink" title="Github Downloader"></a>Github Downloader</h2><p>一款很爽的插件，能够下载Github中的单个文件，没安装这个插件之前，只能先<code>clone</code>全部，安装这个插件之后，在每个文件上方都有一个<code>Download</code>按钮，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Github%E6%8F%92%E4%BB%B6/4.png" alt=""></p>
<p>下载方式也是有两种，可惜我没找到离线包，所有只能翻墙安装了。</p>
<blockquote>
<p>安装地址：<a href="https://chrome.google.com/webstore/detail/github-downloader/jplmabjbdhggnlhndkdfciacklbjcfel?hl=zh-CN" target="_blank" rel="external">Github Downloader</a></p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>三款插件的作者用了很久，公司同事都在使用，喜欢的可以装下尝尝鲜。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png" alt=""></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>优质资源</tag>
      </tags>
  </entry>
  <entry>
    <title>接口限流算法</title>
    <url>/2020/03/23/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>前几天和一个朋友讨论了他们公司的系统问题，传统的单体应用，集群部署，他说近期服务的并发量可能会出现瞬时增加的风险，虽然部署了集群，但是通过压测后发现请求延迟仍然是很大，想问问我有什么改进的地方。我沉思了一会，现在去改架构显然是不可能的，于是我给出了一个建议，让他去做个接口限流，这样能够保证瞬时并发量飙高也不会出现请求延迟的问题，用户的体验度也会上去。</li>
<li>至于什么是接口限流？怎么实现接口限流？如何实现单机应用的限流？如何实现分布式应用的限流？本篇文章将会详细阐述。<a id="more"></a>
</li>
</ul>
<h2 id="限流的常见几种算法"><a href="#限流的常见几种算法" class="headerlink" title="限流的常见几种算法"></a>限流的常见几种算法</h2><ul>
<li>常见的限流算法有很多，但是最常用的算法无非以下四种。</li>
</ul>
<h3 id="固定窗口计数器"><a href="#固定窗口计数器" class="headerlink" title="固定窗口计数器"></a>固定窗口计数器</h3><p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/8ded7a2b90e1482093f92fff555b3615.png" alt=""></p>
<ul>
<li>固定算法的概念如下</li>
</ul>
<ol>
<li>将时间划分为多个窗口</li>
<li>在每个窗口内每有一次请求就将计数器加一</li>
<li>如果计数器超过了限制数量，则本窗口内所有的请求都被丢弃当时间到达下一个窗口时，计数器重置。</li>
</ol>
<ul>
<li>固定窗口计数器是最为简单的算法，但这个算法有时会让通过请求量允许为限制的两倍。考虑如下情况：限制 1 秒内最多通过 5 个请求，在第一个窗口的最后半秒内通过了 5 个请求，第二个窗口的前半秒内又通过了 5 个请求。这样看来就是在 1 秒内通过了 10 个请求。 </li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/4d03e8e43a8edc3f32376d90e52b85f4.png" alt=""></p>
<h3 id="滑动窗口计数器"><a href="#滑动窗口计数器" class="headerlink" title="滑动窗口计数器"></a>滑动窗口计数器</h3><p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/ae4d3cd14efb8dc7046d691c90264715.png" alt=""></p>
<ul>
<li>滑动窗口计数器算法概念如下：</li>
</ul>
<ol>
<li>将时间划分为多个区间；</li>
<li>在每个区间内每有一次请求就将计数器加一维持一个时间窗口，占据多个区间；</li>
<li>每经过一个区间的时间，则抛弃最老的一个区间，并纳入最新的一个区间；</li>
<li>如果当前窗口内区间的请求计数总和超过了限制数量，则本窗口内所有的请求都被丢弃。</li>
</ol>
<ul>
<li>滑动窗口计数器是通过将窗口再细分，并且按照时间 “ 滑动 “，这种算法避免了固定窗口计数器带来的双倍突发请求，但时间区间的精度越高，算法所需的空间容量就越大。</li>
</ul>
<h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/75938d1010138ce66e38c6ed0392f103.png" alt=""></p>
<ul>
<li>漏桶算法概念如下：</li>
</ul>
<ol>
<li>将每个请求视作 “ 水滴 “ 放入 “ 漏桶 “ 进行存储；</li>
<li>“漏桶 “ 以固定速率向外 “ 漏 “ 出请求来执行如果 “ 漏桶 “ 空了则停止 “ 漏水”；</li>
<li>如果 “ 漏桶 “ 满了则多余的 “ 水滴 “ 会被直接丢弃。</li>
</ol>
<ul>
<li>漏桶算法多使用队列实现，服务的请求会存到队列中，服务的提供方则按照固定的速率从队列中取出请求并执行，过多的请求则放在队列中排队或直接拒绝。</li>
<li>漏桶算法的缺陷也很明显，当短时间内有大量的突发请求时，即便此时服务器没有任何负载，每个请求也都得在队列中等待一段时间才能被响应。</li>
</ul>
<h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/eca0e5eaa35dac938c673fecf2ec9a93.png" alt=""></p>
<ul>
<li>令牌桶算法概念如下：</li>
</ul>
<ol>
<li>令牌以固定速率生成。</li>
<li>生成的令牌放入令牌桶中存放，如果令牌桶满了则多余的令牌会直接丢弃，当请求到达时，会尝试从令牌桶中取令牌，取到了令牌的请求可以执行。</li>
<li>如果桶空了，那么尝试取令牌的请求会被直接丢弃。</li>
</ol>
<ul>
<li>令牌桶算法既能够将所有的请求平均分布到时间区间内，又能接受服务器能够承受范围内的突发请求，因此是目前使用较为广泛的一种限流算法。 </li>
</ul>
<h2 id="单体应用实现"><a href="#单体应用实现" class="headerlink" title="单体应用实现"></a>单体应用实现</h2><ul>
<li>在传统的单体应用中限流只需要考虑到多线程即可，使用Google开源工具类guava即可。其中有一个RateLimiter专门实现了单体应用的限流，使用的是令牌桶算法。</li>
<li>单体应用的限流不是本文的重点，官网上现成的API，读者自己去看看即可，这里不再详细解释。</li>
</ul>
<h2 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h2><ul>
<li>分布式限流和熔断现在有很多的现成的工具，比如Hystrix，Sentinel  等，但是还是有些企业不引用外来类库，因此就需要自己实现。</li>
<li>Redis作为单线程多路复用的特性，很显然能够胜任这项任务。</li>
</ul>
<h3 id="Redis如何实现"><a href="#Redis如何实现" class="headerlink" title="Redis如何实现"></a>Redis如何实现</h3><ul>
<li>使用令牌桶的算法实现，根据前面的介绍，我们了解到令牌桶算法的基础需要两个个变量，分别是桶容量，产生令牌的速率。</li>
<li>这里我们实现的就是每秒产生的速率加上一个桶容量。但是如何实现呢？这里有几个问题。</li>
<li><p>需要保存什么数据在redis中？</p>
<ul>
<li>当前桶的容量，最新的请求时间</li>
</ul>
</li>
<li>以什么数据结构存储？<ul>
<li>因为是针对接口限流，每个接口的业务逻辑不同，对并发的处理也是不同，因此要细化到每个接口的限流，此时我们选用HashMap的结构，hashKey是接口的唯一id，可以是请求的uri，里面的分别存储当前桶的容量和最新的请求时间。</li>
</ul>
</li>
<li>如何计算需要放令牌？<ul>
<li>根据redis保存的上次的请求时间和当前时间比较，如果相差大于的<strong>产生令牌的时间（陈某实现的是1秒）</strong>则再次产生令牌，此时的桶容量为当前令牌+产生的令牌</li>
</ul>
</li>
<li>如何保证redis的原子性？<ul>
<li>保证redis的原子性，使用lua脚本即可解决。</li>
</ul>
</li>
<li>有了上述的几个问题，便能很容易的实现。</li>
</ul>
<h3 id="开撸"><a href="#开撸" class="headerlink" title="开撸"></a>开撸</h3><p>1、lua脚本如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><div class="line"><span class="keyword">local</span> ratelimit_info = redis.<span class="built_in">pcall</span>(<span class="string">'HMGET'</span>,KEYS[<span class="number">1</span>],<span class="string">'last_time'</span>,<span class="string">'current_token'</span>)</div><div class="line"><span class="keyword">local</span> last_time = ratelimit_info[<span class="number">1</span>]</div><div class="line"><span class="keyword">local</span> current_token = <span class="built_in">tonumber</span>(ratelimit_info[<span class="number">2</span>])</div><div class="line"><span class="keyword">local</span> max_token = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</div><div class="line"><span class="keyword">local</span> token_rate = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</div><div class="line"><span class="keyword">local</span> current_time = <span class="built_in">tonumber</span>(ARGV[<span class="number">3</span>])</div><div class="line"><span class="keyword">if</span> current_token == <span class="literal">nil</span> <span class="keyword">then</span></div><div class="line">  current_token = max_token</div><div class="line">  last_time = current_time</div><div class="line"><span class="keyword">else</span></div><div class="line">  <span class="keyword">local</span> past_time = current_time-last_time</div><div class="line">  </div><div class="line">  <span class="keyword">if</span> past_time&gt;<span class="number">1000</span> <span class="keyword">then</span></div><div class="line">	  current_token = current_token+token_rate</div><div class="line">	  last_time = current_time</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  ## 防止溢出</div><div class="line">  <span class="keyword">if</span> current_token&gt;max_token <span class="keyword">then</span></div><div class="line">    current_token = max_token</div><div class="line">	last_time = current_time</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="keyword">local</span> result = <span class="number">0</span></div><div class="line"><span class="keyword">if</span>(current_token&gt;<span class="number">0</span>) <span class="keyword">then</span></div><div class="line">  result = <span class="number">1</span></div><div class="line">  current_token = current_token<span class="number">-1</span></div><div class="line">  last_time = current_time</div><div class="line"><span class="keyword">end</span></div><div class="line">redis.call(<span class="string">'HMSET'</span>,KEYS[<span class="number">1</span>],<span class="string">'last_time'</span>,last_time,<span class="string">'current_token'</span>,current_token)</div><div class="line"><span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<ul>
<li>调用lua脚本出四个参数，分别是接口方法唯一id，桶容量，每秒产生令牌的数量，当前请求的时间戳。</li>
</ul>
<p>2、 SpringBoot代码实现</p>
<ul>
<li>采用Spring-data-redis实现lua脚本的执行。</li>
<li>Redis序列化配置：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * 重新注入模板</div><div class="line">    */</div><div class="line">   <span class="meta">@Bean</span>(value = <span class="string">"redisTemplate"</span>)</div><div class="line">   <span class="meta">@Primary</span></div><div class="line">   <span class="function"><span class="keyword">public</span> RedisTemplate <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span>&#123;</div><div class="line">       RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</div><div class="line">       template.setConnectionFactory(redisConnectionFactory);</div><div class="line">       ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</div><div class="line">       objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</div><div class="line">       objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</div><div class="line">       <span class="comment">//设置序列化方式，key设置string 方式，value设置成json</span></div><div class="line">       StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</div><div class="line">       Jackson2JsonRedisSerializer jsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</div><div class="line">       jsonRedisSerializer.setObjectMapper(objectMapper);</div><div class="line">       template.setEnableDefaultSerializer(<span class="keyword">false</span>);</div><div class="line">       template.setKeySerializer(stringRedisSerializer);</div><div class="line">       template.setHashKeySerializer(stringRedisSerializer);</div><div class="line">       template.setValueSerializer(jsonRedisSerializer);</div><div class="line">       template.setHashValueSerializer(jsonRedisSerializer);</div><div class="line">       <span class="keyword">return</span> template;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li>限流工具类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Description</span> 限流工具类</div><div class="line"> * <span class="doctag">@Author</span> CJB</div><div class="line"> * <span class="doctag">@Date</span> 2020/3/19 17:21</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLimiterUtils</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StringRedisTemplate stringRedisTemplate=ApplicationContextUtils.applicationContext.getBean(StringRedisTemplate.class);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * lua脚本，限流</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String TEXT=<span class="string">"local ratelimit_info = redis.pcall('HMGET',KEYS[1],'last_time','current_token')\n"</span> +</div><div class="line">            <span class="string">"local last_time = ratelimit_info[1]\n"</span> +</div><div class="line">            <span class="string">"local current_token = tonumber(ratelimit_info[2])\n"</span> +</div><div class="line">            <span class="string">"local max_token = tonumber(ARGV[1])\n"</span> +</div><div class="line">            <span class="string">"local token_rate = tonumber(ARGV[2])\n"</span> +</div><div class="line">            <span class="string">"local current_time = tonumber(ARGV[3])\n"</span> +</div><div class="line">            <span class="string">"if current_token == nil then\n"</span> +</div><div class="line">            <span class="string">"  current_token = max_token\n"</span> +</div><div class="line">            <span class="string">"  last_time = current_time\n"</span> +</div><div class="line">            <span class="string">"else\n"</span> +</div><div class="line">            <span class="string">"  local past_time = current_time-last_time\n"</span> +</div><div class="line">            <span class="string">"  \n"</span> +</div><div class="line">            <span class="string">"  if past_time&gt;1000 then\n"</span> +</div><div class="line">            <span class="string">"\t  current_token = current_token+token_rate\n"</span> +</div><div class="line">            <span class="string">"\t  last_time = current_time\n"</span> +</div><div class="line">            <span class="string">"  end\n"</span> +</div><div class="line">            <span class="string">"\n"</span> +</div><div class="line">            <span class="string">"  if current_token&gt;max_token then\n"</span> +</div><div class="line">            <span class="string">"    current_token = max_token\n"</span> +</div><div class="line">            <span class="string">"\tlast_time = current_time\n"</span> +</div><div class="line">            <span class="string">"  end\n"</span> +</div><div class="line">            <span class="string">"end\n"</span> +</div><div class="line">            <span class="string">"\n"</span> +</div><div class="line">            <span class="string">"local result = 0\n"</span> +</div><div class="line">            <span class="string">"if(current_token&gt;0) then\n"</span> +</div><div class="line">            <span class="string">"  result = 1\n"</span> +</div><div class="line">            <span class="string">"  current_token = current_token-1\n"</span> +</div><div class="line">            <span class="string">"  last_time = current_time\n"</span> +</div><div class="line">            <span class="string">"end\n"</span> +</div><div class="line">            <span class="string">"redis.call('HMSET',KEYS[1],'last_time',last_time,'current_token',current_token)\n"</span> +</div><div class="line">            <span class="string">"return result"</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取令牌</div><div class="line">     * <span class="doctag">@param</span> key 请求id</div><div class="line">     * <span class="doctag">@param</span> max 最大能同时承受多少的并发（桶容量）</div><div class="line">     * <span class="doctag">@param</span> rate  每秒生成多少的令牌</div><div class="line">     * <span class="doctag">@return</span> 获取令牌返回true，没有获取返回false</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(String key, <span class="keyword">int</span> max,<span class="keyword">int</span> rate)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; keyList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span>);</div><div class="line">        keyList.add(key);</div><div class="line">        DefaultRedisScript&lt;Long&gt; script = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;();</div><div class="line">        script.setResultType(Long.class);</div><div class="line">        script.setScriptText(TEXT);</div><div class="line">        <span class="keyword">return</span> Long.valueOf(<span class="number">1</span>).equals(stringRedisTemplate.execute(script,keyList,Integer.toString(max), Integer.toString(rate),</div><div class="line">                Long.toString(System.currentTimeMillis())));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>采用拦截器+注解的方式实现，注解如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Description</span> 限流的注解，标注在类上或者方法上。在方法上的注解会覆盖类上的注解，同<span class="doctag">@Transactional</span></div><div class="line"> * <span class="doctag">@Author</span> CJB</div><div class="line"> * <span class="doctag">@Date</span> 2020/3/20 13:36</div><div class="line"> */</div><div class="line"><span class="meta">@Inherited</span></div><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RateLimit &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 令牌桶的容量，默认100</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> <span class="keyword">default</span> 100</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 每秒钟默认产生令牌数量，默认10个</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rate</span><span class="params">()</span> <span class="keyword">default</span> 10</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>拦截器如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Description</span> 限流的拦器</div><div class="line"> * <span class="doctag">@Author</span> CJB</div><div class="line"> * <span class="doctag">@Date</span> 2020/3/19 14:34</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiterIntercept</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> HandlerMethod)&#123;</div><div class="line">            HandlerMethod handlerMethod=(HandlerMethod)handler;</div><div class="line">            Method method = handlerMethod.getMethod();</div><div class="line">            <span class="comment">/**</span></div><div class="line">             * 首先获取方法上的注解</div><div class="line">             */</div><div class="line">            RateLimit rateLimit = AnnotationUtils.findAnnotation(method, RateLimit.class);</div><div class="line">            <span class="comment">//方法上没有标注该注解，尝试获取类上的注解</span></div><div class="line">            <span class="keyword">if</span> (Objects.isNull(rateLimit))&#123;</div><div class="line">                <span class="comment">//获取类上的注解</span></div><div class="line">                rateLimit = AnnotationUtils.findAnnotation(handlerMethod.getBean().getClass(), RateLimit.class);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//没有标注注解，放行</span></div><div class="line">            <span class="keyword">if</span> (Objects.isNull(rateLimit))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">            <span class="comment">//尝试获取令牌，如果没有令牌了</span></div><div class="line">            <span class="keyword">if</span> (!RedisLimiterUtils.tryAcquire(request.getRequestURI(),rateLimit.capacity(),rateLimit.rate()))&#123;</div><div class="line">                <span class="comment">//抛出请求超时的异常</span></div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span>  TimeOutException();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>SpringBoot配置拦截器的代码就不贴了，以上就是完整的代码，至此分布式限流就完成了。</li>
</ul>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg" alt=""></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>分享几个压箱底儿的实用工具~</title>
    <url>/2020/11/07/%E6%8E%A8%E8%8D%90%E5%87%A0%E4%B8%AA%E5%8E%8B%E7%AE%B1%E5%BA%95%E5%84%BF%E7%9A%84%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>所谓工欲善其事，必先利其器，一个好的工具往往是提升工作效率的关键，今天作者分享几个工作和生活中常用的工具软件。</p>
<p>如果和你正在使用的工具重复了，请一笑置之，哈哈……</p>
<a id="more"></a>
<h2 id="X-shell"><a href="#X-shell" class="headerlink" title="X-shell"></a>X-shell</h2><p>一款<code>windows</code>下远程连接<code>Linux</code>的软件，支持文件传输、命令行操作，相对古老的<code>Putty</code>来说，界面十分美观，另外附带记忆功能，可以保存连接，不用重复输入密码。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E5%8E%8B%E7%AE%B1%E5%BA%95%E5%84%BF%E7%9A%84%E5%B7%A5%E5%85%B7/1.png" alt=""></p>
<p>不过这款软件是收费的，不差钱的支持买个正版的：<a href="https://www.netsarang.com/en/all-downloads/" title="Xshell官网地址" target="_blank" rel="external">Xshell官网地址</a>。</p>
<blockquote>
<p>免费版回复关键词<strong>Xshell</strong>获取。</p>
</blockquote>
<h2 id="FileZilla"><a href="#FileZilla" class="headerlink" title="FileZilla"></a>FileZilla</h2><p><code>FileZilla</code>是一个快速，实用多功能和界面直观的<code>FTP</code>客户端。最常用的就是与服务器之间进行文件传输，提供一个可视化的界面，非常方便。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E5%8E%8B%E7%AE%B1%E5%BA%95%E5%84%BF%E7%9A%84%E5%B7%A5%E5%85%B7/10.png" alt=""></p>
<blockquote>
<p><a href="https://www.filezilla.cn/download/client" title="FileZilla官网地址" target="_blank" rel="external">FileZilla官网地址</a></p>
</blockquote>
<h2 id="Navicat"><a href="#Navicat" class="headerlink" title="Navicat"></a>Navicat</h2><p>数据库的可视化工具，支持多种数据库，包括<code>MySQL</code>、<code>Oracle</code>、<code>SQL server</code>等。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E5%8E%8B%E7%AE%B1%E5%BA%95%E5%84%BF%E7%9A%84%E5%B7%A5%E5%85%B7/2.png" alt=""></p>
<p>功能虽然强大，但是需要收费，不差钱的买个正版也挺香的，<a href="www.formysql.com/xiazai.html" title="Navicat官网地址">Navicat官网地址</a>。</p>
<blockquote>
<p>免费版回复关键词<strong>Navicat12</strong>获取。</p>
</blockquote>
<h2 id="RedisDesktop"><a href="#RedisDesktop" class="headerlink" title="RedisDesktop"></a>RedisDesktop</h2><p><code>Redis</code>的可视化工具，用来管理<code>Redis</code>数据很方便，界面也很美观。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E5%8E%8B%E7%AE%B1%E5%BA%95%E5%84%BF%E7%9A%84%E5%B7%A5%E5%85%B7/3.png" alt=""></p>
<p>这款软件也是收费的，不差钱的官网下个正版，<a href="https://rdm.dev/pricing" title="RedisDesktop官网地址" target="_blank" rel="external">RedisDesktop官网地址</a>。</p>
<blockquote>
<p>免费版回复关键词<code>RedisDesktop</code></p>
</blockquote>
<h2 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h2><p>一款极简单的<code>Markdown</code>编辑器，作者也是一直在用，免费版本，界面很好看。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E5%8E%8B%E7%AE%B1%E5%BA%95%E5%84%BF%E7%9A%84%E5%B7%A5%E5%85%B7/4.png" alt=""></p>
<blockquote>
<p><a href="https://typora.io/" title="Typora官网地址" target="_blank" rel="external">Typora官网地址</a></p>
</blockquote>
<h2 id="ProcessOn"><a href="#ProcessOn" class="headerlink" title="ProcessOn"></a>ProcessOn</h2><p>个人使用最多在线作图软件，支持脑图，流程图等等，功能很强大，不过超过保存的文件<br>数量需要收费。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E5%8E%8B%E7%AE%B1%E5%BA%95%E5%84%BF%E7%9A%84%E5%B7%A5%E5%85%B7/5.png" alt=""></p>
<blockquote>
<p><a href="https://processon.com/" title="ProcessOn 官网地址" target="_blank" rel="external">ProcessOn 官网地址</a></p>
</blockquote>
<h2 id="drawio"><a href="#drawio" class="headerlink" title="drawio"></a>drawio</h2><p>一款离线专业画图工具，作者文章中很多图都是用<code>drawio</code>画的，最喜欢其中的手绘形式的主题。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E5%8E%8B%E7%AE%B1%E5%BA%95%E5%84%BF%E7%9A%84%E5%B7%A5%E5%85%B7/9.png" alt=""></p>
<blockquote>
<p><a href="https://drawio-app.com/" title="drawio官网地址" target="_blank" rel="external">drawio官网地址</a></p>
</blockquote>
<h2 id="ScreenToGif"><a href="#ScreenToGif" class="headerlink" title="ScreenToGif"></a>ScreenToGif</h2><p>一款制作<code>GIF</code>动图的软件,支持录屏制作动画，功能非常强大，作者一直在用，下面动图就是用它制作的。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E5%8E%8B%E7%AE%B1%E5%BA%95%E5%84%BF%E7%9A%84%E5%B7%A5%E5%85%B7/6.gif" alt=""></p>
<blockquote>
<p><a href="https://www.screentogif.com/" title="ScreenToGif官网地址" target="_blank" rel="external">ScreenToGif官网地址</a></p>
</blockquote>
<h2 id="everything"><a href="#everything" class="headerlink" title="everything"></a>everything</h2><p>这款软件简直是文件搜索神器，<code>windows</code>自带的搜索十分缓慢，但是<code>everything</code>是全局搜索，并且速度极快。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E5%8E%8B%E7%AE%B1%E5%BA%95%E5%84%BF%E7%9A%84%E5%B7%A5%E5%85%B7/7.png" alt=""></p>
<blockquote>
<p><a href="https://www.voidtools.com/zh-cn/downloads/" title="everything下载地址" target="_blank" rel="external">everything下载地址</a></p>
</blockquote>
<h2 id="ApiPost"><a href="#ApiPost" class="headerlink" title="ApiPost"></a>ApiPost</h2><p>类似于<code>PostMan</code>，官方称是”中国人自己的接口管理工具”，不过，确实很好用，轻量级，支持团队协作，各种操作系统都支持，怎地也要支持一把国产，哈哈…….</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E5%8E%8B%E7%AE%B1%E5%BA%95%E5%84%BF%E7%9A%84%E5%B7%A5%E5%85%B7/8.png" alt=""></p>
<blockquote>
<p><a href="https://www.apipost.cn/download.html" title="ApiPost官网地址" target="_blank" rel="external">ApiPost官网地址</a></p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上这几款软件是作者平时用的最多并且很实用的工具，大部分的估计大家都听说过。</p>
<blockquote>
<p><strong>文末留言</strong>：你有什么个人觉得比较好的工具呢，下方留言区安排上…..</p>
</blockquote>
<p>另外作者的第一本<code>PDF</code>书籍已经整理好了，由浅入深的详细介绍了<code>Mybatis</code>基础以及底层源码，有需要的朋友公众号回复关键词<code>Mybatis进阶</code>即可获取，目录如下：</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E8%BF%9B%E9%98%B6PDF/2.png" alt=""></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png" alt=""></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>破解</tag>
        <tag>优质资源</tag>
      </tags>
  </entry>
  <entry>
    <title>撸了个反代工具,可用于激活JRebel</title>
    <url>/2020/11/01/%E6%92%B8%E4%BA%86%E4%B8%AA%E5%8F%8D%E4%BB%A3%E5%B7%A5%E5%85%B7%E7%94%A8%E4%BA%8E%E6%BF%80%E6%B4%BBJRebel/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>热部署相信大家都听说过，比如<code>Spring Boot</code>中的<code>devtools</code>，但是听说过<code>JRebel</code>这个工具的却是少之又少，个人觉得作为热部署界的扛把子却鲜为人知，实在是一大憾事。</p>
<p>很早之前就有读者找我要过<code>JRebel</code>的激活方式，由于忙着专栏文章，一直没安排，今天安排上。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/JRebel%E7%A0%B4%E8%A7%A3/7.jpg" alt=""></p>
<p><code>JRebel</code>目前是收费的，但是中国有大神啊，本篇文章就介绍一下如何撸一个反向代理激活<code>JRebel</code>。</p>
<a id="more"></a>
<h2 id="为什么要自己搭建反向代理？"><a href="#为什么要自己搭建反向代理？" class="headerlink" title="为什么要自己搭建反向代理？"></a>为什么要自己搭建反向代理？</h2><p>网上有很多教程都是直接提供一个反向代理的地址，当然这些地址某些时候也是可以用的，但是这些地址也是别人搭建的反向代理，<strong>一旦别人的服务器将程序关掉了，则这个地址就失效了</strong>。</p>
<p>作为一个程序控，难道要这样依赖别人吗？显然不实际，反正搭建一个很简单，干嘛不自己动手呢？</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/JRebel%E7%A0%B4%E8%A7%A3/3.jpg" alt="真的受够了...."></p>
<h2 id="本地反向代理"><a href="#本地反向代理" class="headerlink" title="本地反向代理"></a>本地反向代理</h2><p>反向代理可以在服务器本地安装，本地安装仅仅适用于个人使用。</p>
<p>首先找到反向代理工具包<code>ReverseProxy_windows_amd64.exe</code>（文末下载），在命令行输入<code>ReverseProxy_windows_amd64.exe</code>，如果出现以下窗口则表示代理成功：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/JRebel%E7%A0%B4%E8%A7%A3/2.png" alt=""></p>
<p>默认启动的是本地<code>8888</code>端口，该命令有个参数<code>-l</code>用来指定启动的端口，如下命令使用本地的<code>9090</code>端口：<br><figure class="highlight cmd"><table><tr><td class="code"><pre><div class="line">ReverseProxy_windows_amd64.exe -l "<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">9090</span>"</div></pre></td></tr></table></figure></p>
<blockquote>
<p>此时本地代理的<code>URL</code>则是<code>http://127.0.0.1:9090</code>。</p>
</blockquote>
<p>但是要想激活<code>JRebel</code>还需一个随机<code>GUID</code>，生成网址：<code>http://www.ofmonkey.com/transfer/guid</code></p>
<blockquote>
<p>最终的激活<code>URL</code>则是<code>http://127.0.0.1:9090/guid</code></p>
</blockquote>
<p><strong>注意</strong>：此时的命令窗口不能关闭，否则代理将会关闭。不过<code>windows</code>可以配置服务器自启动，这里就不再详细介绍了，感兴趣的可以自己研究下。</p>
<h2 id="服务器反向代理【个人推荐】"><a href="#服务器反向代理【个人推荐】" class="headerlink" title="服务器反向代理【个人推荐】"></a>服务器反向代理【个人推荐】</h2><p>服务器反向代理和本地的大同小异，只不过服务器上的反向代理可以作用于的多台，更加方便而已。</p>
<p>首先找到<code>Linux</code>下的反向代理工具包<code>ReverseProxy_linux_amd64</code>，执行以下命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">./ReverseProxy_linux_amd64 &amp;</div></pre></td></tr></table></figure></p>
<p>默认代理<code>8888</code>端口，可以运行一下命令指定端口：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">./ReverseProxy_linux_amd64 -l &quot;ip:port&quot; &amp;</div></pre></td></tr></table></figure></p>
<blockquote>
<p><code>ip</code>则是服务器的IP地址，<code>port</code>则是指定的端口，<strong>注意这里一定要是开放的端口</strong>。</p>
</blockquote>
<p>运行成功后同样需要一个<code>GUID</code>，生成网址同上。</p>
<p>最终的激活<code>URL</code>则是<code>http://ip:port/guid</code>。</p>
<h2 id="IDEA安装JRebel并激活"><a href="#IDEA安装JRebel并激活" class="headerlink" title="IDEA安装JRebel并激活"></a>IDEA安装JRebel并激活</h2><p>JRebel在IDEA中提供了插件，只需要在插件市场（<code>setting-&gt;plugins</code>）搜索<code>JRebel</code>，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/JRebel%E7%A0%B4%E8%A7%A3/4.png" alt="IDEA安装JRebel"></p>
<blockquote>
<p>点击<code>install</code>安装，安装成功后重启IDEA即可。</p>
</blockquote>
<p>选择<code>help-&gt;JRebel-&gt;Activation</code>则出现激活的窗口，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/JRebel%E7%A0%B4%E8%A7%A3/5.png" alt="激活界面"></p>
<p>第一个输入框填激活的<code>URL</code>，第二个输入框填自己的<code>邮箱</code>，填完之后点击确定，则会验证激活，如果出现以下界面，则表示激活成功：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/JRebel%E7%A0%B4%E8%A7%A3/6.png" alt="激活成功"></p>
<h2 id="服务器安装JRebel并激活"><a href="#服务器安装JRebel并激活" class="headerlink" title="服务器安装JRebel并激活"></a>服务器安装JRebel并激活</h2><p>如果涉及到远程热部署的话，服务器是需要安装一个<code>JRebel</code>的，首先需要下载一个<code>JRebel</code>安装包<code>jrebel-2020.1.1-nosetup.zip</code>（文末下载），然后解压到指定的目录下。</p>
<p>这个安装包是免安装的，直接找到<code>bin</code>目录，在其下执行以下命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">./activate.sh http://ip:port/guid 你的邮箱地址</div></pre></td></tr></table></figure></p>
<blockquote>
<p><code>ip</code>则是服务器的IP地址，<code>port</code>则是反向代理的端口，默认<code>8888</code>，<code>guid</code>是生成的随机<code>uid</code>。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>JRebel</code>在热部署界有着举足轻重的地位，无论是本地热部署还是远程热部署都是开发者的一大利器。</p>
<blockquote>
<p>文中<strong>反向代理安装包</strong>、<strong>JRebel安装包</strong>在公众号回复关键词<code>JRebel</code>免费获取。</p>
</blockquote>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png" alt=""></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>破解</tag>
        <tag>优质资源</tag>
      </tags>
  </entry>
  <entry>
    <title>索引的概念和数据结构</title>
    <url>/2020/04/20/%E7%B4%A2%E5%BC%95%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<section id="nice" data-tool="mdnice编辑器" data-website="https://www.mdnice.com" style="padding: 0 10px; word-spacing: 0px; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif; line-height: 1.6; letter-spacing: .034em; color: rgb(63, 63, 63); font-size: 16px; word-break: all;"><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">前言</span><span class="suffix"></span></h2><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引是什么？有什么利弊？一旦在面试中被问道，对于新入门的小白可能是个棘手的问题。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">本篇文章将会详细讲述什么是索引、索引的优缺点、数据结构等等常见的知识。</section></li></ul><br><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">什么是索引</span><span class="suffix"></span></h2><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引就是一种的数据结构，存储表中特定列的值并对值进行排序，所以是在表的列上面创建的。索引将通过缩小一张表中需要查询的记录的数目来加快搜索的速度。如果没有索引，数据库不得不进行全表扫描。索引就好比一本书的目录，它会让你更快的找到内容。</section></li></ul><br><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">索引的优点</span><span class="suffix"></span></h2><br><ol data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以大大加快数据的检索速度，避免进行全表的数据扫描，大大减少遍历匹配的行数，这也是创建索引的最主要的原因。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</section></li></ol><br><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">索引的缺点</span><span class="suffix"></span></h2><br><ol data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p><br></section></li></ol><br><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">在哪些列建立索引</span><span class="suffix"></span></h2><br><ol data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在经常需要搜索的列上，可以加快搜索的速度；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在经常使用在<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">WHERE</code>子句中的列上面创建索引，加快条件的判断速度。</section></li></ol><br><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">不在哪些列建索引？</span><span class="suffix"></span></h2><br><ol data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">对于那些定义为<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">text</code>, <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">image</code>和<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">bit</code>数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</section></li></ol><br><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">索引的数据结构</span><span class="suffix"></span></h2><br><p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">常见的索引的数据结构有：<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">B+Tree</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Hash索引</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">FullText索引</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">R-Tree索引</code>。</p><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">Hash 索引</span><span class="suffix" style="display: none;"></span></h3><br><p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">1. 概述：</strong></p><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">MySQL 中，只有<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Memory</code>存储引擎支持<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Hash</code>索引，是<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Memory</code>表的默认索引类型。hash 索引把数据的索引以 hash 值形式组织起来，因此检索效率非常高，可以一次定位，不像<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">B-/+Tree</code>索引需要进行从根节点到叶节点的多次 IO 操作。</p><br></blockquote><br><p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">2. Hash 索引的缺点：</strong></p><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">① Hash 索引仅仅能满足等值的查询，不能满足范围查询。因为数据在经过 Hash 算法后，其大小关系就可能发生变化。<br>② Hash 索引不能被排序。同样是因为数据经过 Hash 算法后，大小关系就可能发生变化，排序是没有意义的。</p><br></blockquote><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">③ Hash 索引不能避免表数据的扫描。因为发生 Hash 碰撞时，仅仅比较 Hash 值是不够的，需要比较实际的值以判定是否符合要求。</p><br></blockquote><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">④ Hash 索引在发生大量 Hash 值相同的情况时性能不一定比 B-Tree 索引高。因为碰撞情况会导致多次的表数据的扫描，造成整体性能的低下，可以通过采用合适的 Hash 算法一定程度解决这个问题。</p><br></blockquote><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">⑤ Hash 索引不能使用部分索引键查询。因为当使用组合索引情况时，是把多个数据库列数据合并后再计算 Hash 值，所以对单独列数据计算 Hash 值是没有意义的。</p><br></blockquote><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">FullText 索引</span><span class="suffix" style="display: none;"></span></h3><br><p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">1. 概述：</strong></p><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">全文索引，目前 MySQL 中只有<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">MyISAM</code>存储引擎支持，并且只有<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">char</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">varchar</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">text</code> 类型支持。它用于替代效率较低的<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">like</code> 模糊匹配操作，而且可以通过多字段组合的全文索引一次性全模糊匹配多个字段。</p><br></blockquote><br><p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">2. 存储结构：</strong></p><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">同样使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">B-Tree</code>存放索引数据，但使用的是特定的算法，将字段数据分割后再进行索引（一般每 4 个字节一次分割），索引文件存储的是分割前的索引字符串集合，与分割后的索引信息，对应 Btree 结构的节点存储的是分割后的词信息以及它在分割前的索引字符串集合中的位置。</p><br></blockquote><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">B-/+Tree 索引</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">B+Tree 是 mysql 使用最频繁的一个索引数据结构，是 Innodb 和 Myisam 存储引擎模式的索引类型。相对 Hash 索引，B+树在查找单条记录的速度比不上 Hash 索引，但是更适合排序等操作。</section></li></ul><br><p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">1. B+Tree 索引的优点：</strong></p><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">带顺序访问指针的 B+Tree：B+Tree 所有索引数据都在叶子结点上，并且增加了顺序访问指针,每个叶子节点都有指向相邻叶子节点的指针。这样做是为了提高区间查询效率，例如查询 key 为从 18 到 49 的所有数据记录，当找到 18 后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">大大减少磁盘 I/O 读取次数。</p><br></section></li></ul><br><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">B-/+Tree 索引：</span><span class="suffix"></span></h2><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">文件系统及数据库系统普遍采用 B-/+Tree 作为索引结构：一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。这样的话，索引查找过程中就要产生磁盘 I/O 消耗，相对于内存存取，I/O 存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘 I/O 操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘 I/O 的存取次数。</section></li></ul><br><h4 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px; margin-top: 30px;"><span class="prefix" style="display: none;"></span><span class="content">局部性处理与磁盘预读</span><span class="suffix" style="display: none;"></span></h4><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘 I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高 I/O 效率。预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为 4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><br></section></li></ul><br><h4 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px; margin-top: 30px;"><span class="prefix" style="display: none;"></span><span class="content">B-/+Tree 索引的性能分析</span><span class="suffix" style="display: none;"></span></h4><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">上文说过一般使用磁盘 I/O 次数评价索引结构的优劣。先从 B-Tree 分析，根据 B-Tree 的定义，可知检索一次最多需要访问 h 个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次 I/O 就可以完全载入。为了达到这个目的，在实际实现 B-Tree 还需要使用如下技巧：</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个节点只需一次 I/O。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">B-Tree 中一次检索最多需要<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">h-1</code>次 I/O（根节点常驻内存），渐进复杂度为<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">O(h)=O(logdN)</code>。一般实际应用中，出度 d 是非常大的数字，通常超过 100，因此 h 非常小（通常不超过 3）。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">综上所述，用 B-Tree 作为索引结构效率是非常高的。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">而红黑树这种结构，h 明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的 I/O 渐进复杂度也为 O(h)，效率明显比 B-Tree 差很多。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">另外，B+Tree 更适合外存索引，原因和内节点出度 d 有关。从上面分析可以看到，d 越大索引的性能越好，而出度的上限取决于节点内 key 和 data 的大小，由于 B+Tree 内节点去掉了 data 域，因此可以拥有更大的出度，拥有更好的性能。（详细见本部分第 3 点）</p><br></section></li></ul><br><h4 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px; margin-top: 30px;"><span class="prefix" style="display: none;"></span><span class="content">B-Tree 与 B+Tree 的对比</span><span class="suffix" style="display: none;"></span></h4><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">根据 B-Tree 和 B+Tree 的结构，我们可以发现 B+树相比于 B 树，在文件系统或者数据库系统当中，更有优势，原因如下：</section></li></ul><br><p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">1. B+树的磁盘读写代价更低</strong></p><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对 B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说 I/O 读写次数也就降低了。</p><br></blockquote><br><p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">2. B+树的查询效率更加稳定</strong></p><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p><br></blockquote><br><p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">3. B+树更有利于对数据库的扫描</strong></p><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">B 树在提高了磁盘 IO 性能的同时并没有解决元素遍历的效率低下的问题，而 B+树只需要遍历叶子节点就可以解决对全部关键字信息的扫描，所以对于数据库中频繁使用的 range query，B+树有着更高的性能。</p><br></blockquote><br><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">MySQL 索引的实现</span><span class="suffix"></span></h2><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在 MySQL 中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本部分主要讨论 MyISAM 和 InnoDB 两个存储引擎的索引实现方式。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">MyISAM 索引的实现</span><span class="suffix" style="display: none;"></span></h3><br><p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">1. 主键索引</strong></p><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">MyISAM 引擎使用 B+Tree 作为索引结构，叶节点的 data 域存放的是数据记录的地址。下图是 MyISAM 索引的原理图：</p><br></blockquote><br><figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://img-blog.csdnimg.cn/20181123230136209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3NDUyMzM3MDA=,size_16,color_FFFFFF,t_70" alt="img" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"><figcaption style="margin-top: 5px; text-align: center; color: #888; display: block; font-size: 12px; font-family: PingFangSC-Light;">img</figcaption></figure><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">这里设表一共有三列，假设我们以 Col1 为主键，则上图是一个 MyISAM 表的主索引（Primary key）示意。可以看出 MyISAM 的索引文件仅仅保存数据记录的地址。</section></li></ul><br><p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">2. 辅助索引</strong></p><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">在<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">MyISAM</code>中，主索引和辅助索引（<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Secondary key</code>）在结构上没有任何区别，只是主索引要求 key 是唯一的，而辅助索引的 key 可以重复。如果我们在 Col2 上建立一个辅助索引，则此索引的结构如下图所示：</p><br></blockquote><br><figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://img-blog.csdnimg.cn/2018112323034827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3NDUyMzM3MDA=,size_16,color_FFFFFF,t_70" alt="img" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"><figcaption style="margin-top: 5px; text-align: center; color: #888; display: block; font-size: 12px; font-family: PingFangSC-Light;">img</figcaption></figure><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">同样也是一颗 B+Tree，data 域保存数据记录的地址。因此，MyISAM 中索引检索的算法为首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址，读取相应数据记录。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">MyISAM 的索引方式也叫做“非聚集”的，之所以这么称呼是为了与 InnoDB 的聚集索引区分。</p><br></section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">InnoDB 索引的实现</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">虽然 InnoDB 也使用 B+Tree 作为索引结构，但具体实现方式却不相同。</section></li></ul><br><p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">1. 主键索引</strong></p><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">与 MyISAM 第一个重大区别是 InnoDB 的数据文件本身就是索引文件。从上文知道，MyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在 InnoDB 中，表数据文件本身就是按 B+Tree 组织的一个索引结构，这棵树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。</p><br></blockquote><br><figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://img-blog.csdnimg.cn/20181123231121997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3NDUyMzM3MDA=,size_16,color_FFFFFF,t_70" alt="img" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"><figcaption style="margin-top: 5px; text-align: center; color: #888; display: block; font-size: 12px; font-family: PingFangSC-Light;">img</figcaption></figure><br><p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">上图是 InnoDB 主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为 InnoDB 的数据文件本身要按主键聚集，所以 InnoDB 要求表必须有主键（MyISAM 可以没有），如果没有显式指定，则 MySQL 系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，这个字段长度为 6 个字节，类型为长整形。</p><br><p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">2. 辅助索引</strong></p><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">第二个与 MyISAM 索引的不同是 InnoDB 的辅助索引 data 域存储相应记录主键的值而不是地址。换句话说，InnoDB 的所有辅助索引都引用主键作为 data 域。例如，下图为定义在 Col3 上的一个辅助索引：</p><br></blockquote><br><figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://img-blog.csdnimg.cn/20181123231416255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3NDUyMzM3MDA=,size_16,color_FFFFFF,t_70" alt="img" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"><figcaption style="margin-top: 5px; text-align: center; color: #888; display: block; font-size: 12px; font-family: PingFangSC-Light;">img</figcaption></figure><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">这里以英文字符的 ASCII 码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">InnoDB 表是基于聚簇索引建立的</strong>。因此 InnoDB 的索引能提供一种非常快速的主键查找性能。不过，它的辅助索引也会包含主键列，所以，如果主键使用过长的字段，将会导致其他辅助索变得更大。如果想在表上定义 、很多索引，则争取尽量把主键定义得小一些。InnoDB 不会压缩索引。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">更多内容请关注微信公众号【码猿技术专栏】<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E4%B8%83%E7%A7%92%E7%BC%96%E7%A8%8B.jpg" alt="" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></p><br></section></li></ul><br><p id="nice-suffix-juejin-container" class="nice-suffix-juejin-container" data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em; margin-top: 20px !important;">本文使用 <a href="https://mdnice.com/?from=juejin" style="word-wrap: break-word; font-weight: bold; color: #48b378; text-decoration: none; border-bottom: 1px solid #48b378;" target="_blank" rel="external">mdnice</a> 排版</p></section>]]></content>
      <categories>
        <category>数据库干货篇</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>看完这篇缓存穿透的文章，保证你能和面试官互扯！！！</title>
    <url>/2020/04/26/%E7%9C%8B%E5%AE%8C%E8%BF%99%E7%AF%87%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%9A%84%E6%96%87%E7%AB%A0%EF%BC%8C%E4%BF%9D%E8%AF%81%E4%BD%A0%E8%83%BD%E5%92%8C%E9%9D%A2%E8%AF%95%E5%AE%98%E4%BA%92%E6%89%AF%EF%BC%81%EF%BC%81%EF%BC%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>昨天有读者朋友留言，想要陈某写一篇防止缓存穿透的文章，今天特意写了一篇。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/4.png" alt=""></li>
<li>文章目录如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/%E7%9C%8B%E5%AE%8C%E8%BF%99%E7%AF%87%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%9A%84%E6%96%87%E7%AB%A0%EF%BC%8C%E4%BF%9D%E8%AF%81%E4%BD%A0%E8%83%BD%E5%92%8C%E9%9D%A2%E8%AF%95%E5%AE%98%E4%BA%92%E6%89%AF.png" alt=""></li>
</ul>
<h2 id="什么是缓存穿透？"><a href="#什么是缓存穿透？" class="headerlink" title="什么是缓存穿透？"></a>什么是缓存穿透？</h2><ul>
<li><strong>缓存穿透</strong>其实是指从缓存中没有查到数据，而不得不从后端系统（比如数据库）中查询的情况。</li>
<li>缓存毕竟是在内存中，不可能所有的数据都存储在 Redis 中，因此少量的缓存穿透是不可避免的，也是系统能够承受的，但是一旦在瞬间发生大量的缓存穿透，数据库的压力会瞬间增大，后果可想而知。</li>
<li>在开发中使用缓存的方案如下图，在查询数据库之前会先查询 Redis：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/1.png" alt="Redis缓存"></li>
<li>缓存穿透的整个过程分为如下几个步骤：<ol>
<li>应用查询缓存，<strong>缓存不命中</strong></li>
<li>DB 层查询不命中，<strong>不将空结果缓存</strong></li>
<li>返回空结果</li>
<li>下一个请求继续重复1,2,3步。</li>
</ol>
</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul>
<li>万事万物都是相生相克，既然出现了缓存穿透，就一定有避免的方案。</li>
<li>下面介绍两种缓存的方案，分别是<code>缓存空值</code>、<code>布隆过滤器</code>。</li>
</ul>
<h3 id="缓存空值"><a href="#缓存空值" class="headerlink" title="缓存空值"></a>缓存空值</h3><ul>
<li>回顾缓存穿透的定义知道，<strong>大量空值没有缓存导致重复的访问 DB 层</strong>，由此解决方案也是很明显了，直接将返回的空值也缓存即可。此时的执行步骤如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/2.png" alt="缓存空值"></li>
<li>如上图所示，如果缓存不命中，查询 DB 层之后，直接将空值缓存在 Redis 中。伪代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Object nullValue = <span class="keyword">new</span> Object();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  Object valueFromDB = getFromDB(uid); <span class="comment">//从数据库中查询数据</span></div><div class="line">  <span class="keyword">if</span> (valueFromDB == <span class="keyword">null</span>) &#123;</div><div class="line">    cache.set(uid, nullValue, <span class="number">10</span>);   <span class="comment">//如果从数据库中查询到空值，就把空值写入缓存，设置较短的超时时间</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    cache.set(uid, valueFromDB, <span class="number">1000</span>);</div><div class="line">  &#125;</div><div class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</div><div class="line">  <span class="comment">// 出现异常也要写入缓存</span></div><div class="line">  cache.set(uid, nullValue, <span class="number">10</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>通过伪代码可以很清楚的了解了缓存空值的流程，但是需要注意以下问题：<ul>
<li><strong>缓存一定要设置过期时间</strong>：因为空值并不是准确的业务数据，并且会占用缓存空间，所以要给空值加上一个过期时间，使得能够在短期之内被淘汰。但是随之而来的一个问题就是在一定的时间窗口内缓存的数据和实际数据不一致，比如设置 10 秒钟过期时间，但是在这 10 秒之内业务又写入了数据，那么返回就不应该为空值了，所以还要考虑数据一致的问题，解决方法很简单，利用消息系统或者主动更新的方式清除掉缓存中的数据即可。</li>
</ul>
</li>
</ul>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><ul>
<li>1970 年布隆提出了一种布隆过滤器的算法，用来判断一个元素是否在一个集合中。这种算法由一个二进制数组和一个 Hash 算法组成。</li>
<li>具体的算法思想这里不再详细解释了，如有不了解的可以看陈某上一篇文章<a href="https://mp.weixin.qq.com/s/Vo935pCXH0aPgG20f1ppEg" target="_blank" rel="external">大白话布隆过滤器，又能和面试官扯皮了~</a>。</li>
<li>解决缓存穿透的大致思想：<strong>在访问缓存层和存储层之前，可以通过定时任务或者系统任务来初始化布隆过滤器，将存在的 key 用布隆过滤器提前保存起来，做第一层的拦截</strong>。例如：一个推荐系统有 4 亿个用户 id， 每个小时算法工程师会根据每个用户之前历史行为计算出推荐数据放到存储层中， 但是最新的用户由于没有历史行为， 就会发生缓存穿透的行为， 为此可以将所有推荐数据的用户做成布隆过滤器。 如果布隆过滤器认为该用户 id 不存在， 那么就不会访问存储层， 在一定程度保护了存储层。此时的结构如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/6.png" alt="布隆过滤器"></li>
<li>当然布隆过滤器的<strong>假阳性</strong>的存在导致了误判率，但是我们可以尽量的降低误判率，一个解决方案就是：使用多个 Hash 算法为元素计算出多个 Hash 值，只有所有 Hash 值对应的数组中的值都为 1 时，才会认为这个元素在集合中。</li>
<li>这种方法适用于<code>数据命中不高</code>、 <code>数据相对固定</code>、 <code>实时性低</code>（通常是<code>数据 集较大</code>）的应用场景，代码维护较为复杂，但是缓存空间占用少。为什么呢？因为布隆过滤器不支持删除元素，一旦数据变化，并不能及时的更新布隆过滤器。</li>
</ul>
<h2 id="两种方案对比"><a href="#两种方案对比" class="headerlink" title="两种方案对比"></a>两种方案对比</h2><ul>
<li>两种方案各有优缺点，具体使用哪种方案还是要根据业务场景和系统体量来定。具体的区别如下表：</li>
</ul>
<table>
<thead>
<tr>
<th>方案</th>
<th>适用场景</th>
<th>维护成本</th>
</tr>
</thead>
<tbody>
<tr>
<td>缓存对象</td>
<td>1. 数据命中不高 2. 数据频繁变化，实时性高</td>
<td>代码维护点单、需要过多的缓存空间，数据一致性需要自己实现</td>
</tr>
<tr>
<td>布隆过滤器</td>
<td>1. 数据命中不高 2.数据相对固定，实时性低</td>
<td>代码维护复杂、缓存空间占用少</td>
</tr>
</tbody>
</table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>至此，如何解决缓存穿透的问题已经介绍完了，觉得写得不错的，有所收获的朋友，点点在看，分享关注一波。</li>
</ul>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>线上Bug无法复现怎么办？老司机教你一招，SpringBoot远程调试不用愁！</title>
    <url>/2020/04/28/%E7%BA%BF%E4%B8%8ABug%E6%97%A0%E6%B3%95%E5%A4%8D%E7%8E%B0%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F%E8%80%81%E5%8F%B8%E6%9C%BA%E6%95%99%E4%BD%A0%E4%B8%80%E6%8B%9B%EF%BC%8CSpringBoot%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E4%B8%8D%E7%94%A8%E6%84%81%EF%BC%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>在部署线上项目时，相信大家都会遇到一个问题，线上的 Bug 但是在本地不会复现，多么无奈。</li>
<li>此时最常用的就是取到前端传递的数据用接口测试工具测试，比如 POSTMAN，复杂不，难受不？</li>
<li>今天陈某教你一招，让你轻松调试线上的 Bug。文章目录如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/7.png" alt=""></li>
</ul>
<h2 id="什么是-JPDA？"><a href="#什么是-JPDA？" class="headerlink" title="什么是 JPDA？"></a>什么是 JPDA？</h2><ul>
<li><p><code>JPDA</code>(Java Platform Debugger Architecture)，即 Java 平台调试体系，具体结构图如下图所示。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/1.png" alt=""></p>
</li>
<li><p>其中实现调试功能的主要协议是<code>JDWP</code>协议，在 <code>Java SE 5</code> 以前版本，JVM 端的实现接口是 <code>JVMPI</code>(Java Virtual Machine Profiler Interface)，而在 <code>Java SE 5</code> 及以后版本，使用 <code>JVMTI</code>(Java Virtual Machine Tool Interface) 来替代 JVMPI。</p>
</li>
<li>因此，如果使用 Java SE 5 之前版本，使用调试功能的命令为：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">java -Xdebug -Xrunjdwp:...</div></pre></td></tr></table></figure>
<ul>
<li>而 <code>Java SE 5</code> 及之后版本，使用调试功能的命令为：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">java -agentlib:jdwp=...</div></pre></td></tr></table></figure>
<h2 id="调试命令"><a href="#调试命令" class="headerlink" title="调试命令"></a>调试命令</h2><ul>
<li>现在开发中最常见的一条远程调试的的命令如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=<span class="number">9091</span> -jar xxx.jar</div></pre></td></tr></table></figure>
<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><ul>
<li>基于前面的调试命令，我们来分析一下基本的参数代表什么意思。</li>
</ul>
<h3 id="transport"><a href="#transport" class="headerlink" title="transport"></a>transport</h3><ul>
<li>指定运行的被调试应用和调试者之间的通信协议，它由几个可选值：<ol>
<li><code>dt_socket</code>：主要的方式，采用<code>socket</code>方式连接。</li>
<li><code>dt_shmem</code>：采用共享内存方式连接，仅支持 Windows 平台。</li>
</ol>
</li>
</ul>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><ul>
<li>指定当前应用作为调试服务端还是客户端，默认为<code>n</code>。</li>
<li>如果你想将当前应用作为被调试应用，设置该值为 <code>y</code>,如果你想将当前应用作为客户端，作为调试的发起者，设置该值为<code>n</code>。</li>
</ul>
<h3 id="suspend"><a href="#suspend" class="headerlink" title="suspend"></a>suspend</h3><ul>
<li>当前应用启动后，是否阻塞应用直到被连接，默认值为 <code>y</code>。</li>
<li>在大部分的应用场景，这个值为 <code>n</code>，即不需要应用阻塞等待连接。一个可能为 <code>y</code>的应用场景是，你的程序在启动时出现了一个故障，为了调试，必须等到调试方连接上来后程序再启动。</li>
</ul>
<h3 id="address"><a href="#address" class="headerlink" title="address"></a>address</h3><ul>
<li>暴露的调试连接端口，默认值为 <code>8000</code>。</li>
<li><strong>此端口一定不能与项目端口重复，且必须是服务器开放的端口。</strong></li>
</ul>
<h3 id="onthrow"><a href="#onthrow" class="headerlink" title="onthrow"></a>onthrow</h3><ul>
<li>当程序抛出设定异常时，中断调试。</li>
</ul>
<h3 id="onuncaught"><a href="#onuncaught" class="headerlink" title="onuncaught"></a>onuncaught</h3><ul>
<li>当程序抛出未捕获异常时，是否中断调试，默认值为 n。</li>
</ul>
<h3 id="launch"><a href="#launch" class="headerlink" title="launch"></a>launch</h3><ul>
<li>当调试中断时，执行的程序。</li>
</ul>
<h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><ul>
<li>该参数限定为<code>java -agentlib:jdwp=…</code>可用，单位为毫秒<code>ms</code>。</li>
<li>当 <code>suspend = y</code> 时，该值表示等待连接的超时；当 <code>suspend = n</code> 时，该值表示连接后的使用超时。</li>
</ul>
<h2 id="参考命令"><a href="#参考命令" class="headerlink" title="参考命令"></a>参考命令</h2><ol>
<li><p><code>-agentlib:jdwp=transport=dt_socket,server=y,address=8000</code>：以 Socket 方式监听 8000 端口，程序启动阻塞（suspend 的默认值为 y）直到被连接。</p>
</li>
<li><p><code>-agentlib:jdwp=transport=dt_socket,server=y,address=localhost:8000,timeout=5000</code>：以 Socket 方式监听 8000 端口，当程序启动后 5 秒无调试者连接的话终止，程序启动阻塞（suspend 的默认值为 y）直到被连接。</p>
</li>
<li><p><code>-agentlib:jdwp=transport=dt_shmem,server=y,suspend=n</code>：选择可用的共享内存连接地址并使用 stdout 打印，程序启动不阻塞。</p>
</li>
<li><p><code>-agentlib:jdwp=transport=dt_socket,address=myhost:8000</code>：以 socket 方式连接到 <code>myhost:8000</code>上的调试程序，在连接成功前启动阻塞。</p>
</li>
<li><p><code>-agentlib:jdwp=transport=dt_socket,server=y,address=8000,onthrow=java.io.IOException,launch=/usr/local/bin/debugstub</code>：以 Socket 方式监听 8000 端口，程序启动阻塞（suspend 的默认值为 y）直到被连接。当抛出 IOException 时中断调试，转而执行 <code>usr/local/bin/debugstub</code>程序。</p>
</li>
</ol>
<h3 id="IDEA-远程调试示例"><a href="#IDEA-远程调试示例" class="headerlink" title="IDEA 远程调试示例"></a>IDEA 远程调试示例</h3><ul>
<li>首先打包 SpringBoot 项目，在服务器上运行，执行以下命令：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=<span class="number">9190</span> -jar debug-demo.jar</div></pre></td></tr></table></figure>
<ul>
<li><p>出现下图的界面，表示运行成功：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/2.png" alt=""></p>
</li>
<li><p>然后在 IDEA 中，点击 <code>Edit Configurations</code>，在弹框中点击 <code>+</code> 号，然后选择<code>Remote</code>。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/3.png" alt=""></p>
</li>
<li>填写服务器的地址及端口，点击 OK 即可。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/4.png" alt=""></li>
<li>配置完毕后，DEBUG 调试运行即可。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/5.png" alt=""></li>
<li>配置完毕后点击保存即可，因为我配置的 suspend=n，因此服务端程序无需阻塞等待我们的连接。我们点击 IDEA 调试按钮，当我访问某一接口时，能够正常调试。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/6.png" alt=""></li>
</ul>
<h2 id="小福利"><a href="#小福利" class="headerlink" title="小福利"></a>小福利</h2><ul>
<li>作者为大家准备了接近 10M 的面试题，涵盖后端各个技术维度，老规矩，公众号内回复关键词<code>JAVA面试题</code>即可免费获取。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/8.png" alt=""></li>
<li>关注微信公众号回复关键词：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E4%B8%83%E7%A7%92%E7%BC%96%E7%A8%8B.jpg" alt=""></li>
</ul>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之代理模式</title>
    <url>/2018/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="结构型模式之代理模式-静态代理"><a href="#结构型模式之代理模式-静态代理" class="headerlink" title="结构型模式之代理模式(静态代理)"></a>结构型模式之代理模式(静态代理)</h2><ul>
<li><p>由于某些原因，客户端不想或不能直接访问一个对象，此时可以通过一个称之为“代理”的第三者来实现间接访问，该方案对应的设计模式被称为代理模式。</p>
</li>
<li><p>代理其实是实现简介访问的媒介，当然在代理类中还可以在执行代理操作之前，之后，之中，环绕等执行相关动作。<strong>Spring 中面向切面编程</strong>就是这个原理</p>
</li>
<li><p>代理模式是一种应用很广泛的结构型设计模式，而且变化形式非常多，常见的代理形式包括远程代理、保护代理、虚拟代理、缓冲代理、智能引用代理等，后面将学习这些不同的代理形式</p>
</li>
<li><p>当使用代理类的时候， 真实类中的信息对用户来说是透明的(不可见的)</p>
</li>
<li><p><strong>主要就是用于对象的间接访问提供了一个方案，可以对对象的访问进行控制</strong></p>
</li>
</ul>
<a id="more"></a>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="http://ono60m7tl.bkt.clouddn.com/proxypattern1.png" alt="代理模式"></p>
<ol>
<li>Subject（抽象主题角色）：它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。</li>
<li>Proxy（代理主题角色）：它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中，客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作。</li>
<li>RealSubject（真实主题角色）：它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。</li>
</ol>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h3><ul>
<li>需求： 我们知道mac笔记本是在美国生产的，那么如果中国供销商想要卖mac笔记本，那么必须从美国供销商那里先进货，然后中国的顾客才可以在中国供销商买mac。这里的中国供销商就相当于代理，美国供销商就相当于真实主题角色</li>
</ul>
<ul>
<li>Mac笔记本抽象接口(相当于其中的抽象主题)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 苹果笔记本的接口，其中有一个方法实现了买笔记本的动作</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MacBook</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>;   <span class="comment">//购买笔记本的行为</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>美国供销商(相当于这里RealSubject)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 美国的笔记本，实现了MacBook接口，表示在美国买笔记本</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">USAMac</span> <span class="keyword">implements</span> <span class="title">MacBook</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"在美国买笔记本"</span>);</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>中国供销商(相当于这里的代理角色)</p>
<ul>
<li>我们可以看到我们在使用代理模式的时候可以在之前和之后进行操作<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 中国的笔记本，实现了MacBook  表示在中国买笔记本</div><div class="line"> * 但是中国想要买到苹果笔记本，那么还是需要先从美国进货，因此中国只是一个中间的代理作用而已</div><div class="line"> * 当然代理的最大作用就是在代理之前、之后、之中执行相关的操作，这就是面向切面编程的原理</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChinaMac</span> <span class="keyword">implements</span> <span class="title">MacBook</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> MacBook mcBook=<span class="keyword">new</span> USAMac();   <span class="comment">//创建USAMac的对象</span></div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 在购买之前执行的操作</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preBuy</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"购买之前执行的操作"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 在购买之后执行的操作</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterBuy</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"购买之后执行的操作"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.preBuy();   <span class="comment">//之前执行的操作</span></div><div class="line">		mcBook.buy();  <span class="comment">//在美国买笔记本</span></div><div class="line">		System.out.println(<span class="string">"在中国买笔记本"</span>);</div><div class="line">		<span class="keyword">this</span>.afterBuy();   <span class="comment">//之后执行的操作</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>测试类</p>
<ul>
<li>我们在使用的时候直接使用代理类即可，我们根本不知道在真实类的使用，完全是代理类为我们提供了</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		MacBook macBook=<span class="keyword">new</span> ChinaMac();   <span class="comment">//创建ChinaMac对象，在中国买笔记本</span></div><div class="line">		macBook.buy();    <span class="comment">//直接在中国买笔记本</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="第二个例子"><a href="#第二个例子" class="headerlink" title="第二个例子"></a>第二个例子</h3><ul>
<li><p>我们登录一个网站的服务器端的验证步骤：</p>
<ul>
<li>读取用户名和密码</li>
<li>验证用户名和密码</li>
<li>记录到日志中</li>
</ul>
</li>
<li><p>这里的验证密码和记录到日志中可以在代理类中实现，在用户执行操作之前需要读取用户名和密码，并且验证，在操作之后需要将用户的一些操作记录到日志中。其实这里的真实用户需要做的只是执行自己的操作，而验证和记录都是交给代理类实现的。</p>
</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li>用户接口(User)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 用户的抽象类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">User</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoAction</span><span class="params">()</span></span>;   <span class="comment">//执行动作</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>真实的用户类（实现了用户接口）<ul>
<li>主要的做的就是执行自己的操作</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealUser</span> <span class="keyword">implements</span> <span class="title">User</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> String name;</div><div class="line">	<span class="keyword">public</span> String password;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RealUser</span><span class="params">(String name, String password)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">		<span class="keyword">this</span>.password = password;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RealUser</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * 执行一些操作</div><div class="line">	 */</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoAction</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"开始执行操作......"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>代理类(实现了User接口)<ul>
<li>在执行操作之前验证密码和用户名是否正确</li>
<li>在执行操作之后记录到日志中</li>
<li>实际上这里就是面向切面编程</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxUser</span> <span class="keyword">implements</span> <span class="title">User</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> RealUser user; <span class="comment">// 真实用户的对象</span></div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 创建对象</div><div class="line">	 * <span class="doctag">@param</span> name  姓名</div><div class="line">	 * <span class="doctag">@param</span> password   密码</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxUser</span><span class="params">(String name, String password)</span> </span>&#123;</div><div class="line">		user = <span class="keyword">new</span> RealUser(name, password);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoAction</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">//验证用户名和密码</span></div><div class="line">		<span class="keyword">if</span> (Validate()) &#123;</div><div class="line">			user.DoAction();   <span class="comment">//调用真实用户的DoAction方法执行相关操作</span></div><div class="line">			logger();   <span class="comment">//调用日志记录信息</span></div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			System.out.println(<span class="string">"请重新登录......."</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * 验证用户的用户名和密码</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> Boolean <span class="title">Validate</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (<span class="string">"陈加兵"</span>.equals(user.name) &amp;&amp; <span class="string">"123456"</span>.equals(user.password)) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 添加日志记录信息</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logger</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(user.name + <span class="string">"登录成功......"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>测试类<ul>
<li>实际上执行了验证用户名和密码，记录日志的操作，但是对于客户端来说只能看到自己执行的操作</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		ProxUser proxUser=<span class="keyword">new</span> ProxUser(<span class="string">"陈加兵"</span>, <span class="string">"123456"</span>);   <span class="comment">//创建代理对象</span></div><div class="line">		proxUser.DoAction();   <span class="comment">//执行操作，实际执行了验证信息，doaction(),日志记录这个三个动作</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>如果增加一个接口就需要增加一个代理类，如果是要增加很多，那么就要增加很多代理类，代码将会重复</li>
</ul>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul>
<li>下面我们将会讲解到动态代理，仅仅需要一个代理类即可</li>
</ul>
<h1 id="结构型模式之动态代理模式"><a href="#结构型模式之动态代理模式" class="headerlink" title="结构型模式之动态代理模式"></a>结构型模式之动态代理模式</h1><ul>
<li><p>前面我们说的代理模式其实是属于静态代理模式，就是说在程序执行之前已经写好了代理类，但是缺点也是说过，必须为每个接口都实现一个代理类，如果有多个接口需要代理，那么代码肯定是要重复的，因此就需要动态代理了。</p>
</li>
<li><p>动态代理可以实现多个接口共用一个代理类，只需要改变初始化的参数即可，可以省去很多的重复的代码。</p>
</li>
<li><p>JDK的动态代理需要一个类一个接口，分别为Proxy和InvocationHandler</p>
</li>
<li><p>主要原理就是利用了反射的原理</p>
</li>
</ul>
<h2 id="InvocationHandler"><a href="#InvocationHandler" class="headerlink" title="InvocationHandler"></a>InvocationHandler</h2><ul>
<li>这个是代理类必须实现的接口，其中有一个方法<code>public Object invoke(Object proxy,Method method,Object[] args)</code><ul>
<li><code>Object proxy</code>：指被代理的对象。 </li>
<li><code>Method method</code>：要调用的方法 </li>
<li><code>Object[] args</code>：方法调用时所需要的参数 </li>
</ul>
</li>
</ul>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><ul>
<li>Proxy类是专门完成代理的操作类，可以通过此类为一个或多个接口动态地生成实现类，此类提供了如下的操作方法：<br><code>public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code><ul>
<li><code>ClassLoader loader</code>：类加载器 </li>
<li><code>Class&lt;?&gt;[] interfaces</code>：得到全部的接口 </li>
<li><code>InvocationHandler h</code>：得到InvocationHandler接口的子类实例 </li>
</ul>
</li>
</ul>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><ul>
<li>肯德基的接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 肯德基的接口，其中一个eat方法</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IKFC</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>肯德基的实现类(RealSubject)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * IKFC的实现类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KFC</span> <span class="keyword">implements</span> <span class="title">IKFC</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"我在肯德基吃了饭......"</span>);</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>苹果笔记本的接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 苹果笔记本的接口</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MacBook</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>美国供销商的类(RealSubject)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 美国笔记本的类，实现了MacBook接口</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">USAMacBook</span> <span class="keyword">implements</span> <span class="title">MacBook</span> </span>&#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"在美国买了一个苹果电脑......"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>动态代理的类（实现了InvocationHandler接口）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 这个是代理类，实现了InvocationHandler接口</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> Object Realobject;   <span class="comment">//被代理的对象</span></div><div class="line"></div><div class="line">	<span class="comment">//构造方法，用来初始化被代理的对象</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxyHandler</span><span class="params">(Object obj)</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.Realobject=obj;   <span class="comment">//初始化真实类的对象</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * <span class="doctag">@param</span> proxy  表示被代理的对象的，就是真实类的对象</div><div class="line">	 * <span class="doctag">@param</span> method 表示要调用真实类的方法</div><div class="line">	 * <span class="doctag">@param</span> args  表示方法调用的时候所需要的参数</div><div class="line">	 * <span class="doctag">@return</span>   方法调用之后的返回值</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></div><div class="line">			<span class="keyword">throws</span> Throwable &#123;</div><div class="line">		prefunction();   <span class="comment">//执行之前调用的方法</span></div><div class="line">		Object res=method.invoke(Realobject, args);    <span class="comment">//Method类中的执行方法的函数，在反射中常用</span></div><div class="line">		afterFunction();   <span class="comment">//执行之后调用的方法</span></div><div class="line">		<span class="keyword">return</span> res;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 执行方法之前调用的方法</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prefunction</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"执行方法之前......"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 执行方法之后调用的方法</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterFunction</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"执行方法之后......"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>测试类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</div><div class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.generic.NEW;</div><div class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.util.Class2HTML;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">		Class[] cls1=&#123;IKFC.class&#125;;   <span class="comment">//第一个代理的所有接口数组，直接用接口的反射即可</span></div><div class="line"></div><div class="line">		Class[] cls2=USAMacBook.class.getInterfaces(); <span class="comment">//直接具体的实现类的反射调用getInterfaces即可返回所有的接口数组</span></div><div class="line"></div><div class="line">		<span class="comment">// 返回KFC的代理对象</span></div><div class="line">		IKFC kfc = (IKFC) Proxy.newProxyInstance(Client.class.getClassLoader(),</div><div class="line">				cls1, <span class="keyword">new</span> ProxyHandler(<span class="keyword">new</span> KFC()));</div><div class="line">		kfc.eat();   <span class="comment">//执行方法</span></div><div class="line"></div><div class="line">		MacBook macBook = (MacBook) Proxy.newProxyInstance(Client.class.getClassLoader(),</div><div class="line">				cls2, <span class="keyword">new</span> ProxyHandler(</div><div class="line">						<span class="keyword">new</span> USAMacBook()));</div><div class="line"></div><div class="line">		macBook.buy();   <span class="comment">//执行方法</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>动态代理的好处<ul>
<li>即使有多个接口，也仅仅只有一个动态代理类</li>
</ul>
</li>
</ul>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg" alt=""></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之单例模式</title>
    <url>/2018/04/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h2><ul>
<li>该类只有一个实例</li>
<li>构造方法是私有的</li>
<li>有一个获取该类对象的静态方法getInstance()</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>一个国家只有一个主席</li>
<li>如果此时的限定必须是抽象出来的类只能是一个对象，这个时候就需要使用单例模式</li>
</ul>
<a id="more"></a>
<h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><h3 id="什么是懒汉式"><a href="#什么是懒汉式" class="headerlink" title="什么是懒汉式"></a>什么是懒汉式</h3><ul>
<li>懒汉式是当用到这个对象的时候才会创建，即是在getInstance()方法创建这个单例对象</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>只有用到的时候才会创建这个对象，因此节省资源</li>
<li>线程不安全<ul>
<li>我们知道一旦我们使用了懒汉式就是在getInstance()方法中创建这个单例对象，那么不可避免的就是线程安全问题</li>
</ul>
</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 懒汉式的单例模式： 不是线程安全的</div><div class="line"> * 优点： 在使用的时候才会初始化，可以节省资源</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignalLazy</span> </span>&#123;</div><div class="line">	<span class="comment">// 将默认的构造器设置为private类型的</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">SignalLazy</span><span class="params">()</span> </span>&#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 静态的单例对象</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> SignalLazy instance;</div><div class="line"></div><div class="line">	<span class="comment">//静态的获取单例的对象，其中有一个判断，如果没有初始化，那么就创建</span></div><div class="line">	<span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> SignalLazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 如果instance没有被初始化，那么就创建即可，这个是保证了单例，但是并不是线程安全的</span></div><div class="line">		<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">			System.out.println(<span class="string">"this is SignalLazy"</span>);</div><div class="line">			instance = <span class="keyword">new</span> SignalLazy(); <span class="comment">// 创建一 个对象</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> instance; <span class="comment">// 返回这个对象</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>从上面的代码中我们可以知道一旦使用多线程创建对象，那么就会出现线程不安全，最后创建出来的就不是单例了</p>
</li>
<li><p>测试代码如下</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		 <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="comment">//创建实例，并且输出其中的地址，如果地址相同， 那么就是同一个实例</span></div><div class="line">				System.out.println(<span class="string">"this is"</span>+ SignalLazy.getInstance());</div><div class="line"></div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line"></div><div class="line">		 <span class="comment">//主线程也是创建输出其中的地址，运行可以看出这两个地址是不一样的</span></div><div class="line">		 System.out.println(<span class="string">"this is"</span>+SignalLazy.getInstance());</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="解决线程不安全"><a href="#解决线程不安全" class="headerlink" title="解决线程不安全"></a>解决线程不安全</h3><ul>
<li>线程同步锁(synchronized)<ul>
<li>我们知道每一个类都有一个把锁，我们可以使用线程同步锁来实现线程同步方法</li>
<li>但是使用线程同步锁浪费资源，因为每次创建实例都需要请求同步锁，浪费资源</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> SignalLazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 如果instance没有被初始化，那么就创建即可，这个是保证了单例，但是并不是线程安全的</span></div><div class="line">		<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">			System.out.println(<span class="string">"this is SignalLazy"</span>);</div><div class="line">			instance = <span class="keyword">new</span> SignalLazy(); <span class="comment">// 创建一个对象</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> instance; <span class="comment">// 返回这个对象</span></div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ul>
<li>双重校验<ul>
<li>双重校验： 两次判断单例对象是否为 null，这样的话，当当线程经过这个判断的时候就会先判断，而不是等待，一旦判断不成立，那么就会继续执行，不需要等待</li>
<li>相对于前面的同步方法更加节省资源</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignalTonDoubleCheck</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SignalTonDoubleCheck instance = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">SignalTonDoubleCheck</span><span class="params">()</span> </span>&#123;</div><div class="line">	&#125;; <span class="comment">// 将默认的构造方法设置私有</span></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SignalTonDoubleCheck <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">synchronized</span> (SignalTonDoubleCheck.class) &#123;</div><div class="line">				<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">					<span class="keyword">try</span> &#123;</div><div class="line">						Thread.sleep(<span class="number">1000</span>);</div><div class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">					<span class="comment">// 这个new 并不是原子操作，因此当多线程进行到这里需要及时刷新这个值，因此要设置为voliate</span></div><div class="line">					instance = <span class="keyword">new</span> SignalTonDoubleCheck();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> instance;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>匿名内部类 （推荐使用）<ul>
<li>我们知道静态变量、静态代码块、静态方法都是在类加载的时候只加载一次</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignalTonInnerHolder</span> </span>&#123;</div><div class="line">	<span class="comment">//私有构造函数</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">SignalTonInnerHolder</span><span class="params">()</span> </span>&#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * 匿名内部类，其中利用了静态成员变量在类加载的时候初始化，并且只加载一次，因此保证了单例</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerHolder</span> </span>&#123;</div><div class="line">		<span class="keyword">private</span> <span class="keyword">static</span> SignalTonInnerHolder instance = <span class="keyword">new</span> SignalTonInnerHolder();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SignalTonInnerHolder <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> InnerHolder.instance;  <span class="comment">//加载类</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>一旦加载SignalTonInnerHolder类的时候就会加载其中的静态类，随之加载的就是其中的创建对象语句，因此在类加载的时候就完成了创建，这个和我们后面说的饿汉式有点相同</li>
</ul>
<h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><h3 id="什么是饿汉式"><a href="#什么是饿汉式" class="headerlink" title="什么是饿汉式"></a>什么是饿汉式</h3><ul>
<li>在类加载的时候就创建单例对象，而不是在getInstance()方法创建</li>
<li>所谓的饿汉式就是利用静态成员变量或者静态语句块在类加载的时候初始化，并且只初始化一次，因此这个是线程安全的，但是在没有用到的时候就初始化，那么是浪费资源</li>
</ul>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>还没用到就创建，浪费资源</li>
<li>类加载的时候就创建，线程安全</li>
</ul>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 饿汉式：线程安全</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignalHungry</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">SignalHungry</span><span class="params">()</span> </span>&#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 静态变量只有在类加载的时候初始化一次，因此这个是线程安全的</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> SignalHungry instance = <span class="keyword">new</span> SignalHungry();</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SignalHungry <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> instance;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		 <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="comment">//创建实例，并且输出其中的地址，如果地址相同， 那么就是同一个实例</span></div><div class="line">				System.out.println(<span class="string">"this is"</span>+ SignalHungry.getInstance());</div><div class="line"></div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line"></div><div class="line">		 <span class="comment">//主线程也是创建输出其中的地址，运行可以看出这两个地址是不一样的</span></div><div class="line">		 System.out.println(<span class="string">"this is"</span>+SignalHungry.getInstance());</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>饿汉式在类加载的时候就会创建单例对象，因此浪费资源</li>
<li>懒汉式在用到的时候才创建，节省资源，但是线程不安全，但是我们可以使用匿名内部类的方式使其线程安全</li>
<li>一般在使用的时候会使用懒汉式的匿名内部类的实现和饿汉式的创建方式</li>
</ul>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg" alt=""></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之常见关系</title>
    <url>/2018/04/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B8%B8%E8%A7%81%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h1 id="继承和泛化"><a href="#继承和泛化" class="headerlink" title="继承和泛化"></a>继承和泛化</h1><ul>
<li>泛华关系是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。</li>
<li>使用三角箭头的实线表示继承，其中箭头指向的是父类<br><img src="http://ono60m7tl.bkt.clouddn.com/jicheng.png" alt="继承图形"></li>
</ul>
<a id="more"></a>
<h1 id="接口与实现"><a href="#接口与实现" class="headerlink" title="接口与实现"></a>接口与实现</h1><ul>
<li>在java中一个类只能继承一个父类，但是可以实现多个接口</li>
<li>使用的是带三角的虚线表示，其中箭头指向的是接口</li>
</ul>
<p><img src="http://ono60m7tl.bkt.clouddn.com/real.png" alt="实现接口"></p>
<h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><ul>
<li>是一种使用关系，即一个类的实现需要另外一个类的协助，所以尽量不使用双向的依赖关系。</li>
<li>最典型的就是import</li>
<li>比如：一个类要定义String类型的变量，那么这个类就是依赖String这个类</li>
</ul>
<p><img src="http://ono60m7tl.bkt.clouddn.com/dependency.png" alt="依赖"></p>
<h1 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h1><ul>
<li>是一种拥有的关系，它使一个类知道另外一个类的属性和方法，比如数据库中的关系，通过学生可以查找到自己课程的成绩，只需要在学生中定义一个课程的对象即可。</li>
<li>代码体现： 成员变量</li>
<li>带普通箭头的实心线，指向被拥有者</li>
</ul>
<p><img src="http://ono60m7tl.bkt.clouddn.com/association.png" alt="关联"></p>
<h1 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h1><ul>
<li><p>是整体和部分的关系，且部分可以离开整体而单独的存在。车和轮胎是整体和部分的关系，但是轮胎离开车还是可以单独存在的</p>
</li>
<li><p>代码体现： 成员变量</p>
</li>
<li><p>带空心菱形的实心线，菱形指向整体</p>
</li>
</ul>
<p><img src="http://ono60m7tl.bkt.clouddn.com/aggregation.png" alt="聚合"></p>
<h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><ul>
<li>是整体和部分的关系，但是部分不能离开整体而单独存在</li>
<li>代码体现：成员变量</li>
<li>带实心菱形的实线，菱形指向整体</li>
</ul>
<p><img src="http://ono60m7tl.bkt.clouddn.com/composition.png" alt="组合"></p>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg" alt=""></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之原型模式</title>
    <url>/2018/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li><p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>   这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要    在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p>
</li>
<li><p>原型模式可以分为浅克隆和深度克隆</p>
</li>
</ul>
<a id="more"></a>
<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p><img src="http://ono60m7tl.bkt.clouddn.com/property1.png" alt="角色"></p>
<h2 id="java语言中实现克隆的两种方式"><a href="#java语言中实现克隆的两种方式" class="headerlink" title="java语言中实现克隆的两种方式"></a>java语言中实现克隆的两种方式</h2><ol>
<li><p>直接创建一个对象，然后设置成员变量的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Obj obj=<span class="keyword">new</span> Obj(); <span class="comment">//创建一个新的对象</span></div><div class="line">obj.setName(<span class="keyword">this</span>.name);   <span class="comment">//设置其中变量的值</span></div><div class="line">obj.setAge(<span class="keyword">this</span>.age);</div></pre></td></tr></table></figure>
</li>
<li><p>实现cloneable接口</p>
</li>
</ol>
<p><img src="http://ono60m7tl.bkt.clouddn.com/property2.png" alt=""></p>
<h2 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h2><ul>
<li><p>如果克隆的对象的成员变量是值类型的，比如int，double那么使用浅克隆就可以实现克隆完整的原型对象，但是如果其中的成员变量有引用类型的，那么这个引用类型的克隆过去的其实是地址，克隆对象的这个引用类型变量改变了，那么原来变量的值也是会改变的。</p>
</li>
<li><p>简单的说，浅克隆只能复制值类型的，对于引用类型的数据只能复制地址</p>
</li>
</ul>
<p><img src="http://ono60m7tl.bkt.clouddn.com/property3.png" alt="浅克隆"></p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul>
<li>一个公司出版周报，那么这个周报的格式一般是相同的，只是将其中的内容稍作修改即可。但是一开始没有这个原型，员工每周都需要重新手写这个周报，现在有了这个周报的原型，只需要在这个clone这个原型，然后在其基础上修改即可。</li>
</ul>
<p><img src="http://ono60m7tl.bkt.clouddn.com/property4.png" alt="周报"></p>
<ul>
<li>其中的Cloneable就是抽象原型类</li>
</ul>
<ul>
<li>附件类（这个是一个引用类型的对象，验证浅克隆只是复制其中的地址，如果两个对象中的任何一个改变了这个变量的值，那么另外一个也会随之改变）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 附件类，这个是周报的附件</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Attachment</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> String name; <span class="comment">// 名称</span></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Attachment</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>();</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>周报的类（其中实现了Cloneable接口）<ul>
<li>其中的clone()方法返回的就是一个克隆的对象，因此我们调用这个方法克隆一个新的对象</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 这个是周报类，这个类是实现接口Prototype这个接口的</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeeklyLog</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> String name; <span class="comment">// 姓名</span></div><div class="line">	<span class="keyword">private</span> String date; <span class="comment">// 日期</span></div><div class="line">	<span class="keyword">private</span> String content; <span class="comment">// 内容</span></div><div class="line">	<span class="keyword">private</span> Attachment attachment;  <span class="comment">//附件，是一个引用对象，这个只能实现浅克隆</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">WeeklyLog</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>();</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 构造方法</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">WeeklyLog</span><span class="params">(String name, String date, String content)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>();</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">		<span class="keyword">this</span>.date = date;</div><div class="line">		<span class="keyword">this</span>.content = content;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 提供一个clone方法，返回的是一个clone对象</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> WeeklyLog <span class="title">clone</span><span class="params">()</span> </span>&#123;</div><div class="line">		Object object = <span class="keyword">null</span>; <span class="comment">// 创建一个Object对象</span></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			object = <span class="keyword">super</span>.clone(); <span class="comment">// 直接调用clone方法，复制对象</span></div><div class="line">			<span class="keyword">return</span> (WeeklyLog) object; <span class="comment">// 返回即可</span></div><div class="line">		&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</div><div class="line">			System.out.println(<span class="string">"这个对象不能复制....."</span>);</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>测试类<ul>
<li>测试浅克隆的值类型是是否完成复制了</li>
<li>测试引用类型的值能否完成克隆，还是只是复制了一个引用地址</li>
<li>从结果来看，对象是完成复制了，因为判断两个对象的地址是不一样的，但是其中的引用类型的成员变量没有完成复制，只是复制了一个地址</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</div><div class="line"></div><div class="line">		WeeklyLog p1 = <span class="keyword">new</span> WeeklyLog(<span class="string">"陈加兵"</span>, <span class="string">"第一周"</span>, <span class="string">"获得劳动模范的称号..."</span>); <span class="comment">// 创建一个对象</span></div><div class="line">		Attachment attachment = <span class="keyword">new</span> Attachment(<span class="string">"消息"</span>);</div><div class="line">		p1.setAttachment(attachment); <span class="comment">// 添加附件</span></div><div class="line">		WeeklyLog p2 = p1.clone();</div><div class="line">		System.out.println(p1 == p2); <span class="comment">// 判断是否正确</span></div><div class="line">		p2.setName(<span class="string">"Jack"</span>); <span class="comment">// 修改P2对象的内容</span></div><div class="line">		p2.setDate(<span class="string">"第二周"</span>);</div><div class="line">		p2.setContent(<span class="string">"工作认真....."</span>);</div><div class="line">		System.out.println(p2.getName());</div><div class="line">		<span class="comment">// 返回true，可以知道这两个附件的地址是一样的</span></div><div class="line">		System.out.println(p1.getAttachment() == p2.getAttachment());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>浅克隆对于值类型的数据可以复制成功，但是对于引用卡类型的数据只能复制一个地址，如果一个对象中的引用类型的变量的值改变了，那么另外一个也会随之改变</li>
</ul>
<h2 id="深度克隆"><a href="#深度克隆" class="headerlink" title="深度克隆"></a>深度克隆</h2><ul>
<li>浅克隆只能完成复制值类型，深度克隆可以完成复制引用类型和值类型</li>
</ul>
<p><img src="http://ono60m7tl.bkt.clouddn.com/property5.png" alt="深度克隆"></p>
<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ol>
<li>引用类型的变量类实现序列化(实现Serializabl接口）</li>
<li>需要克隆的类实现序列化(实现Serializable接口)</li>
</ol>
<h3 id="为什么实现序列化"><a href="#为什么实现序列化" class="headerlink" title="为什么实现序列化"></a>为什么实现序列化</h3><ul>
<li>因为深度克隆的实现的原理是使用输入和输出流，如果想要将一个对象使用输入和输出流克隆，必须序列化。</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li><p>附件类(引用类型的成员变量，实现序列化)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 附件类，这个是周报的附件</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Attachment</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">799959163401886355L</span>;</div><div class="line">	<span class="keyword">private</span> String name; <span class="comment">// 名称</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Attachment</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>();</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>周报类（需要克隆的类，因为其中有引用类型的成员变量，因此需要实现序列化)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 这个是周报类，这个类是实现接口Prototype这个接口的</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeeklyLog</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8782492113927035907L</span>;</div><div class="line">	<span class="keyword">private</span> String name; <span class="comment">// 姓名</span></div><div class="line">	<span class="keyword">private</span> String date; <span class="comment">// 日期</span></div><div class="line">	<span class="keyword">private</span> String content; <span class="comment">// 内容</span></div><div class="line">	<span class="keyword">private</span> Attachment attachment; <span class="comment">// 附件，是一个引用对象，这个只能实现浅克隆</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">WeeklyLog</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>();</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 构造方法</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">WeeklyLog</span><span class="params">(String name, String date, String content)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>();</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">		<span class="keyword">this</span>.date = date;</div><div class="line">		<span class="keyword">this</span>.content = content;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 提供一个clone方法，返回的是一个clone对象</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> WeeklyLog <span class="title">clone</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 将对象写入到对象流中</span></div><div class="line">		ByteArrayOutputStream arrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(</div><div class="line">					arrayOutputStream); <span class="comment">// 创建对象输出流</span></div><div class="line">			objectOutputStream.writeObject(<span class="keyword">this</span>); <span class="comment">// 将这个类的对象写入到输出流中</span></div><div class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// 将对象从流中读出</span></div><div class="line">		ByteArrayInputStream arrayInputStream = <span class="keyword">new</span> ByteArrayInputStream(</div><div class="line">				arrayOutputStream.toByteArray());</div><div class="line">		WeeklyLog weeklyLog;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(</div><div class="line">					arrayInputStream);<span class="comment">// 新建对象输入流</span></div><div class="line">			weeklyLog = (WeeklyLog) objectInputStream.readObject(); <span class="comment">// 读取对象从流中</span></div><div class="line">			<span class="keyword">return</span> weeklyLog;</div><div class="line">		&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>测试类</p>
<ul>
<li>从中可以看出其中的附件地址是不同的，如果一个对象的附件变量改变了，那么另外一个将保持不变，因此实现了深度克隆，是两个完全不同的对象</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</div><div class="line"></div><div class="line">		WeeklyLog p1 = <span class="keyword">new</span> WeeklyLog(<span class="string">"陈加兵"</span>, <span class="string">"第一周"</span>, <span class="string">"获得劳动模范的称号..."</span>); <span class="comment">// 创建一个对象</span></div><div class="line">		Attachment attachment = <span class="keyword">new</span> Attachment(<span class="string">"消息"</span>);</div><div class="line">		p1.setAttachment(attachment); <span class="comment">// 添加附件</span></div><div class="line">		WeeklyLog p2 = p1.clone();</div><div class="line">		System.out.println(p1 == p2); <span class="comment">// 判断是否正确</span></div><div class="line">		p2.setName(<span class="string">"Jack"</span>); <span class="comment">// 修改P2对象的内容</span></div><div class="line">		p2.setDate(<span class="string">"第二周"</span>);</div><div class="line">		p2.setContent(<span class="string">"工作认真....."</span>);</div><div class="line">		System.out.println(p2.getName());</div><div class="line">		<span class="comment">//返回false，可以看出这个是不同的地址，因此完成了深克隆</span></div><div class="line">		System.out.println(p1.getAttachment() == p2.getAttachment());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>因为深度克隆使用的是将对象写入输入和输出流中的，因此需要实现序列化，否则将不能完成</li>
</ul>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>浅克隆只能克隆对象中的值类型，不能克隆有引用类型成员变量的对象</p>
</li>
<li><p>使用深度克隆：</p>
<ul>
<li>引用类型的成员变量的类必须实现序列化</li>
<li>需要克隆的类必须实现序列化</li>
</ul>
</li>
</ol>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg" alt=""></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之建造模式</title>
    <url>/2018/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li><p>建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。</p>
</li>
<li><p>简单说，建造者的功能就是先构造复杂对象的每一个部件，指挥者的功能就是将这些部件以一定的步骤组装起来，形成一个具有一定功能的产品或者对象。当然这个步骤是透明的对于客户端。</p>
</li>
<li><p>建造者模式一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式结构如图8-2所示：</p>
</li>
</ul>
<p><img src="http://ono60m7tl.bkt.clouddn.com/BuilderPattern.png" alt="建造者模式"></p>
<p><img src="http://ono60m7tl.bkt.clouddn.com/builder2.png" alt=""><br><a id="more"></a></p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul>
<li><p>下面是一个组装汽车的例子，其中汽车由发动机和轮胎组成，那么我们只需要组装轮胎，发动机即可组装完成一个汽车。</p>
</li>
<li><p>汽车包括轮胎，引擎，我们通常在组装汽车的时候一般都是一步一步的组装，比如先装引擎，后装轮胎。使用建造者模式就是将建造汽车的这个过程抽离成几个不同的过程，比如建造引擎和建造轮胎就是两个过程。</p>
</li>
<li><p>轮胎的JavaBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 轮胎</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tyre</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Tyre</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>引擎的JavaBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 引擎</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Engine</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>汽车的JavaBean(汽车包含轮胎和引擎，因此使用聚合的关系)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 汽车的类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Tyre tyre; <span class="comment">// 轮胎</span></div><div class="line">	<span class="keyword">private</span> Engine engine;  <span class="comment">// 引擎</span></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> Tyre <span class="title">getTyre</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> tyre;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTyre</span><span class="params">(Tyre tyre)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.tyre = tyre;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> Engine <span class="title">getEngine</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> engine;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEngine</span><span class="params">(Engine engine)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.engine = engine;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>抽象建造者(实际上是一个接口，其中定义了建造轮胎和引擎的方法)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 构造引擎的方法</div><div class="line">	 */</div><div class="line">	<span class="function">Engine <span class="title">buliderEngine</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 构造轮胎的方法</div><div class="line">	 */</div><div class="line">	<span class="function">Tyre <span class="title">builderTyre</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>具体的建造者(实现了抽象建造者，实现建造轮胎和引擎的详细过程)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 具体的建造者，主要是构造汽车的部件</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuilderCar</span> <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Engine <span class="title">buliderEngine</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"构造汽车发动机"</span>);</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Engine(<span class="string">"傻逼牌发动机"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Tyre <span class="title">builderTyre</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"构造汽车轮胎"</span>);</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Tyre(<span class="string">"傻逼牌轮胎"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>抽象指挥者(定义了一个构造汽车的方法)，指挥者的作用就是按照一定步骤将构造者建造的部件组装起来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 	指挥者的接口，用来按照顺序组装汽车</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Director</span> </span>&#123;</div><div class="line">	<span class="function">Car <span class="title">CreateCar</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>具体的指挥者(实现了指挥者接口)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 指挥者的实现类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectorCar</span> <span class="keyword">implements</span> <span class="title">Director</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Builder builder; <span class="comment">// 建造者的对象</span></div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 构造方法，主要用来初始化建造者对象</div><div class="line">	 *</div><div class="line">	 * <span class="doctag">@param</span> builder  Builder的对象</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DirectorCar</span><span class="params">(Builder builder)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.builder = builder;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Car <span class="title">CreateCar</span><span class="params">()</span> </span>&#123;</div><div class="line">		Car car = <span class="keyword">new</span> Car(); <span class="comment">// 创建汽车对象</span></div><div class="line">		Engine engine = builder.buliderEngine(); <span class="comment">// 构建发动机</span></div><div class="line">		Tyre tyre = builder.builderTyre(); <span class="comment">// 构造轮胎</span></div><div class="line">		car.setEngine(engine); <span class="comment">// 设置属性</span></div><div class="line">		car.setTyre(tyre); <span class="comment">// 设置属性</span></div><div class="line">		<span class="keyword">return</span> car; <span class="comment">// 返回构造好的汽车</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Director director = <span class="keyword">new</span> DirectorCar(<span class="keyword">new</span> BuilderCar()); <span class="comment">// 创建指挥者的对象</span></div><div class="line">		Car car = director.CreateCar(); <span class="comment">// 获取组装完成的</span></div><div class="line">		System.out.println(car.getEngine().getName()); <span class="comment">// 输出引擎的名字</span></div><div class="line">		System.out.println(car.getTyre().getName()); <span class="comment">// 输出轮胎的名字</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li><p>基本部件不变，但是其中的组合经常变化的情况</p>
<ul>
<li>比如你去肯德基点餐，汉堡，可乐，鸡翅这些食物是不变的，但是套餐的组合是经常变化的，建造者模式的指挥者就是将这些部件按照一定步骤将其组合起来的。</li>
<li>java中StringBuilder</li>
</ul>
</li>
<li><p>需要生成的对象具有复杂的内部结构</p>
<ul>
<li>复杂的内部结构，我们可以使用建造者模式将其分离，先将其中的各个小的部件组装成功，然后由指挥者按照一定的步骤将其组装成一个复杂的对象</li>
</ul>
</li>
<li>需要生成的对象内部属性本身相互依赖。</li>
</ul>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg" alt=""></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之桥接模式</title>
    <url>/2018/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<ul>
<li><p>桥接模式是一种很实用的结构型设计模式，如果软件系统中某个类存在两个独立变化的维度，通过该模式可以将这两个维度分离出来，使两者可以独立扩展，让系统更加符合“单一职责原则”。与多层继承方案不同，它将两个独立变化的维度设计为两个独立的继承等级结构，并且在抽象层建立一个抽象关联，该关联关系类似一条连接两个独立继承结构的桥，故名桥接模式。</p>
</li>
<li><p>桥接模式用一种巧妙的方式处理多层继承存在的问题，用抽象关联取代了传统的多层继承，将类之间的静态继承关系转换为动态的对象组合关系，使得系统更加灵活，并易于扩展，同时有效控制了系统中类的个数。桥接定义如下：</p>
</li>
<li><p>桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。</p>
</li>
</ul>
<p><img src="http://ono60m7tl.bkt.clouddn.com/bridge1.png" alt="桥接模式"></p>
<ul>
<li><p>在桥接模式结构图中包含如下几个角色：</p>
<ul>
<li>Abstraction（抽象类）：用于定义抽象类的接口，它一般是抽象类而不是接口，其中定义了一个Implementor（实现类接口）类型的对象并可以维护该对象，它与Implementor之间具有关联关系，它既可以包含抽象业务方法，也可以包含具体业务方法。</li>
<li>RefinedAbstraction（扩充抽象类）：扩充由Abstraction定义的接口，通常情况下它不再是抽象类而是具体类，它实现了在Abstraction中声明的抽象业务方法，在RefinedAbstraction中可以调用在Implementor中定义的业务方法。</li>
<li>Implementor（实现类接口）：定义实现类的接口，这个接口不一定要与Abstraction的接口完全一致，事实上这两个接口可以完全不同，一般而言，Implementor接口仅提供基本操作，而Abstraction定义的接口可能会做更多更复杂的操作。Implementor接口对这些基本操作进行了声明，而具体实现交给其子类。通过关联关系，在Abstraction中不仅拥有自己的方法，还可以调用到Implementor中定义的方法，使用关联关系来替代继承关系。</li>
<li>ConcreteImplementor（具体实现类）：具体实现Implementor接口，在不同的ConcreteImplementor中提供基本操作的不同实现，在程序运行时，ConcreteImplementor对象将替换其父类对象，提供给抽象类具体的业务操作方法。<a id="more"></a>
</li>
</ul>
</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><img src="http://ono60m7tl.bkt.clouddn.com/bridge2.png" alt="实例"></p>
<ul>
<li><p>从上面的这个实例我们可以看出，如果使用多层继承的话，那么我们可以定义是三个抽象类（台式机，笔记本，平板电脑），在这个三个抽象类的下面每个都有三个不同品牌的具体实现类，那么总共要有3x3=9个具体的实现类。不仅仅是类的数量多，在扩展性能上也是成倍的增加，如果想要添加一个品牌，那么需要添加三个类，这个是极其浪费的。</p>
</li>
<li><p>针对上面的缺点，我们可以使用桥接模式，将电脑分类，品牌分类分成两个维度，如下图：<br><img src="http://ono60m7tl.bkt.clouddn.com/bridge3.png" alt=""></p>
</li>
<li><p>其中Computer是一个抽象类，不是接口，其中Brand（品牌）是其中的成员变量，我们就完成了一个电脑具有不同品牌，那么如果我们想添加一个品牌，就只是添加一个具体的实现类即可，就不需要添加三个了。</p>
</li>
</ul>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg" alt=""></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之适配器模式</title>
    <url>/2018/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>适配器模式用于将一个接口转化成客户想要的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</li>
</ul>
<p><img src="http://ono60m7tl.bkt.clouddn.com/adapeter1.png" alt="适配器模式"></p>
<ul>
<li>Target（目标抽象类）：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。</li>
<li>Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。</li>
<li><p>Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。</p>
</li>
<li><p>根据对象适配器模式结构图，在对象适配器中，客户端需要调用request()方法，而适配者类Adaptee没有该方法，但是它所提供的specificRequest()方法却是客户端所需要的。为了使客户端能够使用适配者类，需要提供一个包装类Adapter，即适配器类。这个包装类包装了一个适配者的实例，从而将客户端与适配者衔接起来，在适配器的request()方法中调用适配者的specificRequest()方法。因为适配器类与适配者类是关联关系（也可称之为委派关系），所以这种适配器模式称为对象适配器模式</p>
</li>
</ul>
<a id="more"></a>
<h2 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h2><ul>
<li><p>类适配器是继承适配者类实现的，其中对象适配器是使用组合的方式实现的，就是适配者类作为适配器类的成员变量而实现的</p>
</li>
<li><p>一般目标抽象类是一个接口，适配者类一般是一个具体的实现类，有时候甚至不知道其中的源代码，因此需要适配器类将适配者类转换成适合用户的目标类</p>
</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul>
<li>我们知道笔记本充电的电压是5v，但是我们的高压电是220v，那么我们此时就需要一个适配器将这个220v电压转换成为5v的电压给笔记本充电<ul>
<li>这里的220v电压就是适配者类，即是需要转换的类</li>
<li>5v电压是目标抽象类，由适配器将220v转换而来</li>
<li>这里的适配器类的主要功能就是将220v电压转换成5v电压</li>
</ul>
</li>
</ul>
<ul>
<li>目标接口(5v电压)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 接口为5v电压的接口  ，  这个目标抽象类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Power5</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getPower5</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>220v电压的类（这里是一个具体的类，适配者类）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Power220</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPower220</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"正在输出220v电压....."</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>适配器类（将220v电压转换成5v）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 适配器类，主要的目的就是将220v电压转换为5v的电压供笔记本充电</div><div class="line"> * 其中Power5是目标抽象接口，是最终需要的接口，Power220是一个适配者类，是已经存在的，只需要适配器转换即可</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterPower5</span> <span class="keyword">extends</span> <span class="title">Power220</span> <span class="keyword">implements</span> <span class="title">Power5</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 重载Power5中的方法，获取需要的5v电压</div><div class="line">	 * 过程： 先获取220v电压，然后进行转换即可</div><div class="line">	 * 	 */</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPower5</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.getPower220();   <span class="comment">//首先获取220v电压</span></div><div class="line">		<span class="keyword">this</span>.transform();   <span class="comment">//将220v电压转换成5v的电压</span></div><div class="line">		System.out.println(<span class="string">"获取5v电压......."</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * 将220v电压转换成5v电压的方法</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"现在将220v电压转换成5v电压......."</span>);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>笔记本充电的类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 笔记本类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoteBook</span> </span>&#123;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 笔记本充电的方法</div><div class="line">	 * <span class="doctag">@param</span> power5   电压为5v的对象</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PowerOn</span><span class="params">(Power5 power5)</span></span>&#123;</div><div class="line">		power5.getPower5();   <span class="comment">//获取5v电压</span></div><div class="line">		System.out.println(<span class="string">"笔记本获取了5v的电压，正在开始充电......"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>测试类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		NoteBook noteBook=<span class="keyword">new</span> NoteBook();   <span class="comment">//创建笔记本的类</span></div><div class="line">		noteBook.PowerOn(<span class="keyword">new</span> AdapterPower5());   <span class="comment">//调用笔记本充电的类</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h2><ul>
<li>对象适配器是将适配者类作为适配器类的成员变量并不是继承，这个是一种组合方式</li>
<li>这种方式使用的更加普遍</li>
</ul>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><ul>
<li><p>这里的实例还是前面的例子</p>
</li>
<li><p>这里唯一不同的就是适配器类，不是继承适配者类，而是使用组合的方式</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 适配器类，这个是对象适配器，适配者类是作为成员变量存在，是组合关系</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Power5</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Power220 power;   <span class="comment">//220v电压类的对象，作为成员变量</span></div><div class="line"></div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * 构造方法，主要是为类初始化Power220v的对象</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Power220 power)</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.power=power;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPower5</span><span class="params">()</span> </span>&#123;</div><div class="line">		power.getPower220();   <span class="comment">//获取220v电压</span></div><div class="line">		transform();   <span class="comment">//转换电压</span></div><div class="line">		System.out.println(<span class="string">"正在输出5v电压......."</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"将220v电压转换成5v的电压......"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>类适配器是使用类继承的方式，适配器类继承适配者类(不提倡使用)</p>
</li>
<li><p>对象适配器使用的是一种组合的方式，将适配者类作为其中的成员变量，那么也是可以实现（提倡使用）</p>
</li>
</ul>
<h2 id="麻烦支持下博主的广告事业，点击下即可"><a href="#麻烦支持下博主的广告事业，点击下即可" class="headerlink" title="麻烦支持下博主的广告事业，点击下即可"></a>麻烦支持下博主的广告事业，点击下即可</h2><p><a href="http://click.linktech.cn/?m=huaweivmall&amp;a=A100234624&amp;l=02300&amp;l_cd1=0&amp;l_cd2=0&amp;u_id=chenjiabing" target="_blank" rel="external"><img src="http://banner.linktech.cn/MC/huaweivmallwap/20171206/450x220.jpg" alt="alt text" title="title"></a></p>
<p><a href="http://click.linktech.cn/?m=huaweivmall&a=A100234624&l=02300&l_cd1=0&l_cd2=0&u_id=chenjiabing" target="_blank"><img src="http://banner.linktech.cn/MC/huaweivmallwap/20171206/450x220.jpg" width="450" height="220" border="0"></a><img src="http://track.linktech.cn/?m=huaweivmall&a=A100234624&l=02300&l_cd1=0&l_cd2=0" width="1" height="1" border="0" style="display:none"></p>
<p><a href="http://click.linktech.cn/?m=huaweivmall&a=A100234624&l=02303&l_cd1=0&l_cd2=0&u_id=chenjiabing" target="_blank"><img src="http://banner.linktech.cn/MC/huaweivmall/20171225/640x240.jpg" width="450" height="240" border="0"></a><img src="http://track.linktech.cn/?m=huaweivmall&a=A100234624&l=02303&l_cd1=0&l_cd2=0" width="1" height="1" border="0" style="display:none"></p>
<p><a href="http://click.linktech.cn/?m=huaweivmall&a=A100234624&l=02302&l_cd1=0&l_cd2=0&u_id=chenjiabing" target="_blank"><img src="http://banner.linktech.cn/MC/huaweivmallwap/20171219/450x220.jpg" width="450" height="220" border="0"></a><img src="http://track.linktech.cn/?m=huaweivmall&a=A100234624&l=02302&l_cd1=0&l_cd2=0" width="1" height="1" border="0" style="display:none"></p>
<p><a href="http://click.linktech.cn/?m=huaweivmall&a=A100234624&l=02300&l_cd1=0&l_cd2=0&u_id=chenjiabing" target="_blank"><img src="http://banner.linktech.cn/MC/huaweivmallwap/20171206/450x220.jpg" width="450" height="220" border="0"></a><img src="http://track.linktech.cn/?m=huaweivmall&a=A100234624&l=02300&l_cd1=0&l_cd2=0" width="1" height="1" border="0" style="display:none"></p>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg" alt=""></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式：工厂方法模式</title>
    <url>/2020/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>工厂方法模式是所有设计模式中比较常用的一种模式，但是真正能搞懂用好的少之又少，Spring底层大量的使用该设计模式来进行封装，以致开发者阅读源代码的时候晕头转向。</li>
<li>今天陈某分别从以下五个方面详细讲述一下工厂方法模式：<ol>
<li><strong>从什么是工厂方法模式</strong></li>
<li><strong>通用框架实现</strong></li>
<li><strong>工厂方法模式的优点</strong></li>
<li><strong>工厂方法模式的升级</strong></li>
<li><strong>Spring底层如何使用工厂方法模式</strong></li>
</ol>
</li>
</ul>
<h2 id="什么是工厂方法模式？"><a href="#什么是工厂方法模式？" class="headerlink" title="什么是工厂方法模式？"></a>什么是工厂方法模式？</h2><ul>
<li>定义：定义一个用于创建对象的 接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</li>
<li>工厂方法模式通用类图如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/1.png" alt=""></li>
<li>在工厂方法模式中，抽象产品<code>Product</code>负责定义产品的特性，实现对事物的抽象定义。</li>
<li><code>AbstractFactory</code>是抽象工厂类，定义了一个抽象工厂方法。具体的如何创建产品由工厂实现类<code>ConcreteFactory</code>完成。</li>
</ul>
<h2 id="通用框架实现"><a href="#通用框架实现" class="headerlink" title="通用框架实现"></a>通用框架实现</h2><ul>
<li>工厂方法模式的变种有很多，陈某给出一个比较实用的通用框架。</li>
<li><p><code>抽象产品类</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 公共逻辑方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 抽象方法：由子类实现，根据业务逻辑定义多个</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>具体产品类1</code>，继承抽象产品类，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product1</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 实现抽象产品类的抽象方法</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>具体产品类2</code>，继承抽象产品类，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product2</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 实现抽象产品类的抽象方法</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>抽象工厂类</code>，必须定义一个工厂方法来自己实现具体的创建逻辑，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 工厂方法，需要子类实现</div><div class="line">     * <span class="doctag">@param</span> cls</div><div class="line">     * <span class="doctag">@param</span> &lt;T&gt;</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T extends Product&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; cls)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>具体工厂类，使用了反射对具体产品的实例化，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> &lt;T extends Product&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; cls)</span> </span>&#123;</div><div class="line">        Product product=<span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            product= (Product) Class.forName(cls.getName()).newInstance();</div><div class="line">        &#125;<span class="keyword">catch</span> (Exception ex)&#123;</div><div class="line">            ex.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (T) product;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>测试如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//创建具体工厂类</span></div><div class="line">        ConcreteFactory factory = <span class="keyword">new</span> ConcreteFactory();</div><div class="line">        <span class="comment">//调用工厂方法获取产品类1的实例</span></div><div class="line">        Product1 product1 = factory.create(Product1.class);</div><div class="line">        System.out.println(product1);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>以上是简单的一个通用框架，读者可以根据自己的业务在其上拓展。</p>
</li>
</ul>
<h2 id="工厂方法模式的优点"><a href="#工厂方法模式的优点" class="headerlink" title="工厂方法模式的优点"></a>工厂方法模式的优点</h2><ul>
<li>良好的封装性，代码结构清晰，调用者不用关系具体的实现过程，只需要提供对应的产品类名称即可。</li>
<li>易扩展性，在增加产品类的情况下，只需要适当的修改工厂类逻辑或者重新拓展一个工厂类即可。</li>
<li>屏蔽了产品类，产品类的变化调用者不用关心。比如在使用<code>JDBC</code>连接数据库时，只需要改动一个驱动的名称，数据库就会从<code>Mysql</code>切换到<code>Oracle</code>，极其灵活。</li>
</ul>
<h2 id="工厂方法模式的升级"><a href="#工厂方法模式的升级" class="headerlink" title="工厂方法模式的升级"></a>工厂方法模式的升级</h2><ul>
<li>在复杂的系统中，一个产品的初始化过程是及其复杂的，仅仅一个具体工厂实现可能有些吃力，此时最好的做法就是为每个产品实现一个工厂，达到一个工厂类只负责生产一个产品。</li>
<li>此时工厂方法模式的类图如下：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/2.png" alt=""></p>
<ul>
<li>如上图，每个产品类都对应了一个工厂，一个工厂只负责生产一个产品，非常符合单一职责原则。</li>
<li>针对上述的升级过程，那么工厂方法中不需要传入抽象产品类了，因为一个工厂只负责一个产品的生产，此时的抽象工厂类如下：<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 工厂方法，需要子类实现</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T extends Product&gt; <span class="function">T <span class="title">create</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Spring底层如何使用工厂方法模式？"><a href="#Spring底层如何使用工厂方法模式？" class="headerlink" title="Spring底层如何使用工厂方法模式？"></a>Spring底层如何使用工厂方法模式？</h2><ul>
<li>工厂方法模式在Spring底层被广泛的使用，陈某今天举个最常用的例子就是<code>AbstractFactoryBean</code>。</li>
<li>这个抽象工厂很熟悉了，这里不再讨论具体的作用。其实现了<code>FactoryBean</code>接口，这个接口中<code>getObject()</code>方法返回真正的Bean实例。</li>
<li><p><code>AbstractFactoryBean</code>中的<code>getObject()</code>方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">//单例，从缓存中取，或者暴露一个早期实例解决循环引用</span></div><div class="line">		<span class="keyword">if</span> (isSingleton()) &#123;</div><div class="line">			<span class="keyword">return</span> (<span class="keyword">this</span>.initialized ? <span class="keyword">this</span>.singletonInstance : getEarlySingletonInstance());</div><div class="line">		&#125;</div><div class="line">    <span class="comment">//多实例</span></div><div class="line">		<span class="keyword">else</span> &#123; </div><div class="line">      <span class="comment">//调用createInstance</span></div><div class="line">			<span class="keyword">return</span> createInstance();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">  <span class="comment">//创建对象</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title">createInstance</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>从以上代码可以看出，创建对象的职责交给了<code>createInstance</code>这个抽象方法，由其子类去定制自己的创建逻辑。</p>
</li>
<li>下图显示了继承了<code>AbstractFactoryBean</code>的具体工厂类，如下：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/3.png" alt=""></p>
<ul>
<li>其实与其说<code>AbstractFactoryBean</code>是抽象工厂类，不如说<code>FactoryBean</code>是真正的抽象工厂类，前者只是对后者的一种增强，完成大部分的可复用的逻辑。比如常用的<code>sqlSessionFactoryBean</code>只是简单的实现了<code>FactoryBean</code>，并未继承<code>AbstractFactoryBean</code>，至于结论如何，具体看你从哪方面看了。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>工厂方法模式是一种常见的设计模式，但是真正能够用的高级，用的透彻还是有些难度的，开发者所能做的就是在此模式基础上思考如何优化自己的代码，达到易扩展、封装性强的效果了。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>这类注解都不知道，还好意思说用过Spring Boot~</title>
    <url>/2020/10/20/%E8%BF%99%E7%B1%BB%E6%B3%A8%E8%A7%A3%E9%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%EF%BC%8C%E8%BF%98%E5%A5%BD%E6%84%8F%E6%80%9D%E8%AF%B4%E7%94%A8%E8%BF%87Spring%20Boot/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不知道大家在使用Spring Boot开发的日常中有没有用过<code>@Conditionalxxx</code>注解，比如<code>@ConditionalOnMissingBean</code>。相信看过Spring Boot源码的朋友一定不陌生。</p>
<p><code>@Conditionalxxx</code>这类注解表示某种判断条件成立时才会执行相关操作。掌握该类注解，有助于日常开发，框架的搭建。</p>
<p>今天这篇文章就从前世今生介绍一下该类注解。</p>
<a id="more"></a>
<h2 id="Spring-Boot-版本"><a href="#Spring-Boot-版本" class="headerlink" title="Spring Boot 版本"></a>Spring Boot 版本</h2><p>本文基于的Spring Boot的版本是<code>2.3.4.RELEASE</code>。</p>
<h2 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h2><p><code>@Conditional</code>注解是从<code>Spring4.0</code>才有的，可以用在任何类型或者方法上面，通过<code>@Conditional</code>注解可以配置一些条件判断，当所有条件都满足的时候，被<code>@Conditional</code>标注的目标才会被<code>Spring容器</code>处理。</p>
<p><code>@Conditional</code>的使用很广，比如控制某个<code>Bean</code>是否需要注册，在Spring Boot中的变形很多，比如<code>@ConditionalOnMissingBean</code>、<code>@ConditionalOnBean</code>等等，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E7%AC%AC%E5%8D%81%E4%B8%80%E5%BC%B9%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%B3%A8%E8%A7%A3%E9%83%BD%E4%B8%8D%E6%87%82%EF%BC%8C%E5%A5%BD%E6%84%8F%E6%80%9D%E8%AF%B4%E4%BC%9ASpring%20Boot%EF%BC%9F/1.png" alt=""></p>
<p>该注解的源码其实很简单，只有一个属性<code>value</code>，表示判断的条件（一个或者多个），是<code>org.springframework.context.annotation.Condition</code>类型，源码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Conditional &#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * All &#123;<span class="doctag">@link</span> Condition&#125; classes that must &#123;<span class="doctag">@linkplain</span> Condition#matches match&#125;</div><div class="line">	 * in order for the component to be registered.</div><div class="line">	 */</div><div class="line">	Class&lt;? extends Condition&gt;[] value();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>@Conditional</code>注解实现的原理很简单，就是通过<code>org.springframework.context.annotation.Condition</code>这个接口判断是否应该执行操作。</p>
<h2 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h2><p><code>@Conditional</code>注解判断条件与否取决于<code>value</code>属性指定的<code>Condition</code>实现，其中有一个<code>matches()</code>方法，返回<code>true</code>表示条件成立，反之不成立，接口如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><code>matches</code>中的两个参数如下：</strong></p>
<ol>
<li><code>context</code>：条件上下文，<code>ConditionContext</code>接口类型的，可以用来获取容器中上下文信息。</li>
<li><code>metadata</code>：用来获取被<code>@Conditional</code>标注的对象上的所有注解信息</li>
</ol>
<h3 id="ConditionContext接口"><a href="#ConditionContext接口" class="headerlink" title="ConditionContext接口"></a>ConditionContext接口</h3><p>这个接口很重要，能够从中获取Spring上下文的很多信息，比如<code>ConfigurableListableBeanFactory</code>，源码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConditionContext</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 返回bean定义注册器，可以通过注册器获取bean定义的各种配置信息</div><div class="line">     */</div><div class="line">    <span class="function">BeanDefinitionRegistry <span class="title">getRegistry</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 返回ConfigurableListableBeanFactory类型的bean工厂，相当于一个ioc容器对象</div><div class="line">     */</div><div class="line">    <span class="meta">@Nullable</span></div><div class="line">    <span class="function">ConfigurableListableBeanFactory <span class="title">getBeanFactory</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 返回当前spring容器的环境配置信息对象</div><div class="line">     */</div><div class="line">    <span class="function">Environment <span class="title">getEnvironment</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 返回资源加载器</div><div class="line">     */</div><div class="line">    <span class="function">ResourceLoader <span class="title">getResourceLoader</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 返回类加载器</div><div class="line">     */</div><div class="line">    <span class="meta">@Nullable</span></div><div class="line">    <span class="function">ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="如何自定义Condition？"><a href="#如何自定义Condition？" class="headerlink" title="如何自定义Condition？"></a>如何自定义Condition？</h2><p>举个栗子：<strong>假设有这样一个需求，需要根据运行环境注入不同的<code>Bean</code>，<code>Windows</code>环境和<code>Linux</code>环境注入不同的<code>Bean</code>。</strong></p>
<p>实现很简单，分别定义不同环境的判断条件，实现<code>org.springframework.context.annotation.Condition</code>即可。</p>
<p><strong>windows环境的判断条件源码如下</strong>：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 操作系统的匹配条件，如果是windows系统，则返回true</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowsCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext conditionContext, AnnotatedTypeMetadata metadata)</span> </span>&#123;</div><div class="line">        <span class="comment">//获取当前环境信息</span></div><div class="line">        Environment environment = conditionContext.getEnvironment();</div><div class="line">        <span class="comment">//获得当前系统名</span></div><div class="line">        String property = environment.getProperty(<span class="string">"os.name"</span>);</div><div class="line">        <span class="comment">//包含Windows则说明是windows系统，返回true</span></div><div class="line">        <span class="keyword">if</span> (property.contains(<span class="string">"Windows"</span>))&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>Linux环境判断源码如下</strong>：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 操作系统的匹配条件，如果是windows系统，则返回true</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinuxCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext conditionContext, AnnotatedTypeMetadata metadata)</span> </span>&#123;</div><div class="line">        Environment environment = conditionContext.getEnvironment();</div><div class="line"></div><div class="line">        String property = environment.getProperty(<span class="string">"os.name"</span>);</div><div class="line">        <span class="keyword">if</span> (property.contains(<span class="string">"Linux"</span>))&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>配置类中结合<code>@Bean</code>注入不同的Bean，如下</strong>：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 在Windows环境下注入的Bean为winP</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span>(<span class="string">"winP"</span>)</div><div class="line">    <span class="meta">@Conditional</span>(value = &#123;WindowsCondition.class&#125;)</div><div class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">personWin</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 在Linux环境下注入的Bean为LinuxP</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span>(<span class="string">"LinuxP"</span>)</div><div class="line">    <span class="meta">@Conditional</span>(value = &#123;LinuxCondition.class&#125;)</div><div class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">personLinux</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><strong>简单的测试一下，如下</strong>：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@SpringBootTest</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringbootInterceptApplicationTests</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</div><div class="line">    <span class="meta">@Qualifier</span>(value = <span class="string">"winP"</span>)</div><div class="line">    <span class="keyword">private</span> Person winP;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</div><div class="line">    <span class="meta">@Qualifier</span>(value = <span class="string">"LinuxP"</span>)</div><div class="line">    <span class="keyword">private</span> Person linP;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(winP);</div><div class="line">        System.out.println(linP);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>Windows环境下执行单元测试，输出如下</strong>：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">com.example.springbootintercept.domain.Person@<span class="number">885e7f</span>f</div><div class="line"><span class="keyword">null</span></div></pre></td></tr></table></figure></p>
<p>很显然，判断生效了，Windows环境下只注入了<code>WINP</code>。</p>
<h2 id="条件判断在什么时候执行？"><a href="#条件判断在什么时候执行？" class="headerlink" title="条件判断在什么时候执行？"></a>条件判断在什么时候执行？</h2><p>条件判断的执行分为两个阶段，如下：</p>
<ol>
<li><p><strong>配置类解析阶段(<code>ConfigurationPhase.PARSE_CONFIGURATION</code>)</strong>：在这个阶段会得到一批配置类的信息和一些需要注册的<code>Bean</code>。</p>
</li>
<li><p><strong>Bean注册阶段(<code>ConfigurationPhase.REGISTER_BEAN</code>)</strong>：将配置类解析阶段得到的配置类和需要注册的Bean注入到容器中。</p>
</li>
</ol>
<p>默认都是配置解析阶段，其实也就够用了，但是在Spring Boot中使用了<code>ConfigurationCondition</code>，这个接口可以自定义执行阶段，比如<code>@ConditionalOnMissingBean</code>都是在Bean注册阶段执行，因为需要从容器中判断Bean。</p>
<blockquote>
<p><strong>这个两个阶段有什么不同呢？</strong>：其实很简单的，配置类解析阶段只是将需要加载配置类和一些Bean（被<code>@Conditional</code>注解过滤掉之后）收集起来，而Bean注册阶段是将的收集来的Bean和配置类注入到容器中，<strong>如果在配置类解析阶段执行<code>Condition</code>接口的<code>matches()</code>接口去判断某些Bean是否存在IOC容器中，这个显然是不行的，因为这些Bean还未注册到容器中</strong>。</p>
<p><strong>什么是配置类，有哪些？</strong>：类上被<code>@Component</code>、 <code>@ComponentScan</code>、<code>@Import</code>、<code>@ImportResource</code>、<code>@Configuration</code>标注的以及类中方法有<code>@Bean</code>的方法。如何判断配置类，在源码中有单独的方法：<code>org.springframework.context.annotation.ConfigurationClassUtils#isConfigurationCandidate</code>。</p>
</blockquote>
<h2 id="ConfigurationCondition接口"><a href="#ConfigurationCondition接口" class="headerlink" title="ConfigurationCondition接口"></a>ConfigurationCondition接口</h2><p>这个接口相比于<code>@Condition</code>接口就多了一个<code>getConfigurationPhase()</code>方法，可以自定义执行阶段。源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurationCondition</span> <span class="keyword">extends</span> <span class="title">Condition</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 条件判断的阶段，是在解析配置类的时候过滤还是在创建bean的时候过滤</div><div class="line">     */</div><div class="line">    <span class="function">ConfigurationPhase <span class="title">getConfigurationPhase</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 表示阶段的枚举：2个值</div><div class="line">     */</div><div class="line">    <span class="keyword">enum</span> ConfigurationPhase &#123;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 配置类解析阶段，如果条件为false，配置类将不会被解析</div><div class="line">         */</div><div class="line">        PARSE_CONFIGURATION,</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * bean注册阶段，如果为false，bean将不会被注册</div><div class="line">         */</div><div class="line">        REGISTER_BEAN</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个接口在需要指定执行阶段的时候可以实现，比如需要根据某个Bean是否在IOC容器中来注入指定的Bean，则需要指定执行阶段为<strong>Bean的注册阶段</strong>（<code>ConfigurationPhase.REGISTER_BEAN</code>）。</p>
<h2 id="多个Condition的执行顺序"><a href="#多个Condition的执行顺序" class="headerlink" title="多个Condition的执行顺序"></a>多个Condition的执行顺序</h2><p><code>@Conditional</code>中的<code>Condition</code>判断条件可以指定多个，默认是按照先后顺序执行，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Condition1</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName());</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Condition2</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName());</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Condition3</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName());</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@Conditional</span>(&#123;Condition1.class, Condition2.class, Condition3.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig5</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>上述例子会依次按照<code>Condition1</code>、<code>Condition2</code>、<code>Condition3</code>执行。</strong></p>
<p>默认按照先后顺序执行，但是当我们需要指定顺序呢？很简单，有如下三种方式：</p>
<ol>
<li>实现<code>PriorityOrdered</code>接口，指定优先级</li>
<li>实现<code>Ordered</code>接口接口，指定优先级</li>
<li>使用<code>@Order</code>注解来指定优先级</li>
</ol>
<p>例子如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Order</span>(<span class="number">1</span>) </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Condition1</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName());</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Condition2</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">Ordered</span> </span>&#123; </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName());</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123; </div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Condition3</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">PriorityOrdered</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName());</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1000</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@Conditional</span>(&#123;Condition1.class, Condition2.class, Condition3.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig6</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据排序的规则，<code>PriorityOrdered</code>的会排在前面，然后会再按照<code>order</code>升序，最后可以顺序是：<code>Condtion3-&gt;Condtion2-&gt;Condtion1</code></p>
<h2 id="Spring-Boot中常用的一些注解"><a href="#Spring-Boot中常用的一些注解" class="headerlink" title="Spring Boot中常用的一些注解"></a>Spring Boot中常用的一些注解</h2><p>Spring Boot中大量使用了这些注解，常见的注解如下：</p>
<ol>
<li><code>@ConditionalOnBean</code>：当容器中有指定Bean的条件下进行实例化。</li>
<li><code>@ConditionalOnMissingBean</code>：当容器里没有指定Bean的条件下进行实例化。</li>
<li><code>@ConditionalOnClass</code>：当classpath类路径下有指定类的条件下进行实例化。</li>
<li><code>@ConditionalOnMissingClass</code>：当类路径下没有指定类的条件下进行实例化。</li>
<li><code>@ConditionalOnWebApplication</code>：当项目是一个Web项目时进行实例化。</li>
<li><code>@ConditionalOnNotWebApplication</code>：当项目不是一个Web项目时进行实例化。</li>
<li><code>@ConditionalOnProperty</code>：当指定的属性有指定的值时进行实例化。</li>
<li><code>@ConditionalOnExpression</code>：基于SpEL表达式的条件判断。</li>
<li><code>@ConditionalOnJava</code>：当JVM版本为指定的版本范围时触发实例化。</li>
<li><code>@ConditionalOnResource</code>：当类路径下有指定的资源时触发实例化。</li>
<li><code>@ConditionalOnJndi</code>：在JNDI存在的条件下触发实例化。</li>
<li><code>@ConditionalOnSingleCandidate</code>：当指定的Bean在容器中只有一个，或者有多个但是指定了首选的Bean时触发实例化。</li>
</ol>
<p>比如在<code>WEB</code>模块的自动配置类<code>WebMvcAutoConfiguration</code>下有这样一段代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">  <span class="meta">@Bean</span></div><div class="line"><span class="meta">@ConditionalOnMissingBean</span></div><div class="line"><span class="function"><span class="keyword">public</span> InternalResourceViewResolver <span class="title">defaultViewResolver</span><span class="params">()</span> </span>&#123;</div><div class="line">	InternalResourceViewResolver resolver = <span class="keyword">new</span> InternalResourceViewResolver();</div><div class="line">	resolver.setPrefix(<span class="keyword">this</span>.mvcProperties.getView().getPrefix());</div><div class="line">	resolver.setSuffix(<span class="keyword">this</span>.mvcProperties.getView().getSuffix());</div><div class="line">	<span class="keyword">return</span> resolver;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>常见的<code>@Bean</code>和<code>@ConditionalOnMissingBean</code>注解结合使用，意思是当容器中没有<code>InternalResourceViewResolver</code>这种类型的Bean才会注入。这样写有什么好处呢？好处很明显，可以让开发者自定义需要的视图解析器，如果没有自定义，则使用默认的，这就是Spring Boot为自定义配置提供的便利。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>@Conditional</code>注解在Spring Boot中演变的注解很多，需要着重了解，特别是后期框架整合的时候会大量涉及。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png" alt=""></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式：模板模式</title>
    <url>/2020/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>模板模式在是Spring底层被广泛的应用，比如事务管理器的实现，JDBC模板的实现。</li>
<li>今天就来谈谈<strong>什么是模板模式</strong>、<strong>模板模式的优缺点</strong>、<strong>模板模式的简单演示</strong>、<strong>模板模式在Spring底层的实现</strong>。</li>
</ul>
<h2 id="什么是模板模式"><a href="#什么是模板模式" class="headerlink" title="什么是模板模式"></a>什么是模板模式</h2><ul>
<li>模板模式首先要有一个抽象类，这个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。</li>
<li>定义：<strong>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</strong></li>
<li>比如在造房子一样，<code>地基</code>，<code>铺线</code>，<code>房子户型</code>都是一样的，由开发商决定，但是在交房之后，室内的<code>装修风格</code>和<code>场景布置</code>却是由业主决定，在这个场景中，开发商其实就是一个抽象类，地基，铺线，房子户型都是可以复用的，但是装修却是不可复用的，必须由业主决定，此时的每一个业主的房子就是一个实现的子类。</li>
<li>模板方法的实现条件注意：<ol>
<li>必须是一个抽象类。</li>
<li>抽象类有一个模板方法，其中定义了算法骨架。</li>
<li>为了防止恶意操作，模板方法必须加上<code>final</code>关键词。</li>
<li>模板方法中除了复用的代码，其他的关键代码必须是抽象的，子类可以继承实现。</li>
</ol>
</li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。</li>
<li>它在父类中提取了公共的部分代码，便于代码复用。</li>
<li>部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</li>
<li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li>
</ul>
<h2 id="简单演示"><a href="#简单演示" class="headerlink" title="简单演示"></a>简单演示</h2><ul>
<li>比如游戏的运行需要如下几个步骤：<ol>
<li>初始化游戏</li>
<li>开始游戏</li>
<li>结束游戏</li>
</ol>
</li>
<li>上述的三个步骤可以是模板类的抽象方法，由具体的子类实现，比如足球游戏。</li>
<li><p>定义模板类，必须是一个抽象类，模板方法必须是<code>final</code>修饰。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</div><div class="line">    <span class="comment">//抽象方法</span></div><div class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</div><div class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span></span>;</div><div class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span></span>;</div><div class="line"> </div><div class="line">   <span class="comment">//模板方法</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</div><div class="line"> </div><div class="line">      <span class="comment">//初始化游戏</span></div><div class="line">      initialize();</div><div class="line"> </div><div class="line">      <span class="comment">//开始游戏</span></div><div class="line">      startPlay();</div><div class="line"> </div><div class="line">      <span class="comment">//结束游戏</span></div><div class="line">      endPlay();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>定义实现类，足球游戏，继承模板类，实现其中的三个抽象方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Football</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</div><div class="line"> </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"足球游戏结束......"</span>);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"足球游戏初始化中......"</span>);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"足球游侠开始了......"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>此时写一个测试方法，运行足球游戏，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplatePatternDemo</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      <span class="comment">//创建足球游戏实例</span></div><div class="line">      Game game = <span class="keyword">new</span> Football();</div><div class="line">      <span class="comment">//开始游戏</span></div><div class="line">      game.play();      </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>输出结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">足球游戏初始化中......</div><div class="line">足球游侠开始了......</div><div class="line">足球游戏结束......</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Spring中的模板模式"><a href="#Spring中的模板模式" class="headerlink" title="Spring中的模板模式"></a>Spring中的模板模式</h2><ul>
<li>Spring底层对于模板模式的使用有很多处，今天陈某带大家康康事务管理器是如何使用模板模式的。</li>
</ul>
<h3 id="模板抽象类"><a href="#模板抽象类" class="headerlink" title="模板抽象类"></a>模板抽象类</h3><ul>
<li><code>AbstractPlatformTransactionManager</code>是Spring中的<code>模板抽象类</code>，来看看它的继承关系图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/1.png" alt=""></li>
<li>实现了<code>PlatformTransactionManager</code>接口，重载了接口中的方法。</li>
</ul>
<h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><ul>
<li><p>事务管理器中抽象类中的模板方法不止一个，比如以下两个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//提交事务</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span></span></div><div class="line"></div><div class="line"><span class="comment">//获取TransactionStatus</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title">getTransaction</span><span class="params">()</span></div></pre></td></tr></table></figure>
</li>
<li><p>这两个方法都对于自己要实现的逻辑搭建了一个骨架，主要的功能是由抽象方法完成，由子类来完成。</p>
</li>
</ul>
<h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><ul>
<li><p>事务管理器抽象类中的抽象方法定义了多个，分别用于处理不同的业务逻辑，由子类实现其中具体的逻辑，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//提交事务</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doCommit</span><span class="params">(DefaultTransactionStatus status)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//回滚事务</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doRollback</span><span class="params">(DefaultTransactionStatus status)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//开始事务</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doBegin</span><span class="params">(Object transaction, TransactionDefinition definition)</span></span></div><div class="line"></div><div class="line"><span class="comment">//获取当前的事务对象</span></div><div class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">doGetTransaction</span><span class="params">()</span></div></pre></td></tr></table></figure>
</li>
<li><p>抽象方法的定义便于子类去扩展，在保证算法逻辑不变的情况下，子类能够定制自己的实现。</p>
</li>
</ul>
<h3 id="具体子类"><a href="#具体子类" class="headerlink" title="具体子类"></a>具体子类</h3><ul>
<li>事务管理器的模板类有很多的具体子类，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/2.png" alt=""></li>
<li>其中我们熟悉的有<code>DataSourceTransactionManager</code>、<code>JtaTransactionManager</code>、<code>RabbitTransactionManager</code>。具体承担什么样的角色和责任不是本节的重点，不再细说。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>模板模式是一个很重要，易扩展的模式，提高了代码复用性，在Spring中有着广泛的应用，比如<code>JDBCTemplate</code>,<code>AbstractPlatformTransactionManager</code>，这些实现都用到了模板模式。</li>
<li>如果觉得陈某的文章能够对你有所帮助，有所启发，关注分享一波，点个在看，谢谢支持！！！</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>面试官问：Mybatis中的TypeHandler你用过吗？</title>
    <url>/2020/04/20/%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%EF%BC%9AMybatis%E4%B8%AD%E7%9A%84TypeHandler%E4%BD%A0%E7%94%A8%E8%BF%87%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><p>相信大家用Mybatis这个框架至少一年以上了吧，有没有思考过这样一个问题：数据库有自己的数据类型，Java有自己的数据类型，那么Mybatis是如何把数据库中的类型和Java的数据类型对应的呢？</p>
</li>
<li><p>本篇文章就来讲讲Mybatis中的<code>黑匣子TypeHandler(类型处理器)</code>，说它是黑匣子一点都不为过，总是在默默的奉献着，但是不为人知。</p>
<a id="more"></a>
</li>
</ul>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ul>
<li>本篇文章讲的一切内容都是基于<code>Mybatis3.5</code>和<code>SpringBoot-2.3.3.RELEASE</code>。</li>
</ul>
<h2 id="什么是TypeHandler？"><a href="#什么是TypeHandler？" class="headerlink" title="什么是TypeHandler？"></a>什么是TypeHandler？</h2><ul>
<li><p>顾名思义，类型处理器，将入参和结果转换为所需要的类型，Mybatis中对于内置了许多类型处理器，实际开发中已经足够使用了，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E4%B8%AD%E7%9A%84TypeHandler/1.png" alt=""><br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E4%B8%AD%E7%9A%84TypeHandler/2.png" alt=""></p>
</li>
<li><p>类型处理器这个接口其实很简单，总共四个方法，一个方法将入参的Java类型的数据转换为JDBC类型，三个方法将返回结果转换为Java类型。源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">  <span class="comment">//设置参数，java类型转换为jdbc类型</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, T parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException</span>;</div><div class="line">  <span class="comment">//将查询的结果转换为java类型</span></div><div class="line">  <span class="function">T <span class="title">getResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException</span>;</div><div class="line"></div><div class="line">  <span class="function">T <span class="title">getResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span>;</div><div class="line"></div><div class="line">  <span class="function">T <span class="title">getResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="如何自定义并使用TypeHandler？"><a href="#如何自定义并使用TypeHandler？" class="headerlink" title="如何自定义并使用TypeHandler？"></a>如何自定义并使用TypeHandler？</h2><ul>
<li>实际应用开发中的难免会有一些需求要自定义一个<code>TypeHandler</code>，比如这样一个需求：前端传来的年龄是<code>男</code>,<code>女</code>，但是数据库定义的字段却是<code>int</code>类型（<code>1男2女</code>）。此时可以自定义一个年龄的类型处理器，进行转换。</li>
</ul>
<h3 id="如何自定义？"><a href="#如何自定义？" class="headerlink" title="如何自定义？"></a>如何自定义？</h3><ul>
<li>自定义的方式有两种，一种是实现<code>TypeHandler</code>这个接口，另一个就是继承<code>BaseTypeHandler</code>这个便捷的抽象类。</li>
<li><p>下面直接继承<code>BaseTypeHandler</code>这个抽象类，定义一个年龄的类型处理器，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@MappedJdbcTypes</span>(JdbcType.INTEGER)</div><div class="line"><span class="meta">@MappedTypes</span>(String.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenderTypeHandler</span> <span class="keyword">extends</span> <span class="title">BaseTypeHandler</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//设置参数，这里将Java的String类型转换为JDBC的Integer类型</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, Object parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        ps.setInt(i, StringUtils.equals(parameter.toString(),<span class="string">"男"</span>)?<span class="number">1</span>:<span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//以下三个参数都是将查询的结果转换</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">return</span> rs.getInt(columnName)==<span class="number">1</span>?<span class="string">"男"</span>:<span class="string">"女"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getNullableResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">return</span> rs.getInt(columnIndex)==<span class="number">1</span>?<span class="string">"男"</span>:<span class="string">"女"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getNullableResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">return</span> cs.getInt(columnIndex)==<span class="number">1</span>?<span class="string">"男"</span>:<span class="string">"女"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>这里涉及到两个注解，如下：</p>
<ul>
<li><code>@MappedTypes</code>：指定与其关联的 <code>Java</code> 类型列表。 如果在 <code>javaType</code> 属性中也同时指定，则注解上的配置将被忽略。</li>
<li><code>@MappedJdbcTypes</code>：指定与其关联的 <code>JDBC</code> 类型列表。 如果在 <code>jdbcType</code> 属性中也同时指定，则注解上的配置将被忽略。</li>
</ul>
</li>
</ul>
<h3 id="如何将其添加到Mybatis中？"><a href="#如何将其添加到Mybatis中？" class="headerlink" title="如何将其添加到Mybatis中？"></a>如何将其添加到Mybatis中？</h3><ul>
<li>Mybatis在与SpringBoot整合之后一切都变得很简单了，其实这里有两种配置方式，下面将会一一介绍。</li>
<li><p><strong>第一种</strong>：只需要在配置文件<code>application.properties</code>中添加一行配置即可，如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">## 设置自定义的Typehandler所在的包，启动的时候会自动扫描配置到Mybatis中</div><div class="line">mybatis.type-handlers-package=cn.cb.demo.typehandler</div></pre></td></tr></table></figure>
</li>
<li><p><strong>第二种</strong>：其实任何框架与Springboot整合之后，只要配置文件中能够配置的，在配置类中都可以配置（<strong>除非有特殊定制，否则不要轻易覆盖自动配置</strong>）。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Bean</span>(<span class="string">"sqlSessionFactory"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</div><div class="line">        sqlSessionFactoryBean.setDataSource(dataSource);</div><div class="line">        sqlSessionFactoryBean.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver().getResources(MAPPER_LOCATOIN));</div><div class="line">        org.apache.ibatis.session.Configuration configuration = <span class="keyword">new</span> org.apache.ibatis.session.Configuration();</div><div class="line">        <span class="comment">// 自动将数据库中的下划线转换为驼峰格式</span></div><div class="line">        configuration.setMapUnderscoreToCamelCase(<span class="keyword">true</span>);</div><div class="line">        configuration.setDefaultFetchSize(<span class="number">100</span>);</div><div class="line">        configuration.setDefaultStatementTimeout(<span class="number">30</span>);</div><div class="line">        sqlSessionFactoryBean.setConfiguration(configuration);</div><div class="line">        <span class="comment">//将typehandler注册到mybatis</span></div><div class="line">        GenderTypeHandler genderTypeHandler = <span class="keyword">new</span> GenderTypeHandler();</div><div class="line">        TypeHandler[] typeHandlers=<span class="keyword">new</span> TypeHandler[]&#123;genderTypeHandler&#125;;</div><div class="line">        sqlSessionFactoryBean.setTypeHandlers(typeHandlers);</div><div class="line">        <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>第二种方式的思想其实就是重写自动配置类<code>MybatisAutoConfiguration</code>中的方法。<strong>注意：除非自己有特殊定制，否则不要轻易重写自动配置类中的方法</strong>。</p>
</li>
</ul>
<h3 id="XML文件中如何指定TypeHandler？"><a href="#XML文件中如何指定TypeHandler？" class="headerlink" title="XML文件中如何指定TypeHandler？"></a>XML文件中如何指定TypeHandler？</h3><ul>
<li>上面的两个步骤分别是自定义和注入到Mybatis中，那么如何在<code>XML</code>文件中使用呢？</li>
<li>使用其实很简单，分为两种，一种是<code>更新</code>，一种<code>查询</code>，下面将会一一介绍。</li>
<li><p><strong>更新</strong>：删除自不必说了，这里讲的是<code>update</code>和<code>insert</code>两种，只需要在<code>#{}</code>中指定的属性<code>typeHandler</code>为自定义的<code>全类名</code>即可，代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertUser"</span>&gt;</span></div><div class="line">        insert into user_info(user_id,his_id,name,gender,password,create_time)</div><div class="line">        values(#&#123;userId,jdbcType=VARCHAR&#125;,#&#123;hisId,jdbcType=VARCHAR&#125;,#&#123;name,jdbcType=VARCHAR&#125;,</div><div class="line">        #&#123;gender,jdbcType=INTEGER,typeHandler=cn.cb.demo.typehandler.GenderTypeHandler&#125;,#&#123;password,jdbcType=VARCHAR&#125;,now())</div><div class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>查询</strong>：查询的时候类型处理会将JDBC类型的转化为Java类型，因此也是需要指定<code>typeHandler</code>，需要在<code>resultMap</code>中指定<code>typeHandler</code>这个属性，值为<code>全类名</code>，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userResultMap"</span> <span class="attr">type</span>=<span class="string">"cn.cb.demo.domain.UserInfo"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"user_id"</span> <span class="attr">property</span>=<span class="string">"userId"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"his_id"</span> <span class="attr">property</span>=<span class="string">"hisId"</span>/&gt;</span></div><div class="line">            <span class="comment">&lt;!-- 指定typeHandler属性为全类名--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"gender"</span> <span class="attr">property</span>=<span class="string">"gender"</span> <span class="attr">typeHandler</span>=<span class="string">"cn.cb.demo.typehandler.GenderTypeHandler"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"password"</span> <span class="attr">property</span>=<span class="string">"password"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectList"</span> <span class="attr">resultMap</span>=<span class="string">"userResultMap"</span>&gt;</span></div><div class="line">        select * from user_info where status=1</div><div class="line">        and user_id in</div><div class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"userIds"</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">separator</span>=<span class="string">","</span> <span class="attr">close</span>=<span class="string">")"</span> &gt;</span></div><div class="line">            #&#123;item&#125;</div><div class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="源码中如何执行TypeHandler？"><a href="#源码中如何执行TypeHandler？" class="headerlink" title="源码中如何执行TypeHandler？"></a>源码中如何执行TypeHandler？</h2><ul>
<li>既然会使用<code>TypeHandler</code>了，那么肯定要知道其中的执行原理了，在Mybatis中类型处理器是如何在<code>JDBC</code>类型和<code>Java</code>类型进行转换的，下面的将从源码角度详细介绍。</li>
</ul>
<h3 id="入参如何转换？"><a href="#入参如何转换？" class="headerlink" title="入参如何转换？"></a>入参如何转换？</h3><ul>
<li><p>这个肯定是发生在设置参数的过程中，详细的代码在<code>PreparedStatementHandler</code>中的<code>parameterize()</code>方法中，这个方法就是设置参数的方法。源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="comment">//实际调用的是DefaultParameterHandler</span></div><div class="line">   parameterHandler.setParameters((PreparedStatement) statement);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>实际执行的是<code>DefaultParameterHandler</code>中的<code>setParameters</code>方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span> </span>&#123;</div><div class="line">    ErrorContext.instance().activity(<span class="string">"setting parameters"</span>).object(mappedStatement.getParameterMap().getId());</div><div class="line">    <span class="comment">//获取参数映射</span></div><div class="line">    List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</div><div class="line">    <span class="comment">//遍历参数映射，一一设置</span></div><div class="line">    <span class="keyword">if</span> (parameterMappings != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterMappings.size(); i++) &#123;</div><div class="line">        ParameterMapping parameterMapping = parameterMappings.get(i);</div><div class="line">        <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</div><div class="line">          Object value;</div><div class="line">          String propertyName = parameterMapping.getProperty();</div><div class="line">          <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123; <span class="comment">// issue #448 ask first for additional params</span></div><div class="line">            value = boundSql.getAdditionalParameter(propertyName);</div><div class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</div><div class="line">            value = <span class="keyword">null</span>;</div><div class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</div><div class="line">            value = parameterObject;</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">            MetaObject metaObject = configuration.newMetaObject(parameterObject);</div><div class="line">            value = metaObject.getValue(propertyName);</div><div class="line">          &#125;</div><div class="line">          <span class="comment">//获取类型处理器，如果不存在，使用默认的</span></div><div class="line">          TypeHandler typeHandler = parameterMapping.getTypeHandler();    </div><div class="line">          <span class="comment">//JdbcType</span></div><div class="line">          JdbcType jdbcType = parameterMapping.getJdbcType();</div><div class="line">          <span class="keyword">if</span> (value == <span class="keyword">null</span> &amp;&amp; jdbcType == <span class="keyword">null</span>) &#123;</div><div class="line">            jdbcType = configuration.getJdbcTypeForNull();</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//调用类型处理器中的方法设置参数，将Java类型转换为JDBC类型</span></div><div class="line">            typeHandler.setParameter(ps, i + <span class="number">1</span>, value, jdbcType);</div><div class="line">          &#125; <span class="keyword">catch</span> (TypeException e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">"Could not set parameters for mapping: "</span> + parameterMapping + <span class="string">". Cause: "</span> + e, e);</div><div class="line">          &#125; <span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">"Could not set parameters for mapping: "</span> + parameterMapping + <span class="string">". Cause: "</span> + e, e);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>从上面的源码中可以知道这行代码<code>typeHandler.setParameter(ps, i + 1, value, jdbcType);</code>就是调用类型处理器中的设置参数的方法，将<code>Java</code>类型转换为<code>JDBC</code>类型。</p>
</li>
</ul>
<h3 id="结果如何转换？"><a href="#结果如何转换？" class="headerlink" title="结果如何转换？"></a>结果如何转换？</h3><ul>
<li>这一过程肯定是发生在执行查询语句的过程中，之前也是介绍过Mybatis的六大剑客，其中的<code>ResultSetHandler</code>这个组件就是对查询的结果进行处理的，那么肯定是发生在这一组件中的某个方法。</li>
<li><p>在<code>PreparedStatementHandler</code>执行查询结束之后，调用的是<code>ResultSetHandler</code>中的<code>handleResultSets()</code>方法，对结果进行处理，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    PreparedStatement ps = (PreparedStatement) statement;</div><div class="line">    <span class="comment">//执行SQL</span></div><div class="line">    ps.execute();</div><div class="line">    <span class="comment">//处理结果</span></div><div class="line">    <span class="keyword">return</span> resultSetHandler.handleResultSets(ps);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>最终的在<code>DefaultResultHandler</code>中的<code>getPropertyMappingValue()</code>方法中调用了<code>TypeHandler</code>中的<code>getResult()</code>方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getPropertyMappingValue</span><span class="params">(ResultSet rs, MetaObject metaResultObject, ResultMapping propertyMapping, ResultLoaderMap lazyLoader, String columnPrefix)</span></span></div><div class="line">      <span class="keyword">throws</span> SQLException &#123;</div><div class="line">    <span class="keyword">if</span> (propertyMapping.getNestedQueryId() != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span> getNestedQueryMappingValue(rs, metaResultObject, propertyMapping, lazyLoader, columnPrefix);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propertyMapping.getResultSet() != <span class="keyword">null</span>) &#123;</div><div class="line">      addPendingChildRelation(rs, metaResultObject, propertyMapping);   <span class="comment">// TODO is that OK?</span></div><div class="line">      <span class="keyword">return</span> DEFERRED;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">final</span> TypeHandler&lt;?&gt; typeHandler = propertyMapping.getTypeHandler();</div><div class="line">      <span class="keyword">final</span> String column = prependPrefix(propertyMapping.getColumn(), columnPrefix);</div><div class="line">      <span class="comment">//执行typeHandler中的方法获取结果并且转换为对应的Java类型</span></div><div class="line">      <span class="keyword">return</span> typeHandler.getResult(rs, column);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>上述只是简要的介绍了类型处理器如何在Mybatis中执行的，可能其中有些概念东西如果不清楚的，可以看一下作者前面的文章，如下：<ul>
<li><a href="https://mp.weixin.qq.com/s/lnJx0h_4Kk6fKuhptN1cdg" target="_blank" rel="external">Mybatis源码解析之六剑客</a></li>
<li><a href="https://mp.weixin.qq.com/s/B9e-4y_jokLHtDnS0o6-7g" target="_blank" rel="external">Mybatis源码如何阅读，教你一招！！！</a></li>
<li><a href="https://mp.weixin.qq.com/s/sqRM4BWNv84qbd2Dh-2y4g" target="_blank" rel="external">Mybatis如何执行Select语句，你知道吗？</a></li>
</ul>
</li>
</ul>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li>本文详细的介绍了TypeHandler在Mybatis中的应用、自定义使用以及从源码角度分析了类型处理器的执行流程，如果觉得作者写的不错，有所收获的话，不妨点点关注，分享一波。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E4%B8%83%E7%A7%92%E7%BC%96%E7%A8%8B.jpg" alt=""></li>
</ul>
]]></content>
      <categories>
        <category>Mybatis进阶</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>面试官：你知道哪些事务失效的场景？</title>
    <url>/2020/04/19/%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>声明式事务是Spring功能中最爽之一，可是有些时候，我们在使用声明式事务并未生效，这是为什么呢？</li>
<li>今天陈某带大家来聊一聊声明事务的几种失效场景。本文将会从以下两个方面来说一下事务为什么会失效？<ol>
<li>@Transactional介绍</li>
<li>@Transactional失效场景</li>
</ol>
</li>
</ul>
<h2 id="Transactional介绍"><a href="#Transactional介绍" class="headerlink" title="@Transactional介绍"></a>@Transactional介绍</h2><ul>
<li><code>@Transactional</code>是声明式事务的注解，可以被标记在<code>类上</code>、<code>接口</code>、<code>方法</code>上。</li>
<li>该注解中有很多值得深入了解的几种属性，我们来看一下。</li>
</ul>
<h3 id="transactionManager"><a href="#transactionManager" class="headerlink" title="transactionManager"></a>transactionManager</h3><ul>
<li>指定事务管理器，值为<code>bean</code>的名称，这个主要用于多事务管理器情况下指定。比如多数据源配置的情况下。</li>
</ul>
<h3 id="isolation"><a href="#isolation" class="headerlink" title="isolation"></a>isolation</h3><ul>
<li>事务的隔离级别，默认是<code>Isolation.DEFAULT</code>。</li>
<li>几种值的含义如下：<ul>
<li><code>Isolation.DEFAULT</code>：事务默认的隔离级别，使用数据库默认的隔离级别。</li>
<li><code>Isolation.READ_UNCOMMITTED</code>：这是事务最低的隔离级别，它充许别外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻读。</li>
<li><code>Isolation.READ_COMMITTED</code>：保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻读。</li>
<li><code>Isolation.REPEATABLE_READ</code>：这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻读。</li>
<li><code>Isolation.SERIALIZABLE</code>：这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻读。</li>
</ul>
</li>
</ul>
<h3 id="propagation"><a href="#propagation" class="headerlink" title="propagation"></a>propagation</h3><ul>
<li>代表事务的传播行为，默认值为<code>Propagation.REQUIRED</code>。</li>
<li><code>Propagation.REQUIRED</code>：如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。比如A方法内部调用了B方法，此时B方法将会使用A方法的事务。</li>
<li><code>Propagation.MANDATORY</code>：支持当前事务，如果当前没有事务，就抛出异常。</li>
<li><code>Propagation.NEVER</code>：以非事务方式执行，如果当前存在事务，则抛出异常。</li>
<li><code>Propagation.NOT_SUPPORTED</code>：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li><code>Propagation.REQUIRES_NEW</code>：新建事务，如果当前存在事务，把当前事务挂起。比如A方法使用默认的事务传播属性，B方法使用<code>REQUIRES_NEW</code>，此时A方法在内部调用B方法，一旦A方法出现异常，A方法中的事务回滚了，但是B方法并没有回滚，因为A和B方法使用的不是同一个事务，B方法新建了一个事务。</li>
<li><code>Propagation.NESTED</code>：支持当前事务，新增<code>Savepoint</code>点，也就是在进入子事务之前，父事务建立一个回滚点，与当前事务同步提交或回滚。 子事务是父事务的一部分，在父事务还未提交时，子事务一定没有提交。嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。</li>
</ul>
<h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><ul>
<li>事务的超时时间，单位为秒。</li>
</ul>
<h3 id="readOnly"><a href="#readOnly" class="headerlink" title="readOnly"></a>readOnly</h3><ul>
<li>该属性用于设置当前事务是否为只读事务，设置为true表示只读，false则表示可读写，默认值为false。如果一个事务只涉及到只读，可以设置为true。</li>
</ul>
<h3 id="rollbackFor-属性"><a href="#rollbackFor-属性" class="headerlink" title="rollbackFor 属性"></a>rollbackFor 属性</h3><ul>
<li>用于指定能够触发事务回滚的异常类型，可以指定多个异常类型。</li>
<li>默认是在<code>RuntimeException</code>和<code>Error</code>上回滚。</li>
</ul>
<h3 id="noRollbackFor"><a href="#noRollbackFor" class="headerlink" title="noRollbackFor"></a>noRollbackFor</h3><ul>
<li>抛出指定的异常类型，不回滚事务，也可以指定多个异常类型。</li>
</ul>
<h2 id="Transactional失效场景"><a href="#Transactional失效场景" class="headerlink" title="@Transactional失效场景"></a>@Transactional失效场景</h2><ul>
<li>声明式事务失效的场景有很多，陈某这里只是罗列一下几种常见的场景。</li>
</ul>
<h3 id="底层数据库引擎不支持事务"><a href="#底层数据库引擎不支持事务" class="headerlink" title="底层数据库引擎不支持事务"></a>底层数据库引擎不支持事务</h3><ul>
<li>如果数据库引擎不支持事务，则Spring自然无法支持事务。</li>
</ul>
<h3 id="在非public修饰的方法使用"><a href="#在非public修饰的方法使用" class="headerlink" title="在非public修饰的方法使用"></a>在非public修饰的方法使用</h3><ul>
<li><p>@Transactional注解使用的是AOP，在使用动态代理的时候只能针对<code>public</code>方法进行代理，源码依据在<code>AbstractFallbackTransactionAttributeSource</code>类中的<code>computeTransactionAttribute</code>方法中，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">computeTransactionAttribute</span><span class="params">(Method method,</span></span></div><div class="line">    Class&lt;?&gt; targetClass) &#123;</div><div class="line">        <span class="comment">// Don't allow no-public methods as required.</span></div><div class="line">        <span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>此处如果不是标注在<code>public</code>修饰的方法上并不会抛出异常，但是会导致事务失效。</p>
</li>
</ul>
<h3 id="异常被-“-踹死了-“"><a href="#异常被-“-踹死了-“" class="headerlink" title="异常被 “ 踹死了 “"></a>异常被 “ 踹死了 “</h3><ul>
<li>这种情况小白是最容易犯错的，在整个事务的方法中使用<code>try-catch</code>，导致异常无法抛出，自然会导致事务失效。伪代码如下：<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Transactional</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="keyword">try</span>&#123;</div><div class="line">    <span class="comment">//插入一条数据</span></div><div class="line">    <span class="comment">//更改一条数据</span></div><div class="line">  &#125;<span class="keyword">catch</span>(Exception ex)&#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="方法中调用同类的方法"><a href="#方法中调用同类的方法" class="headerlink" title="方法中调用同类的方法"></a>方法中调用同类的方法</h3><ul>
<li>简单的说就是一个类中的<code>A方法</code>（未标注声明式事务）在内部调用了<code>B方法</code>(标注了声明式事务)，这样会导致B方法中的事务失效。</li>
<li><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//插入一条数据</span></div><div class="line">    <span class="comment">//调用B方法</span></div><div class="line">    B();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="meta">@Transactional</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//插入数据</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>为什么会失效呢？</strong>：其实原因很简单，Spring在扫描Bean的时候会自动为标注了<code>@Transactional</code>注解的类生成一个代理类（proxy）,当有注解的方法被调用的时候，实际上是代理类调用的，代理类在调用之前会开启事务，执行事务的操作，但是同类中的方法互相调用，相当于<code>this.B()</code>，此时的B方法并非是代理类调用，而是直接通过原有的Bean直接调用，所以注解会失效。</p>
</li>
<li><strong>如何解决呢？</strong>：这就涉及到注解失效的原因了，后续文章会介绍到，这里不过多介绍了。</li>
</ul>
<h3 id="rollbackFor属性设置错误"><a href="#rollbackFor属性设置错误" class="headerlink" title="rollbackFor属性设置错误"></a>rollbackFor属性设置错误</h3><ul>
<li>很容易理解，指定异常触发回滚，一旦设置错误，导致一些异常不能触发回滚，此时的声明式事务不就失效了吗。</li>
</ul>
<h3 id="noRollbackFor属性设置错误"><a href="#noRollbackFor属性设置错误" class="headerlink" title="noRollbackFor属性设置错误"></a>noRollbackFor属性设置错误</h3><ul>
<li>这个和rollbackFor属性设置错误类似，一旦设置错误，也会导致异常不能触发回滚，此时的声明式事务会失效。</li>
</ul>
<h3 id="propagation属性设置错误"><a href="#propagation属性设置错误" class="headerlink" title="propagation属性设置错误"></a>propagation属性设置错误</h3><ul>
<li>事务的传播属性在上面已经介绍了，默认的事务传播属性是<code>Propagation.REQUIRED</code>，但是一旦配置了错误的传播属性，也是会导致事务失效，如下三种配置将会导致事务失效：<ul>
<li>Propagation.SUPPORTS</li>
<li>Propagation.NOT_SUPPORTED</li>
<li>Propagation.NEVER</li>
</ul>
</li>
</ul>
<h3 id="原始SSM项目，重复扫描导致事务失效"><a href="#原始SSM项目，重复扫描导致事务失效" class="headerlink" title="原始SSM项目，重复扫描导致事务失效"></a>原始SSM项目，重复扫描导致事务失效</h3><ul>
<li>在原始的SSM项目中都配置了<code>context:component-scan</code>并且同时扫描了service层，此时事务将会失效。</li>
<li>按照Spring配置文件的加载顺序来说，会先加载Springmvc的配置文件，如果在加载Springmvc配置文件的时候把service也加载了，但是此时事务还没加载，将会导致事务无法成功生效。</li>
<li>解决方法很简单，把扫描service层的配置设置在Spring配置文件或者其他配置文件中即可。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>事务失效的原因很多，但是千万不要做到一知半解，只有深入理解了，才能在面试过程中对答如流。</li>
<li><strong>今天的文章就到此结束了，如果觉得陈某写得不错，有所收获的，关注在看来一波，你们的鼓励，将会是我写作的动力，谢谢支持！！！</strong></li>
</ul>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>面试官：讲一讲Mybatis插件的原理及如何实现？</title>
    <url>/2020/04/20/%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%AE%B2%E4%B8%80%E8%AE%B2Mybatis%E6%8F%92%E4%BB%B6%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>Mybatis的分页插件相信大家都使用过，那么可知道其中的实现原理？分页插件就是利用的Mybatis中的插件机制实现的，在<code>Executor</code>的<code>query</code>执行前后进行分页处理。</li>
<li>此篇文章就来介绍以下Mybatis的插件机制以及在底层是如何实现的。<a id="more"></a>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2></li>
<li><p>本篇文章讲的一切内容都是基于<code>Mybatis3.5</code>和<code>SpringBoot-2.3.3.RELEASE</code>。</p>
<h2 id="什么是插件？"><a href="#什么是插件？" class="headerlink" title="什么是插件？"></a>什么是插件？</h2></li>
<li>插件是Mybatis中的最重要的功能之一，能够对特定组件的特定方法进行增强。</li>
<li>MyBatis 允许你在映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：<ul>
<li><strong>Executor</strong>：<code>update</code>, <code>query</code>, <code>flushStatements</code>, <code>commit</code>, <code>rollback</code>, <code>getTransaction</code>, <code>close</code>, <code>isClosed</code></li>
<li><strong>ParameterHandler</strong>: <code>getParameterObject</code>, <code>setParameters</code></li>
<li><strong>ResultSetHandler</strong>：<code>handleResultSets</code>, <code>handleOutputParameters</code></li>
<li><strong>StatementHandler</strong>: <code>prepare</code>, <code>parameterize</code>, <code>batch</code>, <code>update</code>, <code>query</code></li>
</ul>
</li>
</ul>
<h2 id="如何自定义插件？"><a href="#如何自定义插件？" class="headerlink" title="如何自定义插件？"></a>如何自定义插件？</h2><ul>
<li><p>插件的实现其实很简单，只需要实现Mybatis提供的<code>Interceptor</code>这个接口即可，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</div><div class="line">  <span class="comment">//拦截的方法</span></div><div class="line">  <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</div><div class="line">  <span class="comment">//返回拦截器的代理对象</span></div><div class="line">  <span class="function">Object <span class="title">plugin</span><span class="params">(Object target)</span></span>;</div><div class="line">  <span class="comment">//设置一些属性</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3></li>
<li><p>有这样一个需求：需要在Mybatis执行的时候篡改<code>selectByUserId</code>的参数值。</p>
</li>
<li><strong>分析</strong>：修改SQL的入参，应该在哪个组件的哪个方法上拦截篡改呢？研究过源码的估计都很清楚的知道，<code>ParameterHandler</code>中的<code>setParameters()</code>方法就是对参数进行处理的。因此肯定是拦截这个方法是最合适。</li>
<li><p>自定义的插件如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Intercepts</span> 注解标记这是一个拦截器,其中可以指定多个<span class="doctag">@Signature</span></div><div class="line"> * <span class="doctag">@Signature</span> 指定该拦截器拦截的是四大对象中的哪个方法</div><div class="line"> *      type：拦截器的四大对象的类型</div><div class="line"> *      method：拦截器的方法，方法名</div><div class="line"> *      args：入参的类型，可以是多个，根据方法的参数指定，以此来区分方法的重载</div><div class="line"> */</div><div class="line"><span class="meta">@Intercepts</span>(</div><div class="line">        &#123;</div><div class="line">                <span class="meta">@Signature</span>(type = ParameterHandler.class,method =<span class="string">"setParameters"</span>,args = &#123;PreparedStatement.class&#125;)</div><div class="line">        &#125;</div><div class="line">)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        System.out.println(<span class="string">"拦截器执行："</span>+invocation.getTarget());</div><div class="line">        <span class="comment">//目标对象</span></div><div class="line">        Object target = invocation.getTarget();</div><div class="line">        <span class="comment">//获取目标对象中所有属性的值，因为ParameterHandler使用的是DefaultParameterHandler，因此里面的所有的属性都封装在其中</span></div><div class="line">        MetaObject metaObject = SystemMetaObject.forObject(target);</div><div class="line">        <span class="comment">//使用xxx.xxx.xx的方式可以层层获取属性值，这里获取的是mappedStatement中的id值</span></div><div class="line">        String value = (String) metaObject.getValue(<span class="string">"mappedStatement.id"</span>);</div><div class="line">        <span class="comment">//如果是指定的查询方法</span></div><div class="line">        <span class="keyword">if</span> (<span class="string">"cn.cb.demo.dao.UserMapper.selectByUserId"</span>.equals(value))&#123;</div><div class="line">            <span class="comment">//设置参数的值是admin_1，即是设置id=admin_1，因为这里只有一个参数，可以这么设置，如果有多个需要需要循环</span></div><div class="line">            metaObject.setValue(<span class="string">"parameterObject"</span>, <span class="string">"admin_1"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//执行目标方法</span></div><div class="line">        <span class="keyword">return</span> invocation.proceed();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</div><div class="line">        <span class="comment">//如果没有特殊定制，直接使用Plugin这个工具类返回一个代理对象即可</span></div><div class="line">        <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>intercept</code>方法：最终会拦截的方法，最重要的一个方法。</p>
</li>
<li><code>plugin</code>方法：返回一个代理对象，如果没有特殊要求，直接使用Mybatis的工具类<code>Plugin</code>返回即可。</li>
<li><p><code>setProperties</code>：设置一些属性，不重要。</p>
<h3 id="用到哪些注解？"><a href="#用到哪些注解？" class="headerlink" title="用到哪些注解？"></a>用到哪些注解？</h3></li>
<li>自定义插件需要用到两个注解，分别是<code>@Intercepts</code>和<code>@Signature</code>。</li>
<li><code>@Intercepts</code>：标注在实现类上，表示这个类是一个插件的实现类。</li>
<li><p><code>@Signature</code>：作为<code>@Intercepts</code>的属性，表示需要增强Mybatis的<code>某些</code>组件中的<code>某些</code>方法（可以指定多个）。常用的属性如下：</p>
<ul>
<li><code>Class&lt;?&gt; type()</code>：指定哪个组件（<code>Executor</code>、<code>ParameterHandler</code>、<code>ResultSetHandler</code>、<code>StatementHandler</code>）</li>
<li><code>String method()</code>：指定增强组件中的哪个方法，直接写方法名称。</li>
<li><code>Class&lt;?&gt;[] args()</code>：方法中的参数，必须一一对应，可以写多个；这个属性非常重用，区分重载方法。</li>
</ul>
<h3 id="如何注入Mybatis？"><a href="#如何注入Mybatis？" class="headerlink" title="如何注入Mybatis？"></a>如何注入Mybatis？</h3></li>
<li>上面已经将插件定义好了，那么如何注入到Mybatis中使其生效呢？</li>
<li><strong>前提</strong>：由于本篇文章的环境是<code>SpringBoot+Mybatis</code>，因此讲一讲如何在SpringBoot中将插件注入到Mybatis中。</li>
<li><p>在Mybatis的自动配置类<code>MybatisAutoConfiguration</code>中，注入<code>SqlSessionFactory</code>的时候，有如下一段代码：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Myabtis-%E6%8F%92%E4%BB%B6/1.png" alt=""></p>
</li>
<li><p>上图中的<code>this.interceptors</code>是什么，从何而来，其实就是从容器中的获取的<code>Interceptor[]</code>，如下一段代码：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Myabtis-%E6%8F%92%E4%BB%B6/2.png" alt="2"></p>
</li>
<li><p>从上图我们知道，这插件最终还是从IOC容器中获取的<code>Interceptor[]</code>这个<code>Bean</code>，因此我们只需要在配置类中注入这个<code>Bean</code>即可，如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@Configuration</span>：这个注解标注该类是一个配置类</div><div class="line"> */</div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisConfig</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@Bean</span> ： 该注解用于向容器中注入一个Bean</div><div class="line">     * 注入Interceptor[]这个Bean</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="keyword">public</span> Interceptor[] interceptors()&#123;</div><div class="line">        <span class="comment">//创建ParameterInterceptor这个插件</span></div><div class="line">        ParameterInterceptor parameterInterceptor = <span class="keyword">new</span> ParameterInterceptor();</div><div class="line">        <span class="comment">//放入数组返回</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Interceptor[]&#123;parameterInterceptor&#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3></li>
<li><p>此时自定义的插件已经注入了Mybatis中了，现在测试看看能不能成功执行呢？测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">//传入的是1222</span></div><div class="line">    UserInfo userInfo = userMapper.selectByUserId(<span class="string">"1222"</span>);</div><div class="line">    System.out.println(userInfo);</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>测试代码传入的是<code>1222</code>，由于插件改变了入参，因此查询出来的应该是<code>admin_1</code>这个人。</p>
</li>
</ul>
<h2 id="插件原理分析"><a href="#插件原理分析" class="headerlink" title="插件原理分析"></a>插件原理分析</h2><ul>
<li>插件的原理其实很简单，就是在创建组件的时候生成代理对象(<code>Plugin</code>)，执行组件方法的时候拦截即可。下面就来详细介绍一下插件在Mybatis底层是如何工作的？</li>
<li><p>Mybatis的四大组件都是在Mybatis的配置类<code>Configuration</code>中创建的，具体的方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//创建Executor</span></div><div class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</div><div class="line">    executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</div><div class="line">    executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</div><div class="line">    Executor executor;</div><div class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</div><div class="line">      executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</div><div class="line">      executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</div><div class="line">      executor = <span class="keyword">new</span> CachingExecutor(executor);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//调用pluginAll方法，生成代理对象</span></div><div class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</div><div class="line">    <span class="keyword">return</span> executor;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">//创建ParameterHandler</span></div><div class="line">  <span class="function"><span class="keyword">public</span> ParameterHandler <span class="title">newParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span> </span>&#123;</div><div class="line">    ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</div><div class="line">    <span class="comment">//调用pluginAll方法，生成代理对象</span></div><div class="line">    parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</div><div class="line">    <span class="keyword">return</span> parameterHandler;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="comment">//创建ResultSetHandler</span></div><div class="line">  <span class="function"><span class="keyword">public</span> ResultSetHandler <span class="title">newResultSetHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,</span></span></div><div class="line">      ResultHandler resultHandler, BoundSql boundSql) &#123;</div><div class="line">    ResultSetHandler resultSetHandler = <span class="keyword">new</span> DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</div><div class="line">    <span class="comment">//调用pluginAll方法，生成代理对象</span></div><div class="line">    resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</div><div class="line">    <span class="keyword">return</span> resultSetHandler;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">//创建StatementHandler</span></div><div class="line">  <span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</div><div class="line">    StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</div><div class="line">    <span class="comment">//调用pluginAll方法，生成代理对象</span></div><div class="line">    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</div><div class="line">    <span class="keyword">return</span> statementHandler;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>从上面的源码可以知道，创建四大组件的方法中都会执行<code>pluginAll()</code>这个方法来生成一个代理对象。具体如何生成的，下面详解。</p>
<h3 id="如何生成代理对象？"><a href="#如何生成代理对象？" class="headerlink" title="如何生成代理对象？"></a>如何生成代理对象？</h3></li>
<li><p>创建四大组件过程中都执行了<code>pluginAll()</code>这个方法，此方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</div><div class="line">    <span class="comment">//循环遍历插件</span></div><div class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</div><div class="line">      <span class="comment">//调用插件的plugin()方法</span></div><div class="line">      target = interceptor.plugin(target);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//返回</span></div><div class="line">    <span class="keyword">return</span> target;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>pluginAll()</code>方法很简单，直接循环调用插件的<code>plugin()</code>方法，但是我们调用的是<code>Plugin.wrap(target, this)</code>这行代码，因此要看一下<code>wrap()</code>这个方法的源码，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> </span>&#123;</div><div class="line">    <span class="comment">//获取注解的@signature的定义</span></div><div class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</div><div class="line">    <span class="comment">//目标类</span></div><div class="line">    Class&lt;?&gt; type = target.getClass();</div><div class="line">    <span class="comment">//获取需要拦截的接口</span></div><div class="line">    Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</div><div class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</div><div class="line">      <span class="comment">//生成代理对象</span></div><div class="line">      <span class="keyword">return</span> Proxy.newProxyInstance(</div><div class="line">          type.getClassLoader(),</div><div class="line">          interfaces,</div><div class="line">          <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> target;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>Plugin.wrap()</code>这个方法的逻辑很简单，判断这个插件是否是拦截对应的组件，如果拦截了，生成代理对象（<code>Plugin</code>）返回，没有拦截直接返回，上面例子中生成的代理对象如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Myabtis-%E6%8F%92%E4%BB%B6/3.png" alt=""></p>
<h3 id="如何执行？"><a href="#如何执行？" class="headerlink" title="如何执行？"></a>如何执行？</h3></li>
<li>上面讲了Mybatis启动的时候如何根据插件生成代理对象的(<code>Plugin</code>)。现在就来看看这个代理对象是如何执行的？</li>
<li><p>既然是动态代理，肯定会执行的<code>invoke()</code>这个方法，<code>Plugin</code>类中的<code>invoke()</code>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">//获取@signature标注的方法</span></div><div class="line">      Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</div><div class="line">      <span class="comment">//如果这个方法被拦截了</span></div><div class="line">      <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.contains(method)) &#123;</div><div class="line">      <span class="comment">//直接执行插件的intercept()这个方法</span></div><div class="line">        <span class="keyword">return</span> interceptor.intercept(<span class="keyword">new</span> Invocation(target, method, args));</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//没有被拦截，执行原方法</span></div><div class="line">      <span class="keyword">return</span> method.invoke(target, args);</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(e);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>逻辑很简单，这个方法被拦截了就执行插件的<code>intercept()</code>方法，没有被拦截，则执行原方法。</p>
</li>
<li><p>还是以上面自定义的插件来看看执行的流程：</p>
<ul>
<li><code>setParameters()</code>这个方法在<code>PreparedStatementHandler</code>中被调用，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Myabtis-%E6%8F%92%E4%BB%B6/4.png" alt=""></li>
<li>执行<code>invoke()</code>方法，发现<code>setParameters()</code>这个方法被拦截了，因此直接执行的是<code>intercept()</code>方法。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></li>
<li>Mybatis中插件的原理其实很简单，分为以下几步：<ol>
<li>在项目启动的时候判断组件是否有被拦截，如果没有直接返回原对象。</li>
<li>如果有被拦截，返回动态代理的对象（<code>Plugin</code>）。</li>
<li>执行到的组件的中的方法时，如果不是代理对象，直接执行原方法</li>
<li>如果是代理对象，执行<code>Plugin</code>的<code>invoke()</code>方法。</li>
</ol>
</li>
</ul>
<h2 id="分页插件的原理分析"><a href="#分页插件的原理分析" class="headerlink" title="分页插件的原理分析"></a>分页插件的原理分析</h2><ul>
<li><p>此处安利一款经常用的分页插件<code>pagehelper</code>，Maven依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>分页插件很显然也是根据Mybatis的插件来定制的，来看看插件<code>PageInterceptor</code>的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Intercepts</span>(</div><div class="line">        &#123;</div><div class="line">                <span class="meta">@Signature</span>(type = Executor.class, method = <span class="string">"query"</span>, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;),</div><div class="line">                <span class="meta">@Signature</span>(type = Executor.class, method = <span class="string">"query"</span>, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class, CacheKey.class, BoundSql.class&#125;),</div><div class="line">        &#125;</div><div class="line">)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>既然是分页功能，肯定是在<code>query()</code>的时候拦截，因此肯定是在<code>Executor</code>这个组件中。</p>
</li>
<li><p>分页插件的原理其实很简单，不再一一分析源码了，根据的自己定义的分页数据重新赋值<code>RowBounds</code>来达到分页的目的，当然其中涉及到数据库方言等等内容，不是本章重点，有兴趣可以看一下<a href="https://github.com/pagehelper/Mybatis-PageHelper" target="_blank" rel="external">GitHub上的文档</a>。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2></li>
<li>对于业务开发的程序员来说，插件的这个功能很少用到，但是不用就不应该了解吗？做人要有追求，哈哈。</li>
<li>欢迎关注作者的微信公众号<code>码猿技术专栏</code>，作者为你们精心准备了<code>springCloud最新精彩视频教程</code>、<code>精选500本电子书</code>、<code>架构师免费视频教程</code>等等免费资源，让我们一起进阶，一起成长。</li>
</ul>
]]></content>
      <categories>
        <category>Mybatis进阶</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql最全面试题</title>
    <url>/2020/04/20/Mysql%E6%9C%80%E5%85%A8%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<section id="nice" data-tool="mdnice编辑器" data-website="https://www.mdnice.com" style="padding: 0 10px; word-spacing: 0px; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif; line-height: 1.6; letter-spacing: .034em; color: rgb(63, 63, 63); font-size: 16px; word-break: all;"><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">前言</span><span class="suffix"></span></h2><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">前几天有读者找到我，说想要一套全面的Mysql面试题，今天陈某特地为她写了一篇。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">由于篇幅较长，陈某已经将此文章转换为PDF，公众号回复关键词<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Mysql面试题</code>即可获取。</section></li></ul><br><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">Mysql</span><span class="suffix"></span></h2><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">什么是SQL？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询语言。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">作用：用于存取数据、查询、更新和管理关系数据库系统。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">什么是MySQL?</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">数据库三大范式是什么？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">第一范式</code>：每个列都不可以再拆分。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">第二范式</code>：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">第三范式</code>：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">mysql有关权限的表都有哪几个？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：<br><ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">user权限表</code>：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">db权限表</code>：记录各个帐号在各个数据库上的操作权限。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">table_priv权限表</code>：记录数据表级的操作权限。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">columns_priv权限表</code>：记录数据列级的操作权限。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">host权限表</code>：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</section></li></ol><br></section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">MySQL的binlog有有几种录入格式？分别有什么区别？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">有三种格式，statement，row和mixed。<br><ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。</section></li></ul><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">mysql有哪些数据类型？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">1、整数类型，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。<br><ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">长度：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">例子：假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。</section></li></ul><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">2、实数类型，包括FLOAT、DOUBLE、DECIMAL。DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">3、字符串类型，包括VARCHAR、CHAR、TEXT、BLOB<br><ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">VARCHAR用于存储可变长字符串，它比定长类型更节省空间。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">VARCHAR存储的内容超出设置的长度时，内容会被截断。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">CHAR是定长的，根据定义的字符串长度分配足够的空间。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">CHAR会根据需要使用空格进行填充方便比较。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">CHAR适合存储很短的字符串，或者所有值都接近同一个长度。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">CHAR存储的内容超出设置的长度时，内容同样会被截断。</section></li></ul><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">4、枚举类型（ENUM），把不重复的数据存储为一个预定义的集合。<br><ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">有时可以使用ENUM代替常用的字符串类型。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">ENUM在内部存储时，其实存的是整数。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">排序是按照内部存储的整数</section></li></ul><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">5、日期和时间类型，尽量使用timestamp，空间效率高于datetime，<br><ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">用整数保存时间戳通常不方便处理。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如果需要存储微妙，可以使用bigint存储。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">看到这里，这道真题是不是就比较容易回答了。</section></li></ul><br></section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">MyISAM索引与InnoDB索引的区别？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">InnoDB引擎的4大特性</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">插入缓冲（insert buffer)</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">二次写(double write)</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">自适应哈希索引(ahi)</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">预读(read ahead)</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">什么是索引？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">索引有哪些优缺点？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引的优点：<br><ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</section></li></ul><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引的缺点：<br><ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">空间方面：索引需要占物理空间。</section></li></ul><br></section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">索引有哪几种类型？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">主键索引</code>: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">唯一索引</code>: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。<br><ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以通过 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">ALTER TABLE table_name ADD UNIQUE (column);</code> 创建唯一索引</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以通过 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">ALTER TABLE table_name ADD UNIQUE (column1,column2);</code> 创建唯一组合索引</section></li></ul><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">普通索引</code>: 基本的索引类型，没有唯一性的限制，允许为NULL值。<br><ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以通过<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">ALTER TABLE table_name ADD INDEX index_name (column);</code>创建普通索引</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以通过<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);</code>创建组合索引。</section></li></ul><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">全文索引</code>： 是目前搜索引擎使用的一种关键技术。<br><ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以通过<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">ALTER TABLE table_name ADD FULLTEXT (column);</code>创建全文索引</section></li></ul><br></section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">索引的数据结构（b树，hash）</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有Hash索引，B+树索引等，而我们经常使用的InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</section></li></ul><br><p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">1. B树索引</strong></p><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">mysql通过存储引擎取数据，基本上90%的人用的就是InnoDB了，按照实现方式分，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。B树索引是Mysql数据库中使用最频繁的索引类型，基本所有存储引擎都支持BTree索引。通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/1.jpg" alt="B树索引" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></section></li></ul><br><p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">2. B+tree性质</strong></p><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">B+ 树中，数据对象的插入和删除仅在叶节点上进行。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</section></li></ul><br><p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">3. 哈希索引</strong></p><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">简要说下，类似于数据结构中简单实现的HASH表（散列表）一样，当我们在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。当然这只是简略模拟图。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/2.jpg" alt="哈希索引" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">索引的基本原理</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引的原理很简单，就是把无序的数据变成有序的查询<br><ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">把创建了索引的列的内容进行排序</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">对排序结果生成倒排表</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在倒排表内容上拼上数据地址链</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</section></li></ol><br></section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">索引算法有哪些？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引算法有 BTree算法和Hash算法</section></li></ul><br><p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">1. BTree算法</strong></p><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">BTree是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,&gt;,&gt;=,&lt;,&lt;=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量。</section></li></ul><br><p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">2. Hash算法</strong></p><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">Hash Hash索引只能用于对等比较，例如=,&lt;=&gt;（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">索引设计的原则？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">适合索引的列是出现在where子句中的列，或者连接子句中指定的列。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">基数较小的类，索引效果较差，没有必要在此列建立索引</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">创建索引的原则</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引虽好，但也不是无限制的使用，最好符合一下几个原则<br><ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">较频繁作为查询条件的字段才去创建索引</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">更新频繁字段不适合创建索引</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">定义有外键的数据列一定要建立索引。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">对于定义为text、image和bit的数据类型的列不要建立索引。</section></li></ul><br></section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">创建索引时需要注意什么？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">使用索引查询一定能提高查询的性能吗？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">基于一个范围的检索，一般查询返回结果集小于表中记录数的30%</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">基于非唯一性索引的检索</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">百万级别或以上的数据如何删除？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。<br><ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">然后删除其中无用数据（此过程需要不到两分钟）</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</section></li></ol><br></section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">什么是最左前缀原则？什么是最左匹配原则？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">B树和B+树的区别</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/3.jpg" alt="B树和B+树的区别" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">使用B树的好处</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">使用B+树的好处</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。 B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">什么是聚簇索引？何时使用聚簇索引与非聚簇索引？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">非聚簇索引一定会回表查询吗？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行select age from employee where age &lt; 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">联合索引是什么？为什么需要注意联合索引中的顺序？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">MySQL使用索引时需要索引有序，假设现在建立了”name，age，school”的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">什么是数据库事务？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">事物的四大特性(ACID)介绍一下?</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">原子性</code>： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">一致性</code>： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">隔离性</code>： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">持久性</code>： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">什么是脏读？幻读？不可重复读？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">脏读</code>(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">不可重复读</code>(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">幻读</code>(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">什么是事务的隔离级别？MySQL的默认隔离级别是什么？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">SQL 标准定义了四个隔离级别：<br><ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">READ-UNCOMMITTED</code>(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">READ-COMMITTED</code>(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">REPEATABLE-READ</code>(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">SERIALIZABLE</code>(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</section></li></ul><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别</strong></section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">隔离级别与锁的关系</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">按照锁的粒度分数据库锁有哪些？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">行级锁</code>:行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">表级锁</code>: 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">页级锁</code>:页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">从锁的类别上分MySQL都有哪些锁呢？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">从锁的类别上来讲，有共享锁和排他锁。<br><ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</section></li></ul><br></section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">InnoDB存储引擎的锁的算法有哪三种？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">Record lock：单个行记录上的锁</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">Gap lock：间隙锁，锁定一个范围，不包括记录本身</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">Next-key lock：record+gap 锁定一个范围，包含记录本身</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">什么是死锁？怎么解决？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">常见的解决死锁的方法<br><ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</section></li></ol><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如果业务处理不好可以用分布式事务锁或者使用乐观锁</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">数据库的乐观锁和悲观锁是什么？怎么实现的？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">悲观锁</code>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">乐观锁</code>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">大表数据查询，怎么优化？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">优化shema、sql语句+索引；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">第二加缓存，memcached, redis；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">主从复制，读写分离；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">超大分页怎么处理？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">超大的分页一般从两个方向上来解决:<br><ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于select <em> from table where age &gt; 20 limit 1000000,10这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为select </em> from table where id in (select id from table where age &gt; 20 limit 1000000,10).这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以select * from table where id &gt; 1000000 limit 10,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">从需求的角度减少这种请求…主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击</section></li></ul><br></section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">为什么要尽量设定一个主键？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">主键使用自增ID还是UUID？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">推荐使用自增ID，不要使用UUID。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">总之，在数据量大一些的情况下，用自增主键性能会好一些。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">关于主键是聚簇索引，如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">字段为什么要求定义为not null？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">null值会占用更多的字节，且会在程序中造成很多与预期不符的情况。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">如果要存储用户的密码散列，应该使用什么字段进行存储？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">密码散列，盐，用户身份证号等固定长度的字符串应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">数据库结构优化？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">将字段很多的表分解成多个表</strong>：对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">增加中间表</strong>：对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">增加冗余字段</strong>：设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">MySQL数据库cpu飙升到500%的话他怎么处理？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">主从复制的作用？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">主数据库出现问题，可以切换到从数据库。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以进行数据库层面的读写分离。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以在从数据库上进行日常备份。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">MySQL主从复制解决的问题？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">数据分布：随意开始或停止复制，并在不同地理位置分布数据备份</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">负载均衡：降低单个服务器的压力</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">高可用和故障切换：帮助应用程序避免单点失败</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">升级测试：可以用更高版本的MySQL作为从库</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">MySQL主从复制工作原理？</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在主库上把数据更高记录到二进制日志</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">从库将主库的日志复制到自己的中继日志</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">从库读取中继日志的事件，将其重放到从库数据中。</section></li></ul><br><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">小福利</span><span class="suffix"></span></h2><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">由于文章篇幅较长，陈某将其转换为PDF文档，老规矩，回复关键词<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Mysql面试题</code>即可获取。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/4.png" alt="" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></section></li></ul><br><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">巨人的肩膀</span><span class="suffix"></span></h2><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><a href="https://www.cnblogs.com/hsmwlyl/p/10719152.html" target="_blank" rel="external">https://www.cnblogs.com/hsmwlyl/p/10719152.html</a></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><a href="https://www.cnblogs.com/caomusheng/p/12586895.html" target="_blank" rel="external">https://www.cnblogs.com/caomusheng/p/12586895.html</a></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><a href="https://article.itxueyuan.com/eoJEMj" target="_blank" rel="external">https://article.itxueyuan.com/eoJEMj</a></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><a href="https://blog.csdn.net/thinkwon/article/details/104778621#comments" target="_blank" rel="external">https://blog.csdn.net/thinkwon/article/details/104778621#comments</a></section></li></ul><br><p id="nice-suffix-juejin-container" class="nice-suffix-juejin-container" data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em; margin-top: 20px !important;">本文使用 <a href="https://mdnice.com/?from=juejin" style="word-wrap: break-word; font-weight: bold; color: #48b378; text-decoration: none; border-bottom: 1px solid #48b378;" target="_blank" rel="external">mdnice</a> 排版</p></section>]]></content>
      <categories>
        <category>数据库干货篇</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中索引如何优化？</title>
    <url>/2020/04/20/%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<section id="nice" data-tool="mdnice编辑器" data-website="https://www.mdnice.com" style="padding: 0 10px; word-spacing: 0px; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif; line-height: 1.6; letter-spacing: .034em; color: rgb(63, 63, 63); font-size: 16px; word-break: all;"><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">前言</span><span class="suffix"></span></h2><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引的相信大家都听说过，但是真正会用的又有几人？平时工作中写SQL真的会考虑到这条SQL如何能够用上索引，如何能够提升执行效率？</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">此篇文章详细的讲述了索引优化的几个原则，只要在工作中能够随时应用到，相信你写出的SQL一定是效率最高，最牛逼的。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">文章的脑图如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96.png" alt="索引优化几大规则" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></section></li></ul><br><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">索引优化规则</span><span class="suffix"></span></h2><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">1、like语句的前导模糊查询不能使用索引</span><span class="suffix" style="display: none;"></span></h3><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> <em> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> doc <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> title <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">like</span> <span class="hljs-string" style="color: #d14; line-height: 26px;">‘%XX’</span>；   <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">–不能使用索引</span><br><span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> </span></em> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> doc <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> title <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">like</span> <span class="hljs-string" style="color: #d14; line-height: 26px;">‘XX%’</span>；   <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">–非前导模糊查询，可以使用索引</span><br><span></span></code></pre><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">因为页面搜索严禁左模糊或者全模糊，如果需要可以使用搜索引擎来解决。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">2、union、in、or 都能够命中索引，建议使用 in</span><span class="suffix" style="display: none;"></span></h3><br><ol data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">union</code>能够命中索引，并且MySQL 耗费的 CPU 最少。</section></li></ol><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> <em> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> doc <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">status</span>=<span class="hljs-number" style="color: #008080; line-height: 26px;">1</span><br><span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">union</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">all</span><br><span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> </span></span></em> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> doc <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">status</span>=<span class="hljs-number" style="color: #008080; line-height: 26px;">2</span>;<br><span></span></code></pre><br><ol start="2" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">in</code>能够命中索引，查询优化耗费的 CPU 比 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">union all</code> 多，但可以忽略不计，一般情况下建议使用 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">in</code>。</section></li></ol><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> <em> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> doc <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">status</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">in</span> (<span class="hljs-number" style="color: #008080; line-height: 26px;">1</span>, <span class="hljs-number" style="color: #008080; line-height: 26px;">2</span>);<br><span></span></em></code></pre><br><ol start="3" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">or</code> 新版的 MySQL 能够命中索引，查询优化耗费的 CPU 比 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">in</code>多，不建议频繁用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">or</code>。</section></li></ol><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span>  <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> doc <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">status</span> = <span class="hljs-number" style="color: #008080; line-height: 26px;">1</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">or</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">status</span> = <span class="hljs-number" style="color: #008080; line-height: 26px;">2</span><br><span></span></code></pre><br><ol start="4" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">补充</strong>：有些地方说在<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">where</code>条件中使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">or</code>，索引会失效，造成全表扫描，这是个误区：</section></li></ol><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">①要求<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">where</code>子句使用的所有字段，都必须建立索引；</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">②如果数据量太少，mysql制定执行计划时发现全表扫描比索引查找更快，所以会不使用索引；</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">③确保mysql版本<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">5.0</code>以上，且查询优化器开启了<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">index_merge_union=on</code>, 也就是变量<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">optimizer_switch</code>里存在<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">index_merge_union</code>且为<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">on</code>。</p><br></section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">3、负向条件查询不能使用索引</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">负向条件有：<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">!=</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">&lt;&gt;</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">not in</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">not exists</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">not like</code> 等。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">例如下面SQL语句：</p><br></section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> <em> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> doc <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">status</span> != <span class="hljs-number" style="color: #008080; line-height: 26px;">1</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">and</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">status</span> != <span class="hljs-number" style="color: #008080; line-height: 26px;">2</span>;<br><span></span></em></code></pre><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以优化为 in 查询：</section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span>  <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> doc <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">status</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">in</span> (<span class="hljs-number" style="color: #008080; line-height: 26px;">0</span>,<span class="hljs-number" style="color: #008080; line-height: 26px;">3</span>,<span class="hljs-number" style="color: #008080; line-height: 26px;">4</span>);<br><span></span></code></pre><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">4、联合索引最左前缀原则</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">如果在<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">(a,b,c)</code>三个字段上建立联合索引，那么他会自动建立 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">a</code>| <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">(a,b)</code> | <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">(a,b,c)</code>组索引。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">登录业务需求，SQL语句如下：</p><br></section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> uid, login_time <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">user</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> login_name=? andpasswd=?<br><span></span></code></pre><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以建立<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">(login_name, passwd)</code>的联合索引。因为业务上几乎没有<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">passwd</code> 的单条件查询需求，而有很多<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">login_name</code> 的单条件查询需求，所以可以建立<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">(login_name, passwd)</code>的联合索引，而不是<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">(passwd, login_name</code>)。</section></li></ul><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">建立联合索引的时候，区分度最高的字段在最左边</strong></section></li></ol><br></blockquote><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><ol start="2" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">存在非等号和等号混合判断条件时，在建立索引时，把等号条件的列前置</strong>。如 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">where a&gt;? and b=?</code>，那么即使<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">a</code> 的区分度更高，也必须把 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">b</code> 放在索引的最前列。</section></li></ol><br></blockquote><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><ol start="3" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">最左前缀查询时，并不是指SQL语句的where顺序要和联合索引一致</strong>。</section></li></ol><br></blockquote><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">下面的 SQL 语句也可以命中 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">(login_name, passwd)</code> 这个联合索引：</section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> uid, login_time <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">user</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> passwd=? andlogin_name=?<br><span></span></code></pre><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">但还是建议 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">where</code> 后的顺序和联合索引一致，养成好习惯。</section></li></ul><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><ol start="4" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">假如<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">index(a,b,c)</code>, <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">where a=3 and b like ‘abc%’ and c=4</code>，<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">a</code>能用，<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">b</code>能用，<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">c</code>不能用。</section></li></ol><br></blockquote><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">5、不能使用索引中范围条件右边的列（范围列可以用到索引），范围列之后列的索引全失效</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">范围条件有：<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">&lt;、&lt;=、&gt;、&gt;=、between</code>等。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引最多用于一个范围列，如果查询条件中有两个范围列则无法全用到索引。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">假如有联合索引 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">(empno、title、fromdate)</code>，那么下面的 SQL 中 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">emp_no</code> 可以用到索引，而<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">title</code> 和 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">from_date</code> 则使用不到索引。</section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> <em> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> employees.titles <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> emp_no &lt; <span class="hljs-number" style="color: #008080; line-height: 26px;">10010</span><span class="hljs-string" style="color: #d14; line-height: 26px;">‘ and title=’</span>Senior Engineer<span class="hljs-string" style="color: #d14; line-height: 26px;">‘and from_date between ‘</span><span class="hljs-number" style="color: #008080; line-height: 26px;">1986</span><span class="hljs-number" style="color: #008080; line-height: 26px;">-01</span><span class="hljs-number" style="color: #008080; line-height: 26px;">-01</span><span class="hljs-string" style="color: #d14; line-height: 26px;">‘ and ‘</span><span class="hljs-number" style="color: #008080; line-height: 26px;">1986</span><span class="hljs-number" style="color: #008080; line-height: 26px;">-12</span><span class="hljs-number" style="color: #008080; line-height: 26px;">-31</span><span class="hljs-string" style="color: #d14; line-height: 26px;">‘<br><span></span></span></em></code></pre><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">6、不要在索引列上面做任何操作（计算、函数），否则会导致索引失效而转向全表扫描</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">例如下面的 SQL 语句，即使 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">date</code> 上建立了索引，也会全表扫描：</section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span>  <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> doc <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">YEAR</span>(create_time) &lt;= <span class="hljs-string" style="color: #d14; line-height: 26px;">‘2016’</span>;<br><span></span></code></pre><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可优化为值计算，如下：</section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> <em> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> doc <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> create_time &lt;= <span class="hljs-string" style="color: #d14; line-height: 26px;">‘2016-01-01’</span>;<br><span></span></em></code></pre><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">比如下面的 SQL 语句：</section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span>  <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">order</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-built_in" style="color: #0086b3; line-height: 26px;">date</span> &lt; = <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">CURDATE</span>()；<br><span></span></code></pre><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以优化为：</section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> <em> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">order</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-built_in" style="color: #0086b3; line-height: 26px;">date</span> &lt; = <span class="hljs-string" style="color: #d14; line-height: 26px;">‘2018-01-2412:00:00’</span>;<br><span></span></em></code></pre><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">7、强制类型转换会全表扫描</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">字符串类型不加单引号会导致索引失效，因为mysql会自己做类型转换,相当于在索引列上进行了操作。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如果 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">phone</code> 字段是 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">varchar</code> 类型，则下面的 SQL 不能命中索引。</section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span>  <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">user</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> phone=<span class="hljs-number" style="color: #008080; line-height: 26px;">13800001234</span><br><span></span></code></pre><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以优化为：</section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> <em> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">user</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> phone=<span class="hljs-string" style="color: #d14; line-height: 26px;">‘13800001234’</span>;<br><span></span></em></code></pre><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">8、更新十分频繁、数据区分度不高的列不宜建立索引</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">更新会变更 B+ 树，更新频繁的字段建立索引会大大降低数据库性能。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">“性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">一般区分度在80%以上的时候就可以建立索引，区分度可以使用 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">count(distinct(列名))/count()</code> 来计算。</p><br></section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">9、利用覆盖索引来进行查询操作，避免回表，减少select <em> 的使用</em></span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">覆盖索引：查询的列和所建立的索引的列个数相同，字段相同。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">被查询的列，数据能从索引中取得，而不用通过行定位符 row-locator 再到 row 上获取，即“被查询列要被所建的索引覆盖”，这能够加速查询速度。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">例如登录业务需求，SQL语句如下。</section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">Select</span> uid, login_time <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">user</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> login_name=? <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">and</span> passwd=?<br><span></span></code></pre><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以建立<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">(login_name, passwd, login_time)</code>的联合索引，由于 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">login_time</code> 已经建立在索引中了，被查询的 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">uid</code> 和 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">login_time</code> 就不用去 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">row</code> 上获取数据了，从而加速查询。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">10、索引不会包含有NULL值的列</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">NULL</code>值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时，尽量使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">not null</code> 约束以及默认值。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">11、is null, is not null无法使用索引</span><span class="suffix" style="display: none;"></span></h3><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">12、如果有order by、group by的场景，请注意利用索引的有序性</span><span class="suffix" style="display: none;"></span></h3><br><ol data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">order by</code> 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现file_sort 的情况，影响查询性能。</section></li></ol><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">例如对于语句 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">where a=? and b=? order by c</code>，可以建立联合索引<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">(a,b,c)</code>。</section></li></ul><br><ol start="2" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如果索引中有范围查找，那么索引有序性无法利用，如<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">WHERE a&gt;10 ORDER BY b;</code>，索引<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">(a,b)</code>无法排序。</section></li></ol><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">13、使用短索引（前缀索引）</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">对列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">CHAR(255)</code>的列，如果该列在前<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">10</code>个或<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">20</code>个字符内，可以做到既使得前缀索引的区分度接近全列索引，那么就不要对整个列进行索引。因为短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作，减少索引文件的维护开销。可以使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">count(distinct leftIndex(列名, 索引长度))/count()</code> 来计算前缀索引的区分度。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">但缺点是不能用于 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">ORDER BY</code> 和 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">GROUP BY</code> 操作，也不能用于覆盖索引。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">不过很多时候没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。</p><br></section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">14、利用延迟关联或者子查询优化超多分页场景</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">MySQL 并不是跳过 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">offset</code> 行，而是取 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">offset+N</code> 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">示例如下，先快速定位需要获取的<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">id</code>段，然后再关联:</section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">selecta.<em> from 表1 a,(<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">id</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> 表<span class="hljs-number" style="color: #008080; line-height: 26px;">1</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> 条件 limit100000,<span class="hljs-number" style="color: #008080; line-height: 26px;">20</span> ) b <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> a.id=b.id；<br><span></span></em></code></pre><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">15、如果明确知道只有一条结果返回，limit 1 能够提高效率</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">比如如下 SQL 语句：</section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span>  <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">user</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> login_name=?;<br><span></span></code></pre><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以优化为：</section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> <em> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">user</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> login_name=? <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">limit</span> <span class="hljs-number" style="color: #008080; line-height: 26px;">1</span><br><span></span></em></code></pre><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">自己明确知道只有一条结果，但数据库并不知道，明确告诉它，让它主动停止游标移动。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">16、超过三个表最好不要 join</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">需要 join 的字段，数据类型必须一致，多表关联查询时，保证被关联的字段需要有索引。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">例如：<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">left join</code>是由左边决定的，左边的数据一定都有，所以右边是我们的关键点，<strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">建立索引要建右边的</strong>。当然如果索引在左边，可以用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">right join</code>。</p><br></section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">17、单表索引建议控制在5个以内</span><span class="suffix" style="display: none;"></span></h3><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">18、SQL 性能优化 explain 中的 type：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">consts</code>：单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">ref</code>：使用普通的索引<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">（Normal Index）</code>。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">range</code>：对索引进行范围检索。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">当 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">type=index</code> 时，索引物理文件全扫，速度非常慢。</p><br></section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">19、业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">不要以为唯一索引影响了 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">insert</code> 速度，这个速度损耗可以忽略，但提高查找速度是明显的。另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">20.创建索引时避免以下错误观念</span><span class="suffix" style="display: none;"></span></h3><br><ol data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引越多越好，认为需要一个查询就建一个索引。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">宁缺勿滥，认为索引会消耗空间、严重拖慢更新和新增速度。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">抵制惟一索引，认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">过早优化，在不了解系统的情况下就开始优化。</section></li></ol><br><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">索引选择性与前缀索引</span><span class="suffix"></span></h2><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">第一种情况是表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了。至于多少条记录才算多，这个个人有个人的看法，我个人的经验是以2000作为分界线，记录数不超过 2000可以考虑不建索引，超过2000条可以酌情考虑索引。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">另一种不建议建索引的情况是索引的选择性较低。所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：</p><br></section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">Index Selectivity = Cardinality / <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">#T</span><br><span></span></code></pre><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">显然选择性的取值范围为<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">(0, 1]<code>`，选择性越高的索引价值越大，这是由&lt;/code&gt;B+Tree&lt;code style=&quot;font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;&quot;&gt;的性质决定的。例如，&lt;/code&gt;employees.titles&lt;code style=&quot;font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;&quot;&gt;表，如果&lt;/code&gt;title</code>字段经常被单独查询，是否需要建索引，我们看一下它的选择性：</code></section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">SELECT</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">count</span>(<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">DISTINCT</span>(title))/<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">count</span>() <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">AS</span> Selectivity <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">FROM</span> employees.titles;<br><span>+<span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">————-+</span><br><span>| Selectivity |<br><span>+<span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">————-+</span><br><span>|      0.0000 |<br><span>+<span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">————-+</span><br><span></span></span></span></span></span></span></code></pre><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">title</code>的选择性不足<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">0.0001</code>（精确值为0.00001579），所以实在没有什么必要为其单独建索引。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">有一种与索引选择性有关的索引优化策略叫做前缀索引，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。下面以<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">employees.employees</code>表为例介绍前缀索引的选择和使用。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">假设employees表只有一个索引&lt;emp_no&gt;，那么如果我们想按名字搜索一个人，就只能全表扫描了：</p><br></section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">EXPLAIN</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">SELECT</span> <em> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">FROM</span> employees.employees <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">WHERE</span> first_name=<span class="hljs-string" style="color: #d14; line-height: 26px;">‘Eric’</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">AND</span> last_name=<span class="hljs-string" style="color: #d14; line-height: 26px;">‘Anido’</span>;<br><span>+<span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">—-+————-+———–+——+—————+——+———+——+——–+————-+</span><br><span>| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows   | Extra       |<br><span>+<span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">—-+————-+———–+——+—————+——+———+——+——–+————-+</span><br><span>|  1 | SIMPLE      | employees | ALL  | NULL          | NULL | NULL    | NULL | 300024 | Using where |<br><span>+<span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">—-+————-+———–+——+—————+——+———+——+——–+————-+</span><br><span></span></span></span></span></span></span></em></code></pre><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如果频繁按名字搜索员工，这样显然效率很低，因此我们可以考虑建索引。有两种选择，建<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">&lt;first_name&gt;</code>或<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">&lt;first_name, last_name&gt;</code>，看下两个索引的选择性：</section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">SELECT</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">count</span>(<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">DISTINCT</span>(first_name))/<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">count</span>() <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">AS</span> Selectivity <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">FROM</span> employees.employees;<br><span>+<span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">————-+</span><br><span>| Selectivity |<br><span>+<span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">————-+</span><br><span>|      0.0042 |<br><span>+<span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">————-+</span><br><span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">SELECT</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">count</span>(<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">DISTINCT</span>(<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">concat</span>(first_name, last_name)))/<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">count</span>(<em>) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">AS</span> Selectivity <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">FROM</span> employees.employees;<br><span>+<span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">————-+</span><br><span>| Selectivity |<br><span>+<span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">————-+</span><br><span>|      0.9313 |<br><span>+<span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">————-+</span><br><span></span></span></span></span></span></span></em></span></span></span></span></span></span></code></pre><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">&lt;first_name&gt;</code>显然选择性太低，<code>`&amp;lt;first_name, last_name&amp;gt;&lt;code style=&quot;font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;&quot;&gt;选择性很好，但是&lt;/code&gt;first_name&lt;code style=&quot;font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;&quot;&gt;和&lt;/code&gt;last_name&lt;code style=&quot;font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;&quot;&gt;加起来长度为&lt;/code&gt;30&lt;code style=&quot;font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;&quot;&gt;，有没有兼顾长度和选择性的办法？可以考虑用first_name和last_name的前几个字符建立索引，例如&lt;/code&gt;&amp;lt;first_name, left(last_name, 3)&amp;gt;</code>，看看其选择性：</section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">SELECT count(DISTINCT(concat(first_name, left(last_name, 3))))/count() AS Selectivity FROM employees.employees;<br><span>+————-+<br><span>| Selectivity |<br><span>+————-+<br><span>|      0.7879 |<br><span>+————-+<br><span><br><span></span></span></span></span></span></span></span></code></pre><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">选择性还不错，但离0.9313还是有点距离，那么把last_name前缀加到4：</section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">SELECT</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">count</span>(<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">DISTINCT</span>(<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">concat</span>(first_name, <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">left</span>(last_name, <span class="hljs-number" style="color: #008080; line-height: 26px;">4</span>))))/<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">count</span>(<em>) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">AS</span> Selectivity <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">FROM</span> employees.employees;<br><span>+<span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">————-+</span><br><span>| Selectivity |<br><span>+<span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">————-+</span><br><span>|      0.9007 |<br><span>+<span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">————-+</span><br><span></span></span></span></span></span></span></em></code></pre><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">这时选择性已经很理想了，而这个索引的长度只有<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">18</code>，比<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">&lt;first_name, last_name&gt;</code>短了接近一半，我们把这个前缀索引建上：</section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">ALTER TABLE employees.employees<br><span>ADD INDEX <code>first_name_last_name4</code> (first_name, last_name(4));<br><span></span></span></code></pre><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">此时再执行一遍按名字查询，比较分析一下与建索引前的结果：</section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">SHOW PROFILES;<br><span>+———-+————+———————————————————————————+<br><span>| Query_ID | Duration   | Query                                                                           |<br><span>+———-+————+———————————————————————————+<br><span>|       87 | 0.11941700 | SELECT  FROM employees.employees WHERE first_name=<span class="hljs-string" style="color: #d14; line-height: 26px;">‘Eric’</span> AND last_name=<span class="hljs-string" style="color: #d14; line-height: 26px;">‘Anido’</span> |<br><span>|       90 | 0.00092400 | SELECT * FROM employees.employees WHERE first_name=<span class="hljs-string" style="color: #d14; line-height: 26px;">‘Eric’</span> AND last_name=<span class="hljs-string" style="color: #d14; line-height: 26px;">‘Anido’</span> |<br><span>+———-+————+———————————————————————————+<br><span></span></span></span></span></span></span></span></code></pre><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">性能的提升是显著的，查询速度提高了120多倍。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">ORDER BY</code>和<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">GROUP BY</code>操作，也不能用于<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Covering index</code>（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）。</p><br></section></li></ul><br><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">总结</span><span class="suffix"></span></h2><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">本文主要讲了索引优化的二十个原则，希望读者喜欢。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">本篇文章<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">脑图</code>和<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">PDF文档</code>已经准备好，有需要的伙伴可以回复关键词<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">索引优化</code>获取。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96pdf.png" alt="" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></section></li></ul><br><p id="nice-suffix-juejin-container" class="nice-suffix-juejin-container" data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em; margin-top: 20px !important;">本文使用 <a href="https://mdnice.com/?from=juejin" style="word-wrap: break-word; font-weight: bold; color: #48b378; text-decoration: none; border-bottom: 1px solid #48b378;" target="_blank" rel="external">mdnice</a> 排版</p></section>]]></content>
      <categories>
        <category>数据库干货篇</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>吐血总结：MySQL性能如何优化？</title>
    <url>/2020/04/20/%E5%90%90%E8%A1%80%E6%80%BB%E7%BB%93%EF%BC%9AMySQL%E6%80%A7%E8%83%BD%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%EF%BC%9F/</url>
    <content><![CDATA[<section id="nice" data-tool="mdnice编辑器" data-website="https://www.mdnice.com" style="padding: 0 10px; word-spacing: 0px; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif; line-height: 1.6; letter-spacing: .034em; color: rgb(63, 63, 63); font-size: 16px; word-break: all;"><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">前言</span><span class="suffix"></span></h2><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">上篇讲了MySQL的索引优化，此篇文章从大范围讲一下MySQL数据库到底该如何优化？这个问题在面试中时常被问到，今天陈某来总结下。</section></li></ul><br><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">SQL 优化的几个步骤</span><span class="suffix"></span></h2><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">1. 通过<code>show status</code> 命令了解各种 SQL 的执行效率</span><span class="suffix" style="display: none;"></span></h3><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">show</span> [<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">session</span> | <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">global</span>] <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">status</span>;<br><span></span></code></pre><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以根据需要加上参数来显示<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">session</code>级（当前连接，默认）和<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">global</code>级（自数据库上次启动至今）的统计结果。</section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">show</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">status</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">like</span> <span class="hljs-string" style="color: #d14; line-height: 26px;">‘Com_%’</span>;  <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">—显示当前连接所有统计参数的值。</span><br><span></span></code></pre><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Com_xxx</code>表示每个<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">xxx</code>语句执行的次数，通常需要注意的是下面几个参数：<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Com_select/Com_insert/Com_update/Com_delete</code>。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">2. 定位执行效率较低的 SQL 语句</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">通过<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">show processlist</code>命令实时查看当前 SQL 的执行情况；</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">通过<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">慢查询日志</code>定位出现的问题。</p><br></section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">3. 通过<code>explain</code> 或 <code>desc</code>分析低效 SQL 的执行计划</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以参考上篇文章<a href="https://mp.weixin.qq.com/s/utdzi49ZDH16Bsi8ZIktIQ" style="word-wrap: break-word; font-weight: bold; color: #48b378; text-decoration: none; border-bottom: 1px solid #48b378;" target="_blank" rel="external">Mysql 探索之 Explain 执行计划详解</a></section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">4. 通过<code>show profile</code> 分析 SQL。</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">show profile</code> 能帮我们了解时间都耗费到哪里去了。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">通过<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">show profiles</code>我们能够更清楚了解 SQL 执行的过程；</p><br></section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">5. 通过<code>trace</code>分析优化器如何选择执行计划</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">MySQL5.6</code>提供了对 SQL 的跟踪<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">trace</code>,能帮我们了解为什么优化器选择执行 A 计划而不是 B 计划，进一步理解优化器的行为。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">6. 确定问题并采取相应的优化措施。</span><span class="suffix" style="display: none;"></span></h3><br><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">MySQL 常用的 SQL 语句优化方法</span><span class="suffix"></span></h2><br><ol data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">应尽量避免在 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">where</code> 子句中使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">!=</code>或<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">&lt;&gt;</code>操作符，否则将引擎放弃使用索引而进行全表扫描。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">对查询进行优化，应尽量避免全表扫描，首先应考虑在 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">where</code> 及 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">order by</code> 涉及的列上建立索引。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">应尽量避免在<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">where</code> 子句中对字段进行 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">null</code> 值判断，否则将导致引擎放弃使用索引而进行全表扫描。如：</p><br></section></li></ol><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">id</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> t <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">num</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">is</span> <span class="hljs-literal" style="color: #008080; line-height: 26px;">null</span><br><span></span></code></pre><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以在 num 上设置默认值 0，确保表中 num 列没有 null 值，然后这样查询：</section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">id</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> t <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">num</span>=<span class="hljs-number" style="color: #008080; line-height: 26px;">0</span><br><span></span></code></pre><br><ol start="4" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">避免在<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">where</code>子句中使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">or</code>来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">前导模糊查询将导致全表扫描</p><br></section></li></ol><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">  <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">id</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> t <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">name</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">like</span> ‘%c%’<br><span></span></code></pre><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">下面使用索引</section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">id</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> t <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">name</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">like</span> ‘c%’<br><span></span></code></pre><br><ol start="6" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">not in</code> 也要慎用，否则会导致全表扫描；对于连续的数值，能用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">between</code> 就不要用 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">in</code> 了，尽量使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">exists</code>代替<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">in</code>。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">如果在 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">where</code> 子句中使用参数，也会导致全表扫描。因为 SQL 只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p><br></section></li></ol><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">  <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">id</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> t <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">num</span>=@<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">num</span><br><span></span></code></pre><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以改为强制查询使用索引：</section></li></ul><br><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">  <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">id</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> t <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">with</span>(<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">index</span>(索引名)) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">num</span>=@<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">num</span><br><span></span></code></pre><br><ol start="8" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">应尽量避免在 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">where</code> 子句中对字段进行表达式与函数或其他表达式运算操作，这将导致引擎放弃使用索引而进行全表扫描。如：</section></li></ol><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">select id from t where num/2=100</code>，应改为：<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">select id from t where num=100<em>2</em></code></p><br></blockquote><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">select id from t where substring(name,1,3)=’abc’</code>;<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">name</code>以<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">abc</code>开头的<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">id</code>,应改为：<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">select id from t where name like ‘abc%’</code></p><br></blockquote><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">select id from t where datediff(day,createdate,’2005-11-30’)=0 –’2005-11-30′</code>生成的 id,应改为：<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">select id from t where createdate&gt;=’2005-11-30′ and createdate&lt;’2005-12-01’</code></p><br></blockquote><br><ol start="9" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Update</code> 语句，如果只更改 1、2 个字段，不要 Update 全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">并不是所有索引对查询都有效，SQL 是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL 查询可能不会去利用索引。如一表中有字段 sex，male、female 几乎各一半，那么即使在 sex 上建了索引也对查询效率起不了作用。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">索引并不是越多越好，索引固然可以提高相应的 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">select</code> 的效率，但同时也降低了 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">insert</code> 及 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">update</code> 的效率，因为 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">insert</code> 或 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">update</code> 时有可能会重建索引。一个表的索引数较好不要超过 6 个。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">应尽可能的避免更新 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">clustered</code> 索引数据列，因为 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">clustered</code> 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">任何地方都不要使用 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">select  from t</code> ，用具体的字段列表代替<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;"><em></em></code>，不要返回用不到的任何字段。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">对于多张大数据量（这里几百条就算大了）的表<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">JOIN</code>，要先分页再<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">JOIN</code>，否则逻辑读会很高，性能很差。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">尽量使用表变量来代替临时表。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">考虑使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">临时表</code>暂存中间结果。临时表并不是不可使用，适当地使用它们可以使某些查询更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。将临时结果暂存在临时表，后面的查询就在<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">tempdb</code>中查询了，这可以避免程序中多次扫描主表，也大大减少了程序执行中<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">共享锁</code>阻塞<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">更新锁</code>，减少了阻塞，提高了并发性能。但是，对于一次性事件，较好使用导出表。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">在新建临时表时，如果一次性插入数据量很大，那么可以使用 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">select into</code> 代替 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">create table</code>，避免造成大量 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">log</code> ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">create table</code>，然后<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">insert</code>。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">truncate table</code> ，然后 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">drop table</code> ，这样可以避免系统表的较长时间锁定。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">避免频繁创建和删除临时表，以减少系统表资源的消耗。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">尽量避免使用游标，因为游标的效率较差。与临时表一样，游标并不是不可使用。对小型数据集使用 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">FAST_FORWARD</code> 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">在所有的存储过程和触发器的开始处设置 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">SET NOCOUNT ON</code> ，在结束时设置 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">SET NOCOUNT OFF</code> 。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">尽量避免向客户端返回大数据量。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">尽量避免大事务操作，提高系统并发能力。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">where</code>子句替换<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Having</code>子句</p><br></section></li></ol><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">避免使用 having 子句，having 只会在检索出所有记录之后才会对结果集进行过滤，这个处理需要排序，如果能通过 where 子句限制记录的数目，就可以减少这方面的开销。on、where、having 这三个都可以加条件的子句，on 是最先执行，where 次之，having 最后。</p><br></blockquote><br><ol start="27" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">使用 Truncate 替代 delete</section></li></ol><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">当需要删除全表的记录时使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Truncate</code>替代<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">delete</code>。在通常情况下, 回滚段(<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">rollback segments</code> ) 用来存放可以被恢复的信息. 如果你没有<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">COMMIT</code>事务,ORACLE 会将数据恢复到删除之前的状态(准确地说是恢复到执行删除命令之前的状况) 而当运用 TRUNCATE 时, 回滚段不再存放任何可被恢复的信息.当命令运行后,数据不能被恢复.因此很少的资源被调用,执行时间也会很短。</p><br></blockquote><br><ol start="28" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">使用表的别名:</section></li></ol><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">当在 SQL 语句中连接多个表时, 请使用表的别名并把别名前缀于每个 Column 上.这样一来,就可以减少解析的时间并减少那些由 Column 歧义引起的语法错误。</p><br></blockquote><br><ol start="29" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">union all</code> 替换 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">union</code></section></li></ol><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">当 SQL 语句需要<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">union</code>两个查询结果集合时，这两个结果集合会以 union all 的方式被合并，然后再输出最终结果前进行排序。如果用 union all 替代料 union，这样排序就不是不要了，效率就会因此得到提高. 需要注意的是，UNION ALL 将重复输出两个结果集合中相同记录。</p><br></blockquote><br><ol start="30" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">用 where 替代 order by：<br><blockquote class="multiquote-1" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">ORDER BY</code> 子句只在两种严格的条件下使用索引：<br>①<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">ORDER BY</code>中所有的列必须包含在相同的索引中并保持在索引中的排列顺序；<br>②<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">ORDER BY</code>中所有的列必须定义为非空；</p><br></blockquote><br></section></li></ol><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">低效: (索引不被使用)<br><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">SELECT DEPT_CODE FROM DEPT ORDER BY DEPT_TYPE</code></p><br></blockquote><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">高效: (使用索引)<br><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">SELECT DEPT_CODE FROM DEPT WHERE DEPT_TYPE &gt; 0</code></p><br></blockquote><br><ol start="31" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">避免索引列的类型转换：</section></li></ol><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">假设 EMP_TYPE 是一个字符类型的索引列.<br><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">SELECT … FROM EMP WHERE EMP_TYPE = 123</code><br>这个语句被转换为:<br><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">SELECT … FROM EMP WHERE EMP_TYPE=’123’</code>;<br>因为内部发生的类型转换, 这个索引将不会被用到! 为了避免 ORACLE 对你的 SQL 进行隐式的类型转换, 最好把类型转换用显式表现出来. 注意当字符和数值比较时, ORACLE 会优先转换数值类型到字符类型。</p><br></blockquote><br><ol start="32" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">优化 Group by</section></li></ol><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">提高<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">GROUP BY</code> 语句的效率, 可以通过将不需要的记录在<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">GROUP BY</code> 之前过滤掉。下面两个查询返回相同结果但第二个明显就快了许多。</p><br></blockquote><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">低效:<br><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">SELECT JOB , AVG(SAL) FROM EMP GROUP by JOB HAVING JOB = ‘PRESIDENT’ OR JOB = ‘MANAGER’</code></p><br></blockquote><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">高效:<br><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">SELECT JOB , AVG(SAL) FROM EMP WHERE JOB = ‘PRESIDENT’ OR JOB = ‘MANAGER’ GROUP by JOB</code></p><br></blockquote><br><ol start="33" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">避免使用耗费资源的操作：</section></li></ol><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">带有<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">DISTINCT</code>,<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">UNION,MINUS</code>,<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">INTERSECT</code>,<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">ORDER BY</code>的 SQL 语句会启动 SQL 引擎执行耗费资源的排序(SORT)功能. <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">DISTINCT</code>需要一次排序操作, 而其他的至少需要执行两次排序. 通常, 带有<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">UNION</code>, <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">MINUS</code> , <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">INTERSECT</code>的 SQL 语句都可以用其他方式重写. 如果你的数据库的 SORT_AREA_SIZE 调配得好, 使用 UNION , MINUS, INTERSECT 也是可以考虑的, 毕竟它们的可读性很强。</p><br></blockquote><br><ol start="34" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在运行代码中，尽量使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">PreparedStatement</code>来查询，不要用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Statement</code>。</section></li></ol><br><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">MySQL 常用的索引优化方法</span><span class="suffix"></span></h2><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">关于索引的优化，前面的文章已经详细的讲了二十条铁则，感兴趣的可以看<a href="https://mp.weixin.qq.com/s/fgi-BlRQxnM-kWUrTbctcw" style="word-wrap: break-word; font-weight: bold; color: #48b378; text-decoration: none; border-bottom: 1px solid #48b378;" target="_blank" rel="external">一文带你搞懂索引如何优化！</a></section></li></ul><br><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">MySQL 数据库的优化目标、常见误区和基本原则</span><span class="suffix"></span></h2><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">优化目标</span><span class="suffix" style="display: none;"></span></h3><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">MySQL 数据库是常见的两个瓶颈是 CPU 和 I/O 的瓶颈，CPU 在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候。磁盘 I/O 瓶颈发生在装入数据远大于内存容量的时候。</p><br><ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">减少 I/O 次数：I/O 永远是数据库最容易瓶颈的地方，这是由数据库的职责所决定的，大部分数据库操作中超过 90%的时间都是 IO 操作所占用的，减少 IO 次数是 SQL 优化中需要第一优先考虑，当然，也是收效最明显的优化手段。</p><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">降低 CPU 计算：除了 IO 瓶颈之外，SQL 优化中需要考虑的就是 CPU 运算量的优化了。<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">order by</code>, <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">group by</code>,<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">distinct</code> … 都是消耗 CPU 的大户（这些操作基本上都是 CPU 处理内存中的数据比较运算）。当我们的 IO 优化做到一定阶段之后，降低 CPU 计算也就成为了我们 SQL 优化的重要目标。</p><br></section></li></ul><br></section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">常见误区</span><span class="suffix" style="display: none;"></span></h3><br><ol data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">count(1)</code>和<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">count(primary_key)</code> 优于 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">count()</code>:</section></li></ol><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">很多人为了统计记录条数，就使用 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">count(1)</code> 和 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">count(primary_key)</code> 而不是 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">count(<em>)</em></code>，他们认为这样性能更好，其实这是一个误区。对于有些场景，这样做可能性能会更差，应为数据库对 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">count()</code> 计数操作做了一些特别的优化。如在 MyISAM 引擎中，会对表的总行数进行记录，使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">count（<em>）</em></code>可以直接取出该值。</p><br></blockquote><br><ol start="2" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">count(column)</code> 和 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">count()</code> 是一样的</section></li></ol><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">实际上，<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">count(column)</code> 和 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">count(<em>)</em></code> 是一个完全不一样的操作，所代表的意义也完全不一样。<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">count(column)</code> 是表示结果集中有多少个<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">column</code>字段不为空的记录，只处理非空值。<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">count()</code> 是表示整个结果集有多少条记录，不会跳过<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">null</code>值。</p><br></blockquote><br><ol start="3" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">select a,b from …</code>比 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">select a,b,c from …</code>可以让数据库访问更少的数据量<br><blockquote class="multiquote-1" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">实际上，大多数关系型数据库都是按照行（row）的方式存储，而数据存取操作都是以一个固定大小的 IO 单元（被称作 block 或者 page）为单位，一般为 4KB，8KB… 大多数时候，每个 IO 单元中存储了多行，每行都是存储了该行的所有字段（lob 等特殊类型字段除外）。所以，我们是取一个字段还是多个字段，实际上数据库在表中需要访问的数据量其实是一样的。</p><br></blockquote><br></section></li></ol><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">当然，也有例外情况，那就是我们的这个查询在索引中就可以完成，也就是说当只取 a,b 两个字段的时候，不需要回表，而 c 这个字段不在使用的索引中，需要回表取得其数据。在这样的情况下，二者的 IO 量会有较大差异。</p><br></blockquote><br><ol start="4" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">order by</code> 一定需要排序操作</p><br><blockquote class="multiquote-1" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">我们知道索引数据实际上是有序的，如果我们的需要的数据和某个索引的顺序一致，而且我们的查询又通过这个索引来执行，那么数据库一般会省略排序操作，而直接将数据返回，因为数据库知道数据已经满足我们的排序需求了。实际上，利用索引来优化有排序需求的 SQL，是一个非常重要的优化手段。</p><br></blockquote><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">执行计划中有 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">filesort</code> 就会进行磁盘文件排序</p><br><blockquote class="multiquote-1" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">有这个误区其实并不能怪我们，而是因为 MySQL 开发者在用词方面的问题。<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">filesort</code> 是我们在使用 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">explain</code> 命令查看一条 SQL 的执行计划的时候可能会看到在 “Extra” 一列显示的信息。实际上，只要一条 SQL 语句需要进行排序操作，都会显示<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Using filesort</code>，这并不表示就会有文件排序操作。</p><br></blockquote><br></section></li></ol><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">基本原则</span><span class="suffix" style="display: none;"></span></h3><br><ol data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">尽量少 join</p><br><blockquote class="multiquote-1" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">MySQL 的优势在于简单，但这在某些方面其实也是其劣势。MySQL 优化器效率高，但是由于其统计信息的量有限，优化器工作过程出现偏差的可能性也就更多。对于复杂的多表 Join，一方面由于其优化器受限，再者在 Join 这方面所下的功夫还不够，所以性能表现离 Oracle 等关系型数据库前辈还是有一定距离。但如果是简单的单表查询，这一差距就会极小甚至在有些场景下要优于这些数据库前辈。</p><br></blockquote><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">尽量少排序</p><br><blockquote class="multiquote-1" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">排序操作会消耗较多的 CPU 资源，所以减少排序可以在缓存命中率高等 IO 能力足够的场景下会较大影响 SQL 的响应时间。对于 MySQL 来说，减少排序有多种办法，比如：上面误区中提到的通过利用索引来排序的方式进行优化;减少参与排序的记录条数；非必要不对数据进行排序。</p><br></blockquote><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">尽量避免 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">select *</code></p><br><blockquote class="multiquote-1" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">很多人看到这一点后觉得比较难理解，上面不是在误区中刚刚说 select 子句中字段的多少并不会影响到读取的数据吗？<br>是的，大多数时候并不会影响到 IO 量，但是当我们还存在 order by 操作的时候，select 子句中的字段多少会在很大程度上影响到我们的排序效率，此外，上面误区中不是也说了，只是大多数时候是不会影响到 IO 量，当我们的查询结果仅仅只需要在索引中就能找到的时候，还是会极大减少 IO 量的。</p><br></blockquote><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">尽量用 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">join</code> 代替子查询</p><br><blockquote class="multiquote-1" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">虽然 Join 性能并不佳，但是和 MySQL 的子查询比起来还是有非常大的性能优势。</p><br></blockquote><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">尽量少 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">or</code></p><br><blockquote class="multiquote-1" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">当 where 子句中存在多个条件以“或”并存的时候，MySQL 的优化器并没有很好的解决其执行计划优化问题，再加上 MySQL 特有的 SQL 与 Storage 分层架构方式，造成了其性能比较低下，很多时候使用 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">union all</code> 或者是<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">union</code>（必要的时候）的方式来代替<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">or</code>会得到更好的效果。</p><br></blockquote><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">尽量用 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">union all</code> 代替 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">union</code></p><br><blockquote class="multiquote-1" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">union 和 union all 的差异主要是前者需要将两个（或者多个）结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的 CPU 运算，加大资源消耗及延迟。所以当我们可以确认不可能出现重复结果集或者不在乎重复结果集的时候，尽量使用 union all 而不是 union。</p><br></blockquote><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">尽量早过滤</p><br><blockquote class="multiquote-1" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">这一优化策略其实最常见于索引的优化设计中（将过滤性更好的字段放得更靠前）。<br>在 SQL 编写中同样可以使用这一原则来优化一些 Join 的 SQL。比如我们在多个表进行分页数据查询的时候，我们最好是能够在一个表上先过滤好数据分好页，然后再用分好页的结果集与另外的表 Join，这样可以尽可能多的减少不必要的 IO 操作，大大节省 IO 操作所消耗的时间。</p><br></blockquote><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">避免类型转换</p><br><blockquote class="multiquote-1" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">这里所说的“类型转换”是指 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">where</code> 子句中出现 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">column</code> 字段的类型和传入的参数类型不一致的时候发生的类型转换</p><br></blockquote><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">优先优化高并发的 SQL，而不是执行频率低某些“大”SQL</p><br><blockquote class="multiquote-1" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">对于破坏性来说，高并发的 SQL 总是会比低频率的来得大，因为高并发的 SQL 一旦出现问题，甚至不会给我们任何喘息的机会就会将系统压跨。而对于一些虽然需要消耗大量 IO 而且响应很慢的 SQL，由于频率低，即使遇到，最多就是让整个系统响应慢一点，但至少可能撑一会儿，让我们有缓冲的机会。</p><br></blockquote><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">从全局出发优化，而不是片面调整</p><br></section></li></ol><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">SQL 优化不能是单独针对某一个进行，而应充分考虑系统中所有的 SQL，尤其是在通过调整索引优化 SQL 的执行计划的时候，千万不能顾此失彼，因小失大。</p><br></blockquote><br><ol start="11" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">尽可能对每一条运行在数据库中的 SQL 进行 explain</section></li></ol><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">优化 SQL，需要做到心中有数，知道 SQL 的执行计划才能判断是否有优化余地，才能判断是否存在执行计划问题。在对数据库中运行的 SQL 进行了一段时间的优化之后，很明显的问题 SQL 可能已经很少了，大多都需要去发掘，这时候就需要进行大量的 explain 操作收集执行计划，并判断是否需要进行优化。</p><br></blockquote><br><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">MySQL 数据库的表结构优化</span><span class="suffix"></span></h2><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">由于 MySQL 数据库是基于行（Row）存储的数据库，而数据库操作 IO 的时候是以 page（block）的方式，也就是说，如果我们每条记录所占用的空间量减小，就会使每个 page 中可存放的数据行数增大，那么每次 IO 可访问的行数也就增多了。反过来说，处理相同行数的数据，需要访问的 page 就会减少，也就是 IO 操作次数降低，直接提升性能。此外，由于我们的内存是有限的，增加每个 page 中存放的数据行数，就等于增加每个内存块的缓存数据量，同时还会提升内存换中数据命中的几率，也就是缓存命中率。</section></li></ul><br><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">数据类型选择</span><span class="suffix" style="display: none;"></span></h3><br><ol data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">数据库操作中最为耗时的操作就是 IO 处理，大部分数据库操作 90% 以上的时间都花在了 IO 读写上面。所以尽可能减少 IO 读写量，可以在很大程度上提高数据库操作的性能。我们无法改变数据库中需要存储的数据，但是我们可以在这些数据的存储方式方面花一些心思。下面的这些关于字段类型的优化建议主要适用于记录条数较多，数据量较大的场景，因为精细化的数据类型设置可能带来维护成本的提高，过度优化也可能会带来其他的问题：</section></li></ol><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">数字类型</code>：非万不得已不要使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">DOUBLE</code>，不仅仅只是存储长度的问题，同时还会存在精确性的问题。同样，固定精度的小数，也不建议使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">DECIMAL</code>，建议乘以固定倍数转换成整数存储，可以大大节省存储空间，且不会带来任何附加维护成本。对于整数的存储，在数据量较大的情况下，建议区分开 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">TINYINT / INT / BIGINT</code> 的选择，因为三者所占用的存储空间也有很大的差别，能确定不会使用负数的字段，建议添加 unsigned 定义。当然，如果数据量较小的数据库，也可以不用严格区分三个整数类型。</p><br></blockquote><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">int</code>类型只增主键字段=&gt;4 字节=&gt;每个字节 8 位=&gt;32 位，在 CPU 加载一条指令的时候，4 字节是和 CPU 寄存器的运算有关，如：64 位，由于之前的系统一般都是 32 位的，所以在运算 4 字节的数据是刚好的，效率最高，而现今我们系统基本都是 64 位的时候，其实没有更好的利用好 CPU 运算，所以在设计表字段建议，使用 8 字节的主键<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">bigint</code>，而不是直接使用 int 来做主键。</p><br></blockquote><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">字符类型</code>：非万不得已不要使用 TEXT 数据类型，其处理方式决定了他的性能要低于 char 或者是 varchar 类型的处理。定长字段，建议使用 CHAR 类型，不定长字段尽量使用 VARCHAR，且仅仅设定适当的最大长度，而不是非常随意的给一个很大的最大长度限定，因为不同的长度范围，MySQL 也会有不一样的存储处理。<br>`char(10)`` 不管该字段是否存储数据，都占 10 个字符的存储空间，char(10) 同时存在一个坑，就是存储 abc 数据后改数据库字段的值为“abc 7 个空格 ”，在精准查询（where）就必须带上后面的 7 个空格。varchar 不存的时候不占空间，存多长数据就占多少空间。</p><br></blockquote><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">时间类型：尽量使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">TIMESTAMP</code>类型，因为其存储空间只需要 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">DATETIME</code> 类型的一半。对于只需要精确到某一天的数据类型，建议使用 DATE 类型，因为他的存储空间只需要 3 个字节，比 TIMESTAMP 还少。不建议通过 INT 类型类存储一个 unix timestamp 的值，因为这太不直观，会给维护带来不必要的麻烦，同时还不会带来任何好处。</p><br></blockquote><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">ENUM &amp; SET</code>：对于状态字段，可以尝试使用 ENUM 来存放，因为可以极大的降低存储空间，而且即使需要增加新的类型，只要增加于末尾，修改结构也不需要重建表数据。如果是存放可预先定义的属性数据呢？可以尝试使用 SET 类型，即使存在多种属性，同样可以游刃有余，同时还可以节省不小的存储空间。</p><br></blockquote><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">LOB</code>类型：强烈反对在数据库中存放 LOB 类型数据，虽然数据库提供了这样的功能，但这不是他所擅长的，我们更应该让合适的工具做他擅长的事情，才能将其发挥到极致。在数据库中存储 LOB 数据就像让一个多年前在学校学过一点 Java 的营销专业人员来写 Java 代码一样。</p><br></blockquote><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">字符编码</code>：字符集直接决定了数据在 MySQL 中的存储编码方式，由于同样的内容使用不同字符集表示所占用的空间大小会有较大的差异，所以通过使用合适的字符集，可以帮助我们尽可能减少数据量，进而减少 IO 操作次数。<br>① 纯拉丁字符能表示的内容，没必要选择 latin1 之外的其他字符编码，因为这会节省大量的存储空间；<br>② 如果我们可以确定不需要存放多种语言，就没必要非得使用 UTF8 或者其他 UNICODE 字符类型，这回造成大量的存储空间浪费；<br>③MySQL 的数据类型可以精确到字段，所以当我们需要大型数据库中存放多字节数据的时候，可以通过对不同表不同字段使用不同的数据类型来较大程度减小数据存储量，进而降低 IO 操作次数并提高缓存命中率。</p><br></blockquote><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">适当拆分</code>：有些时候，我们可能会希望将一个完整的对象对应于一张数据库表，这对于应用程序开发来说是很有好的，但是有些时候可能会在性能上带来较大的问题。当我们的表中存在类似于 TEXT 或者是很大的 VARCHAR 类型的大字段的时候，如果我们大部分访问这张表的时候都不需要这个字段，我们就该义无反顾的将其拆分到另外的独立表中，以减少常用数据所占用的存储空间。这样做的一个明显好处就是每个数据块中可以存储的数据条数可以大大增加，既减少物理 IO 次数，也能大大提高内存中的缓存命中率。</p><br></blockquote><br><ol start="2" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">上面几点的优化都是为了减少每条记录的存储空间大小，让每个数据库中能够存储更多的记录条数，以达到减少 IO 操作次数，提高缓存命中率。下面这个优化建议可能很多开发人员都会觉得不太理解，因为这是典型的反范式设计，而且也和上面的几点优化建议的目标相违背。</section></li></ol><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">适度冗余</code>：<br>为什么我们要冗余？这不是增加了每条数据的大小，减少了每个数据块可存放记录条数吗？确实，这样做是会增大每条记录的大小，降低每条记录中可存放数据的条数，但是在有些场景下我们仍然还是不得不这样做：<br>① 被频繁引用且只能通过 Join 2 张（或者更多）大表的方式才能得到的独立小字段：这样的场景由于每次 Join 仅仅只是为了取得某个小字段的值，Join 到的记录又大，会造成大量不必要的 IO，完全可以通过空间换取时间的方式来优化。不过，冗余的同时需要确保数据的一致性不会遭到破坏，确保更新的同时冗余字段也被更新。</p><br></blockquote><br><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;"><br><p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">尽量使用 NOT NULL</code>：<br>NULL 类型比较特殊，SQL 难优化。虽然 MySQL NULL 类型和 Oracle 的 NULL 有差异，会进入索引中，但如果是一个组合索引，那么这个 NULL 类型的字段会极大影响整个索引的效率。很多人觉得 NULL 会节省一些空间，所以尽量让 NULL 来达到节省 IO 的目的，但是大部分时候这会适得其反，虽然空间上可能确实有一定节省，倒是带来了很多其他的优化问题，不但没有将 IO 量省下来，反而加大了 SQL 的 IO 量。所以尽量确保 DEFAULT 值不是 NULL，也是一个很好的表结构设计优化习惯。</p><br></blockquote><br><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">MySQL 数据库的缓存参数优化</span><span class="suffix"></span></h2><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">用处不大，忽略</section></li></ul><br><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">总结</span><span class="suffix"></span></h2><br><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">数据库最常用的优化方式有：SQL 语句和索引、数据库表结构、系统配置、硬件。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">优化效果：SQL 语句和索引 &gt; 数据库表结构 &gt; 系统配置 &gt; 硬件，但成本从低到高。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">数据库的优化方法小结：<br><ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><br><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">设计符合范式的数据库</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">选择合适的存储引擎</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">SQL 语句优化</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引优化：高分离字段建立索引</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">SQL 表结构、字段优化</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">数据库参数优化：IO 参数、CPU 参数</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">分库分表：垂直切分与水平切分</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">分区：将表的数据按照特定的规则放在不同的分区，提高磁盘的 IO 效率，提高数据库的性能</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">主从复制与读写分离：三个主要线程与 bin-log 文件、relay_log 文件，主数据库负责写操作，从数据库负责读操作</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">负载均衡</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">数据库集群</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">硬件</section></li></ol><br></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">更多文章欢迎关注微信公众号【码猿技术专栏】</section></li></ul><br><p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E4%B8%83%E7%A7%92%E7%BC%96%E7%A8%8B.jpg&lt;/p&gt;
&lt;p id=&quot;nice-suffix-juejin-container&quot; class=&quot;nice-suffix-juejin-container&quot; data-tool=&quot;mdnice编辑器&quot; style=&quot;font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74" alt="">; line-height: 1.75em; margin-top: 20px !important;”&gt;本文使用 <a href="https://mdnice.com/?from=juejin" style="word-wrap: break-word; font-weight: bold; color: #48b378; text-decoration: none; border-bottom: 1px solid #48b378;" target="_blank" rel="external">mdnice</a> 排版</p></section>]]></content>
      <categories>
        <category>数据库干货篇</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
</search>
