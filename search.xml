<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Linux干货篇一]]></title>
      <url>%2F2017%2F04%2F13%2FLinux%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B8%80%2F</url>
      <content type="text"><![CDATA[Linux干货篇一虚拟机的安装(VMware) 选择文件-&gt;新建虚拟机 选择自定义 设置安装来源，选择稍后安装 选择安装的操作系统，选择Linux,然后选择自己安装的对应版本即可 设置虚拟机的安装路径，自己选择 指定磁盘容量，选择默认20G,然后选择将虚拟磁盘存储为单个文件 设置cpu数量，内存大小，默认即可 设置Linux安装镜像文件路径 点击开启虚拟机即可根据对应的设置安装 目录文件 /boot:存放系统引导时所需要的文件，包括Linux内核以及引导程序(BootLoader) /bin:存放可执行程序 /etc:存放系统配置文件 /home:普通用户的主目录所在位置 /lib:存放基本的共享文件和内核模块 /mnt(mount):用户为需要挂载的文件系统提供挂载点 /proc(process):存放与内核进程有关的信息 /root:根用户的主目录 /tmp(temporary):存放临时性文件 /usr(user):存放可共享的只读文件 /var(variable):存放各类的数据文件 ls重要选项 -a(all) 列出目录中的所有项，包括”.”开头的隐藏文件 -l(list) 以列表的方式显示文件 -R(recursive) 用于递归列出子目录中的内容，如果在选择的目录下还有子文件夹，那么可以列出子文件夹中的文件 -d仅仅列出目录本身的信息实例 ls -al /etc 以列表的方式列出ect目录下的所有文件 pwd 显示当前路径cd(切换目录) cd .. 跳闸到当前目录的上一级 cd ~ 跳转到当前用户的主目录 例子 cd /tmp/testdir 跳转到tmp文件下的testdir目录 stat 获取关于某文件的基本信息，包括创建的信息，大小，时间。。。。 实例 stat test 查看test文件的基本信息 touch 创建或者更新一个文件的访问和修改的时间，如果一个文件存在，那么更新这个文件的创建时间，但是文件的内容不会改变，如果文件不存在，那么就会在当前目录下创建一个文件 实例 touch /tmp/testdir/test 在指定路径下创建一个test文件，如果存在那么会更新创建的时间，可以使用stat命令查看创建时间 mkdir(创建目录) mkdir /tmp/testdir/test_file 在/tmp/testdir目录下创建一个test_file文件夹 mv 移动或者重命名文件或目录 重要选项 b(backup):若存在同名文件，覆盖前先备份原来的文件 f(force):强制覆盖同名的文件 实例12345mkdir /tmp/testdir //创建一个目录testdirtouch test1 test2 //创建两个文件test1 test2mv -b test1 test2 //移动test1为test2,这里会先备份原来的test2为test2~mv -b test1 /tmp/testdir1/test //移动文件到指定目录下 cp(copy) 复制文件和目录 选项 -b :8ball: 若存在同名文件，覆盖前先备份 -f :强制覆盖同名文件 -r : 以递归的方式复制文件，就是复制文件夹，如果不使用这个，那么文件夹就无法复制 实例 cp /tmp/testdir tmp/testdir1 复制文件夹，这里表示不能复制，因此要加上-r选项才能复制文件夹 -&gt; cp -r /tmp/testdir /tmp/testdir1 可以复制，复制到/tmp文件夹下命名为testdir1 cp -b /tmp/testdir/test1 /tmp/testdir1/test 将文件test1复制到testdir1文件夹下命名为test rm 删除命令 选项 -f 强制删除 -r 删除文件夹（递归删除） 实例 rm -rf /tmp/testdir 强制删除testdir目录 rmdir 删除目录，但是要求目录必须是空的，这里实用性不大，一般用rm -r cat 查看文件内容 重要选项 -n 显示行数 实例 cat -n /tmp/testdir/test 查看文件test的内容，显示行数 more 分屏显示文件内容，首先显示一屏后如果还有内容，按回车键在显示下一行，按Space显示下一屏的内容 实例 more /tmp/testdir/test tail 显示文本文件结尾的部分，默认显示最后10行 重要选项 -n 指定显示的行数 head 显示开头的内容，与tail类似 wc 一次显示文本文件的行数，单词数，字节数 重要选项 -c 显示文件字节数 -l(line) 显示文件行数 -w(word) 显示文件单词数 实例 wc -cl /tmp/testdir/test 查看文件的字数和文件的行数 date查看或者修改系统命令 实例 date 查看系统时间 date 09012017 修改系统时间为2017-09-01 who列出当前系统的登录用户 重要选项 -r 显示系统当前的运行级 -q 显示当前所有登录的用户名称和在线人数 shutdown关闭重启系统 重要选项 -r(reboot) 重启系统 -h(halt) 关闭系统 -P(poweroff) 关闭系统同时关闭电源 注意上面选项均可给出数字参数指定多少分钟之后执行操作 实例 shutdown -h 10 设置10分钟后关闭系统 clear清楚当前终端的屏幕内容 man显示命令的使用手册，按上下键移动光标，Q键退出 实例 man cat 快速查询cat命令的手册 histroy查看shell命令的历史记录 实例 histroy 5 显示最近的5条记录 vim调用vim编辑器，按i键插入，w键保存，q键退出，wq保存后退出 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL干货篇二]]></title>
      <url>%2F2017%2F04%2F09%2FSQL%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[SQL干货篇之查询数据单表查询 只在一个表中查询数据1SELECT * FROM student where Sno='13143'; //根据学号查询数据 多表查询 同时查询多个表12SELECT student.Sno,student.Sname,GradeFROM student,SC where Grade&gt;=90; 说明：这是在学生表student和成绩表SC中查询成绩大于90的学生姓名和学号,因为这里Sno,Sname在两个表中都存在，因此要指定查询哪一个表中的数据，而Grade只在SC表中出现，因此不用指明哪张表 模糊查找 说明：模糊查找用like和not like进行查找 SELECT * FROM student where Sname like &#39;刘%&#39;;查询所有姓刘的学生 SELECT * FROM student where Sname like &#39;%加%&#39;查询名字中含有加字的学生信息，不固定加字的位置，在任意位置都能查到，这里一般搜索引擎都用是用这种模糊查找的方法来匹配搜索项 SELECT * FROM student where Sname like &#39;欧阳_&#39;;查找以姓欧阳并且名字为三个字的学生信息 SELECT * FROM student WHERE Sname like &#39;_阳&#39;;查找所有姓名为两个字并且第二个字为阳的学生信息 SELECT * FROM student where Sname like &#39;_阳%&#39;;查询所有姓名中第二个字为阳的学生信息 SELECT * FROM Course where Cname like &#39;\_IS&#39; ESCAPE &#39;\&#39;;查询课程名字为_is的课程信息，这里如果要查询的字符串本省就含有通配符”%“或者”_“，这时就要使用ESCAPE&lt;转码字符&gt;来对字符进行转义了，这里的转码字符可以是任意的，但是我们通常都是用\,上面的查询语句中的\就是转码字符 空值查询 判断数据是否为空用is not null和is nullSELECT * FROM student where Sname is null;查询姓名为空的学生信息 多重条件的查询 多重条件的查询用AND和OR,其区别不用多说了SELECT Sname FROM student where Sdept=&#39;IS&#39; and Sage&gt;20;查找院系是IS并且年龄超过20岁的学生姓名 ORDER BY子句(排序) 用户可以使用ORDER BY子句对数据进行升序(ASC)或者降序(DESC)排列 SELECT * FROM student where Sage&gt;20 ORDER BY Sno DESC;查询年龄超过20岁的学生信息，并且按照降序排列输出 SELECT * FROM student ORDER BY Sdept,Sage DESC;查询全体学生情况，查询结果按照所在系的系号升序排列，同一系的按照年龄降序排列 聚集函数 COUNT(*) 统计元组个数 COUNT(DISTINCT|ALL &lt;列名&gt;) 计算一列中值的个数，其中DISTINCT表示去除重复的元素，ALL则保留所有的元素 SUM(DISTINCT|ALL &lt;列名&gt;) 计算一列值的总和 AVG(DISTINCT|ALL&lt;列名&gt;) 计算一列中的平均值 MAX(DISTINCT|ALL&lt;列名&gt; ) 求一列中的最大值 MIN(DISTINCT|ALL&lt;列名&gt; ) 求一列中的最小值 实例： select count(*) from student; 查询学生总数 select count(DISTINCT Sdept); 查询总共有多少系 select AVG(Grade) from SC; 查询学生的平均分 select SUM(Grade) from SC; 查询学生的总分 select MAX(Grade) from SC where Cno=&#39;1&#39;; 查询课程1的最高分 select MIN(Grade) from SC where Cno=&#39;1&#39;; 查询课程1的最低分 注意：where子句中不能用聚集函数，只有在select子句和Group by子句中才能使用聚集函数 GROUP BY子句 GROUP BY子句将查询结果按某一列或者多列的值分组，值相等的为一组。 对查询结果分组的目的是为了细化聚集函数的对象。如果未对查询结果进行分组，那么聚集函数将会作用于整个查询结果，分组后聚集函数将会作用于每一组，即每一组都有一个函数值 实例： select Cno,Count(Sno) from SC Group by Cno; 求各个课程号以及相应的选课人数 select Cno as &#39;课程号&#39;,count(Sno) as &#39;选课人数&#39; from sc group by Cno;求各个课程号以及相应的选课人数 select Cno,count(Sno),AVG(Grade) from sc group by Cno Having AVG(Grade)&gt;80; 查询课程平均分大于80分的课程号和所选学生人数,这里是先分组后然后对这些组进行筛选就用Having子句进行条件筛选，不能使用where子句进行筛选,当然这里的sleect子句中的AVG(Grade)可以去掉,可以写成select Cno,count(Sno) from sc group by Cno Having AVG(Grade)&gt;80; select Sno from sc Group by Sno having count(*)&gt;2; 查询选修了两门以上课程的学生学号 select Sno,AVG(Grade) from sc Group by Sno; 查询每一个学生选修课程的平均成绩,这里先按照学号进行分组，然后对每一个分组进行求平均成绩 注意：这里的如果使用了聚集函数，那么select子句中出现的选项一定要在聚集函数或者Group by子句中出现，否则就会出现错误，如：select Sno,count(Cno) from sc;这条语句就是错误的，因为Sno没有出现在聚集函数或者Group by子句中，如果改成select Sno,count(Cno) from SC Group by Sno;就正确了,因为Sno出现在了Group by子句中了 连接查询 如果一个查询涉及两个以上的表则称之为连接查询，连接查询包括等值连接查询，自然连接查询，自身连接查询，非等值连接查询，外连接查询，复合条件查询 等值和非等值连接查询当连接运算符为=时为等值连接查询，否则为非等值连接查询 实例： select student.*,SC.* from student,SC where student.Sno=SC.Sno;查询每个学生及其选修课程的情况 自然连接查询在等值连接的基础上去掉相等的属性组就是自然连接查询 实例：select student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade from student,SC where student.Sno=SC.Sno; 嵌套查询 在SQL语言中一个SELECT-FROM-WHERE语句称为一个查询块，将一个查询块嵌套在另外一个查询块的WHERE子句或HAVING短语的条件查询称之为嵌套查询实例：12SELECT SNAME FROM STUDENT WHERE SNO IN /*外层查询*/(SELECT SNO FROM SC WHERE CNO='2'); /*内层查询或者子查询*/ 注意: 这里的查询条件Sno只能有一个，并且外层查询的where子句中出现的Sno属性要和内层查询select语句中的Sno属性要对应。 子查询中不能使用ORDER BY子句，ORDER BY子句只能对最终的查询结果排序 带有IN谓词的嵌套查询 实例： 12345678910SELECT Sno,Sname,Sdept from student where Sdept IN(SELECT Sdept From student Where Sname='刘晨');``` **查询与刘晨在同一个系的学生信息,当然本例中也可以用自身连接查询来完成，如下：**```sqlselect first.Sno,first.Sname,first.Sdept from student first,student secondwhere first.Sdept=second.Sdept and second.Sname='刘晨'; 带有比较运算符的子查询12select Sno,Cno from sc x where Grade &gt;(select AVG(Grade) from sc y where x.Sno=y.Sno); 查询了所有学生成绩超过选修课程平均成绩的课程号 带有ANY或者ALL的谓词子查询 ANY表示查询条件只要满足其中一个即可，而ALL表示查询条件要满足所有的才行实例： SELECT SNAME,SAGE FROM STUDENT WHERE SAGE&lt;ANY(SELECT SAGE FROM STUDENT WHERE SDEPT=&#39;CS&#39;) AND SDEPT!=&#39;CS&#39;;查询非计算机系的比计算机系任意一个学生年龄小的学生姓名和年龄,这里只要满足比一个学生的年龄小即可 SELECT SNAME,SAGE FROM STUDENT WHERE SAGE&lt;ALL(SELECT SAGE FROM STUDENT WHERE SDEPT=&#39;CS&#39;) AND SDEPT!=&#39;CS&#39;;查询非计算机系的比计算机系的所有学生年龄小的学生信息，这里要满足比所有的学生信息都要小，就是比计算机系年龄最小的都要小 带有EXISTS谓词的子查询 EXISTS表示存在的意思，带有EXISTS的子查询步返回任何的数据，只产生逻辑真或者假 SELECT Sname From student where EXISTS (SELECT Sname from SC where Sno=student.Sno and Cno=&#39;2&#39;);查询选择课程2的学生姓名，这里只判断是否存在这样的学生，如果子查询中没有找到课程2这项，那么查到的就是空,子查询只判断是否为true or false,当然还有NOT EXISTS 集合查询 集合操作包括并操作UNION、交操作INTERSECT、差操作EXCEPT 实例： select * from student where Sdept= &#39;CS&#39; UNION select * from student where Sage&gt;19;查找计算机系的学生以及年龄不大于19岁的学生信息，这里UNION会自动去掉重复的元组，如果想要保留全部的数据需要用UNION ALL select Sno from SC where Cno=&#39;1&#39; UNION select Sno from SC where Cno=&#39;2&#39;;查询选修课程1或者选修课程2的学生学号，这里并集就是去掉重复的元组，使用UNION ALL 可以保留 select Sno from SC where Cno=&#39;1&#39; Intersect select Sno from SC where Cno=&#39;2&#39;;查询同时选修课程1和课程2的学生学号 基于派生表的查询123select Sno,Cno from SC,(select Sno,AVG(Grade) from SC Group by Sno) AS AVG_SC(avg_Sno,avg_grade)where SC.Sno=AVG_SC.avg_Sno and SC.Grade&gt;=AVG_SC.avg_grade; 这里的From子句中将会派生出一个AVG_SC表,该表由avg_Sno、avg_grade组成，主查询将SC表和AVG_SC表进行连接，选出修课成绩大于其平均成绩的课程号 注意：如果子查询中没有聚集函数，那么派生表不用指定属性列，子查询后面的列名为其属性，如下： select Sname from student,(select Sno From SC where Cno=&#39;1&#39;) AS SCI where student.Sno=SCI.Sno;这里的SCI默认的列属性名是Sno，AS关键词可以省略，但是必须要为派生表指定一个别名。 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java干货篇之文字特效]]></title>
      <url>%2F2017%2F04%2F09%2Fjava%E5%B9%B2%E8%B4%A7%E7%AF%87%E4%B9%8B%E6%96%87%E5%AD%97%E7%89%B9%E6%95%88%2F</url>
      <content type="text"><![CDATA[java干货篇文字特效立体效果的文字主要使用了Graphics类中的setFont和setColor的方法，绘制多层字然后加上平移一个坐标即可实现多重叠加的效果,让人看起来就像是立体一样,详情请见源码 阴影效果的文字和面一样，只是平移的方式有些不同，详情请见源码 倾斜效果的文字主要使用的时Graphics2D类的shear方法，使绘图上下文倾斜，详情见源码public abstract void shear(double shx,double shy)其中shx表示在正x轴方向移动坐标的乘数，可以作为其y坐标的函数 渐变效果的文字主要使用了Graphics2D中的setPaint的方法,详情请见源码public abstract void setPaint(Paint paint)paint封装了渐变颜色的Paint对象其中Paint对象的创建是由GradientPaint初始化的,其中的构造函数如下：GradientPaint(float x1, float y1, Color color1, float x2, float y2, Color color2) 会变色的文字这个主要使用了多线程的方式实现的，用多线程改变Color方法中的RGB的值,用Random在指定范围内任意取值然后组成了不同的颜色，详情请见源码 水印文字特效(源码)水印文字主要通过改变了文字的透明度实现的，将文字绘制在图片上，然后改变图片的透明度，主要使用了Graphaics2D中的setComposite方法，定义如下：public abstract void setComposite(Composite comp)，其中Comp是AlphaComposite对象，可以使用以下两种方式创建 AlphaComposite alpha=AlphaComposite.getInstance(AlphaComposite.SRC_OVER,0.3f)获得一个SRC_OVER规则的对象 AlphaComposite alpha=AlphaComposite.SC_OVER.driver(0.3f)同上 动态绘制文本(源码)主要使用BufferedReader缓冲流从指定文件中读取一个字符，然后使用线程一个一个的绘制在画板上，中间sleep了400ms，这样就能展示出动态的效果，还使用了System类的getProperty方法获得项目的路径,以下提供了两种方法读取文件，更多的读取方法请看我的博客文章 BufferedReader read=new BufferedReader(new FileReader(pathname)) BufferedReader read=new BufferedReader(new InputStreamReader(in)) 由于都是比较简单的代码，这里不再贴出来le，有想要看的朋友，请点击上面的源码 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[swing干货系列之JTextField]]></title>
      <url>%2F2017%2F04%2F08%2FSwing%E5%B9%B2%E8%B4%A7%E7%B3%BB%E5%88%97%E4%B9%8BJTextField%2F</url>
      <content type="text"><![CDATA[Swing系列之JTextField(单行文本框)介绍 JTextField是一个轻量级组件，它允许编辑单行文本。 JTextField 具有建立字符串的方法，此字符串用作针对被激发的操作事件的命令字符串。java.awt.TextField 把字段文本用作针对 ActionEvent 的命令字符串。如果通过 setActionCommand 方法设置的命令字符串不为 null，则 JTextField 将使用该字符串来保持与 java.awt.TextField 的兼容性，否则将使用字段文本来保持兼容性。 setEchoChar 和 getEchoChar 方法不是直接提供的，以避免可插入的外观的新实现意外公开密码字符。为了提供类似密码的服务，单独的类 JPasswordField 扩展了 JTextField，从而通过可插入外观独立地提供此服务。 JTextField 的水平对齐方式可以设置为左对齐、前端对齐、居中对齐、右对齐或尾部对齐。右对齐/尾部对齐在所需的字段文本尺寸小于为它分配的尺寸时使用。这是由 setHorizontalAlignment 和 getHorizontalAlignment 方法确定的。默认情况下为前端对齐。 文本字段如何使用 VK_ENTER 事件取决于文本字段是否具有任何操作侦听器。如果具有操作侦听器，则 VK_ENTER 导致侦听器获取一个 ActionEvent，并使用 VK_ENTER 事件。这与 AWT 文本字段处理 VK_ENTER 事件的方式是兼容的。如果文本字段没有操作侦听器，则从 1.3 版本开始不使用 VK_ENTER 事件。而是处理祖先组件的绑定，这将启用 JFC/Swing 的默认按钮特性。 Swing 不是线程安全的 构造函数 JTextField() 构造一个新的 TextField JTextField(Document doc, String text, int columns) 构造一个新的 JTextField，它使用给定文本存储模型和给定的列数。 JTextField(int columns) 构造一个具有指定列数的新的空 TextField。 JTextField(String text)构造一个用指定文本初始化的新 TextField。 JTextField(String text, int columns) 构造一个用指定文本和列初始化的新 TextField。 常用的函数 get/setHorizontalAlignment(int alignment) 设置/得到文本的水平对齐方式。其中水平的对齐方式有：JTextField.LEFT JTextField.CENTER JTextField.RIGHT JTextField.LEADING (the default) JTextField.TRAILING setFont(Font font) 设置字体 setScrollOffset(int scrollOffset) 获取滚动偏移量（以像素为单位）。 setDocument(Document doc) 将编辑器与一个文本文档关联，这里的意思就是将此文本框与一个文本文档关联，这将会保持内容一致，如果一个改变了，另外一个也会改变。 setInputVerifier(verifier) 设置验证方式，如果此文本不能通过验证那么就不能将焦点聚焦到下一个组件上，就会一直聚焦到这个文本框上 setDragEnabled(boolean x) 设置在文本框中是否能够拖放文本,为true则是能够，这里的意思就是能够将文本选中后能不能将文本拖走 addActionListener(ActionListener action) 添加监听机制，输入文本按回车即可触发，和按钮的监听机制相同 write(InfileWriter writer) 将文本框中的内容输入到文件中 addKeyListener(KeyListener event) 添加键盘监听，在文本框中输入内容时会触发键盘，其中有按下，释放，键入的动作，详情见官方文档 addCaretListener(CareListener event) 添加一个侦听文本组件插入符的位置更改的侦听器，只要鼠标指针的位置改变就会触发 一个简单的实例1234567891011121314151617181920212223242526272829303132333435363738394041import javax.swing.*;import java.awt.*;class text extends JFrame &#123; private JTextField textField1; private JTextField textField2; public static void main(String args[]) &#123; text my = new text(); my.setVisible(true); &#125; public text() &#123; //this.setBounds(100,100,300,200); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JPanel panel = new JPanel(new GridLayout(2, 1)); textField1 = new JTextField(10); textField2 = new JTextField(); panel.add(textField1); panel.add(textField2); this.getContentPane().add(panel, BorderLayout.CENTER); this.pack(); InputVerifier verifier = new InputVerifier() &#123; //添加验证方式 @Override public boolean verify(JComponent input) &#123; //重载函数 boolean value; textField1 = (JTextField) input; //将input组件强制转化为JTextField类型的单行文本框 return textField1.getText().equals("pass"); //判断是否输入的时pass,如果不是就会验证错误 &#125; &#125;; textField1.setInputVerifier(verifier); //设置验证方式 textField1.setHorizontalAlignment(JTextField.CENTER); //设置水平对齐方式 Font font = new Font("楷体", Font.BOLD + Font.ITALIC, 20); textField1.setFont(font); //设置字体 textField1.setDragEnabled(true); //设置在单行文本框中能够拖放文本，如果为false则不能够拖放文本 &#125;&#125; 关联文本文档123456789101112131415161718192021222324252627282930313233343536import java.awt.Container;import java.awt.GridLayout;/*from w ww.jav a 2s . co m*/import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JTextField;import javax.swing.text.Document;public class Main extends JFrame &#123; JLabel nameLabel = new JLabel("Name:"); JLabel mirroredNameLabel = new JLabel("Mirrored:"); JTextField name = new JTextField(20); JTextField mirroredName = new JTextField(20); public Main() &#123; this.setDefaultCloseOperation(EXIT_ON_CLOSE); this.setLayout(new GridLayout(2, 0)); Container contentPane = this.getContentPane(); contentPane.add(nameLabel); contentPane.add(name); contentPane.add(mirroredNameLabel); contentPane.add(mirroredName); Document nameModel = name.getDocument(); //得到文本框的文本文档，将之与第二个文本框关联 mirroredName.setDocument(nameModel); //两个文本框中的内容相互关联，这样只需要在一个里面输入文本，同时也会在另外一个文本框中显示 pack(); setVisible(true); &#125; public static void main(String[] args) &#123; Main frame = new Main(); &#125;&#125; 说明：这里是将两个文本框相关联，这样就能达到一个文本框输入的同时，另外一个也会同时更新内容 Action Listener(动作监听机制)输入文本后按回车即可触发123456789101112131415161718192021222324252627import java.awt.event.ActionEvent;//from w w w. ja va2s .c o mimport javax.swing.JFrame;import javax.swing.JTextField;public class Main &#123; public static void main(String[] a) &#123; JFrame frame = new JFrame(); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JTextField jTextField1 = new JTextField(); jTextField1.setText("jTextField1"); //添加监听机制 jTextField1.addActionListener(new java.awt.event.ActionListener() &#123; public void actionPerformed(ActionEvent e) &#123; System.out.println("action"); &#125; &#125;); frame.add(jTextField1); frame.setSize(300, 200); frame.setVisible(true); &#125;&#125; 验证文本内容使用InputVerifier)验证 12345678910111213141516171819202122232425262728293031import java.awt.BorderLayout;import javax.swing.InputVerifier;import javax.swing.JComponent;import javax.swing.JFrame;import javax.swing.JTextField;public class Main &#123; public static void main(String args[]) &#123; JFrame frame = new JFrame("Verifier Sample"); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JTextField textField1 = new JTextField(); JTextField textField2 = new JTextField(); InputVerifier verifier = new InputVerifier() &#123; //创建一个验证 public boolean verify(JComponent comp) &#123; boolean returnValue; JTextField textField = (JTextField) comp; //强制转换，将控件类型的comp转换成JTextFiled类型的 try &#123; Integer.parseInt(textField.getText()); //将输入的内容转化程int类型，如果输入的字符串不是十进制的话就会触发 //NumberFormateException错误 returnValue = true; &#125; catch (NumberFormatException e) &#123; returnValue = false; &#125; return returnValue; //如果返回false的话，那么指针就会一直聚焦在此文本框中，不能移动到其他的组件上 &#125; &#125;; textField1.setInputVerifier(verifier); frame.add(textField1, BorderLayout.NORTH); frame.add(textField2, BorderLayout.CENTER); frame.setSize(300, 100); frame.setVisible(true); &#125;&#125; 说明：如果返回false的话，那么指针就会一直聚焦在此文本框中，不能移动到其他的组件上 将文本框中的内容保存到文件中12345678910111213141516171819202122232425262728293031323334353637383940414243444546import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.io.File;import java.io.FileWriter;import java.io.IOException;class Main extends JFrame &#123; private JTextField textField; private FileWriter writer; public static void main(String args[]) &#123; Main my = new Main(); my.setVisible(true); &#125; public Main() &#123; this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JPanel panel = new JPanel(new BorderLayout()); JButton button = new JButton("运行"); JLabel label = new JLabel("name"); textField = new JTextField(); panel.add(label, BorderLayout.WEST); panel.add(textField, BorderLayout.CENTER); String filename = "text.txt"; button.addActionListener(new ActionListener() &#123; //添加一个按钮触发装置，这里只要点击一下anniu就会将文本框中的内容输入到文件中 @Override public void actionPerformed(ActionEvent e) &#123; try &#123; writer = new FileWriter(filename, false); //创建一个写入文件的对象，这里的false表示不在文件的末尾添加 textField.write(writer); //将单行文本中输入的内容写入到文件中 writer.close(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); System.out.println("false"); &#125; &#125; &#125;); panel.add(button, BorderLayout.SOUTH); this.getContentPane().add(panel, BorderLayout.CENTER); this.pack(); &#125;&#125; 说明：这里使用的是FileWriter类将内容写入到文件中，详情请看我的上一篇文章 复制、粘贴、剪切文本 这里使用的时copy()、paste()、cut()函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.awt.FlowLayout;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JTextField;import javax.swing.event.CaretEvent;import javax.swing.event.CaretListener;public class Main &#123; public static void main(String args[]) &#123; final JTextField textField = new JTextField(15); JButton buttonCut = new JButton("Cut"); JButton buttonPaste = new JButton("Paste"); JButton buttonCopy = new JButton("Copy"); JFrame jfrm = new JFrame("Cut, Copy, and Paste"); jfrm.setLayout(new FlowLayout()); jfrm.setSize(230, 150); jfrm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); buttonCut.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent le) &#123; textField.cut(); &#125; &#125;); buttonPaste.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent le) &#123; textField.paste(); &#125; &#125;); buttonCopy.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent le) &#123; textField.copy(); &#125; &#125;); textField.addCaretListener(new CaretListener() &#123; public void caretUpdate(CaretEvent ce) &#123; System.out.println("All text: " + textField.getText()); if (textField.getSelectedText() != null) System.out.println("Selected text: " + textField.getSelectedText()); else System.out.println("Selected text: "); &#125; &#125;); jfrm.add(textField); jfrm.add(buttonCut); jfrm.add(buttonPaste); jfrm.add(buttonCopy); jfrm.setVisible(true); &#125;&#125; 说明：这里使用的时用三个按钮监听操作，只需要按住对应的按钮就会触发机制 添加键盘监听机制12345678910111213141516171819202122232425262728293031323334353637383940import java.awt.Dimension;import java.awt.FlowLayout;import java.awt.HeadlessException;import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JTextField;public class Main extends JFrame &#123; public Main() throws HeadlessException &#123; setSize(200, 200); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setLayout(new FlowLayout(FlowLayout.LEFT)); JLabel usernameLabel = new JLabel("Username: "); JTextField usernameTextField = new JTextField(); usernameTextField.setPreferredSize(new Dimension(100, 20)); add(usernameLabel); add(usernameTextField); usernameTextField.addKeyListener(new KeyAdapter() &#123; //创建机制 public void keyReleased(KeyEvent e) &#123; //重载函数，释放按键触发 JTextField textField = (JTextField) e.getSource(); //得到最初发生event的组件对象,既是文本框对象 String text = textField.getText(); textField.setText(text.toUpperCase()); //将所有的小写字母转换成大写字母 &#125; public void keyTyped(KeyEvent e) &#123; //键入时触发 &#125; public void keyPressed(KeyEvent e) &#123; //释放按键时触发的函数 &#125; &#125;); &#125; public static void main(String[] args) &#123; new Main().setVisible(true); &#125;&#125; 添加插入符位置变化的监听机制使用的是CareListener类来实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.zzk;import java.awt.BorderLayout;import java.awt.Color;import java.awt.Font;import java.awt.Graphics;import java.awt.Graphics2D;import javax.swing.JFrame;import javax.swing.JPanel;import javax.swing.JTextField;import javax.swing.event.CaretEvent;import javax.swing.event.CaretListener;public class ClockwiseTextFrame extends JFrame &#123; private JTextField textField; ClockwiseTextPanel clockwiseTextPanel = new ClockwiseTextPanel(); // 创建面板类的实例 public static void main(String args[]) &#123; // 主方法 ClockwiseTextFrame frame = new ClockwiseTextFrame(); // 创建窗体类的实例 frame.setVisible(true); // 显示窗体 &#125; public ClockwiseTextFrame() &#123; super(); // 调用超类的构造方法 setTitle("顺时针旋转文字"); // 窗体标题 setBounds(100, 100, 340, 240); // 窗体的显示位置和大小 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 窗体关闭方式 add(clockwiseTextPanel); // 将面板类的实例添加到窗体容器中 textField = new JTextField(); textField.addCaretListener(new CaretListener() &#123; public void caretUpdate(CaretEvent arg0) &#123; String text = textField.getText();// 获取文本框字符串 clockwiseTextPanel.setText(text);// 为面板中的text变量赋值 &#125; &#125;); getContentPane().add(textField, BorderLayout.SOUTH); &#125; class ClockwiseTextPanel extends JPanel &#123; // 创建内部面板类 private String text; public ClockwiseTextPanel() &#123; setOpaque(false);// 设置面板为透明 setLayout(null);// 设置为绝对布局 &#125; public String getText() &#123; return text; // 获得成员变量的值 &#125; public void setText(String text) &#123; this.text = text;// 为成员变量赋值 repaint();// 调整paint()方法 &#125; public void paint(Graphics g) &#123;// 重写paint()方法 Graphics2D g2 = (Graphics2D) g;// 获得Graphics2D的实例 int width = getWidth();// 获得面板的宽度 int height = getHeight();// 获得面板的高度 if (text != null) &#123; char[] array = text.toCharArray();// 将文本转换为字符数组 int len = array.length * 5;// 定义圆的半径，同时可以调整文字的距离 Font font = new Font("宋体", Font.BOLD, 22);// 创建字体 g2.setFont(font);// 设置字体 double angle = 0;// 定义初始角度 for (int i = 0; i &lt; array.length; i++) &#123;// 遍历字符串中的字符 if (i == 0) &#123; g2.setColor(Color.BLUE);// 第一个字符用蓝色 &#125; else &#123; g2.setColor(Color.BLACK);// 其他字符用黑色 &#125; int x = (int) (len * Math.sin(Math.toRadians(angle + 270)));// 计算每个文字的横坐标位置 int y = (int) (len * Math.cos(Math.toRadians(angle + 270)));// 计算每个文字的纵坐标位置 g2.drawString(array[i] + "", width / 2 + x, height / 2 - y);// 绘制字符 angle = angle + 360d / array.length;// 改变角度 &#125; &#125; &#125; &#125;&#125; 参考文档 官方网站) 英文文档 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[scrapy爬取豆瓣全站]]></title>
      <url>%2F2017%2F04%2F08%2Fscrapy%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E5%85%A8%E7%AB%99%2F</url>
      <content type="text"><![CDATA[Scrapy爬取豆瓣读书全站分析网页 首先打开豆瓣读书中的分类浏览，可以看到其中有很多的分类 豆瓣应该是一个比较好爬的网站，所有的数据都不是ajax加载的，我们打开谷歌的F12或者是火狐的FireBug可以很轻松的找到每一个分类的链接 这里我们使用scrapy中的一个linkextractors库,这个库的作用是会根据提供的限制，自动爬取和深入每一个页面并且提取需要的链接，如果想要找到每一个分类的url,只需Rule(LinkExtractor(allow=&#39;/tag/&#39;,restrict_xpaths=&quot;//div[@class=&#39;article&#39;]&quot;),follow=True),这里的allow是一个正则表达式，用来筛选分类url,restrict_xpaths是限制在哪个结构中筛选url,这里限制的是在&lt;div class=&#39;article&#39;&gt;这个盒模型中，follow表示是否深入，这里当然是要深入,这里就能得到每一个分类url了，自己可以在回调函数中测试下，输入所得的url,可以使用respose.url 得到所有的分类url，就可以继续深入到每一步作品所在的页面了，如下图! 但是我们需要不止是这一页，我们要爬的时全站，因此这里必须实现翻页，我们可以看到页面底部清楚的写着下一页，我们通过解析页面同样可以得到url,如下图所示 可以看到所有的url的规则，我们就可以用正则表达式限制，以获取我们的需要，我们可以写出翻页的代码 1Rule(LinkExtractor(allow="\?start=\d+\&amp;type=",restrict_xpaths="//div[@class='pa&gt;ginator']"),follow=True), 最后一步就是打开每一部书的网页得到所需的信息了，我们就可以通过这里通过解析网页还是可以很清楚的知道url,这里就不再详细的说怎么解析了，这里可以看到所有的url都在li标签中，如下图 我们打开li标签可以很清楚的看大url的规律，因此这里还是用到上面说的库解析深入，连同上面的代码如下 123Rule(LinkExtractor(allow='/tag/',restrict_xpaths="/ /div[@class='article']"),follow=True),#第一步Rule(LinkExtractor(allow="\?start=\d+\&amp;type=",restrict_xpaths="//div[@class='pa&gt;ginator']"),follow=True), #第二步翻翻页Rule(LinkExtractor(allow="/subject/\d+/$",restrict_&gt;xpaths="//ul[@class='subject-list']"),callback='parse_item')#得到所需网页的url 到了这里总算是大功告成了，下面就需要解析自己的所需要的信息了,这里附上网页 下面就是写自己解析代码了，这里就不需要详细的说了，详细内容请看源码,值得注意的是爬取的网页速度不要太快，豆瓣会禁IP的，这里可以采用一些反爬虫措施,如请求头的更换，ip地址的更换，下一篇会详细解说。 参考文档： scrapy中文文档 最后附上本人的github地址,不要忘了给个star哦 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL干货篇一]]></title>
      <url>%2F2017%2F04%2F06%2FSQL%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[SQL系列之基本操作新建表 CREATE TABLE [&lt;列名&gt;&lt;数据类型&gt;[表级完整性约束条件]],[&lt;列名&gt;&lt;数据类型&gt;[表级完整性约束条件]]…… 实例 12345CREATE TABLE student(Sno CHAR(9) PRIMARY KEY,Sname CHAR(20) UNIQUE,Ssex CHAR(2),Sage SMALLINT,Sdept CHAR(20)); 其中student是表名，Sno,Sname,Ssex,Sage,Sdept都是列名，后面的CHAR都是数据类型,这里的PRIMARY KEY是将Sno定义为主键,UNIQUE是将Sname定义为唯一的也就是后面插入数据的时候不能有重复的名字 拓展：主键的定义是在多个候选码中找出那个能够唯一识别一组数据的列名，如果需要两个列名才能识别一组数据，那么可以将这两个列名都定义为主键：PRIMARY KEY(Sno,Sname) 删除表 DROP TABLE NAME;只能删除没有被其他表引用，或者没有建立视图的，这里的引用可以是作为被参照表或者作为参照表 DROP TABLE NAME CASCADE;将全部删除，包括基本表和视图 修改表 添加列 alter table 表名 add 列名 列数据类型 [after 插入位置] 例子 alter table student add grade smallint; //将grade插入到student表中的末尾一列，这里不加after默认的是在末尾添加 alter table studnet add grade smallint after Sname; //这里将grade插入到表中Sname列的后面 删除列alter table 表名 drop 列名 alter table student drop Sname; //输出Sname那一列 修改列alter table 表名 change 列名称 列新名称 新数据类型; 实例 alter table student change Sname name char(10) not null; //修改列名Sname为name,并且还可以修改其中的数据类型，如果想要保持不变，就保持原型。 重命名表alter table 表名 rename 新表名; 实例：alter table student rename STUDENT; //将表名改为STUDENT 插入数据 INSERT INTO table_name(列名,列名，列名....)VALUES(DATA); //这里的data一定要对应每一列的数据类型，当然如果要想要插入所有的数据，就不需要列出所有的列名了 例子: INSERT INTO student(Sno,Sname,Sage,Ssex)values(&#39;201215124&#39;,&#39;jack&#39;,34,&#39;男&#39;); //这里是插入表中的一些列的数据，并且对应了数据类型 INSERT INTO student values(&#39;201215124&#39;,&#39;男&#39;,&#39;jack&#39;,34,&#39;IS&#39;); //这里是按照表中的列名顺序插入数据的 更新数据 update 表名称 set 列名称=新值 where 更新条件; 实例： update student set Sage=Sage+1 where Sno=&#39;12134&#39;; //将Sno为12134的那一列数据的年龄加一 删除表中的数据 delete from 表名称 where 删除条件; 实例： delete from student where Sno=’121314125’; //删除Sno为121314125的那一行数据 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[swing布局管理器]]></title>
      <url>%2F2017%2F04%2F05%2Fjava%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8%2F</url>
      <content type="text"><![CDATA[Swing系列之布局管理器流布局(FlowLayout)默认的JApplet,JPanel,JScrollPane 流布局是相对比较简单的一种布局管理器，也是最常用的布局管理器。在流布局中放置控件时，将按照控件的添加顺序，依次将控件从左到右进行摆放，并且在一行的最后会进行自动换行放置 。在一行中，控件是默认居中放置的。 布局管理器也是通过构造器来创建的。流布局是通过FlowLayout 类来创建，FlowLayout类具有三种构造器。首先是无参构造器， 使用无参构造器能够创建一个默认的以居中对齐方式，控件间水 平和垂直间距为5个像素的流布局。 FlowLayout类还具有一个需要整型参数的构造器，使用该构造器能够创建一个指定对齐方式的流布局管理器，它的控件间水平和垂直间距仍然是默认的5个像素。流布局管理器的对齐方式如下所示。 LEFT 左对齐方式 CENTER 居中对齐方式 RIGHT 右对齐方式 LEADING 控件与容器开始边对齐 TRAILING 构造函数： FlowLayout(),生成一个默认的FlowLayout布局。默认情况下，组件居中，间隙为5个像素。 FlowLayout(int aligment),设定每珩的组件的对齐方式。alignment取值可以为FlowLayout.LEFT,FlowLayout.CENTER,FlowLayout.RIGHT。 FlowLayout(int aligment,int horz, int vert),设定对齐方式，并设定组件的水平间距horz和垂直间距vert，用超类Container的方法setLayout()为容器设定布局。例如，代码setLayout(new FlowLayout())为容器设定 FlowLayout布局。将组件加入容器的方法是add(组件名)。 常用的函数：getAlignment方法和setAlignment方法分别获取和设置流布局管理器的对齐方式。 getHgap方法和setHgap方法分别获取和设置流布局管理器中控件和控件之间的水平间距。getVgap方法和setVgap方法分别获取和 设置流布局管理器中控件和控件之间的垂直间距。12345678910111213141516171819202122232425262728293031import javax.swing.*;import java.awt.*;/** * Created by Chenjiabing on 2017/4/5. */public class BuJu &#123; public static void main(String args[]) &#123; JFrame frame=new JFrame(); FlowLayout flowLayout=new FlowLayout(FlowLayout.LEFT); JPanel panel=new JPanel(flowLayout); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setBounds(100,100,500,400); flowLayout.setHgap(20); //设置水平间距 flowLayout.setVgap(20); //控件之间的垂直间距 for(int i=0;i&lt;6;i++) &#123; JButton button=new JButton("按钮"); panel.add(button); &#125; frame.getContentPane().add(panel); frame.setVisible(true); &#125;&#125; 网格布局(GridLayout) 网络布局也是一种比较常见的布局管理器。使用网格布局管理器后，会将所有的控件尽量按照给出的行数和列数来排列，同时网格布局管理器也会对控件进行尺寸的调整，使所有的控件具有相同的尺寸。在网格布局中，也会尽量使使用的空间成矩形的形式来显示。当窗体发生大小变化时，所有的空间也将自动改变大小来填充窗体。 网格布局是通过GridLayout类来创建的。GridLayout类具有三个构造器，使用无参构造器将创建具有默认行和默认列的网格布局。在创建网格布局管理器时最常用的就是具有两个整型参数的构造器，第一个参数表示网格布局管理器的行数，第二个参数表示网格布局管理器的列数。还有一个具有四个参数的构造器，除了可以定义行数和列数外，还可以定义控件间水平间距和垂直间距。 GridLayout类中还定义了一些方法来对创建的网格布局进行操作 。getRows方法和setRows方法分别是获取和设置网格布局的行数。getColumns方法和setColumns方法分别是获取和设置网格布局 的列数。getHgap方法和setHgap方法分别是获取和设置网格布局 中控件间水平间距。getVgap方法和setVgap方法分别是获取和设 置网络布局中的控件间垂直间距。 构造函数： GridLayout(),生成一个单列的GridLayout布局。默认情况下，无间隙。1.GridLayout(int row,int col),设定一个有行row和列`col的GridLayout布局。 GridLayout(int row,int col,int horz,int vert),设定布局的行数和列数、组件的水平间距和垂直间距 代码大概和上面的设置一样，这里注意的是，网格布局是以行为基准的，如果定义的控件多了或者少了，不会改变行的数量，会根据情况改变列的数量 边框布局(BorderLayout)默认的是JWindow、JFrame,JDialog 上面学习的流布局和网格布局具有很多相似的地方，但是边框布局就和他们存在很大的不同。在使用边框布局时，通常都会由程序员来为控件指定在容器中的位置。边框布局将容器分为五个部分，包括东南西北中五部分。在每一个部分中只能放置一个控件 ，所以如果控件超过五个将不能完全显示。在使用边框布局时需 要注意的是，当容器的大小发生变化时，四周的控件是不会发生变化的，只有中间的控件将发生变化。 边框布局是通过BorderLayout类创建的。BorderLayout类具有两个构造器，一个是无参构造器，另一个是指定控件间间距的构造器，通常使用无参构造器来创建边框布局管理器。 在前面将控件添加到容器中都是通过add方法，将控件作为add方法的参 数来进行添加的。但是在向边框布局容器中添加控件时，这样是不完全 的。在向边框布局容器中添加控件是使用具有两个参数的add方法。其中 第一个参数表示要添加的控件，第二个参数表示要添加到边框布局中的 哪一个位置。边框布局的位置表示是通过常量来表示的，具体常量如下所示 NORTH 容器顶部 SOUTH 容器底部 WEST 容器左边 EAST 容器右边 CENTER 容器的中央 构造函数： BorderLayout(),生成一个默认的BorderLayout布局。默认情况下，没有间隙。 BorderLayout(int horz,int vert),设定组件之间的水平间距和垂直间距。 注意这里还有一些常用的方法，就是设置水平和垂直的间距，上面已经赘述过了，这里就不再详说了 空布局(null) 空布局就是没有使用布局管理器，在空布局的情况下将根据控件的自身信息来为控件指定位置。这就使得控件的布局更加灵活，与此同时给开发人员带来了更大的工作量。 空布局是不需要使用类来创建的，只需要在程序指定布局管理器 为null。将控件添加到空布局容器中时，仍然是使用add方法。因 为这里使用的是空布局管理器，所以在添加控件之前，要对控件 进行设置操作。设置操作是通过setBounds方法来完成的， setBounds方法的基本语法格式如下所示。 public void setBounds(int x,int y,int width,int height); 其中x和y表示的是控件最左上侧的坐标，从而也固定了该控件的 位置。width和height表示的是空间的宽度和高度，从而也指定了控件的大小。 示例代码：1234567&gt;frame.setLayout(null);//布局管理器设置为null JLabel label = new JLabel("First Name:"); label.setBounds(20, 20, 100, 20);//四个参数分别是x,y坐标和label的宽和高 JTextField textField = new JTextField(); textField.setBounds(124, 25, 100, 20); frame.add(label); frame.add(textField); BoxLayout BoxLayout是一种能够实现所有的控件水平放置和垂直放置，因为用到的不多，这里就简单的说一下构造函数：public BoxLayout(Container target,int axis):其中axis表示放置的样式，主要有两种常用到的: X_AXIS:指定组件应该从左到右放置。 Y_AXIS：指定组件从上到下放置 代码 12345678910111213141516171819202122232425262728import oracle.jrockit.jfr.JFR;import javax.swing.*;import java.awt.*;public class BuJu &#123; public static void main(String args[]) &#123; JFrame frame = new JFrame(); // frame.setLayout(new BorderLayout(frame.getComponentCount(),BoxLayout.Y_AXIS)); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JPanel panel = new JPanel(); BoxLayout boxLayout = new BoxLayout(panel, BoxLayout.X_AXIS); panel.setLayout(boxLayout); for (int i = 0; i &lt; 10; i++) &#123; JButton button = new JButton("cma"); panel.add(button); &#125; frame.getContentPane().add(panel, BorderLayout.CENTER); // System.out.println(boxLayout.getTarget()); frame.pack(); //frame.setSize(300,200); frame.setVisible(true); &#125;&#125; 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java图像处理干货篇一]]></title>
      <url>%2F2017%2F04%2F04%2Fjava%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%B9%B2%E8%B4%A7%E7%AF%87%2F</url>
      <content type="text"><![CDATA[java图像处理干货篇绘制图像 绘制图像主要用到的是Graphics类中drawImage方法，当然Graphics2D中也有相应的方法 主要的用法： public abstract boolean drawImage(Image img,x,y,ImageObserver observer):img是Image对象，x,y起始坐标,observer是观察对象 drawImage(Image img,int x,int y,int width,int height,Imageobersver observer):width和height是指定图像的宽度和高度，主要的作用是放大和缩小图像 drawImage(Image img,int dx1,int dy1,int dx2,int dx2,int sx1,int sy1,int sx2,int sy2,ImageObserver observer):主要用来翻转图形,通过互换源矩形的第一个和第二个角的x坐标可以实现水平翻转，通过互换源矩形的第一个和第二个角的y坐标可以实现垂直翻转 翻转图像12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.zzk;import java.awt.BorderLayout;import java.awt.Graphics;import java.awt.Image;import java.awt.Toolkit;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.net.URL;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JPanel;public class PartImageFrame extends JFrame &#123; private Image img = null; // 声明图像对象 private PartImagePanel imagePanel = null; // 声明图像面板对象 private int dx1, dy1, dx2, dy2; // 目标矩形第一个角与第二个角的X、Y坐标 private int sx1, sy1, sx2, sy2; // 源矩形第一个角与第二个角的X、Y坐标 public static void main(String args[]) &#123; PartImageFrame frame = new PartImageFrame(); frame.setVisible(true); &#125; public PartImageFrame() &#123; super(); URL imgUrl = PartImageFrame.class.getResource("/img/image.jpg");// 获取图片资源的路径 img = Toolkit.getDefaultToolkit().getImage(imgUrl); // 获取图像资源 dx2 = sx2 = 340; // 初始化图像大小 dy2 = sy2 = 200; // 初始化图像大小 imagePanel = new PartImagePanel(); // 创建图像面板对象 this.setBounds(200, 160, 355, 276); // 设置窗体大小和位置 this.add(imagePanel); // 在窗体中部位置添加图像面板对象 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置窗体关闭模式 this.setTitle("翻转图像"); // 设置窗体标题 final JPanel panel = new JPanel(); getContentPane().add(panel, BorderLayout.SOUTH); final JButton btn_h = new JButton(); btn_h.addActionListener(new ActionListener() &#123; public void actionPerformed(final ActionEvent e) &#123; // 下面3行代码用于交换sx1和sx2的值 int x = sx1; sx1 = sx2; sx2 = x; imagePanel.repaint(); // 重新调用面板类的paint()方法 &#125; &#125;); btn_h.setText("水平翻转"); panel.add(btn_h); final JButton btn_v = new JButton(); btn_v.addActionListener(new ActionListener() &#123; public void actionPerformed(final ActionEvent e) &#123; // 下面3行代码用于交换sy1和sy2的值 int y = sy1; sy1 = sy2; sy2 = y; imagePanel.repaint();// 重新调用面板类的paint()方法 &#125; &#125;); btn_v.setText("垂直翻转"); panel.add(btn_v); &#125; // 创建面板类 class PartImagePanel extends JPanel &#123; public void paint(Graphics g) &#123; g.clearRect(0, 0, this.getWidth(), this.getHeight());// 清除绘图上下文的内容 g.drawImage(img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, this);// 绘制图像 &#125; &#125;&#125; 旋转图像 主要用到的是Graphics2D类中的rotate函数，定义如下:public abstract void rotate(double theta): theta是角度，以弧度为单位代码如下 123456789101112131415161718192021222324252627282930package com.zzk;import java.awt.*;import java.net.URL;import javax.swing.*;public class RotateImageFrame extends JFrame &#123; private Image img = null; private RotatePanel rotatePanel = null; public RotateImageFrame() &#123; URL imgUrl = RotateImageFrame.class.getResource(&quot;/img/image.jpg&quot;);// 获取图片资源的路径 img = Toolkit.getDefaultToolkit().getImage(imgUrl); // 获取图片资源 rotatePanel = new RotatePanel(); // 创建旋转图像的面板对象 this.setBounds(150, 120, 380, 310); // 设置窗体大小和位置 add(rotatePanel);// 在窗体上放置图像面板 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置窗体关闭模式 this.setTitle(&quot;旋转图像&quot;); // 设置窗体标题 &#125; public static void main(String[] args) &#123; new RotateImageFrame().setVisible(true); &#125; class RotatePanel extends JPanel &#123; public void paint(Graphics g) &#123; Graphics2D g2 = (Graphics2D) g; // 获得Graphics2D对象 g2.drawImage(img, 80, 10, 260, 150, this); // 绘制指定大小的图片 g2.rotate(Math.toRadians(10)); // 将图片旋转10度 g2.drawImage(img, 80, 10, 260, 150, this); // 绘制指定大小的图片 g2.rotate(Math.toRadians(10)); // 将图片旋转10度 g2.drawImage(img, 80, 10, 260, 150, this); // 绘制指定大小的图片 &#125; &#125;&#125; 倾斜图像 主要用到的是Graphics2D中的shear函数定义如：public abstract void shear(doubel shx,double shy):shx是在正x轴上移动坐标的乘数，它可以作为其纵坐标的值,shy是在正y轴方形移动坐标的乘数，它可以作为其x坐标的函数。本人的理解：倾斜画布，如果shx&gt;0就是向正方向平移，平移的长度为shx*height(图形纵坐标的值，如果是矩形就是乘以矩形的高)相同的对于shy是乘以矩形宽123456789101112131415161718192021222324252627package com.zzk;import java.awt.*;import java.net.URL;import javax.swing.*;public class ShearImageFrame extends JFrame &#123; private Image img; private ShearImagePanel canvasPanel = null; public ShearImageFrame() &#123; URL imgUrl = ShearImageFrame.class.getResource("/img/image.jpg");// 获取图片资源的路径 img = Toolkit.getDefaultToolkit().getImage(imgUrl); // 获取图片资源 canvasPanel = new ShearImagePanel(); // 创建绘制倾斜图像的面板对象 this.setBounds(100, 100, 360, 240); // 设置窗体大小和位置 add(canvasPanel);// 在窗体上添加面板对象 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置窗体关闭模式 this.setTitle("倾斜图像"); // 设置窗体标题 &#125; public static void main(String[] args) &#123; new ShearImageFrame().setVisible(true); &#125; class ShearImagePanel extends JPanel &#123;// 绘制倾斜图像的面板类 public void paint(Graphics g) &#123; Graphics2D g2=(Graphics2D) g;// 获得Graphics2D对象 g2.shear(0, -0.5);// 倾斜图像 g2.drawImage(img, 10, 20, 220, 160, this); // 绘制指定大小的图片 &#125; &#125;&#125; 裁剪图片 public BufferedImage createScreenCapture(Rectangle screenRect):返回的是一个BufferedImage对象，参数是Rectangle对象，这个函数是Robot类中的，主要用于裁剪图形 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package com.zzk;import java.awt.AWTException;import java.awt.BasicStroke;import java.awt.BorderLayout;import java.awt.Color;import java.awt.Graphics;import java.awt.Graphics2D;import java.awt.Image;import java.awt.Rectangle;import java.awt.Robot;import java.awt.Toolkit;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import java.awt.event.MouseMotionAdapter;import java.awt.image.BufferedImage;import java.net.URL;import javax.swing.JFrame;import javax.swing.JPanel;import javax.swing.JSplitPane;public class CutImageFrame extends JFrame &#123; private Image img = null; // 声明图像对象 private OldImagePanel oldImagePanel = null; // 声明图像面板对象 private int pressPanelX = 0, pressPanelY = 0;// 鼠标按下点的X、Y坐标 private int pressX = 0, pressY = 0;// 鼠标按下点在屏幕上的X、Y坐标 private int releaseX = 0, releaseY = 0;// 鼠标释放点在屏幕上的X、Y坐标 private Robot robot = null; // 声明Robot对象 private BufferedImage buffImage = null; // 声明缓冲图像对象 private CutImagePanel cutImagePanel = new CutImagePanel(); // 创建绘制裁剪结果的面板 private boolean flag = false; // 声明标记变量，为true时显示选择区域的矩形，否则不显示 public static void main(String args[]) &#123; CutImageFrame frame = new CutImageFrame(); frame.setVisible(true); &#125; public CutImageFrame() &#123; super(); URL imgUrl = CutImageFrame.class.getResource("/img/image.jpg");// 获取图片资源的路径 img = Toolkit.getDefaultToolkit().getImage(imgUrl); // 获取图像资源 oldImagePanel = new OldImagePanel(); // 创建图像面板对象 this.setBounds(200, 160, 355, 276); // 设置窗体大小和位置 final JSplitPane splitPane = new JSplitPane(); splitPane.setDividerLocation((this.getWidth() / 2) - 10); getContentPane().add(splitPane, BorderLayout.CENTER); splitPane.setLeftComponent(oldImagePanel); splitPane.setRightComponent(cutImagePanel); oldImagePanel.addMouseListener(new MouseAdapter() &#123; public void mousePressed(final MouseEvent e) &#123; // 鼠标键按下事件 pressPanelX = e.getX(); // 获得鼠标按下点的X坐标 pressPanelY = e.getY();// 获得鼠标按下点的Y坐标 pressX = e.getXOnScreen() + 1;// 鼠标按下点在屏幕上的X坐标加1，即去除选择线 pressY = e.getYOnScreen() + 1;// 鼠标按下点在屏幕上的Y坐标加1，即去除选择线 flag = true;// 为标记变量赋值为true &#125; public void mouseReleased(final MouseEvent e) &#123; // 鼠标键释放事件 releaseX = e.getXOnScreen() - 1;// 鼠标释放点在屏幕上的X坐标减1，即去除选择线 releaseY = e.getYOnScreen() - 1;// 鼠标释放点在屏幕上的Y坐标减1，即去除选择线 try &#123; robot = new Robot();// 创建Robot对象 if (releaseX - pressX &gt; 0 &amp;&amp; releaseY - pressY &gt; 0) &#123; Rectangle rect = new Rectangle(pressX, pressY, releaseX - pressX, releaseY - pressY);// 创建Rectangle对象 buffImage = robot.createScreenCapture(rect);// 获得缓冲图像对象 cutImagePanel.repaint(); // 调用CutImagePanel面板的paint()方法 &#125; &#125; catch (AWTException e1) &#123; e1.printStackTrace(); &#125; flag = false;// 为标记变量赋值为false &#125; &#125;); oldImagePanel.addMouseMotionListener(new MouseMotionAdapter() &#123; public void mouseDragged(final MouseEvent e) &#123;// 鼠标拖动事件 if (flag) &#123; releaseX = e.getXOnScreen();// 获得鼠标释放点在屏幕上的X坐标 releaseY = e.getYOnScreen();// 获得鼠标释放点在屏幕上的Y坐标 oldImagePanel.repaint();// 调用OldImagePanel面板的paint()方法 &#125; &#125; &#125;); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置窗体关闭模式 this.setTitle("裁剪图片"); // 设置窗体标题 &#125; class OldImagePanel extends JPanel &#123;// 创建绘制原图像的面板类 public void paint(Graphics g) &#123; Graphics2D g2 = (Graphics2D) g; g2.drawImage(img, 0, 0, this.getWidth(), this.getHeight(), this);// 绘制图像 g2.setColor(Color.WHITE); if (flag) &#123; float[] arr = &#123;5.0f&#125;; // 创建虚线模式的数组 BasicStroke stroke = new BasicStroke(1, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 1.0f, arr, 0); // 创建宽度是1的平头虚线笔画对象 g2.setStroke(stroke);// 设置笔画对象 g2.drawRect(pressPanelX, pressPanelY, releaseX - pressX, releaseY - pressY);// 绘制矩形选区 &#125; &#125; &#125; class CutImagePanel extends JPanel &#123;// 创建绘制裁剪结果的面板类 public void paint(Graphics g) &#123; g.clearRect(0, 0, this.getWidth(), this.getHeight());// 清除绘图上下文的内容 g.drawImage(buffImage, 0, 0, releaseX - pressX, releaseY - pressY, this);// 绘制图像 &#125; &#125;&#125; 调整图片的亮度 RescaleOp类中的filter方法原缓冲图像进行重缩放，定义如下public abstract BufferedImage filter(BufferedImage src,BufferedImage dst):src是要过滤的源对象，dst是目标对象，或则为null 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.zzk;import java.awt.BorderLayout;import java.awt.Graphics;import java.awt.Image;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.image.BufferedImage;import java.awt.image.RescaleOp;import java.io.File;import java.io.IOException;import javax.imageio.ImageIO;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JPanel;public class ImageBrightenFrame extends JFrame &#123; private BufferedImage image;// 用于调整亮度的缓冲图像对象 private BufferedImage oldImage;// 用于存放调整亮度之前的原缓冲图像对象 private ImageBrightenPanel imageBrightenPanel = new ImageBrightenPanel(); public static void main(String args[]) &#123; ImageBrightenFrame frame = new ImageBrightenFrame(); frame.setVisible(true); &#125; public ImageBrightenFrame() &#123; super(); setBounds(100, 100, 357, 276); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setTitle("调整图片的亮度"); Image img = null; try &#123; img = ImageIO.read(new File("src/img/image.jpg")); // 创建图像对象 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; image = new BufferedImage(img.getWidth(this), img.getHeight(this), BufferedImage.TYPE_INT_RGB);// 创建缓冲图像对象 image.getGraphics().drawImage(img, 0, 0, null);// 在缓冲图像对象上绘制图像 oldImage = image;// 存储原来的图像对象，用于以后的恢复操作 getContentPane().add(imageBrightenPanel, BorderLayout.CENTER); final JPanel panel = new JPanel(); getContentPane().add(panel, BorderLayout.SOUTH); final JButton button = new JButton(); button.addActionListener(new ActionListener() &#123; public void actionPerformed(final ActionEvent e) &#123; float a = 1.0f;// 定义缩放因子 float b = 5.0f;// 定义偏移量 RescaleOp op = new RescaleOp(a,b,null);// 创建具有指定缩放因子和偏移量的 RescaleOp对象 image = op.filter(image, null);// 对源图像中的数据进行逐像素重缩放，达到变亮的效果 repaint();// 重新绘制图像 &#125; &#125;); button.setText("变 亮"); panel.add(button); final JButton button_3 = new JButton(); button_3.addActionListener(new ActionListener() &#123; public void actionPerformed(final ActionEvent e) &#123; float a = 1.0f;// 定义缩放因子 float b = -5.0f;// 定义偏移量 RescaleOp op = new RescaleOp(a,b,null);// 创建具有指定缩放因子和偏移量的 RescaleOp对象 image = op.filter(image, null);// 对源图像中的数据进行逐像素重缩放，达到变暗的效果 repaint();// 重新绘制图像 &#125; &#125;); button_3.setText("变 暗"); panel.add(button_3); final JButton button_2 = new JButton(); button_2.addActionListener(new ActionListener() &#123; public void actionPerformed(final ActionEvent e) &#123; image = oldImage; // 获得变亮前的图像 imageBrightenPanel.repaint();// 重新绘制原图像，即恢复为变亮前的图像 &#125; &#125;); button_2.setText("恢 复"); panel.add(button_2); final JButton button_1 = new JButton(); button_1.addActionListener(new ActionListener() &#123; public void actionPerformed(final ActionEvent e) &#123; System.exit(0); &#125; &#125;); button_1.setText("退 出"); panel.add(button_1); &#125; class ImageBrightenPanel extends JPanel &#123; public void paint(Graphics g) &#123; if (image != null) &#123; g.drawImage(image, 0, 0, null); // 将缓冲图像对象绘制到面板上 &#125; &#125; &#125;&#125; 补充说明：这里的RescaleOp类可以调整色数，其原理是每一个样本值乘以一个缩放因子然后加上偏移量就是缩放的数，如果要变亮的话就将偏移量为正，反之为负，这里将缩放因子设置为1.0f是因为不想那么快速的变亮，如果你设置的大一点，就会很快变得很亮，反之亦然 转换彩色图片为灰色图片 主要使用ColorConvertOp类，其构造函数如下public ColorConvertOp(ColorSpace src,ColorSpace dst,RenderingHints hints):src是原颜色空间对象，dst是目标颜色空间对象，hints是用于控制颜色转换的RenderingHints对象，可以为null使用ColorConvertOp类中的filter方法将彩色图像转换成灰色图像，定义如下：public final BufferedImage filter(BufferedImage src,BufferedImage dst):scr要过滤的对象，dst目标空间对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.zzk;import java.awt.BorderLayout;import java.awt.Graphics;import java.awt.Image;import java.awt.color.ColorSpace;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.image.BufferedImage;import java.awt.image.ColorConvertOp;import java.io.File;import java.io.IOException;import javax.imageio.ImageIO;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JPanel;public class MultiColorToGrayFrame extends JFrame &#123; private BufferedImage image; private ColorToGrayPanel colorToGrayPanel = new ColorToGrayPanel(); public static void main(String args[]) &#123; MultiColorToGrayFrame frame = new MultiColorToGrayFrame(); frame.setVisible(true); &#125; public MultiColorToGrayFrame() &#123; super(); setBounds(100, 100, 357, 276); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setTitle("彩色图像转换为灰度"); Image img = null; try &#123; img = ImageIO.read(new File("src/img/image.jpg")); // 创建图像对象 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; image = new BufferedImage(img.getWidth(this), img.getHeight(this), BufferedImage.TYPE_INT_RGB);// 创建缓冲图像对象 image.getGraphics().drawImage(img, 0, 0, null);// 在缓冲图像对象上绘制图像 getContentPane().add(colorToGrayPanel, BorderLayout.CENTER); final JPanel panel = new JPanel(); getContentPane().add(panel, BorderLayout.SOUTH); final JButton button = new JButton(); button.addActionListener(new ActionListener() &#123; public void actionPerformed(final ActionEvent e) &#123; ColorSpace colorSpace1 = ColorSpace.getInstance(ColorSpace.CS_GRAY);// 创建内置线性为灰度的颜色空间 ColorSpace colorSpace2 = ColorSpace.getInstance(ColorSpace.CS_LINEAR_RGB);// 创建内置线性为 RGB的颜色空间 ColorConvertOp op = new ColorConvertOp(colorSpace1,colorSpace2, null);// 创建进行颜色转换的对象 image = op.filter(image, null);// 对缓冲图像进行颜色转换 repaint();// 重新绘制图像 &#125; &#125;); button.setText("转换为灰度"); panel.add(button); final JButton button_1 = new JButton(); button_1.addActionListener(new ActionListener() &#123; public void actionPerformed(final ActionEvent e) &#123; System.exit(0); &#125; &#125;); button_1.setText("退 出"); panel.add(button_1); &#125; class ColorToGrayPanel extends JPanel &#123; public void paint(Graphics g) &#123; if (image != null) &#123; g.drawImage(image, 0, 0, null); // 将缓冲图像对象绘制到面板上 &#125; &#125; &#125;&#125; 补充说明：这里的image.getGraphics().drawImage(img, 0, 0, null)可以删除的，因为这里Graphics类中的drawImage可以直接绘制BufferedImage类型的缓冲图像，下面会给出一段代码做个示范 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import javax.imageio.ImageIO;import javax.swing.*;import java.awt.*;import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;/** * Created by Chenjiabing on 2017/4/5. */public class demo extends JFrame&#123; private BufferedImage image=null; private Graphics2D graphics2D=null; private draw my_draw=new draw(); public static void main(String args[]) &#123; demo my=new demo(); my.setVisible(true); &#125; public demo() &#123; this.setBounds(100,100,1000,1000); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); try&#123; image= ImageIO.read(new File("src/img/image.jpg")); //graphics2D=image.createGraphics(); //graphics2D.drawImage(image,0,0,null); // image.getGraphics().drawImage(image,0,0,null); &#125; catch (IOException e) &#123; e.printStackTrace(); System.out.println("error"); &#125; this.getContentPane().add(my_draw); &#125; class draw extends JPanel &#123; public void paint(Graphics g) &#123; g.drawImage(image,0,0,image.getWidth(),image.getHeight(),this); &#125; &#125;&#125; 总结： 从文件中读取图像的方法 URL imgUrl = CutImageFrame.class.getResource(“/img/image.jpg”);//得到的是URL img = Toolkit.getDefaultToolkit().getImage(imgUrl); //得到的是Image对象，同样的想要得到BufferedImage对象可以进行转 化 Image img=ImageIo(new File(&quot;path&quot;));这里得到的是Image对象，如果想要得到BufferedImage对象，可以用BufferedImage的构造方法BufferedImage(int width,int height,) 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[matplotlib绘制图形基础]]></title>
      <url>%2F2017%2F04%2F01%2Fmatplotlib%E7%BB%98%E5%88%B6%E5%9B%BE%E5%BD%A2%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[matplotlib绘制基本图形折线图12345678import matplotlib.pyplot as pltimport numpy as npx=np.arange(0,10,1) #创建一个0-10之间以1为间隔的numpy数组y=x+10 plt.plot(x,y,color='red',linestyle='--',marker='&gt;',linewidth=3,label='example one') #绘制图形plt.savefig('first.png',dpi=50) #保存图形，dpi表示plt.legend() #显示图例plt.show() #显示图形 图形展示说明plt.plot()可以直接绘制折线，其中marker是折线上的标记，linewidth是折线的宽度，label是图例，如果要想显示就要设置plt.legend(),linestyle是折线的风格，color是颜色 饼状图123456789101112131415import matplotlib.pyplot as pltslices = [2,3,4,9] #指定每一个切片的大小，这里就是每块的比例activities = ['sleeping','eating','working','playing'] #指定标签cols = ['c','m','r','b'] #y颜色plt.pie(slices, labels=activities, colors=cols, #指定每一个区块的颜色 startangle=90, #开始角度，默认是0度，从x轴开始，90度从y轴开始 shadow= True, #阴影效果 explode=(0,0.1,0,0), #拉出第二个切片，如果全为0就不拉出，这里的数字是相对与圆心的距离 autopct='%1.1f%%') #显示百分比plt.title('Interesting Graph\nCheck it out') #设置标题plt.show() 图片展示 散点图12345678import numpy as npimport matplotlib.pyplot as pltx=np.random.rand(1000)y=np.random.rand(len(x))plt.scatter(x,y,color='r',alpha=0.3,label='example one',marker='o') #绘图plt.legend()#plt.axis([0,2,0,2]) #设置坐标的范围plt.show() 图片展示 直方图123456789import matplotlib.pyplot as pltimport numpy as npx=np.random.randint(1,1000,200)axis=plt.gca() #得到当前的绘图对象axis.hist(x,bins=35,facecolor='r',normed=True,histtype='bar',alpha=0.5)#bins表示直方图的个数，histtype表示直方图的样式，normed如果为True就将直方归一化，显示概率密度，默认是Falseaxis.set_xlabel("Values") #设置x的标签axis.set_ylabel("Frequency") axis.set_title("HIST")plt.show() 图片展示 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swing干货系列之JSplitPane(分割面板)]]></title>
      <url>%2F2017%2F03%2F28%2FSwing%E4%B8%AD%E7%9A%84JSplitPane%2F</url>
      <content type="text"><![CDATA[Swing中的JSplitPane(分割面板)引言 JSplitPane 用于分隔两个（只能两个）Component。两个 Component 图形化分隔以外观实现为基础，并且这两个 Component 可以由用户交互式调整大小。有关如何使用 JSplitPane 的信息，请参阅 The Java Tutorial 中的 How to Use Split Panes 一节。 使用 JSplitPane.HORIZONTAL_SPLIT 可让分隔窗格中的两个 Component 从左到右排列，或者使用 JSplitPane.VERTICAL_SPLIT 使其从上到下排列。改变 Component 大小的首选方式是调用 setDividerLocation，其中 location 是新的 x 或 y 位置，具体取决于 JSplitPane 的方向。 要将 Component 调整到其首选大小，可调用 resetToPreferredSizes。 当用户调整 Component 的大小时，Component 的最小大小用于确定 Component 能够设置的最大/最小位置。如果两个组件的最小大小大于分隔窗格的大小，则分隔条将不允许您调整其大小。改变 JComponent 最小大小，请参阅 JComponent.setMinimumSize(java.awt.Dimension)。 当用户调整分隔窗格大小时，新的空间以 resizeWeight 为基础在两个组件之间分配。默认情况下，值为 0 表示右边/底部的组件获得所有空间，而值为 1 表示左边/顶部的组件获得所有空间。补充说明： 这里的JComponebt.SetMinimumSize(java.awt.Dimension):用于设置组件的最小值，这里的Dimension是一个封装组件的高度和宽度的一个类，其中的一个构造函数就是Dimension(int width,int height),详情见文档，当然有设置最小的就有设置最大的啊，详情看文档吧 构造函数 public JSplitPanel():创建一个配置为将其子组件水平排列、无连续布局、为组件使用两个按钮的新 JSplitPane public JSplitPanel(int newOrientation):创建一个指定方向的分割板，这里的newOrientation可以设置两个值， VERTICAL_SPLIT(设置分割板为上下布局),HORIZONTAL_SPLIT(设置分隔板左右布局) public JSplitPane(int newOrientation,Component newLeftComponent,Component newRightComponent):创建一个具有指定方向和不连续重绘的指定组件的新 JSplitPane。 public JSplitPane(int newOrientation,boolean newContinuousLayout,Component newLeftComponent,Component newRightComponent):创建一个具有指定方向、重绘方式和指定组件的新 JSplitPane。 常用方法 setContinuousLayout(boolean newContinuousLayout):设置是否连续重新显示组件，如果为false就会发现在调整面板的过程中会显示一道黑线，只有当停下的时候才能正常的显示，默认是false setDividerSize(int newSize):设置分割条的大小* setDividerLocation(double size):设置分隔条的位置,这里的size是小数，个人觉得官方文档好像这里有点对劲，相当于占整个面板的百分比 setLeftComponent(Componentcomp)/setTopComponent(Component comp): 将组件设置到分隔条的上面或者左边。 setRightComponent(Component comp)/setBottomComponent(Component comp):将组件设置到分隔条的下面或者右边。 setOneTouchExpandable(boolean newValue):设置 oneTouchExpandable 属性的值，要使 JSplitPane 在分隔条上提供一个 UI 小部件来快速展开/折叠分隔条，此属性必须为 true。 补充说明： 上面只是常用的几个函数，具体的请看官方文档，注意这里的setLeftComponent的四个设置组件的函数要根据分隔板的分布来确定 开始撸代码 初步实现(创建两个按钮实现分隔板的布局)12345678910111213141516171819202122232425262728import java.awt.BorderLayout;import javax.swing.JButton;import javax.swing.JComponent;import javax.swing.JFrame;import javax.swing.JSplitPane;public class Main &#123; public static void main(String[] a) &#123; JFrame horizontalFrame = new JFrame(); horizontalFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JComponent topButton = new JButton("Left"); JComponent bottomButton = new JButton("Right"); final JSplitPane splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT); splitPane.setTopComponent(topButton); splitPane.setBottomComponent(bottomButton); horizontalFrame.add(splitPane, BorderLayout.CENTER); horizontalFrame.setSize(150, 150); horizontalFrame.setVisible(true); splitPane.setDividerLocation(0.5); &#125;&#125; 更进一步(两种布局的操作)123456789101112131415161718192021222324import java.awt.BorderLayout;import javax.swing.JButton;import javax.swing.JComponent;import javax.swing.JFrame;import javax.swing.JSplitPane;public class Main &#123; public static void main(String[] a) &#123; JFrame horizontalFrame = new JFrame(); horizontalFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JComponent leftButton = new JButton("Left"); JComponent rightButton = new JButton("Right"); JSplitPane splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT); splitPane.setLeftComponent(leftButton); splitPane.setRightComponent(rightButton); horizontalFrame.add(splitPane, BorderLayout.CENTER); horizontalFrame.setSize(150, 150); horizontalFrame.setVisible(true); &#125;&#125; 嵌套分隔板12345678910111213141516171819202122232425262728293031323334import javax.swing.JApplet;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JSplitPane;public class Main&#123; public static void main(String[] a) &#123; int HORIZSPLIT = JSplitPane.HORIZONTAL_SPLIT; int VERTSPLIT = JSplitPane.VERTICAL_SPLIT; boolean continuousLayout = true; JLabel label1 = new JLabel("a"); JLabel label2 = new JLabel("b"); JLabel label3 = new JLabel("c"); JSplitPane splitPane1 = new JSplitPane(VERTSPLIT, continuousLayout, label1, label2); splitPane1.setOneTouchExpandable(true); splitPane1.setDividerSize(2); splitPane1.setDividerLocation(0.5); JSplitPane splitPane2 = new JSplitPane(HORIZSPLIT, splitPane1, label3);//将分隔板和一个label放在第二个分割板中实现嵌套 splitPane2.setOneTouchExpandable(true); splitPane2.setDividerLocation(0.4); splitPane2.setDividerSize(2); JFrame frame = new JFrame(); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.add(splitPane2); frame.pack(); frame.setVisible(true); &#125;&#125; 事件监听12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.awt.BorderLayout;import java.beans.PropertyChangeEvent;import java.beans.PropertyChangeListener;// w w w . j a va2s . co mimport javax.swing.JButton;import javax.swing.JComponent;import javax.swing.JFrame;import javax.swing.JSplitPane;public class Main &#123; public static void main(String args[]) &#123; JFrame frame = new JFrame("Property Split"); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JSplitPane splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT); splitPane.setContinuousLayout(true); splitPane.setOneTouchExpandable(true); JComponent topComponent = new JButton("A"); splitPane.setTopComponent(topComponent); JComponent bottomComponent = new JButton("B"); splitPane.setBottomComponent(bottomComponent); PropertyChangeListener propertyChangeListener = new PropertyChangeListener() &#123; public void propertyChange(PropertyChangeEvent changeEvent) &#123; JSplitPane sourceSplitPane = (JSplitPane) changeEvent.getSource(); String propertyName = changeEvent.getPropertyName(); if (propertyName.equals(JSplitPane.LAST_DIVIDER_LOCATION_PROPERTY)) &#123; int current = sourceSplitPane.getDividerLocation(); System.out.println("Current: " + current); Integer last = (Integer) changeEvent.getNewValue(); System.out.println("Last: " + last); Integer priorLast = (Integer) changeEvent.getOldValue(); System.out.println("Prior last: " + priorLast); &#125; &#125; &#125;; splitPane.addPropertyChangeListener(propertyChangeListener); frame.add(splitPane, BorderLayout.CENTER); frame.setSize(300, 150); frame.setVisible(true); &#125;&#125; 说明无论 bean 何时更改 bound 属性，都会激发一个 PropertyChange 事件。可以向源 bean 注册一个 PropertyChangeListener，以便获得所有绑定 (bound) 属性更改的通知。 类 PropertyChangeEvent无论 bean 何时更改 “bound” 或 “constrained” 属性，都会提交一个 “PropertyChange” 事件。PropertyChangeEvent 对象被作为参数发送给 PropertyChangeListener 和 VetoableChangeListener 方法。通常 PropertyChangeEvent 还附带名称和已更改属性的旧值和新值。如果新值是基本类型（比如 int 或 boolean），则必须将它包装为相应的 java.lang.* Object 类型（比如 Integer 或 Boolean）。如果旧值和新值的真实值是未知的，则可能为它们提供 null 值。事件源可能发送一个 null 对象作为名称，以指示其属性的任意事件集已更改。在这种情况下，旧值和新值应该仍然为 null。getSource():返回最初未变化的对象，未Object类型的,因此这里需要强制转换成JSplitPanel 参考文章 官方文档 英文Swing教程 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swing干货系列之JSlider(滑块)]]></title>
      <url>%2F2017%2F03%2F27%2FSwing-%E5%B9%B2%E8%B4%A7%E7%B3%BB%E5%88%97%E4%B9%8BJSlider%2F</url>
      <content type="text"><![CDATA[Swing干货系列之JSlider(滑块)引言 一个让用户以图形方式在有界区间内通过移动滑块来选择值的组件。 滑块可以显示主刻度标记以及主刻度之间的次刻度标记。刻度标记之间的值的个数由 setMajorTickSpacing和 setMinorTickSpacing 来控制。刻度标记的绘制由 setPaintTicks 控制。 滑块也可以在固定时间间隔（或在任意位置）沿滑块刻度打印文本标签。标签的绘制由 setLabelTable 和 setPaintLabels 控制。 构造函数 JSlider():创建一个空值的滑块组件，但是默认的刻度是100，其中如果获得其值的话可以很清楚的看见 JSlider(BoundedRangeModel brm):使用指定的 BoundedRangeModel 创建一个水平滑块 JSlider(int min,int max):创建一个带有最小值和最大值得滑块 JSlider(int min,int max,int value):创建一个带有最小值，最大值和当前值的滑块 常用的方法 getValue(int x)/setValue(int x):得到和设置当前值 getPaintsLabels():return boolean 告知是否绘制了签 SetFont(Font font):设置组件的字体，其中Font类的font对象是参数 setInverted(boolean b):反转滑块的刻度 setMaximum(int maximum) ：设置最大值 setMinimum(int min):设置最小值 setMinorTickSpacing(int n) :设置次刻度，就是主刻度中间不用标记数值的刻度 setMajorTickSpacing(int n):设置主刻度 setPaintTicks(boolean b):确定是否在滑块下面显示刻度线，如果为false表示不显示 setPaintLabels(boolean b):确定是否在刻度线下绘制数值，默认不绘制以上只是列了几个常用的函数，详情见官方文档 下面撸个代码试试身手12345678910111213141516171819202122232425262728293031323334353637383940package com;import javax.swing.*;import javax.swing.event.ChangeEvent;import javax.swing.event.ChangeListener;import java.awt.*;/** * Created by chenjiabing on 2017/3/27. */public class Java_swing extends JFrame &#123; public JSlider points = null; public Java_swing() &#123; super(); setTitle("记事本"); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setSize(300, 400);// points=new JSlider(); points = new JSlider(0, 50, 5); points.setMinorTickSpacing(5);//设置次要的间隔，每个一个间隔，这个显示时中间不标记数值 points.setMajorTickSpacing(10);//显示主要的刻度线，每个两个间隔，这个设置了，如果setPaintLabels为true就会显示数值 points.setPaintTicks(true); //确定是否显示刻度线 points.setPaintLabels(true); //确定是否显示刻度的值 //points.setInverted(true);//指定为true反转刻 度 points.setSnapToTicks(true); points.addChangeListener(new ChangeListener() &#123; @Override public void stateChanged(ChangeEvent e) &#123; int value = points.getValue(); System.out.println(value); &#125; &#125;); getContentPane().add(points, BorderLayout.CENTER); &#125; public static void main(String args[]) &#123; Java_swing my = new Java_swing(); my.setVisible(true); &#125;&#125; Change Listener(一个监听机制)1234567891011121314151617181920212223242526272829303132333435import java.awt.Dimension;/*from w ww . ja v a 2 s .c o m*/import javax.swing.JFrame;import javax.swing.JSlider;import javax.swing.event.ChangeEvent;import javax.swing.event.ChangeListener;public class Main &#123; public static void main(String[] args) &#123; JFrame f = new JFrame(); final JSlider slider = new JSlider(0, 150, 0); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); slider.setPreferredSize(new Dimension(150, 30)); //添加change Listener,当然这里的和JButton的也是一样，可以在一个类中实现 slider.addChangeListener(new ChangeListener() &#123; public void stateChanged(ChangeEvent event) &#123; int value = slider.getValue(); if (value == 0) &#123; System.out.println("0"); &#125; else if (value &gt; 0 &amp;&amp; value &lt;= 30) &#123; System.out.println("value &gt; 0 &amp;&amp; value &lt;= 30"); &#125; else if (value &gt; 30 &amp;&amp; value &lt; 80) &#123; System.out.println("value &gt; 30 &amp;&amp; value &lt; 80"); &#125; else &#123; System.out.println("max"); &#125; &#125; &#125;); f.add(slider); f.pack(); f.setLocationRelativeTo(null); f.setVisible(true); &#125;&#125; 当然以上只是JSlider的一部分内容，还有的后面会陆续更新本文参考的文章： 中文文档 英文文档 福利时间，博主写了一个小例子，想要的朋友可以参见github,不要忘了随手点个赞哦！！！ 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[scrapy设置请求池]]></title>
      <url>%2F2017%2F03%2F26%2Fscrapy%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E6%B1%A0%2F</url>
      <content type="text"><![CDATA[scrapy设置”请求池”引言 相信大家有时候爬虫发出请求的时候会被ban，返回的是403错误，这个就是请求头的问题，其实在python发出请求时，使用的是默认的自己的请求头，网站管理者肯定会不允许机器访问的，但是有些比较low的网站还是可以访问的，有时候网站管理者看到同一个请求头在一秒内请求多次，傻子都知道这是机器在访问，因此会被ban掉，这时就需要设置请求池了，这个和ip代理池是一个概念 爬虫请求常见的错误 200：请求成功 处理方式：获得响应的内容，进行处理201：请求完成，结果是创建了新资源。新创建资源的 URI 可在响应的实体中得到 处理方式：爬虫中不会遇到202：请求被接受，但处理尚未完成 处理方式：阻塞等待204：服务器端已经实现了请求，但是没有返回新的信 息。如果客户是用户代理，则无须为此更新自身的文档视图。 处理方式：丢弃300：该状态码不被 HTTP/1.0 的应用程序直接使用， 只是作为 3XX 类型回应的默认解释。存在多个可用的被请求资源。 处理方式：若程序中能够处理，则进行进一步处理，如果程序中不能处理，则丢弃301：请求到的资源都会分配一个永久的 URL，这样就可以在将来通过该 URL 来访问此资源 处理方式：重定向到分配的 URL302：请求到的资源在一个不同的 URL 处临时保存 处理方式：重定向到临时的 URL304 请求的资源未更新 处理方式：丢弃400 非法请求 处理方式：丢弃401 未授权 处理方式：丢弃403 禁止 处理方式：丢弃404 没有找到 处理方式：丢弃5XX 回应代码以“5”开头的状态码表示服务器端发现自己出现错误，不能继续执行请求 处理方式：丢弃 话不多说直接撸代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from scrapy import logimport randomfrom scrapy.downloadermiddlewares.useragent import UserAgentMiddlewareclass RotateUserAgentMiddleware(UserAgentMiddleware):# for more user agent strings,you can find it in http://www.useragentstring.com/pages/useragentstring.phpuser_agent_list = [ "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 " "(KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1", "Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 " "(KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11", "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 " "(KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6", "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.6 " "(KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6", "Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.1 " "(KHTML, like Gecko) Chrome/19.77.34.5 Safari/537.1", "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 " "(KHTML, like Gecko) Chrome/19.0.1084.9 Safari/536.5", "Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 " "(KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5", "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3", "Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3", "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3", "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3", "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3", "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3", "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3", "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 " "(KHTML, like Gecko) Chrome/19.0.1061.0 Safari/536.3", "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 " "(KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24", "Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 " "(KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24"]def process_request(self, request, spider): ua = random.choice(self.user_agent_list) if ua: # 显示当前使用的useragent print "********Current UserAgent:%s************" % ua # 记录 log.msg('Current UserAgent: ' + ua) request.headers.setdefault('User-Agent', ua) 说明 这里的思路就是在下载器中间件中对request设置请求，这里是使用request.headers.setdefault(&quot;User-Agent&quot;,user_agent)这个函数设置请求头，对于下载器中间件在我博客前面的文章已经有说明，想要了解的请点击 注意 这里还要说明的是设置了请求池还要在配置文件settins中设置一下，具体设置方法和设置代理ip一样，详情请看scrapy代理ip的设置 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Scrapy中使用cookie免于验证登录和模拟登录]]></title>
      <url>%2F2017%2F03%2F26%2FScrapy%E4%B8%AD%E4%BD%BF%E7%94%A8cookie%E5%85%8D%E4%BA%8E%E9%AA%8C%E8%AF%81%E7%99%BB%E5%BD%95%E5%92%8C%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%2F</url>
      <content type="text"><![CDATA[Scrapy中使用cookie免于验证登录和模拟登录引言 python爬虫我认为最困难的问题一个是ip代理，另外一个就是模拟登录了，更操蛋的就是模拟登录了之后还有验证码，真的是不让人省心，不过既然有了反爬虫，那么就有反反爬虫的策略，这里就先介绍一个cookie模拟登陆，后续还有seleminum+phantomjs模拟浏览器登录的文章。还不知道cookie是什么朋友们，可以点击这里 cookie提取方法： 打开谷歌浏览器或者火狐浏览器，如果是谷歌浏览器的按F12这个键就会跳出来浏览器控制台，然后点击Network，之后就是刷新网页开始抓包了，之后在抓到的页面中随便打开一个，就能看到cokie了，但是这里的cookie并不符合python中的格式，因此需要转换格式，下面提供了转换的代码 1234567891011121314151617181920212223# -*- coding: utf-8 -*-class transCookie:def __init__(self, cookie): self.cookie = cookiedef stringToDict(self): ''' 将从浏览器上Copy来的cookie字符串转化为Scrapy能使用的Dict :return: ''' itemDict = &#123;&#125; items = self.cookie.split(';') for item in items: key = item.split('=')[0].replace(' ', '') value = item.split('=')[1] itemDict[key] = value return itemDictif __name__ == "__main__":cookie = "你复制的cookie"trans = transCookie(cookie)print trans.stringToDict() 补充说明： 只需要将你网页上的cookie复制到上述代码中直接运行就可以了 使用cookie操作scrapy 直接撸代码 123456789101112131415161718# -*- coding: utf-8 -*-import scrapyfrom scrapy.conf import settings #从settings文件中导入Cookie，这里也可以室友from scrapy.conf import settings.COOKIEclass DemoSpider(scrapy.Spider):name = "demo"#allowed_domains = ["csdn.com"]start_urls = ["http://write.blog.csdn.net/postlist"]cookie = settings['COOKIE'] # 带着Cookie向网页发请求\headers = &#123; 'Connection': 'keep - alive', # 保持链接状态 'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.82 Safari/537.36'&#125;def start_requests(self): yield scrapy.Request(url=self.start_urls[0],headers=self.headers,cookies=self.cookie)# 这里带着cookie发出请求def parse(self, response): print response.body 说明 这里是scrapy工程目录下spiders目录下的主要的解析网页的py文件相信学过scrapy的应该不会陌生，上述代码中的cookie值是放在Settings文件中的，因此使用的时候需要导入，当然你也可以直接将cookie粘贴到这个文件中 注意 虽说这里使用直接使用cookie可以省去很多麻烦，但是cookie的生命周期特别的短，不过小型的项目足够使用了，向那些需要爬两三天甚至几个月的项目就不适用了，因此在隔一段时间就要重新换cookie的值，虽说有很多麻烦，但是我还是比较喜欢这种方法的，因为可以省去不少脑筋 作者说 本人秉着方便他人的想法才开始写技术文章的，因为对于自学的人来说想要找到系统的学习教程很困难，这一点我深有体会，我也是在不断的摸索中才小有所成，如果你们觉得我写的不错就帮我推广一下，让更多的人看到。另外如果有什么错误的地方也要及时联系我，方便我改进，谢谢大家对我的支持。 最后欢迎大家看看我的其他scrapy文章 scrapy设置代理ip scrapy架构初探 scrapy初试 scrapy下载器中间件 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[scrapy设置代理ip]]></title>
      <url>%2F2017%2F03%2F26%2Fscrapy%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86ip%2F</url>
      <content type="text"><![CDATA[scrapy代理的设置 在我的上一篇文章介绍了scrapy下载器中间件的使用,这里的scrapyIP的代理就是用这个原理实现的，重写了下载器中间件的process_request(self,request,spider)这个函数,这个函数的主要作用就是对request进行处理。 话不多说直接撸代码 123456789101112131415161718192021222324import random import scrapyimport loggingclass proxMiddleware(object):#proxy_list=[&#123;'http': 'http://123.157.146.116:8123'&#125;, &#123;'http': 'http://116.55.16.233:8998'&#125;, &#123;'http': 'http://115.85.233.94:80'&#125;, &#123;'http': 'http://180.76.154.5:8888'&#125;, &#123;'http': 'http://139.213.135.81:80'&#125;, &#123;'http': 'http://124.88.67.14:80'&#125;, &#123;'http': 'http://106.46.136.90:808'&#125;, &#123;'http': 'http://106.46.136.226:808'&#125;, &#123;'http': 'http://124.88.67.21:843'&#125;, &#123;'http': 'http://113.245.84.253:8118'&#125;, &#123;'http': 'http://124.88.67.10:80'&#125;, &#123;'http': 'http://171.38.141.12:8123'&#125;, &#123;'http': 'http://124.88.67.52:843'&#125;, &#123;'http': 'http://106.46.136.237:808'&#125;, &#123;'http': 'http://106.46.136.105:808'&#125;, &#123;'http': 'http://106.46.136.190:808'&#125;, &#123;'http': 'http://106.46.136.186:808'&#125;, &#123;'http': 'http://101.81.120.58:8118'&#125;, &#123;'http': 'http://106.46.136.250:808'&#125;, &#123;'http': 'http://106.46.136.8:808'&#125;, &#123;'http': 'http://111.78.188.157:8998'&#125;, &#123;'http': 'http://106.46.136.139:808'&#125;, &#123;'http': 'http://101.53.101.172:9999'&#125;, &#123;'http': 'http://27.159.125.68:8118'&#125;, &#123;'http': 'http://183.32.88.133:808'&#125;, &#123;'http': 'http://171.38.37.193:8123'&#125;]proxy_list=[ "http://180.76.154.5:8888", "http://14.109.107.1:8998", "http://106.46.136.159:808", "http://175.155.24.107:808", "http://124.88.67.10:80", "http://124.88.67.14:80", "http://58.23.122.79:8118", "http://123.157.146.116:8123", "http://124.88.67.21:843", "http://106.46.136.226:808", "http://101.81.120.58:8118", "http://180.175.145.148:808"]def process_request(self,request,spider): # if not request.meta['proxies']: ip = random.choice(self.proxy_list) print ip #print 'ip=' %ip request.meta['proxy'] = ip 主要的原理： 给出一个代理列表，然后在这个列表中随机取出一个代理，设置在request中，其中request.meta[&#39;proxy&#39;]就是设置代理的格式 但是现在主要的问题就是没有代理ip可用，如果去买的话又太贵了，自己玩玩买代理不值当，所以只好自己写爬虫去爬取免费的代理了，但是免费的代理存活的时间是有限的，这是个非常麻烦的事情，我提供的方法就是实现自己的一个ip代理池，每天定时更新自己的代理池，具体的实现方法会在下一篇文章中介绍，现在提供一段代码用来爬取西刺网站的代理 直接撸代码，接招吧 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#coding:utf-8import requestsfrom bs4 import BeautifulSoupimport threadingimport Queueclass Get_ips():def __init__(self,page): self.ips=[] self.urls=[] for i in range(page): self.urls.append("http://www.xicidaili.com/nn/" + str(i)) self.header = &#123;"User-Agent": 'Mozilla/5.0 (Windows NT 6.3; WOW64; rv:43.0) Gecko/20100101 Firefox/43.0'&#125; #self.file=open("ips",'w') self.q=Queue.Queue() self.Lock=threading.Lock()def get_ips(self): for url in self.urls: res = requests.get(url, headers=self.header) soup = BeautifulSoup(res.text, 'lxml') ips = soup.find_all('tr') for i in range(1, len(ips)): ip = ips[i] tds = ip.find_all("td") ip_temp = "http://" + tds[1].contents[0] + ":" + tds[2].contents[0] # print str(ip_temp) self.q.put(str(ip_temp))def review_ips(self): while not self.q.empty(): ip=self.q.get() try: proxy=&#123;"http": ip&#125; #print proxy res = requests.get("http://www.baidu.com", proxies=proxy,timeout=5) self.Lock.acquire() if res.status_code == 200: self.ips.append(ip) print ip self.Lock.release() except Exception: pass #print 'error'def main(self): self.get_ips() threads=[] for i in range(40): threads.append(threading.Thread(target=self.review_ips,args=[])) for t in threads: t.start() for t in threads: t.join() return self.ipsdef get_ip():my=Get_ips(4)return my.main()get_ip() 实现的原理 这里用到了BeautifulSoup解析页面，然后将提取到的代理交给队列，然后再通过共享队列分配给线程，这里主要开启线程通过设置代理ip访问一个网站，因为访问网站的时间比较长，因此要开起多个线程，相信大家能够学习设置代理ip了应该都是比较上手的了，这里具体的代码就不一一解释了，如果代码有什么问题可以及时联系我，我的联系方式在关于我的一栏中有提到 补充 想要ip应用起来，还要在配置文件settings中添加DOWNLOADER_MIDDLEWARES = { &#39;demo.proxy.proxMiddleware&#39;:400 }这里的demo是工程的名字，proxy是py文件的名,proxMiddleware是类的名字 当然这里可能你觉得proxy_list写在这里有点冗余，你可以在配置文件中定义，然后将配置文件的内容import到py文件中 以上全是博主慢慢摸索出来的，可以说自学一门技术真的很难，学习python爬虫已经有两三个月了，可以说全是自己通过看项目，网上查资料才有了今天的成功，不过现在还有几个问题没有解决，就是分布式爬虫、移动端爬取，博主接下来就要主攻这两个方面，学好之后会在自己的博客上分享学习心得的，因为网上没有系统的学习教程，对于自学的人来说实在是太痛苦了 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[scrapy的下载器中间件]]></title>
      <url>%2F2017%2F03%2F25%2Fscrapy%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%99%A8%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[scrapy中的下载器中间件下载中间件 下载器中间件是介于Scrapy的request/response处理的钩子框架。 是用于全局修改Scrapy request和response的一个轻量、底层的系统。 编写下载器中间件 1. process_request(request, spider)当每个request通过下载中间件时，该方法被调用。process_request() 必须返回其中之一: 返回 None 、返回一个 Response 对象、返回一个 Request对象或raise IgnoreRequest 。 如果其返回 None ，Scrapy将继续处理该request，执行其他的中间件的相应方法，直到合适的下载器处理函数(download handler)被调用， 该request被执行(其response被下载)。 如果其返回 Response 对象，Scrapy将不会调用 任何 其他的 process_request() 或 process_exception() 方法，或相应地下载函数； 其将返回该response。 已安装的中间件的 process_response() 方法则会在每个response返回时被调用。 如果其返回 Request 对象，Scrapy则停止调用 process_request方法并重新调度返回的request。当新返回的request被执行后， 相应地中间件链将会根据下载的response被调用。 如果其raise一个 IgnoreRequest 异常，则安装的下载中间件的 process_exception() 方法会被调用。如果没有任何一个方法处理该异常， 则request的errback(Request.errback)方法会被调用。如果没有代码处理抛出的异常， 则该异常被忽略且不记录(不同于其他异常那样)。 参数: request (Request 对象) – 处理的request spider (Spider 对象) – 该request对应的spider 2. process_response(request, response, spider) process_response() 必须返回以下之一: 返回一个 Response对象、 返回一个Request 对象或raise一个 IgnoreRequest 异常。 如果其返回一个 Response (可以与传入的response相同，也可以是全新的对象)， 该response会被在链中的其他中间件的 process_response() 方法处理。 如果其返回一个 Request 对象，则中间件链停止， 返回的request会被重新调度下载。处理类似于 process_request() 返回request所做的那样。 如果其抛出一个 IgnoreRequest 异常，则调用request的errback(Request.errback)。 如果没有代码处理抛出的异常，则该异常被忽略且不记录(不同于其他异常那样)。 参数: request (Request对象) – response所对应的request response (Response 对象) – 被处理的response spider (Spider 对象) – response所对应的spider 3.process_exception(request, exception, spider) 当下载处理器(download handler)或 process_request() (下载中间件)抛出异常(包括 IgnoreRequest 异常)时， Scrapy调用 process_exception() 。 process_exception() 应该返回以下之一: 返回 None 、 一个 Response 对象、或者一个 Request 对象。 如果其返回 None ，Scrapy将会继续处理该异常，接着调用已安装的其他中间件的 process_exception() 方法，直到所有中间件都被调用完毕，则调用默认的异常处理。 如果其返回一个 Response 对象，则已安装的中间件链的 process_response() 方法被调用。Scrapy将不会调用任何其他中间件的 process_exception() 方法。 如果其返回一个 Request 对象， 则返回的request将会被重新调用下载。这将停止中间件的 process_exception() 方法执行，就如返回一个response的那样。 参数: request (是 Request 对象) – 产生异常的request exception (Exception 对象) – 抛出的异常 spider (Spider 对象) – request对应的spider 总结： 总的来说下载器中间件就是起到处理request请求并且返回response的作用，一切从网页爬取的url发起的请求会组成一个请求队列，然后一个一个排队经过下载器中间件，之后下载器中间件会对request做出相应的处理，比如添加请求头，添加代理等等，然后通过process_response返回一个response，之后就是用得到的response做出相应的分析，当然这里的内容页可以不实现，但是如果要爬取大型的网站，会遇到被ban的可能就要在下载器中间件这里着手，设置一些相应的请求头，ip代理等等内容。以上纯属个人逐渐摸索总结出来的内容，如果有什么错误欢迎指正 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[scrapy初试]]></title>
      <url>%2F2017%2F03%2F25%2Fscrapy%E5%88%9D%E8%AF%95%2F</url>
      <content type="text"><![CDATA[scrapy初试 创建项目 打开cmd，在终端输入scrapy startproject tutorial,这里将在指定的文件夹下创建一个scrapy工程 其中将会创建以下的文件： scrapy.cfg: 项目的配置文件 tutorial/: 该项目的python模块。之后您将在此加入代码。 tutorial/items.py: 项目中的item文件. tutorial/pipelines.py: 项目中的pipelines文件. tutorial/settings.py: 项目的设置文件. tutorial/spiders/: 放置spider代码的目录. 定义item Item是保存爬取到的数据的容器；其使用方法和python字典类似， 并且提供了额外保护机制来避免拼写错误导致的未定义字段错误。 类似在ORM中做的一样，您可以通过创建一个 scrapy.Item 类， 并且定义类型为 scrapy.Field的类属性来定义一个Item。 (如果不了解ORM, 不用担心，您会发现这个步骤非常简单) 首先根据需要从dmoz.org获取到的数据对item进行建模。 我们需要从dmoz中获取名字，url，以及网站的描述。 对此，在item中定义相应的字段。编辑 tutorial 目录中的 items.py 文件: 12345import scrapyclass DmozItem(scrapy.Item):title = scrapy.Field()link = scrapy.Field()desc = scrapy.Field() 一开始这看起来可能有点复杂，但是通过定义item， 您可以很方便的使用Scrapy的其他方法。而这些方法需要知道您的item的定义. 编写第一个爬虫 在工程的根目录下打开终端输入scrapy genspider demo douban.com这里的demo是spders文件下的主要py文件douban.com是要爬取的域名，会在demo.py中的 allowed_domains中显示，主要的功能就是限制爬取的url spider代码中内容解析 name: 用于区别Spider。 该名字必须是唯一的，您不可以为不同的Spider设定相同的名字。 start_urls: 包含了Spider在启动时进行爬取的url列表。 因此，第一个被获取到的页面将是其中之一。 后续的URL则从初始的URL获取到的数据中提取。 parse() 是spider的一个方法。 被调用时，每个初始URL完成下载后生成的 Response 对象将会作为唯一的参数传递给该函数。 该方法负责解析返回的数据(response data)，提取数据(生成item)以及生成需要进一步处理的URL的 Request对象。 以下是spider目录下的demo.py的代码 1234567891011121314import scrapyclass DmozSpider(scrapy.Spider):name = "dmoz"allowed_domains = ["dmoz.org"]start_urls = [ "http://www.dmoz.org/Computers/Programming/Languages/Python/Books/", "http://www.dmoz.org/Computers/Programming/Languages/Python/Resources/"]def parse(self, response): filename = response.url.split("/")[-2] with open(filename, 'wb') as f: f.write(response.body) spider的爬取 进入工程的根目录下打开终端输入：scrapy crawl dmoz spider中的数据存取 在工程的根目录下打开终端输入scrapy crawl dmoz -o items.json这里是将数据存储到json文件中]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java中的IO操作]]></title>
      <url>%2F2017%2F03%2F25%2Fjava%E4%B8%AD%E7%9A%84IO%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[java中IO操作读取文件中的内容 使用Scanner读取文本中的内容 相信大家都知道Scanner console=new Scanner(System.in)是用来读取控制台上输入的内容，但是这里是用来读取文件的内容，原理是一样的，只是对象不同罢了，这里用到的是File对象，用来创建一个文件对象 123456Scanner input=new Scanner(new File("hello.txt"));//创建一个对象inputwhile(input.hasNextLine()) //这里用来判断是否还有内容， 以免读到最后发生错误&#123;String content=input.nextLine();System.out.println(content);&#125; 这里顺便补充一下Scannner中的几个函数： nextLine():读取一行的内容，包括空格，换行 nextInt():读取一个整型内容 nexDouble():读取一个双精度的浮点数 next():读取下一个内容，无论什么类型，其中遇到空格和换行默认是一个标记（即是跳过）和nextLine()类似 hasNext():用来判断文件中的还有下一个内容，无论什么类型的 hasNextInt() hasNextDouble()://相似，不在赘述 使用FileReader读取 用来读取字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的。要自己指定这些值，可以先在 FileInputStream上构造一个 InputStreamReader。FileReader 用于读取字符流。要读取原始字节流，请考虑使用 FileInputStream。 //这里使用new File创建一个对象，同样的也可以直接将文件的绝对路径传入 FileReader file=new FileReader(new File(&quot;hello.txt&quot;)); while(file.ready()) //用来判断是否还有字符可读 { int content=file.read(); //这里的read是读取将单个字符 返回的是int，即是ascii码,这里官方文档说返回的是读取的字符数，但是我实验了一下返回的ascii码 System.out.println((char)content); //所以要将ascii码转换成字符 } file.close(); 常用的几个方法： read(): return int 上面介绍过 read(char[] cbuf,int int length):将内容读入到一个char类型的数组，length是读取的字符数，offest是偏移量 使用BufferedReader的类实现高效的读取文件 123456//传入一个reader创建一个对象 BufferedReader file= new BufferedReader(new FileReader("hello.txt")); System.out.println(file.skip(3));//实现将指针跳过3个字符 System.out.println((char)file.read()); //read的方法，和FileReader中的read一样 String line=file.readLine(); //读取一行 System.out.println(line); 常用的方法： readLine() read()：如果到了末尾返回-1 read(char [],int off,int length):和FileReader中的一样 ready():判断是否还可以读取，一般和read配对使用 skip(long n):跳过的字符数 close() 文件的写入 用FileWriter写入文件 12345/*创建将对象f传入FileWriter,其中Filewriter有两个参数，第一个是File对象后者是一个String(即是文件的路径），第二个参数是boolean类型的，表示是否在文件的末尾追加内容，默认的是false表示不用在末尾追加，如果想要在末尾追加要写入另外一个参数true,当然这里可以用更加简洁的方式创建：FileWriter file=new FileWriter("hello.txt",false);*/FileWriter file=new FileWriter(f,true);file.write("chenjiabing");//写入函数writefile.close(); //最后必须关闭文件的输入流，否则写入将会失败，这里不想c和c++ 其中Filewriter中的方法还有 flush：刷新缓存流 close append():当前的领会的就是写入数组:append(Arrays.toString(list)); getEncoding():返回此流使用的字符编码 用PrintStream写入文件 这里同样的是和System.out.println()一样的原理，System.out.println只是内部实现了PrintStream，这里是用来将指定的内容写入到文件中而已 12345PrintStream output=new PrintStream(new File("hello.txt"));//创建一个写入的对象outputoutput.print("flan");output.println("vmlkfamla");output.println("vmslfkmadvmfs;dm"); 这里是用BufferedWriter类写入文件(一个高效的写入方式) 简单介绍 将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。可以指定缓冲区的大小，或者接受默认的大小。在大多数情况下，默认值就足够大了。该类提供了 newLine() 方法，它使用平台自己的行分隔符概念，此概念由系统属性 line.separator 定义。并非所有平台都使用新行符 (‘\n’) 来终止各行。因此调用此方法来终止每个输出行要优于直接写入新行符。通常 Writer 将其输出立即发送到底层字符或字节流。除非要求提示输出，否则建议用 BufferedWriter 包装所有其 write() 操作可能开销很高的 Writer（如 FileWriters 和 OutputStreamWriters）。例如， PrintWriter out= new PrintWriter(new BufferedWriter(new FileWriter(&quot;foo.out&quot;))); 将缓冲 PrintWriter对文件的输出。如果没有缓冲，则每次调用 print() 方法会导致将字符转换为字节，然后立即入到文件，而这是极其低效的。 例子 12345BufferedWriter input=new BufferedWriter(new FileWriter("hello.txt")); input.write("这是一个文件读入的方法"); input.newLine(); input.write("一个高效的方法"); input.close(); 其他的方法 close() flush() newLine():写入一个换行，因为每一个操作系统上的换行符可能不一样，不能系统的都用”\n”表示 write() 详情参见API 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[scrapy架构初探]]></title>
      <url>%2F2017%2F03%2F25%2Fscrapy%E6%9E%B6%E6%9E%84%E5%88%9D%E6%8E%A2%2F</url>
      <content type="text"><![CDATA[scrapy架构初探引言 Python即时网络爬虫启动的目标是一起把互联网变成大数据库。单纯的开放源代码并不是开源的全部，开源的核心是“开放的思想”，聚合最好的想法、技术、人员，所以将会参照众多领先产品，比如，Scrapy，ScrapingHub，import io等。 本文简单讲解一下Scrapy的架构。没错，通用提取器gsExtractor就是要集成到Scrapy架构中。 请注意，本文不想复述原文内容，而是为了开源Python爬虫的发展方向找参照，而且以9年来开发网络爬虫经验作为对标，从而本文含有不少笔者主观评述，如果想读Scrapy官方原文，请点击Scrapy官网的Architecture。 scrapy数据流 Scrapy中的数据流由执行引擎控制，下面的原文摘自Scrapy官网，我根据猜测做了点评，为进一步开发GooSeeker开源爬虫指示方向： The Engine gets the first URLs to crawl from the Spider and schedules them in the Scheduler, as Requests. URL谁来准备呢？看样子是Spider自己来准备，那么可以猜测Scrapy架构部分（不包括Spider）主要做事件调度，不管网址的存储。看起来类似GooSeeker会员中心的爬虫罗盘，为目标网站准备一批网址，放在罗盘中准备执行爬虫调度操作。所以，这个开源项目的下一个目标是把URL的管理放在一个集中的调度库里面。 The Engine asks the Scheduler for the next URLs to crawl. 看到这里其实挺难理解的，要看一些其他文档才能理解透。接第1点，引擎从Spider中把网址拿到以后，封装成一个Request，交给了事件循环，会被Scheduler收来做调度管理的，暂且理解成对Request做排队。引擎现在就找Scheduler要接下来要下载的网页地址。 The Scheduler returns the next URLs to crawl to the Engine and the Engine sends them to the Downloader, passing through the Downloader Middleware (request direction). 从调度器申请任务，把申请到的任务交给下载器，在下载器和引擎之间有个下载器中间件，这是作为一个开发框架的必备亮点，开发者可以在这里进行一些定制化扩展。 Once the page finishes downloading the Downloader generates a Response (with that page) and sends it to the Engine, passing through the Downloader Middleware (response direction). 下载完成了，产生一个Response，通过下载器中间件交给引擎。注意，Response和前面的Request的首字母都是大写，虽然我还没有看其它Scrapy文档，但是我猜测这是Scrapy框架内部的事件对象，也可以推测出是一个异步的事件驱动的引擎，就像DS打数机的三级事件循环一样，对于高性能、低开销引擎来说，这是必须的。 The Engine receives the Response from the Downloader and sends it to the Spider for processing, passing through the Spider Middleware (input direction). 再次出现一个中间件，给开发者足够的发挥空间。 The Spider processes the Response and returns scraped items and new Requests (to follow) to the Engine. 每个Spider顺序抓取一个个网页，完成一个就构造另一个Request事件，开始另一个网页的抓取。 The Engine passes scraped items and new Requests returned by a spider through Spider Middleware (output direction), and then sends processed items to Item Pipelines and processed Requests to the Scheduler. 引擎作事件分发 The process repeats (from step 1) until there are no more requests from the Scheduler. 持续不断地运行。 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java图形与文本处理一]]></title>
      <url>%2F2017%2F03%2F25%2Fjava%E5%9B%BE%E5%BD%A2%E4%B8%8E%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%80%2F</url>
      <content type="text"><![CDATA[java绘制图形和文本&lt;一&gt;开篇介绍(官方文档) java.awt类 Graphicsjava.lang.Object继承者 java.awt.Graphics直接已知子类：DebugGraphics, Graphics2Dpublic abstract class Graphics extends Object Graphics 类是所有图形上下文的抽象基类，允许应用程序在组件（已经在各种设备上实现）以及闭屏图像上进行绘制。Graphics 对象封装了 Java 支持的基本呈现操作所需的状态信息。此状态信息包括以下属性：要在其上绘制的 Component 对象。呈现和剪贴坐标的转换原点。当前剪贴区。当前颜色。当前字体。当前逻辑像素操作函数（XOR 或 Paint）。当前 XOR 交替颜色（参见 setXORMode(java.awt.Color)）。坐标是无限细分的，并且位于输出设备的像素之间。绘制图形轮廓的操作是通过使用像素大小的画笔遍历像素间无限细分路径的操作，画笔从路径上的锚点向下和向右绘制。填充图形的操作是填充图形内部区域无限细分路径操作。呈现水平文本的操作是呈现字符字形完全位于基线坐标之上的上升部分。图形画笔从要遍历的路径向下和向右绘制。其含义如下：如果绘制一个覆盖给定矩形的图形，那么该图形与填充被相同矩形所限定的图形相比，在右侧和底边多占用一行像素。如果沿着与一行文本基线相同的 y 坐标绘制一条水平线，那么除了文字的所有下降部分外，该线完全画在文本的下面。所有作为此 Graphics 对象方法的参数而出现的坐标，都是相对于调用该方法前的此 Graphics 对象转换原点的。所有呈现操作仅修改当前剪贴区所限定区域内的像素，此剪贴区是由用户空间中的 Shape 指定的，并通过使用 Graphics 对象的程序来控制。此用户剪贴区 被转换到设备空间中，并与设备剪贴区 组合，后者是通过窗口可见性和设备范围定义的。用户剪贴区和设备剪贴区的组合定义复合剪贴区，复合剪贴区确定最终的剪贴区域。用户剪贴区不能由呈现系统修改，以反映得到的复合剪贴区。用户剪贴区只能通过 setClip 或 clipRect 方法更改。所有的绘制或写入都以当前的颜色、当前绘图模式和当前字体完成。 绘制直线主要用到的内容是Graphics类中的drawLine函数定义： public abstract void drawLine(int x1,int y1,int x2,int y2)x1,y1是起始点的坐标，x2,y2是尾点的坐标 拓展 SetColor(Color color) setColor是Graphics类中的一个函数，主要是设置颜色作用，其中参数是Color类中的一个对象，用于定义自己的颜色，里面的变量的是RGB,定义的方法：Color color=newe Color(R,G,B) 代码 123456789101112131415161718192021222324252627282930 import java.awt.Graphics; import javax.swing.JFrame; import javax.swing.JPanel; public class DrawLineFrame extends JFrame &#123; DrawLinePanel linePanel = new DrawLinePanel(); public static void main(String args[]) &#123; // 主函数 DrawLineFrame frame = new DrawLineFrame(); // 创建一个继承JFrame的一个类对象 frame.setVisible(true); // 设置窗体可见，true为可见，false为不可见 &#125; public DrawLineFrame() &#123; super(); setTitle("绘制直线"); // 设置窗体的标题 setBounds(100, 100, 273, 167); // 设置窗体的显示位置和大小 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置窗体的关闭方式，具体见官方文档 add(linePanel); // 将继承Jpanel类的容器对象添加在窗体中 &#125; class DrawLinePanel extends JPanel &#123; // 继承在JPanel类的一个内部类，用于定义直线 public void paint(Graphics g) &#123; // 重写JCommponent类中的paint方法，用来绘制直线 Color color=new Color(Color.Red);//这里用的是Color提供的颜色，当然读者也可以自己定义RGB颜色 g.setColor(Color);//将颜色作用于绘图上下文 g.drawLine(70, 50, 180, 50); // 调用方法 g.drawLine(70, 80, 180, 80); // 第二条直线 g.drawLine(110, 10, 140, 120); // 第三条 &#125; &#125;&#125; 绘制矩形主要用到的函数是：public abstract void drawRect(int x,int y,int width,int height)这里的x,y是矩形左上角的坐标，width，height是矩形的长和宽 拓展fillRect(int x,int y,int width,int height):绘制实心矩形 代码 1234567891011121314151617181920212223242526import java.awt.Graphics;import javax.swing.JFrame;import javax.swing.JPanel;public class DrawRectangleFrame extends JFrame &#123;DrawRectanglePanel rectPanel = new DrawRectanglePanel(); // 创建面板类的实例public static void main(String args[]) &#123; // 主方法 DrawRectangleFrame frame = new DrawRectangleFrame(); // 创建窗体类的实例 frame.setVisible(true); // 显示窗体&#125;public DrawRectangleFrame() &#123; super(); // 调用超类的构造方法 setTitle("绘制矩形"); // 窗体标题 setBounds(100, 100, 269, 184); // 窗体的显示位置和大小 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 窗体关闭方式 add(rectPanel); // 将面板类的实例添加到窗体容器中&#125;class DrawRectanglePanel extends JPanel &#123; // 创建内部面板类 public void paint(Graphics g) &#123; // 重写paint()方法 g.drawRect(30, 40, 80, 60); // 绘制空心矩形 g.fillRect(140, 40, 80, 60); // 绘制实心矩形 &#125;&#125;&#125; 绘制椭圆 函数：public abstract void drawOval(int x,int y,int width,int height),其中x,y是外切矩形的左上角的坐标，width，height是长宽 拓展 其中将令width=height，即是一个圆了，fillOval(int x,int y,int width,int height)用来绘制实心的椭圆 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 package com.zzk; import java.awt.Graphics; import javax.swing.JFrame; import javax.swing.JPanel; public class DrawEllipseFrame extends JFrame &#123; DrawEllipsePanel ellipsePanel = new DrawEllipsePanel(); // 创建面板类的实例 public static void main(String args[]) &#123; // 主方法 DrawEllipseFrame frame = new DrawEllipseFrame(); // 创建窗体类的实例 frame.setVisible(true); // 显示窗体 &#125; public DrawEllipseFrame() &#123; super(); // 调用超类的构造方法 setTitle("绘制椭圆"); // 窗体标题 setBounds(100, 100, 269, 222); // 窗体的显示位置和大小 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 窗体关闭方式 add(ellipsePanel); // 将面板类的实例添加到窗体容器中 &#125; class DrawEllipsePanel extends JPanel &#123; // 创建内部面板类 public void paint(Graphics g) &#123; // 重写paint()方法 g.drawOval(30, 20, 80, 50); // 绘制空心椭圆 g.drawOval(150, 10, 50, 80); // 绘制空心椭圆 g.fillOval(40, 90, 50, 80); // 绘制实心椭圆 g.fillOval(140, 110, 80, 50); // 绘制实心椭圆 &#125; &#125; &#125; ``` &gt;&gt;## 绘制圆弧&gt;&gt;&gt;主要用到的函数`public astract void drawArc(int x,int y,int width,int height,int startAngle,int arcAngle)`，其中x,y是要绘制圆弧的左上角的坐标，width，height是要绘制的长宽，startAngle是开始角度，arcAngle是相对于开始角度而言的，弧跨越的角度，&gt;&gt;&gt;&gt;### 拓展:&gt;&gt;&gt;&gt;&gt;fillArc(int x,int y,int width,int height,int startAngle,int arcAngle)用来绘制实心圆弧&gt;&gt;&gt;&gt;&gt;当然你也可以用这个来绘制扇形，用drawLine方法将圆弧的两端连起来就可以了，不过这个对坐标的精确度就要求很高了，暂时不想费那个脑筋来搞了&gt;&gt;&gt;&gt;### 代码```java package com.zzk; import java.awt.Graphics; import javax.swing.JFrame; import javax.swing.JPanel; public class DrawArcFrame extends JFrame &#123; DrawArcPanel arcPanel = new DrawArcPanel(); // 创建面板类的实例 public static void main(String args[]) &#123; // 主方法 DrawArcFrame frame = new DrawArcFrame(); // 创建窗体类的实例 frame.setVisible(true); // 显示窗体 &#125; public DrawArcFrame() &#123; super(); // 调用超类的构造方法 setTitle("绘制圆弧"); // 窗体标题 setBounds(100, 100, 269, 184); // 窗体的显示位置和大小 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 窗体关闭方式 add(arcPanel); // 将面板类的实例添加到窗体容器中 &#125; class DrawArcPanel extends JPanel &#123; // 创建内部面板类 public void paint(Graphics g) &#123; // 重写paint()方法 g.drawArc(20, 20, 80, 80, 0, 120); // 绘制圆弧 g.drawArc(20, 40, 80, 80, 0, -120); // 绘制圆弧 g.drawArc(150, 20, 80, 80, 180, -120);// 绘制圆弧 g.drawArc(150, 40, 80, 80, 180, 120); // 绘制圆弧 &#125; &#125; &#125; 绘制多边形 主要用到的函数是：public abstract void drawPolygon(int[] xpoints,int[] ypoints,int npoints)，其中xpoints：要绘制多边形的x坐标组，ypoints是要绘制多边形的y坐标组，npoints是多边形的n条边 拓展 fillPolygon(...)是绘制实心多边形的函数 代码 1234567891011121314151617181920212223242526package com.zzk;import java.awt.Graphics;import javax.swing.JFrame;import javax.swing.JPanel;public class DrawSectorFrame extends JFrame &#123;DrawSectorPanel sectorPanel = new DrawSectorPanel(); // 创建面板类的实例public static void main(String args[]) &#123; // 主方法 DrawSectorFrame frame = new DrawSectorFrame(); // 创建窗体类的实例 frame.setVisible(true); // 显示窗体&#125;public DrawSectorFrame() &#123; super(); // 调用超类的构造方法 setTitle("绘制填充扇形"); // 窗体标题 setBounds(100, 100, 278, 184); // 窗体的显示位置和大小 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 窗体关闭方式 add(sectorPanel); // 将面板类的实例添加到窗体容器中&#125;class DrawSectorPanel extends JPanel &#123; // 创建内部面板类 public void paint(Graphics g) &#123; // 重写paint()方法 g.fillArc(40, 20, 80, 80, 0, 150); // 绘制填充扇形 g.fillArc(140, 20, 80, 80, 180, -150);// 绘制填充扇形 g.fillArc(40, 40, 80, 80, 0, -110); // 绘制填充扇形 g.fillArc(140, 40, 80, 80, 180, 110); // 绘制填充扇形 &#125;&#125;&#125; 绘制文本 主要用到的函数是：public abstract void drawString(String value,int x,int y),其中value是要绘制的文本，x,y是第一个字的坐标 拓展 SetFont(Font font):这个函数是用来设置文本的字体大小，颜色的，其中参数font是Font类中的 代码 12345678910111213141516171819202122232425262728293031323334353637package com.zzk;import java.awt.Font;import java.awt.Graphics;import javax.swing.JFrame;import javax.swing.JPanel;public class TextFontFrame extends JFrame &#123;ChangeTextFontPanel changeTextFontPanel = new ChangeTextFontPanel(); // 创建面板类的实例public static void main(String args[]) &#123; // 主方法 TextFontFrame frame = new TextFontFrame(); // 创建窗体类的实例 frame.setVisible(true); // 显示窗体&#125;public TextFontFrame() &#123; super(); // 调用超类的构造方法 setTitle("设置文本的字体"); // 窗体标题 setBounds(100, 100, 333, 199); // 窗体的显示位置和大小 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 窗体关闭方式 add(changeTextFontPanel); // 将面板类的实例添加到窗体容器中&#125;class ChangeTextFontPanel extends JPanel &#123; // 创建内部面板类 public void paint(Graphics g) &#123; // 重写paint()方法 String value = "明日编程词典社区"; int x = 40; // 文本位置的横坐标 int y = 50; // 文本位置的纵坐标 Font font = new Font("华文行楷", Font.BOLD + Font.ITALIC, 26); // 创建字体对象 g.setFont(font); // 设置字体 g.drawString(value, x, y); // 绘制文本 value = "http://community.mrbccd.com"; x = 10; // 文本位置的横坐标 y = 100; // 文本位置的纵坐标 font = new Font("宋体", Font.BOLD, 20); // 创建字体对象 g.setFont(font); // 设置字体 g.drawString(value, x, y); // 绘制文本 &#125;&#125;&#125; 补充 字体样式包括Font.BLOD(粗体)，Font.ITALIC(斜体)，Font.PLAIN(普通字体)，其中如果要设置两种样式，可以用”+”连接，如：Font.BLOD+Font.ITALIC，这样就会同时设置了斜体和粗体样式 以上是本人的学习成果，通过不断的学习和探索，发现网上没有什么系统的学习java图形处理的文章，就下定决心准备好好写，于是前几天就花了一晚上的时间搭建了博客，以前都是在CSDN上写的，发现在那上面写，没有逼格，为了提高逼格，自己撸了一个博客，让我来自由发挥，另外喜欢编程的朋友可以加我的联系方式，我们可以一起探讨，在下面留言也是可以的哦,联系方式可以在我的关于我可以找到 版权信息所有者：chenjiabing如若转载请标明出处：chenjiabing666.github.io6]]></content>
    </entry>

    
  
  
</search>
